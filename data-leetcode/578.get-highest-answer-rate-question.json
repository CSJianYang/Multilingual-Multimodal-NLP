[
    {
        "title": "Subsets",
        "question_content": "Given an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\nExample 2:\n\nInput: nums = [0]\nOutput: [[],[0]]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 10\n\t-10 <= nums[i] <= 10\n\tAll the numbers of&nbsp;nums are unique.",
        "solutions": [
            {
                "id": 27281,
                "title": "a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning",
                "content": "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. \\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n\\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. \\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n\\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/",
                "codeTag": "Unknown"
            },
            {
                "id": 27278,
                "title": "c-recursive-iterative-bit-manipulation",
                "content": "**Recursive (Backtracking)**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs;\\n        vector<int> sub;\\n        subsets(nums, 0, sub, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, int i, vector<int>& sub, vector<vector<int>>& subs) {\\n        subs.push_back(sub);\\n        for (int j = i; j < nums.size(); j++) {\\n            sub.push_back(nums[j]);\\n            subsets(nums, j + 1, sub, subs);\\n            sub.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n**Iterative**\\n\\nUsing `[1, 2, 3]` as an example, the iterative process is like:\\n\\n 1. Initially, one empty subset `[[]]`\\n 2. Adding `1` to `[]`: `[[], [1]]`;\\n 3. Adding `2` to `[]` and `[1]`: `[[], [1], [2], [1, 2]]`;\\n 4. Adding `3` to `[]`, `[1]`, `[2]` and `[1, 2]`: `[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs = {{}};\\n        for (int num : nums) {\\n            int n = subs.size();\\n            for (int i = 0; i < n; i++) {\\n                subs.push_back(subs[i]); \\n                subs.back().push_back(num);\\n            }\\n        }\\n        return subs;\\n    }\\n}; \\n```\\n\\n**Bit Manipulation**\\n\\nTo give all the possible subsets, we just need to exhaust all the possible combinations of the numbers. And each number has only two possibilities: either in or not in a subset. And this can be represented using a bit.\\n\\nUsing `[1, 2, 3]` as an example, `1` appears once in every two consecutive subsets, `2` appears twice in every four consecutive subsets, and `3` appears four times in every eight subsets (initially all subsets are empty):\\n\\n```\\n[], [ ], [ ], [    ], [ ], [    ], [    ], [       ]\\n[], [1], [ ], [1   ], [ ], [1   ], [    ], [1      ]\\n[], [1], [2], [1, 2], [ ], [1   ], [2   ], [1, 2   ]\\n[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]\\n```\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size(), p = 1 << n;\\n        vector<vector<int>> subs(p);\\n        for (int i = 0; i < p; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if ((i >> j) & 1) {\\n                    subs[i].push_back(nums[j]);\\n                }\\n            }\\n        }\\n        return subs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs;\\n        vector<int> sub;\\n        subsets(nums, 0, sub, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, int i, vector<int>& sub, vector<vector<int>>& subs) {\\n        subs.push_back(sub);\\n        for (int j = i; j < nums.size(); j++) {\\n            sub.push_back(nums[j]);\\n            subsets(nums, j + 1, sub, subs);\\n            sub.pop_back();\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs = {{}};\\n        for (int num : nums) {\\n            int n = subs.size();\\n            for (int i = 0; i < n; i++) {\\n                subs.push_back(subs[i]); \\n                subs.back().push_back(num);\\n            }\\n        }\\n        return subs;\\n    }\\n}; \\n```\n```\\n[], [ ], [ ], [    ], [ ], [    ], [    ], [       ]\\n[], [1], [ ], [1   ], [ ], [1   ], [    ], [1      ]\\n[], [1], [2], [1, 2], [ ], [1   ], [2   ], [1, 2   ]\\n[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size(), p = 1 << n;\\n        vector<vector<int>> subs(p);\\n        for (int i = 0; i < p; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if ((i >> j) & 1) {\\n                    subs[i].push_back(nums[j]);\\n                }\\n            }\\n        }\\n        return subs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 122645,
                "title": "3ms-easiest-solution-no-backtracking-no-bit-manipulation-no-dfs-no-bullshit",
                "content": "While iterating through all numbers, for each new number, we can either pick it or not pick it\\n1, if pick, just add current number to every existing subset.\\n2, if not pick, just leave all existing subsets as they are.\\nWe just combine both into our result.\\n\\nFor example, {1,2,3} intially we have an emtpy set as result [ [ ] ]\\nConsidering 1, if not use it, still [ ], if use 1, add it to [ ], so we have [1] now\\nCombine them, now we have [ [ ], [1] ] as all possible subset\\n\\nNext considering 2, if not use it, we still have [ [ ], [1] ], if use 2, just add 2 to each previous subset, we have [2], [1,2]\\nCombine them, now we have [ [ ], [1], [2], [1,2] ]\\n\\nNext considering 3, if not use it, we still have  [ [ ], [1], [2], [1,2] ], if use 3, just add 3 to each previous subset, we have [ [3], [1,3], [2,3], [1,2,3] ]\\nCombine them, now we have  [ [ ], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3] ]\\n\\n```\\npublic List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>());\\n        for(int n : nums){\\n            int size = result.size();\\n            for(int i=0; i<size; i++){\\n                List<Integer> subset = new ArrayList<>(result.get(i));\\n                subset.add(n);\\n                result.add(subset);\\n            }\\n        }\\n        return result;\\n    }\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>());\\n        for(int n : nums){\\n            int size = result.size();\\n            for(int i=0; i<size; i++){\\n                List<Integer> subset = new ArrayList<>(result.get(i));\\n                subset.add(n);\\n                result.add(subset);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27301,
                "title": "python-easy-to-understand-solutions-dfs-recursively-bit-manipulation-iteratively",
                "content": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        ret = []\\n        self.dfs(nums, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, path, ret):\\n        ret.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], path+[nums[i]], ret)\\n       \\n    # Bit Manipulation    \\n    def subsets2(self, nums):\\n        res = []\\n        nums.sort()\\n        for i in xrange(1<<len(nums)):\\n            tmp = []\\n            for j in xrange(len(nums)):\\n                if i & 1 << j:  # if i >> j & 1:\\n                    tmp.append(nums[j])\\n            res.append(tmp)\\n        return res\\n\\t\\t\\n    # Iteratively\\n    def subsets(self, nums):\\n        res = [[]]\\n        for num in sorted(nums):\\n            res += [item+[num] for item in res]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        ret = []\\n        self.dfs(nums, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, path, ret):\\n        ret.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], path+[nums[i]], ret)\\n       \\n    # Bit Manipulation    \\n    def subsets2(self, nums):\\n        res = []\\n        nums.sort()\\n        for i in xrange(1<<len(nums)):\\n            tmp = []\\n            for j in xrange(len(nums)):\\n                if i & 1 << j:  # if i >> j & 1:\\n                    tmp.append(nums[j])\\n            res.append(tmp)\\n        return res\\n\\t\\t\\n    # Iteratively\\n    def subsets(self, nums):\\n        res = [[]]\\n        for num in sorted(nums):\\n            res += [item+[num] for item in res]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27288,
                "title": "my-solution-using-bit-manipulation",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > subsets(vector<int> &S) {\\n            sort (S.begin(), S.end());\\n            int elem_num = S.size();\\n            int subset_num = pow (2, elem_num);\\n            vector<vector<int> > subset_set (subset_num, vector<int>());\\n            for (int i = 0; i < elem_num; i++)\\n                for (int j = 0; j < subset_num; j++)\\n                    if ((j >> i) & 1)\\n                        subset_set[j].push_back (S[i]);\\n            return subset_set;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > subsets(vector<int> &S) {\\n            sort (S.begin(), S.end());\\n            int elem_num = S.size();\\n            int subset_num = pow (2, elem_num);\\n            vector<vector<int> > subset_set (subset_num, vector<int>());\\n            for (int i = 0; i < elem_num; i++)\\n                for (int j = 0; j < subset_num; j++)\\n                    if ((j >> i) & 1)\\n                        subset_set[j].push_back (S[i]);\\n            return subset_set;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 429534,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27356,
                "title": "5-lines-of-python",
                "content": "    class Solution(object):\\n        def subsets(self, nums):\\n            nums.sort()\\n            result = [[]]\\n            for num in nums:\\n                result += [i + [num] for i in result]\\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def subsets(self, nums):\\n            nums.sort()\\n            result = [[]]\\n            for num in nums:\\n                result += [i + [num] for i in result]\\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 731215,
                "title": "c-3-approaches-recursive-iterative-bit-manipulation-solutions",
                "content": "```\\n// Recursive Solution\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void sub(vector<int> &nums, int i, vector<int> temp)\\n    {\\n        if(i==nums.size())\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        sub(nums, i+1, temp);\\n        temp.push_back(nums[i]);\\n        sub(nums, i+1, temp);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int> temp;       \\n        sub(nums, 0, temp); // or sub(nums, 0, vector<int> {});\\n        return ans;\\n    }\\n};\\n```\\n```\\n// Iterative Solution\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        \\n        ans.push_back({});\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int sz = ans.size();\\n            for(int j=0; j<sz; j++)\\n            {\\n                vector<int> temp = ans[j];\\n                temp.push_back(nums[i]);\\n                ans.push_back(temp);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n```\\n// Bit Manipulation\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        int num = pow(2, n), i = 0;\\n        \\n        while(i<num)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i & 1<<j)\\n                    temp.push_back(nums[j]);\\n            }\\n            ans.push_back(temp);\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion",
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\n// Recursive Solution\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void sub(vector<int> &nums, int i, vector<int> temp)\\n    {\\n        if(i==nums.size())\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        sub(nums, i+1, temp);\\n        temp.push_back(nums[i]);\\n        sub(nums, i+1, temp);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int> temp;       \\n        sub(nums, 0, temp); // or sub(nums, 0, vector<int> {});\\n        return ans;\\n    }\\n};\\n```\n```\\n// Iterative Solution\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        \\n        ans.push_back({});\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int sz = ans.size();\\n            for(int j=0; j<sz; j++)\\n            {\\n                vector<int> temp = ans[j];\\n                temp.push_back(nums[i]);\\n                ans.push_back(temp);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n// Bit Manipulation\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        int num = pow(2, n), i = 0;\\n        \\n        while(i<num)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i & 1<<j)\\n                    temp.push_back(nums[j]);\\n            }\\n            ans.push_back(temp);\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766675,
                "title": "java-intuition-of-approach-backtracking",
                "content": "****\\nPlease upvote if the explanation helps, as it keeps up the motivation to provide such posts.\\n****\\n\\n**Intuition**\\n\\nThis falls into a set of classic problems that can be solved using \"pick\"- \"don\\'t pick\" approach. \\n\\n![image](https://assets.leetcode.com/users/images/1ca8ad88-a0dc-4995-82e0-ce6822177b98_1621218217.2663536.png)\\n\\nAs through observation, it is clear that we start with having a choice to pick or not pick from the first element and then, we propagate this choice down the tree. \\nSo, \\n1. we either pick the element and move ahead ( increment the index ) or,\\n2. we don\\'t pick the element and move ahead\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        result = new ArrayList();\\n        if(nums==null || nums.length==0) return result;\\n        \\n        subsets(nums,new ArrayList<Integer>(), 0);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, ArrayList<Integer> temp, int index) {\\n        // base condition\\n        if(index >= nums.length) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        \\n        // main logic\\n\\t\\t// case 1 : we pick the element\\n        temp.add(nums[index]);\\n        subsets(nums, temp, index+1); // move ahead\\n        temp.remove(temp.size()-1);\\n        \\n\\t\\t// case 2 : we don\\'t pick the element ( notice, we did not add the current element in our temporary list\\n        subsets(nums, temp, index+1); // move ahead\\n    }\\n}\\n```\\n*****\\n\\n\\u2714\\uFE0F **Another related problems** : \\n* https://leetcode.com/problems/subsets-ii/\\n* https://leetcode.com/problems/permutations/\\n* https://leetcode.com/problems/permutations-ii/\\n* https://leetcode.com/problems/combination-sum/\\n* https://leetcode.com/problems/combination-sum-ii/\\n* https://leetcode.com/problems/palindrome-partitioning/\\n\\n\\n\\u2714\\uFE0F **Complexity Analysis:**\\n* TC: `O(n * 2^n)`, as every element has two options-to pick or not pick and `n` bcz we are copying the list of size `n` in base case.\\n* SC: `O(n * 2^n)`\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        result = new ArrayList();\\n        if(nums==null || nums.length==0) return result;\\n        \\n        subsets(nums,new ArrayList<Integer>(), 0);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, ArrayList<Integer> temp, int index) {\\n        // base condition\\n        if(index >= nums.length) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        \\n        // main logic\\n\\t\\t// case 1 : we pick the element\\n        temp.add(nums[index]);\\n        subsets(nums, temp, index+1); // move ahead\\n        temp.remove(temp.size()-1);\\n        \\n\\t\\t// case 2 : we don\\'t pick the element ( notice, we did not add the current element in our temporary list\\n        subsets(nums, temp, index+1); // move ahead\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27279,
                "title": "simple-java-solution-with-for-each-loops",
                "content": "No  messy indexing. Avoid the ConcurrentModificationException by using a temp list.\\n\\n    public class Solution {\\n        public List<List<Integer>> subsets(int[] S) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            res.add(new ArrayList<Integer>());\\n            \\n            Arrays.sort(S);\\n            for(int i : S) {\\n                List<List<Integer>> tmp = new ArrayList<>();\\n                for(List<Integer> sub : res) {\\n                    List<Integer> a = new ArrayList<>(sub);\\n                    a.add(i);\\n                    tmp.add(a);\\n                }\\n                res.addAll(tmp);\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> subsets(int[] S) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            res.add(new ArrayList<Integer>());\\n            \\n            Arrays.sort(S);\\n            for(int i : S) {\\n                List<List<Integer>> tmp = new ArrayList<>();\\n                for(List<Integer> sub : res) {\\n                    List<Integer> a = new ArrayList<>(sub);\\n                    a.add(i);\\n                    tmp.add(a);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 973667,
                "title": "backtracking-template-explanation-visual-python",
                "content": "TL;DR use standard backtracking template that can be applied to backtracking problems that involve [combinations](https://leetcode.com/problems/combinations/) or [permutations](https://leetcode.com/problems/permutations/discuss/971584/Backtracking-or-Explanation-%2B-Visual-or-Python)\\n\\n(starter list of problems that use template  below + explanation + visual) \\n\\n```python \\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t    res, path = [], []\\n        self.dfs(0, res, path, nums)\\n        return res\\n\\t\\t\\n def dfs(self, index, res, path, nums):\\n        res.append(list(path)) \\n        for i in range(index, len(nums)):\\n            path.append(nums[i])\\n            self.dfs(i+1, res, path, nums)\\n            path.pop()\\n```\\n#### Problems That Use This Template\\n1. [Combinations](https://leetcode.com/problems/combinations/)\\n2. [Combination Sum I](https://leetcode.com/problems/combination-sum/)\\n3. [Combination sum II](https://leetcode.com/problems/combination-sum-ii/)\\n4. [Combination sum III](https://leetcode.com/problems/combination-sum-iii/)\\n5. [N Queens I](https://leetcode.com/problems/n-queens/)\\n6. [N Queens II](https://leetcode.com/problems/n-queens-ii/discuss/)\\n7. [Permutations I](https://leetcode.com/problems/permutations/)\\n8. [Permutations II](https://leetcode.com/problems/permutations-ii/discuss/972627/Backtracking-%2B-Permutation-Template-or-Explanation-or-Python)\\n\\n(there are definetly more problems that use this template feel free to comment below if you know one and i will update the list) \\n\\n### Explanation + Visual \\n\\nThe goal is to generate all possible subsets given a set of ```N``` elements. \\n\\nTo put another way the goal is to find the power (the set of all subsets) set of ```S``` (the given set of elements) \\n\\nAll subsets must be generated,  meaning all options must be exaushted. This indicates that backtracking is a good approach to take to solve the problem.  \\n\\nFrom a recursive perspective, a choice is made at each step, to include an element in the subset or exclude an element from the subset. the choice is binary (yes or no) and this choice must be made for all  ```N``` elements and we make every choice. this results in a runtime of \\n```O(N*2^N)``` \\n\\nThe code uses a DFS traversal and undoes previous decisions by removing a previous choice from the current subset. ***This is the heart of backtracking***, we try all possibilities knowing that some may not lead to a solution. when path no longer can lead to a solution, the decision is reveresed. \\n\\nTo understand the code for this problem, it is essntial to understand how the recursion tree (state space tree) is generated. Thus i have provided a visual with numbers to denote the order in which nodes are generated. \\n\\nVisual is for example ```[1, 2 , 3]```\\n![image](https://assets.leetcode.com/users/images/5252e51a-8e1f-4394-af00-0c0bea61aa8b_1608066366.6589456.png)\\n\\n",
                "solutionTags": [],
                "code": "```python \\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t    res, path = [], []\\n        self.dfs(0, res, path, nums)\\n        return res\\n\\t\\t\\n def dfs(self, index, res, path, nums):\\n        res.append(list(path)) \\n        for i in range(index, len(nums)):\\n            path.append(nums[i])\\n            self.dfs(i+1, res, path, nums)\\n            path.pop()\\n```\n```N```\n```S```\n```N```\n```O(N*2^N)```\n```[1, 2 , 3]```",
                "codeTag": "Python3"
            },
            {
                "id": 27511,
                "title": "c-8ms-simple-iterative-solution",
                "content": "    class Solution {\\n    public:\\n\\tvector<vector<int> > subsets(vector<int> &S) {\\n\\t\\tvector<vector<int> > res(1, vector<int>());\\n\\t\\tsort(S.begin(), S.end());\\n\\t\\t\\n\\t\\tfor (int i = 0; i < S.size(); i++) {\\n\\t\\t\\tint n = res.size();\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tres.push_back(res[j]);\\n\\t\\t\\t\\tres.back().push_back(S[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t  }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n\\tvector<vector<int> > subsets(vector<int> &S) {\\n\\t\\tvector<vector<int> > res(1, vector<int>());\\n\\t\\tsort(S.begin(), S.end());\\n\\t\\t\\n\\t\\tfor (int i = 0; i < S.size(); i++) {\\n\\t\\t\\tint n = res.size();\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tres.push_back(res[j]);\\n\\t\\t\\t\\tres.back().push_back(S[i]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1766969,
                "title": "c-100-faster-solution-0-ms-bit-manipulation-easy-to-understand",
                "content": "**Upvote if helpful**\\n\\n**Explaination** : We can use a n-bit integer ( from 0 to 2^n-1) whose individual bits represent wether the element(present at ith index) of the string is included or not.\\nthe two options can be represented as :\\n\\n* \\'1\\' (set bit ) denotes element included\\n\\n* \\'0\\' denotes element not included\\n\\n**If the ith bit in the integer is set then, append ith element from the string for the subset.**\\n```\\nTry to understand this thing with the help of example:\\n\\nchar s[3] = [\\'1\\' , \\'2\\' , \\'3\\' ]\\nTotal number of subsets = pow(2, n) = pow(2, 3) = 8\\nValue of integer Subsets\\n\\n000                    -> Empty set\\n001                    -> 1\\n010                    -> 2\\n011                    -> 12\\n100                    -> 3\\n101                    -> 13\\n110                    -> 23\\n111                    -> 123\\n```\\n![image](https://assets.leetcode.com/users/images/a78610ac-542e-4301-8c85-0e236a43dec6_1644758596.1727226.png)\\n\\n* **Code**\\n```\\nvoid findsub( vector<vector<int>> &res , vector<int> nums , int i){\\n        int j = 0;\\n        vector<int>v;\\n        while(i>0){\\n            if((i&1)==1) v.push_back(nums[j]);\\n            j++;\\n            i = i>>1;\\n        }\\n        res.push_back(v);\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n = nums.size();\\n        for(int i = 0 ; i < (1<<n) ;i++){\\n            findsub(res,nums,i);\\n        }\\n        return res;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nTry to understand this thing with the help of example:\\n\\nchar s[3] = [\\'1\\' , \\'2\\' , \\'3\\' ]\\nTotal number of subsets = pow(2, n) = pow(2, 3) = 8\\nValue of integer Subsets\\n\\n000                    -> Empty set\\n001                    -> 1\\n010                    -> 2\\n011                    -> 12\\n100                    -> 3\\n101                    -> 13\\n110                    -> 23\\n111                    -> 123\\n```\n```\\nvoid findsub( vector<vector<int>> &res , vector<int> nums , int i){\\n        int j = 0;\\n        vector<int>v;\\n        while(i>0){\\n            if((i&1)==1) v.push_back(nums[j]);\\n            j++;\\n            i = i>>1;\\n        }\\n        res.push_back(v);\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n = nums.size();\\n        for(int i = 0 ; i < (1<<n) ;i++){\\n            findsub(res,nums,i);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 940599,
                "title": "3-approaches-for-your-interview-dry-run-iterative-recursive-bitmasking",
                "content": "#### **Approach  1:** Recursive\\n* simplest insight is to follow : `\\'take it\\'`, and` \\'dont take\\' `approach\\n\\n<br>\\n\\n```\\nvar subsets = function(nums) {\\n\\tlet res=[]                    // the final arr, which we will display\\n\\tlet auxArr = [], i=0             // global vars\\n    \\n    function recur(nums,i,auxArr){\\n        if(i==nums.length) { res.push(auxArr); return } //operation of recursion will be upto i=n-1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // when it will hit, i==n, it will store the computed arr, in the final arr, and break(return)\\n        \\n\\t\\t// take it\\n        recur(nums, i+1, [...auxArr, nums[i] ] ) //or, we can use \\'aux.concat(nums[i])\\'\\n\\t\\t\\n\\t\\t// dont take\\n        recur(nums, i+1, auxArr)\\n    \\n    }\\n    \\n    recur(nums,i,auxArr) // passing the global variable declared already\\n    return res        // rerturn the final 2d arr\\n    \\n    \\n};\\n\\n\\n\\t                  1 2 3\\n \\t\\t\\t\\t  /           \\\\\\n \\t\\t    \\t1 \\t\\t\\t     []\\t\\n              /     \\\\           /.  \\\\\\n            1 2\\t     1\\t       2.    []\\n           /  \\\\\\t\\t/ \\\\       / \\\\    / \\\\\\n        123.   12. 13. 1.    23. 2. 3. [].\\n\\n```\\n\\nAll the left part are result of : `\\'Take it\\'`\\nAll the right one are :  `\\'dont take\\'`\\n<br><br><br>\\n<hr><hr>\\n<br>\\n\\n#### **Approach 2**  : Iterative \\n\\n```\\nvar subsets = function(nums) {\\n    let res = [[]], appendarr= []\\n    \\n    for(let num of nums){\\n        appendarr = []\\n        for(let entry of res){\\n            appendarr.push([...entry, num])\\n        }\\n        \\n        res.push(...appendarr)\\n    }\\n    \\n    return res\\n    \\n};\\n\\n\\n0 (Empty)             :         [] \\n1 (Adding 1 to it)    :         [] [1] \\n2 (Adding 2 to it)    :         [] [1] [2] [1,2]\\n3 (Adding 3 to it)    :         [] [1] [2] [1,2] [3] [1,3] [2,3] [1,2,3]\\n```\\n\\n<br> <br> <br> <hr> <hr>\\n#### **Approach 3** : Bit Masking \\n<br> <br>\\n```\\nvar subsets = function(nums) {\\n  const result = [];\\n  result.push([]);   // handling the first case (i=0). for that, an empty arr should be there\\n  \\n  let size = nums.length\\n  \\n  for(let i = 1; i < (1<<size) ; i++){   // generating for range upto [(2^n)-1]\\n    let subset = [];\\n    let bitmask=0\\n    \\n      while(bitmask<size){\\n          if(i & (1 << bitmask)){           // if it exists (not zero)\\n              subset.push( nums[bitmask] );\\n          }\\n          bitmask++   \\n      }\\n      result.push(subset)\\n  }\\n  return result\\n};\\n```\\n<br> <br>\\n```\\nDry Run: \\n\\nlets take nums = [1,2,3]\\nwe will be searching all elem from 0-> 2^n\\n\\nso, checking :\\n\\ni         \\n\\u2B07                                  while(bitmask<size)\\n\\n0 [000]                             [ ] \\n\\n\\n1 [001]      i=1.           \\n\\t\\t\\t\\t\\t\\t\\ti\\t\\t001      001      001\\n\\t\\t\\t  \\t          mask\\t    001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t   ----     ----     ----\\n\\t\\t\\t\\t\\t\\t\\t\\t  [001]      000      000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n2 [010]      i=2.                        \\n\\t\\t\\t\\t\\t       i        010      010      010\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t000     [010]     000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3 [011]      i=3.           \\n\\t\\t\\t\\t\\t       i        011      011      011\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t  [001]     [010]     000\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n4 [100]      i=4.         \\n\\t\\t\\t\\t\\t       i        100      100      100\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t000      000     [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n5 [101]      i=5.           \\n\\t\\t\\t\\t\\t       i        101      101      101\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t   [001]      000     [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n6 [110]      i=6.          \\n\\t\\t\\t\\t\\t       i        110      110      110\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t    000     [010]    [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n7 [111]      i=7.          \\n\\t\\t\\t\\t\\t       i        111      111      111\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t   [001]     [010]    [100]\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nvar subsets = function(nums) {\\n\\tlet res=[]                    // the final arr, which we will display\\n\\tlet auxArr = [], i=0             // global vars\\n    \\n    function recur(nums,i,auxArr){\\n        if(i==nums.length) { res.push(auxArr); return } //operation of recursion will be upto i=n-1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // when it will hit, i==n, it will store the computed arr, in the final arr, and break(return)\\n        \\n\\t\\t// take it\\n        recur(nums, i+1, [...auxArr, nums[i] ] ) //or, we can use \\'aux.concat(nums[i])\\'\\n\\t\\t\\n\\t\\t// dont take\\n        recur(nums, i+1, auxArr)\\n    \\n    }\\n    \\n    recur(nums,i,auxArr) // passing the global variable declared already\\n    return res        // rerturn the final 2d arr\\n    \\n    \\n};\\n\\n\\n\\t                  1 2 3\\n \\t\\t\\t\\t  /           \\\\\\n \\t\\t    \\t1 \\t\\t\\t     []\\t\\n              /     \\\\           /.  \\\\\\n            1 2\\t     1\\t       2.    []\\n           /  \\\\\\t\\t/ \\\\       / \\\\    / \\\\\\n        123.   12. 13. 1.    23. 2. 3. [].\\n\\n```\n```\\nvar subsets = function(nums) {\\n    let res = [[]], appendarr= []\\n    \\n    for(let num of nums){\\n        appendarr = []\\n        for(let entry of res){\\n            appendarr.push([...entry, num])\\n        }\\n        \\n        res.push(...appendarr)\\n    }\\n    \\n    return res\\n    \\n};\\n\\n\\n0 (Empty)             :         [] \\n1 (Adding 1 to it)    :         [] [1] \\n2 (Adding 2 to it)    :         [] [1] [2] [1,2]\\n3 (Adding 3 to it)    :         [] [1] [2] [1,2] [3] [1,3] [2,3] [1,2,3]\\n```\n```\\nvar subsets = function(nums) {\\n  const result = [];\\n  result.push([]);   // handling the first case (i=0). for that, an empty arr should be there\\n  \\n  let size = nums.length\\n  \\n  for(let i = 1; i < (1<<size) ; i++){   // generating for range upto [(2^n)-1]\\n    let subset = [];\\n    let bitmask=0\\n    \\n      while(bitmask<size){\\n          if(i & (1 << bitmask)){           // if it exists (not zero)\\n              subset.push( nums[bitmask] );\\n          }\\n          bitmask++   \\n      }\\n      result.push(subset)\\n  }\\n  return result\\n};\\n```\n```\\nDry Run: \\n\\nlets take nums = [1,2,3]\\nwe will be searching all elem from 0-> 2^n\\n\\nso, checking :\\n\\ni         \\n\\u2B07                                  while(bitmask<size)\\n\\n0 [000]                             [ ] \\n\\n\\n1 [001]      i=1.           \\n\\t\\t\\t\\t\\t\\t\\ti\\t\\t001      001      001\\n\\t\\t\\t  \\t          mask\\t    001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t   ----     ----     ----\\n\\t\\t\\t\\t\\t\\t\\t\\t  [001]      000      000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n2 [010]      i=2.                        \\n\\t\\t\\t\\t\\t       i        010      010      010\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t000     [010]     000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3 [011]      i=3.           \\n\\t\\t\\t\\t\\t       i        011      011      011\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t  [001]     [010]     000\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n4 [100]      i=4.         \\n\\t\\t\\t\\t\\t       i        100      100      100\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t000      000     [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n5 [101]      i=5.           \\n\\t\\t\\t\\t\\t       i        101      101      101\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t   [001]      000     [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n6 [110]      i=6.          \\n\\t\\t\\t\\t\\t       i        110      110      110\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t    000     [010]    [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n7 [111]      i=7.          \\n\\t\\t\\t\\t\\t       i        111      111      111\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t   [001]     [010]    [100]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27294,
                "title": "simple-iteration-no-recursion-no-twiddling-explanation",
                "content": "My idea was to start out with an empty subset and either take or don't take the next element in the input array. Here's how it goes down for input `[1,2,3]`:\\n\\nstart with\\n\\n    [] // empty set is always a subset\\n\\nthen either take or not take the next element (`1`), this doubles the result size:\\n\\n    []   // not take 1\\n    [1] //      take 1 + new\\n\\nthen take or not take the next element: `2`\\n\\n    []    // not take 1, not take 2\\n    [2]   // not take 1,     take 2 + new\\n    [1]   //     take 1, not take 2\\n    [1,2] //     take 1,     take 2 + new\\n\\nand finally take or not take `3`.\\n\\n    []      // not take 1, not take 2, not take 3\\n    [3]     // not take 1, not take 2,     take 3 + new\\n    [2]     // not take 1,     take 2, not take 3\\n    [2,3]   // not take 1,     take 2,     take 3 + new\\n    [1]     //     take 1, not take 2, not take 3\\n    [1,3]   //     take 1, not take 2,     take 3 + new\\n    [1,2]   //     take 1,     take 2, not take 3\\n    [1,2,3] //     take 1,     take 2,     take 3 + new\\n\\nAnd we're done, we have all `2^3 = 8` subsets generated.\\n\\nIt is possible to generate these with a simple loop, there's only one trick here, the variable `size`. It's usually a good practice to cache method call results, but now it is cached for a different reason: because it changes in every iteration. If we don't want to end up with an infinite loop, we have to remember how many `results` were available in the previous iteration, which is exactly the `size()` of the `result` at the beginning of the current iteration.\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums); // make sure subsets are ordered\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>()); // start with empty set\\n        for (int i = 0; i < nums.length; ++i) {\\n            for (int j = 0, size = result.size(); j < size; ++j) { // remember\\n                List<Integer> subset = new ArrayList<>(result.get(j)); // copy a new one\\n                subset.add(nums[i]); // expand\\n                result.add(subset); // collect\\n            }\\n        }\\n        return result;\\n    }\\n\\nIt is also necessary to order the input to satisfy the requirement:\\n\\n> * Elements in a subset must be in non-descending order.\\n\\nBecause `i` is increasing it means that whatever we take from nums will also be in increasing order.\\n\\nThe other requirement:\\n\\n> * The solution set must not contain duplicate subsets.\\n\\nis automatically guaranteed by the input specification and the algorithm walking indices straight and once:\\n\\n> Given a set of **distinct** integers, `nums`, return all possible subsets. *[emphasis mine]*",
                "solutionTags": [
                    "Java"
                ],
                "code": "My idea was to start out with an empty subset and either take or don't take the next element in the input array. Here's how it goes down for input `[1,2,3]`:\\n\\nstart with\\n\\n    [] // empty set is always a subset\\n\\nthen either take or not take the next element (`1`), this doubles the result size:\\n\\n    []   // not take 1\\n    [1] //      take 1 + new\\n\\nthen take or not take the next element: `2`\\n\\n    []    // not take 1, not take 2\\n    [2]   // not take 1,     take 2 + new\\n    [1]   //     take 1, not take 2\\n    [1,2] //     take 1,     take 2 + new\\n\\nand finally take or not take `3`.\\n\\n    []      // not take 1, not take 2, not take 3\\n    [3]     // not take 1, not take 2,     take 3 + new\\n    [2]     // not take 1,     take 2, not take 3\\n    [2,3]   // not take 1,     take 2,     take 3 + new\\n    [1]     //     take 1, not take 2, not take 3\\n    [1,3]   //     take 1, not take 2,     take 3 + new\\n    [1,2]   //     take 1,     take 2, not take 3\\n    [1,2,3] //     take 1,     take 2,     take 3 + new\\n\\nAnd we're done, we have all `2^3 = 8` subsets generated.\\n\\nIt is possible to generate these with a simple loop, there's only one trick here, the variable `size`. It's usually a good practice to cache method call results, but now it is cached for a different reason: because it changes in every iteration. If we don't want to end up with an infinite loop, we have to remember how many `results` were available in the previous iteration, which is exactly the `size()` of the `result` at the beginning of the current iteration.\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums); // make sure subsets are ordered\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>()); // start with empty set\\n        for (int i = 0; i < nums.length; ++i) {\\n            for (int j = 0, size = result.size(); j < size; ++j) { // remember\\n                List<Integer> subset = new ArrayList<>(result.get(j)); // copy a new one\\n                subset.add(nums[i]); // expand\\n                result.add(subset); // collect\\n            }\\n        }\\n        return result;\\n    }\\n\\nIt is also necessary to order the input to satisfy the requirement:\\n\\n> * Elements in a subset must be in non-descending order.\\n\\nBecause `i` is increasing it means that whatever we take from nums will also be in increasing order.\\n\\nThe other requirement:\\n\\n> * The solution set must not contain duplicate subsets.\\n\\nis automatically guaranteed by the input specification and the algorithm walking indices straight and once:\\n\\n> Given a set of **distinct** integers, `nums`, return all possible subsets. *[emphasis mine]*",
                "codeTag": "Unknown"
            },
            {
                "id": 729863,
                "title": "c-using-bit-masking-most-simpler-with-explain",
                "content": "Idea is ---\\nAs they said all numbers are ```distinct integers``` and We need to find out  all possible subsets\\nNo of subsets would be ```(2 power, No_of_element[from the array])```\\nAnd how We are going to Find It Out ????\\nNeed To Run A loop From 0 to 2^No_of_element and for each number Find All Set Bit Positions Element from that array\\n\\nlets take An Example For better Understanding\\n\\narray = [1,2,3]\\nNo of subsets = 2^3 = 8\\nfrom 0 to 8 for each value find setbit and put into an array\\n\\n    No     BitRepresentation       Array         Ans_Array \\n    0         [ 0 0 0 ]             []            {}                  ----->as There No Set Bit \\n\\n    1         [ 0 0 1 ]            [ 0 0 3]       {3}  \\n\\n    2         [ 0 1 0 ]            [ 0 2 0]       {2}  \\n\\n    3         [ 0 1 1 ]            [ 0 2 3]       {2,3}  \\n\\n    4         [ 1 0 0 ]            [ 1 0 0]       {1}  \\n\\n    5         [ 1 0 1 ]            [ 1 0 3]       {1,3}  \\n\\n    6         [ 1 1 0 ]            [ 1 2 0]       {1,2}  \\n\\n    7         [ 1 1 1 ]            [ 1 2 3]       {1,2,3}  \\n \\nANSWER - [{},{3},{2},{1},{1,3},{1,2},{1,2,3}]  - --->return It\\n   \\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>FindSubSet(int no,vector<int>&nums){\\n        vector<int>re;\\n        int i = 0;\\n        while(no){\\n            if(no&1){\\n                re.push_back(nums[i]);\\n            }\\n            i++;\\n            no>>=1;\\n        }\\n        return re;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>>ans;\\n        int total = 1<<n;\\n        for(int i=0;i<total;i++){\\n            vector<int>temp = FindSubSet(i,nums);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nI hope It Help You \\nIf You Realy Like This Please UpVote\\nAny Suggesstion Comments below\\nThank You (^-^)",
                "solutionTags": [],
                "code": "```distinct integers```\n```(2 power, No_of_element[from the array])```\n```\\nclass Solution {\\npublic:\\n    vector<int>FindSubSet(int no,vector<int>&nums){\\n        vector<int>re;\\n        int i = 0;\\n        while(no){\\n            if(no&1){\\n                re.push_back(nums[i]);\\n            }\\n            i++;\\n            no>>=1;\\n        }\\n        return re;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>>ans;\\n        int total = 1<<n;\\n        for(int i=0;i<total;i++){\\n            vector<int>temp = FindSubSet(i,nums);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140388,
                "title": "clear-and-simple-explanation-with-example-100-faster",
                "content": "**Intuition:** Since we are asked to calculate all the possible subsets, hence we will use backtracking , accepting the cases which satisfy conditions and reject the others.\\n\\n**Concept:** This problem is different than the rest of the usual backtracking ones in the sense that , in this problem, we dont have a separate base case that tells us when to stop with the recursion. We keep looping until we run out of indexes and that marks the end of our recursion. \\n\\nWe basically loop over every element in our input `nums`, and we recursively call the method to generate subsets corresponding to that element in the next line and then we remove that element since we are done with it, and we add it to our `subsets` array. \\n\\nAnd **VOILA!!!** Its done.\\nI know it sounds confusing, hence I am going to give an example to explain myself better:\\n\\n**Let\\'s take an example -> nums = [1,2,3]**\\n * first of all, we created current = [ ]\\nNow, we are going to create a copy of current and add it to our subsets Arraylist.\\nSo far, we have subsets = [[ ]]  \\n\\n* Now, we insert the nums[i] i.e., nums[0] in current. Current become -> [1]\\nNow, we make a recursion call with index = 1 and current = [1].\\n\\n* Now, we  add current in subsets. Subsets = [[ ], [1]] (created a copy of current and added it to subset)\\nAdd nums[i] to current where index = 1. Current = [1,2]\\nRecursion call -> index = 2, current = [1, 2].\\n\\n* Add current to subsets. Subsets = [[ ], [1], [1,2]]\\nAdd nums[i] to current where index = 2.\\nRecursion call -> index = 3, current = [1,2,3]\\n\\n* Add current to subset. Subsets = [[ ], [1],[1,2],[1,2,3]]\\nNow, for loop won\\'t execute because index > nums.length().\\nSo, it will return now. \\n\\n* Now, we come to statement current.remove(current.size() - 1).\\nWe now get, current = [1,2]. i = 2 here. Now, we come to next iteration of for loop, i becomes 3 but 3 < nums.length(). \\nSo, it will again return.\\n\\n* Now, we come to statement current.remove(current.size() - 1) again.\\nWe now get, current = [1], i = 1 here. Now, in next loop iteration, i = 2.\\nWe add nums[i] to current. i = 2. Current = [1,3]\\nRecursion Call -> current = [1,3], index = 3\\n\\n* Insert current to subset. Subset = [[ ], [1], [1,2], [1,2,3], [1,3]]\\nWe now try to run the loop but i = 3 and it is not less than nums.length(). \\nSo, we return.\\n\\n* Now, we come back to statement current.remove(current.size() - 1).\\nAnd in the same fashion, [1] is also removed. After 1 is removed, we get [ ] and we insert 2 in it. then we insert [2] in subsets. Then we insert [2,3]. Then we remove 3 and 2. Then we insert [3]. And we are done.\\n\\n* We finally get subset = [[ ], [1], [1,2], [1,2,3], [1,3], [2], [2,3], [3]] ------> ANSWER. Return it. \\n\\nI hope this helped ,and now to implement the logic above , here is the code:\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>subset;\\n    void helper(int index, vector<int>&current,vector<int>&nums)\\n    {\\n        subset.push_back(current); // push the current subset into the resultant array\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            current.push_back(nums[i]); // add the current element to consider the subsets corresponding to it\\n            helper(i+1,current,nums);  //generate subsets for this array\\n            current.pop_back(); // as this has been used, pop it\\n        }\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>current;\\n        helper(0,current,nums);\\n        return subset; //return answer\\n    }\\n};\\n```\\n**For similar problems: [Backtracking Collection](https://leetcode.com/discuss/interview-question/1141947/backtracking-study-and-analysis)**\\n\\nIf you like, please **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>subset;\\n    void helper(int index, vector<int>&current,vector<int>&nums)\\n    {\\n        subset.push_back(current); // push the current subset into the resultant array\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            current.push_back(nums[i]); // add the current element to consider the subsets corresponding to it\\n            helper(i+1,current,nums);  //generate subsets for this array\\n            current.pop_back(); // as this has been used, pop it\\n        }\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>current;\\n        helper(0,current,nums);\\n        return subset; //return answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27332,
                "title": "java-subsets-solution",
                "content": "public class Solution {\\n    \\n    \\n    public List<List<Integer>> subsets(int[] S) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n       \\n        if(S.length == 0){\\n            return result;\\n        }\\n        \\n        Arrays.sort(S);\\n        dfs(S, 0, new ArrayList<Integer>(), result);\\n        return result;\\n    }\\n    \\n    public void dfs(int[] s, int index, List<Integer> path, List<List<Integer>> result){\\n        result.add(new ArrayList<Integer>(path));\\n        \\n        for(int i = index; i < s.length; i++){\\n            path.add(s[i]);\\n            dfs(s, i+1, path, result);\\n            path.remove(path.size()-1);\\n        }\\n    }\\n    \\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    \\n    public List<List<Integer>> subsets(int[] S) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n       \\n        if(S.length == 0){\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 360873,
                "title": "python-backtracking",
                "content": "This is a classic backtracking problem. Every back tracking problem can be solved by using the **\"choose\"-> \"explore\" -> \"unchoose\"** strategy.\\n\"Choosing\" is based on the decision tree specific to the problem. Look at the image attached. ![image](https://assets.leetcode.com/users/geekcoder1989/image_1566089485.png)\\n At every level, the decision is whether to include the first element from the remaining set into the chosen set. Based on the decision, further exploration follows.\\n\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def explore(chosen, remaining, res):\\n            if not remaining:\\n                res.append(chosen[:])\\n                return\\n            d = remaining.pop(0)\\n            #choose\\n            chosen.append(d)\\n            #explore\\n            explore(chosen, remaining, res)\\n            chosen.pop()\\n            explore(chosen, remaining, res)\\n            #unchoose\\n            remaining.insert(0, d)\\n        \\n        res = []\\n        chosen = []\\n        explore(chosen, nums, res)\\n        return res\\n```\\t\\t",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def explore(chosen, remaining, res):\\n            if not remaining:\\n                res.append(chosen[:])\\n                return\\n            d = remaining.pop(0)\\n            #choose\\n            chosen.append(d)\\n            #explore\\n            explore(chosen, remaining, res)\\n            chosen.pop()\\n            explore(chosen, remaining, res)\\n            #unchoose\\n            remaining.insert(0, d)\\n        \\n        res = []\\n        chosen = []\\n        explore(chosen, nums, res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27353,
                "title": "short-and-clear-solutions",
                "content": "Straight-forward iterative solution:\\n\\n    def subsets(self, nums):\\n        subsets = [[]]\\n        for n in nums:\\n            subsets += [s + [n] for s in subsets]\\n        return subsets\\n\\nSame thing but with `reduce` instead of the loop:\\n\\n    def subsets(self, nums):\\n        return reduce(lambda subsets, n: subsets + [s+[n] for s in subsets], nums, [[]])\\n\\nUsing `combinations` from the library:\\n\\n    def subsets(self, nums):\\n        return [s for n in range(len(nums)+1)\\n                for s in itertools.combinations(nums, n)]\\n\\nUsing integers as bit mask to tell which elements to use in a subset:\\n\\n    def subsets(self, nums):\\n        return [[nums[i] for i in range(len(nums)) if mask >> i & 1]\\n                for mask in range(2 ** len(nums))]",
                "solutionTags": [
                    "Python"
                ],
                "code": "Straight-forward iterative solution:\\n\\n    def subsets(self, nums):\\n        subsets = [[]]\\n        for n in nums:\\n            subsets += [s + [n] for s in subsets]\\n        return subsets\\n\\nSame thing but with `reduce` instead of the loop:\\n\\n    def subsets(self, nums):\\n        return reduce(lambda subsets, n: subsets + [s+[n] for s in subsets], nums, [[]])\\n\\nUsing `combinations` from the library:\\n\\n    def subsets(self, nums):\\n        return [s for n in range(len(nums)+1)\\n                for s in itertools.combinations(nums, n)]\\n\\nUsing integers as bit mask to tell which elements to use in a subset:\\n\\n    def subsets(self, nums):\\n        return [[nums[i] for i in range(len(nums)) if mask >> i & 1]\\n                for mask in range(2 ** len(nums))]",
                "codeTag": "Python3"
            },
            {
                "id": 1766584,
                "title": "python3-bit-manipulation-99-55-faster-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe idea is to use a bitmask where every bit represents an element in the `nums` list. If a bit is set to one, that means the corresponding element is active and goes to a subset. By subtracting the mask by 1 until it turns to zero, we will be able to iterate all possible variations of unique subsets. Example: `nums=[1, 2, 3]`:\\nmask=111 | nums=[**1, 2, 3**]\\nmask=110 | nums=[**1,2,** 3]\\nmask=101 | nums=[**1,** 2, **3**]\\nmask=100 | nums=[**1,** 2, 3]\\netc.\\n\\nTime: **O(N * 2^N)** - iterations\\nSpace: **O(1)** - if not account for the answer list \\n\\nRuntime: 24 ms, faster than **99.55%** of Python3 online submissions for Subsets.\\nMemory Usage: 14.1 MB, less than **95.43%** of Python3 online submissions for Subsets.\\n\\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\tL, ans = len(nums), list([[]])\\n\\n\\tmask = 2**L - 1\\n\\twhile mask:\\n\\t\\tcopy, i, subset = mask, L - 1, list()\\n\\t\\twhile copy:\\n\\t\\t\\tif copy & 1: subset.append(nums[i])\\n\\t\\t\\ti, copy = i - 1, copy >> 1\\n\\n\\t\\tans.append(subset)\\n\\t\\tmask -= 1\\n\\n\\treturn ans\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\tL, ans = len(nums), list([[]])\\n\\n\\tmask = 2**L - 1\\n\\twhile mask:\\n\\t\\tcopy, i, subset = mask, L - 1, list()\\n\\t\\twhile copy:\\n\\t\\t\\tif copy & 1: subset.append(nums[i])\\n\\t\\t\\ti, copy = i - 1, copy >> 1\\n\\n\\t\\tans.append(subset)\\n\\t\\tmask -= 1\\n\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 299665,
                "title": "recursive-javascript-solution",
                "content": "```js\\nfunction subsets(nums) {\\n\\tconst powerset = [];\\n\\tgeneratePowerset([], 0);\\n\\n\\tfunction generatePowerset(path, index) {\\n\\t\\tpowerset.push(path);\\n\\t\\tfor (let i = index; i < nums.length; i++) {\\n\\t\\t\\tgeneratePowerset([...path, nums[i]], i + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn powerset;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```js\\nfunction subsets(nums) {\\n\\tconst powerset = [];\\n\\tgeneratePowerset([], 0);\\n\\n\\tfunction generatePowerset(path, index) {\\n\\t\\tpowerset.push(path);\\n\\t\\tfor (let i = index; i < nums.length; i++) {\\n\\t\\t\\tgeneratePowerset([...path, nums[i]], i + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn powerset;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27277,
                "title": "5-line-simple-python-solution-beat-96",
                "content": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for n in nums:\\n            for i in range(len(res)):\\n                res.append(res[i] + [n])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for n in nums:\\n            for i in range(len(res)):\\n                res.append(res[i] + [n])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27485,
                "title": "share-my-12-line-simple-java-code-with-brief-explanations",
                "content": "    /*\\n        dfs. \\u6bcf\\u4e2a\\u4f4d\\u7f6e\\u90fd\\u6709\\u9009\\u4e0e\\u4e0d\\u9009\\u4e24\\u4e2a\\u9009\\u9879, \\u4e5f\\u53ef\\u4ee5\\u770b\\u6210\\u904d\\u5386\\u4e00\\u68f5\\u4e8c\\u53c9\\u6811, \\u5411\\u5de6\\u8d70\\u9009, \\u5411\\u53f3\\u8d70\\u4e0d\\u9009\\n    */\\n    public class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            if (nums == null) { return ans; }\\n            Arrays.sort(nums);  // non-descending order\\n            dfs(ans, nums, new ArrayList<Integer>(), 0);\\n            return ans; \\n        }\\n        \\n        private void dfs(List<List<Integer>> ans, int[] nums, List<Integer> list, int index) {\\n            if (index == nums.length) { ans.add(new ArrayList<Integer>(list)); return; }\\n            dfs(ans, nums, list, index+1);  // not pick the number at this index\\n            list.add(nums[index]);\\n            dfs(ans, nums, list, index+1);  // pick the number at this index\\n            list.remove(list.size()-1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            if (nums == null) { return ans; }",
                "codeTag": "Java"
            },
            {
                "id": 381670,
                "title": "c-backtracking-solution-with-comments",
                "content": "```\\n/*\\nTime complexity : O(N*(2^N))\\nSpace complexity : O(N*(2^N))\\n\\nI am not very clear, please refer to Back to Back SWE\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> cache;\\n        vector<int> temp;\\n        subsets(nums, cache, temp, 0);\\n        return cache;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, vector<vector<int>>& cache, vector<int> &temp, int start) {\\n        // goal, once we reach the end, add it to the result\\n        if(start == nums.size()) {\\n            cache.push_back(temp);\\n            return;\\n        }\\n        // for every element we have two choices : keep it or drop it\\n        // choice 1, keep it\\n        temp.push_back(nums[start]);\\n        subsets(nums, cache, temp, start + 1);\\n        // choice 2, drop it\\n        temp.pop_back();\\n        subsets(nums, cache, temp, start + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n/*\\nTime complexity : O(N*(2^N))\\nSpace complexity : O(N*(2^N))\\n\\nI am not very clear, please refer to Back to Back SWE\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> cache;\\n        vector<int> temp;\\n        subsets(nums, cache, temp, 0);\\n        return cache;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, vector<vector<int>>& cache, vector<int> &temp, int start) {\\n        // goal, once we reach the end, add it to the result\\n        if(start == nums.size()) {\\n            cache.push_back(temp);\\n            return;\\n        }\\n        // for every element we have two choices : keep it or drop it\\n        // choice 1, keep it\\n        temp.push_back(nums[start]);\\n        subsets(nums, cache, temp, start + 1);\\n        // choice 2, drop it\\n        temp.pop_back();\\n        subsets(nums, cache, temp, start + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184674,
                "title": "javascript",
                "content": "```\nvar subsets = function(nums) {\n    let result = [];\n    dfs([], 0);\n    \n    function dfs(current, index){\n        result.push(current);\n        for(let i = index; i < nums.length; i++) {\n            dfs(current.concat(nums[i]), i + 1);\n        }\n    }\n    \n    return result;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar subsets = function(nums) {\n    let result = [];\n    dfs([], 0);\n    \n    function dfs(current, index){\n        result.push(current);\n        for(let i = index; i < nums.length; i++) {\n            dfs(current.concat(nums[i]), i + 1);\n        }\n    }\n    \n    return result;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 729842,
                "title": "python-3-solutions-backtracking-2-oneliners-explained",
                "content": "In this problem we need to return all posible subsets of given set, and there are a big number of them: `2^n`. It usually means, that we need to use some backtracking approach to do it.\\nLet us have function `dfs(self, current, nums)`, with parameters:\\n1. `current` is set of indexes choosen number: we always choose indexes in increasing order. \\n2. `nums` are our original numbers (we can make it global varialbe as well).\\n\\nAlso I start with dummy variable index `-1`, and when we add subset to final answer, we remove this element. Then we recursively run `dfs` with new added number `i`.\\n\\n**Complexity**: both time ans space is `O(2^n*n)`, because we have `2^n` subsets with n/2 elements in average.\\n\\n```\\nclass Solution:\\n    def subsets(self, nums):\\n        self.out = []\\n        self.dfs([-1],nums)\\n        return self.out\\n\\n    def dfs(self, current, nums):\\n        self.out.append([nums[s] for s in current][1:])\\n        for i in range(current[-1] + 1, len(nums)):\\n            self.dfs(current + [i], nums)\\n```\\n\\n**Oneliners**\\nFirst one is to use `combinations` library from python, and we itarate over all possible number of elements. Second one uses binary masks.\\n\\n```\\nreturn chain.from_iterable(combinations(nums, i) for i in range(len(nums)+1))\\n\\nreturn [[nums[j] for j in range(len(nums)) if (i&(1<<j))] for i in range(1<<len(nums))]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums):\\n        self.out = []\\n        self.dfs([-1],nums)\\n        return self.out\\n\\n    def dfs(self, current, nums):\\n        self.out.append([nums[s] for s in current][1:])\\n        for i in range(current[-1] + 1, len(nums)):\\n            self.dfs(current + [i], nums)\\n```\n```\\nreturn chain.from_iterable(combinations(nums, i) for i in range(len(nums)+1))\\n\\nreturn [[nums[j] for j in range(len(nums)) if (i&(1<<j))] for i in range(1<<len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362545,
                "title": "python3-backtracking",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    level 0: []\\n    level 1: [11]                    [22]       [33]\\n    level 2: [11,22]     [11,33]     [22,33] \\n    level 3: [11,22,33]\\n  \\n    \"\"\"\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            subset.append(nums[i])\\n            self.backtracking(res,i+1,subset,nums)\\n            subset.pop()\\n```\\n* The length of subset:\\nwe have two choices for a given item in the nums: in the subset or not in the subset. So, if we have 2 choices for each of the \\uD835\\uDC5B elements, the total number of subsets possible is 2**n.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    level 0: []\\n    level 1: [11]                    [22]       [33]\\n    level 2: [11,22]     [11,33]     [22,33] \\n    level 3: [11,22,33]\\n  \\n    \"\"\"\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            subset.append(nums[i])\\n            self.backtracking(res,i+1,subset,nums)\\n            subset.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766662,
                "title": "easy-to-go-solution",
                "content": ">In this question if you observe you will found out that we have given some `choices` & on that `choices` we have to make `decision`.\\n>>So, what choices we have given is whether **to include \"Yes\" or not \"No\".**\\n\\nLet\\'s say we have **input:** [1, 2, 3] to make it\\'s recursive diagram. We have choices like to include 1 or not & so on...\\n\\n```\\n       1                    2                      3\\n\\t  / \\\\                  / \\\\                    / \\\\\\n\\tYes  No              Yes  No                Yes  No\\n```\\n\\nSo, on these choices whatever decision I will take, it will make my subset!\\n\\n![image](https://assets.leetcode.com/users/images/e031f1ed-c20f-4999-ab43-bc49bb1e235d_1644719174.8762171.png)\\n\\nSo, if you see we are taking choices whether to have or not. [ 0 or 1 ] And by these choices we are making decision\\'s. And because of that. Our Input is getting smaller.\\n\\nNow let\\'s understand, how we will build our **recursion tree**\\n\\nAgain, let\\'s understand with example we have to get subset of [1, 2]\\n\\n```\\n|  [ ]  |   1 -> 0 2 -> 0\\n|  1    |   1 -> 1 2 -> 0\\n|  2    |   1 -> 0 2 -> 1\\n|  12   |   1 -> 1 2 -> 1\\n```\\n\\nSo, instead of representing in `1->0 2->0` way. We want to represent in a good way & that way is called **Recursive Tree**\\n\\nFor Recursive tree there is a method called **\"IP - OP Method\"**\\n\\n![image](https://assets.leetcode.com/users/images/f3beda30-bb5b-4f19-8642-56ce05fff151_1644719440.842423.png)\\n\\nLet\\'s understand this tree with an example as well. **Get subset of [1, 2, 3]**\\n\\n![image](https://assets.leetcode.com/users/images/219e18c6-cc00-45c5-b9c2-e1cc287123d8_1644720694.847087.png)\\n\\nSo, as you see once the **input is becoming empty** we are getting our answer:\\nWe put our base-condition `if input size becomes 0`\\n **return & get\\'s the answer**\\n\\n\\n>**2 steps to solve Recursion Problem**\\n* `Design a recursive tree`\\n* `F8ck the problem a.k.a` **Write the code**\\n\\n*I hope now, you got the idea.* **Let\\'s code it:**\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<Integer> ip = new ArrayList<>(); // ip = input\\n        for(int i = 0; i < nums.length; i++){\\n            ip.add(nums[i]);\\n        }\\n        List<Integer> op = new ArrayList<>(); // op = output\\n        List<List<Integer>> res = new ArrayList<>(); \\n        \\n        solve(ip, op, res);\\n        return res;\\n    }\\n    public void solve(List<Integer> ip, List<Integer> op, List<List<Integer>> res){\\n        if(ip.size() == 0){\\n            res.add(op);\\n            return;\\n        }\\n        \\n        List<Integer> op1 = new ArrayList<>(op); // op1 = output1\\n        List<Integer> op2 = new ArrayList<>(op); // op2 = output2\\n        \\n        op2.add(ip.get(0));\\n        \\n        //NEED TO DECALARE NEW input ARRAYLIST BECUASE JAVA IS \"PASS BY VALUE\"\\n        List<Integer> input = new ArrayList<>(ip);\\n\\n        input.remove(0);\\n        \\n        solve(input, op1, res);\\n        solve(input, op2, res);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n       1                    2                      3\\n\\t  / \\\\                  / \\\\                    / \\\\\\n\\tYes  No              Yes  No                Yes  No\\n```\n```\\n|  [ ]  |   1 -> 0 2 -> 0\\n|  1    |   1 -> 1 2 -> 0\\n|  2    |   1 -> 0 2 -> 1\\n|  12   |   1 -> 1 2 -> 1\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<Integer> ip = new ArrayList<>(); // ip = input\\n        for(int i = 0; i < nums.length; i++){\\n            ip.add(nums[i]);\\n        }\\n        List<Integer> op = new ArrayList<>(); // op = output\\n        List<List<Integer>> res = new ArrayList<>(); \\n        \\n        solve(ip, op, res);\\n        return res;\\n    }\\n    public void solve(List<Integer> ip, List<Integer> op, List<List<Integer>> res){\\n        if(ip.size() == 0){\\n            res.add(op);\\n            return;\\n        }\\n        \\n        List<Integer> op1 = new ArrayList<>(op); // op1 = output1\\n        List<Integer> op2 = new ArrayList<>(op); // op2 = output2\\n        \\n        op2.add(ip.get(0));\\n        \\n        //NEED TO DECALARE NEW input ARRAYLIST BECUASE JAVA IS \"PASS BY VALUE\"\\n        List<Integer> input = new ArrayList<>(ip);\\n\\n        input.remove(0);\\n        \\n        solve(input, op1, res);\\n        solve(input, op2, res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598122,
                "title": "python-subsets-vs-combinations-vs-permutations-visualized",
                "content": "**Idea:**\\n- To generate subsets, each node in the recrsive tree is part of the solution.\\n- The generation of **subsets** and that of **combinations** are simialr. In fact, combinations is a special case of subsets where the answers must be of a specific size k (nCk)\\n- On the other hand, subsets come in varying sizes - from 0 (aka. empty subset)all the way to size n.\\n- **Visually,** the recursive tree that we must generate to arrive at *both* **subsets** and **combinations** of a list is the same. \\n- However, only **leaf nodes that are of size k** make up the solution to the **combination problem,** whereas the solution for the **subsets** problem comprise of **all nodes** in the recursive tree without exception.\\n- See below visuals for a comparison between: \\n    - **Trimming algortihm** (used in generating subsets, combinations)\\n    - **Swapping algorithm** (used in generating permutations)\\n\\n![image](https://assets.leetcode.com/users/images/f45911f6-3d16-4ff9-b745-ea473f48b70e_1641245486.5257618.png)\\n\\n![image](https://assets.leetcode.com/users/images/73e04b91-2fac-40f8-9cc2-d696fb7c81f2_1637989748.5639527.png)\\n\\n\\n------------------------------------------------------------------------------\\n[1] Recursive\\n--------------------------------\\n------------------------------------------------------------------------------\\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\'\\'\\'\\n\\tRecursive\\n\\t\\'\\'\\'\\n\\t# - helper\\n\\tdef recurse(start, subset):\\n\\n\\t\\tres.append(subset)\\n\\t\\tfor i in range(start, len(nums)):\\n\\t\\t\\trecurse(i+1, subset+[nums[i]])\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\treturn recurse(0, []) # startIndx, subset\\n```\\n------------------------------------------------------------------------------\\n[2] Iterative\\n--------------------------------\\n------------------------------------------------------------------------------\\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\'\\'\\'\\n\\titerative\\n\\t\\'\\'\\'\\n\\tstack = [(0, [])] # start, subset\\n\\tres = []\\n\\twhile stack:\\n\\t\\tstart, subset = stack.pop()\\n\\t\\tres.append(subset) # no cond to be checked (unlike combinations, perm)\\n\\n\\t\\tfor i in range(start, len(nums)):\\n\\t\\t\\tstack.append((i+1, subset+[nums[i]]))\\n\\n\\treturn res\\n```\\n- Similar problems:\\n\\t- Combinations: https://leetcode.com/problems/combinations/discuss/1409224/Python-4-Approaches-Explained-%2B-Visualized\\n\\t- Permuations: https://leetcode.com/problems/permutations/discuss/993970/Python-4-Approaches-%3A-Visuals-%2B-Time-Complexity-Analysis",
                "solutionTags": [
                    "Recursion",
                    "Iterator",
                    "Probability and Statistics"
                ],
                "code": "```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\'\\'\\'\\n\\tRecursive\\n\\t\\'\\'\\'\\n\\t# - helper\\n\\tdef recurse(start, subset):\\n\\n\\t\\tres.append(subset)\\n\\t\\tfor i in range(start, len(nums)):\\n\\t\\t\\trecurse(i+1, subset+[nums[i]])\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\treturn recurse(0, []) # startIndx, subset\\n```\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\'\\'\\'\\n\\titerative\\n\\t\\'\\'\\'\\n\\tstack = [(0, [])] # start, subset\\n\\tres = []\\n\\twhile stack:\\n\\t\\tstart, subset = stack.pop()\\n\\t\\tres.append(subset) # no cond to be checked (unlike combinations, perm)\\n\\n\\t\\tfor i in range(start, len(nums)):\\n\\t\\t\\tstack.append((i+1, subset+[nums[i]]))\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 473975,
                "title": "learning-and-summarizing-3-solutions",
                "content": "\\n**BFS**\\n```\\nlet subsetsbfs = function (nums) {\\n  const res = [[]];\\n  for (let i = 0; i < nums.length; i++) {\\n    const size = res.length;\\n    for (let j = 0; j < size; j++) {\\n      res.push([...res[j], nums[i]]);\\n    }\\n  }\\n  return res;\\n};\\n```\\n\\n\\n**Backtracking**\\n```\\nlet subsets = function (nums) {\\n  const res = [];\\n  const backtracking = (nums, res, idx, path) => {\\n    res.push([...path]);\\n\\n    for (let i = idx; i < nums.length; i++) {\\n      path.push(nums[i]);\\n      backtracking(nums, res, i + 1, path);\\n      path.pop();\\n    }\\n  };\\n\\n  backtracking(nums, res, 0, []);\\n\\n  return res;\\n};\\n```\\n\\n\\n**Lexicographic Subsets**\\n```\\nvar subsets = function(nums) {\\n    let res = []\\n    const powSize = Math.pow(2, nums.length)\\n\\n    for (let i = 0; i < powSize; i++) {\\n        let set = []\\n        for (let j = 0; j < nums.length; j++) {\\n            if ((i & (1 << j)) > 0) {\\n                set.push(nums[j])\\n            }\\n        }\\n        res.push(set)\\n    }\\n    return res\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet subsetsbfs = function (nums) {\\n  const res = [[]];\\n  for (let i = 0; i < nums.length; i++) {\\n    const size = res.length;\\n    for (let j = 0; j < size; j++) {\\n      res.push([...res[j], nums[i]]);\\n    }\\n  }\\n  return res;\\n};\\n```\n```\\nlet subsets = function (nums) {\\n  const res = [];\\n  const backtracking = (nums, res, idx, path) => {\\n    res.push([...path]);\\n\\n    for (let i = idx; i < nums.length; i++) {\\n      path.push(nums[i]);\\n      backtracking(nums, res, i + 1, path);\\n      path.pop();\\n    }\\n  };\\n\\n  backtracking(nums, res, 0, []);\\n\\n  return res;\\n};\\n```\n```\\nvar subsets = function(nums) {\\n    let res = []\\n    const powSize = Math.pow(2, nums.length)\\n\\n    for (let i = 0; i < powSize; i++) {\\n        let set = []\\n        for (let j = 0; j < nums.length; j++) {\\n            if ((i & (1 << j)) > 0) {\\n                set.push(nums[j])\\n            }\\n        }\\n        res.push(set)\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1571250,
                "title": "c-solution-using-recursion-with-full-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- We pass ans array, index, input array(ip), output array(op) to solve function.\\n- In every function call either we have to take the input to the array or skip that.\\n- If we skip we simply call the function and increase the index by 1.\\n- else we include that in op array\\xA0***//op.push_back(ip[i])***\\n- again we call for the next index and after we return we simply pop last element from op\\n- Base condition: When idx is equal to the size of ip we return.\\n- **Time complexity:** O().\\n\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\n    void solve(vector<vector<int>> &ans, int i, vector<int>& ip, vector<int> op){\\n        if(ip.size()==i){\\n            ans.push_back(op);\\n            return;\\n        }\\n        solve(ans, i+1, ip, op);        \\n        op.push_back(ip[i]);\\n        solve(ans, i+1, ip, op);\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& ip) {\\n        vector<vector<int>> ans;\\n        vector<int>op;\\n        solve(ans, 0, ip, op);\\n        return ans;\\n        \\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\n    void solve(vector<vector<int>> &ans, int i, vector<int>& ip, vector<int> op){\\n        if(ip.size()==i){\\n            ans.push_back(op);\\n            return;\\n        }\\n        solve(ans, i+1, ip, op);        \\n        op.push_back(ip[i]);\\n        solve(ans, i+1, ip, op);\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& ip) {\\n        vector<vector<int>> ans;\\n        vector<int>op;\\n        solve(ans, 0, ip, op);\\n        return ans;\\n        \\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549657,
                "title": "java-tc-o-n-2-n-sc-o-1-constant-space-iterative-backtracking-solutions",
                "content": "**Constant Space Iterative Solution**\\n```java\\n/**\\n * Constant Space Iterative Solution\\n *\\n * S(n) = (0 \\xD7 (n C 0) + 1 \\xD7 (n C 1) + 2 \\xD7 (n C 2) + \\u2026 + n \\xD7 (n C n))\\n * Note that (n C k) = (n C n-k). Therefore:\\n * S(n) = 0 \\xD7 (n C n) + 1 \\xD7 (n C n-1) + 2 \\xD7 (n C n-2) + \\u2026 + n \\xD7 (n C 0)\\n * If we add these two together, we get\\n * 2S(n) = n \\xD7 (n C 0) + n \\xD7 (n C 1) + \\u2026 + n \\xD7 (n C n)\\n *       = n \\xD7 (n C 0 + n C 1 + \\u2026 + n C n)\\n * As per binomial theorem, (n C 0 + n C 1 + \\u2026 + n C n) = 2^n, so\\n * 2*S(n) = n * 2^n => S(n) = n * 2^(n-1)\\n *\\n * Time Complexity: O(S(N) + n C 0) = O(N * 2^(N-1) + 1) = O(N * 2^N)\\n *\\n * Space Complexity: O(1) (Excluding the result space)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        result.add(new ArrayList<>());\\n        for (int n : nums) {\\n            int size = result.size();\\n            for (int i = 0; i < size; i++) {\\n                List<Integer> temp = new ArrayList<>(result.get(i));\\n                temp.add(n);\\n                result.add(temp);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Backtracking (Recursion). This solution take O(N) space for recursion depth and temp list.**\\n```java\\n/**\\n * Backtracking (Recursion)\\n *\\n * Time Complexity: O(N * 2 ^ N) Refer to above explanation\\n *\\n * Space Complexity: O(N) (Recursion Depth + TempList)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        subsetsHelper(nums, 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void subsetsHelper(int[] nums, int start, List<Integer> temp, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(temp));\\n\\n        for (int i = start; i < nums.length; i++) {\\n            temp.add(nums[i]);\\n            subsetsHelper(nums, i + 1, temp, result);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Subsets questions on LeetCode:\\n- [90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/1549662/Java-or-TC:-O(N*2N)-or-SC:-O(UniqueNums)-or-Space-Optimized-Iterative-and-Backtracking-solutions)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n/**\\n * Constant Space Iterative Solution\\n *\\n * S(n) = (0 \\xD7 (n C 0) + 1 \\xD7 (n C 1) + 2 \\xD7 (n C 2) + \\u2026 + n \\xD7 (n C n))\\n * Note that (n C k) = (n C n-k). Therefore:\\n * S(n) = 0 \\xD7 (n C n) + 1 \\xD7 (n C n-1) + 2 \\xD7 (n C n-2) + \\u2026 + n \\xD7 (n C 0)\\n * If we add these two together, we get\\n * 2S(n) = n \\xD7 (n C 0) + n \\xD7 (n C 1) + \\u2026 + n \\xD7 (n C n)\\n *       = n \\xD7 (n C 0 + n C 1 + \\u2026 + n C n)\\n * As per binomial theorem, (n C 0 + n C 1 + \\u2026 + n C n) = 2^n, so\\n * 2*S(n) = n * 2^n => S(n) = n * 2^(n-1)\\n *\\n * Time Complexity: O(S(N) + n C 0) = O(N * 2^(N-1) + 1) = O(N * 2^N)\\n *\\n * Space Complexity: O(1) (Excluding the result space)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        result.add(new ArrayList<>());\\n        for (int n : nums) {\\n            int size = result.size();\\n            for (int i = 0; i < size; i++) {\\n                List<Integer> temp = new ArrayList<>(result.get(i));\\n                temp.add(n);\\n                result.add(temp);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Backtracking (Recursion)\\n *\\n * Time Complexity: O(N * 2 ^ N) Refer to above explanation\\n *\\n * Space Complexity: O(N) (Recursion Depth + TempList)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        subsetsHelper(nums, 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void subsetsHelper(int[] nums, int start, List<Integer> temp, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(temp));\\n\\n        for (int i = start; i < nums.length; i++) {\\n            temp.add(nums[i]);\\n            subsetsHelper(nums, i + 1, temp, result);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855802,
                "title": "java-backtracking-2-n-100-fast-solution-time-complexity-explained",
                "content": "```\\nclass Solution {\\n    int nums[];\\n    List<List<Integer>> result;\\n    \\n    public List<List<Integer>> subsets(int[] nums) {\\n        this.result=new ArrayList<List<Integer>>();\\n        this.nums=nums;\\n        \\n        compute(0,new ArrayList<Integer>());\\n        return result;\\n    }\\n    \\n    private void compute(int i,ArrayList<Integer> al){\\n        if(i==nums.length){\\n            result.add(new ArrayList<Integer>(al));\\n            return;\\n        }\\n        compute(i+1,al);\\n        al.add(nums[i]);\\n        compute(i+1,al);\\n        al.remove(new Integer(nums[i]));\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/d2f21464-a034-4873-a490-179e24383fa5_1600613703.2150216.png)\\n\\n\\nFor set of n elements, power set will have, 2^n elements.\\n\\nso let\\'s say.. we have elements [1,2,3]\\nso for every number we have a choice, we include that number, or we exclude it..\\n\\nso above approach follows same concept..\\n\\nLook at the image above, \\n1) intially index is 0, and list is empty.. \\n2) so now, element at index 0 have two functions calls, one where 1 is not included in arrayList\\n   and other one where 1 is included..\\n3) now, for level-1\\'s dunction call, index is 1. so again element at index 2, will have those function calls..\\n4) continue same, till the last element. \\n5) when index reaches value n (i.e, processed all elements) \\n   copy the content of list into other arraylist, and insert it into new list.\\n   \\nNOTE: if you have noticed, all lists will be unique.. reason is, this approach creates, exactly 2^n paths from root to leaf nodes and every leaf node represents one list from power set.\\n\\nTime Complexity: \\n1) let\\'s ccreate recurrence relation first.. T(n) = 2*T(n-1) &  if(n=1) T(0)= 1;\\n2) so now, T(n) = 2*2*T(n-2)\\n3) T(n) = (2^2) * T(n-2)\\n4) if we generalize this expression, using k,\\n    T(n) = (2^k) * T(n-k)\\n5) when k=n,\\n    T(n) = 2^n * T(0) and T(0) = 1;\\ntherfore time complexity of above program is, T(n) = 2^n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int nums[];\\n    List<List<Integer>> result;\\n    \\n    public List<List<Integer>> subsets(int[] nums) {\\n        this.result=new ArrayList<List<Integer>>();\\n        this.nums=nums;\\n        \\n        compute(0,new ArrayList<Integer>());\\n        return result;\\n    }\\n    \\n    private void compute(int i,ArrayList<Integer> al){\\n        if(i==nums.length){\\n            result.add(new ArrayList<Integer>(al));\\n            return;\\n        }\\n        compute(i+1,al);\\n        al.add(nums[i]);\\n        compute(i+1,al);\\n        al.remove(new Integer(nums[i]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527606,
                "title": "several-python-solution-w-explanation-demo",
                "content": "Here, we share some solution, including bit serial mapping, element adding, concise DFS, as well as built-in iteration tools in Python.\\n\\nTime Complexity: O( n * 2^n )\\nSpace Complexity: O( n * 2^n )\\n\\n---\\n**Algorithm**:\\n\\n**#1: Bit serial mapping**\\n\\nThe bit serial from 0 to 2^n - 1 can be mapped to element selction for subset generation.\\n\\nTake nums = [1,2,3] for example.\\n\\nsize of input = 3.\\nThus, we go through bit serial from 0 to 2^3 -1 = ( 1 << 3 ) - 1 =  7, then getting corresponding subset on the fly.\\n\\n0 = 0b 000 = empty set = [ ]\\n1 = 0b 00**1** = select first element = [ 1 ]\\n2 = 0b 0**1**0 = select second element = [ 2 ]\\n3 = 0b 0**11** = select first and second elements = [ 1, 2 ]\\n4 = 0b **1**00 = select third element = [ 3 ]\\n5 = 0b **1**0**1** = select first and third elements = [ 1, 3 ]\\n6 = 0b **11**0 = select second and third elements = [ 2, 3 ]\\n7 = 0b **111** = select all elements = [ 1, 2 , 3 ]\\n\\n---\\n\\n**Implementation_#1**:\\nBy bit serial mapping\\n\\n```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n    \\n        size = len(nums)\\n        upper_bound = 1 << size\\n\\t\\t\\n        return [ [ nums[i]  for i in range(size) if bits_sn & (1 << i) != 0 ] for bits_sn in range(upper_bound) ]\\n```\\n\\nor\\n\\n```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n    \\n        size = len(nums)\\n        upper_bound = 1 << size \\n        \\n        all_subset = [ ]\\n        for bits_sn in range(upper_bound):\\n            \\n            cur_subset = []\\n            \\n            for i in range(size):\\n                \\n                if bits_sn & (1 << i) != 0:\\n                    \\n                    cur_subset.append( nums[i] )\\n            \\n            all_subset.append( cur_subset )\\n        \\n        return all_subset\\n```\\n\\n---\\n\\n**#2: Element adding**\\n\\n**Base case** is **empty set**: [ **[ ]**  ]\\nBuild all subsets from base-case in bottom-up, add one element for each iteration.\\n\\nTake nums = [1,2,3] for example.\\n\\nInitialization of solution = [ **[ ]**  ] # empty set\\n\\n1st iteration, add [ **1** ] to current solution\\nsolution = [ [ ], [ **1** ] ]\\n\\n2nd iteration, add [ **2** ] to current solution\\nsolution = [ [ ], [ 1 ], [ **2** ], [ 1, **2** ] ]\\n\\n3rd iteration, add [ **3** ] to current solution\\nsolution = [ [ ], [ 1 ], [ 2 ], [ 1, 2 ], [ **3** ], [ 1, **3** ], [ 2, **3** ], [ 1, 2, **3** ] ]\\n\\nCompleted.\\n\\nAll subsets = [ [ ], [ 1 ], [ 2 ], [ 1, 2 ], [ 3 ], [ 1, 3 ], [ 2, 3 ], [ 1, 2, 3 ] ]\\n\\n---\\n\\n**Implementation_#2**:\\nBy element adding\\n\\n```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n        \\n        # Base case:\\n        solution = [ [] ]\\n        \\n        # General case:\\n        # Generate subset by element adding\\n        for element in nums:\\n            \\n            solution += ( [ current + [ element ] for current in solution ] )\\n            \\n        return solution\\n```\\n\\n---\\n\\n**#3: Concise DFS**\\n\\n---\\n\\n**Implementation_#3**:\\nBy concise DFS\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        solution = []\\n        size = len(nums)\\n        \\n        def dfs(cur, set_len, start_idx):\\n            \\n            if set_len == len(cur):\\n                solution.append( cur[::] )\\n                return\\n            \\n            for j in range(start_idx, size):\\n                \\n                cur.append( nums[j] )\\n                dfs(cur, set_len, j+1)\\n                cur.pop()\\n        #------------------------------------------\\n        \\n        for set_len in range(0, size+1):\\n            dfs(cur=[], set_len=set_len, start_idx=0)\\n        \\n        return solution\\n```\\n\\n---\\n\\n**#4: Built-in iteration tools in Python**\\n\\nLet size = *n* denote the length of input array\\n\\nAll subset \\n= subset of no element, subset of 1 element, subset of 2 element,... subset of n elements\\n= cases of C( *n*, 0) + cases of C( *n*, 1) + cases of C( *n*, 2) + ... + cases of C( *n*, *n* )\\n= 2^n cases in total\\n\\nPython have **built-in tool** to generate **Combination** of given list and *k*, *k* is from 1 to *n*. Its syntax is as following:\\n\\nitertools.combinations( *iterable* , *k* )\\n\\nExample:\\ncombinations(\\'ABCD\\', 2) --> AB AC AD BC BD CD\\n\\n---\\n\\n**Implementation_#4**:\\nBy built-in iteration tools in Python\\n\\n```\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def subsets(self, nums):\\n        \\n        solution, size = [], len(nums)\\n        \\n        for k in range(size+1):\\n            \\n            solution += [ list(comb) for comb in combinations(nums, k) ]\\n        \\n        return solution\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #90 Subset II](https://leetcode.com/problems/subsets-ii/)\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about bitwise shift operator <<, >>](https://docs.python.org/3/reference/expressions.html#shifting-operations)\\n\\n[2] [Python official docs about list comprehension [ ... ]](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)\\n\\n[3] [Python official docs about itertools.combination( )](https://docs.python.org/3.8/library/itertools.html#itertools.combinations)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n    \\n        size = len(nums)\\n        upper_bound = 1 << size\\n\\t\\t\\n        return [ [ nums[i]  for i in range(size) if bits_sn & (1 << i) != 0 ] for bits_sn in range(upper_bound) ]\\n```\n```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n    \\n        size = len(nums)\\n        upper_bound = 1 << size \\n        \\n        all_subset = [ ]\\n        for bits_sn in range(upper_bound):\\n            \\n            cur_subset = []\\n            \\n            for i in range(size):\\n                \\n                if bits_sn & (1 << i) != 0:\\n                    \\n                    cur_subset.append( nums[i] )\\n            \\n            all_subset.append( cur_subset )\\n        \\n        return all_subset\\n```\n```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n        \\n        # Base case:\\n        solution = [ [] ]\\n        \\n        # General case:\\n        # Generate subset by element adding\\n        for element in nums:\\n            \\n            solution += ( [ current + [ element ] for current in solution ] )\\n            \\n        return solution\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        solution = []\\n        size = len(nums)\\n        \\n        def dfs(cur, set_len, start_idx):\\n            \\n            if set_len == len(cur):\\n                solution.append( cur[::] )\\n                return\\n            \\n            for j in range(start_idx, size):\\n                \\n                cur.append( nums[j] )\\n                dfs(cur, set_len, j+1)\\n                cur.pop()\\n        #------------------------------------------\\n        \\n        for set_len in range(0, size+1):\\n            dfs(cur=[], set_len=set_len, start_idx=0)\\n        \\n        return solution\\n```\n```\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def subsets(self, nums):\\n        \\n        solution, size = [], len(nums)\\n        \\n        for k in range(size+1):\\n            \\n            solution += [ list(comb) for comb in combinations(nums, k) ]\\n        \\n        return solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187733,
                "title": "backtrack-template-make-backtracking-easy",
                "content": "Here is my summary about Backtracking Template:\\n[Never be stuck by Backtracking Problem -- Backtracking problem Template](https://leetcode.com/problems/palindrome-partitioning/discuss/182307/Java:-Backtracking-Template-General-Approach)\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        // Backtracking\\n        // Edge case\\n        if(nums == null || nums.length == 0) return new ArrayList<>();\\n        \\n        List<Integer> step = new ArrayList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        helper(nums, 0, step, result);\\n        return result;\\n    }\\n    public void helper(int[] nums, int start, List<Integer> step, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(step));\\n        for(int i = start; i < nums.length; i++) {\\n            // choose\\n            step.add(nums[i]);\\n            // explore\\n            helper(nums, i + 1, step, result);\\n            // unchoose\\n            step.remove(step.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        // Backtracking\\n        // Edge case\\n        if(nums == null || nums.length == 0) return new ArrayList<>();\\n        \\n        List<Integer> step = new ArrayList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        helper(nums, 0, step, result);\\n        return result;\\n    }\\n    public void helper(int[] nums, int start, List<Integer> step, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(step));\\n        for(int i = start; i < nums.length; i++) {\\n            // choose\\n            step.add(nums[i]);\\n            // explore\\n            helper(nums, i + 1, step, result);\\n            // unchoose\\n            step.remove(step.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768746,
                "title": "python3-o-n-2-n-3-line-solution",
                "content": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans=[[]]\\n        for j in nums:\\n            ans+=[i+[j] for i in ans]\\n        return ans\\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans=[[]]\\n        for j in nums:\\n            ans+=[i+[j] for i in ans]\\n        return ans\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27550,
                "title": "very-simple-and-fast-java-solution-with-explanation",
                "content": "\\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 0, nums);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int[] n) {\\n        if (pos <= n.length) {\\n            res.add(each);\\n        }\\n        for (int i = pos; i < n.length; i++) {\\n            each.add(n[i]);\\n            helper(res, new ArrayList<>(each), i + 1, n);\\n            each.remove(each.size() - 1);\\n        }\\n        return;\\n    }\\n\\n\\n----------\\nThe idea is use pos to keep track of the index of the array. Compare to other backracking problem like combinations, the condition that each single List adds to the List<List<Integer>> is when the index of the array is valid. Meanwhile, after adding to the List<List<Integer>> , keeping going for the for loop.\\n\\n\\n----------\\nthe following is the combinations I wrote, which is very similar to this problem.\\n\\n        public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 1, n, k);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int n, int k) {\\n        if (each.size() == k) {\\n            res.add(each);\\n            return;\\n        }\\n        for (int i = pos; i <= n; i++) {\\n            each.add(i);\\n            helper(res, new ArrayList<>(each), i + 1, n, k);\\n            each.remove(each.size() - 1);\\n        }\\n        return;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 0, nums);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int[] n) {\\n        if (pos <= n.length) {\\n            res.add(each);\\n        }\\n        for (int i = pos; i < n.length; i++) {\\n            each.add(n[i]);\\n            helper(res, new ArrayList<>(each), i + 1, n);\\n            each.remove(each.size() - 1);\\n        }\\n        return;\\n    }\\n\\n\\n----------\\nThe idea is use pos to keep track of the index of the array. Compare to other backracking problem like combinations, the condition that each single List adds to the List<List<Integer>> is when the index of the array is valid. Meanwhile, after adding to the List<List<Integer>> , keeping going for the for loop.\\n\\n\\n----------\\nthe following is the combinations I wrote, which is very similar to this problem.\\n\\n        public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 1, n, k);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int n, int k) {\\n        if (each.size() == k) {\\n            res.add(each);\\n            return;\\n        }\\n        for (int i = pos; i <= n; i++) {\\n            each.add(i);\\n            helper(res, new ArrayList<>(each), i + 1, n, k);\\n            each.remove(each.size() - 1);\\n        }\\n        return;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2418147,
                "title": "c-explained-beats-100-optimized-tc-o-2-n",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Time complexity: O(2^n)**\\n**Space complexity: O(n)**\\n\\n**Approach:**\\n* Subsets can be determined by trying different combinations, so we will use recursion here.\\n* Case1: exclude the element then include the element.\\n* Case2: include the element then exclude the element.\\n* Either of the cases can be used to solve this problem.\\n\\n**Case1:**\\n```\\nclass Solution {\\nprivate:\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int>>& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        \\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n\\n**Case2:**\\n```\\nclass Solution {\\nprivate:\\n    void subset_finder(vector<int>& nums, int index, vector<int> one_subset, vector<vector<int>> &ans)\\n    {\\n        // base case\\n        if(index>=nums.size())\\n        {\\n            ans.push_back(one_subset);\\n            return;\\n        }\\n        // take\\n        one_subset.push_back(nums[index]);\\n        subset_finder(nums, index+1, one_subset, ans);\\n        \\n        // not take\\n\\t\\t// backtracking\\n        one_subset.pop_back();\\n        subset_finder(nums, index+1, one_subset, ans);\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> one_subset;\\n        int index = 0;\\n        subset_finder(nums, index, one_subset, ans);\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int>>& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        \\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    void subset_finder(vector<int>& nums, int index, vector<int> one_subset, vector<vector<int>> &ans)\\n    {\\n        // base case\\n        if(index>=nums.size())\\n        {\\n            ans.push_back(one_subset);\\n            return;\\n        }\\n        // take\\n        one_subset.push_back(nums[index]);\\n        subset_finder(nums, index+1, one_subset, ans);\\n        \\n        // not take\\n\\t\\t// backtracking\\n        one_subset.pop_back();\\n        subset_finder(nums, index+1, one_subset, ans);\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> one_subset;\\n        int index = 0;\\n        subset_finder(nums, index, one_subset, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489255,
                "title": "javascript-backtracking",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsets = function(nums) {\\n    let result = [[]];\\n    \\n    function backtrack(first, current) {\\n    // we iterate over the indexes i from \\'first\\' to the length\\n    //of the entire sequence \\'nums\\'\\n    for (let i = first; i < nums.length; i++) {\\n        current.push(nums[i]);\\n\\n        // use distructure operator to clone \\'current\\' value and save to \\'result\\'\\n        result.push([...current]);\\n\\n        // generate all other subsets for the current subset.\\n        // increasing the position by one to avoid duplicates in \\'result\\'\\n        backtrack(i + 1, current);\\n\\n        // BACKTRACK.\\n        current.pop();\\n    }\\n}\\n    \\n    backtrack(0, []);\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsets = function(nums) {\\n    let result = [[]];\\n    \\n    function backtrack(first, current) {\\n    // we iterate over the indexes i from \\'first\\' to the length\\n    //of the entire sequence \\'nums\\'\\n    for (let i = first; i < nums.length; i++) {\\n        current.push(nums[i]);\\n\\n        // use distructure operator to clone \\'current\\' value and save to \\'result\\'\\n        result.push([...current]);\\n\\n        // generate all other subsets for the current subset.\\n        // increasing the position by one to avoid duplicates in \\'result\\'\\n        backtrack(i + 1, current);\\n\\n        // BACKTRACK.\\n        current.pop();\\n    }\\n}\\n    \\n    backtrack(0, []);\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 827202,
                "title": "best-java-fastest-solution-0ms-100-faster-and-98-3-less-space",
                "content": "\\nits works on concept of taking the item and ignoring the item at each step\\n\\n```\\n public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> ll=new ArrayList<>();\\n        generate(nums,0,new ArrayList<>(),ll);\\n        return ll;\\n    }\\n    public void generate(int[] nums,int i,List<Integer> ls,List<List<Integer>> ll){\\n        if(i==nums.length){\\n            ll.add(new ArrayList(ls));\\n            return;\\n        }\\n        generate(nums,i+1,ls,ll);\\n        ls.add(nums[i]);\\n        generate(nums,i+1,ls,ll);\\n        ls.remove(ls.size()-1);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> ll=new ArrayList<>();\\n        generate(nums,0,new ArrayList<>(),ll);\\n        return ll;\\n    }\\n    public void generate(int[] nums,int i,List<Integer> ls,List<List<Integer>> ll){\\n        if(i==nums.length){\\n            ll.add(new ArrayList(ls));\\n            return;\\n        }\\n        generate(nums,i+1,ls,ll);\\n        ls.add(nums[i]);\\n        generate(nums,i+1,ls,ll);\\n        ls.remove(ls.size()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 159942,
                "title": "python3-backtracking-no-loops-very-easy-to-understand",
                "content": "I\\'m a beginner, so I learned about backtracking from a Stanford lecture on youtube. Most python solutions on here used loops, which initially was hard for me to understand. \\n\\nBasically, the idea here is that you\\'re \"choosing\" an element, running the helper *including* the element (which gets all possible sublists with the \"chosen\" one), then running the helper again *not including* the chosen one.\\n\\n*sidenote*: In the helper, I appended a copy of the aux list. If you pass in the reference, your result will have all empty sublists.\\n```\\nclass Solution:\\n    def subsets(self, nums):\\n        res = []\\n        self.helper(nums, 0, res, [])\\n        return res\\n    \\n    def helper(self, nums, idx, res, aux):\\n        if idx == len(nums):\\n            res.append(aux.copy())\\n            return\\n        aux.append(nums[idx])\\n        self.helper(nums, idx + 1, res, aux)\\n        aux.pop()\\n        self.helper(nums, idx + 1, res, aux)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums):\\n        res = []\\n        self.helper(nums, 0, res, [])\\n        return res\\n    \\n    def helper(self, nums, idx, res, aux):\\n        if idx == len(nums):\\n            res.append(aux.copy())\\n            return\\n        aux.append(nums[idx])\\n        self.helper(nums, idx + 1, res, aux)\\n        aux.pop()\\n        self.helper(nums, idx + 1, res, aux)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27604,
                "title": "not-sure-if-this-is-the-best-solution-using-java",
                "content": "    public List<List<Integer>> subsets(int[] S) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        res.add(new ArrayList<Integer>());\\n        Arrays.sort(S);\\n        for(int i = S.length - 1; i >= 0; i--){\\n            int size = res.size() - 1;\\n            for(int j = size; j >= 0; j--){\\n                List<Integer> newList1 = new ArrayList<>();\\n                newList1.add(S[i]);\\n                newList1.addAll(res.get(j));\\n                res.add(newList1);\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    public List<List<Integer>> subsets(int[] S) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        res.add(new ArrayList<Integer>());\\n        Arrays.sort(S);\\n        for(int i = S.length - 1; i >= 0; i--){\\n            int size = res.size() - 1;\\n            for(int j = size; j >= 0; j--){\\n                List<Integer> newList1 = new ArrayList<>();\\n                newList1.add(S[i]);\\n                newList1.addAll(res.get(j));\\n                res.add(newList1);\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1333022,
                "title": "c-simple-and-short-solution-no-recursion-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250619,
                "title": "javascript-solution",
                "content": "```\\nvar subsets = function(nums) {\\n    let res = [[]]\\n    for (let i = 0; i < nums.length; ++i) {\\n  \\t\\tlet length = res.length;\\n\\t\\tfor (let j = 0; j < length; ++j) {\\n\\t\\t\\tres.push([...res[j],nums[i]])\\n        }  \\n   }\\n   return res\\n };\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subsets = function(nums) {\\n    let res = [[]]\\n    for (let i = 0; i < nums.length; ++i) {\\n  \\t\\tlet length = res.length;\\n\\t\\tfor (let j = 0; j < length; ++j) {\\n\\t\\t\\tres.push([...res[j],nums[i]])\\n        }  \\n   }\\n   return res\\n };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27522,
                "title": "haven-t-see-dp-solution-here-it-is",
                "content": "\\nFor this question, DP or recursive or backtrack what ever, I think it's almost same thing,but let's do it in a pure DP way:\\n        \\n1 Start from only 1 dig in the list, then result is obvious, [[],[nums[0]]]\\n        \\n2 Than for each new dig, the result is the previous list + previous list append the new dig,\\n          it's easy to understand, since once the new dig come in, there is 2 options, with it or with out it.\\n          without it, is the previous result, with it, it  to add this dig in each array of the previuos result\\n    \\n\\n    def subnets(nums):\\n        nums.sort()\\n        dp={}\\n        dp[0]=[[],[nums[0]] ] \\n        \\n        for i in range(1,len(nums)):\\n            dp[i]=dp[i-1]+[x+[nums[i]] for x in dp[i-1]]\\n        return dp[len(nums)-1]",
                "solutionTags": [],
                "code": "\\nFor this question, DP or recursive or backtrack what ever, I think it's almost same thing,but let's do it in a pure DP way:\\n        \\n1 Start from only 1 dig in the list, then result is obvious, [[],[nums[0]]]\\n        \\n2 Than for each new dig, the result is the previous list + previous list append the new dig,\\n          it's easy to understand, since once the new dig come in, there is 2 options, with it or with out it.\\n          without it, is the previous result, with it, it  to add this dig in each array of the previuos result\\n    \\n\\n    def subnets(nums):\\n        nums.sort()\\n        dp={}\\n        dp[0]=[[],[nums[0]] ] \\n        \\n        for i in range(1,len(nums)):\\n            dp[i]=dp[i-1]+[x+[nums[i]] for x in dp[i-1]]\\n        return dp[len(nums)-1]",
                "codeTag": "Python3"
            },
            {
                "id": 27543,
                "title": "simple-java-solution-using-bit-operations",
                "content": "    public class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int n = nums.length;\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        for (int i = 0; i < Math.pow(2, n); i++)\\n        {\\n            List<Integer> subset = new ArrayList<>();\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (((1 << j) & i) != 0)\\n                    subset.add(nums[j]);\\n            }\\n            Collections.sort(subset);\\n            subsets.add(subset);\\n        }\\n        return subsets;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int n = nums.length;\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        for (int i = 0; i < Math.pow(2, n); i++)\\n        {\\n            List<Integer> subset = new ArrayList<>();\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (((1 << j) & i) != 0)\\n                    subset.add(nums[j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1768235,
                "title": "python-recursion-dfs-backtractking-easy-to-understand",
                "content": "**Approach:**\\n1.  If index reaches to the end that means we have covered all the values in the set.\\n2.  We simply leave the value and move to the next position once.\\n3.  We add the value to subSet and then move to next position.\\nFinally, we get powerset with all the unique subsets.\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n, result = len(nums), []\\n        def powerSet(nums, i, subSet): \\n            if i==n:\\n                result.append(subSet) \\n                return \\n            powerSet(nums, i+1, subSet) \\n            powerSet(nums, i+1, subSet + [nums[i]]) \\n        powerSet(nums, 0, [])\\n        return result \\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n, result = len(nums), []\\n        def powerSet(nums, i, subSet): \\n            if i==n:\\n                result.append(subSet) \\n                return \\n            powerSet(nums, i+1, subSet) \\n            powerSet(nums, i+1, subSet + [nums[i]]) \\n        powerSet(nums, 0, [])\\n        return result \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767500,
                "title": "c-backtracking-recursion-two-approaches",
                "content": "***Brief note about Question-***\\n* We have to return *all possible subsets (the power set).*\\n```\\nLets take an example which is not given in the question-\\nsuppose array is given arr[]: [7,4,5]\\n\\nso, the answer should be \\n[[],[7],[4],[4,7],[5],[5,7],[4,5],[4,5,7]]\\n```\\n________\\n***Solution - I (Backtracking, Accepted)-***\\n```\\nclass Solution {\\npublic:\\n    // it is use to store answer\\n    vector<vector<int>> ans;\\n    \\n    // solve function for generating answer\\n    void solve(int i, vector<int>&arr, vector<int>&temp)\\n    {\\n        if(i == arr.size()) // if index reaches the size of the array \\n        {\\n            //if we find out a possibility, push it into the answer array\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        // taking ith element\\n        temp.push_back(arr[i]);\\n        \\n        // call for the next index\\n        solve(i + 1, arr, temp);\\n        \\n        // not taking ith ele,so first pop that already pushed ele, and then call for next index and generating the next possibility\\n        temp.pop_back();\\n        \\n        // calling for next index\\n        solve(i + 1, arr, temp);\\n        \\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        ans.clear(); // clear global array\\n        \\n        vector<int> temp; // temporary array for generating answer\\n        solve(0, arr, temp); // generating all possibility\\n        \\n        return ans;\\n    }\\n};\\n```\\n__________\\n***Solution - II (Accepted)-***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // to store answer\\n    \\n    void solve(vector<int> &arr, int i, vector<int> temp)\\n    {\\n        if(i == arr.size()) // if we find out one possibility\\n        {\\n            //push into the final answer that possibility\\n            ans.push_back(temp); \\n            return;\\n        }\\n        \\n        solve(arr, i + 1, temp); // finding possibility for next index\\n        \\n        temp.push_back(arr[i]); // push into the array\\n        \\n        solve(arr, i + 1, temp); //again finding out the next possibility\\n        \\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n         vector<int> temp; // vector to store temporary answer\\n        \\n        solve(arr, 0, temp); // function that will generate our final answer\\n        \\n        return ans; // return the final answer\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLets take an example which is not given in the question-\\nsuppose array is given arr[]: [7,4,5]\\n\\nso, the answer should be \\n[[],[7],[4],[4,7],[5],[5,7],[4,5],[4,5,7]]\\n```\n```\\nclass Solution {\\npublic:\\n    // it is use to store answer\\n    vector<vector<int>> ans;\\n    \\n    // solve function for generating answer\\n    void solve(int i, vector<int>&arr, vector<int>&temp)\\n    {\\n        if(i == arr.size()) // if index reaches the size of the array \\n        {\\n            //if we find out a possibility, push it into the answer array\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        // taking ith element\\n        temp.push_back(arr[i]);\\n        \\n        // call for the next index\\n        solve(i + 1, arr, temp);\\n        \\n        // not taking ith ele,so first pop that already pushed ele, and then call for next index and generating the next possibility\\n        temp.pop_back();\\n        \\n        // calling for next index\\n        solve(i + 1, arr, temp);\\n        \\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        ans.clear(); // clear global array\\n        \\n        vector<int> temp; // temporary array for generating answer\\n        solve(0, arr, temp); // generating all possibility\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // to store answer\\n    \\n    void solve(vector<int> &arr, int i, vector<int> temp)\\n    {\\n        if(i == arr.size()) // if we find out one possibility\\n        {\\n            //push into the final answer that possibility\\n            ans.push_back(temp); \\n            return;\\n        }\\n        \\n        solve(arr, i + 1, temp); // finding possibility for next index\\n        \\n        temp.push_back(arr[i]); // push into the array\\n        \\n        solve(arr, i + 1, temp); //again finding out the next possibility\\n        \\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n         vector<int> temp; // vector to store temporary answer\\n        \\n        solve(arr, 0, temp); // function that will generate our final answer\\n        \\n        return ans; // return the final answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651200,
                "title": "c-iterative-generate-next-subset-based-on-previous-subsets",
                "content": "Start with empty subset, and for each of existing subsets, create the copy and add next num to it.\\n\\n```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{        \\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tresult.Add(new List<int>());\\n\\n\\tforeach(var num in nums)\\n\\t{\\n\\t\\tint currentCount = result.Count;\\n\\t\\tfor(int i = 0; i < currentCount; i++)\\n\\t\\t{\\n\\t\\t\\tList<int> subset = result[i].ToList();\\n\\t\\t\\tsubset.Add(num);\\n\\t\\t\\tresult.Add(subset);                \\n\\t\\t}            \\n\\t}\\n\\n\\treturn result;\\n}\\n```\\n\\nUsing bit mask\\n```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{\\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tint size = (int) Math.Pow(2, nums.Length);\\n\\n\\tfor(int i = 0; i < size; i++)\\n\\t{\\n\\t\\tList<int> subset = new List<int>();\\n\\t\\tfor(int j = 0; j < nums.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif((i & (1 << j)) != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsubset.Add(nums[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.Add(subset);\\n\\t}\\n\\n\\treturn result;\\n}\\n```\\n\\nAlso, recursive solution:\\n```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{       \\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tList<int> currentList = new List<int>();\\n\\thelper(nums, result, currentList, 0);\\n\\treturn result;\\n}\\n\\nprivate void helper(int[] nums, IList<IList<int>> result, List<int> currentList, int start)\\n{\\n\\tresult.Add(currentList.ToList());\\n\\tfor(int i = start; i < nums.Length; i++)\\n\\t{\\n\\t\\tcurrentList.Add(nums[i]); \\n\\t\\thelper(nums, result, currentList, i + 1);\\n\\t\\tcurrentList.RemoveAt(currentList.Count - 1);\\n\\t}\\n} \\n```\\n",
                "solutionTags": [
                    "Recursion",
                    "Iterator"
                ],
                "code": "```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{        \\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tresult.Add(new List<int>());\\n\\n\\tforeach(var num in nums)\\n\\t{\\n\\t\\tint currentCount = result.Count;\\n\\t\\tfor(int i = 0; i < currentCount; i++)\\n\\t\\t{\\n\\t\\t\\tList<int> subset = result[i].ToList();\\n\\t\\t\\tsubset.Add(num);\\n\\t\\t\\tresult.Add(subset);                \\n\\t\\t}            \\n\\t}\\n\\n\\treturn result;\\n}\\n```\n```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{\\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tint size = (int) Math.Pow(2, nums.Length);\\n\\n\\tfor(int i = 0; i < size; i++)\\n\\t{\\n\\t\\tList<int> subset = new List<int>();\\n\\t\\tfor(int j = 0; j < nums.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif((i & (1 << j)) != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsubset.Add(nums[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.Add(subset);\\n\\t}\\n\\n\\treturn result;\\n}\\n```\n```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{       \\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tList<int> currentList = new List<int>();\\n\\thelper(nums, result, currentList, 0);\\n\\treturn result;\\n}\\n\\nprivate void helper(int[] nums, IList<IList<int>> result, List<int> currentList, int start)\\n{\\n\\tresult.Add(currentList.ToList());\\n\\tfor(int i = start; i < nums.Length; i++)\\n\\t{\\n\\t\\tcurrentList.Add(nums[i]); \\n\\t\\thelper(nums, result, currentList, i + 1);\\n\\t\\tcurrentList.RemoveAt(currentList.Count - 1);\\n\\t}\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27466,
                "title": "java-concise-recursive-solution",
                "content": "        \\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> ret = new ArrayList<>();\\n        dfs(nums, 0, new ArrayList<>(), ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(int[] nums, int idx, List<Integer> path, List<List<Integer>> ret) {\\n        ret.add(path);\\n        for (int i = idx; i < nums.length; i++) {\\n            List<Integer> p = new ArrayList<>(path);\\n            p.add(nums[i]);\\n            dfs(nums, i+1, p, ret);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "        \\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> ret = new ArrayList<>();\\n        dfs(nums, 0, new ArrayList<>(), ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(int[] nums, int idx, List<Integer> path, List<List<Integer>> ret) {\\n        ret.add(path);\\n        for (int i = idx; i < nums.length; i++) {\\n            List<Integer> p = new ArrayList<>(path);\\n            p.add(nums[i]);\\n            dfs(nums, i+1, p, ret);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2216391,
                "title": "python-most-concise-recursive-and-iterative-backtracking-with-explanations",
                "content": "I think that an iterative solution is more intuitive for beginners because you can easily debug it step by step and understand what is going on. \\n\\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n        # create list for storing subsets\\n        ans = []\\n        \\n\\t\\t# initialize stack with empty subset and next position equal to 0\\n        stack = [(0,[])]\\n        \\n        while stack:\\n            \\n\\t\\t\\t# retrieve last subset in a stack and its\\' corresponding next position\\n            next_pos, subset = stack.pop()\\n\\t\\t\\t\\n\\t\\t\\t# save current subset\\n            ans.append(subset)\\n            \\n\\t\\t\\t# append each available element starting from next position\\n\\t\\t\\t# to the current subset and append it to the stack increasing next \\n\\t\\t\\t# position by one\\n            for i in range(next_pos,len(nums)):\\n                stack.append((i+1,subset+[nums[i]]))\\n        \\n        return ans\\n```\\nRecursive solution is absolutely the same, but instead of using stack explicitly it uses the call stack.\\n\\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        ans = []\\n        \\n        def dfs(next_pos,subset):\\n            \\n            ans.append(subset)\\n            \\n            for i in range(next_pos,len(nums)):\\n                \\n                dfs(i+1,subset+[nums[i]])\\n        \\n        dfs(0,[])\\n        \\n        return ans\\n```\\nAnd also, to understand all these backtracking problems you should draw it: draw a corresponding tree of choices and you will understand it faster.",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Stack",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n        # create list for storing subsets\\n        ans = []\\n        \\n\\t\\t# initialize stack with empty subset and next position equal to 0\\n        stack = [(0,[])]\\n        \\n        while stack:\\n            \\n\\t\\t\\t# retrieve last subset in a stack and its\\' corresponding next position\\n            next_pos, subset = stack.pop()\\n\\t\\t\\t\\n\\t\\t\\t# save current subset\\n            ans.append(subset)\\n            \\n\\t\\t\\t# append each available element starting from next position\\n\\t\\t\\t# to the current subset and append it to the stack increasing next \\n\\t\\t\\t# position by one\\n            for i in range(next_pos,len(nums)):\\n                stack.append((i+1,subset+[nums[i]]))\\n        \\n        return ans\\n```\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        ans = []\\n        \\n        def dfs(next_pos,subset):\\n            \\n            ans.append(subset)\\n            \\n            for i in range(next_pos,len(nums)):\\n                \\n                dfs(i+1,subset+[nums[i]])\\n        \\n        dfs(0,[])\\n        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1918862,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var res: [[Int]] = []\\n\\n\\n        func backtrack(_ path: [Int], _ max: Int, _ target: Int) {\\n            if target == 0 {\\n                res.append([])\\n                return\\n            }\\n            \\n            if path.count == target {\\n                res.append(path.map({ nums[$0] }))\\n                return\\n            }\\n            \\n            var path = path\\n            \\n            for index in max+1..<nums.count {\\n                path.append(index)\\n                backtrack(path, index, target)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        for i in 0...nums.count {\\n            backtrack([], -1, i)\\n        }\\n        \\n        return res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var res: [[Int]] = []\\n\\n\\n        func backtrack(_ path: [Int], _ max: Int, _ target: Int) {\\n            if target == 0 {\\n                res.append([])\\n                return\\n            }\\n            \\n            if path.count == target {\\n                res.append(path.map({ nums[$0] }))\\n                return\\n            }\\n            \\n            var path = path\\n            \\n            for index in max+1..<nums.count {\\n                path.append(index)\\n                backtrack(path, index, target)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        for i in 0...nums.count {\\n            backtrack([], -1, i)\\n        }\\n        \\n        return res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957648,
                "title": "python-4-lines-iterative-recursive-mapping-bits",
                "content": "Iterative\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = [[]]\\n        for n in nums:\\n            subsets += [s + [n] for s in subsets]        \\n        return subsets\\n```\\nRecursive\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        if not nums:\\n            return [[]]\\n        without = self.subsets(nums[1:])\\n        return without + [s + [nums[0]] for s in without]\\n```\\nMapping bits\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = []\\n        for n in range(2**len(nums)):            \\n            subsets.append([nums[i] for i, c in enumerate(bin(n)[:1:-1]) if c == \\'1\\'])\\n        return subsets\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = [[]]\\n        for n in nums:\\n            subsets += [s + [n] for s in subsets]        \\n        return subsets\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        if not nums:\\n            return [[]]\\n        without = self.subsets(nums[1:])\\n        return without + [s + [nums[0]] for s in without]\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = []\\n        for n in range(2**len(nums)):            \\n            subsets.append([nums[i] for i, c in enumerate(bin(n)[:1:-1]) if c == \\'1\\'])\\n        return subsets\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27337,
                "title": "simple-fast-and-short-swift-solution-beat-97-3",
                "content": "Add one integer every time. Not only add to ans array, but add a integer to ans array 's element. For example,\\ninput = [1,2,3] \\nAdd a number 1:\\nans = [ [1] ]\\nand add a number 2:\\nans = [ [1], [1,2], [2] ]\\nand add a number 3:\\nans = [ [1], [1,2], [2], [1,3], [1,2,3], [2,3], [3] ]    \\n\\n```\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var ans:[[Int]] = []\\n        for i in 0..<nums.count{\\n            for j in 0..<ans.count{\\n                var temp = ans[j]\\n                temp.append(nums[i])\\n                ans.append(temp)\\n            }\\n            ans.append([nums[i]])\\n        }\\n        ans.append([])\\n        return ans\\n    }",
                "solutionTags": [
                    "Swift"
                ],
                "code": "Add one integer every time. Not only add to ans array, but add a integer to ans array 's element. For example,\\ninput = [1,2,3] \\nAdd a number 1:\\nans = [ [1] ]\\nand add a number 2:\\nans = [ [1], [1,2], [2] ]\\nand add a number 3:\\nans = [ [1], [1,2], [2], [1,3], [1,2,3], [2,3], [3] ]    \\n\\n```\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var ans:[[Int]] = []\\n        for i in 0..<nums.count{\\n            for j in 0..<ans.count{\\n                var temp = ans[j]\\n                temp.append(nums[i])\\n                ans.append(temp)\\n            }\\n            ans.append([nums[i]])\\n        }\\n        ans.append([])\\n        return ans\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 27536,
                "title": "4ms-c-solution-using-recursion",
                "content": "    class Solution {\\n    public:\\n    \\tvoid f(vector<int>& temp,vector<vector<int>>&result,int i,vector<int>& nums){\\n    \\t\\tif(i==nums.size()){\\n    \\t\\t\\tresult.push_back(temp);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\ttemp.push_back(nums[i]);\\n    \\t\\tf(temp,result,i+1,nums);\\n    \\t\\ttemp.pop_back();\\n    \\t\\tf(temp,result,i+1,nums);\\n    \\t\\treturn;\\n    \\t}\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            sort(nums.begin(),nums.end());\\n            vector<int> temp;\\n    \\t\\tvector<vector<int>>result;\\n    \\t\\tf(temp,result,0,nums);\\n    \\t\\treturn result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tvoid f(vector<int>& temp,vector<vector<int>>&result,int i,vector<int>& nums){\\n    \\t\\tif(i==nums.size()){\\n    \\t\\t\\tresult.push_back(temp);\\n    \\t\\t\\treturn;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 27546,
                "title": "share-my-recursive-solution",
                "content": "I am a big recursive person. And I would like to think everything in a recursive way. \\n\\nFor the case of this problem, using a loop seems definitely to be a more elegant solution. But I would still like to share my recursive solution with you guys.\\n\\nI make recursive call trying to go over the vector from left to right. For each number in vector, it has to options: show in the subset, or not show in the subset. There for each recursive call will generate two more recursive calls. And in the base case, we add the vector to result set. \\n\\nHope you liked my solution.\\n\\n    class Solution {\\n    public:\\n        void subsets_helper(vector<int> tmpVec, vector<vector<int>>& result, vector<int>& S, int level){\\n            if(level==0) result.push_back(tmpVec);\\n            else{\\n                vector<int> newVec0 = tmpVec; newVec0.push_back(S[S.size()-level]);\\n                vector<int> newVec1 = tmpVec;\\n                subsets_helper(newVec0, result, S, level-1);\\n                subsets_helper(newVec1, result, S, level-1);\\n            }\\n        }\\n    \\n        vector<vector<int> > subsets(vector<int> &S) {\\n            sort(S.begin(), S.end());\\n            vector<vector<int>> result;\\n            vector<int> tmpVec;\\n            subsets_helper(tmpVec, result, S, S.size());\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void subsets_helper(vector<int> tmpVec, vector<vector<int>>& result, vector<int>& S, int level){\\n            if(level==0) result.push_back(tmpVec);\\n            else{\\n                vector<int> newVec0 = tmpVec; newVec0.push_back(S[S.size()-level]);\\n                vector<int> newVec1 = tmpVec;\\n                subsets_helper(newVec0, result, S, level-1);\\n                subsets_helper(newVec1, result, S, level-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3088930,
                "title": "simple-c-using-bitmask-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>>ans;\\n        for(int i=0;i<(1<<n);i++){\\n            vector<int>temp;\\n           for(int j=0;j<n;j++){\\n              if(i&(1<<j))temp.push_back(arr[j]);\\n           }\\n           ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>>ans;\\n        for(int i=0;i<(1<<n);i++){\\n            vector<int>temp;\\n           for(int j=0;j<n;j++){\\n              if(i&(1<<j))temp.push_back(arr[j]);\\n           }\\n           ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739067,
                "title": "python-java-js-c-by-dfs-backtracking-w-demo",
                "content": "[\\u4E2D\\u6587\\u8A73\\u89E3 \\u89E3\\u8AAA\\u5F71\\u7247\\nTutorial video in Chinese](https://www.youtube.com/watch?v=ITwWVCfLgug&t=0s)\\n\\n**Hint**\\n\\nWhen it comes to **subset**, **combination**, **permutation**, **tree path sum**, think of **DFS+backtracking**.\\n\\n\\nTime Complexity: O( n * 2^n )\\nSpace Complexity: O( n * 2^n )\\n\\n\\n---\\n\\nReview of DFS + backtracking template\\n\\n```\\n\\ndef backtrack( parameter ):\\n\\n\\t# Base case handle, aka stop condition\\n\\tif stop condition:\\n\\t\\t# save valid result if needed\\n\\t\\treturn\\n\\t\\t\\n\\t\\n\\t# General cases handle:\\n\\tfor each possible next move/next selection:\\n\\t\\t\\n\\t\\tmake a next move/ select a element\\n\\t\\n\\t\\tbacktrack( updated parameter )\\n\\t\\t\\n\\t\\troll back / undo selection\\n\\t\\t\\n\\treturn\\n```\\n\\n---\\n\\n**Demo of subset generation with input = [1, 2, 3]**\\n\\n<img src=\"https://i.imgur.com/FrdBKKY.png\">\\n\\n---\\n\\n**Python**\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        \\n        all_subset = []\\n        bag = []\\n        \\n        \\n        def makeSubsetFrom( startIndex ):\\n            \\n            # Add current subset into final result\\n            # Note: python object is passing by reference, so we have to make a copy\\n            all_subset.append( bag[::] )\\n            \\n            \\n            ## Base cases aka stop condition:\\n            # No more element\\n            if startIndex == len(nums):\\n                return\\n            \\n            ## General cases\\n            # Current level, we choouse element on index i\\n            for i in range(startIndex, len(nums) ):\\n                \\n                bag.append( nums[i] )           # put this element into bag\\n                makeSubsetFrom( i+1 )           # make subset from remaining elements\\n                bag.pop()                       # undo selection\\n            \\n            return\\n        \\n        #----------------------------------------\\n        makeSubsetFrom( startIndex = 0 )\\n        \\n        return all_subset\\n```\\n\\n---\\n\\n**Java**\\n\\n```\\nclass Solution {\\n    \\n    private List< List<Integer> > allSubset = new ArrayList< List<Integer> >();\\n    private List< Integer > bag = new ArrayList<Integer>();\\n    \\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        makeSubsetFrom( 0, nums );    \\n    \\n        return allSubset;\\n    }\\n    \\n    private void makeSubsetFrom( int startIndex, int[] nums){\\n        \\n        // Add current subset into final result\\n        // Java object is passing by refernce, so we have to make a copy here\\n        allSubset.add( new ArrayList<Integer>(bag) );\\n\\n\\n        //// Base cases aka stop condition:\\n        // No more element\\n        if( startIndex == nums.length ){\\n            return;\\n        }\\n\\n        //// General cases\\n        // Current level, we choouse element on index i\\n        for( int i = startIndex ; i < nums.length ; i++ ){ \\n\\n            bag.add( nums[i] );            // put this element into bag\\n            makeSubsetFrom( i+1, nums );   // make subset from remaining elements\\n            bag.remove( bag.size()-1);     // undo selection\\n        }\\n        return;\\n        \\n    }\\n    \\n}\\n```\\n\\n---\\n\\n**Javascript**\\n\\n```\\nvar subsets = function(nums) {\\n    \\n    let allSubset = [];\\n    let bag = [];\\n    \\n    \\n    var makeSubsetFrom = function( startIndex ){\\n        \\n        // JS object is passing by referece, so we have to make a copy here\\n        allSubset.push( [...bag] );\\n        \\n        //// Base cases aka stop condition:\\n        // No more element\\n        if ( startIndex == nums.length ){\\n            return;\\n        }\\n        \\n        //// General cases\\n        // Current level, we choouse element on index i\\n        for( let i = startIndex ; i < nums.length ; i++){\\n            \\n            bag.push( nums[i] );    // put this element into bag\\n            makeSubsetFrom( i+1 );  // make subset from remaining elements\\n            bag.pop();              // undo selection\\n        }\\n        return;\\n    }\\n    // ---------------------------------\\n    makeSubsetFrom( startIndex = 0 );\\n    return allSubset;\\n    \\n};\\n```\\n\\n---\\n\\n**C++**\\n\\n```\\nclass Solution{\\npublic:\\n    vector< vector<int> > subsets( vector<int>& nums ){\\n    \\n        vector< vector<int> > allSubset;\\n        vector< int > bag;\\n        \\n        \\n        std::function< void(int)> makeSubsetFrom = [&](int startIndex)->void{\\n            \\n            // Add current subset into final result\\n            allSubset.emplace_back( bag );\\n            \\n            \\n            //// Base cases aka stop condition:\\n            // No more element\\n            if( startIndex == nums.size() ){\\n                return;\\n            }\\n            \\n            //// General cases\\n            // Current level, we choouse element on index i\\n            for( int i = startIndex ; i < nums.size() ; i++ ){ \\n                \\n                bag.emplace_back( nums[i] );            // put this element into bag\\n                makeSubsetFrom( i+1 );                  // make subset from remaining elements\\n                bag.pop_back();                         // undo selection\\n            }\\n            return;\\n        };\\n        \\n        //----------------------------------------\\n        makeSubsetFrom( 0 );    \\n    \\n        return allSubset;\\n    }\\n};\\n\\n```\\n\\n---\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n\\ndef backtrack( parameter ):\\n\\n\\t# Base case handle, aka stop condition\\n\\tif stop condition:\\n\\t\\t# save valid result if needed\\n\\t\\treturn\\n\\t\\t\\n\\t\\n\\t# General cases handle:\\n\\tfor each possible next move/next selection:\\n\\t\\t\\n\\t\\tmake a next move/ select a element\\n\\t\\n\\t\\tbacktrack( updated parameter )\\n\\t\\t\\n\\t\\troll back / undo selection\\n\\t\\t\\n\\treturn\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        \\n        all_subset = []\\n        bag = []\\n        \\n        \\n        def makeSubsetFrom( startIndex ):\\n            \\n            # Add current subset into final result\\n            # Note: python object is passing by reference, so we have to make a copy\\n            all_subset.append( bag[::] )\\n            \\n            \\n            ## Base cases aka stop condition:\\n            # No more element\\n            if startIndex == len(nums):\\n                return\\n            \\n            ## General cases\\n            # Current level, we choouse element on index i\\n            for i in range(startIndex, len(nums) ):\\n                \\n                bag.append( nums[i] )           # put this element into bag\\n                makeSubsetFrom( i+1 )           # make subset from remaining elements\\n                bag.pop()                       # undo selection\\n            \\n            return\\n        \\n        #----------------------------------------\\n        makeSubsetFrom( startIndex = 0 )\\n        \\n        return all_subset\\n```\n```\\nclass Solution {\\n    \\n    private List< List<Integer> > allSubset = new ArrayList< List<Integer> >();\\n    private List< Integer > bag = new ArrayList<Integer>();\\n    \\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        makeSubsetFrom( 0, nums );    \\n    \\n        return allSubset;\\n    }\\n    \\n    private void makeSubsetFrom( int startIndex, int[] nums){\\n        \\n        // Add current subset into final result\\n        // Java object is passing by refernce, so we have to make a copy here\\n        allSubset.add( new ArrayList<Integer>(bag) );\\n\\n\\n        //// Base cases aka stop condition:\\n        // No more element\\n        if( startIndex == nums.length ){\\n            return;\\n        }\\n\\n        //// General cases\\n        // Current level, we choouse element on index i\\n        for( int i = startIndex ; i < nums.length ; i++ ){ \\n\\n            bag.add( nums[i] );            // put this element into bag\\n            makeSubsetFrom( i+1, nums );   // make subset from remaining elements\\n            bag.remove( bag.size()-1);     // undo selection\\n        }\\n        return;\\n        \\n    }\\n    \\n}\\n```\n```\\nvar subsets = function(nums) {\\n    \\n    let allSubset = [];\\n    let bag = [];\\n    \\n    \\n    var makeSubsetFrom = function( startIndex ){\\n        \\n        // JS object is passing by referece, so we have to make a copy here\\n        allSubset.push( [...bag] );\\n        \\n        //// Base cases aka stop condition:\\n        // No more element\\n        if ( startIndex == nums.length ){\\n            return;\\n        }\\n        \\n        //// General cases\\n        // Current level, we choouse element on index i\\n        for( let i = startIndex ; i < nums.length ; i++){\\n            \\n            bag.push( nums[i] );    // put this element into bag\\n            makeSubsetFrom( i+1 );  // make subset from remaining elements\\n            bag.pop();              // undo selection\\n        }\\n        return;\\n    }\\n    // ---------------------------------\\n    makeSubsetFrom( startIndex = 0 );\\n    return allSubset;\\n    \\n};\\n```\n```\\nclass Solution{\\npublic:\\n    vector< vector<int> > subsets( vector<int>& nums ){\\n    \\n        vector< vector<int> > allSubset;\\n        vector< int > bag;\\n        \\n        \\n        std::function< void(int)> makeSubsetFrom = [&](int startIndex)->void{\\n            \\n            // Add current subset into final result\\n            allSubset.emplace_back( bag );\\n            \\n            \\n            //// Base cases aka stop condition:\\n            // No more element\\n            if( startIndex == nums.size() ){\\n                return;\\n            }\\n            \\n            //// General cases\\n            // Current level, we choouse element on index i\\n            for( int i = startIndex ; i < nums.size() ; i++ ){ \\n                \\n                bag.emplace_back( nums[i] );            // put this element into bag\\n                makeSubsetFrom( i+1 );                  // make subset from remaining elements\\n                bag.pop_back();                         // undo selection\\n            }\\n            return;\\n        };\\n        \\n        //----------------------------------------\\n        makeSubsetFrom( 0 );    \\n    \\n        return allSubset;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095689,
                "title": "cpp-using-aditya-verma-subset-video-12-recursion-playlist",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> >m;\\n    void solve(vector<int>nums,vector<int>op)\\n    {\\n        if(nums.size()==0)\\n        {\\n            m.push_back(op);\\n            return;\\n        }\\n        vector<int>op1=op,op2=op;\\n        op1.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve(nums,op1);\\n        solve(nums,op2);\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>op;\\n        solve(nums,op);\\n        return m;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> >m;\\n    void solve(vector<int>nums,vector<int>op)\\n    {\\n        if(nums.size()==0)\\n        {\\n            m.push_back(op);\\n            return;\\n        }\\n        vector<int>op1=op,op2=op;\\n        op1.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve(nums,op1);\\n        solve(nums,op2);\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>op;\\n        solve(nums,op);\\n        return m;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803124,
                "title": "simple-python-recursive-and-iterative-solution",
                "content": "Recursive:\\n```\\ndef subsets(self, nums):\\n    res = []\\n    self.generateSubsets(nums, res, [], 0)\\n    return res\\ndef generateSubsets(self, nums, res, curr, index):\\n    res.append(list(curr))\\n    for i in range(index, len(nums)):\\n        curr.append(nums[i])\\n        self.generateSubsets(nums, res, curr, i + 1)\\n        curr.pop()\\n```\\n\\nIterative:\\n```\\ndef subsets(self, nums):\\n        result = [[]]\\n        for num in nums:\\n            size = len(result)\\n            for j in range(size):\\n                subset = list(result[j])                \\n                subset.append(num) # or subset += [num]\\n                result.append(subset) # or result += subset\\n            \\n        return result\\n```\\n\\nI think understanding the recursive and iterative solution for this problem helps understand the concept better.\\n(I know there is a shorter one-line iterative solution for this, but I think writing it out helps to better visualize and understand the algorithm)\\n\\n*Note: we do list(result[j]) to manipulate the copy of result[j] instead of the direct reference to result[j]",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef subsets(self, nums):\\n    res = []\\n    self.generateSubsets(nums, res, [], 0)\\n    return res\\ndef generateSubsets(self, nums, res, curr, index):\\n    res.append(list(curr))\\n    for i in range(index, len(nums)):\\n        curr.append(nums[i])\\n        self.generateSubsets(nums, res, curr, i + 1)\\n        curr.pop()\\n```\n```\\ndef subsets(self, nums):\\n        result = [[]]\\n        for num in nums:\\n            size = len(result)\\n            for j in range(size):\\n                subset = list(result[j])                \\n                subset.append(num) # or subset += [num]\\n                result.append(subset) # or result += subset\\n            \\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 332547,
                "title": "java-very-simple-bit-manipulation-solution-time-1ms-space-37-5-mb",
                "content": "```\\n public class Solution {\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < 1 << nums.length; ++i) {\\n            List<Integer> subSet = new ArrayList<>();\\n\\n            for (int b = 0; b < nums.length; ++b) {\\n                if (((i >> b) & 1) == 1) {\\n                    subSet.add(nums[b]);\\n                }\\n            }\\n\\n            result.add(subSet);\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\nExplanation:\\nInput: nums = [1,2,3]\\nOutput:\\n *   [3],       0 0 1\\n *   [1],       1 0 0\\n *   [2],       0 1 0\\n *   [1,2,3],   1 1 1\\n *   [1,3],     1 0 1\\n *   [2,3],     0 1 1\\n *   [1,2],     1 1 0\\n *   []         0 0 0",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n public class Solution {\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < 1 << nums.length; ++i) {\\n            List<Integer> subSet = new ArrayList<>();\\n\\n            for (int b = 0; b < nums.length; ++b) {\\n                if (((i >> b) & 1) == 1) {\\n                    subSet.add(nums[b]);\\n                }\\n            }\\n\\n            result.add(subSet);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246941,
                "title": "c-solution-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> dp;\\n        \\n        dp.push_back({});\\n        \\n        for (auto i = 0; i < nums.size(); i++) {\\n            auto size = dp.size();\\n\\n            for (auto j = 0; j < size; j++) {\\n                auto v = dp[j];\\n                v.push_back(nums[i]);\\n                dp.push_back(v);\\n            }\\n        }\\n        return dp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> dp;\\n        \\n        dp.push_back({});\\n        \\n        for (auto i = 0; i < nums.size(); i++) {\\n            auto size = dp.size();\\n\\n            for (auto j = 0; j < size; j++) {\\n                auto v = dp[j];\\n                v.push_back(nums[i]);\\n                dp.push_back(v);\\n            }\\n        }\\n        return dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611072,
                "title": "c-3-approach-recursive-bit-manipulation-iterative",
                "content": "# Approach 1: Recusion\\n<!-- Describe your approach to solving the problem. -->\\n# Code \\n```\\nclass Solution {\\npublic:\\n    \\n    void sub(int i,vector<int> &nums, vector<int> &temp,vector<vector<int>>&ans)\\n    {\\n        if(i>=nums.size())\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        // pick\\n        temp.push_back(nums[i]);\\n        sub(nums, i+1, temp,ans);\\n\\n        // not pick\\n        temp.pop_back();\\n        //this pop is necessary because we are passing temp by reference. \\n        //if anything will be picked in above call it will remain in temp if we will not pop it.\\n        sub(nums, i+1, temp,ans);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;       \\n        sub(nums, 0, temp,ans); \\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- `Time complexity:O(N*(2^N))`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- `Space complexity: O(N) + O(N*(2^N)) = O(N*(2^N)) `\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. maximum depth of recusion tree will be N hence recursion stack space is O(N).\\n2. we have to store 2^N subsets in ans each of size O(N)\\n\\n# Video Solution by Striver :\\n[https://youtu.be/AxNNVECce8c]()\\n---\\n\\n\\n# Approach 2: Bit Manipulation (Power Set)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>> ans;\\n        // (1<<n) =2^n\\n        for(int subset_num=0; subset_num < (1<<n); subset_num++)\\n        {\\n            vector<int> subset;\\n            for(int i=0;i<n;i++)\\n            {\\n                // if the ith bit is set \\n                if( (subset_num & (1<<i)) )\\n                {\\n                    subset.push_back(nums[i]);\\n                }\\n            }\\n            ans.push_back(subset);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- `Time complexity: O(N*(2^N))`\\n1. 2^N subsets will be generated.\\n2. for each subset number we check N bits (set or not)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- `Space complexity:  O(N*(2^N)) `\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. we have to store 2^N subsets in ans each of size O(N)\\n\\n# Video Solution by Striver :\\n[https://youtu.be/b7AYbpM5YrE]()\\n---\\n\\n# Approach 3: Iterative\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        int n=nums.size();\\n\\n        output.push_back({});\\n        // initialising the output with an empty subset\\n\\n        for(int i=0; i<n;i++)\\n        {\\n            // for every index i in nums make a copy of all the existing rows in output.\\n            // Then add the ith num to the copy and then push it in output \\n            int size=output.size();\\n            for(int j=0;j<size;j++)\\n            {\\n                vector<int> newRow=output[j]; //O(N)\\n                \\n                newRow.push_back(nums[i]);\\n                output.push_back(newRow);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```\\n# Complexity\\n- `Time complexity: O(N*(2^N))`\\n1. 2^N subsets will be generated.\\n2. while generating each subset we have to copy one of the previous subset:\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- `Space complexity:  O(N*(2^N))` \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. we have to store 2^N subsets in ans each of size O(N)\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void sub(int i,vector<int> &nums, vector<int> &temp,vector<vector<int>>&ans)\\n    {\\n        if(i>=nums.size())\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        // pick\\n        temp.push_back(nums[i]);\\n        sub(nums, i+1, temp,ans);\\n\\n        // not pick\\n        temp.pop_back();\\n        //this pop is necessary because we are passing temp by reference. \\n        //if anything will be picked in above call it will remain in temp if we will not pop it.\\n        sub(nums, i+1, temp,ans);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;       \\n        sub(nums, 0, temp,ans); \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>> ans;\\n        // (1<<n) =2^n\\n        for(int subset_num=0; subset_num < (1<<n); subset_num++)\\n        {\\n            vector<int> subset;\\n            for(int i=0;i<n;i++)\\n            {\\n                // if the ith bit is set \\n                if( (subset_num & (1<<i)) )\\n                {\\n                    subset.push_back(nums[i]);\\n                }\\n            }\\n            ans.push_back(subset);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        int n=nums.size();\\n\\n        output.push_back({});\\n        // initialising the output with an empty subset\\n\\n        for(int i=0; i<n;i++)\\n        {\\n            // for every index i in nums make a copy of all the existing rows in output.\\n            // Then add the ith num to the copy and then push it in output \\n            int size=output.size();\\n            for(int j=0;j<size;j++)\\n            {\\n                vector<int> newRow=output[j]; //O(N)\\n                \\n                newRow.push_back(nums[i]);\\n                output.push_back(newRow);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252865,
                "title": "python3-using-recursion",
                "content": "\\n# Complexity\\n- Time complexity:\\n2^N\\n\\n- Space complexity:\\n0(N) due to recursive stack\\n\\n# Code\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n=len(nums)\\n        ans=[]\\n        def solve(idx,lst):\\n            if idx>=n:\\n                ans.append(lst)\\n                return \\n            solve(idx+1,lst)                    #Not Take\\n            solve(idx+1,lst+[nums[idx]])        #Take\\n        solve(0,[])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n=len(nums)\\n        ans=[]\\n        def solve(idx,lst):\\n            if idx>=n:\\n                ans.append(lst)\\n                return \\n            solve(idx+1,lst)                    #Not Take\\n            solve(idx+1,lst+[nums[idx]])        #Take\\n        solve(0,[])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770171,
                "title": "c-iterative-solution-with-explanation",
                "content": "Kindly **upvote** if you find it helpful **: )**\\n```\\n//Consider nums = [1, 2, 3]\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans = {{}}; //Initialize nums with an empty subset\\n        //In first iteration, adding 1 to []: [[], [1]];\\n        //In second iteration, adding 2 to [] and [1]: [[], [1], [2], [1, 2]];\\n        //In third iteration, adding 3 to [], [1], [2] and [1, 2]: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]];\\n        for (int a : nums) { \\n            int n = ans.size();\\n            for (int i = 0; i < n; i++) {\\n                ans.push_back(ans[i]); //adds existing element of ans to ans\\n                ans.back().push_back(a);//adds nums\\'s element to the back of the ans\\'s element\\n            }\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n//Consider nums = [1, 2, 3]\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans = {{}}; //Initialize nums with an empty subset\\n        //In first iteration, adding 1 to []: [[], [1]];\\n        //In second iteration, adding 2 to [] and [1]: [[], [1], [2], [1, 2]];\\n        //In third iteration, adding 3 to [], [1], [2] and [1, 2]: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]];\\n        for (int a : nums) { \\n            int n = ans.size();\\n            for (int i = 0; i < n; i++) {\\n                ans.push_back(ans[i]); //adds existing element of ans to ans\\n                ans.back().push_back(a);//adds nums\\'s element to the back of the ans\\'s element\\n            }\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766515,
                "title": "easy-python-dp-solution",
                "content": "Keep track of all subsets in an array `dp`. Initially add the empty set. Then iterate through the numbers and add each number to all existing solutions, so all possible subsets are generated.\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        dp = [[]]\\n        for n in nums:\\n            tmp = []\\n            for x in dp:\\n                tmp.append(x + [n])\\n            dp += tmp\\n        return dp\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        dp = [[]]\\n        for n in nums:\\n            tmp = []\\n            for x in dp:\\n                tmp.append(x + [n])\\n            dp += tmp\\n        return dp\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1381418,
                "title": "c-solution-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void solve(vector<int>input, vector<int>output){\\n        if(input.size() == 0){\\n            ans.push_back(output);   \\n            return;\\n        }\\n        vector<int>op1 = output, op2 = output;\\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        solve(input, op1);\\n        solve(input, op2);   \\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        solve(nums, {});\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void solve(vector<int>input, vector<int>output){\\n        if(input.size() == 0){\\n            ans.push_back(output);   \\n            return;\\n        }\\n        vector<int>op1 = output, op2 = output;\\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        solve(input, op1);\\n        solve(input, op2);   \\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        solve(nums, {});\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195865,
                "title": "c-easy-backtracking-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    \\n    vector <vector <int>> powerSet;\\n    void getSubset(vector<int> &nums, vector<int> subset, int i) {\\n        if (i == nums.size()) {\\n            powerSet.push_back(subset);\\n            return;\\n        }\\n        \\n        // accepting element\\n        subset.push_back(nums[i]);\\n        getSubset(nums, subset, i + 1);\\n        \\n        // rejecting element\\n        subset.pop_back();\\n        getSubset(nums, subset, i + 1);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector <int> subset;\\n        getSubset(nums, subset, 0);\\n        return powerSet;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector <vector <int>> powerSet;\\n    void getSubset(vector<int> &nums, vector<int> subset, int i) {\\n        if (i == nums.size()) {\\n            powerSet.push_back(subset);\\n            return;\\n        }\\n        \\n        // accepting element\\n        subset.push_back(nums[i]);\\n        getSubset(nums, subset, i + 1);\\n        \\n        // rejecting element\\n        subset.pop_back();\\n        getSubset(nums, subset, i + 1);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector <int> subset;\\n        getSubset(nums, subset, 0);\\n        return powerSet;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388568,
                "title": "subsets-i-ii-java-solution-with-detailed-explanation-and-comments-recursion-iteration",
                "content": "Reference: [Subsets I](https://leetcode.com/problems/subsets/) & [Subsets II](https://leetcode.com/problems/subsets-ii/) <span class=\"gray\">EPI 15.5</span>\\nDifficulty: <span class=\"orange\">Medium</span> (I think Subsets II should be hard)\\n\\n\\n\\n## Problem\\n\\n> Given a set of `distinct` integers, `nums`, return all possible subsets (the power set).\\n\\n**Note:** The solution set must not contain duplicate subsets.\\n\\n**Example:** \\n\\n```java\\nInput: nums = [1,2,3]\\nOutput: [\\n  [3],\\n  [1],\\n  [2],\\n  [1,2,3],\\n  [1,3],\\n  [2,3],\\n  [1,2],\\n  []\\n]\\n```\\n\\n**Follow up:** Check out the [Subsets II](#subsets_ii) section below.\\n\\n\\n## Analysis\\n\\nThe power set of a set `S` is the set of all subsets of `S`, including both the empty set `emptyset` and `S` itself. The power set of `{1, 2, 3}` is graphically illustrated as follows.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/mgtg8.jpg)\\n\\n\\n### Backtracking\\n\\nThe idea is that we loop over the number list. For each number, we have two choices: pick it, or not. For example, in `[1, 2, 3]`, we pick `1` and then do the same thing for the subproblem `[2, 3]`; and we don\\'t pick `1` and then do the same thing for the subproblem `[2, 3]`.\\n\\nThe size of subproblems is decreasing. When picking `2`, the subproblem becomes `[3]` instead of `[1, 3]`.\\n\\nConsider the following questions:\\n\\n- What is the base case?\\n- When do we add the list to the result?\\n\\nHere is an illustration of recursive process on `[1, 2, 3]`.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/gfdd3.jpg)\\n\\n\\n**Note:** Remember to add empty set manually.\\n\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  result.add(new ArrayList<>()); // empty set\\n  subsets(0, nums, numList, result);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result);\\n  // add to result\\n  result.add(new ArrayList<>(numList));\\n  // not pick\\n  numList.remove(numList.size() - 1);\\n  subsets(offset + 1, nums, numList, result);\\n}\\n```\\n\\n**Time:** `O(N * 2^N)` since the recurrence is `T(N) = 2T(N - 1)` and we also spend at most `O(N)` time within a call.\\n**Space:** `O(N * 2^N)` since there are `2^N` subsets. If we only print the result, we just need `O(N)` space.\\n\\n\\n### Iteration\\n\\nThe idea is simple. We go through the elements in the `nums` list. For each element, we loop over the current `result` list we have constructed so far. For each list in the `result`, we make a copy of this list and append the current element to it (it means picking the element). It is based on the same idea in backtracking (in each step you have choices: `pick` or `not pick`).\\n\\nThe result list initially contains an empty list `[]`. We loop over each element of `nums`, e.g. `[1, 2, 3]`.\\n\\n- After the first round, we have `[[], [1]]`.\\n- After the second round, we have `[[], [1], [2], [1,2]]`.\\n- After the third round, we have `[[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]`.\\n\\nFirst, let\\'s go over an incorrect version. There are two errors:\\n\\n1. We add a new element to `L`, but it changes the existed `L`. Thus, we should make a new copy of it.\\n2. While looping over `result`, we are modifying its size. In Java, the compiler would yell.\\n\\n**Incorrect version:**\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    for (List<Integer> L : result) {\\n      L.add(nums[i]);\\n      result.add(L);\\n    }\\n  }\\n  return result;\\n}\\n```\\n\\n**Correct version:**\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>(); // used for new lists\\n    for (List<Integer> L : result) {\\n      L = new ArrayList<>(L); // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n- The outer loop takes `O(N)` time.\\n- The inner loop takes `2, 4, 8, ..., 2^N` time respectively.\\n- In inner loop, making a new copy of `L` takes at most `O(N)` time.\\n- Total runtime `T(N) = N * (2 + 4 + 8 + ... + 2^N) ~= N * 2^N`\\n\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n### K-Size Subsets\\n\\nActually, we can use the code in [77. Combinations](https://www.junhaow.com/lc/problems/backtracking/77_combinations.html) to solve this problem.\\n\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  int n = nums.length;\\n  for (int k = 0; k <= n; ++k) { // compatible with empty set\\n    combine(n, k, 1, nums, numList, result);\\n  }\\n  return result;\\n}\\n\\nprivate void combine(int n, int k, int d, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  // base case (in order to handle empty set, ordering of two IFs matters)\\n  if (numList.size() == k) { // get a result\\n    result.add(new ArrayList<>(numList));\\n    return;\\n  }\\n  if (n - d + 1 < k - numList.size()) { // remaining elements are not enough\\n    return;\\n  }\\n\\n  for (int i = d; i <= n; ++i) {\\n    int val = nums[i - 1];\\n    numList.add(val);\\n    combine(n, k, i + 1, nums, numList, result);\\n    numList.remove(numList.size() - 1); // remove the last\\n  }\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n- `C(0, N) + C(1, N) + C(2, N) + C(3, N) + ... + C(N, N) = 2^N`\\n\\n**Space:** `O(N * 2^N)`\\n\\n\\n## Subsets II\\n\\nReference:\\n\\n- [[Java] Two Way of Recursive thinking](https://leetcode.com/problems/subsets-ii/discuss/169226/Java-Two-Way-of-Recursive-thinking)\\n- [Simple iterative solution](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution)\\n\\n> Given a collection of integers that might **contain duplicates**, `nums`, return all possible subsets (the power set).\\n\\n**Note:** The solution set must not contain duplicate subsets.\\n\\n```java\\nInput: [1,2,2]\\nOutput: [\\n  [2],\\n  [1],\\n  [1,2,2],\\n  [2,2],\\n  [1,2],\\n  []\\n]\\n```\\n\\n### Backtracking\\n\\nWe need to know when we **should not** add a list to the result list.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/wek92.jpg)\\n\\nBy observation, a duplicate list occurs when `offset >= 1` (when `offset = 0`, duplicate cannot occur) and `nums[offset - 1] == nums[offset]` and in the previous step we did not pick `nums[offset - 1]`. The information of whether it picks or not could be passed down by a **boolean parameter** `isPicked`.\\n \\nIf the above condition is satisfied:\\n- Do not add the list to the result list.\\n- Do not do the subproblem after picking the current element.\\n- Only do the subproblem after not picking the current element.\\n\\n**Note:** Be careful where we should put the `numList.add(val)` and `numList.remove(numList.size() - 1)`.\\n\\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sorting\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  result.add(new ArrayList<>());\\n  subsets(0, nums, numList, result, true);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // duplicate checking (convert && to ||)\\n  if (offset == 0 || nums[offset - 1] != nums[offset] || isPicked == true) {\\n    // pick\\n    numList.add(val);\\n    subsets(offset + 1, nums, numList, result, true);\\n    result.add(new ArrayList<>(numList));  // add to the result list\\n    numList.remove(numList.size() - 1);\\n  }\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n}\\n```\\n\\nAnother version (similar): \\n\\n```java\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n  // duplicate check\\n  if (offset >= 1 && nums[offset - 1] == nums[offset] && isPicked == false) {\\n    return;\\n  }\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result, true);\\n  result.add(new ArrayList<>(numList));  // add to the result list\\n  numList.remove(numList.size() - 1); \\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n\\n### Iteration\\n\\nUsing the same idea in backtracking, we need to figure out when we should add a list to the result list. Check out three examples below (`[1,2,3]`, `[1,2,2]`, `[5,5,5]`).\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/y0inx.jpg)\\n\\nBy observation, we learn that we should start from, if duplicate is detected, a specific location in the result list. In Subsets I, we always start from $0$.\\n\\nInterestingly, the specific location corresponds to the initial size of the result list in the previous round. Since we change the result list in each round, we should cache the size of the result list as `cachedSize`.\\n\\nThen we denote the starting index as `startIdx`. In each round, similar to what we\\'ve done in Subsets I, we set `startIdx` as:\\n\\n- `0` (no duplicate or `i == 0`)\\n- `cachedSize` (duplicate occurs)\\n\\nAfter setting `startIdx`, remember to do the caching job for the current size of the result list. Notice a fact that this cached size may not be used in the next round.\\n\\n\\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sort\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  \\n  int cachedSize = 0, startIdx = 0;\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>();  // used for new lists\\n    // set startIdx first before we update cachedSize\\n    startIdx = (i > 0 && nums[i - 1] == nums[i]) ? cachedSize : 0; // if duplicate occurs\\n    cachedSize = result.size(); // cache the size for startIdx in the next round\\n    for (int j = startIdx; j < result.size(); ++j) {\\n      List<Integer> L = result.get(j);\\n      L = new ArrayList<>(L);  // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java\\nInput: nums = [1,2,3]\\nOutput: [\\n  [3],\\n  [1],\\n  [2],\\n  [1,2,3],\\n  [1,3],\\n  [2,3],\\n  [1,2],\\n  []\\n]\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  result.add(new ArrayList<>()); // empty set\\n  subsets(0, nums, numList, result);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result);\\n  // add to result\\n  result.add(new ArrayList<>(numList));\\n  // not pick\\n  numList.remove(numList.size() - 1);\\n  subsets(offset + 1, nums, numList, result);\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    for (List<Integer> L : result) {\\n      L.add(nums[i]);\\n      result.add(L);\\n    }\\n  }\\n  return result;\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>(); // used for new lists\\n    for (List<Integer> L : result) {\\n      L = new ArrayList<>(L); // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  int n = nums.length;\\n  for (int k = 0; k <= n; ++k) { // compatible with empty set\\n    combine(n, k, 1, nums, numList, result);\\n  }\\n  return result;\\n}\\n\\nprivate void combine(int n, int k, int d, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  // base case (in order to handle empty set, ordering of two IFs matters)\\n  if (numList.size() == k) { // get a result\\n    result.add(new ArrayList<>(numList));\\n    return;\\n  }\\n  if (n - d + 1 < k - numList.size()) { // remaining elements are not enough\\n    return;\\n  }\\n\\n  for (int i = d; i <= n; ++i) {\\n    int val = nums[i - 1];\\n    numList.add(val);\\n    combine(n, k, i + 1, nums, numList, result);\\n    numList.remove(numList.size() - 1); // remove the last\\n  }\\n}\\n```\n```java\\nInput: [1,2,2]\\nOutput: [\\n  [2],\\n  [1],\\n  [1,2,2],\\n  [2,2],\\n  [1,2],\\n  []\\n]\\n```\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sorting\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  result.add(new ArrayList<>());\\n  subsets(0, nums, numList, result, true);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // duplicate checking (convert && to ||)\\n  if (offset == 0 || nums[offset - 1] != nums[offset] || isPicked == true) {\\n    // pick\\n    numList.add(val);\\n    subsets(offset + 1, nums, numList, result, true);\\n    result.add(new ArrayList<>(numList));  // add to the result list\\n    numList.remove(numList.size() - 1);\\n  }\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n}\\n```\n```java\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n  // duplicate check\\n  if (offset >= 1 && nums[offset - 1] == nums[offset] && isPicked == false) {\\n    return;\\n  }\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result, true);\\n  result.add(new ArrayList<>(numList));  // add to the result list\\n  numList.remove(numList.size() - 1); \\n}\\n```\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sort\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  \\n  int cachedSize = 0, startIdx = 0;\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>();  // used for new lists\\n    // set startIdx first before we update cachedSize\\n    startIdx = (i > 0 && nums[i - 1] == nums[i]) ? cachedSize : 0; // if duplicate occurs\\n    cachedSize = result.size(); // cache the size for startIdx in the next round\\n    for (int j = startIdx; j < result.size(); ++j) {\\n      List<Integer> L = result.get(j);\\n      L = new ArrayList<>(L);  // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 363804,
                "title": "python-4-ms-beats-100-00-the-shortest-solution-ever-image-explanation",
                "content": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res, path = [], []\\n        def inner(nums, path, res):\\n            for i, el in enumerate(nums):\\n                inner(nums[i+1:], path + [el], res)\\n            res.append(path)\\n        inner(nums, path, res)\\n        return res\\n```\\nIllustration for recursion tree in case of nums = [1, 2, 3]\\n![image](https://assets.leetcode.com/users/deniskoder/image_1566992853.png)",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res, path = [], []\\n        def inner(nums, path, res):\\n            for i, el in enumerate(nums):\\n                inner(nums[i+1:], path + [el], res)\\n            res.append(path)\\n        inner(nums, path, res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226217,
                "title": "java-super-simple-8-lines-iterative-1-ms-beats-100",
                "content": "I\\'ve seen all sorts of long and complicated solutions to this problem, with backtracking and recursion and bit manipulation and other stuff.  But it\\'s a pretty simple problem.  Each element of nums is either in, or not in, each subset.  So we can start with the empty set, and then just iteratively build up the solution by simply adding each element.\\n```\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> powerSet = new ArrayList<List<Integer>>( 1<<nums.length );\\n        powerSet.add( new ArrayList<Integer>() );\\n        \\n        for( int num: nums )\\n            for( int i=0, j=powerSet.size(); i<j; i++ ) {\\n                List<Integer> withNum = new ArrayList<Integer>( powerSet.get(i) );\\n                withNum.add( num );\\n                powerSet.add( withNum );\\n            }\\n        \\n        return powerSet;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> powerSet = new ArrayList<List<Integer>>( 1<<nums.length );\\n        powerSet.add( new ArrayList<Integer>() );\\n        \\n        for( int num: nums )\\n            for( int i=0, j=powerSet.size(); i<j; i++ ) {\\n                List<Integer> withNum = new ArrayList<Integer>( powerSet.get(i) );\\n                withNum.add( num );\\n                powerSet.add( withNum );\\n            }\\n        \\n        return powerSet;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 216279,
                "title": "python-solution",
                "content": "Recursive algorithm. Time complexity: `O(2^n)`, space complexity: `O(2^n)`.\\n\\n```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(nums, i, j):\\n            if i > j:\\n                return [[]]\\n            if j - i == 1:\\n                return [[], [nums[i]]]\\n            head = nums[i]\\n            res = helper(nums, i+1, j)\\n            for i in range(len(res)):\\n                res.append(res[i]+[head])\\n            return res\\n        \\n        return helper(nums, 0, len(nums))\\n```\\n\\nIterative algorithm. Time complexity: `O(2^n)`, space complexity: `O(2^n)`.\\n\\n```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for n in nums:\\n            for i in range(len(res)):\\n                res.append(res[i]+[n])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(nums, i, j):\\n            if i > j:\\n                return [[]]\\n            if j - i == 1:\\n                return [[], [nums[i]]]\\n            head = nums[i]\\n            res = helper(nums, i+1, j)\\n            for i in range(len(res)):\\n                res.append(res[i]+[head])\\n            return res\\n        \\n        return helper(nums, 0, len(nums))\\n```\n```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for n in nums:\\n            for i in range(len(res)):\\n                res.append(res[i]+[n])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27520,
                "title": "three-ways-to-do-this-c",
                "content": "1. Clone the lists when process each num.\\n-----------------------------------------\\n\\nAt beginning, there is only one empty list. <br>\\n**{{}}**<br>\\nWhen we process the first num( use 1 to represent), clone all the existing list, for the cloned list, add the cur num to the list.  . Add all the cloned list to the result.<br>\\n**{{},{1}}**<br>\\nwhen we process the second num( use 2 to represent), again clone all existing list, and add cur num to the cloned list. Add all the cloned list to the result.<br>\\n**{{},{1},{2},{1,2}}**<br>\\n\\ndo this until n. \\n\\n    public IList<IList<int>> Subsets(int[] nums) \\n    {\\n        Array.Sort(nums);\\n        IList<IList<int>> res = new List<IList<int>>();\\n        res.Add(new List<int>());\\n        if( nums == null || nums.Length == 0 ) return res;\\n        \\n        for( int i = 0; i < nums.Length; ++i )\\n        {\\n            int count = res.Count;\\n            for( int j = 0; j < count; ++j )\\n            {\\n                List<int> newList = new List<int>( res[j] );\\n                newList.Add( nums[i] );\\n                res.Add(newList);\\n            }\\n            \\n        }\\n        return res;\\n    }\\n\\n\\n2.Bit manipulation\\n------------------\\ngo from 0 to Pow(2, nums.Length) <br>\\n0 -> 0000  -> {}<br>\\n1 -> 0001  -> {1}  // {1} means the list contains the first num in the array nums<br>\\n2 -> 0010  -> {2}<br>\\n3 -> 0011  -> {2,1}<br>\\n.....<br>\\nPow(2, nums.Length) -> ......<br>\\nAdd all above list to the result.<br>\\n\\n\\n    public IList<IList<int>> Subsets(int[] nums) \\n    {\\n        Array.Sort(nums);\\n        \\n        IList<IList<int>> result = new List<IList<int>>();\\n        \\n        int max =  (int)Math.Pow(2, nums.Length);\\n        for( int counter = 0; counter < max; ++counter )\\n        {\\n           IList<int> subSet = new List<int>();\\n           int mark = 1;\\n           for( int j = 0; j < nums.Length; ++j ) \\n           {\\n               if( (mark & counter) != 0 )\\n               {\\n                  subSet.Add(nums[j]); \\n               }\\n               mark <<= 1;\\n           }\\n           \\n           result.Add(subSet);\\n        } \\n        \\n        return result;\\n        \\n    }\\n\\n\\n3. Back tracking\\n----------------\\nWhen process each num, there're two choice, add or do not add. If add, a back track is needed.<br>\\n\\n    public class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) \\n    {\\n        Array.Sort(nums);\\n        \\n        IList<IList<int>> res = new List<IList<int>>();\\n        IList<int> list = new List<int>();\\n        \\n        Subset(res, list, nums, 0);\\n        \\n        return res;\\n    }\\n    \\n    private void Subset( IList<IList<int>> res, IList<int> list, int[] nums, int index )\\n    {\\n       if( index == nums.Length ) \\n       {\\n           res.Add(new List<int>(list));\\n           return;\\n       }\\n       \\n       int count = list.Count;\\n       Subset( res, list, nums,index +1 );\\n      \\n       list.Add( nums[index] );\\n       Subset( res, list, nums,index +1 );\\n       list.RemoveAt( list.Count -1 );\\n       \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) \\n    {\\n        Array.Sort(nums);\\n        \\n        IList<IList<int>> res = new List<IList<int>>();\\n        IList<int> list = new List<int>();\\n        \\n        Subset(res, list, nums, 0);\\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 27560,
                "title": "1-3-lines-ruby-solutions",
                "content": "**Solution 1**\\n\\n    def subsets(nums)\\n      (0..nums.size).flat_map{ |k| nums.combination(k).to_a }\\n    end\\n\\n**Solution 2**\\n\\n    def subsets(nums)\\n      subsets = [[]]\\n      nums.each { |n| subsets += subsets.map { |s| s + [n] } }\\n      subsets\\n    end\\n\\n**Solution 3**\\n\\n    def subsets(nums)\\n      nums.reduce([[]]) { |subsets, n| subsets + subsets.map { |s| s + [n] } }\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "**Solution 1**\\n\\n    def subsets(nums)\\n      (0..nums.size).flat_map{ |k| nums.combination(k).to_a }\\n    end\\n\\n**Solution 2**\\n\\n    def subsets(nums)\\n      subsets = [[]]\\n      nums.each { |n| subsets += subsets.map { |s| s + [n] } }\\n      subsets\\n    end\\n\\n**Solution 3**\\n\\n    def subsets(nums)\\n      nums.reduce([[]]) { |subsets, n| subsets + subsets.map { |s| s + [n] } }\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 27582,
                "title": "java-recursion-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            List<Integer> subset = new ArrayList<Integer>();\\n            res.add(subset);\\n            \\n            Arrays.sort(nums);\\n            doSubsets(nums,res,subset,0);\\n            return res;\\n        }\\n        \\n        private void doSubsets(int[] nums, List res,List subset,int start){\\n            if(start != nums.length){\\n                for(int i=start; i<nums.length; i++){\\n                    subset.add(nums[i]);\\n                    res.add(new ArrayList(subset));\\n                    doSubsets(nums,res,subset,i+1);\\n                    subset.remove(subset.get(subset.size()-1));\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            List<Integer> subset = new ArrayList<Integer>();\\n            res.add(subset);\\n            \\n            Arrays.sort(nums);\\n            doSubsets(nums,res,subset,0);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3509457,
                "title": "c-recursive-solution-100-beat-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void subsetsum(int index, vector<int>& nums, vector<int>& subset, vector<vector<int>>& result) {\\n        if (index == nums.size()) {\\n            result.push_back(subset);\\n            return;\\n        }\\n        subset.push_back(nums[index]);\\n        subsetsum(index + 1, nums, subset, result);\\n        subset.pop_back();\\n        subsetsum(index + 1, nums, subset, result);\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int> subset;\\n        vector<vector<int>> result;\\n        subsetsum(0, nums, subset, result);\\n        return result;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void subsetsum(int index, vector<int>& nums, vector<int>& subset, vector<vector<int>>& result) {\\n        if (index == nums.size()) {\\n            result.push_back(subset);\\n            return;\\n        }\\n        subset.push_back(nums[index]);\\n        subsetsum(index + 1, nums, subset, result);\\n        subset.pop_back();\\n        subsetsum(index + 1, nums, subset, result);\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int> subset;\\n        vector<vector<int>> result;\\n        subsetsum(0, nums, subset, result);\\n        return result;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342430,
                "title": "using-bit-manipulation-power-set-concept-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each element we need to take two decisions. Either to **take it or not to take it**, this is how we can create all the subsets.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf an array is of \\'n\\' size, then it must have \\'2^n\\' subsets. \\n- So, the outer loop is running till \\'2^n\\' (same as 1<<n).\\n- We need to take decision(take or not take) for each element. As there are \\'n\\' elements in the array, the inner loop is running \\'n\\' times.\\n- In the inner loop **if (1<<j)&i is giving a set bit** then jth element is taken in the subset, otherwise it is not taken.\\n- at the end of the inner loop the subset is inserted in ans (**vector of vectors**) ans.\\n- At the end of the Outer loop ans is returned.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*2^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2) \\n\\nIf you find it helpful then please upvote\\u2B06\\uFE0F\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        for(int i=0;i<(1<<n);i++){\\n            vector<int>v;\\n            for(int j=0;j<n;j++){\\n                if((1<<j)&i){\\n                    v.push_back(nums[j]);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        for(int i=0;i<(1<<n);i++){\\n            vector<int>v;\\n            for(int j=0;j<n;j++){\\n                if((1<<j)&i){\\n                    v.push_back(nums[j]);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209304,
                "title": "best-c-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity : O(2^N), For every index, we make 2 recursion calls and there are N elements so total time complexity is O(2^N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity : O(2^N*N), There are 2^N-1 subsets and for every subset, we need O(N) space on average so total space complexity is O(2^N*N).\\n\\n# Code\\n```\\n/*\\n\\n    Time complexity : O(2^N), For every index, we make 2 recursion calls and there are N elements so total time\\n    complexity is O(2^N).\\n\\n    Space complexity : O(2^N*N), There are 2^N-1 subsets and for every subset, we need O(N) space on average so\\n    total space complexity is O(2^N*N).\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsets(vector<int> &nums, vector<vector<int>> &output, vector<int>&temp, int index){\\n        if(nums.size() == index){\\n            output.push_back(temp);\\n            return;\\n        }\\n        // Exclude Element\\n        subsets(nums, output, temp, index+1);\\n        // Include Element\\n        temp.push_back(nums[index]);\\n        subsets(nums, output, temp, index+1);\\n        temp.pop_back();\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        subsets(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsets(vector<int> nums, vector<vector<int>> &output, vector<int> temp, int index){\\n        if(nums.size() == index){\\n            output.push_back(temp);\\n            return;\\n        }\\n        // Exclude Element\\n        subsets(nums, output, temp, index+1);\\n        // Include Element\\n        temp.push_back(nums[index]);\\n        subsets(nums, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        subsets(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time complexity : O(2^N), For every index, we make 2 recursion calls and there are N elements so total time\\n    complexity is O(2^N).\\n\\n    Space complexity : O(2^N*N), There are 2^N-1 subsets and for every subset, we need O(N) space on average so\\n    total space complexity is O(2^N*N).\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsets(vector<int> &nums, vector<vector<int>> &output, vector<int>&temp, int index){\\n        if(nums.size() == index){\\n            output.push_back(temp);\\n            return;\\n        }\\n        // Exclude Element\\n        subsets(nums, output, temp, index+1);\\n        // Include Element\\n        temp.push_back(nums[index]);\\n        subsets(nums, output, temp, index+1);\\n        temp.pop_back();\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        subsets(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsets(vector<int> nums, vector<vector<int>> &output, vector<int> temp, int index){\\n        if(nums.size() == index){\\n            output.push_back(temp);\\n            return;\\n        }\\n        // Exclude Element\\n        subsets(nums, output, temp, index+1);\\n        // Include Element\\n        temp.push_back(nums[index]);\\n        subsets(nums, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        subsets(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088993,
                "title": "beats-100-simple-c-back-tracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple try to generate all the subseqeunces of array and backtrack.\\nSimply in each backtraking problem three steps are there :\\n- Choose \\n- Explore\\n- Unchoose\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Pick a starting point.\\n- while problem is not solved\\n  -  For each path from the starting point\\n      make recursive call to rest of the problem\\n        before which we undo the current move.\\n \\n- Keep adding the answer in ans vector generated at each recursive call.\\n\\n# Complexity\\n- Time complexity:$$O(n*2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n*2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void backtrack(vector<int>&arr,int start,vector<int>&temp){\\n        ans.push_back(temp);\\n        for(int i=start;i<arr.size();i++){\\n            temp.push_back(arr[i]);\\n            backtrack(arr,i+1,temp);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>temp;\\n        backtrack(arr,0,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void backtrack(vector<int>&arr,int start,vector<int>&temp){\\n        ans.push_back(temp);\\n        for(int i=start;i<arr.size();i++){\\n            temp.push_back(arr[i]);\\n            backtrack(arr,i+1,temp);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>temp;\\n        backtrack(arr,0,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217980,
                "title": "go-bfs",
                "content": "```\\nfunc subsets(nums []int) [][]int {\\n    var queue [][]int\\n    queue = append(queue, []int{})\\n    \\n    for i := 0; i < len(nums); i++ {\\n        length := len(queue)\\n        \\n        for j := 0; j < length; j++ {\\n            item := queue[j]\\n            \\n            tmp := make([]int, len(item))\\n            copy(tmp, item)\\n            tmp = append(tmp, nums[i])\\n            \\n            queue = append(queue, tmp)\\n        }\\n    }\\n    \\n    return queue\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc subsets(nums []int) [][]int {\\n    var queue [][]int\\n    queue = append(queue, []int{})\\n    \\n    for i := 0; i < len(nums); i++ {\\n        length := len(queue)\\n        \\n        for j := 0; j < length; j++ {\\n            item := queue[j]\\n            \\n            tmp := make([]int, len(item))\\n            copy(tmp, item)\\n            tmp = append(tmp, nums[i])\\n            \\n            queue = append(queue, tmp)\\n        }\\n    }\\n    \\n    return queue\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1697053,
                "title": "bit-manipulation-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        \\n        int n=nums.size();\\n        int setSize = 1<<n;   // 2^n Number of subset ;\\n        \\n        for(int i=0;i<setSize;i++){\\n            \\n            vector<int>temp;   // for storing values in subsets\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                if(i & (1<<j)){ //Checking for set bits in number i;\\n                temp.push_back(nums[j]);   // Push the value which is at founded index of setbit \\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nHow to check if ith bit is set or not of number num i.e. (num & 1<<(i-1))\\n\\n We have to check if ith bit is set or not\\n \\n Step 1 : Take number 1 \\n Step 2 : Left shift this to i-1 times so the number becomes 10000 (like this)\\n Step 3 : DO Bitwise And  with num to check if the ith bit is set or not\\n \\n For Example : \\n      Let\\'s Have number 9 \\n\\t  Its Binary representation is 1001\\n\\t  if we have to check is 4th bit\\n\\t  \\n\\t  According to steps take 1 and left shift it 3 times so Number is 1000\\n\\t  Now \\n\\t   1001\\n\\t&1000\\n\\tResults 1000 that is not zero which means that 4th bit is set.\\n\\t\\n\\tHere is picture how to algorithm works :\\n\\t\\n![image](https://assets.leetcode.com/users/images/197bb06c-5c6b-4bb0-a37f-6701c6b2026d_1642422912.8045533.jpeg)\\n\\n\\n\\n\\t\\n\\tThanks",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        \\n        int n=nums.size();\\n        int setSize = 1<<n;   // 2^n Number of subset ;\\n        \\n        for(int i=0;i<setSize;i++){\\n            \\n            vector<int>temp;   // for storing values in subsets\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                if(i & (1<<j)){ //Checking for set bits in number i;\\n                temp.push_back(nums[j]);   // Push the value which is at founded index of setbit \\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628820,
                "title": "78-subsets-c-solution-2-approaches-full-explaination",
                "content": "**Please upvote if you like the solution and any improvements or suggestion are welcomed in the comments.**\\n**Problem Statement:** Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.\\n## Approach 1: Using Optimal Substructure\\n**Intuition:** \\nIf we know all the subsets of vector of size n, so, we know the solution for nums[1..n-1]\\nEg - n=3 nums[1,2,3]\\n`Subsets for [1, 2] => {[],[1],[2],[1,2]}`\\nNow, as you can see on adding one more element 3 in above set, \\n* all  the subsets of nums[1..n-1] are also subsets of nums[1..n], so copy them\\n* in all subsets of nums[n-1] add one more element at the end and it will create the subsets resulted by adding the last element\\nSo,\\n```\\nsubsets of [1,2,3]= { [] , [1] , [2] , [1,2] } + { []+[3] , [1] + [3] , [2] + [3] , [1,2] + [3] }\\n                    |  subsets of [1,2]        |   new subsets due to element 3                 | \\n\\t\\t\\t\\t\\t={ [],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]}\\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Subsets.\\nMemory Usage: 7.3 MB, less than 37.30% of C++ online submissions for Subsets\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> superset={{},{nums[0]}};\\n        for(int i=1;i<nums.size();i++){\\n           vector<vector<int>> curr=superset;\\n            for(auto vec : curr){\\n                vec.push_back(nums[i]);\\n                superset.push_back(vec);\\n            }\\n        }\\n        return superset;\\n    }\\n};\\n```\\n**Time Complexity=O(n*2^n)**\\n## Approach 2: Bit Manipulation\\nIntuition-\\nFor set of size n, we know there are 2^n subsets.  So, each element is represented by a bit of N (=2^n)\\nfor i=0 to 2^n-1\\n    select the elements from array whose bit is set\\nExample-\\nFor n=3, there will be N=2^3 = 8 subsets.\\nrepresenting i as 3 bits\\ni=0 => [000] => []\\ni=1 => [00**1**] => [1]\\ni=2 => [0**1**0] => [2]\\ni=3 => [0**11**] => [1,2]\\ni=4 => [**1**00] => [3]\\ni=5 => [**1**0**1**] => [1,3]\\ni=6 => [**11**0] => [2,3]\\ni=7 => [**111**] => [1,2,3]\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        int num = pow(2, n), i = 0;\\n        \\n        while(i<num)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i & 1<<j)\\n                    temp.push_back(nums[j]);\\n            }\\n            for(int i=0; i < temp.size(); i++)\\n            cout<<temp[i]<<\" \";\\n            cout<<\"\\\\n\";\\n            ans.push_back(temp);\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity=O(n*2^n)**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nsubsets of [1,2,3]= { [] , [1] , [2] , [1,2] } + { []+[3] , [1] + [3] , [2] + [3] , [1,2] + [3] }\\n                    |  subsets of [1,2]        |   new subsets due to element 3                 | \\n\\t\\t\\t\\t\\t={ [],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> superset={{},{nums[0]}};\\n        for(int i=1;i<nums.size();i++){\\n           vector<vector<int>> curr=superset;\\n            for(auto vec : curr){\\n                vec.push_back(nums[i]);\\n                superset.push_back(vec);\\n            }\\n        }\\n        return superset;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        int num = pow(2, n), i = 0;\\n        \\n        while(i<num)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i & 1<<j)\\n                    temp.push_back(nums[j]);\\n            }\\n            for(int i=0; i < temp.size(); i++)\\n            cout<<temp[i]<<\" \";\\n            cout<<\"\\\\n\";\\n            ans.push_back(temp);\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1207948,
                "title": "c-78-backtrack-approach",
                "content": "class Solution {\\npublic:\\n    \\n    int n;\\n    vector<vector<int>> ans;\\n    vector<int> eachpair;\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        n = nums.size();\\n        backtrack(0, nums);\\n        \\n        return ans;\\n    }\\n    \\n    void backtrack(int index, vector<int>& nums){\\n        if(index == n){\\n            ans.push_back(eachpair);\\n        }\\n        else{\\n            eachpair.push_back(nums[index]);\\n            backtrack(index+1, nums);\\n            eachpair.pop_back();\\n            backtrack(index+1, nums);\\n        }\\n    }\\n    \\n};\\n\\n![image](https://assets.leetcode.com/users/images/25b23cc5-74c9-45a8-aa6f-a274810c588b_1620993522.5976417.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int n;\\n    vector<vector<int>> ans;\\n    vector<int> eachpair;\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        n = nums.size();\\n        backtrack(0, nums);\\n        \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 348032,
                "title": "swift-one-line-solution",
                "content": "```\\nfunc subsets(_ nums: [Int]) -> [[Int]] {\\n        return nums.reduce([[]]){result, num in\\n              result + result.map{$0 + [num]}\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc subsets(_ nums: [Int]) -> [[Int]] {\\n        return nums.reduce([[]]){result, num in\\n              result + result.map{$0 + [num]}\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27324,
                "title": "simple-c-using-recursion-and-a-template-to-solve-similar-problems",
                "content": "Actually there is a template to those combination problems, you can refer to this post I wrote: [A template to those combination problems](https://discuss.leetcode.com/topic/97538/a-template-to-those-combination-problems).\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        backtrack(nums, 0, vector<int>(), res);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<int>& nums, int k, vector<int> subset, vector<vector<int>>& res){\\n        if(k == nums.size()){\\n            res.push_back(subset);\\n            return;\\n        }\\n        backtrack(nums, k+1, subset, res);\\n        subset.push_back(nums[k]);\\n        backtrack(nums, k+1, subset, res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        backtrack(nums, 0, vector<int>(), res);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<int>& nums, int k, vector<int> subset, vector<vector<int>>& res){\\n        if(k == nums.size()){\\n            res.push_back(subset);\\n            return;\\n        }\\n        backtrack(nums, k+1, subset, res);\\n        subset.push_back(nums[k]);\\n        backtrack(nums, k+1, subset, res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27495,
                "title": "share-my-several-c-solutions-easy-to-understand",
                "content": "***Solution(1):***\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            int n = nums.size();\\n            vector<vector<int>> ret;\\n            if (n == 0)\\n                return ret;\\n                \\n            sort(nums.begin(), nums.end());\\n            \\n            int i = 0, j = 0, len = 0;\\n            vector<int> temp;\\n            ret.push_back(temp);\\n            \\n            for (i = 0; i < n; i++)\\n            {\\n                len = ret.size();\\n                for (j = 0; j < len; j++)\\n                {\\n                    temp = ret[j];\\n                    temp.push_back(nums[i]);\\n                    ret.push_back(temp);\\n                }\\n            }\\n            \\n            return ret;\\n        }\\n    };\\n\\n***Solution(2):using recursion***\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            int n = nums.size();\\n            vector<vector<int>> ret;\\n            vector<int> temp;\\n            \\n            if (n == 0)\\n                return ret;\\n                \\n            sort(nums.begin(), nums.end());\\n            \\n            subsetRecusion(nums, ret, temp, 0);\\n            \\n            return ret;\\n        }\\n        \\n        void subsetRecusion(vector<int>& nums, vector<vector<int>>& ret, vector<int> temp, int i)\\n        {\\n            if (i == nums.size())\\n            {\\n                ret.push_back(temp);\\n                return;\\n            }\\n            \\n            //there is no nums[i]\\n            subsetRecusion(nums, ret, temp, i+1);\\n            \\n            //there is nums[i]\\n            temp.push_back(nums[i]);\\n            subsetRecusion(nums, ret, temp, i+1);\\n        }\\n    };\\n\\n***Solution(3):bit manipulation*** \\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            int n = nums.size();\\n            vector<vector<int>> ret;\\n            if (n == 0)\\n                return ret;\\n                \\n            int total = 1 << n;\\n            int i = 0, j = 0, t = 0;\\n            \\n            sort(nums.begin(), nums.end());\\n            \\n            for (i = 0; i < total; i++)\\n            {\\n                vector<int> temp;\\n                t = i;\\n                j = 0;\\n                \\n                for (j = 0; j < n; j++)\\n                {\\n                    if (t == 0)\\n                        break;\\n                    if (t & 1)\\n                        temp.push_back(nums[j]);\\n                    \\n                    t = t >> 1;\\n                }\\n                \\n                ret.push_back(temp);\\n            }\\n            \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            int n = nums.size();\\n            vector<vector<int>> ret;\\n            if (n == 0)\\n                return ret;\\n                \\n            sort(nums.begin(), nums.end());\\n            \\n            int i = 0, j = 0, len = 0;\\n            vector<int> temp;\\n            ret.push_back(temp);\\n            \\n            for (i = 0; i < n; i++)\\n            {\\n                len = ret.size();\\n                for (j = 0; j < len; j++)\\n                {\\n                    temp = ret[j];\\n                    temp.push_back(nums[i]);\\n                    ret.push_back(temp);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 27564,
                "title": "simple-python-code",
                "content": "    class Solution:\\n        # @param S, a list of integer\\n        # @return a list of lists of integer\\n        def subsets(self, S):\\n        \\tif S == []:\\n        \\t\\treturn []\\n            S.sort() #sort the array to avoid descending list of int\\n            res=[[]]\\n            for element in S:\\n            \\ttemp = []\\n            \\tfor ans in res:\\n            \\t\\t #append the new int to each existing list\\n            \\t\\ttemp.append(ans+[element])\\n            \\tres += temp\\n            return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param S, a list of integer\\n        # @return a list of lists of integer\\n        def subsets(self, S):\\n        \\tif S == []:\\n        \\t\\treturn []\\n            S.sort() #sort the array to avoid descending list of int\\n            res=[[]]\\n            for element in S:\\n            \\ttemp = []\\n            \\tfor ans in res:\\n            \\t\\t #append the new int to each existing list\\n            \\t\\ttemp.append(ans+[element])\\n            \\tres += temp\\n            return res",
                "codeTag": "Java"
            },
            {
                "id": 3434928,
                "title": "java-100-faster-solution-recursion-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(2^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/d36f503d-b393-4657-a375-4904ec0d9f31_1681911363.8691647.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n\\n        List<List<Integer>> ans = new ArrayList<>(); // initialize the answer list\\n\\n        ArrayList<Integer> subset = new ArrayList<>(); // initialize the subset list\\n\\n        helper(nums, 0, subset, ans); // call the recursive helper function with initial values\\n\\n        return ans; // return the answer list\\n    }\\n\\n    public void helper(int nums[], int i, ArrayList<Integer> subset, List<List<Integer>> ans){\\n        \\n        // base case: if the index i has reached the end of the array, add the current subset to the answer list and return\\n        if(i == nums.length){\\n            ans.add(new ArrayList<>(subset));\\n            return;\\n        }\\n\\n        // add the current element to the subset and recursively call the helper function with the next index\\n        subset.add(nums[i]);\\n        helper(nums, i + 1, subset, ans);\\n\\n        // remove the last element from the subset and recursively call the helper function with the next index\\n        subset.remove(subset.size()-1);\\n        helper(nums, i + 1, subset, ans);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n\\n        List<List<Integer>> ans = new ArrayList<>(); // initialize the answer list\\n\\n        ArrayList<Integer> subset = new ArrayList<>(); // initialize the subset list\\n\\n        helper(nums, 0, subset, ans); // call the recursive helper function with initial values\\n\\n        return ans; // return the answer list\\n    }\\n\\n    public void helper(int nums[], int i, ArrayList<Integer> subset, List<List<Integer>> ans){\\n        \\n        // base case: if the index i has reached the end of the array, add the current subset to the answer list and return\\n        if(i == nums.length){\\n            ans.add(new ArrayList<>(subset));\\n            return;\\n        }\\n\\n        // add the current element to the subset and recursively call the helper function with the next index\\n        subset.add(nums[i]);\\n        helper(nums, i + 1, subset, ans);\\n\\n        // remove the last element from the subset and recursively call the helper function with the next index\\n        subset.remove(subset.size()-1);\\n        helper(nums, i + 1, subset, ans);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215703,
                "title": "easiest-solution-have-a-look-java-c",
                "content": "Please Upvote \\uD83D\\uDE0A\\uD83D\\uDE0A\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) {\\n        IList<IList<int>> subsets = new List<IList<int>>();\\n        subsets.Add(new List<int>()); \\n\\n        for(int i=0; i<nums.Length; i++)\\n        {\\n            int count = subsets.Count;\\n            for(int j=0; j<count; j++)\\n            {\\n                var temp = subsets[j].ToList();\\n                temp.Add(nums[i]);\\n                subsets.Add(temp);\\n\\n            }\\n        }\\n        return subsets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) {\\n        IList<IList<int>> subsets = new List<IList<int>>();\\n        subsets.Add(new List<int>()); \\n\\n        for(int i=0; i<nums.Length; i++)\\n        {\\n            int count = subsets.Count;\\n            for(int j=0; j<count; j++)\\n            {\\n                var temp = subsets[j].ToList();\\n                temp.Add(nums[i]);\\n                subsets.Add(temp);\\n\\n            }\\n        }\\n        return subsets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772766,
                "title": "subsets-java-solution-2-approaches-with-explanation",
                "content": "```\\n1. First Approach\\n\\ndivide task for recursion and for us\\nExample:- a[1,2,3]\\n\\ndivide problem as [1] & [2,3]\\nand for [2,3] subsets are :- [],[2],[3],[2,3] now our task is simply add [1] in [2,3] subsets\\ni.e. [1],[1,2],[1,3],[1,2,3] and before updating [2,3] subsets with [1] make a copy of them\\n\\nsubsets of [1,2,3] = [],[2],[3],[2,3],[1],[1,2],[1,3],[1,2,3] \\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        return helper(nums,0);\\n    }\\n    public List<List<Integer>> helper(int[] nums, int index)\\n    {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(index==nums.length){\\n            List<Integer> store = new ArrayList<>();\\n            ans.add(store);\\n            return ans;\\n        }\\n        \\n        List<List<Integer>> partialAns = helper(nums,index+1);\\n        \\n        //store or make a copy of recursion subsets ans so that when we adding our first elementnit does not effect\\n        for(List<Integer> list : partialAns){\\n            ans.add(list);\\n        }\\n        \\n\\t\\t//adding first element to the recursion ans\\n        for(List<Integer> list : partialAns){\\n           List<Integer> list1 = new ArrayList<>();\\n            list1.add(nums[index]);\\n            for(int elem:list)\\n                list1.add(elem);\\n            \\n            ans.add(list1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n2. Second Approach :- Take or Not Take  || Include or Not include\\n\\nExample :- [1,2,3]\\nin this approach we have two options for each element either take this element in our final ans or not take\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n       \\n        List<Integer> subset = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(nums,0,ans,subset);\\n        return ans;\\n    }\\n    public void helper(int[] nums, int index, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(index==nums.length){\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        //include\\n        subset.add(nums[index]);\\n        helper(nums,index+1,ans,subset);\\n        \\n        //exclude\\n        subset.remove(subset.size()-1);\\n        helper(nums,index+1,ans,subset);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n1. First Approach\\n\\ndivide task for recursion and for us\\nExample:- a[1,2,3]\\n\\ndivide problem as [1] & [2,3]\\nand for [2,3] subsets are :- [],[2],[3],[2,3] now our task is simply add [1] in [2,3] subsets\\ni.e. [1],[1,2],[1,3],[1,2,3] and before updating [2,3] subsets with [1] make a copy of them\\n\\nsubsets of [1,2,3] = [],[2],[3],[2,3],[1],[1,2],[1,3],[1,2,3] \\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        return helper(nums,0);\\n    }\\n    public List<List<Integer>> helper(int[] nums, int index)\\n    {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(index==nums.length){\\n            List<Integer> store = new ArrayList<>();\\n            ans.add(store);\\n            return ans;\\n        }\\n        \\n        List<List<Integer>> partialAns = helper(nums,index+1);\\n        \\n        //store or make a copy of recursion subsets ans so that when we adding our first elementnit does not effect\\n        for(List<Integer> list : partialAns){\\n            ans.add(list);\\n        }\\n        \\n\\t\\t//adding first element to the recursion ans\\n        for(List<Integer> list : partialAns){\\n           List<Integer> list1 = new ArrayList<>();\\n            list1.add(nums[index]);\\n            for(int elem:list)\\n                list1.add(elem);\\n            \\n            ans.add(list1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n2. Second Approach :- Take or Not Take  || Include or Not include\\n\\nExample :- [1,2,3]\\nin this approach we have two options for each element either take this element in our final ans or not take\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n       \\n        List<Integer> subset = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(nums,0,ans,subset);\\n        return ans;\\n    }\\n    public void helper(int[] nums, int index, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(index==nums.length){\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        //include\\n        subset.add(nums[index]);\\n        helper(nums,index+1,ans,subset);\\n        \\n        //exclude\\n        subset.remove(subset.size()-1);\\n        helper(nums,index+1,ans,subset);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877168,
                "title": "c-4-ms-easy-to-understand-recursion",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid solve(vector<int>& nums,vector<int>output,int index,vector<vector<int>>&ans)\\n\\t\\t{\\n\\t\\t\\tif(index>=nums.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back(output);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tsolve(nums,output,index+1,ans);\\n\\n\\t\\t\\tint element=nums[index];\\n\\t\\t\\toutput.push_back(element);\\n\\t\\t\\t solve(nums,output,index+1,ans);\\n\\n\\n\\t\\t}\\n\\t\\tvector<vector<int>> subsets(vector<int>& nums) {\\n\\t\\tvector<vector<int>>ans;\\n\\t\\tvector<int>output;\\n\\t\\tint index=0;\\n\\t\\tsolve(nums,output,index,ans);\\n\\n\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid solve(vector<int>& nums,vector<int>output,int index,vector<vector<int>>&ans)\\n\\t\\t{\\n\\t\\t\\tif(index>=nums.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back(output);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1855532,
                "title": "java-simple-iterative-solution-with-easy-explanation-0-ms-faster-than-100-00",
                "content": "![image](https://assets.leetcode.com/users/images/f72cdcf3-be55-4ee2-956a-9824dcdb5f59_1647450776.2683885.jpeg)\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> outer=new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n        for(int num:nums){\\n            int size=outer.size();\\n            for(int i=0;i<size;i++){\\n                List<Integer> internal=new ArrayList<>(outer.get(i));\\n                internal.add(num);\\n                outer.add(internal);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n//please give a reputation if it seems to be easy to understand to you\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> outer=new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n        for(int num:nums){\\n            int size=outer.size();\\n            for(int i=0;i<size;i++){\\n                List<Integer> internal=new ArrayList<>(outer.get(i));\\n                internal.add(num);\\n                outer.add(internal);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n//please give a reputation if it seems to be easy to understand to you\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721954,
                "title": "java-easy-and-clean-code-with-comments",
                "content": "Runtime: 1 ms, faster than 71.85% of Java online submissions for Subsets.\\n\\n```\\n/*\\n\\nSubsets of an array of length n is (2 to the power n). We will loop i from 0 to (2 to the power n). \\nThen take binary form of i and make a subset. As binary form contains 0 or 1 only, so if 1 comes, \\nthen add the element from the array in the subset list, else not. In a subset of array, each element \\nhas 2 choices, either it will come in the subset, or not come in the subset. So, 1 represents that\\nelement will come in the subset, 0 represents element will not come in the subset. \\n\\nExample : nums = [1,2,3]\\n          Number of subsets = (2 to the power 3) = 8. \\n          So, loop from 0 to 7.\\n\\nLoop (i)     |     Binary form     |     Subset we get\\n0            |       000           |       []\\n1            |       001           |       [3]\\n2            |       010           |       [2]\\n3            |       011           |       [2,3]\\n4            |       100           |       [1]\\n5            |       101           |       [1,3]\\n6            |       110           |       [1,2]\\n7            |       111           |       [1,2,3]\\n\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        //main list to store subsets.\\n        List<List<Integer>> ml = new ArrayList<>();\\n        int n = nums.length;\\n        \\n        //total number of subsets = \\'2 to the power n\\' (1 << n = 1 * (2 to the power n) = 2 to the power n).\\n        int numOfSub = 1 << n; \\n        \\n        //As number of subsets of an array of length n is (2 to the power n), so loop i from 0 till (2 to the power n).\\n        for (int i = 0; i < numOfSub; i++) {\\n            //child list to store a subset.\\n            List<Integer> cl = new ArrayList<>();\\n            //Store i in a temp variable as i is controlling outer loop and cannot be messed with.\\n            int temp = i;\\n            \\n            //We are looping backwards, as when we are calculating binary of a number, the first bit that \\n\\t\\t\\t//comes after dividing the number with 2 is the LSB(Least Significant Bit) or the last bit of the \\n\\t\\t\\t//number\\'s binary form. \\n\\t\\t\\t//For more clarification :- When calculating binary form of a number we divide it repeatedly\\n\\t\\t\\t//by 2 until the remainder becomes 0. After that we write the remainder that has come at every \\n\\t\\t\\t//step of division backwards.\\n            for (int j = n - 1; j >= 0; j--) {\\n                //Taking remainder. (temp & 1) is equal to (temp % 2)\\n                int rem = temp & 1;\\n                //Then dividing it by 2. (temp >> 1) is equal to (temp / 2).\\n                temp = temp >> 1;\\n                \\n                //If rem is equal to 1, then add nums[j].\\n                if (rem == 1) {\\n                    cl.add(0, nums[j]);\\n                }\\n            }\\n            \\n            //After a subset is formed, add it in the main list.\\n            ml.add(cl);\\n        }\\n        \\n        return ml;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n\\nSubsets of an array of length n is (2 to the power n). We will loop i from 0 to (2 to the power n). \\nThen take binary form of i and make a subset. As binary form contains 0 or 1 only, so if 1 comes, \\nthen add the element from the array in the subset list, else not. In a subset of array, each element \\nhas 2 choices, either it will come in the subset, or not come in the subset. So, 1 represents that\\nelement will come in the subset, 0 represents element will not come in the subset. \\n\\nExample : nums = [1,2,3]\\n          Number of subsets = (2 to the power 3) = 8. \\n          So, loop from 0 to 7.\\n\\nLoop (i)     |     Binary form     |     Subset we get\\n0            |       000           |       []\\n1            |       001           |       [3]\\n2            |       010           |       [2]\\n3            |       011           |       [2,3]\\n4            |       100           |       [1]\\n5            |       101           |       [1,3]\\n6            |       110           |       [1,2]\\n7            |       111           |       [1,2,3]\\n\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        //main list to store subsets.\\n        List<List<Integer>> ml = new ArrayList<>();\\n        int n = nums.length;\\n        \\n        //total number of subsets = \\'2 to the power n\\' (1 << n = 1 * (2 to the power n) = 2 to the power n).\\n        int numOfSub = 1 << n; \\n        \\n        //As number of subsets of an array of length n is (2 to the power n), so loop i from 0 till (2 to the power n).\\n        for (int i = 0; i < numOfSub; i++) {\\n            //child list to store a subset.\\n            List<Integer> cl = new ArrayList<>();\\n            //Store i in a temp variable as i is controlling outer loop and cannot be messed with.\\n            int temp = i;\\n            \\n            //We are looping backwards, as when we are calculating binary of a number, the first bit that \\n\\t\\t\\t//comes after dividing the number with 2 is the LSB(Least Significant Bit) or the last bit of the \\n\\t\\t\\t//number\\'s binary form. \\n\\t\\t\\t//For more clarification :- When calculating binary form of a number we divide it repeatedly\\n\\t\\t\\t//by 2 until the remainder becomes 0. After that we write the remainder that has come at every \\n\\t\\t\\t//step of division backwards.\\n            for (int j = n - 1; j >= 0; j--) {\\n                //Taking remainder. (temp & 1) is equal to (temp % 2)\\n                int rem = temp & 1;\\n                //Then dividing it by 2. (temp >> 1) is equal to (temp / 2).\\n                temp = temp >> 1;\\n                \\n                //If rem is equal to 1, then add nums[j].\\n                if (rem == 1) {\\n                    cl.add(0, nums[j]);\\n                }\\n            }\\n            \\n            //After a subset is formed, add it in the main list.\\n            ml.add(cl);\\n        }\\n        \\n        return ml;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473439,
                "title": "python-solutions",
                "content": "attempt 2, bitmap\\n```\\n    # Runtime: 32 ms, faster than 83.27%\\n    # Memory Usage: 14.5 MB, less than 50.73%\\n    #\\n    # note:\\n    #     * use a bitmap, each bit represent whethre an element in @nums appears\\n    #       in a subset, e.g., for [1,2,3], 101 => [1,3]\\n    #     * for @nums of length n, we need n bits, so the bitmap would be from 0\\n    #       to 2**(n-1)\\n    #     * then each bit in the bitmap is tested, if the bit is 1, the\\n    #       corresponding element in @nums appears in the current subset\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        for bitmap in range(2**len(nums)): # O(2**n)\\n            cur = []\\n            for i in range(len(nums)):     # O(n)\\n                if bitmap & 2**i:          # note it is 2**i\\n                    cur.append(nums[i])\\n            res.append(cur)\\n        return res\\n```\\nattempt 3, recursion (is this backtrack?)\\n```   \\n   # Runtime: 26 ms, faster than 95.26%\\n    # Memory Usage: 14.5 MB, less than 50.73%\\n    #\\n    # note:\\n    #     * in each recursion, we decide whether node at current location is\\n    #       added to the subset, so the decision tree for [1,2,3] would be:\\n    #                  ___ 1 ___           -> to make decision for the 1st node\\n    #                y/         \\\\n\\n    #                /           \\\\\\n    #              _2_           _2_       -> to make decision for the 2nd node\\n    #            y/   \\\\n       y/   \\\\n\\n    #            /     \\\\       /     \\\\\\n    #           3       3     3       3    -> to make decision for the 3rd node\\n    #         y/ \\\\n   y/ \\\\n y/ \\\\n   y/ \\\\n\\n    #         /   \\\\   /   \\\\ /   \\\\   /   \\\\\\n    #       123   12 13   1 23  2  3    [] -> leaf nodes are all the subsets\\n    #\\n    # time: O(3*2**n)\\n    #     * number of nodes in the decision tree is:\\n    #         2**0 + 2**1 + ... + 2**n\\n    #       = bit(0) + bit(1) + ... + bit(n)\\n    #       = bit(n+1) - 1\\n    #     * for example, for [1,2,3] number of noeds in the decision tree is:\\n    #         2**0 + 2**1 + 2**2 + 2**3\\n    #       = 00001 + 00010 + 00100 + 01000\\n    #       = 01111\\n    #       = 10000 - 00001\\n    #       = 16 - 1 = 15\\n    #     * and for each of the 2**n result, it is appended to @res, this takes\\n    #       O(1) and the append is called 2**n times so totally O(2**n)\\n    #     * therefore the time complexity is:\\n    #         O(2**(n+1)) + O(2**n)\\n    #       = O(2*2**n) + O(2**n)\\n    #       = O(3*2**n)\\n    # space:\\n    #     * for stack usage, the longest path is log(n)\\n    #     * for the result, since there are 2**n results and each of length\\n    #       O(n), it would be O(n*2**n)\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, path):\\n            if i == len(nums):\\n                res.append(path) # subset decisided when a leaf is reached\\n                return\\n            backtrack(i + 1, path + [nums[i]]) # current element added (this creates a new list???)\\n            backtrack(i + 1, path)             # current element skipped\\n        res = []\\n        backtrack(0, [])\\n        return res\\n```\\nattempt 4, backtrack\\n```\\n    # peeked https://leetcode.com/problems/subsets/discuss/362545/Python3-Backtracking\\n    # Runtime: 32 ms, faster than 83.27%\\n    # Memory Usage: 14.5 MB, less than 18.88%\\n    #\\n    # note:\\n    #     * the decision tree for [1,2,3], infeasible paths are avoided by\\n    #       adding only elements with greater indices to the subset, this is how\\n    #       element uniqueness in a subset is guaranteed\\n    #                ____[]_______\\n    #               /         \\\\   \\\\\\n    #              [1]        [2] [3]\\n    #             /   \\\\       /\\n    #          [1,2] [1,3] [2,3]\\n    #           /\\n    #       [1,2,3]\\n    #     * this way the nodes and their subtrees like[1,3,1], [1,3,2], ... are\\n    #       \"pruned\"\\n    #     * therefore unlike the previous attempt, this one does not recored\\n    #       result when i==len(nums)\\n    #     * for path.pop():\\n    #       - as an example, if we just finished [1,2,3] and returned from a\\n    #         call to backtrack(), now @path is [1,2,3] and we want to go back\\n    #         to [1,2] and go the next path (which does not exist though)\\n    #       - as another example, if we just finished [1,2] and returned from a\\n    #         call to backtrack(), now @path is [1,2] and the next path is\\n    #         [1,3], so we have to remove 2\\n    #\\n    # time: O(2*2**n)\\n    #     * number of nodes in the decision tree is 2**n\\n    #     * appending a result to @res takes O(1) and it is called 2**n times\\n    # space: O(2**n)\\n    #     * for stack usage, the deepest path is the subset that contains all\\n    #       the element in @nums, and the elements are added one by one, so it\\n    #       is O(n)\\n    #     * for the result, it is O(n*2**n) as there are 2**n results each has\\n    #       length O(n)\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, path):\\n            # use list() because @path is passed by reference and we want to\\n            # create a new lispt here\\n            res.append(list(path)) # O(1)\\n            for i in range(i, len(nums)):\\n                path.append(nums[i])   # O(1)\\n                backtrack(i + 1, path)\\n                path.pop()             # O(1)\\n        res = []\\n        backtrack(0, [])\\n        return res\\n```\\nattempt 6, cascading\\n```\\n    # ref: https://leetcode.com/problems/subsets/discuss/519823/Simple-Intuitive-Python-Solution\\n    # Runtime: 28 ms, faster than 95.21%\\n    # Memory Usage: 14.2 MB, less than 92.48%\\n    #\\n    # note:\\n    #     * the challenging part of this method is that we can\\'t just create\\n    #       references to the elements in the lists, but we have to make copy of\\n    #       them\\n    #     * ---> [[]]\\n    #       -1-> [[],[1]]\\n    #       -2-> [[],[1],[2],[1,2]]\\n    #       -3-> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\\n    #\\n    # time:\\n    #     * the process is taking lists in @res out and append @n for each of\\n    #       them and @res is started with only one element and ends up with 2**n\\n    #       elements\\n    #       - the process is done 2**0 + 2**1 + ... + 2**n = 2**(n+1) - 1 times\\n    #       - each time the list is copied and appended, which takes O(n) ???\\n    #       - so totally O(n*2**(n+1))\\n    #     * number of nodes in the tree:\\n    #\\n    #     * each element in a subset appended one by one\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for n in nums:          # @n is the element to be added\\n            cur = []            # @cur will be a list in @res each with @n added\\n            for c in res:       # take elements in @res out and add with @n\\n                cur += [c + [n]] # this way we create a new copy of @c with @n added\\n            res += cur\\n        return res\\n```\\nattempt 5, cascading\\n```\\n    # peeked the solution page and\\n    # https://leetcode.com/problems/subsets/discuss/519823/Simple-Intuitive-Python-Solution\\n    #\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for n in nums:\\n            res += [cur + [n] for cur in res]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    # Runtime: 32 ms, faster than 83.27%\\n    # Memory Usage: 14.5 MB, less than 50.73%\\n    #\\n    # note:\\n    #     * use a bitmap, each bit represent whethre an element in @nums appears\\n    #       in a subset, e.g., for [1,2,3], 101 => [1,3]\\n    #     * for @nums of length n, we need n bits, so the bitmap would be from 0\\n    #       to 2**(n-1)\\n    #     * then each bit in the bitmap is tested, if the bit is 1, the\\n    #       corresponding element in @nums appears in the current subset\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        for bitmap in range(2**len(nums)): # O(2**n)\\n            cur = []\\n            for i in range(len(nums)):     # O(n)\\n                if bitmap & 2**i:          # note it is 2**i\\n                    cur.append(nums[i])\\n            res.append(cur)\\n        return res\\n```\n```   \\n   # Runtime: 26 ms, faster than 95.26%\\n    # Memory Usage: 14.5 MB, less than 50.73%\\n    #\\n    # note:\\n    #     * in each recursion, we decide whether node at current location is\\n    #       added to the subset, so the decision tree for [1,2,3] would be:\\n    #                  ___ 1 ___           -> to make decision for the 1st node\\n    #                y/         \\\\n\\n    #                /           \\\\\\n    #              _2_           _2_       -> to make decision for the 2nd node\\n    #            y/   \\\\n       y/   \\\\n\\n    #            /     \\\\       /     \\\\\\n    #           3       3     3       3    -> to make decision for the 3rd node\\n    #         y/ \\\\n   y/ \\\\n y/ \\\\n   y/ \\\\n\\n    #         /   \\\\   /   \\\\ /   \\\\   /   \\\\\\n    #       123   12 13   1 23  2  3    [] -> leaf nodes are all the subsets\\n    #\\n    # time: O(3*2**n)\\n    #     * number of nodes in the decision tree is:\\n    #         2**0 + 2**1 + ... + 2**n\\n    #       = bit(0) + bit(1) + ... + bit(n)\\n    #       = bit(n+1) - 1\\n    #     * for example, for [1,2,3] number of noeds in the decision tree is:\\n    #         2**0 + 2**1 + 2**2 + 2**3\\n    #       = 00001 + 00010 + 00100 + 01000\\n    #       = 01111\\n    #       = 10000 - 00001\\n    #       = 16 - 1 = 15\\n    #     * and for each of the 2**n result, it is appended to @res, this takes\\n    #       O(1) and the append is called 2**n times so totally O(2**n)\\n    #     * therefore the time complexity is:\\n    #         O(2**(n+1)) + O(2**n)\\n    #       = O(2*2**n) + O(2**n)\\n    #       = O(3*2**n)\\n    # space:\\n    #     * for stack usage, the longest path is log(n)\\n    #     * for the result, since there are 2**n results and each of length\\n    #       O(n), it would be O(n*2**n)\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, path):\\n            if i == len(nums):\\n                res.append(path) # subset decisided when a leaf is reached\\n                return\\n            backtrack(i + 1, path + [nums[i]]) # current element added (this creates a new list???)\\n            backtrack(i + 1, path)             # current element skipped\\n        res = []\\n        backtrack(0, [])\\n        return res\\n```\n```\\n    # peeked https://leetcode.com/problems/subsets/discuss/362545/Python3-Backtracking\\n    # Runtime: 32 ms, faster than 83.27%\\n    # Memory Usage: 14.5 MB, less than 18.88%\\n    #\\n    # note:\\n    #     * the decision tree for [1,2,3], infeasible paths are avoided by\\n    #       adding only elements with greater indices to the subset, this is how\\n    #       element uniqueness in a subset is guaranteed\\n    #                ____[]_______\\n    #               /         \\\\   \\\\\\n    #              [1]        [2] [3]\\n    #             /   \\\\       /\\n    #          [1,2] [1,3] [2,3]\\n    #           /\\n    #       [1,2,3]\\n    #     * this way the nodes and their subtrees like[1,3,1], [1,3,2], ... are\\n    #       \"pruned\"\\n    #     * therefore unlike the previous attempt, this one does not recored\\n    #       result when i==len(nums)\\n    #     * for path.pop():\\n    #       - as an example, if we just finished [1,2,3] and returned from a\\n    #         call to backtrack(), now @path is [1,2,3] and we want to go back\\n    #         to [1,2] and go the next path (which does not exist though)\\n    #       - as another example, if we just finished [1,2] and returned from a\\n    #         call to backtrack(), now @path is [1,2] and the next path is\\n    #         [1,3], so we have to remove 2\\n    #\\n    # time: O(2*2**n)\\n    #     * number of nodes in the decision tree is 2**n\\n    #     * appending a result to @res takes O(1) and it is called 2**n times\\n    # space: O(2**n)\\n    #     * for stack usage, the deepest path is the subset that contains all\\n    #       the element in @nums, and the elements are added one by one, so it\\n    #       is O(n)\\n    #     * for the result, it is O(n*2**n) as there are 2**n results each has\\n    #       length O(n)\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, path):\\n            # use list() because @path is passed by reference and we want to\\n            # create a new lispt here\\n            res.append(list(path)) # O(1)\\n            for i in range(i, len(nums)):\\n                path.append(nums[i])   # O(1)\\n                backtrack(i + 1, path)\\n                path.pop()             # O(1)\\n        res = []\\n        backtrack(0, [])\\n        return res\\n```\n```\\n    # ref: https://leetcode.com/problems/subsets/discuss/519823/Simple-Intuitive-Python-Solution\\n    # Runtime: 28 ms, faster than 95.21%\\n    # Memory Usage: 14.2 MB, less than 92.48%\\n    #\\n    # note:\\n    #     * the challenging part of this method is that we can\\'t just create\\n    #       references to the elements in the lists, but we have to make copy of\\n    #       them\\n    #     * ---> [[]]\\n    #       -1-> [[],[1]]\\n    #       -2-> [[],[1],[2],[1,2]]\\n    #       -3-> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\\n    #\\n    # time:\\n    #     * the process is taking lists in @res out and append @n for each of\\n    #       them and @res is started with only one element and ends up with 2**n\\n    #       elements\\n    #       - the process is done 2**0 + 2**1 + ... + 2**n = 2**(n+1) - 1 times\\n    #       - each time the list is copied and appended, which takes O(n) ???\\n    #       - so totally O(n*2**(n+1))\\n    #     * number of nodes in the tree:\\n    #\\n    #     * each element in a subset appended one by one\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for n in nums:          # @n is the element to be added\\n            cur = []            # @cur will be a list in @res each with @n added\\n            for c in res:       # take elements in @res out and add with @n\\n                cur += [c + [n]] # this way we create a new copy of @c with @n added\\n            res += cur\\n        return res\\n```\n```\\n    # peeked the solution page and\\n    # https://leetcode.com/problems/subsets/discuss/519823/Simple-Intuitive-Python-Solution\\n    #\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for n in nums:\\n            res += [cur + [n] for cur in res]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 715304,
                "title": "python-2-ways-w-explnation",
                "content": "**IDEA 1:** For every number in nums, we have the option to either include it or exclude it and proceed further. So, if we have 2 choices for each of the \\uD835\\uDC5B elements, the total number of subsets possible is 2\\\\**n.\\nThis method first builds the lists by including numbers and then backtracks to exclude them and proceed further.\\n\\nThe output for the input [1,2,3] looks like:\\n```\\n    level 0: []\\n    level 1: [1]                    [2]                   [3]\\n    level 2: [1,2]               [1,3]                [2,3] \\n    level 3: [1,2,3]\\n\\n```\\nImplementation: \\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n        self.gen_subsets(nums, 0, [], result)\\n        return result\\n\\n    def gen_subsets(self, nums, curr_idx, curr, result):\\n        result.append(list(curr))\\n        # Iterating over all the elements of the array\\n        for i in range(curr_idx, len(nums)):\\n            # Include\\n            curr.append(nums[i])\\n            # Simulate proceeding while including it\\n            self.gen_subsets(nums, i + 1, curr, result)\\n            # Exclude\\n            curr.pop()\\n\\n```\\n\\n----------------------------------------------------------------------------------------------------\\n\\n\\n**IDEA 2:** Build the result list in a bottom-up manner. Here, we consider one number at a time and then keep building the rest of the list over it. This can be illustrated by the following example:\\n\\n```\\nINPUT                                                      OUTPUT\\n[1]                                                       [[], [1]]\\n[1,2]                                                 [[], [1], [2], [1,2]]\\n[1,2,3]                                     [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]\\n```\\n\\nHere, we can see that when the input is [1,2], we have used the output for [1], as it is, and then added \\'2\\' to every list within the output to obtain the result for [1,2].\\nSimilarly, for [1,2,3], we have used the output for [1,2], as it is, and then added \\'3\\' to every list within the output to obtain the result for [1,2,3].\\n\\nThus, its like doubling the results with some modification.\\nA general pattern can be observed as:\\n**Output for [1...k] = Output for [1...(k-1)] + Add k to every entry in Output for [1...(k-1)]**\\n\\nThus, the implementation:\\n\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        result = [[]]\\n        for ele in nums:\\n            result += [entry + [ele] for entry in result]\\n        return result\\n```\\n\\n\\nIf you found this helpful, please upvote and constructive criticism is always welcome! :)\\nPlease feel free to comment if you\\'ve any doubts! :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    level 0: []\\n    level 1: [1]                    [2]                   [3]\\n    level 2: [1,2]               [1,3]                [2,3] \\n    level 3: [1,2,3]\\n\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n        self.gen_subsets(nums, 0, [], result)\\n        return result\\n\\n    def gen_subsets(self, nums, curr_idx, curr, result):\\n        result.append(list(curr))\\n        # Iterating over all the elements of the array\\n        for i in range(curr_idx, len(nums)):\\n            # Include\\n            curr.append(nums[i])\\n            # Simulate proceeding while including it\\n            self.gen_subsets(nums, i + 1, curr, result)\\n            # Exclude\\n            curr.pop()\\n\\n```\n```\\nINPUT                                                      OUTPUT\\n[1]                                                       [[], [1]]\\n[1,2]                                                 [[], [1], [2], [1,2]]\\n[1,2,3]                                     [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        result = [[]]\\n        for ele in nums:\\n            result += [entry + [ele] for entry in result]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358219,
                "title": "python3-clean-solution-in-5-lines-of-code",
                "content": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans = [[]]\\n        for num in nums:\\n            for i in range(len(ans)):\\n                ans.append(ans[i] + [num])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans = [[]]\\n        for num in nums:\\n            for i in range(len(ans)):\\n                ans.append(ans[i] + [num])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221467,
                "title": "scala-solution",
                "content": "```\\n  def solution(nums: Array[Int]): List[List[Int]] = {\\n    if (nums.isEmpty) return List(List())\\n    val next = solution(nums.tail)\\n    next ++ next.map(_ :+ nums.head)\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  def solution(nums: Array[Int]): List[List[Int]] = {\\n    if (nums.isEmpty) return List(List())\\n    val next = solution(nums.tail)\\n    next ++ next.map(_ :+ nums.head)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 180242,
                "title": "java-o-n-dfs-iterative-recursive-and-bfs",
                "content": "# DFS Iterative\\nThis Solution is a simple extension of **DFS Iterative Pre-Order Traversal** \\n1. Tree needs to be built. So In-Order or Post-Order cannot be used which require to visit child before visiting parent.\\n2. Only Pre-order (Top-Down) is possible.\\n\\n***DFS Iterative Pre-Order***\\n1. Create nodeStack \\n2. Add root to stack\\n3. while nodeStack not empty\\n\\t* \\tPop a node out of the stack\\n\\t* \\tVisit the node\\n\\t* \\tAdd left child to stack\\n\\t* \\tAdd right child ot stack\\n\\n***Extension for this problem***\\n* We do not have a tree yet.\\n* Need to build the tree\\n* So no point creating nodeStack\\n* Instead create positionStack to keep track of the position ***( nums[position] )*** we are dealing with at the moment.\\n* Each position in num[] array crossponds to each level in the tree\\n* Start with position 0\\n1. Create new levelStack \\n2. Add position 0 to levelStack\\n3. Create a tempList - as a carrier to transport values from parent to child\\n4. while ( levelStack not empty )\\n\\t* pop() position from levelStack\\n\\t* We will be dealing with nums[positon] in THIS iteration\\n\\t* Check Exit Condition\\n\\t* Time to create left child\\n\\t\\t* Do not add this num[position] to tempList for left child\\n\\t\\t* Push position+1 into stack\\n\\t* Right child\\n\\t\\t* Add nums[position] into tempList\\n\\t\\t* Again Push position+1 into stack for right child \\n\\t\\n\\t* Exit condition\\n\\t\\t* Check if we are at the leaf\\n\\t\\t* If yes - Then its time to record the node to result list\\n\\t\\t* Once result is recorded restore tempList to previous state (backtracking)\\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n\\t\\tif(nums == null || nums.length <= 0)\\n\\t\\t\\treturn new ArrayList<>();\\n\\t\\t\\n\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\tStack<Integer> levelStack = new Stack<>();\\n\\t\\tList<Integer> tempList = new ArrayList<>();\\n\\t\\tlevelStack.push(0);\\n\\t\\t\\n\\t\\twhile(!levelStack.isEmpty()){\\n\\t\\t\\tint pos = levelStack.pop();\\n\\t\\t\\tif(pos == nums.length){ //Exit condition\\n\\t\\t\\t\\tlistCnt++; \\n\\t\\t\\t\\tres.add(new ArrayList<>(tempList));\\n\\t\\t\\t\\tif(!tempList.isEmpty())\\n\\t\\t\\t\\t\\ttempList.remove(tempList.size()-1);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t//Left child\\n\\t\\t\\tlevelStack.push(pos+1);\\n\\t\\t\\t//Right child\\n\\t\\t\\ttempList.add(nums[pos]);\\n\\t\\t\\tlevelStack.push(pos+1);\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n}\\n```\\n\\n# DFS Recursive\\n```\\npublic List<List<Integer>> subsets_DFS_Recursive(int[] nums) {\\n\\tif(nums == null || nums.length <= 0)\\n\\t\\treturn new ArrayList<>();\\n\\n\\tList<List<Integer>> result = new ArrayList<>();\\n\\tList<Integer> input = new ArrayList<>();\\n\\tdfs_Recursive(nums, 0, input, result);\\n\\treturn result;\\n}\\n\\nprivate void dfs_Recursive(int[] nums, int position, List<Integer> input, List<List<Integer>> result) {\\n\\tif(position == nums.length) {\\n\\t\\tresult.add(new ArrayList<>(input));\\n\\t\\treturn;\\n\\t}\\n\\n\\tdfs_Recursive(nums, position+1, input, result);\\n\\tinput.add(nums[position]);\\n\\tdfs_Recursive(nums, position+1, input, result);\\n\\tinput.remove(input.size()-1);\\n}\\n```\\n# BFS\\n```\\npublic List<List<Integer>> subsets_BFS(int[] nums) {\\n\\tif(nums == null || nums.length <= 0)\\n\\t\\treturn new ArrayList<>();\\n\\n\\tList<List<Integer>> res = new ArrayList<>();\\n\\tQueue<List<Integer>> queue = new LinkedList<>(); \\n\\tqueue.offer(new ArrayList<Integer>());\\n\\n\\tfor(int i=0; i<nums.length; i++){\\n\\t\\tint levelSize = queue.size();\\n\\t\\tfor(int j=0; j<levelSize; j++){\\n\\t\\t\\tList<Integer> polled = queue.poll();\\n\\n\\t\\t\\tList<Integer> leftChild = polled;\\n\\t\\t\\t//Left child - Reuse parent\\'s array list obj\\n\\t\\t\\tqueue.offer(leftChild);\\n\\n\\t\\t\\t//Left child has reused the parent\\'s arraylist.. So right child creates a new copy\\n\\t\\t\\tList<Integer> rightChild = new ArrayList<>(polled);\\n\\t\\t\\trightChild.add(nums[i]);\\n\\t\\t\\tqueue.offer(rightChild);\\n\\t\\t}\\t\\n\\t}\\n\\tres.addAll(queue);\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n\\t\\tif(nums == null || nums.length <= 0)\\n\\t\\t\\treturn new ArrayList<>();\\n\\t\\t\\n\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\tStack<Integer> levelStack = new Stack<>();\\n\\t\\tList<Integer> tempList = new ArrayList<>();\\n\\t\\tlevelStack.push(0);\\n\\t\\t\\n\\t\\twhile(!levelStack.isEmpty()){\\n\\t\\t\\tint pos = levelStack.pop();\\n\\t\\t\\tif(pos == nums.length){ //Exit condition\\n\\t\\t\\t\\tlistCnt++; \\n\\t\\t\\t\\tres.add(new ArrayList<>(tempList));\\n\\t\\t\\t\\tif(!tempList.isEmpty())\\n\\t\\t\\t\\t\\ttempList.remove(tempList.size()-1);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t//Left child\\n\\t\\t\\tlevelStack.push(pos+1);\\n\\t\\t\\t//Right child\\n\\t\\t\\ttempList.add(nums[pos]);\\n\\t\\t\\tlevelStack.push(pos+1);\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n}\\n```\n```\\npublic List<List<Integer>> subsets_DFS_Recursive(int[] nums) {\\n\\tif(nums == null || nums.length <= 0)\\n\\t\\treturn new ArrayList<>();\\n\\n\\tList<List<Integer>> result = new ArrayList<>();\\n\\tList<Integer> input = new ArrayList<>();\\n\\tdfs_Recursive(nums, 0, input, result);\\n\\treturn result;\\n}\\n\\nprivate void dfs_Recursive(int[] nums, int position, List<Integer> input, List<List<Integer>> result) {\\n\\tif(position == nums.length) {\\n\\t\\tresult.add(new ArrayList<>(input));\\n\\t\\treturn;\\n\\t}\\n\\n\\tdfs_Recursive(nums, position+1, input, result);\\n\\tinput.add(nums[position]);\\n\\tdfs_Recursive(nums, position+1, input, result);\\n\\tinput.remove(input.size()-1);\\n}\\n```\n```\\npublic List<List<Integer>> subsets_BFS(int[] nums) {\\n\\tif(nums == null || nums.length <= 0)\\n\\t\\treturn new ArrayList<>();\\n\\n\\tList<List<Integer>> res = new ArrayList<>();\\n\\tQueue<List<Integer>> queue = new LinkedList<>(); \\n\\tqueue.offer(new ArrayList<Integer>());\\n\\n\\tfor(int i=0; i<nums.length; i++){\\n\\t\\tint levelSize = queue.size();\\n\\t\\tfor(int j=0; j<levelSize; j++){\\n\\t\\t\\tList<Integer> polled = queue.poll();\\n\\n\\t\\t\\tList<Integer> leftChild = polled;\\n\\t\\t\\t//Left child - Reuse parent\\'s array list obj\\n\\t\\t\\tqueue.offer(leftChild);\\n\\n\\t\\t\\t//Left child has reused the parent\\'s arraylist.. So right child creates a new copy\\n\\t\\t\\tList<Integer> rightChild = new ArrayList<>(polled);\\n\\t\\t\\trightChild.add(nums[i]);\\n\\t\\t\\tqueue.offer(rightChild);\\n\\t\\t}\\t\\n\\t}\\n\\tres.addAll(queue);\\n\\treturn res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 178796,
                "title": "kotlin-solution-short-and-simple",
                "content": "Kotlin deals with lists in very elegant way, as you can see below. The only thing that might be not obvious is `result.map { it + num}` which for each list in result adds current element `num`. BUT `map` doesn\\'t modify collection itself (`result` in this case), it returns mapped lists.\\n```\\n    fun subsets(nums: IntArray): List<List<Int>> {\\n        val result = mutableListOf(emptyList<Int>())\\n        nums.forEach { num ->\\n            val newAdditions = result.map { it + num}\\n            result.addAll(newAdditions)\\n        }\\n        return result\\n    }",
                "solutionTags": [],
                "code": "Kotlin deals with lists in very elegant way, as you can see below. The only thing that might be not obvious is `result.map { it + num}` which for each list in result adds current element `num`. BUT `map` doesn\\'t modify collection itself (`result` in this case), it returns mapped lists.\\n```\\n    fun subsets(nums: IntArray): List<List<Int>> {\\n        val result = mutableListOf(emptyList<Int>())\\n        nums.forEach { num ->\\n            val newAdditions = result.map { it + num}\\n            result.addAll(newAdditions)\\n        }\\n        return result\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 27622,
                "title": "share-my-accepted-simple-python-code",
                "content": "    class Solution:\\n    # @param S, a list of integer\\n    # @return a list of lists of integer\\n    def subsets(self, S):\\n        if not S:\\n            return [[]]\\n        else:\\n            S.sort()\\n            pre_subsets = self.subsets(S[1:])\\n            return pre_subsets + [[S[0]]+elem for elem in pre_subsets]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param S, a list of integer\\n    # @return a list of lists of integer\\n    def subsets(self, S):\\n        if not S:\\n            return [[]]\\n        else:\\n            S.sort()\\n            pre_subsets = self.subsets(S[1:])\\n            return pre_subsets + [[S[0]]+elem for elem in pre_subsets]",
                "codeTag": "Java"
            },
            {
                "id": 27624,
                "title": "accepted-dynamic-solution-with-explanation-in-cpp",
                "content": "    /*\\n       LEgend:\\n            #S -> size of input set\\n            #SS(n) -> total number of subsets for a set with size n (i.e 2^n)\\n            S(i) ->ith element of input set\\n            SS(i) -> ith element of the set of subsets of S (starting from 0)\\n            SSn = set of Subset for Sn\\n            SS(#SS(n)-1) -> Last element in SSn\\n       \\n       Logic:\\n            #SS(n)= 2 * #SS(n-1)\\n            => SSn = SSn-1 U { {SS(0),S(n)} , {SS(1),S(n)} , ...  , {SS(#SS(n-1)-1),S(n)} }\\n      \\n       Explanation :      \\n        In simple words,I am using the logic of Dynamic Programming and breaking the problem in smaller subproblems\\n        \\n        eg. S={1,2}\\n        SS2 = { { } , {1} , {2} , {1,2} }\\n        \\n        now to get the subset for {1,2,3} we add the element 3 \\n         in each of the solution set of SS and with this new set do union of SS\\n        \\n        SS3 = SS2 U { {3} , {1,3} , {2,3} , {1,2,3} }\\n            = { {} , {1} , {2} , {1,2} , {3} , {1,3} , {2,3} , {1,2,3} }  \\n    */\\n    \\n        vector<vector<int> > subsets(vector<int> &S) {\\n            vector <int> temp;\\n            vector<vector<int> >ans;\\n            ans.push_back(temp);   //Enters null set\\n            int len=S.size();\\n            int len2;\\n            if(len==0)\\n             return ans;\\n        \\n            sort(S.begin(),S.end());\\n            \\n            for(int i=0 ; i<len ; i++)   //Traverses the whole input array\\n            {    \\n                len2=ans.size();\\n              // Since we cannot append the new number along with the null set therefore this is done outside the loop\\n                temp.clear();\\n                temp.push_back(S[i]);\\n                ans.push_back(temp);\\n            \\n                for(int j=1 ; j<len2 ; j++)\\n                {\\n                    vector<int> temp2(ans[j]);\\n                    temp2.push_back(S[i]);\\n                    ans.push_back(temp2);\\n                }\\n            }\\n            return ans;\\n        }",
                "solutionTags": [],
                "code": "    /*\\n       LEgend:\\n            #S -> size of input set\\n            #SS(n) -> total number of subsets for a set with size n (i.e 2^n)\\n            S(i) ->ith element of input set\\n            SS(i) -> ith element of the set of subsets of S (starting from 0)\\n            SSn = set of Subset for Sn\\n            SS(#SS(n)-1) -> Last element in SSn\\n       \\n       Logic:\\n            #SS(n)= 2 * #SS(n-1)\\n            => SSn = SSn-1 U { {SS(0),S(n)} , {SS(1),S(n)} , ...  , {SS(#SS(n-1)-1),S(n)} }\\n      \\n       Explanation :      \\n        In simple words,I am using the logic of Dynamic Programming and breaking the problem in smaller subproblems\\n        \\n        eg. S={1,2}\\n        SS2 = { { } , {1} , {2} , {1,2} }\\n        \\n        now to get the subset for {1,2,3} we add the element 3 \\n         in each of the solution set of SS and with this new set do union of SS\\n        \\n        SS3 = SS2 U { {3} , {1,3} , {2,3} , {1,2,3} }\\n            = { {} , {1} , {2} , {1,2} , {3} , {1,3} , {2,3} , {1,2,3} }  \\n    */\\n    \\n        vector<vector<int> > subsets(vector<int> &S) {\\n            vector <int> temp;\\n            vector<vector<int> >ans;\\n            ans.push_back(temp);   //Enters null set\\n            int len=S.size();\\n            int len2;\\n            if(len==0)\\n             return ans;\\n        \\n            sort(S.begin(),S.end());\\n            \\n            for(int i=0 ; i<len ; i++)   //Traverses the whole input array\\n            {    \\n                len2=ans.size();\\n              // Since we cannot append the new number along with the null set therefore this is done outside the loop\\n                temp.clear();\\n                temp.push_back(S[i]);\\n                ans.push_back(temp);\\n            \\n                for(int j=1 ; j<len2 ; j++)\\n                {\\n                    vector<int> temp2(ans[j]);\\n                    temp2.push_back(S[i]);\\n                    ans.push_back(temp2);\\n                }\\n            }\\n            return ans;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3164338,
                "title": "solution",
                "content": "```C++ []\\n#include <vector>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> pw_set;\\n        vector<int> subset;\\n        recurse(nums, subset, pw_set, 0);\\n        return pw_set;\\n    }\\nprivate:\\n    void recurse (vector<int>& nums, vector<int>& subset, vector<vector<int>>& pw_set, int i) {\\n        if (i >= nums.size()) {\\n            pw_set.push_back(subset);\\n            return;\\n        }\\n        subset.push_back(nums[i]);\\n        recurse(nums, subset, pw_set, i + 1);\\n\\n        subset.pop_back();\\n        recurse(nums, subset, pw_set, i + 1);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = [[]]\\n\\n        for num in nums:\\n            n = len(subsets)\\n\\n            for i in range(n):\\n                subset = list(subsets[i])\\n                subset.append(num)\\n                subsets.append(subset)\\n\\n        return subsets\\n```\\n\\n```Java []\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> outer = new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n\\n        for(int num : nums) {\\n            int n = outer.size();\\n            for(int i = 0; i < n; i++) {\\n                List<Integer> list = new ArrayList<>(outer.get(i));\\n                list.add(num);\\n                outer.add(list);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\n#include <vector>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> pw_set;\\n        vector<int> subset;\\n        recurse(nums, subset, pw_set, 0);\\n        return pw_set;\\n    }\\nprivate:\\n    void recurse (vector<int>& nums, vector<int>& subset, vector<vector<int>>& pw_set, int i) {\\n        if (i >= nums.size()) {\\n            pw_set.push_back(subset);\\n            return;\\n        }\\n        subset.push_back(nums[i]);\\n        recurse(nums, subset, pw_set, i + 1);\\n\\n        subset.pop_back();\\n        recurse(nums, subset, pw_set, i + 1);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = [[]]\\n\\n        for num in nums:\\n            n = len(subsets)\\n\\n            for i in range(n):\\n                subset = list(subsets[i])\\n                subset.append(num)\\n                subsets.append(subset)\\n\\n        return subsets\\n```\n```Java []\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> outer = new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n\\n        for(int num : nums) {\\n            int n = outer.size();\\n            for(int i = 0; i < n; i++) {\\n                List<Integer> list = new ArrayList<>(outer.get(i));\\n                list.add(num);\\n                outer.add(list);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2034062,
                "title": "subset-i-4-approaches-java-solution",
                "content": "### Approach 1 :  Recursive\\n```\\n//Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        helper(nums , 0 , new ArrayList<Integer>() , ans );\\n        return ans;\\n    }\\n    \\n    void helper(int[] nums , int i , ArrayList<Integer> list , List<List<Integer>> ans)\\n    {\\n        if(i==nums.length)\\n        {\\n            ans.add(new ArrayList<>(list));\\n            return ;\\n        }\\n        helper(nums,i+1 , new ArrayList<>(list) , ans);\\n        list.add(nums[i]);\\n        helper(nums , i+1 , list , ans);\\n    }\\n}\\n```\\n\\n### Approach 2 :  Recursive Backtracking\\n```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n         List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        subset(nums, 0 , new ArrayList<>() , ans);\\n        return ans;\\n    }\\n    \\n    void subset(int[] nums , int p , ArrayList<Integer> list, List<List<Integer>> ans)\\n    {\\n        ans.add(new ArrayList<>(list));\\n        for(int i=p ; i<nums.length;i++)\\n        {\\n            list.add(nums[i]);\\n            subset(nums , i+1, list , ans);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n\\n```\\n\\n### Approach 3 : Bit Manipulation\\n\\n```\\n// Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        int n = nums.length;\\n       //loop will run for 2^n-1 times\\n       for(int i=0;i<(1<<n) ; i++)\\n       {\\n           ArrayList<Integer> list = new ArrayList<>();\\n           for(int k=0;k<n;k++)\\n           {\\n               if((i & (1<<k))>0)\\n                   list.add(nums[k]);\\n           }\\n               ans.add(new ArrayList<>(list));\\n       }\\n       return ans;   \\n    }\\n}\\n```\\n\\n### Aproach 4 : Iterative Solution\\n```\\n// Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        ans.add(new ArrayList<>()); //adding empty arraylist inside ans\\n        for(int i=0;i<nums.length;i++)   \\n        {\\n            int n=ans.size();\\n            for(int j=0;j<n;j++)\\n            {\\n                //have added the list with same elements \\n                ans.add(new ArrayList<>(ans.get(j)));\\n                //now make sure to add another element too\\n                ans.get(ans.size()-1).add(nums[i]);\\n            }   \\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n* We can see here , Recursive Backtracking is the fastest approach",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\n//Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        helper(nums , 0 , new ArrayList<Integer>() , ans );\\n        return ans;\\n    }\\n    \\n    void helper(int[] nums , int i , ArrayList<Integer> list , List<List<Integer>> ans)\\n    {\\n        if(i==nums.length)\\n        {\\n            ans.add(new ArrayList<>(list));\\n            return ;\\n        }\\n        helper(nums,i+1 , new ArrayList<>(list) , ans);\\n        list.add(nums[i]);\\n        helper(nums , i+1 , list , ans);\\n    }\\n}\\n```\n```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n         List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        subset(nums, 0 , new ArrayList<>() , ans);\\n        return ans;\\n    }\\n    \\n    void subset(int[] nums , int p , ArrayList<Integer> list, List<List<Integer>> ans)\\n    {\\n        ans.add(new ArrayList<>(list));\\n        for(int i=p ; i<nums.length;i++)\\n        {\\n            list.add(nums[i]);\\n            subset(nums , i+1, list , ans);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n\\n```\n```\\n// Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        int n = nums.length;\\n       //loop will run for 2^n-1 times\\n       for(int i=0;i<(1<<n) ; i++)\\n       {\\n           ArrayList<Integer> list = new ArrayList<>();\\n           for(int k=0;k<n;k++)\\n           {\\n               if((i & (1<<k))>0)\\n                   list.add(nums[k]);\\n           }\\n               ans.add(new ArrayList<>(list));\\n       }\\n       return ans;   \\n    }\\n}\\n```\n```\\n// Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        ans.add(new ArrayList<>()); //adding empty arraylist inside ans\\n        for(int i=0;i<nums.length;i++)   \\n        {\\n            int n=ans.size();\\n            for(int j=0;j<n;j++)\\n            {\\n                //have added the list with same elements \\n                ans.add(new ArrayList<>(ans.get(j)));\\n                //now make sure to add another element too\\n                ans.get(ans.size()-1).add(nums[i]);\\n            }   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766605,
                "title": "highly-commented-recursive-javascript-90-faster-easy-understanding",
                "content": "```\\n/* This is a recursive solution\\nFor recursion we need 2 main thing:\\n1) Base case or the terminating condition\\n2) Next state transition/Recurrence Relation i.e\\n A way to move to next from current state/input\\n\\n In this problem our base case will be when we have\\n iterated through the entire length of array i.e\\n when currentIndex >= nums.length\\n\\n And we can apply common sense to derive recurrence relation.\\n So for currentIndex we have only two choices i.e.\\n we can either select/include the number at current index in out set\\n or we can exclude/pass the number at current index.\\n If we choose to include the number in our set when we can do it by [...set,nums[currentIndex]]\\n otherwise if we exclude/pass currentIndex num then our set will remain same as it was earlier i.e set\\n And in either case we will increment our currentIndex so that next time we \\n check for another number in nums array\\n\\n Now let\\'s look into the code \\n */\\nvar subsets = function (nums) {\\n\\t//Array finalOutput stores all the power sets\\n\\tlet finalOutput = [];\\n\\n\\t// Helper method is a recursive function that call\\'s itself\\n\\tconst helper = (currentIndex, set) => {\\n\\t\\t// Check for base case as stated above\\n\\t\\tif (currentIndex >= nums.length) {\\n\\t\\t\\t// push the set of current iteration in finalOutput\\n\\t\\t\\tfinalOutput.push(set);\\n\\t\\t\\treturn; //Necessary to end the recursion iteration\\n\\t\\t}\\n\\n\\t\\t//This is the 1st case where we are including the currentIndex number\\n\\t\\t// We increment currentIndex and add currentNumber i.e nums[currentIndex] in our set i.e. [...set, nums[currentIndex]]\\n\\t\\thelper(currentIndex + 1, [...set, nums[currentIndex]]);\\n\\n\\t\\t// This is the second case where we are excluding the currentIndex number\\n\\t\\t// We increment currentIndex and our set remains unchanged\\n\\t\\thelper(currentIndex + 1, set);\\n\\t};\\n\\t//1st call to recursive function\\n\\thelper(0, []);\\n\\n\\t// return our power set stored in finalOutput\\n\\treturn finalOutput;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/* This is a recursive solution\\nFor recursion we need 2 main thing:\\n1) Base case or the terminating condition\\n2) Next state transition/Recurrence Relation i.e\\n A way to move to next from current state/input\\n\\n In this problem our base case will be when we have\\n iterated through the entire length of array i.e\\n when currentIndex >= nums.length\\n\\n And we can apply common sense to derive recurrence relation.\\n So for currentIndex we have only two choices i.e.\\n we can either select/include the number at current index in out set\\n or we can exclude/pass the number at current index.\\n If we choose to include the number in our set when we can do it by [...set,nums[currentIndex]]\\n otherwise if we exclude/pass currentIndex num then our set will remain same as it was earlier i.e set\\n And in either case we will increment our currentIndex so that next time we \\n check for another number in nums array\\n\\n Now let\\'s look into the code \\n */\\nvar subsets = function (nums) {\\n\\t//Array finalOutput stores all the power sets\\n\\tlet finalOutput = [];\\n\\n\\t// Helper method is a recursive function that call\\'s itself\\n\\tconst helper = (currentIndex, set) => {\\n\\t\\t// Check for base case as stated above\\n\\t\\tif (currentIndex >= nums.length) {\\n\\t\\t\\t// push the set of current iteration in finalOutput\\n\\t\\t\\tfinalOutput.push(set);\\n\\t\\t\\treturn; //Necessary to end the recursion iteration\\n\\t\\t}\\n\\n\\t\\t//This is the 1st case where we are including the currentIndex number\\n\\t\\t// We increment currentIndex and add currentNumber i.e nums[currentIndex] in our set i.e. [...set, nums[currentIndex]]\\n\\t\\thelper(currentIndex + 1, [...set, nums[currentIndex]]);\\n\\n\\t\\t// This is the second case where we are excluding the currentIndex number\\n\\t\\t// We increment currentIndex and our set remains unchanged\\n\\t\\thelper(currentIndex + 1, set);\\n\\t};\\n\\t//1st call to recursive function\\n\\thelper(0, []);\\n\\n\\t// return our power set stored in finalOutput\\n\\treturn finalOutput;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1570009,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions-for-subsets",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int n=nums.length;\\n        \\n        int range=1<<n;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<range;i++){\\n            int x=i;\\n            ArrayList<Integer> a=new ArrayList<>();\\n            int j=0;   \\n            while(x>0 && j<n){\\n                if((x&1)==1){\\n                    a.add(nums[n-1-j]);\\n                }\\n                j++;\\n                x=x>>1;\\n            }\\n            ans.add(a);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int n=nums.length;\\n        \\n        int range=1<<n;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<range;i++){\\n            int x=i;\\n            ArrayList<Integer> a=new ArrayList<>();\\n            int j=0;   \\n            while(x>0 && j<n){\\n                if((x&1)==1){\\n                    a.add(nums[n-1-j]);\\n                }\\n                j++;\\n                x=x>>1;\\n            }\\n            ans.add(a);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308506,
                "title": "java-0ms-easy-solution",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> lists;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        lists = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        solve(list,nums,0);\\n        \\n        return lists;\\n    }\\n    \\n    void solve(List<Integer> list,int[] nums,int curr)\\n    {\\n        \\n        if(curr == nums.length)\\n        {\\n            lists.add(new ArrayList(list));\\n            return;\\n        }\\n        \\n        List<Integer> list2 = new ArrayList(list);\\n        list.add(nums[curr]);\\n        solve(list2,nums,curr+1);\\n        solve(list,nums,curr+1);\\n        \\n    }\\n    \\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> lists;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        lists = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        solve(list,nums,0);\\n        \\n        return lists;\\n    }\\n    \\n    void solve(List<Integer> list,int[] nums,int curr)\\n    {\\n        \\n        if(curr == nums.length)\\n        {\\n            lists.add(new ArrayList(list));\\n            return;\\n        }\\n        \\n        List<Integer> list2 = new ArrayList(list);\\n        list.add(nums[curr]);\\n        solve(list2,nums,curr+1);\\n        solve(list,nums,curr+1);\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213159,
                "title": "easiest-solution-with-recursive-tree-intuitive-java-diagram",
                "content": "**Intuition**\\n\\nThe intuition behind the following solution is too simple to believe. Let us first have a look at the following option tree : \\n\\n![image](https://assets.leetcode.com/users/images/1ca8ad88-a0dc-4995-82e0-ce6822177b98_1621218217.2663536.png)\\n\\nAs through observation, it is clear that we start with having a choice to pick or not pick from the first element and then, we propagate this choice down the tree. \\nSo, \\n1. we either pick the element and move ahead ( increment the index ) or,\\n2. we don\\'t pick the element and move ahead\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        result = new ArrayList();\\n        if(nums==null || nums.length==0) return result;\\n        \\n        subsets(nums,new ArrayList<Integer>(), 0);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, ArrayList<Integer> temp, int index) {\\n        // base condition\\n        if(index >= nums.length) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        \\n        // main logic\\n\\t\\t// case 1 : we pick the element\\n        temp.add(nums[index]);\\n        subsets(nums, temp, index+1); // move ahead\\n        temp.remove(temp.size()-1);\\n        \\n\\t\\t// case 2 : we don\\'t pick the element ( notice, we did not add the current element in our temporary list\\n        subsets(nums, temp, index+1); // move ahead\\n    }\\n}\\n```\\n\\n\\nProceed to solve this related problem : [https://leetcode.com/problems/subsets-ii/](http://)\\n\\n[ Here is the explanation to the same ]\\n[https://leetcode.com/problems/subsets-ii/discuss/1213326/Simple-Intuitive-Solution-or-Using-HashSet](http://)",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        result = new ArrayList();\\n        if(nums==null || nums.length==0) return result;\\n        \\n        subsets(nums,new ArrayList<Integer>(), 0);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, ArrayList<Integer> temp, int index) {\\n        // base condition\\n        if(index >= nums.length) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        \\n        // main logic\\n\\t\\t// case 1 : we pick the element\\n        temp.add(nums[index]);\\n        subsets(nums, temp, index+1); // move ahead\\n        temp.remove(temp.size()-1);\\n        \\n\\t\\t// case 2 : we don\\'t pick the element ( notice, we did not add the current element in our temporary list\\n        subsets(nums, temp, index+1); // move ahead\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161814,
                "title": "java-easy-bit-manipulation",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        List<List<Integer>> ans=  new ArrayList<>();\\n        for(int i= 0; i < (1 << nums.length); ++i){\\n            List<Integer> res = new ArrayList<>();\\n            for(int j= 0; j < nums.length; ++j){\\n                if(((i >> j) & 1 )!= 0)res.add(nums[j]);\\n            }\\n            \\n            ans.add(new ArrayList(res));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        List<List<Integer>> ans=  new ArrayList<>();\\n        for(int i= 0; i < (1 << nums.length); ++i){\\n            List<Integer> res = new ArrayList<>();\\n            for(int j= 0; j < nums.length; ++j){\\n                if(((i >> j) & 1 )!= 0)res.add(nums[j]);\\n            }\\n            \\n            ans.add(new ArrayList(res));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083568,
                "title": "4-different-solutions-to-find-subsets",
                "content": "**Solution 1: Use python funciton itertools.combinations**\\n````\\nfrom itertools import combinations\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        l = len(nums)\\n        ret = []\\n        for i in range(l+1):\\n            temp = list(map(list, combinations(nums, i)))\\n            ret += temp\\n        return ret\\n````\\n**Solution 2: Dynamic programming**\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        dp = [[]]\\n        for n in nums:\\n            dp += [it + [n] for it in dp]\\n        return dp\\n```\\n**Solution 3: General recursion + backtracking solution**\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ret = []\\n        def dfs(i, path):\\n            ret.append(path)\\n            for j in range(i, len(nums)):\\n                dfs(j+1, path + [nums[j]]) # here should be j+1 rather than j!\\n        dfs(0, [])\\n        return ret\\n```\\n**Solution 4: Bit manipulation to find subsets**\\nUse bit manipulation to find subsets might be useful in other LeetCode problems.\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        # for example nums is [5, 6, 1], input number is 3, convert to binary is 011, then return list should be [6, 1]\\n\\t\\t# if input number is 5 which binary is 101, then return list is [5, 1]\\n        def bit2list(n):\\n            ret = []\\n            idx = 0\\n            while n:\\n                if n&1:\\n                    ret.append(nums[idx])\\n                n >>= 1\\n                idx += 1\\n            return ret\\n        # convert nums to binary, if len(nums)=3, output is 111; if len(nums)=4, output is 1111\\n        base, one = 0, 1\\n        for _ in range(len(nums)):\\n            base += one\\n            one <<= 1\\n        # Use bit manipulation to find subsets; e.g. base=11, subsets: 10, 01\\n\\t\\tret = []\\n        mask = base\\n        while mask:\\n            ret.append(bit2list(mask))\\n            mask = (mask - 1) & base\\n        return ret + [[]]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "````\\nfrom itertools import combinations\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        l = len(nums)\\n        ret = []\\n        for i in range(l+1):\\n            temp = list(map(list, combinations(nums, i)))\\n            ret += temp\\n        return ret\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        dp = [[]]\\n        for n in nums:\\n            dp += [it + [n] for it in dp]\\n        return dp\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ret = []\\n        def dfs(i, path):\\n            ret.append(path)\\n            for j in range(i, len(nums)):\\n                dfs(j+1, path + [nums[j]]) # here should be j+1 rather than j!\\n        dfs(0, [])\\n        return ret\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        # for example nums is [5, 6, 1], input number is 3, convert to binary is 011, then return list should be [6, 1]\\n\\t\\t# if input number is 5 which binary is 101, then return list is [5, 1]\\n        def bit2list(n):\\n            ret = []\\n            idx = 0\\n            while n:\\n                if n&1:\\n                    ret.append(nums[idx])\\n                n >>= 1\\n                idx += 1\\n            return ret\\n        # convert nums to binary, if len(nums)=3, output is 111; if len(nums)=4, output is 1111\\n        base, one = 0, 1\\n        for _ in range(len(nums)):\\n            base += one\\n            one <<= 1\\n        # Use bit manipulation to find subsets; e.g. base=11, subsets: 10, 01\\n\\t\\tret = []\\n        mask = base\\n        while mask:\\n            ret.append(bit2list(mask))\\n            mask = (mask - 1) & base\\n        return ret + [[]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946533,
                "title": "c-recursve-diagram-to-show-how-backtracking-works-here",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs;\\n        vector<int> currvec;\\n        subsets(nums, 0, currvec, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int> nums, int i, vector<int> currvec, vector<vector<int>>& subs) {\\n\\t\\n        subs.push_back(currvec);\\n\\t\\t\\n        for (int j = i; j < nums.size(); j++) {\\n            currvec.push_back(nums[j]);\\n            subsets(nums, j + 1, currvec, subs);\\n            currvec.pop_back();\\n        }\\n    }\\n};\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c1b75fc0-1b93-4663-a0b1-ce558ffe9a1e_1606145921.6017413.png)\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs;\\n        vector<int> currvec;\\n        subsets(nums, 0, currvec, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int> nums, int i, vector<int> currvec, vector<vector<int>>& subs) {\\n\\t\\n        subs.push_back(currvec);\\n\\t\\t\\n        for (int j = i; j < nums.size(); j++) {\\n            currvec.push_back(nums[j]);\\n            subsets(nums, j + 1, currvec, subs);\\n            currvec.pop_back();\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917360,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    private IList<IList<int>> res = new List<IList<int>>();\\n    \\n    public IList<IList<int>> Subsets(int[] nums) {\\n        if (nums == null || nums.Length == 0)\\n            return res;\\n        \\n        Backtrack(nums, 0, new List<int>());\\n        \\n        return res;\\n    }\\n    \\n    private void Backtrack(int[] nums, int i, List<int> cur)\\n    {\\n        res.Add(new List<int>(cur));\\n        \\n        if (nums.Length == i)\\n            return;\\n        \\n        for (int j = i; j < nums.Length; j++)\\n        {\\n            cur.Add(nums[j]);\\n            \\n            Backtrack(nums, j + 1, cur);\\n            \\n            cur.RemoveAt(cur.Count - 1);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private IList<IList<int>> res = new List<IList<int>>();\\n    \\n    public IList<IList<int>> Subsets(int[] nums) {\\n        if (nums == null || nums.Length == 0)\\n            return res;\\n        \\n        Backtrack(nums, 0, new List<int>());\\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 891089,
                "title": "c-no-recursion-two-for-loops",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int>t;\\n        ans.push_back(t);\\n        for(int n:nums)\\n        {\\n            int s=ans.size();\\n            for(int i=0;i<s;i++)\\n            {\\n                auto t1=ans[i];\\n                t1.push_back(n);\\n                ans.push_back(t1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int>t;\\n        ans.push_back(t);\\n        for(int n:nums)\\n        {\\n            int s=ans.size();\\n            for(int i=0;i<s;i++)\\n            {\\n                auto t1=ans[i];\\n                t1.push_back(n);\\n                ans.push_back(t1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760907,
                "title": "cpp-iterative-solution",
                "content": "**PLEASE UPVOTE IF YOU LIKE THE SOLUTION**\\n \\n         vector<vector<int>> subsets;\\n         subsets.push_back({});\\n         int size=nums.size();\\n         for(int i=0;i<size;i++){\\n             int subsetsize=subsets.size();\\n             for(int j=0;j<subsetsize;j++){\\n                 vector<int>set=subsets[j];\\n                 set.push_back(nums[i]);\\n                 subsets.push_back(set);\\n             }\\n         }\\n        return subsets;",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "**PLEASE UPVOTE IF YOU LIKE THE SOLUTION**\\n \\n         vector<vector<int>> subsets;\\n         subsets.push_back({});\\n         int size=nums.size();\\n         for(int i=0;i<size;i++){\\n             int subsetsize=subsets.size();\\n             for(int j=0;j<subsetsize;j++){\\n                 vector<int>set=subsets[j];\\n                 set.push_back(nums[i]);\\n                 subsets.push_back(set);\\n             }\\n         }\\n        return subsets;",
                "codeTag": "Unknown"
            },
            {
                "id": 730024,
                "title": "java-clean-code-easy-to-understand-0-ms-time-100-faster",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        List<List<Integer>> answer = new ArrayList<> ();\\n        answer.add (new ArrayList<> ());\\n        \\n        for (int num : nums) {\\n            int size = answer.size ();\\n            \\n            for (int i = 0; i < size; i++) {\\n                List<Integer> curr = new ArrayList<> (answer.get (i));\\n                curr.add (num);\\n                answer.add (curr);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        List<List<Integer>> answer = new ArrayList<> ();\\n        answer.add (new ArrayList<> ());\\n        \\n        for (int num : nums) {\\n            int size = answer.size ();\\n            \\n            for (int i = 0; i < size; i++) {\\n                List<Integer> curr = new ArrayList<> (answer.get (i));\\n                curr.add (num);\\n                answer.add (curr);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729973,
                "title": "c-2-solutions-with-explanation",
                "content": "The last solution was inspired from leetcode solution\\n### Solution 1\\nThis solution is straightforward. Let\\'s take the example given in the q.\\nnums = [1,2,3]. Let ``i = 0`` the index we are looking at.\\nlet our ans be stored in the array = ans\\nEmpty is set is always a subset. So ans = ``[[]]``\\n\\nApporach: Iterate through the ans array and add nums[i] to that array and add this array to ans.\\n1. ``i=0; nums[i] =1; ans = [[]]``\\nans = [[],[1]];\\n2. ``i=1; nums[i]=2; ans = [[],[1]]``\\nNow we iterate over ans\\n```\\n[]  + 2 = [2]\\n[1] + 2 = [1,2]\\n```\\nPush these two values to ``ans = [[],[1],[2],[1,2]]``\\n3. ``i=2; nums[i]=3; ans = [[],[1],[2],[1,2]]``\\n\\tThis time we iterate over these 4 and inner arrays and add value 3 we get 4 more arrays.\\n```\\n[]    + 3 = [3]\\n[1]   + 3 = [1,3]\\n[2]   + 3 = [2,3]\\n[1,2] + 3 = [1,2,3]\\nadd these 4 new arrays to ans\\nans = [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\\n```\\nCODE: \\n```\\nclass Solution {\\npublic:\\n\\t//helper method\\n    void fillPowerSet(vector<int>& nums,int i,int n,vector<vector<int>>& ans){\\n        if(i==n) return;  //n is end of nums array if we reach there return\\n        int v = nums[i];  // The current element we are looking at\\n        vector<vector<int>>t = ans;  // temp array to store the arrays for current element\\n        for(auto x: t){\\n            x.push_back(v);   // add the current element\\n            ans.push_back(x);  // insert it to ans array\\n        }\\n        fillPowerSet(nums,i+1,n,ans);  // go for the next element (i = i+1)\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int i = 0, n=nums.size();\\n        if(n==0) return {};  // if empty array\\n        vector<vector<int>>ans;\\n        ans.push_back({});\\n        fillPowerSet(nums,i,n,ans);\\n        return ans;\\n    }\\n};\\n```\\nTime and space complexity will be: O(2^n * n)\\n2^n iteration for each n;\\n\\n### Solution 2 (backtracking)\\n1. Let i denote the length of the current combination\\n\\tWhen i = 0, we are looking for combination []\\n\\tWhen i=1, we want [1], [2], [3] and so on.\\n2. Let start be the index from which we want to have the combination\\n\\tWhen start = 0 and i = 1 we will get [1]  (nums[start] = 1)\\n\\tstart =1 and i=1 we will get [2] (nums[start] = 2)\\n\\tstart =2 and i=1 we will get [3] ((nums[start] = 3))\\n3. It can be seen as take the sub-array from nums as nums(start,i) where start is the starting index and i is the number of element we need from the start index. (This is just an analogy to understand)\\n4. state is a temporary array that will contain the combinations of i lentgth which will be added to ans once the length of state array is same as i which is the length of the combination we need\\n5. After each time we call backtrack function (bt) we will remove the last element to get the next combination\\n\\nCODE: \\n```\\nclass Solution {\\n  void bt(vector<int>& nums,int start,int i,int n,vector<vector<int>>& ans,vector<int>& state) {\\n    // If this state is complete add to ans\\n\\tif (state.size() == i)  ans.push_back(state);\\n\\n    for (int j = start; j < n; j++) {\\n      state.push_back(nums[j]); // push our element to this combination\\n      bt(nums,j + 1, i,n,ans,state); // go to next element (j=j+1)\\n      state.pop_back();  //remove the last element we added \\n    }\\n  }\\n\\n  vector<vector<int>> subsets(vector<int>& nums) {\\n    int n = nums.size();\\n\\tif(!n) return {}; //empty array\\n\\tvector<vector<int>>ans;\\n    for (int i = 0; i <= n; i++) {\\n\\t\\tvector<int>state;\\n      bt(nums,0,i,n,ans,state);\\n    }\\n    return ans;\\n  }\\n}\\n```\\nTIme and space complexity same as the previous solution: O(2^n *  n)\\n\\n- Leetcode solution contains a third solution with same time & same complexity but is better due to bit masking.\\n\\nThank you!",
                "solutionTags": [],
                "code": "```\\n[]  + 2 = [2]\\n[1] + 2 = [1,2]\\n```\n```\\n[]    + 3 = [3]\\n[1]   + 3 = [1,3]\\n[2]   + 3 = [2,3]\\n[1,2] + 3 = [1,2,3]\\nadd these 4 new arrays to ans\\nans = [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\\n```\n```\\nclass Solution {\\npublic:\\n\\t//helper method\\n    void fillPowerSet(vector<int>& nums,int i,int n,vector<vector<int>>& ans){\\n        if(i==n) return;  //n is end of nums array if we reach there return\\n        int v = nums[i];  // The current element we are looking at\\n        vector<vector<int>>t = ans;  // temp array to store the arrays for current element\\n        for(auto x: t){\\n            x.push_back(v);   // add the current element\\n            ans.push_back(x);  // insert it to ans array\\n        }\\n        fillPowerSet(nums,i+1,n,ans);  // go for the next element (i = i+1)\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int i = 0, n=nums.size();\\n        if(n==0) return {};  // if empty array\\n        vector<vector<int>>ans;\\n        ans.push_back({});\\n        fillPowerSet(nums,i,n,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n  void bt(vector<int>& nums,int start,int i,int n,vector<vector<int>>& ans,vector<int>& state) {\\n    // If this state is complete add to ans\\n\\tif (state.size() == i)  ans.push_back(state);\\n\\n    for (int j = start; j < n; j++) {\\n      state.push_back(nums[j]); // push our element to this combination\\n      bt(nums,j + 1, i,n,ans,state); // go to next element (j=j+1)\\n      state.pop_back();  //remove the last element we added \\n    }\\n  }\\n\\n  vector<vector<int>> subsets(vector<int>& nums) {\\n    int n = nums.size();\\n\\tif(!n) return {}; //empty array\\n\\tvector<vector<int>>ans;\\n    for (int i = 0; i <= n; i++) {\\n\\t\\tvector<int>state;\\n      bt(nums,0,i,n,ans,state);\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729931,
                "title": "explanation-provided-c-approach-using-bit-manipulation-bit-masking",
                "content": "```\\nclass Solution {\\npublic:\\n    // Time Complexity: O(N*2^N), Space Complexity: O(N*2^N)\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        // Loop is run from 0 to 2^nums.size()-1 because that will be the total number of subsets.\\n        for(int i=0;i< 1<<nums.size(); i++){\\n            vector<int> subset;\\n            int temp = i, bitPos = 0;\\n            // Checking each bit of a number from the \"for\" loop.\\n            while(temp){\\n                if(temp&1)\\n                    subset.push_back(nums[bitPos]);\\n                bitPos++;\\n                temp = temp>>1;\\n            }\\n            ans.push_back(subset);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nFeel free to ask any doubts in the **comment** section.\\nIf you like this solution, do **UPVOTE**.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity: O(N*2^N), Space Complexity: O(N*2^N)\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        // Loop is run from 0 to 2^nums.size()-1 because that will be the total number of subsets.\\n        for(int i=0;i< 1<<nums.size(); i++){\\n            vector<int> subset;\\n            int temp = i, bitPos = 0;\\n            // Checking each bit of a number from the \"for\" loop.\\n            while(temp){\\n                if(temp&1)\\n                    subset.push_back(nums[bitPos]);\\n                bitPos++;\\n                temp = temp>>1;\\n            }\\n            ans.push_back(subset);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519823,
                "title": "simple-intuitive-python-solution",
                "content": "![image](https://assets.leetcode.com/users/tohbaino/image_1582599357.png)\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n        result = [[]]\\n        \\n        for num in nums:\\n            curRes = [val for val in result]\\n            for cur in curRes:\\n                result += [cur+[num]]\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n        result = [[]]\\n        \\n        for num in nums:\\n            curRes = [val for val in result]\\n            for cur in curRes:\\n                result += [cur+[num]]\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347517,
                "title": "swift-solution-backtracking-explanation-with-simple-example",
                "content": "```\\nclass Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        guard nums.count > 0 else { return [] }\\n        \\n        var result = [[Int]]()\\n        var candidates = [Int]()\\n        let startIndex = 0\\n        \\n        backTracking(&result, &candidates, startIndex, nums)\\n        return result\\n    }\\n    \\n    // assume it\\'s like a tree, we do a similar \"inorder traversal\"\\n    private func backTracking(_ result: inout [[Int]], _ candidates: inout [Int], _ startIndex: Int, _ nums: [Int]) {\\n        // store each case(\"node\")\\'s value\\n        result.append(candidates)\\n        \\n        // try to find if it has \"children\", if no \"child\", we done\\n        for i in startIndex..<nums.count {\\n            // update candidates to next level\\'s value(child\\'s value)\\n            candidates.append(nums[i])\\n            \\n            // startIndex + 1, go next level(go to its child)\\n            backTracking(&result, &candidates, i+1, nums)\\n            \\n            // update candidates to previous level\\'s value(parent\\'s value)\\n            candidates.removeLast()\\n        }\\n    }\\n}\\n\\n// eg: [1, 2, 3]; assume it is like a tree (inorder traversal)\\n//                     []\\n//              /       \\\\       \\\\\\n//            [1]       [2]    [3]\\n//           /   \\\\       |\\n//       [1, 2]  [1, 3] [2, 3]\\n//         /\\n//     [1, 2, 3]\\n\\n// output: [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\\n```\\n",
                "solutionTags": [
                    "Swift",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        guard nums.count > 0 else { return [] }\\n        \\n        var result = [[Int]]()\\n        var candidates = [Int]()\\n        let startIndex = 0\\n        \\n        backTracking(&result, &candidates, startIndex, nums)\\n        return result\\n    }\\n    \\n    // assume it\\'s like a tree, we do a similar \"inorder traversal\"\\n    private func backTracking(_ result: inout [[Int]], _ candidates: inout [Int], _ startIndex: Int, _ nums: [Int]) {\\n        // store each case(\"node\")\\'s value\\n        result.append(candidates)\\n        \\n        // try to find if it has \"children\", if no \"child\", we done\\n        for i in startIndex..<nums.count {\\n            // update candidates to next level\\'s value(child\\'s value)\\n            candidates.append(nums[i])\\n            \\n            // startIndex + 1, go next level(go to its child)\\n            backTracking(&result, &candidates, i+1, nums)\\n            \\n            // update candidates to previous level\\'s value(parent\\'s value)\\n            candidates.removeLast()\\n        }\\n    }\\n}\\n\\n// eg: [1, 2, 3]; assume it is like a tree (inorder traversal)\\n//                     []\\n//              /       \\\\       \\\\\\n//            [1]       [2]    [3]\\n//           /   \\\\       |\\n//       [1, 2]  [1, 3] [2, 3]\\n//         /\\n//     [1, 2, 3]\\n\\n// output: [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197900,
                "title": "python-solution-with-intuitive-explanation",
                "content": "Find all leaf nodes:\\n```text\\n                        []        \\n                   /          \\\\        \\n                  /            \\\\     \\n                 /              \\\\\\n              [1]                []\\n           /       \\\\           /    \\\\\\n          /         \\\\         /      \\\\        \\n       [1 2]       [1]       [2]     []\\n      /     \\\\     /   \\\\     /   \\\\    / \\\\\\n  [1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] []\\n```\\n\\n```python\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\t\\t# DFS\\n        self.res = []\\n        self.dfs(nums, 0, [])\\n        return self.res\\n    \\n    def dfs(self, nums, pos, tmp):\\n        self.res.append(tmp)\\n        for i in range(pos, len(nums)):\\n            self.dfs(nums, i+1, tmp+[nums[i]])\\n        \\n\\t\\t# BFS    \\n        # res = [[]]\\n        # for num in nums:\\n        #     size = len(res)\\n        #     for i in range(size):\\n        #         res.append(copy.deepcopy(res[i]))\\n        #         res[-1].append(num)\\n        # return res\\n```",
                "solutionTags": [],
                "code": "```text\\n                        []        \\n                   /          \\\\        \\n                  /            \\\\     \\n                 /              \\\\\\n              [1]                []\\n           /       \\\\           /    \\\\\\n          /         \\\\         /      \\\\        \\n       [1 2]       [1]       [2]     []\\n      /     \\\\     /   \\\\     /   \\\\    / \\\\\\n  [1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] []\\n```\n```python\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\t\\t# DFS\\n        self.res = []\\n        self.dfs(nums, 0, [])\\n        return self.res\\n    \\n    def dfs(self, nums, pos, tmp):\\n        self.res.append(tmp)\\n        for i in range(pos, len(nums)):\\n            self.dfs(nums, i+1, tmp+[nums[i]])\\n        \\n\\t\\t# BFS    \\n        # res = [[]]\\n        # for num in nums:\\n        #     size = len(res)\\n        #     for i in range(size):\\n        #         res.append(copy.deepcopy(res[i]))\\n        #         res[-1].append(num)\\n        # return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27430,
                "title": "5-line-python-code-with-easy-explanation",
                "content": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for i in range(len(nums)):\\n            k = nums[i]\\n            res += map(lambda x:x+[k],res)\\n        return res\\n```\\nlet nums = [1,2,3]\\nFirst initialize res as empty list [[]], then pick the first element from nums, that is 1. Then append 1 to all subsets in res, also append the original res to update current res, so res becomes[[],[1]], then pick 2 from nums, res becomes[[],[1],[2],[1,2]]. Finally pick 3 from nums, res becomes [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]. This can be done easily by lambda functions.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for i in range(len(nums)):\\n            k = nums[i]\\n            res += map(lambda x:x+[k],res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27481,
                "title": "java-straight-forward-iteration-method-easy-to-understand",
                "content": "Basic thought is that for every value in nums, generate new list based on result list with adding value to the result list, and add new list to the result list.\\n\\n    public class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> list = new ArrayList<List<Integer>>();\\n            Arrays.sort(nums);\\n\\n            for(int value : nums) { // for every value in nums, check the list, \\n                if(list.isEmpty()) {\\n                    list.add(new ArrayList(Arrays.asList(value)));\\n                } else {\\n                    int size = list.size();\\n                    for(int i = 0; i < size; i++) {\\n                        List<Integer> temp = new ArrayList<>(list.get(i)); // based on exist list\\n                        temp.add(value); // add value to each list\\n                        list.add(temp);\\n                    }\\n                    list.add(new ArrayList(Arrays.asList(value))); // add current single value\\n                }\\n            }\\n            \\n            list.add(new ArrayList<Integer>());\\n            return list;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> list = new ArrayList<List<Integer>>();\\n            Arrays.sort(nums);\\n\\n            for(int value : nums) { // for every value in nums, check the list, \\n                if(list.isEmpty()) {\\n                    list.add(new ArrayList(Arrays.asList(value)));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3741158,
                "title": "c-bit-mask-vs-backtracking-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code uses bit manipulation to generate all possible subsets of the input vector. It creates a vector called powerSet to store the subsets. The outer loop iterates from m = 0 to m = Mask - 1, representing all possible binary numbers of length n, where n is the size of the input vector. \\n\\nThe inner loop iterates through the elements of the input vector nums and checks if the i-th bit of m is set (i.e., if m & (1 << i) evaluates to true). If the bit is set, it adds the corresponding element nums[i] to the subset stored in powerSet[m]. Finally, it returns the generated power set powerSet.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$ O(2^N * N)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$ O(2^N * N)$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n=nums.size();\\n        int Mask=1<<n;\\n        vector<vector<int>> powerSet(Mask);\\n        for (int m=0; m<Mask; m++){\\n            for(int i=0; i<n; i++){\\n                if (m& 1<<i)\\n                    powerSet[m].push_back(nums[i]);\\n            }\\n        }\\n        return powerSet;\\n    }\\n};\\n```\\n# Code with Comments\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();                        // Get the size of the input vector\\n        int Mask = 1 << n;                           // Calculate the maximum number of subsets using bit manipulation\\n        vector<vector<int>> powerSet(Mask);          // Create a vector to store all the subsets\\n        \\n        for (int m = 0; m < Mask; m++) {              // Iterate through all the possible combinations of subsets\\n            for (int i = 0; i < n; i++) {             // Iterate through the elements of the input vector\\n                if (m & (1 << i))                     // Check if the i-th bit of m is set\\n                    powerSet[m].push_back(nums[i]);  // If the bit is set, add the corresponding element to the subset\\n            }\\n        }\\n        \\n        return powerSet;                             // Return the generated power set\\n    }\\n};\\n\\n```\\n# Code using Backtracking beats 100%\\n```\\nclass Solution {\\npublic:\\nint n;\\n    vector<vector<int>> powerSet;\\n    void dfs(int idx, vector<int> subset, vector<int>& nums ){\\n       \\n        powerSet.push_back(subset);\\n        \\n        for(int i=idx; i<n; i++){\\n            subset.push_back(nums[i]);\\n            dfs(i+1, subset, nums);\\n            subset.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        n=nums.size();\\n        dfs(0,  {}, nums);\\n        \\n        return powerSet;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n=nums.size();\\n        int Mask=1<<n;\\n        vector<vector<int>> powerSet(Mask);\\n        for (int m=0; m<Mask; m++){\\n            for(int i=0; i<n; i++){\\n                if (m& 1<<i)\\n                    powerSet[m].push_back(nums[i]);\\n            }\\n        }\\n        return powerSet;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();                        // Get the size of the input vector\\n        int Mask = 1 << n;                           // Calculate the maximum number of subsets using bit manipulation\\n        vector<vector<int>> powerSet(Mask);          // Create a vector to store all the subsets\\n        \\n        for (int m = 0; m < Mask; m++) {              // Iterate through all the possible combinations of subsets\\n            for (int i = 0; i < n; i++) {             // Iterate through the elements of the input vector\\n                if (m & (1 << i))                     // Check if the i-th bit of m is set\\n                    powerSet[m].push_back(nums[i]);  // If the bit is set, add the corresponding element to the subset\\n            }\\n        }\\n        \\n        return powerSet;                             // Return the generated power set\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\nint n;\\n    vector<vector<int>> powerSet;\\n    void dfs(int idx, vector<int> subset, vector<int>& nums ){\\n       \\n        powerSet.push_back(subset);\\n        \\n        for(int i=idx; i<n; i++){\\n            subset.push_back(nums[i]);\\n            dfs(i+1, subset, nums);\\n            subset.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        n=nums.size();\\n        dfs(0,  {}, nums);\\n        \\n        return powerSet;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596405,
                "title": "best-solution",
                "content": "# Approach\\nUsing Recursion\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n*k)$$ --> k is average length of every subset\\n\\n- Space complexity:\\n$$O(2^n*k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    void subsetHelper(int idx, vector<int>& nums, int n, vector<int> &temp, vector<vector<int>>& ans) {\\n        if (idx == n) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        temp.push_back(nums[idx]);\\n        subsetHelper(idx+1, nums, n, temp, ans);\\n        temp.pop_back();\\n        subsetHelper(idx+1, nums, n, temp, ans);\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        subsetHelper(0, nums, n, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    void subsetHelper(int idx, vector<int>& nums, int n, vector<int> &temp, vector<vector<int>>& ans) {\\n        if (idx == n) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        temp.push_back(nums[idx]);\\n        subsetHelper(idx+1, nums, n, temp, ans);\\n        temp.pop_back();\\n        subsetHelper(idx+1, nums, n, temp, ans);\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        subsetHelper(0, nums, n, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432033,
                "title": "easy-python-solution-using-recursion",
                "content": "# Code\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        l=[]\\n        def subs(idx,tmp,lst,n,l):\\n            if idx>n:\\n                l.append(lst[:])\\n                return \\n            lst.append(tmp[idx])\\n            subs(idx+1,tmp,lst,n,l)\\n            lst.pop()\\n            subs(idx+1,tmp,lst,n,l)\\n            return \\n        lst=[]\\n        l=[]\\n        n=len(nums)-1\\n        subs(0,nums,lst,n,l)\\n        return sorted(l)\\n\\n       \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        l=[]\\n        def subs(idx,tmp,lst,n,l):\\n            if idx>n:\\n                l.append(lst[:])\\n                return \\n            lst.append(tmp[idx])\\n            subs(idx+1,tmp,lst,n,l)\\n            lst.pop()\\n            subs(idx+1,tmp,lst,n,l)\\n            return \\n        lst=[]\\n        l=[]\\n        n=len(nums)-1\\n        subs(0,nums,lst,n,l)\\n        return sorted(l)\\n\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939690,
                "title": "c-easy-to-understand-best-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void arrr(vector<vector<int>> &ans, int k) {\\n        vector<vector<int>> temp = ans;\\n        for (int i = 0; i < temp.size(); ++i) {\\n            temp[i].push_back(k);\\n            ans.push_back(temp[i]);\\n        }\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& n) {\\n        vector<vector<int>> ans;\\n        ans.push_back(vector<int>());\\n        for (int i = 0; i < n.size(); ++i) {\\n            arrr(ans, n[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void arrr(vector<vector<int>> &ans, int k) {\\n        vector<vector<int>> temp = ans;\\n        for (int i = 0; i < temp.size(); ++i) {\\n            temp[i].push_back(k);\\n            ans.push_back(temp[i]);\\n        }\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& n) {\\n        vector<vector<int>> ans;\\n        ans.push_back(vector<int>());\\n        for (int i = 0; i < n.size(); ++i) {\\n            arrr(ans, n[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630421,
                "title": "java-iterative-approach",
                "content": "```\\n        List<List<Integer>> ans=new ArrayList<>();\\n        ans.add(new ArrayList<Integer>());//[]\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int n=ans.size();\\n            for(int j=0;j<n;j++){\\n                List<Integer> temp=new ArrayList(ans.get(j));\\n                temp.add(nums[i]);\\n                ans.add(temp);\\n            }\\n        }\\n       return ans; \\n",
                "solutionTags": [],
                "code": "```\\n        List<List<Integer>> ans=new ArrayList<>();\\n        ans.add(new ArrayList<Integer>());//[]\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int n=ans.size();\\n            for(int j=0;j<n;j++){\\n                List<Integer> temp=new ArrayList(ans.get(j));\\n                temp.add(nums[i]);\\n                ans.add(temp);\\n            }\\n        }\\n       return ans; \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2331563,
                "title": "python-simple-backtracking-solution-clean-and-easy",
                "content": "**UPVOTE PLS :-)**\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans=[]\\n        def backtrackMe(i,temp):\\n            if i==len(nums):\\n                ans.append(temp.copy())\\n                return\\n            else:\\n                backtrackMe(i+1,temp+[nums[i]])\\n                backtrackMe(i+1,temp)\\n        backtrackMe(0,[])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans=[]\\n        def backtrackMe(i,temp):\\n            if i==len(nums):\\n                ans.append(temp.copy())\\n                return\\n            else:\\n                backtrackMe(i+1,temp+[nums[i]])\\n                backtrackMe(i+1,temp)\\n        backtrackMe(0,[])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301048,
                "title": "simple-js-solution-w-comments-bractracking",
                "content": "```\\n/**\\n * *Time: O(N x 2^N)\\n * *Space: O(N)\\n */\\n// Runtime: 112 ms, faster than 21.68% of JavaScript online submissions for Subsets.\\n// Memory Usage: 44.2 MB, less than 35.31% of JavaScript online submissions for Subsets.\\nconst subsets = nums => {\\n\\tconst output = [];\\n\\n\\tconst backtrack = (idx, subset) => {\\n\\t\\toutput.push([...subset]);\\n\\n    // for each of the current subset\\n    // recursively generate all possible subsets by increasing the position by one\\n\\t\\tfor (let i = idx; i < nums.length; i++) {\\n\\t\\t\\tsubset.push(nums[i]);\\n\\t\\t\\tbacktrack(i + 1, subset); // create next subset\\n\\t\\t\\tsubset.pop(); // backtrack\\n\\t\\t}\\n\\t};\\n\\n\\tbacktrack(0, []);\\n\\treturn output;\\n};\\n\\n// subset\\n// []\\n// [ 1 ]\\n// [ 1, 2 ]\\n// [ 1, 2, 3 ]\\n// [ 1, 3 ]\\n// [ 2 ]\\n// [ 2, 3 ]\\n// [ 3 ]\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * *Time: O(N x 2^N)\\n * *Space: O(N)\\n */\\n// Runtime: 112 ms, faster than 21.68% of JavaScript online submissions for Subsets.\\n// Memory Usage: 44.2 MB, less than 35.31% of JavaScript online submissions for Subsets.\\nconst subsets = nums => {\\n\\tconst output = [];\\n\\n\\tconst backtrack = (idx, subset) => {\\n\\t\\toutput.push([...subset]);\\n\\n    // for each of the current subset\\n    // recursively generate all possible subsets by increasing the position by one\\n\\t\\tfor (let i = idx; i < nums.length; i++) {\\n\\t\\t\\tsubset.push(nums[i]);\\n\\t\\t\\tbacktrack(i + 1, subset); // create next subset\\n\\t\\t\\tsubset.pop(); // backtrack\\n\\t\\t}\\n\\t};\\n\\n\\tbacktrack(0, []);\\n\\treturn output;\\n};\\n\\n// subset\\n// []\\n// [ 1 ]\\n// [ 1, 2 ]\\n// [ 1, 2, 3 ]\\n// [ 1, 3 ]\\n// [ 2 ]\\n// [ 2, 3 ]\\n// [ 3 ]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995496,
                "title": "easy-to-understand-python-recursion-solution",
                "content": "\\n\\n![image](https://assets.leetcode.com/users/images/88e79e57-7364-4dfa-a858-88c750d129ac_1651349284.1383734.png)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        def recursion(idx, currentSet):\\n            if idx == len(nums):\\n                results.append(currentSet)\\n                return\\n            \\n            #including the item at idx\\n            recursion(idx + 1, currentSet + [nums[idx]])\\n            #excluding the item at idx\\n            recursion(idx + 1, currentSet)\\n        \\n        results = []\\n        recursion(0,[])\\n        return results\\n```\\n\\nplease UPVOTE if you like \\uD83D\\uDE0A",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        def recursion(idx, currentSet):\\n            if idx == len(nums):\\n                results.append(currentSet)\\n                return\\n            \\n            #including the item at idx\\n            recursion(idx + 1, currentSet + [nums[idx]])\\n            #excluding the item at idx\\n            recursion(idx + 1, currentSet)\\n        \\n        results = []\\n        recursion(0,[])\\n        return results\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1858250,
                "title": "python-solutions-dp-bit-masking-recursion",
                "content": "# Method 1: using Dp.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for i in nums: res += [j+[i] for j in res]\\n        return res\\n# Method 2: using bit masking.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res, n = [], len(nums)\\n        for i in range(1<<n):\\n            ans = []\\n            for j in range(n):\\n                if i & 1<<j: ans.append(nums[j])\\n            res.append(ans)\\n        return res\\n\\n# Method 3: using recursion.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res, n = [], len(nums)\\n        def sub(i, l):\\n            if i == n:\\n                res.append(l)\\n                return\\n            sub(i + 1, l + [nums[i]])\\n            sub(i + 1, l)\\n        sub(0,[])\\n        return res\\n# please upvote if you like it!!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "# Method 1: using Dp.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for i in nums: res += [j+[i] for j in res]\\n        return res\\n# Method 2: using bit masking.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res, n = [], len(nums)\\n        for i in range(1<<n):\\n            ans = []\\n            for j in range(n):\\n                if i & 1<<j: ans.append(nums[j])\\n            res.append(ans)\\n        return res\\n\\n# Method 3: using recursion.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res, n = [], len(nums)\\n        def sub(i, l):\\n            if i == n:\\n                res.append(l)\\n                return\\n            sub(i + 1, l + [nums[i]])\\n            sub(i + 1, l)\\n        sub(0,[])\\n        return res\\n# please upvote if you like it!!",
                "codeTag": "Python3"
            },
            {
                "id": 1767767,
                "title": "c-simplest-short-solution-no-recursion-0-ms-faster-than-100",
                "content": "We start with a group that contains only the empty group.\\nThem, for each number in `nums`, we add it to all the previous groups.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767761,
                "title": "all-subsets-short-simple-8-lines-of-code-in-c-using-power-set",
                "content": "**Intuition :** Total number of subsets will be 2 to the power of `n` where n is the length of the given `nums` array. So if we find all the set bits for each positions for all the number between 0 to 2 to the power of `n`, we can replace the `nums[i]` (where i is the position of the number\\'s bit representation, if i th position is set bit or not) for each set bit positions consecutively. If we find that the i th position is set bit then we\\'ll put nums[i] in the postion and we\\'ll push back that into the resultant vector `res` and res vector into `ans`.\\n\\n**Note :** `1<<nums.size()` == `2 to the power of n` and `i & (1<<j)` with this we are checking if the jth position is set bit or not.\\n\\nIf you like this solution please upvote this THANKS **: )** \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0; i<(1<<nums.size()); i++){\\n            vector<int> res;\\n            \\n            for(int j=0; j<nums.size(); j++){\\n                if(i & (1<<j))\\n                    res.push_back(nums[j]);\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf you get any doubt  please comment down below...I\\'ll give my best to clear your doubtsb",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0; i<(1<<nums.size()); i++){\\n            vector<int> res;\\n            \\n            for(int j=0; j<nums.size(); j++){\\n                if(i & (1<<j))\\n                    res.push_back(nums[j]);\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603493,
                "title": "rust-fast-100",
                "content": "```\\nimpl Solution {\\n    pub fn subsets(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        if nums.len() == 0{\\n            return vec![vec![]];\\n        }\\n        let last = nums.pop().unwrap();\\n        let remain_subsets = Self::subsets(nums);\\n        let mut res = remain_subsets.clone();\\n        for mut v in remain_subsets{\\n            v.push(last);\\n            res.push(v);\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn subsets(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        if nums.len() == 0{\\n            return vec![vec![]];\\n        }\\n        let last = nums.pop().unwrap();\\n        let remain_subsets = Self::subsets(nums);\\n        let mut res = remain_subsets.clone();\\n        for mut v in remain_subsets{\\n            v.push(last);\\n            res.push(v);\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 899942,
                "title": "simple-recursive-scala",
                "content": "```scala\\nobject Solution {\\n  def subsets(nums: Array[Int]): List[List[Int]] = {\\n    @annotation.tailrec\\n    def go(as: List[Int], acc: List[List[Int]]): List[List[Int]] = {\\n      as match {\\n        case Nil => acc\\n        case h::t => go(t, acc ::: acc.map(_.appended(h)))\\n      }\\n    }\\n\\n    go(nums.toList, List(List()))\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```scala\\nobject Solution {\\n  def subsets(nums: Array[Int]): List[List[Int]] = {\\n    @annotation.tailrec\\n    def go(as: List[Int], acc: List[List[Int]]): List[List[Int]] = {\\n      as match {\\n        case Nil => acc\\n        case h::t => go(t, acc ::: acc.map(_.appended(h)))\\n      }\\n    }\\n\\n    go(nums.toList, List(List()))\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 852038,
                "title": "simple-cpp-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>nums,vector<int>op,vector<vector<int>>& v)\\n    {  if(nums.size()==0)\\n        {   v.push_back(op);\\n            return;\\n        }\\n        vector<int>op1;\\n        vector<int>op2;\\n        for(int i=0;i<op.size();i++)\\n        {   op1.push_back(op[i]);\\n            op2.push_back(op[i]);\\n        }\\n        op2.push_back(nums[0]);\\n        vector<int>::iterator it;\\n        it=nums.begin();\\n        nums.erase(it);\\n        solve(nums,op1,v);\\n        solve(nums,op2,v);\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<int>op;\\n        solve(nums,op,v);\\n        return v;\\n    }\\n};\\n```\\nFor understanding the concept behind this solution check this-\\nhttps://www.youtube.com/watch?v=Yg5a2FxU4Fo&list=PL_z_8CaSLPWeT1ffjiImo0sYTcnLzo-wY&index=12",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>nums,vector<int>op,vector<vector<int>>& v)\\n    {  if(nums.size()==0)\\n        {   v.push_back(op);\\n            return;\\n        }\\n        vector<int>op1;\\n        vector<int>op2;\\n        for(int i=0;i<op.size();i++)\\n        {   op1.push_back(op[i]);\\n            op2.push_back(op[i]);\\n        }\\n        op2.push_back(nums[0]);\\n        vector<int>::iterator it;\\n        it=nums.begin();\\n        nums.erase(it);\\n        solve(nums,op1,v);\\n        solve(nums,op2,v);\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<int>op;\\n        solve(nums,op,v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730432,
                "title": "swift-8ms-solution",
                "content": "```\\nfinal class Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var arrayVales = [[Int]]()\\n        arrayVales.append([])\\n        for num in nums {\\n            for val in arrayVales {\\n                var valUpdate = val\\n                valUpdate.append(num)\\n                arrayVales.append(valUpdate)\\n            }\\n        }\\n        return arrayVales\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfinal class Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var arrayVales = [[Int]]()\\n        arrayVales.append([])\\n        for num in nums {\\n            for val in arrayVales {\\n                var valUpdate = val\\n                valUpdate.append(num)\\n                arrayVales.append(valUpdate)\\n            }\\n        }\\n        return arrayVales\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729871,
                "title": "java-bitmask-solution",
                "content": "Explanation: In order to generate every subset, we decide wether or not to put an element of the array. Using combinatorics, the number of different subsets is `2^(num_of_elements)`, because for every element, we put it or not.\\n\\nInterestingly, if we take the binary representation of all the numbers from zero up to `2^(num_of_elements) - 1`, we can use the bits of those numbers to decide wether or not to put the corresponding number from the array. Notice that, starting from zero and going up to `2^(num_of_elements) - 1`, there are `2^(num_of_elements)` different values.\\n\\nIt works like this. Suppose your array has 5 elements. We then start from `0` and go up to `(2^5) - 1`. Using the describe approach, we then start with a bitmask containing `00000`. If a bit is zero it means `do not put the element at the correspoding bit position on the subset` and 1 means `put it on the subset`. For the first number, we have the empty subset. We then add one to our bitmask, resulting in `00001`, meaning we now have a subset with the first element only. The next one would be `00010`, and the next `00011`, and so on. This way we generate all the possible subsets. The last bitmask has all the ones set (`11111`).\\n\\n**Remarks**\\n- Why `2^(num_of_elements) - 1` ? When doing, for example, `2^5` you will have `100000`, if you do `-1` on that you will have `11111`.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int total = (int)Math.pow(2,nums.length)-1;\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n\\t\\t//for every bitmask\\n        for(int i = 0; i <= total; i++) {\\n\\t\\t\\n            List<Integer> set = new ArrayList<Integer>();\\n\\t\\t\\t//for every element in the array\\n            for(int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\t//if the corresponding bit is set on the bitmask\\n                if ( ((i>>j)&1) == 1) set.add(nums[j]);\\n            }\\n\\t\\t\\t\\n            ans.add(set);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int total = (int)Math.pow(2,nums.length)-1;\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n\\t\\t//for every bitmask\\n        for(int i = 0; i <= total; i++) {\\n\\t\\t\\n            List<Integer> set = new ArrayList<Integer>();\\n\\t\\t\\t//for every element in the array\\n            for(int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\t//if the corresponding bit is set on the bitmask\\n                if ( ((i>>j)&1) == 1) set.add(nums[j]);\\n            }\\n\\t\\t\\t\\n            ans.add(set);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707102,
                "title": "python-short-10-lines-with-complete-explanation",
                "content": "n is the length of the array.A subset is represented by a binarynumber of n bits.Each bit represents whether the number of that index exists in the subset or not.And the numbers that has this binary representation are [0,2^n-1] Now,we need to obtain the bits that are one\\'s in every number.\\n```Eg: input array = [4,7,6]\\n\\tExplanation:\\n\\tsubsets =[ ] [4] [7] [6] [4,7] [4,6]  [7,6] [4,7,6]\\n\\tThere are 3 numbers in the array i.e n = 3\\n\\tTherefore, no of subsets = 2^n = 2^3 = 8\\n\\tEach subset can be represented by a number in [0,2^n -1] i.e [0,1,2,3,4,5,6,7]\\n\\tbinary rep of 7 = \\'111\\'  => [4, 7, 6]\\n\\tbinary rep of 6 = \\'110\\'  => [4, 7   ]\\n\\tbinary rep of 5 = \\'101\\'  => [4,   ,6]\\n\\tbinary rep of 4 = \\'100\\'  => [4,      ]\\n\\t...... binary rep of 0 =\\'000\\' =>[ ]  i.e null set. \\n\\tSo,The idea is to represent [0,2^n -1] numbers in n-bit binary.\\n\\tFor each such number,find the subset by parsing the set-bits of binary number.\\n``` \\nNow, into the code. `Time:O(2^n),SpaceO(2^n)`\\n    \\n\\t\\t```python\\t\\n\\t\\tclass Solution:\\n\\t\\t\\tdef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\trightEnd = 2**n\\n\\t\\t\\tres = []\\n\\t\\t\\tfor number in range(rightEnd):\\n\\t\\t\\t\\tans = []\\n\\t\\t\\t\\tfor bit in range(n):\\n\\t\\t\\t\\t\\tif 1<<bit & number:\\n\\t\\t\\t\\t\\t\\tans.append(nums[bit])\\n\\t\\t\\t\\tres.append(ans)\\n\\t\\t\\treturn res\\n\\t\\t\\t```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```Eg: input array = [4,7,6]\\n\\tExplanation:\\n\\tsubsets =[ ] [4] [7] [6] [4,7] [4,6]  [7,6] [4,7,6]\\n\\tThere are 3 numbers in the array i.e n = 3\\n\\tTherefore, no of subsets = 2^n = 2^3 = 8\\n\\tEach subset can be represented by a number in [0,2^n -1] i.e [0,1,2,3,4,5,6,7]\\n\\tbinary rep of 7 = \\'111\\'  => [4, 7, 6]\\n\\tbinary rep of 6 = \\'110\\'  => [4, 7   ]\\n\\tbinary rep of 5 = \\'101\\'  => [4,   ,6]\\n\\tbinary rep of 4 = \\'100\\'  => [4,      ]\\n\\t...... binary rep of 0 =\\'000\\' =>[ ]  i.e null set. \\n\\tSo,The idea is to represent [0,2^n -1] numbers in n-bit binary.\\n\\tFor each such number,find the subset by parsing the set-bits of binary number.\\n```\n```python\\t\\n\\t\\tclass Solution:\\n\\t\\t\\tdef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\trightEnd = 2**n\\n\\t\\t\\tres = []\\n\\t\\t\\tfor number in range(rightEnd):\\n\\t\\t\\t\\tans = []\\n\\t\\t\\t\\tfor bit in range(n):\\n\\t\\t\\t\\t\\tif 1<<bit & number:\\n\\t\\t\\t\\t\\t\\tans.append(nums[bit])\\n\\t\\t\\t\\tres.append(ans)\\n\\t\\t\\treturn res\\n\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 364179,
                "title": "python-iterative-backtracking-with-detail-explanation-and-deep-copy-problem",
                "content": "**Iterative Approach**\\nThe ituition is that when we have a subset of itmes a[0] to a[k-1] (we name this subset S(k-1)) what we could do to obtain the subset of a[0] to a[k] (S(k)).\\nSince for new item a[k], the subset of a[0] to a[k] could eigher contain a[k] or not. And when it not caintain a[k], this part of subset becomes S(k-1). when it caintains a[k], we could just add a[k] to all the subset of a[0] to a[k-1]. So we could write down the following fomula:\\nS(k) = S(k-1) + S(k-1)Ua[k]\\nthen we could write down the following codes:\\n```\\nclass Solution:\\n    def subsets(self, nums):\\n        res = [[]]\\n        for num in nums:\\n            res = res + [s+[num] for s in res]\\n        return res\\n```\\ntime analysis:\\n* we iterate over all the element in nums. For each element a[i], we iterate all the subset of a[0] to a[i-1]. So every step the time complexity if O(|S(i-1)|)\\n* according to the S(k) = S(k-1) + S(k-1)Ua[k], we could know that the |S(k)| (which is the number of subset of a[0] to a[k]) have the relationship: |S(k)| = 2|S(k-1)| =...=2^k|S(0)|=O(2^k)\\n* so the total time complexity would be O(1)+O(2)+...+O(2^n)=O(2^n)\\nspace complexity:\\n* since we only use res to store results, so it\\'s O(2^n)\\n\\n**Backtracking**\\nSince it\\'s hard to decide what is the subset of n items, we could try to the  break big one to some smaller problems. For k items, we could decide whether or not to include the first one in k items. Then the problem becomes for k-1 items what is their subset. After obtaining k-1\\'s subsets, we know that the subsets of k-1 items are also subsets of k items for the reason that k items include k-1 items. And we could also add the first one in k items to all the subsets of k-1\\'s subsets. So the algorithm becomes:\\n* when the nums equals zero, it means there is zero elements to work. We have chosen all the elements in the subsets, we could append them in the result and return.\\n* choose not to include nums[0] in the subsets and explore all the subsets of nums[1:]\\n* choose to include nums[0] in the subsets and explore all the subsets of nums[1:]. So the choose becomes choose+nums[0]\\n*  unchoose nums[0] so when backtrack to the uppper level, so, we donot let chosen array grow without control\\n```\\nimport copy\\nclass Solution:\\n    def subsets(self, nums):\\n        N = len(nums)\\n        res = []\\n        def helper(nums, chosen):\\n            if nums == []:\\n                res.append(copy.deepcopy(chosen))\\n                return\\n\\t\\t\\t#choose & explore\\n            helper(nums[1:], chosen)\\n\\t\\t\\t#choose & explore\\n            chosen.append(nums[0])\\n            helper(nums[1:], chosen)\\n\\t\\t\\t#unchoose\\n            chosen.pop()\\n            return\\n        helper(nums, [])\\n        return res\\n```\\n**Deep copy problem!**\\nI try to use `res.append(chosen)` in the first time, but find ou the output is very wired!! If you try the code without use of deepcopy then you would find that every time you change chosen, the res also changes. This is because how python pass parameters and the effect of shallow copy. After appending chosen, res[-1] and chosen reference points to the same memory location. As a result even since you append chosen to res, every time you modify chosen, you also change the element in res.\\nBTW, I am also wondering if it is okay to work on the results in the base case. We could also modify the method so it returns the subsets. I am not sure which one is better.\\n\\nIf there is anything confusing or misleading, please comment below. I would try my best to clarify.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums):\\n        res = [[]]\\n        for num in nums:\\n            res = res + [s+[num] for s in res]\\n        return res\\n```\n```\\nimport copy\\nclass Solution:\\n    def subsets(self, nums):\\n        N = len(nums)\\n        res = []\\n        def helper(nums, chosen):\\n            if nums == []:\\n                res.append(copy.deepcopy(chosen))\\n                return\\n\\t\\t\\t#choose & explore\\n            helper(nums[1:], chosen)\\n\\t\\t\\t#choose & explore\\n            chosen.append(nums[0])\\n            helper(nums[1:], chosen)\\n\\t\\t\\t#unchoose\\n            chosen.pop()\\n            return\\n        helper(nums, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351704,
                "title": "javascript-recursive",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsets = function(nums) {\\n    let res = [];\\n    const helper = (nums, i, arr) => {\\n        if(i === nums.length) {\\n            res.push(arr);\\n            return;\\n        }\\n        helper(nums, i+1, arr);\\n        helper(nums, i+1, arr.concat(nums[i]));\\n    };\\n    helper(nums, 0, []);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsets = function(nums) {\\n    let res = [];\\n    const helper = (nums, i, arr) => {\\n        if(i === nums.length) {\\n            res.push(arr);\\n            return;\\n        }\\n        helper(nums, i+1, arr);\\n        helper(nums, i+1, arr.concat(nums[i]));\\n    };\\n    helper(nums, 0, []);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 310034,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 277064,
                "title": "bfs-to-generate-subset",
                "content": "Recursion is my favorite solution. However, the interviewer might ask non-recursion solution. In this case, BFS could be helpful. \\n\\nImagine sub-set generation as an implicit binary tree, where the node is a set A, and its 2 children are A + [x] and A + []. \\n\\nDo a level order BFS, and stop at `level == len(nums)`\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        from collections import deque\\n        \\n        qu = deque([[]])\\n        \\n        i = 0\\n        while qu and i < len(nums):\\n            N = len(qu)\\n            \\n            for _ in range(N):\\n                lst = qu.popleft()\\n                \\n                qu.append(lst[:])\\n                qu.append(lst + [nums[i]])\\n            \\n            \\n            i += 1\\n            \\n        return list(qu)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        from collections import deque\\n        \\n        qu = deque([[]])\\n        \\n        i = 0\\n        while qu and i < len(nums):\\n            N = len(qu)\\n            \\n            for _ in range(N):\\n                lst = qu.popleft()\\n                \\n                qu.append(lst[:])\\n                qu.append(lst + [nums[i]])\\n            \\n            \\n            i += 1\\n            \\n        return list(qu)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231695,
                "title": "why-everybody-overthink-it-just-simple-recursion-beats-100-c",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) {\\n        return helper(nums, new List<IList<int>>(), 0);\\n    }\\n    \\n    public IList<IList<int>> helper(int[] nums, IList<IList<int>> ans, int index)\\n    {\\n        if(index == 0) ans.Add(new List<int>());\\n        if(index == nums.Length) return ans;\\n        int precount = ans.Count;\\n        for(int i = 0; i < precount; i++)\\n        {\\n            IList<int> cur = new List<int>(ans[i]);\\n            cur.Add(nums[index]);\\n            ans.Add(cur);\\n        }\\n        return helper(nums, ans, index + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) {\\n        return helper(nums, new List<IList<int>>(), 0);\\n    }\\n    \\n    public IList<IList<int>> helper(int[] nums, IList<IList<int>> ans, int index)\\n    {\\n        if(index == 0) ans.Add(new List<int>());\\n        if(index == nums.Length) return ans;\\n        int precount = ans.Count;\\n        for(int i = 0; i < precount; i++)\\n        {\\n            IList<int> cur = new List<int>(ans[i]);\\n            cur.Add(nums[index]);\\n            ans.Add(cur);\\n        }\\n        return helper(nums, ans, index + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197551,
                "title": "simple-javascript-recursive-solution-inspired-by-sicp-exercise-2-32",
                "content": "```\\nfunction subsets(s) {\\n    if (s.length === 0) {\\n        return [[]]\\n    } else {\\n        let rest = subsets(s.slice(1))  \\n        let newSets = rest.map(         \\n            (set) => [s[0], ...set]\\n        )\\n        return [...rest, ...newSets]    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunction subsets(s) {\\n    if (s.length === 0) {\\n        return [[]]\\n    } else {\\n        let rest = subsets(s.slice(1))  \\n        let newSets = rest.map(         \\n            (set) => [s[0], ...set]\\n        )\\n        return [...rest, ...newSets]    \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172300,
                "title": "java-a-dp-solution",
                "content": "```\npublic List<List<Integer>> subsets( int[] nums ) {\n        List<List<Integer>> res = new ArrayList<>();\n        List<Integer> emptySubset = new ArrayList<>(); // 每个集合都有的 空子集\n        res.add(emptySubset);\n\n        for (int i = 0; i < nums.length; i++) {\n            // 遍历元素，将元素依次加进res的每个子集末尾，形成一个新子集；\n            int length = res.size();\n            for (int j = 0; j < length; j++) {\n                List<Integer> newSubset = new ArrayList<>(res.get(j));\n                newSubset.add(nums[i]);\n                res.add(newSubset);\n            }\n        }\n        return res;\n    }\n```",
                "solutionTags": [],
                "code": "```\npublic List<List<Integer>> subsets( int[] nums ) {\n        List<List<Integer>> res = new ArrayList<>();\n        List<Integer> emptySubset = new ArrayList<>(); // 每个集合都有的 空子集\n        res.add(emptySubset);\n\n        for (int i = 0; i < nums.length; i++) {\n            // 遍历元素，将元素依次加进res的每个子集末尾，形成一个新子集；\n            int length = res.size();\n            for (int j = 0; j < length; j++) {\n                List<Integer> newSubset = new ArrayList<>(res.get(j));\n                newSubset.add(nums[i]);\n                res.add(newSubset);\n            }\n        }\n        return res;\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 142650,
                "title": "a-c-0ms-solution-with-annotation",
                "content": "```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *columnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** subsets(int* nums, int numsSize, int** columnSizes, int* returnSize) {\\n        *returnSize = 1 << numsSize;                                    // Power set of S always has 2^|S| elements\\n\\n        /* Allocating memory dynamically */\\n        int** rv = malloc(sizeof(*rv) * *returnSize);                   // Returned array of arrays\\n        *columnSizes = malloc(sizeof(**columnSizes) * *returnSize);     // columnSizes output\\n        \\n        for (int i = 0; i < *returnSize; ++i) {\\n                \\n                /* popcount is an x86 instruction which returns the number of 1 bits in a register */\\n                /* GCC compiler supports a similar instruction, regardless of platform */\\n                (*columnSizes)[i] = __builtin_popcount(i);              // Let client know length of array\\n\\n                rv[i] = malloc(sizeof(*(rv[i])) * (*columnSizes)[i]);   // Allocate array\\n\\n                int rvi_idx = 0;                                        // Index into newly allocated rv[i] array\\n                \\n                /* Each of the first numsSize bits of `i` is associated with an integer in nums */\\n                for (int idx = 0; idx < numsSize; ++idx) {\\n                        if ((1 << idx) & i) {\\n                                /* If the idx\\'th bit of `i` is 1, then we add the idx\\'th num to rv[i] */\\n                                rv[i][rvi_idx++] = nums[idx];\\n                        }\\n                }\\n        }\\n        return rv;\\n        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *columnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** subsets(int* nums, int numsSize, int** columnSizes, int* returnSize) {\\n        *returnSize = 1 << numsSize;                                    // Power set of S always has 2^|S| elements\\n\\n        /* Allocating memory dynamically */\\n        int** rv = malloc(sizeof(*rv) * *returnSize);                   // Returned array of arrays\\n        *columnSizes = malloc(sizeof(**columnSizes) * *returnSize);     // columnSizes output\\n        \\n        for (int i = 0; i < *returnSize; ++i) {\\n                \\n                /* popcount is an x86 instruction which returns the number of 1 bits in a register */\\n                /* GCC compiler supports a similar instruction, regardless of platform */\\n                (*columnSizes)[i] = __builtin_popcount(i);              // Let client know length of array\\n\\n                rv[i] = malloc(sizeof(*(rv[i])) * (*columnSizes)[i]);   // Allocate array\\n\\n                int rvi_idx = 0;                                        // Index into newly allocated rv[i] array\\n                \\n                /* Each of the first numsSize bits of `i` is associated with an integer in nums */\\n                for (int idx = 0; idx < numsSize; ++idx) {\\n                        if ((1 << idx) & i) {\\n                                /* If the idx\\'th bit of `i` is 1, then we add the idx\\'th num to rv[i] */\\n                                rv[i][rvi_idx++] = nums[idx];\\n                        }\\n                }\\n        }\\n        return rv;\\n        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27456,
                "title": "python-solution-inspired-by-prime-products",
                "content": "Python solution, similar to Prime Products and all kinds of num combination problems:\\n\\nReference: http://sahandsaba.com/interview-question-facebook-primes.html \\n\\n       class Solution:\\n            # @param S, a list of integer\\n            # @return a list of lists of integer\\n            def subsets(self, S):\\n                # Base result\\n                result = [[]]\\n                for num in S:\\n                    for element in result[:]:\\n                        x=element[:]\\n                        x.append(num)\\n                        result.append(x)\\n                return result",
                "solutionTags": [],
                "code": "Python solution, similar to Prime Products and all kinds of num combination problems:\\n\\nReference: http://sahandsaba.com/interview-question-facebook-primes.html \\n\\n       class Solution:\\n            # @param S, a list of integer\\n            # @return a list of lists of integer\\n            def subsets(self, S):\\n                # Base result\\n                result = [[]]\\n                for num in S:\\n                    for element in result[:]:\\n                        x=element[:]\\n                        x.append(num)\\n                        result.append(x)\\n                return result",
                "codeTag": "Java"
            },
            {
                "id": 27583,
                "title": "simple-backtracking-minimal-copying-16ms",
                "content": "Simply back-track, try both choosing the value at the given index or skipping it. \\n\\n    public:\\n        void op(const vector<int>& S, int idx){\\n            if(idx >= S.size()){\\n                mRes.push_back(mVec);\\n                return;\\n            }\\n            \\n            mVec.push_back(S[idx]);\\n            op(S, idx + 1);\\n            mVec.pop_back();\\n            op(S, idx + 1);\\n        }\\n    \\n        vector<vector<int> > subsets(vector<int> &S) {\\n            sort(S.begin(), S.end());\\n            op(S, 0);\\n            return mRes;\\n        }\\n    \\n    private:\\n        vector<int> mVec;\\n        vector< vector<int> > mRes;",
                "solutionTags": [
                    "C++"
                ],
                "code": "Simply back-track, try both choosing the value at the given index or skipping it. \\n\\n    public:\\n        void op(const vector<int>& S, int idx){\\n            if(idx >= S.size()){\\n                mRes.push_back(mVec);\\n                return;\\n            }\\n            \\n            mVec.push_back(S[idx]);\\n            op(S, idx + 1);\\n            mVec.pop_back();\\n            op(S, idx + 1);\\n        }\\n    \\n        vector<vector<int> > subsets(vector<int> &S) {\\n            sort(S.begin(), S.end());\\n            op(S, 0);\\n            return mRes;\\n        }\\n    \\n    private:\\n        vector<int> mVec;\\n        vector< vector<int> > mRes;",
                "codeTag": "Unknown"
            },
            {
                "id": 27649,
                "title": "accepted-java-solution-dfs",
                "content": "Basic idea is: \\n\\n1. sort the array\\n2. start from the end of the array, for each element, do recursive call to get subset for element 'n-1'.  \\n3. Once get all sebset for n-1, then your subset for n will be :  Subset(n)= Subset(n-1)+(n itself) +(add n to Subset(n-1))\\n4. at last, don't forget to add [] , from OJ, it counts as one subset as well.\\n\\n \\n\\n      public class Solution {\\n    \\n        public List <List <Integer>> subsets (int[] S) {\\n            if (S == null)\\n                return null;\\n            Arrays.sort (S);\\n            List <List <Integer>> result = new ArrayList <List <Integer>> ();\\n            result = getSubSet (S, S.length - 1);\\n            result.add (new ArrayList <Integer> ());\\n            return result;\\n        }\\n    \\n        List <List <Integer>> getSubSet (int[] s, int index) {\\n            List <List <Integer>> result = new ArrayList <List <Integer>> ();\\n            if (index < 0) {\\n                return result;\\n            }\\n            List <List <Integer>> subResult = getSubSet (s, index - 1);\\n            result.addAll (subResult);\\n            for (int i = 0; i < subResult.size (); i++) {\\n                List <Integer> bList = new ArrayList <> ();\\n                bList.addAll (subResult.get (i));\\n                bList.add (s[index]);\\n                result.add (bList);\\n            }\\n            result.add (Arrays.asList (s[index]));\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n        public List <List <Integer>> subsets (int[] S) {\\n            if (S == null)\\n                return null;\\n            Arrays.sort (S);\\n            List <List <Integer>> result = new ArrayList <List <Integer>> ();\\n            result = getSubSet (S, S.length - 1);\\n            result.add (new ArrayList <Integer> ());\\n            return result;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1804734,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1575501,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1566209,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1926509,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1570208,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1568898,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1567345,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1575771,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 2014481,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1936905,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1804734,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1575501,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1566209,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1926509,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1570208,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1568898,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1567345,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1575771,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 2014481,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1936905,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1935017,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1758105,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1715583,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1572036,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1571182,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 2060599,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 2026476,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 2013160,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 2006087,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1951263,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1936909,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1911128,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1808352,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1800858,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1781924,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1776381,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1767466,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1754131,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1739549,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1733505,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            }
        ]
    },
    {
        "title": "Rank Scores",
        "question_content": "<p>Table: <code>Scores</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| score       | decimal |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains the score of a game. Score is a floating point value with two decimal places.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the rank of the scores. The ranking should be calculated according to the following rules:</p>\n\n<ul>\n\t<li>The scores should be ranked from the highest to the lowest.</li>\n\t<li>If there is a tie between two scores, both should have the same ranking.</li>\n\t<li>After a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks.</li>\n</ul>\n\n<p>Return the result table ordered by <code>score</code> in descending order.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nScores table:\n+----+-------+\n| id | score |\n+----+-------+\n| 1  | 3.50  |\n| 2  | 3.65  |\n| 3  | 4.00  |\n| 4  | 3.85  |\n| 5  | 4.00  |\n| 6  | 3.65  |\n+----+-------+\n<strong>Output:</strong> \n+-------+------+\n| score | rank |\n+-------+------+\n| 4.00  | 1    |\n| 4.00  | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.50  | 4    |\n+-------+------+\n</pre>\n",
        "solutions": [
            {
                "id": 53094,
                "title": "simple-short-fast",
                "content": "These are four different solutions.\\n\\n---\\n**With Variables:** 841 ms\\n\\nFirst one uses two variables, one for the current rank and one for the previous score.\\n\\n    SELECT\\n      Score,\\n      @rank := @rank + (@prev <> (@prev := Score)) Rank\\n    FROM\\n      Scores,\\n      (SELECT @rank := 0, @prev := -1) init\\n    ORDER BY Score desc\\n\\n---\\n\\n**Always Count:** 1322 ms\\n\\nThis one counts, for each score, the number of distinct greater or equal scores.\\n\\n    SELECT\\n      Score,\\n      (SELECT count(distinct Score) FROM Scores WHERE Score >= s.Score) Rank\\n    FROM Scores s\\n    ORDER BY Score desc\\n\\n---\\n\\n**Always Count, Pre-uniqued:** 795 ms\\n\\nSame as the previous one, but faster because I have a subquery that \"uniquifies\" the scores first. Not entirely sure *why* it's faster, I'm guessing MySQL makes `tmp` a temporary table and uses it for every outer Score.\\n\\n    SELECT\\n      Score,\\n      (SELECT count(*) FROM (SELECT distinct Score s FROM Scores) tmp WHERE s >= Score) Rank\\n    FROM Scores\\n    ORDER BY Score desc\\n\\n---\\n\\n**Filter/count Scores^2:** 1414 ms\\n\\nInspired by the attempt in wangkan2001's answer. Finally `Id` is good for something :-)\\n\\n    SELECT s.Score, count(distinct t.score) Rank\\n    FROM Scores s JOIN Scores t ON s.Score <= t.score\\n    GROUP BY s.Id\\n    ORDER BY s.Score desc",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "These are four different solutions.\\n\\n---\\n**With Variables:** 841 ms\\n\\nFirst one uses two variables, one for the current rank and one for the previous score.\\n\\n    SELECT\\n      Score,\\n      @rank := @rank + (@prev <> (@prev := Score)) Rank\\n    FROM\\n      Scores,\\n      (SELECT @rank := 0, @prev := -1) init\\n    ORDER BY Score desc\\n\\n---\\n\\n**Always Count:** 1322 ms\\n\\nThis one counts, for each score, the number of distinct greater or equal scores.\\n\\n    SELECT\\n      Score,\\n      (SELECT count(distinct Score) FROM Scores WHERE Score >= s.Score) Rank\\n    FROM Scores s\\n    ORDER BY Score desc\\n\\n---\\n\\n**Always Count, Pre-uniqued:** 795 ms\\n\\nSame as the previous one, but faster because I have a subquery that \"uniquifies\" the scores first. Not entirely sure *why* it's faster, I'm guessing MySQL makes `tmp` a temporary table and uses it for every outer Score.\\n\\n    SELECT\\n      Score,\\n      (SELECT count(*) FROM (SELECT distinct Score s FROM Scores) tmp WHERE s >= Score) Rank\\n    FROM Scores\\n    ORDER BY Score desc\\n\\n---\\n\\n**Filter/count Scores^2:** 1414 ms\\n\\nInspired by the attempt in wangkan2001's answer. Finally `Id` is good for something :-)\\n\\n    SELECT s.Score, count(distinct t.score) Rank\\n    FROM Scores s JOIN Scores t ON s.Score <= t.score\\n    GROUP BY s.Id\\n    ORDER BY s.Score desc",
                "codeTag": "Unknown"
            },
            {
                "id": 456610,
                "title": "mysql-two-simple-solutions-and-explanations-for-beginners",
                "content": "# **1. MySQL Solution: (777ms)**\\n```\\nSELECT S.Score, COUNT(S2.Score) AS Rank FROM Scores S,\\n(SELECT DISTINCT Score FROM Scores) S2\\nWHERE S.Score<=S2.Score\\nGROUP BY S.Id \\nORDER BY S.Score DESC;\\n```\\n![image](https://assets.leetcode.com/users/sophiesu0827/image_1576871668.png)\\n\\n\\n\\n\\n# **2. Optional MySQL solution using Variables: (397ms)**\\n```\\nSELECT Score, convert(Rank,SIGNED) AS Rank FROM\\n    (SELECT Score, @rank:=CASE WHEN Score=@previous THEN @rank ELSE @rank+1 END AS Rank, @previous:=Score FROM Scores,\\n        (SELECT @previous:=-1,@rank:=0) AS initial\\n    ORDER BY Score DESC) A;  \\n```\\n**Intuition:** \\nFirst we sort the table by descending scores. We check each score to see if it is equal to or lower than the previous score. If equal, keep the same rank; If lower, increase the rank by 1.\\n\\n**Yes! We\\'ve found that using Variables would save half of the running time.**\\n",
                "solutionTags": [],
                "code": "```\\nSELECT S.Score, COUNT(S2.Score) AS Rank FROM Scores S,\\n(SELECT DISTINCT Score FROM Scores) S2\\nWHERE S.Score<=S2.Score\\nGROUP BY S.Id \\nORDER BY S.Score DESC;\\n```\n```\\nSELECT Score, convert(Rank,SIGNED) AS Rank FROM\\n    (SELECT Score, @rank:=CASE WHEN Score=@previous THEN @rank ELSE @rank+1 END AS Rank, @previous:=Score FROM Scores,\\n        (SELECT @previous:=-1,@rank:=0) AS initial\\n    ORDER BY Score DESC) A;  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218193,
                "title": "dense-rank-sql-server-604-ms",
                "content": "Hello,\\n\\nI am not sure why I have not come across a solution using DENSE_RANK() since it\\'s made for exactly this purpose. Please do let me know if the goal of the question is to arrive at a solution without using DENSE_RANK().\\n\\nNOTE : I am using MS SQL SERVER and not MySQL. It accepts my solution.\\n\\nHere is my solution :\\n\\n```\\nSELECT s.Score as Score,\\nDENSE_RANK() OVER (ORDER BY s.Score DESC) as Rank\\nFROM Scores s\\n\\n```\\n\\nit does exactly what the question asks us to do. If you want ranks with gaps, we can use RANK() instead of DENSE_RANK()",
                "solutionTags": [],
                "code": "```\\nSELECT s.Score as Score,\\nDENSE_RANK() OVER (ORDER BY s.Score DESC) as Rank\\nFROM Scores s\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3861595,
                "title": "pandas-simple-2-step-approach-additional-knowledge-at-the-end",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Use the rank method with method=\\'dense\\' to assign ranks to the scores in descending order while handling ties. Add a new column \\'rank\\' to the scores DataFrame to store the ranks.\\n2. Sort the DataFrame by score in descending order. This can be achieved using the sort_values method.\\n\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    # Use the rank method to assign ranks to the scores in descending order with no gaps\\n    scores[\\'rank\\'] = scores[\\'score\\'].rank(method=\\'dense\\', ascending=False)\\n    \\n    # Drop id column & Sort the DataFrame by score in descending order\\n    result_df = scores.drop(\\'id\\',axis=1).sort_values(by=\\'score\\', ascending=False)\\n    \\n    return result_df\\n```\\n\\n# Additional Knowledge \\uD83E\\uDD29\\nThe Approach is super simple if we know about the rank method and method = \\'dense\\', but we should not stop here for this question let\\'s explore and increase our knowledge.\\n\\nwhat are other available options like dense? \\uD83E\\uDD14\\nIn Pandas\\' rank method, there are several options available for the method parameter to handle ties when assigning ranks. Here are the available options:\\n\\n**\\'average\\' (default):** This method assigns the average rank to tied elements. For example, if two elements tie for the second rank, they both get the rank of 2.5, and the next rank will be 4.\\n\\n**\\'min\\':** This method assigns the minimum rank to tied elements. For example, if two elements tie for the second rank, they both get the rank of 2, and the next rank will be 4.\\n\\n**\\'max\\':** This method assigns the maximum rank to tied elements. For example, if two elements tie for the second rank, they both get the rank of 3, and the next rank will be 4.\\n\\n**\\'first\\':** This method assigns ranks in the order they appear in the input data, without using any average or other calculations for ties. For example, if two elements tie for the second rank, the first element gets the rank of 2, and the next rank will be 4.\\n\\n**\\'dense\\':** This method assigns dense ranks to tied elements, meaning there are no gaps in the ranks. For example, if two elements tie for the second rank, they both get the rank of 2, and the next rank will be 3.\\n\\n**\\'ordinal\\':** This method is similar to \\'dense\\', but it considers the order of appearance in the data for assigning ranks to tied elements. For example, if two elements tie for the second rank, the first element gets the rank of 2, and the next rank will be 3.\\n\\nThese methods allow you to choose how ties in the data should be handled while assigning ranks. You can select the appropriate method based on your specific requirements. By default, \\'average\\' is used when the method parameter is not provided.\\n\\n## Please upvote the solution which gives me motivation to share high quality solutions like this. Thank You.\\n\\n\\n",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    # Use the rank method to assign ranks to the scores in descending order with no gaps\\n    scores[\\'rank\\'] = scores[\\'score\\'].rank(method=\\'dense\\', ascending=False)\\n    \\n    # Drop id column & Sort the DataFrame by score in descending order\\n    result_df = scores.drop(\\'id\\',axis=1).sort_values(by=\\'score\\', ascending=False)\\n    \\n    return result_df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1967099,
                "title": "mysql-solution",
                "content": "# Solution\\n```\\nSELECT score, dense_rank() OVER(ORDER BY score DESC) as \"rank\"\\nFROM Scores\\n```\\nThe **DENSE_RANK()** is a window function that assigns a rank to each row within a partition of a result set. Unlike the **RANK()** function, the **DENSE_RANK()** function returns consecutive rank values. Rows in each partition receive the same ranks if they have the same values.\\nIf you find this **solution** and **explanation** helpful, please **upvote** it for others people.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score, dense_rank() OVER(ORDER BY score DESC) as \"rank\"\\nFROM Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53096,
                "title": "accepted-solution-using-innerjoin-and-groupby",
                "content": "    SELECT Scores.Score, COUNT(Ranking.Score) AS RANK\\n      FROM Scores\\n         , (\\n           SELECT DISTINCT Score\\n             FROM Scores\\n           ) Ranking\\n     WHERE Scores.Score <= Ranking.Score\\n     GROUP BY Scores.Id, Scores.Score\\n     ORDER BY Scores.Score DESC;",
                "solutionTags": [],
                "code": "    SELECT Scores.Score, COUNT(Ranking.Score) AS RANK\\n      FROM Scores\\n         , (\\n           SELECT DISTINCT Score\\n             FROM Scores\\n           ) Ranking\\n     WHERE Scores.Score <= Ranking.Score\\n     GROUP BY Scores.Id, Scores.Score\\n     ORDER BY Scores.Score DESC;",
                "codeTag": "Unknown"
            },
            {
                "id": 570963,
                "title": "logically-simple-4-lines-mysql-solution-701ms",
                "content": "```\\nSELECT S1.Score, (\\n    SELECT COUNT(DISTINCT Score) FROM Scores WHERE Score >= S1.Score) AS Rank\\nFROM Scores S1\\nORDER BY S1.Score DESC\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT S1.Score, (\\n    SELECT COUNT(DISTINCT Score) FROM Scores WHERE Score >= S1.Score) AS Rank\\nFROM Scores S1\\nORDER BY S1.Score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53129,
                "title": "maybe-the-simpest-solution",
                "content": "Maybe the simplest solution I guess\\n-----------\\n\\nSELECT score,(SELECT COUNT(DISTINCT score) FROM Scores where score > a.score) + 1 rank\\n from Scores a  \\nORDER by score DESC;\\n\\n-----------\\n\\nInspired by Oracle Function row_number()\\uff0crank()\\uff0cdense()",
                "solutionTags": [],
                "code": "Maybe the simplest solution I guess\\n-----------\\n\\nSELECT score,(SELECT COUNT(DISTINCT score) FROM Scores where score > a.score) + 1 rank\\n from Scores a  \\nORDER by score DESC;\\n\\n-----------\\n\\nInspired by Oracle Function row_number()\\uff0crank()\\uff0cdense()",
                "codeTag": "Unknown"
            },
            {
                "id": 1803710,
                "title": "best-smart-mysql-solution-178-rank-scores",
                "content": "```\\nselect s1.score, (select count(distinct score) from scores s2 where s2.score >= s1.score) as \"rank\" from scores s1\\norder by s1.score DESC;\\n\\n#pls upvote if you find solution easy to understand..Thanks..!!\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s1.score, (select count(distinct score) from scores s2 where s2.score >= s1.score) as \"rank\" from scores s1\\norder by s1.score DESC;\\n\\n#pls upvote if you find solution easy to understand..Thanks..!!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53110,
                "title": "accepted-solution-with-subqueries-and-group-by",
                "content": "# Solution with sub-queries\\n\\nWe just get the rows the distinct rows that are <= that each score, count them and wrap them in an external SELECT for formatting. \\n\\n    SELECT Scores.Score, Q3.Rank\\n    FROM(\\n        SELECT Q1.Score as Score, COUNT(Q1.Score) as Rank\\n        FROM \\n            (SELECT DISTINCT Score from Scores) as Q1,\\n            (SELECT DISTINCT Score from Scores) as Q2\\n        WHERE Q1.Score <= Q2.Score\\n        GROUP BY Q1.Score\\n        ) as Q3, Scores\\n    WHERE Q3.Score = Scores.Score\\n    ORDER BY Scores.Score DESC",
                "solutionTags": [],
                "code": "# Solution with sub-queries\\n\\nWe just get the rows the distinct rows that are <= that each score, count them and wrap them in an external SELECT for formatting. \\n\\n    SELECT Scores.Score, Q3.Rank\\n    FROM(\\n        SELECT Q1.Score as Score, COUNT(Q1.Score) as Rank\\n        FROM \\n            (SELECT DISTINCT Score from Scores) as Q1,\\n            (SELECT DISTINCT Score from Scores) as Q2\\n        WHERE Q1.Score <= Q2.Score\\n        GROUP BY Q1.Score\\n        ) as Q3, Scores\\n    WHERE Q3.Score = Scores.Score\\n    ORDER BY Scores.Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 1046525,
                "title": "solution-without-dense-rank",
                "content": "```\\nSELECT \\n    b.Score, \\n\\t(SELECT COUNT(DISTINCT a.Score) FROM Scores a WHERE b.Score <= a.Score) as `Rank`\\nFROM Scores b ORDER BY `Rank`\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    b.Score, \\n\\t(SELECT COUNT(DISTINCT a.Score) FROM Scores a WHERE b.Score <= a.Score) as `Rank`\\nFROM Scores b ORDER BY `Rank`\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3301918,
                "title": "fast-windows-vs-windowless-function-examples",
                "content": "Generally, interviewers want you to use a Windows Function to solve a problem like this.  \\n\\nHowever, you might have an interviewer who specifically says, don\\'t use a Windows Function, so it\\'s good to know both ways.\\n\\nHas anyone every asked you to answer a question like this without a subquery?\\n\\nThanks!\\n\\n[@easyCodingSolutions](https://youtu.be/K3KFG8Hpb2M)\\n\\nhttps://youtu.be/K3KFG8Hpb2M\\n\\nWith Windows Function:\\n\\n```\\n# Using DENSE_RANK - generally what interviewers want\\nSELECT\\n    score\\n    , DENSE_RANK() OVER (ORDER BY score DESC) \\'rank\\'\\nFROM Scores\\n    ORDER BY score DESC\\n```\\n\\nSame as Windows Function:\\n```\\nSELECT\\n  score,\\n  (SELECT COUNT(*) FROM (SELECT distinct score s FROM Scores) CTE WHERE s >= score) \\'Rank\\'\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Using DENSE_RANK - generally what interviewers want\\nSELECT\\n    score\\n    , DENSE_RANK() OVER (ORDER BY score DESC) \\'rank\\'\\nFROM Scores\\n    ORDER BY score DESC\\n```\n```\\nSELECT\\n  score,\\n  (SELECT COUNT(*) FROM (SELECT distinct score s FROM Scores) CTE WHERE s >= score) \\'Rank\\'\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1884813,
                "title": "simple-mysql-solution-with-and-without-window-function",
                "content": "```\\n# Window Function Approach\\nselect score, dense_rank() over (order by score desc) as \"Rank\" from scores;\\n\\n# Using count method\\nselect score, (select count(distinct score) from scores s2 where s2.score >= s1.score) as \"Rank\"\\nfrom scores s1\\norder by score desc;\\n\\n# Do upvote if you like both the approaches!!\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Window Function Approach\\nselect score, dense_rank() over (order by score desc) as \"Rank\" from scores;\\n\\n# Using count method\\nselect score, (select count(distinct score) from scores s2 where s2.score >= s1.score) as \"Rank\"\\nfrom scores s1\\norder by score desc;\\n\\n# Do upvote if you like both the approaches!!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1082561,
                "title": "faster-than-96-memory-less-than-100",
                "content": "```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \\'Rank\\'\\nFROM Scores \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \\'Rank\\'\\nFROM Scores \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420861,
                "title": "mysql-easy-understanding-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome.***\\n____________________________________________________________________________________________________________________________\\n\\u2705 **MySQL Code :**\\n```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \\'Rank\\'\\nFROM Scores \\n```\\n____________________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \\'Rank\\'\\nFROM Scores \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1756654,
                "title": "concise-solution-with-sql-ranking",
                "content": "There are many ways we can calculate the rank of each score, the easiest is to use a built in method named `DENSE_RANK()`. \\n\\n```\\nSELECT \\n    score, \\n    DENSE_RANK() OVER(ORDER BY score desc) AS `rank` \\nFROM scores\\nORDER BY `rank`\\n```\\n\\nTwo things to take in consideration here:\\n\\n1. There is another method called `RANK()` which will give different result for the same query. If you don\\'t understand their difference, I would suggest you to try this with `RANK()` and see the difference in results, it will help you.\\n2. In the 3rd line you have to put the alias `rank` inside `` or `\"\"`, otherwise mysql will give error. This is because `rank` is a syntax used by mysql itself so you have to tell the db engine explicitely that it\\'s not the build in method, it\\'s a string.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    score, \\n    DENSE_RANK() OVER(ORDER BY score desc) AS `rank` \\nFROM scores\\nORDER BY `rank`\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 115770,
                "title": "accepted-solution-with-subquery-for-rank",
                "content": "SELECT s1.Score AS Score, \n(SELECT COUNT(DISTINCT S2.Score) FROM Scores as S2 WHERE S2.Score > S1.Score)+1 AS Rank\nFROM Scores AS s1\nORDER BY Rank ASC",
                "solutionTags": [],
                "code": "(SELECT COUNT(DISTINCT S2.Score) FROM Scores as S2 WHERE S2.Score > S1.Score)+1 AS Rank",
                "codeTag": "Unknown"
            },
            {
                "id": 3907201,
                "title": "pandas-2-lines-very-easy-and-simple-beginners-solution-with-comments",
                "content": "# Code\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n\\n    #Sorting the table in descending Order\\n    scores=scores.sort_values(by=[\\'score\\'],ascending=False)\\n\\n    #Using \\'rank\\' to rank the rows in descending method\\n    #\\'dense\\' method gives ranks continuous without any gap. \\n    scores[\\'rank\\']=(scores[\\'score\\'].rank(method=\\'dense\\',ascending=False))\\n\\n    return scores[[\\'score\\',\\'rank\\']]\\n```\\n\\n---\\n\\n\\n# PLEASE UPVOTE :)",
                "solutionTags": [
                    "Python",
                    "Database",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n\\n    #Sorting the table in descending Order\\n    scores=scores.sort_values(by=[\\'score\\'],ascending=False)\\n\\n    #Using \\'rank\\' to rank the rows in descending method\\n    #\\'dense\\' method gives ranks continuous without any gap. \\n    scores[\\'rank\\']=(scores[\\'score\\'].rank(method=\\'dense\\',ascending=False))\\n\\n    return scores[[\\'score\\',\\'rank\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3350226,
                "title": "mysql-simple-dense-rank-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing ranking method\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nusing dense_rank() approach\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect round(score,2) as score , \\ndense_rank() \\nOVER (  order by score desc ) \\nAS \\'rank\\'\\n from scores order by score desc\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect round(score,2) as score , \\ndense_rank() \\nOVER (  order by score desc ) \\nAS \\'rank\\'\\n from scores order by score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329735,
                "title": "mysql-and-ms-sql-accepted-solutions",
                "content": "1. MySQL Solution:\\n```\\nSELECT s1.Score as score, \\n(SELECT COUNT(DISTINCT s2.Score)+1 FROM Scores s2 WHERE s1.Score< s2.Score) AS \\'Rank\\' \\nFROM Scores s1\\nORDER BY 1 DESC\\n```\\n2. MS SQL Solution\\n```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT s1.Score as score, \\n(SELECT COUNT(DISTINCT s2.Score)+1 FROM Scores s2 WHERE s1.Score< s2.Score) AS \\'Rank\\' \\nFROM Scores s1\\nORDER BY 1 DESC\\n```\n```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648415,
                "title": "rank-scores-one-liner",
                "content": "\\tselect score, dense_rank() over(order by score desc) as \\'rank\\' from scores;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tselect score, dense_rank() over(order by score desc) as \\'rank\\' from scores;",
                "codeTag": "Unknown"
            },
            {
                "id": 190760,
                "title": "simple-subquery-solution",
                "content": "My solution using subquery and allowing dense ranking\n```\nSELECT Score\n  \t   ,(SELECT count(distinct score)\n  \t   \t FROM scores b\n  \t   \t WHERE b.score>= a.score ) as Rank\nFROM scores a\nORDER BY Rank;\n```\n",
                "solutionTags": [],
                "code": "```\nSELECT Score\n  \t   ,(SELECT count(distinct score)\n  \t   \t FROM scores b\n  \t   \t WHERE b.score>= a.score ) as Rank\nFROM scores a\nORDER BY Rank;\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 431650,
                "title": "simple-mysql-solution-not-using-dense-rank",
                "content": "Simple mySql solution not using dense_rank()\\n\\n```\\nselect s.Score, count(a.Score) as rank \\nfrom scores s, (\\n    select distinct Score \\n    FROM Scores) a\\nwhere s.Score <= a.Score\\ngroup by s.Id, s.Score\\norder by s.Score desc;\\n```",
                "solutionTags": [],
                "code": "```\\nselect s.Score, count(a.Score) as rank \\nfrom scores s, (\\n    select distinct Score \\n    FROM Scores) a\\nwhere s.Score <= a.Score\\ngroup by s.Id, s.Score\\norder by s.Score desc;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872817,
                "title": "pandas-vs-sql-elegant-short-all-30-days-of-pandas-solutions",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```Python []\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    return scores.sort_values(\\n        by=\\'score\\', ascending=False,\\n    ).assign(\\n        rank=scores[\\'score\\'].rank(method=\\'dense\\', ascending=False),\\n    )[[\\'score\\', \\'rank\\']]\\n```\\n```SQL []\\nSELECT s1.score,\\n       count(s2.score) AS \"Rank\"\\n  FROM Scores s1,\\n      (SELECT DISTINCT score FROM Scores) s2\\n WHERE s1.score <= s2.score\\n GROUP BY s1.id\\n ORDER BY s1.score DESC;\\n```\\n\\n# Important!\\n###### If you like the solution or find it useful, feel free to **upvote** for it, it will support me in creating high quality solutions)\\n\\n# 30 Days of Pandas solutions\\n\\n### Data Filtering \\u2705\\n- [Big Countries](https://leetcode.com/problems/big-countries/solutions/3848474/pandas-elegant-short-1-line/)\\n- [Recyclable and Low Fat Products](https://leetcode.com/problems/recyclable-and-low-fat-products/solutions/3848500/pandas-elegant-short-1-line/)\\n- [Customers Who Never Order](https://leetcode.com/problems/customers-who-never-order/solutions/3848527/pandas-elegant-short-1-line/)\\n- [Article Views I](https://leetcode.com/problems/article-views-i/solutions/3867192/pandas-elegant-short-1-line/)\\n\\n\\n### String Methods \\u2705\\n- [Invalid Tweets](https://leetcode.com/problems/invalid-tweets/solutions/3849121/pandas-elegant-short-1-line/)\\n- [Calculate Special Bonus](https://leetcode.com/problems/calculate-special-bonus/solutions/3867209/pandas-elegant-short-1-line/)\\n- [Fix Names in a Table](https://leetcode.com/problems/fix-names-in-a-table/solutions/3849167/pandas-elegant-short-1-line/)\\n- [Find Users With Valid E-Mails](https://leetcode.com/problems/find-users-with-valid-e-mails/solutions/3849177/pandas-elegant-short-1-line/)\\n- [Patients With a Condition](https://leetcode.com/problems/patients-with-a-condition/solutions/3849196/pandas-elegant-short-1-line-regex/)\\n\\n\\n### Data Manipulation \\u2705\\n- [Nth Highest Salary](https://leetcode.com/problems/nth-highest-salary/solutions/3867257/pandas-elegant-short-1-line/)\\n- [Second Highest Salary](https://leetcode.com/problems/second-highest-salary/solutions/3867278/pandas-elegant-short/)\\n- [Department Highest Salary](https://leetcode.com/problems/department-highest-salary/solutions/3867312/pandas-elegant-short-1-line/)\\n- [Rank Scores](https://leetcode.com/problems/rank-scores/solutions/3872817/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Delete Duplicate Emails](https://leetcode.com/problems/delete-duplicate-emails/solutions/3849211/pandas-elegant-short/)\\n- [Rearrange Products Table](https://leetcode.com/problems/rearrange-products-table/solutions/3849226/pandas-elegant-short-1-line/)\\n\\n\\n### Statistics \\u2705\\n- [The Number of Rich Customers](https://leetcode.com/problems/the-number-of-rich-customers/solutions/3849251/pandas-elegant-short-1-line/)\\n- [Immediate Food Delivery I](https://leetcode.com/problems/immediate-food-delivery-i/solutions/3872719/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Count Salary Categories](https://leetcode.com/problems/count-salary-categories/solutions/3872801/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Find Total Time Spent by Each Employee](https://leetcode.com/problems/find-total-time-spent-by-each-employee/solutions/3872715/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Game Play Analysis I](https://leetcode.com/problems/game-play-analysis-i/solutions/3863223/pandas-elegant-short-1-line/)\\n- [Number of Unique Subjects Taught by Each Teacher](https://leetcode.com/problems/number-of-unique-subjects-taught-by-each-teacher/solutions/3863239/pandas-elegant-short-1-line/)\\n- [Classes More Than 5 Students](https://leetcode.com/problems/classes-more-than-5-students/solutions/3863249/pandas-elegant-short/)\\n- [Customer Placing the Largest Number of Orders](https://leetcode.com/problems/customer-placing-the-largest-number-of-orders/solutions/3863257/pandas-elegant-short-1-line/)\\n- [Group Sold Products By The Date](https://leetcode.com/problems/group-sold-products-by-the-date/solutions/3863267/pandas-elegant-short-1-line/)\\n- [Daily Leads and Partners](https://leetcode.com/problems/daily-leads-and-partners/solutions/3863279/pandas-elegant-short-1-line/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Actors and Directors Who Cooperated At Least Three Times](https://leetcode.com/problems/actors-and-directors-who-cooperated-at-least-three-times/solutions/3863309/pandas-elegant-short/)\\n- [Replace Employee ID With The Unique Identifier](https://leetcode.com/problems/replace-employee-id-with-the-unique-identifier/solutions/3872822/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Students and Examinations](https://leetcode.com/problems/students-and-examinations/solutions/3872699/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Managers with at Least 5 Direct Reports](https://leetcode.com/problems/managers-with-at-least-5-direct-reports/solutions/3872861/pandas-elegant-short/)\\n- [Sales Person](https://leetcode.com/problems/sales-person/solutions/3872712/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "MySQL",
                    "Pandas"
                ],
                "code": "```Python []\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    return scores.sort_values(\\n        by=\\'score\\', ascending=False,\\n    ).assign(\\n        rank=scores[\\'score\\'].rank(method=\\'dense\\', ascending=False),\\n    )[[\\'score\\', \\'rank\\']]\\n```\n```SQL []\\nSELECT s1.score,\\n       count(s2.score) AS \"Rank\"\\n  FROM Scores s1,\\n      (SELECT DISTINCT score FROM Scores) s2\\n WHERE s1.score <= s2.score\\n GROUP BY s1.id\\n ORDER BY s1.score DESC;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3212948,
                "title": "178-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo rank the scores, we can use a window function DENSE_RANK() in SQL. The DENSE_RANK() function assigns ranks to rows within the partition of a result set. If two or more rows have the same value, they receive the same rank, and the next rank is assigned to the next row.\\n\\nHere\\'s the SQL query to rank the scores:\\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as `rank`\\nFROM Scores\\nORDER BY score DESC;\\n```\\nThis query selects the score column and applies the DENSE_RANK() function to it, which will generate the ranking. We order the result set by the score in descending order, which means the highest score will have the rank 1.\\n\\nThe output of the query for the given input in the problem statement will be:\\n\\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 4.00  | 1    |\\n| 4.00  | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.50  | 4    |\\n+-------+------+\\n\\n```\\nSecond example solution:\\n\\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as `rank`\\nFROM Scores\\nORDER BY score DESC;\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as `rank`\\nFROM Scores\\nORDER BY score DESC;\\n```\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 4.00  | 1    |\\n| 4.00  | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.50  | 4    |\\n+-------+------+\\n\\n```\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as `rank`\\nFROM Scores\\nORDER BY score DESC;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2517177,
                "title": "two-mysql-solutions-simple-dense-rank-and-complex-row-number",
                "content": "1. Simple Method (which a lot of people have used)\\n\\n```\\nSELECT score, DENSE_RANK() over (ORDER BY score DESC) AS \\'rank\\'\\nFROM Scores\\n```\\n\\n2. Complex Method (if dense_rank did not exist) - Faster than 88.95% of MySQL submissions\\n\\n```\\nWITH s1 AS (SELECT score, \\n            ROW_NUMBER() OVER (ORDER BY score DESC) AS \\'rank\\'\\nFROM Scores\\nGROUP BY score) # First create a table with unique row numbers for each distinct score\\n\\nSELECT s1.score, s1.rank\\nFROM s1\\nRIGHT JOIN Scores AS s2  \\nUSING (score) # join two tables using score as the foreign key\\nORDER BY score DESC\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score, DENSE_RANK() over (ORDER BY score DESC) AS \\'rank\\'\\nFROM Scores\\n```\n```\\nWITH s1 AS (SELECT score, \\n            ROW_NUMBER() OVER (ORDER BY score DESC) AS \\'rank\\'\\nFROM Scores\\nGROUP BY score) # First create a table with unique row numbers for each distinct score\\n\\nSELECT s1.score, s1.rank\\nFROM s1\\nRIGHT JOIN Scores AS s2  \\nUSING (score) # join two tables using score as the foreign key\\nORDER BY score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850672,
                "title": "best-solutions-mysql-pandas-beats-100",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT score, dense_rank() OVER(ORDER BY score DESC) as \"rank\"\\nFROM Scores\\n```\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    df[\\'rank\\'] = df[\\'score\\'].rank(method=\\'dense\\', ascending=False) \\n    return df[[\\'score\\',\\'rank\\']]\\n```",
                "solutionTags": [
                    "MySQL",
                    "Pandas"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT score, dense_rank() OVER(ORDER BY score DESC) as \"rank\"\\nFROM Scores\\n```\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    df[\\'rank\\'] = df[\\'score\\'].rank(method=\\'dense\\', ascending=False) \\n    return df[[\\'score\\',\\'rank\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3824711,
                "title": "100-easy-fast-clean-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE 1\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT score, DENSE_RANK () OVER (ORDER BY score DESC) \\n\\nRANK FROM Scores;\\n```\\nIF THIS WILL BE HELPFUL TO YOU,PLEASE UPVOTE!![5kej8w.jpg](https://assets.leetcode.com/users/images/6bae3f42-eb8f-4240-a2a7-fd40f588350a_1690475198.0246775.jpeg)\\n",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT score, DENSE_RANK () OVER (ORDER BY score DESC) \\n\\nRANK FROM Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2308104,
                "title": "row-number-vs-rank-vs-dense-rank",
                "content": "This question is a great place to learn these 3 functions. The best way for you to understand these 3 functions is to simply run the below code for them and see why and what they produce as output. The correct answer is given by DENSE_RANK() but a beginner will always get confused on why and when to use DENSE_RANK() or RANK() or ROW_NUMBER()\\n\\n**ROW_NUMBER()** is like a basic counting function, where it will give continous ranks like 1-2-3-4-5-6 and does not care if the values are same or not. So lets suppose we have three people with marks as 100, 100 and 99. ROW_NUMBER() will give rank 1 to person with 100/100 marks and then give rank 2 to person with 100/100 marks and then give rank 3 to person with 99 marks.\\n\\n* Rank 1 --- 100/100 marks Person A\\n* Rank 2 --- 100/100 marks Person B\\n* Rank 3 --- 99/100 marks Person C\\n\\n```\\nSELECT \\n    score AS \"score\",\\n    ROW_NUMBER() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```\\n\\n**RANK()** is the very close to the correct answer for this question but RANK() leaves hole when it operates. So lets suppose we have three people with marks as 100, 100 and 99. RANK() will give rank 1 to person with 100/100 marks and then give rank 1 to person with 100/100 marks but in the end it will give rank 3 to person with 99 marks.\\n\\n* Rank 1 --- 100/100 marks Person A\\n* Rank 1 --- 100/100 marks Person B\\n* Rank 3 ---  99/100 marks Person C\\n\\n```\\nSELECT \\n    score AS \"score\",\\n    RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```\\n\\n**DENSE_RANK()** is the perfect function as per our given requirments. So lets suppose we have three people with marks as 100, 100 and 99. DENSE_RANK() will give rank 1 to person with 100/100 marks and then give rank 1 to person with 100/100 marks but in the end it will give rank 2 to person with 99 marks.\\n\\n* Rank 1 --- 100/100 marks Person A\\n* Rank 1 --- 100/100 marks Person B\\n* Rank 2 ---  99/100 marks Person C\\n```\\nSELECT \\n    score AS \"score\",\\n    DENSE_RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    score AS \"score\",\\n    ROW_NUMBER() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```\n```\\nSELECT \\n    score AS \"score\",\\n    RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```\n```\\nSELECT \\n    score AS \"score\",\\n    DENSE_RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2234543,
                "title": "mysql-solution",
                "content": "```\\nSELECT\\n    score,\\n    DENSE_RANK() OVER (\\n        ORDER BY\\n            score DESC\\n    ) AS \\'rank\\'\\nFROM\\n    SCORES;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    score,\\n    DENSE_RANK() OVER (\\n        ORDER BY\\n            score DESC\\n    ) AS \\'rank\\'\\nFROM\\n    SCORES;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711996,
                "title": "super-simple-solution",
                "content": "select\\nscore, (select count(distinct score)+1 from Scores where score>s.score) as \"rank\"\\nfrom Scores s\\norder by score desc",
                "solutionTags": [],
                "code": "select\\nscore, (select count(distinct score)+1 from Scores where score>s.score) as \"rank\"\\nfrom Scores s\\norder by score desc",
                "codeTag": "Unknown"
            },
            {
                "id": 1698301,
                "title": "3-easiest-ways",
                "content": "Classic way\\n```\\nSELECT s.score\\n     , DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\n  FROM scores s\\n ORDER BY s.score DESC\\n```\\nOne stupid way. Use on the interview is your interviewer doesn\\'t know or hates window functions\\n```\\nSELECT t.score\\n     , (SELECT COUNT(DISTINCT s.score)  FROM scores s WHERE s.score >=t.score)  AS rank \\n  FROM scores t\\n ORDER BY t.score DESC\\n```\\n\\n3th way (MySQL):\\n```\\nSELECT s1.score\\n, 1+COUNT(DISTINCT CASE WHEN s2.score>s1.score AND s1.id!=s2.id THEN s2.score ELSE NULL END) AS \"rank\"\\nFROM scores s1\\nCROSS JOIN\\nscores s2\\nGROUP BY s1.id\\n, s1.score\\nORDER BY 2 ASC\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT s.score\\n     , DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\n  FROM scores s\\n ORDER BY s.score DESC\\n```\n```\\nSELECT t.score\\n     , (SELECT COUNT(DISTINCT s.score)  FROM scores s WHERE s.score >=t.score)  AS rank \\n  FROM scores t\\n ORDER BY t.score DESC\\n```\n```\\nSELECT s1.score\\n, 1+COUNT(DISTINCT CASE WHEN s2.score>s1.score AND s1.id!=s2.id THEN s2.score ELSE NULL END) AS \"rank\"\\nFROM scores s1\\nCROSS JOIN\\nscores s2\\nGROUP BY s1.id\\n, s1.score\\nORDER BY 2 ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 719776,
                "title": "easy-using-methods-to-rank-rows-in-sql",
                "content": "```\\nSELECT score, dense_rank() over (order by score desc) as \\'Rank\\'\\nFROM scores\\n```\\n\\n\\n\\nPlease note that the description says \"If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value\" \\n\\nThat\\'s why you need to use **DENSE_RANK** instead of rank or row_number. \\n\\nSee the functions for other rank methods:\\n-- row_number() : \"Returns a unique number for each row\" IN CASE OF A TIE: with rankings arbitrarily assigned \\n-- rank() \"Returns the same ranking\" IN CASE OF A TIE: gaps* in the rankings\\n-- dense_rank() \"Returns the same ranking\" IN CASE OF A TIE: no gaps in the rankings",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nSELECT score, dense_rank() over (order by score desc) as \\'Rank\\'\\nFROM scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53130,
                "title": "my-800ms-simple-solution-without-variables",
                "content": "    SELECT T2.Score Score, (SELECT COUNT(*) + 1 FROM (SELECT T1.Score FROM Scores T1 GROUP BY Score ORDER BY Score DESC) TEMP WHERE T2.Score < TEMP.Score) Rank FROM Scores T2 ORDER BY Score DESC;",
                "solutionTags": [],
                "code": "    SELECT T2.Score Score, (SELECT COUNT(*) + 1 FROM (SELECT T1.Score FROM Scores T1 GROUP BY Score ORDER BY Score DESC) TEMP WHERE T2.Score < TEMP.Score) Rank FROM Scores T2 ORDER BY Score DESC;",
                "codeTag": "Unknown"
            },
            {
                "id": 53148,
                "title": "very-concise-accepted-solution-without-variables-check-it-out",
                "content": "    Select sc.Score,\\n           (Select count(*)+1 from (select distinct (Score) from Scores)\\n            as uniqeScores where Score > sc.Score) as rank \\n    from Scores sc order by sc.Score desc;",
                "solutionTags": [],
                "code": "    Select sc.Score,\\n           (Select count(*)+1 from (select distinct (Score) from Scores)\\n            as uniqeScores where Score > sc.Score) as rank \\n    from Scores sc order by sc.Score desc;",
                "codeTag": "Unknown"
            },
            {
                "id": 53152,
                "title": "1169ms-solution-without-variables-and-union",
                "content": "    SELECT\\n      s2.`Score`,\\n      (SELECT COUNT(DISTINCT s1.`Score`) FROM `Scores` s1 WHERE s1.`Score` >= s2.`Score`)\\n        FROM `Scores` s2\\n          ORDER BY s2.`Score` DESC\\n\\np.s. please share more faster solutions!",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "    SELECT\\n      s2.`Score`,\\n      (SELECT COUNT(DISTINCT s1.`Score`) FROM `Scores` s1 WHERE s1.`Score` >= s2.`Score`)\\n        FROM `Scores` s2\\n          ORDER BY s2.`Score` DESC\\n\\np.s. please share more faster solutions!",
                "codeTag": "Unknown"
            },
            {
                "id": 3146556,
                "title": "easy-method-by-oracle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT s.score,\\n DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\n  FROM scores s\\n ORDER BY s.score DESC;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT s.score,\\n DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\n  FROM scores s\\n ORDER BY s.score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2740501,
                "title": "sql-multiple-approaches-with-explanation-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/rank-scores.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\nSELECT s.score,\\n    (\\n        SELECT count(DISTINCT (ss.score)) + 1\\n        FROM Scores ss\\n        WHERE ss.score > s.score\\n        ) AS \\'rank\\'\\nFROM Scores s\\nORDER BY s.score DESC\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT s.score,\\n    (\\n        SELECT count(DISTINCT (ss.score)) + 1\\n        FROM Scores ss\\n        WHERE ss.score > s.score\\n        ) AS \\'rank\\'\\nFROM Scores s\\nORDER BY s.score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1719541,
                "title": "faster-than-99",
                "content": "Subquery the grouped score with a rank so that you can duplicate the rows.\\n```\\nSELECT Scores.score, x.rank\\nFROM Scores\\nINNER JOIN (\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) as \"rank\"\\n    FROM Scores\\n    GROUP BY score\\n) x ON x.score = Scores.score\\nORDER BY x.rank\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Scores.score, x.rank\\nFROM Scores\\nINNER JOIN (\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) as \"rank\"\\n    FROM Scores\\n    GROUP BY score\\n) x ON x.score = Scores.score\\nORDER BY x.rank\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1641262,
                "title": "good-of-sql-beginner-to-understand",
                "content": "select a.score, (select count(distinct b.score) from Scores b \\n                 where a.score <= b.score) as \"rank\"\\nfrom Scores a\\norder by score desc;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select a.score, (select count(distinct b.score) from Scores b \\n                 where a.score <= b.score) as \"rank\"\\nfrom Scores a\\norder by score desc;",
                "codeTag": "Unknown"
            },
            {
                "id": 1066148,
                "title": "no-dense-rank-faster-than-96-63-mysql",
                "content": "```\\nSELECT s.score, u.rank\\nFROM Scores s\\nLEFT JOIN(\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) AS `rank`\\n    FROM (SELECT DISTINCT score FROM Scores ORDER BY score DESC) d\\n) u\\nON s.score=u.score\\nORDER BY score DESC;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT s.score, u.rank\\nFROM Scores s\\nLEFT JOIN(\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) AS `rank`\\n    FROM (SELECT DISTINCT score FROM Scores ORDER BY score DESC) d\\n) u\\nON s.score=u.score\\nORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 750332,
                "title": "mysql-dense-rank",
                "content": "```\\nSELECT score, dense_rank() over(order by score DESC) as \\'Rank\\'\\nFROM Scores\\n```\\nLeetcode updates the version of the MYSQL!!! Thank god.",
                "solutionTags": [],
                "code": "```\\nSELECT score, dense_rank() over(order by score DESC) as \\'Rank\\'\\nFROM Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 676422,
                "title": "ms-sql-server-solution-simple-and-fast",
                "content": "```\\nSELECT Score AS score,\\n       DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\nFROM Scores\\n```\\n\\nRuntime: 825 ms, faster than 91.66% of MS SQL Server online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MS SQL Server online submissions for Rank Scores.\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT Score AS score,\\n       DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\nFROM Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 665469,
                "title": "solution-with-and-without-window-function",
                "content": "If you are allowed to use window functions, then a simple dense_rank() will work.\\nIf you are not allowed to use window functions:\\n```\\nSelect \\nScore,\\n(SELECT COUNT(*) FROM \\n        (SELECT DISTINCT Score S FROM Scores) TMP\\nWHERE S >= Score\\n) \"Rank\"\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "solutionTags": [],
                "code": "```\\nSelect \\nScore,\\n(SELECT COUNT(*) FROM \\n        (SELECT DISTINCT Score S FROM Scores) TMP\\nWHERE S >= Score\\n) \"Rank\"\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525229,
                "title": "mysql-solution-works-on-leetcode-s-version-5-7",
                "content": "Generating `row_number` would have been a lot easier with version 8 with `ROW_NUMBER() OVER()`. Unfornately LeetCode has an older version of MySQL that does not have this feature.\\n```SQL\\nSELECT s.Score, r.Rank\\nFROM (\\n    --  Subquery 2: Generate row_number\\n    SELECT Score, (@row_number:=@row_number + 1) AS `Rank`\\n    FROM (\\n        -- Subquery 1: Generate ranked, unique scores\\n        SELECT Score\\n        FROM Scores\\n        GROUP BY Score\\n        ORDER BY Score DESC\\n    ) AS s, (SELECT @row_number:=0) AS dummie\\n) AS r\\nRIGHT JOIN Scores AS s\\n    ON s.Score = r.Score\\nORDER BY r.Rank;\\n```",
                "solutionTags": [],
                "code": "```SQL\\nSELECT s.Score, r.Rank\\nFROM (\\n    --  Subquery 2: Generate row_number\\n    SELECT Score, (@row_number:=@row_number + 1) AS `Rank`\\n    FROM (\\n        -- Subquery 1: Generate ranked, unique scores\\n        SELECT Score\\n        FROM Scores\\n        GROUP BY Score\\n        ORDER BY Score DESC\\n    ) AS s, (SELECT @row_number:=0) AS dummie\\n) AS r\\nRIGHT JOIN Scores AS s\\n    ON s.Score = r.Score\\nORDER BY r.Rank;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354027,
                "title": "sql-easy-to-understand",
                "content": "SELECT s.Score, COUNT(t.Score) AS Rank FROM\\n(SELECT DISTINCT Score FROM Scores) AS t, Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.Id, s.Score\\nORDER BY s.Score DESC;",
                "solutionTags": [],
                "code": "SELECT s.Score, COUNT(t.Score) AS Rank FROM\\n(SELECT DISTINCT Score FROM Scores) AS t, Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.Id, s.Score\\nORDER BY s.Score DESC;",
                "codeTag": "Unknown"
            },
            {
                "id": 163333,
                "title": "no-variable-no-group-by",
                "content": "SELECT t1.Score,(\\nSELECT COUNT(DISTINCT t2.Score)+1\\n    FROM Scores t2\\n    WHERE t1.Score < t2.Score\\n) AS Rank\\nFROM Scores t1\\nORDER BY t1.Score DESC",
                "solutionTags": [],
                "code": "SELECT t1.Score,(\\nSELECT COUNT(DISTINCT t2.Score)+1\\n    FROM Scores t2\\n    WHERE t1.Score < t2.Score\\n) AS Rank\\nFROM Scores t1\\nORDER BY t1.Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 3979058,
                "title": "sql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSelect score, dense_rank() over (Order By score DESC) as \\'rank\\' from Scores ;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect score, dense_rank() over (Order By score DESC) as \\'rank\\' from Scores ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466260,
                "title": "easy-approach",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect score,dense_rank() over( order by score desc) as \\'rank\\' from scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect score,dense_rank() over( order by score desc) as \\'rank\\' from scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3324093,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect score, dense_rank() over (order by score desc) as `rank`\\nfrom Scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect score, dense_rank() over (order by score desc) as `rank`\\nfrom Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2797938,
                "title": "oracle-solution-with-correlated-subquery",
                "content": "```\\nSELECT s1.score AS score, \\n(\\n    SELECT COUNT(DISTINCT s2.score) \\n    FROM scores s2 \\n    WHERE s1.score < s2.score \\n) + 1 AS rank\\nFROM Scores s1\\nORDER BY score DESC;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT s1.score AS score, \\n(\\n    SELECT COUNT(DISTINCT s2.score) \\n    FROM scores s2 \\n    WHERE s1.score < s2.score \\n) + 1 AS rank\\nFROM Scores s1\\nORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620875,
                "title": "sql-easy-approach-simple-and-fast",
                "content": "**If You Like, Please Upvote.**\\n![image](https://assets.leetcode.com/users/images/326dcf2e-e386-4ecf-8eb7-49c26770842f_1664080468.680641.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**If You Like, Please Upvote.**\\n![image](https://assets.leetcode.com/users/images/326dcf2e-e386-4ecf-8eb7-49c26770842f_1664080468.680641.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2411341,
                "title": "simple-solution-using-correlated-subquery",
                "content": "```\\nselect score,\\n(select count(s2.score) from (select distinct score from scores) s2 \\nwhere s2.score >= s1.score) as \"RANK\"\\nfrom scores s1 \\nORDER BY score DESC;\\n```\\n\\nApproach : Rank will be decided based on unique scores. We want rank of all the scores. So the idea is to loop for all distinct scores and find the count of scores(s2) greater than or equal to current distinct score (s1) and store it as rank and display it in descending order.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect score,\\n(select count(s2.score) from (select distinct score from scores) s2 \\nwhere s2.score >= s1.score) as \"RANK\"\\nfrom scores s1 \\nORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1305451,
                "title": "mysql-no-dense-rank-436ms-17-66",
                "content": "I was not aware that SQL had a function for this already, so after quite a bit of trial and error I arrived at this solution.\\n\\n```\\nSELECT s3.Score, s4.Rank\\nFROM Scores s3\\nINNER JOIN ( SELECT Score, @i:=@i+1 \\'Rank\\'\\n            FROM ( SELECT DISTINCT Score\\n                    FROM Scores\\n                    ORDER BY Score DESC) s1\\n            CROSS JOIN (SELECT @i:=0) s2) s4\\nON s3.Score = s4.Score\\nORDER BY s3.Score DESC;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT s3.Score, s4.Rank\\nFROM Scores s3\\nINNER JOIN ( SELECT Score, @i:=@i+1 \\'Rank\\'\\n            FROM ( SELECT DISTINCT Score\\n                    FROM Scores\\n                    ORDER BY Score DESC) s1\\n            CROSS JOIN (SELECT @i:=0) s2) s4\\nON s3.Score = s4.Score\\nORDER BY s3.Score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122959,
                "title": "using-dense-rank-in-mysql-97-faster",
                "content": "```\\nSelect score, DENSE_RANK() over (\\norder by Score desc\\n)\\'Rank\\' from Scores;\\n```",
                "solutionTags": [],
                "code": "```\\nSelect score, DENSE_RANK() over (\\norder by Score desc\\n)\\'Rank\\' from Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374182,
                "title": "simply-answer",
                "content": "select s1.score, count(distinct s2.score) as Rank\\nfrom scores s1, scores s2\\nwhere s1.score <=s2.score\\ngroup by s1.id\\norder by s1.score desc\\n",
                "solutionTags": [],
                "code": "select s1.score, count(distinct s2.score) as Rank\\nfrom scores s1, scores s2\\nwhere s1.score <=s2.score\\ngroup by s1.id\\norder by s1.score desc\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 259968,
                "title": "solution-accepted",
                "content": "SELECT Score, \\n       (SELECT COUNT(DISTINCT Score) FROM Scores WHERE Score >= s.Score) Rank\\nFROM Scores s\\nORDER BY Score DESC",
                "solutionTags": [],
                "code": "SELECT Score, \\n       (SELECT COUNT(DISTINCT Score) FROM Scores WHERE Score >= s.Score) Rank\\nFROM Scores s\\nORDER BY Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 187650,
                "title": "simple-dense-rank-solution",
                "content": "select score, dense_rank() over (  order by Score desc) [Rank] from scores",
                "solutionTags": [],
                "code": "select score, dense_rank() over (  order by Score desc) [Rank] from scores",
                "codeTag": "Unknown"
            },
            {
                "id": 53141,
                "title": "runtime-704-ms-use-two-variables",
                "content": "    select Score,Rank from \\n    (\\n    SELECT Score,\\n           CASE\\n               WHEN @dummy <=> Score THEN @Rank := @Rank \\n               ELSE @Rank := @Rank +1\\n    \\tEND AS Rank,@dummy := Score as dummy\\n    FROM\\n      (SELECT @Rank := 0,@dummy := NULL) r,\\n         Scores\\n    ORDER BY Score DESC\\n    ) AS C",
                "solutionTags": [],
                "code": "    select Score,Rank from \\n    (\\n    SELECT Score,\\n           CASE\\n               WHEN @dummy <=> Score THEN @Rank := @Rank \\n               ELSE @Rank := @Rank +1\\n    \\tEND AS Rank,@dummy := Score as dummy\\n    FROM\\n      (SELECT @Rank := 0,@dummy := NULL) r,\\n         Scores\\n    ORDER BY Score DESC\\n    ) AS C",
                "codeTag": "Unknown"
            },
            {
                "id": 53101,
                "title": "accepted-solution-with-variables",
                "content": "    select Score,\\n      case \\n        when @prevScore = Score then @rank\\n        when (@prevScore := Score) is not null then @rank := @rank+1\\n      end as Rank\\n    from Scores, (select @rank := 0, @prevScore := NULL) a\\n    order by Score desc;",
                "solutionTags": [],
                "code": "    select Score,\\n      case \\n        when @prevScore = Score then @rank\\n        when (@prevScore := Score) is not null then @rank := @rank+1\\n      end as Rank\\n    from Scores, (select @rank := 0, @prevScore := NULL) a\\n    order by Score desc;",
                "codeTag": "Unknown"
            },
            {
                "id": 3872696,
                "title": "simple-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect score,dense_rank() over (order by score desc) as \\'Rank\\' from Scores\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect score,dense_rank() over (order by score desc) as \\'Rank\\' from Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855743,
                "title": "simple-approach-beats-98",
                "content": "```\\nselect score,\\ndense_rank() over (order by score desc) as \\'Rank\\'\\nfrom Scores\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect score,\\ndense_rank() over (order by score desc) as \\'Rank\\'\\nfrom Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850396,
                "title": "pandas-3-lines-sort-dense-rank",
                "content": "\\n# Code\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    # assign lowest rank to highest value\\n    # `method=\\'dense\\'` assigns same rank to equal values without skipping ranks\\n    df[\\'rank\\'] = df[\\'score\\'].rank(method=\\'dense\\', ascending=False) \\n    return df[[\\'score\\',\\'rank\\']]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    # assign lowest rank to highest value\\n    # `method=\\'dense\\'` assigns same rank to equal values without skipping ranks\\n    df[\\'rank\\'] = df[\\'score\\'].rank(method=\\'dense\\', ascending=False) \\n    return df[[\\'score\\',\\'rank\\']]\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3523708,
                "title": "mysql-server-solution-for-rank-scores-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this SQL query is to retrieve the scores from the Scores table along with their corresponding rank, where the rank is determined by the score in descending order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Use the dense_rank() function to assign a rank to each score in the Scores table, ordered by score in descending order.\\n2. Select the Score column and the rank assigned by the dense_rank() function.\\n3. The result set will contain one row for each score in the Scores table, with the score and its corresponding rank.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n The time complexity of this query depends on the size of the Scores table and the efficiency of the database engine\\'s query optimizer. In general, the time complexity of a query with an ORDER BY clause is O(n * log n), where n is the number of rows in the table. However, the dense_rank() function may help to optimize the query execution plan and reduce the actual time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this query depends on the size of the result set and the size of the columns being selected. In this case, the result set will have at most as many rows as the Scores table, and each row will have two columns (Score and Rank). Therefore, the space complexity is O(n), where n is the number of rows in the Scores table.\\n\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect Score, dense_rank() over(order by Score desc) as Rank from Scores;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect Score, dense_rank() over(order by Score desc) as Rank from Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2908530,
                "title": "mysql-dense-rank-vs-rank",
                "content": "\\n\\n# Using **DENSE_RANK()**\\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score desc) as \\'rank\\'\\nFROM Scores\\nORDER BY score desc\\n```\\n\\n# Using **RANK()**\\nRank() not assigning rank in a consecutive order, it is assigning by a rank of row within same categories/ score in this case.\\n\\n\\n```\\nSELECT score, RANK() OVER (ORDER BY score desc) as \\'rank\\'\\nFROM Scores\\nORDER BY score desc\\n```\\nThe following are the differences between using **DENSE_RANK()** and **RANK()**:\\n![image.png](https://assets.leetcode.com/users/images/db3ecabf-c532-4ee5-9e36-3ca47585bc47_1671004821.9050007.png)\\n\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score desc) as \\'rank\\'\\nFROM Scores\\nORDER BY score desc\\n```\n```\\nSELECT score, RANK() OVER (ORDER BY score desc) as \\'rank\\'\\nFROM Scores\\nORDER BY score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2607382,
                "title": "178-rank-scores",
                "content": "```\\nSELECT score,\\n    DENSE_RANK() OVER (\\n    ORDER BY score DESC\\n    ) AS \\'rank\\'\\nFROM SCORES;",
                "solutionTags": [],
                "code": "```\\nSELECT score,\\n    DENSE_RANK() OVER (\\n    ORDER BY score DESC\\n    ) AS \\'rank\\'\\nFROM SCORES;",
                "codeTag": "Unknown"
            },
            {
                "id": 2237222,
                "title": "simplest-oracle-solution",
                "content": "select score,DENSE_RANK() over(order by score desc ) as rank from Scores\\norder by score desc\\n",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "select score,DENSE_RANK() over(order by score desc ) as rank from Scores\\norder by score desc\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1730791,
                "title": "dense-rank-can-not-think-of-a-simpler-solution",
                "content": "```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) AS `rank` FROM Scores ORDER BY score DESC;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) AS `rank` FROM Scores ORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1660727,
                "title": "dense-rank",
                "content": "```\\nSELECT \\n    score,\\n    DENSE_RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \\'rank\\'\\nFROM \\n    Scores;\\n```\\n\\nThe difference between rank and dense_rank is rank will skip numbers after ranking two equal values. Dense_rank will always rank with consecutive numbers.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    score,\\n    DENSE_RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \\'rank\\'\\nFROM \\n    Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1556821,
                "title": "faster-than-99-95-solution-using-mysql-s-built-in-windowing-s-dense-rank",
                "content": "Runtime: 208 ms, faster than 99.95% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores.\\n\\nThe simplest solution is to use built-in Windowing with a [`DENSE_RANK` function](https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_dense-rank), which by design gives exactly what we need.\\n\\nTo learn more, please see [MySQL documentation and examples on Windowing](https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html). Windowing concept is very powerful and is definitely the fastest way to calculate ranks, sums, averages, counts on \"buckets\" of data, where by the bucket I understand a group of data (groupped by a certain characteristic, like date, category or a given value type). Whereas Windowing is a bit harder to master, it\\'s definitely useful when creating reports.\\n\\n```sql\\n# Write your MySQL query statement below\\nSELECT\\n    s.score,\\n    DENSE_RANK() OVER (\\n        ORDER BY s.score DESC\\n    ) \\'rank\\'\\nFROM Scores s;\\n```\\n",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "```sql\\n# Write your MySQL query statement below\\nSELECT\\n    s.score,\\n    DENSE_RANK() OVER (\\n        ORDER BY s.score DESC\\n    ) \\'rank\\'\\nFROM Scores s;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1516798,
                "title": "without-dense-rank",
                "content": "Select s1.Score, count(distinct s2.Score) as \"Rank\"\\n    From Scores s1\\n    Join Scores s2 \\n    where s1.Score<=s2.Score\\n    Group by s1.Id\\n    order by Score DESC",
                "solutionTags": [],
                "code": "Select s1.Score, count(distinct s2.Score) as \"Rank\"\\n    From Scores s1\\n    Join Scores s2 \\n    where s1.Score<=s2.Score\\n    Group by s1.Id\\n    order by Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 1507145,
                "title": "mssql-dense-rank",
                "content": "```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY SCORE DESC) Rank\\nFROM SCORES S;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY SCORE DESC) Rank\\nFROM SCORES S;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174149,
                "title": "solution-without-dense-rank",
                "content": "select c.score, d.ran as \\'Rank\\' from (\\nselect a.score, ROW_NUMBER() OVER (ORDER BY a.score desc) AS ran from\\n(select distinct score from Scores) as a ) as d \\ninner join\\nScores as c \\non c.score = d.score\\norder by ran asc",
                "solutionTags": [],
                "code": "select c.score, d.ran as \\'Rank\\' from (\\nselect a.score, ROW_NUMBER() OVER (ORDER BY a.score desc) AS ran from\\n(select distinct score from Scores) as a ) as d \\ninner join\\nScores as c \\non c.score = d.score\\norder by ran asc",
                "codeTag": "Unknown"
            },
            {
                "id": 972814,
                "title": "intuitive-answer-with-inner-join",
                "content": "Per question description, the rank of a number $a$ is the number of unique numbers larger than or equal to $a$. Translate that into sql:\\n\\n```sql\\n# Write your MySQL query statement below\\n\\nselect a.score\\n    , count(distinct(b.score)) as `Rank`\\nfrom Scores a\\ninner join Scores b\\non b.score >= a.score\\ngroup by a.id, a.score\\norder by `Rank` ASC\\n```",
                "solutionTags": [],
                "code": "```sql\\n# Write your MySQL query statement below\\n\\nselect a.score\\n    , count(distinct(b.score)) as `Rank`\\nfrom Scores a\\ninner join Scores b\\non b.score >= a.score\\ngroup by a.id, a.score\\norder by `Rank` ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 902347,
                "title": "one-line-with-dense-rank",
                "content": "select score, dense_rank() over (order by score desc) as \\'Rank\\' from scores",
                "solutionTags": [],
                "code": "select score, dense_rank() over (order by score desc) as \\'Rank\\' from scores",
                "codeTag": "Unknown"
            },
            {
                "id": 586577,
                "title": "1-liner",
                "content": "select score, dense_rank() over (order by score desc) as rank from scores",
                "solutionTags": [],
                "code": "select score, dense_rank() over (order by score desc) as rank from scores",
                "codeTag": "Unknown"
            },
            {
                "id": 437961,
                "title": "simple-mysql-solution-accepted-runtime-264-ms",
                "content": "SELECT t1.Score,(SELECT count(distinct Score)+1 from Scores t2 where t2.Score-t1.Score>0.00001) Rank FROM Scores t1 ORDER BY Rank;",
                "solutionTags": [],
                "code": "SELECT t1.Score,(SELECT count(distinct Score)+1 from Scores t2 where t2.Score-t1.Score>0.00001) Rank FROM Scores t1 ORDER BY Rank;",
                "codeTag": "Unknown"
            },
            {
                "id": 415318,
                "title": "one-more-simple-solution",
                "content": "Select s1.Score, ((Select  COUNT(DISTINCT Score)  From Scores Where Score > s1.Score) + 1) as Rank From Scores  s1    ORDER BY s1.Score DESC",
                "solutionTags": [],
                "code": "Select s1.Score, ((Select  COUNT(DISTINCT Score)  From Scores Where Score > s1.Score) + 1) as Rank From Scores  s1    ORDER BY s1.Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 268759,
                "title": "very-simple-solution",
                "content": "```\\nSELECT  Score, DENSE_RANK( ) OVER (ORDER BY Score DESC ) as Rank\\nFROM Scores;",
                "solutionTags": [],
                "code": "```\\nSELECT  Score, DENSE_RANK( ) OVER (ORDER BY Score DESC ) as Rank\\nFROM Scores;",
                "codeTag": "Unknown"
            },
            {
                "id": 261595,
                "title": "solution-accepted",
                "content": "# Write your MySQL query statement below\\n```sql\\nSELECT Scores.Score as Score, count(rankings.Score) as Rank\\nFROM Scores, (Select Distinct Score from Scores) as rankings\\nWhere rankings.Score >= Scores.Score\\nGroup by Scores.id\\nOrder by Scores.Score DESC;\\n```",
                "solutionTags": [],
                "code": "```sql\\nSELECT Scores.Score as Score, count(rankings.Score) as Rank\\nFROM Scores, (Select Distinct Score from Scores) as rankings\\nWhere rankings.Score >= Scores.Score\\nGroup by Scores.id\\nOrder by Scores.Score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 229353,
                "title": "mysql-solution-not-use-row-number-function",
                "content": "This question seems to be not allowed row_number function.\\n```\\nselect score, rank\\nfrom\\n(\\n select \\n  a.id, \\n  a.score, \\n  count(distinct b.score) + 1 as rank \\n from Scores a \\n left outer join Scores b \\n on a.score < b.score\\n group by a.id, a.score\\n) tbl\\norder by rank\\n```",
                "solutionTags": [],
                "code": "```\\nselect score, rank\\nfrom\\n(\\n select \\n  a.id, \\n  a.score, \\n  count(distinct b.score) + 1 as rank \\n from Scores a \\n left outer join Scores b \\n on a.score < b.score\\n group by a.id, a.score\\n) tbl\\norder by rank\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 175722,
                "title": "simple-and-easy-to-understand",
                "content": "```\\nSELECT Scores.Score ,COUNT(DISTINCT greater.Score)+1 AS Rank\\nFROM Scores\\nLEFT JOIN Scores greater ON greater.Score>Scores.Score\\nGROUP BY Scores.Id\\nORDER BY Rank\\n```\\n\\nNotice that \\'rank of a score\\' = \\'#unique scores\\' + 1. For example, rank(4.0) = 0(no unique score greater than 4.0) + 1 = 1. \\nWe want to count unique score here because we want dense rank, which means all scores with the same value will be calculated as one rank (say two 4.0 won\\'t let 3.85 be rank3)\\u3002\\nIn the sql\\uFF0Cwe left join the original table with itself and calculate distinct count of scores greater than the current value. And the rank of current value = this count+1 ",
                "solutionTags": [],
                "code": "```\\nSELECT Scores.Score ,COUNT(DISTINCT greater.Score)+1 AS Rank\\nFROM Scores\\nLEFT JOIN Scores greater ON greater.Score>Scores.Score\\nGROUP BY Scores.Id\\nORDER BY Rank\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 170610,
                "title": "using-dense-rank-387ms-sql-server",
                "content": "```select  Score, dense_rank() over (order by Score DESC) as Rank from Scores;```",
                "solutionTags": [],
                "code": "```select  Score, dense_rank() over (order by Score DESC) as Rank from Scores;```",
                "codeTag": "Unknown"
            },
            {
                "id": 143486,
                "title": "accepted-solution-looking-for-simplified-idea",
                "content": "SELECT Score, CAST(Rank AS UNSIGNED) AS Rank\\nFROM (\\n    SELECT Score, CASE \\n        WHEN @preScore = Score \\n        THEN @countRank \\n        ELSE @countRank := @countRank + 1 \\n        END AS Rank, @preScore := Score AS preScore\\n    FROM Scores AS s, (SELECT @countRank := 0, @preScore := NULL) AS p\\n    ORDER BY Score DESC) AS sr;\\n",
                "solutionTags": [],
                "code": "SELECT Score, CAST(Rank AS UNSIGNED) AS Rank\\nFROM (\\n    SELECT Score, CASE \\n        WHEN @preScore = Score \\n        THEN @countRank \\n        ELSE @countRank := @countRank + 1 \\n        END AS Rank, @preScore := Score AS preScore\\n    FROM Scores AS s, (SELECT @countRank := 0, @preScore := NULL) AS p\\n    ORDER BY Score DESC) AS sr;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 124148,
                "title": "184ms-solution-beats-100-submission-easy-to-understand",
                "content": "Runtime 184ms\\n\\nFirst, create a table with distinct score and generate new rank id from 1 to 4.\\nSecond, left join with Scores table on score, keep score and rank id, then order by rank.\\n\\n```\\nSelect Scores.score as Score, rank.rankid as Rank\\nfrom\\nscores left join\\n(select @rowid := @rowid + 1 as rankid, temp1.score\\nfrom \\n    (select distinct score from scores order by score desc) as temp1, \\n    (select @rowid:=0) as temp2) as rank\\non Scores.score = rank.score\\norder by Rank\\n```",
                "solutionTags": [],
                "code": "```\\nSelect Scores.score as Score, rank.rankid as Rank\\nfrom\\nscores left join\\n(select @rowid := @rowid + 1 as rankid, temp1.score\\nfrom \\n    (select distinct score from scores order by score desc) as temp1, \\n    (select @rowid:=0) as temp2) as rank\\non Scores.score = rank.score\\norder by Rank\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53147,
                "title": "my-accepted-solution",
                "content": "# Write your MySQL query statement below\\nselect a.Score, count(b.Score) as Rank\\nfrom Scores as a, \\n    (select distinct Score\\n     from Scores) as b\\nwhere a.Score <= b.Score\\ngroup by a.ID\\norder by a.Score desc\\n;",
                "solutionTags": [],
                "code": "# Write your MySQL query statement below\\nselect a.Score, count(b.Score) as Rank\\nfrom Scores as a, \\n    (select distinct Score\\n     from Scores) as b\\nwhere a.Score <= b.Score\\ngroup by a.ID\\norder by a.Score desc\\n;",
                "codeTag": "Unknown"
            },
            {
                "id": 53151,
                "title": "solution-accepted-by-the-sqlfiddle-but-get-runtime-error-in-oj",
                "content": "[http://www.sqlfiddle.com/#!2/dc9b4d/3][1]\\n\\n\\n  [1]: http://www.sqlfiddle.com/#!2/dc9b4d/3",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3983443,
                "title": "extremely-simple-solution-in-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT s1.score, count(s2.score) AS \\'rank\\'\\nFROM scores s1, (SELECT DISTINCT score FROM scores) s2\\nWHERE s2.score>=s1.Score\\nGROUP BY s1.Id \\nORDER BY s1.score DESC;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s1.score, count(s2.score) AS \\'rank\\'\\nFROM scores s1, (SELECT DISTINCT score FROM scores) s2\\nWHERE s2.score>=s1.Score\\nGROUP BY s1.Id \\nORDER BY s1.score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931507,
                "title": "pandas-2-easy-and-different-ways-to-solve",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n**Method 1:**\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    \\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    \\n    rank = []\\n    max_score = 1e9\\n    curr_rank = 0\\n    \\n    for idx, row in df.iterrows():\\n        if row.score == max_score:\\n            rank.append(curr_rank)\\n        else:\\n            max_score = row.score\\n            curr_rank += 1\\n            rank.append(curr_rank)\\n            \\n    df[\\'rank\\'] = rank\\n    \\n    return df[[\\'score\\', \\'rank\\']]\\n```\\n\\n**Method 2:**\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    \\n    scores[\\'rank\\'] = scores[\\'score\\'].rank(method=\\'dense\\', ascending=False)\\n    \\n    return scores[[\\'score\\', \\'rank\\']].sort_values(by=\\'score\\', ascending=False)\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    \\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    \\n    rank = []\\n    max_score = 1e9\\n    curr_rank = 0\\n    \\n    for idx, row in df.iterrows():\\n        if row.score == max_score:\\n            rank.append(curr_rank)\\n        else:\\n            max_score = row.score\\n            curr_rank += 1\\n            rank.append(curr_rank)\\n            \\n    df[\\'rank\\'] = rank\\n    \\n    return df[[\\'score\\', \\'rank\\']]\\n```\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    \\n    scores[\\'rank\\'] = scores[\\'score\\'].rank(method=\\'dense\\', ascending=False)\\n    \\n    return scores[[\\'score\\', \\'rank\\']].sort_values(by=\\'score\\', ascending=False)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3678531,
                "title": "one-liner-solution-with-explanation",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe intuition behind the solution is to use the **dense_rank()** function to assign ranks to the scores in descending order, ensuring that higher scores receive lower ranks.\\n\\n\\n# Approach\\nTo solve the problem, we need to rank the scores in descending order and assign a rank to each score. Here\\'s how your SQL query accomplishes this:\\n\\n1. The SELECT statement is used to select the \"Score\" column from the \"Scores\" table. This retrieves all the scores from the table.\\n\\n1. The **DENSE_RANK() OVER (ORDER BY Score DESC)** function is used to calculate the rank of each score. The DENSE_RANK() function assigns the same rank to scores with the same value, and the ranks are determined based on the score values. The ORDER BY Score DESC part ensures that the scores are sorted in descending order before assigning the ranks.\\n\\n1. The result of the query includes both the \"Score\" and \"Rank\" columns. This means that for each score, you will see its corresponding rank in the output.\\n\\n1. The query handles the ranking and ordering of the scores for us, so we don\\'t need to manually implement any logic to determine the ranks. By using the **DENSE_RANK()** function, the query efficiently assigns ranks to the scores in descending order.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is dependent on the number of scores in the Scores table and the efficiency of the DENSE_RANK() function. The time complexity is typically $$O(n log n)$$ or better, as it involves sorting the scores.\\n\\n- Space complexity:\\nThe space complexity is determined by the size of the input data (the Scores table) and the storage required for the result set. In this case, the space complexity is $$O(n)$$, where n is the number of scores in the table.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank FROM Scores;\\n\\n```\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/d3db36f0-8de0-4f9d-96d2-b38b6d7bf201_1687639061.1030006.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank FROM Scores;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3534148,
                "title": "direct-by-using-dense-rank-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect Score as score , (dense_rank() over(order by Score desc)) as \"rank\" from Scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Score as score , (dense_rank() over(order by Score desc)) as \"rank\" from Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3171344,
                "title": "mysql-easy-approach",
                "content": "Here is my MYSQL code for this problem.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect score, dense_rank() over(order by score desc) as \"Rank\" from Scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect score, dense_rank() over(order by score desc) as \"Rank\" from Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2761644,
                "title": "simple-solution-two-approaches-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThanks for the question. I learned about Rank and Dense Rank functions in sql\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitially tried with the regular approach using subquery but came to know we can do quickly using rank function.\\n\\n\\n\\n\\n# Code\\n```\\n#Subquery\\nselect s1.score,(select count(distinct s2.score) from scores s2\\nwhere s2.score>=s1.score) \\'rank\\'\\nfrom scores s1\\norder by score desc\\n\\n#Functions\\nselect score, DENSE_RANK () OVER( Order by score desc ) \\'rank\\' \\nfrom scores \\norder by score desc\\n```\\n\\nPlease upvote if you find the solution useful :) Happy Learning!!",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n#Subquery\\nselect s1.score,(select count(distinct s2.score) from scores s2\\nwhere s2.score>=s1.score) \\'rank\\'\\nfrom scores s1\\norder by score desc\\n\\n#Functions\\nselect score, DENSE_RANK () OVER( Order by score desc ) \\'rank\\' \\nfrom scores \\norder by score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2581831,
                "title": "simple-solution-mysql",
                "content": "```\\nselect score, dense_rank() over(order by score desc) as \\'Rank\\' from Scores;\\n```",
                "solutionTags": [],
                "code": "```\\nselect score, dense_rank() over(order by score desc) as \\'Rank\\' from Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2567630,
                "title": "using-dense-rank-in-single-select",
                "content": "**Upvote if you feel it easy :)**\\n```\\nSELECT score, DENSE_RANK() OVER(ORDER BY score DESC) as Rank\\nFROM Scores\\nORDER BY score DESC;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT score, DENSE_RANK() OVER(ORDER BY score DESC) as Rank\\nFROM Scores\\nORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555084,
                "title": "mysql-two-apparoches",
                "content": "```\\n-- approach 1 \\n# SELECT score, DENSE_RANK() OVER (ORDER BY score desc) as \"rank\"\\n# FROM scores;\\n\\n\\n-- approach 2 \\nSELECT s1.score,\\n     (SELECT count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\"\\nFROM scores s1\\norder by s1.score desc;",
                "solutionTags": [],
                "code": "```\\n-- approach 1 \\n# SELECT score, DENSE_RANK() OVER (ORDER BY score desc) as \"rank\"\\n# FROM scores;\\n\\n\\n-- approach 2 \\nSELECT s1.score,\\n     (SELECT count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\"\\nFROM scores s1\\norder by s1.score desc;",
                "codeTag": "Unknown"
            },
            {
                "id": 2451783,
                "title": "solution-with-proper-explanation-easy-to-understand",
                "content": "**Please  Press the ^ Star above**\\n\\nThere is RANK() and DENSE_RANK()\\n\\nUnlike the RANK() function, the DENSE_RANK() function returns consecutive rank values. Rows in each partition receive the same ranks if they have the same values.\\n\\n```\\nSELECT score , DENSE_RANK() OVER(ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score , DENSE_RANK() OVER(ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2446634,
                "title": "mysql-using-dense-rank-100-fast-solution",
                "content": "Simple, Short, Fast\\n\\n```\\nSELECT score,  \\n       DENSE_RANK() OVER(ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```\\n\\nDo comment your suggestions!!",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score,  \\n       DENSE_RANK() OVER(ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2397131,
                "title": "sql-server-one-line-dense-rank-easy-understanding",
                "content": "\\tSELECT SCORE , DENSE_RANK() OVER (ORDER BY SCORE DESC) AS RANK FROM Scores",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tSELECT SCORE , DENSE_RANK() OVER (ORDER BY SCORE DESC) AS RANK FROM Scores",
                "codeTag": "Unknown"
            },
            {
                "id": 2203985,
                "title": "mysql-without-dense-rank-easy",
                "content": "```\\nselect s1.score, (select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\"\\nfrom scores s1 order by s1.score desc\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s1.score, (select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\"\\nfrom scores s1 order by s1.score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061067,
                "title": "simple-easy-mysql-solution-using-dense-rank",
                "content": "```\\nSELECT SCORE,\\nDENSE_RANK() OVER(ORDER BY SCORE DESC) AS \\'rank\\'\\nFROM SCORES;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT SCORE,\\nDENSE_RANK() OVER(ORDER BY SCORE DESC) AS \\'rank\\'\\nFROM SCORES;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2012104,
                "title": "ms-sql",
                "content": "Select A.score,B.rank FROM Scores A Inner JOIN \\n(Select score,ROW_NUMBER() OVER (ORDER BY score desc) as rank  FROM Scores A with(nolock) group by score ) B ON A.score = B.score\\norder by B.rank",
                "solutionTags": [],
                "code": "Select A.score,B.rank FROM Scores A Inner JOIN \\n(Select score,ROW_NUMBER() OVER (ORDER BY score desc) as rank  FROM Scores A with(nolock) group by score ) B ON A.score = B.score\\norder by B.rank",
                "codeTag": "Unknown"
            },
            {
                "id": 1974551,
                "title": "a-short-and-clean-solution-through-dense-rank",
                "content": "```\\nselect score, dense_rank() over (order by score desc) \\'rank\\'\\nfrom Scores\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect score, dense_rank() over (order by score desc) \\'rank\\'\\nfrom Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1971713,
                "title": "t-sql-3-ways-dense-rank-groupby-subquery",
                "content": "```\\n/* Write your T-SQL query statement below */\\n--select score, dense_rank() over (order by score desc) as rank from Scores order by 1 desc\\n--select score,  (select count(*) from (select distinct score from Scores) t where t.score>=s.score) rank from Scores s order by 1 desc\\nselect s.score, count(distinct t.score) as rank\\nfrom Scores s join Scores t on s.score<=t.score \\ngroup by s.id,s.score\\norder by 1 desc\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\n--select score, dense_rank() over (order by score desc) as rank from Scores order by 1 desc\\n--select score,  (select count(*) from (select distinct score from Scores) t where t.score>=s.score) rank from Scores s order by 1 desc\\nselect s.score, count(distinct t.score) as rank\\nfrom Scores s join Scores t on s.score<=t.score \\ngroup by s.id,s.score\\norder by 1 desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1860356,
                "title": "easy-to-understand-solution-no-window-function-no-subqueries",
                "content": "```\\nselect a.score , count(distinct b.score) rank\\nfrom scores a inner join scores b on b.score >= a.score\\ngroup by a.id , a.score \\norder by 2 asc\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect a.score , count(distinct b.score) rank\\nfrom scores a inner join scores b on b.score >= a.score\\ngroup by a.id , a.score \\norder by 2 asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1793653,
                "title": "easy-ms-sql-dense-rank",
                "content": "select score, dense_rank() over (order by score desc) as rank from Scores",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "select score, dense_rank() over (order by score desc) as rank from Scores",
                "codeTag": "Unknown"
            },
            {
                "id": 1659612,
                "title": "solution",
                "content": "select score, dense_rank() over (order by score desc) as rank from Scores order by rank",
                "solutionTags": [],
                "code": "select score, dense_rank() over (order by score desc) as rank from Scores order by rank",
                "codeTag": "Unknown"
            },
            {
                "id": 1611930,
                "title": "use-dense-rank-with-mysql-very-simple",
                "content": "```\\nSELECT\\n    score, DENSE_RANK() OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM\\n    Scores\\n;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    score, DENSE_RANK() OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM\\n    Scores\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1600162,
                "title": "short-simple-using-dense-rank-224ms",
                "content": "simple and short answer using dense_rank()\\n```\\nselect score, dense_rank() over (order by score desc ) \"rank\" from scores;\\n```",
                "solutionTags": [],
                "code": "```\\nselect score, dense_rank() over (order by score desc ) \"rank\" from scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1588386,
                "title": "very-easy-solution-using-window-function",
                "content": "SELECT score, DENSE_RANK() OVER (ORDER BY Score DESC) as \\'rank\\' FROM scores",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "SELECT score, DENSE_RANK() OVER (ORDER BY Score DESC) as \\'rank\\' FROM scores",
                "codeTag": "Unknown"
            },
            {
                "id": 1581489,
                "title": "3-lines-using-dense-rank-384ms",
                "content": "**** i don\\'t know why the answers provided by y\\'all are so complicated. So complicated that I don\\'t even understand. Here is a simple solution that works.\\n```\\nselect score, \\ndense_rank() over (order by score desc) \\'rank\\'\\nfrom Scores\\n```",
                "solutionTags": [],
                "code": "```\\nselect score, \\ndense_rank() over (order by score desc) \\'rank\\'\\nfrom Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1512713,
                "title": "ms-sql",
                "content": "#### Question\\n````\\nSQL Schema\\nTable: Scores\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| Id          | int     |\\n| Score       | decimal |\\n+-------------+---------+\\nId is the primary key for this table.\\nEach row of this table contains the score of a game. Score is a floating point value with two decimal places.\\n \\n\\nWrite an SQL query to rank the scores. The ranking should be calculated according to the following rules:\\n\\nThe scores should be ranked from the highest to the lowest.\\nIf there is a tie between two scores, both should have the same ranking.\\nAfter a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks.\\nReturn the result table ordered by score in descending order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nScores table:\\n+----+-------+\\n| Id | Score |\\n+----+-------+\\n| 1  | 3.50  |\\n| 2  | 3.65  |\\n| 3  | 4.00  |\\n| 4  | 3.85  |\\n| 5  | 4.00  |\\n| 6  | 3.65  |\\n+----+-------+\\nOutput: \\n+-------+------+\\n| Score | Rank |\\n+-------+------+\\n| 4.00  | 1    |\\n| 4.00  | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.50  | 4    |\\n+-------+------+\\n````\\n#### Answer\\n```\\nselect Score, dense_rank() over (order by Score desc) as Rank from Scores\\norder by Score desc\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "````\\nSQL Schema\\nTable: Scores\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| Id          | int     |\\n| Score       | decimal |\\n+-------------+---------+\\nId is the primary key for this table.\\nEach row of this table contains the score of a game. Score is a floating point value with two decimal places.\\n \\n\\nWrite an SQL query to rank the scores. The ranking should be calculated according to the following rules:\\n\\nThe scores should be ranked from the highest to the lowest.\\nIf there is a tie between two scores, both should have the same ranking.\\nAfter a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks.\\nReturn the result table ordered by score in descending order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nScores table:\\n+----+-------+\\n| Id | Score |\\n+----+-------+\\n| 1  | 3.50  |\\n| 2  | 3.65  |\\n| 3  | 4.00  |\\n| 4  | 3.85  |\\n| 5  | 4.00  |\\n| 6  | 3.65  |\\n+----+-------+\\nOutput: \\n+-------+------+\\n| Score | Rank |\\n+-------+------+\\n| 4.00  | 1    |\\n| 4.00  | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.50  | 4    |\\n+-------+------+\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1487318,
                "title": "without-dense-rank",
                "content": "```\\nSELECT s.score, l.rank \\nFROM scores s\\nLEFT JOIN (\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) AS rank \\n    FROM scores \\n    GROUP BY score\\n) l ON l.score=s.score\\nORDER BY s.score DESC;",
                "solutionTags": [],
                "code": "```\\nSELECT s.score, l.rank \\nFROM scores s\\nLEFT JOIN (\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) AS rank \\n    FROM scores \\n    GROUP BY score\\n) l ON l.score=s.score\\nORDER BY s.score DESC;",
                "codeTag": "Unknown"
            },
            {
                "id": 1423441,
                "title": "simple-dense-rank",
                "content": "select Score as score,\\n        dense_rank() over(order by Score desc) as \\'Rank\\'\\nfrom Scores\\norder by Score desc\\n",
                "solutionTags": [],
                "code": "select Score as score,\\n        dense_rank() over(order by Score desc) as \\'Rank\\'\\nfrom Scores\\norder by Score desc\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1383076,
                "title": "using-corelated-subqueries",
                "content": "```\\nSELECT score, (select count(distinct score) from scores s2 where s1.score<=s2.score ) AS \"Rank\"\\nFROM Scores s1 ORDER BY score DESC;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score, (select count(distinct score) from scores s2 where s1.score<=s2.score ) AS \"Rank\"\\nFROM Scores s1 ORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1362374,
                "title": "my-sql-sol-dense-rank",
                "content": "\\n\\n    select score , dense_rank() over(order by score desc) as `Rank`\\n    from scores",
                "solutionTags": [],
                "code": "\\n\\n    select score , dense_rank() over(order by score desc) as `Rank`\\n    from scores",
                "codeTag": "Unknown"
            },
            {
                "id": 1359601,
                "title": "steps-by-step-groupby-orderby-simple-and-crisp",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT S.Score, COUNT(S2.Score) as `Rank`\\nFROM Scores S,\\n(SELECT DISTINCT Score FROM Scores) S2\\nWHERE S.Score<=S2.Score\\nGROUP BY S.Id\\nORDER BY S.Score DESC;\\n\\n/*\\nSTEPS : \\n\\n1- create a new table s2 which contains all distinct salaries. ( LINE 3)\\n2- find the number of salaries which is >= entry created in step 1 ( LINE 4 )\\n3- group them on basis of id and sort them in desc order. (LINE 5-6)\\n4- Finally, display score and count of the score. ( Line 2 ).\\n*/",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT S.Score, COUNT(S2.Score) as `Rank`\\nFROM Scores S,\\n(SELECT DISTINCT Score FROM Scores) S2\\nWHERE S.Score<=S2.Score\\nGROUP BY S.Id\\nORDER BY S.Score DESC;\\n\\n/*\\nSTEPS : \\n\\n1- create a new table s2 which contains all distinct salaries. ( LINE 3)\\n2- find the number of salaries which is >= entry created in step 1 ( LINE 4 )\\n3- group them on basis of id and sort them in desc order. (LINE 5-6)\\n4- Finally, display score and count of the score. ( Line 2 ).\\n*/",
                "codeTag": "Unknown"
            },
            {
                "id": 1320960,
                "title": "join-286ms",
                "content": "\\n\\'\\'\\'\\nselect s1.Score, s2.Rank from Scores s1\\nleft join (\\n    select Score, row_number() over (order by Score desc) as \"Rank\" from Scores\\ngroup by Score) as s2 \\non s1.Score = s2.Score\\norder by s1.Score desc \\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'\\nselect s1.Score, s2.Rank from Scores s1\\nleft join (\\n    select Score, row_number() over (order by Score desc) as \"Rank\" from Scores\\ngroup by Score) as s2 \\non s1.Score = s2.Score\\norder by s1.Score desc \\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1217702,
                "title": "row-number-solution",
                "content": "```\\nselect s.Score, srn.rn as \\'rank\\'\\nfrom Scores s left join (select a.Score, row_number() over (order by a.Score desc) as rn\\n                         from (select distinct Score from Scores) a) srn\\non s.Score = srn.Score\\norder by Score desc\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect s.Score, srn.rn as \\'rank\\'\\nfrom Scores s left join (select a.Score, row_number() over (order by a.Score desc) as rn\\n                         from (select distinct Score from Scores) a) srn\\non s.Score = srn.Score\\norder by Score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1158391,
                "title": "easy-2-line-solution-mysql",
                "content": "Select score, Dense_Rank() OVER(order by score DESC) as \\'Rank\\'\\nfrom Scores\\n",
                "solutionTags": [],
                "code": "Select score, Dense_Rank() OVER(order by score DESC) as \\'Rank\\'\\nfrom Scores\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1132103,
                "title": "mysql-subquery-and-inner-join-where-in",
                "content": "```\\nSELECT s.Score, rnk.Rank\\nFROM Scores s, (SELECT *, ROW_NUMBER() OVER (ORDER BY Score DESC) AS \\'Rank\\' FROM (SELECT DISTINCT Score FROM Scores) AS r2) AS rnk \\nWHERE s.Score=rnk.Score\\nORDER BY rnk.Rank ASC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT s.Score, rnk.Rank\\nFROM Scores s, (SELECT *, ROW_NUMBER() OVER (ORDER BY Score DESC) AS \\'Rank\\' FROM (SELECT DISTINCT Score FROM Scores) AS r2) AS rnk \\nWHERE s.Score=rnk.Score\\nORDER BY rnk.Rank ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1095407,
                "title": "mysql-single-line",
                "content": "SELECT Score,  DENSE_RANK ()  OVER( ORDER BY Score desc) AS \\'Rank\\'\\nFROM Scores\\n",
                "solutionTags": [],
                "code": "SELECT Score,  DENSE_RANK ()  OVER( ORDER BY Score desc) AS \\'Rank\\'\\nFROM Scores\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1075937,
                "title": "simple-solution",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT score,\\nDENSE_RANK() OVER(ORDER BY score DESC) AS \\'Rank\\'\\nFROM Scores\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT score,\\nDENSE_RANK() OVER(ORDER BY score DESC) AS \\'Rank\\'\\nFROM Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1037049,
                "title": "easy-solution-only-use-rank-faster-than-96-memory-less-than-100",
                "content": "The difference in using between **dense_rank** or **rank** is that, the former one would consider the tied numbers only will take one position in the rank, while the later one would consider the tied numbers will take consecutive potitions in the rank, which will leave holes in the rank.\\n\\nEasy to understood coding part:\\n\\n```\\nselect score, dense_rank() over(order by score desc) as Rank\\nfrom scores\\norder by 1 desc\\n```\\nThis is the reference link for SQL RANK functions, very helpful:\\nhttps://www.sqlshack.com/overview-of-sql-rank-functions/",
                "solutionTags": [],
                "code": "```\\nselect score, dense_rank() over(order by score desc) as Rank\\nfrom scores\\norder by 1 desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1023926,
                "title": "dense-rank",
                "content": "```\\nSELECT\\n    score,\\n    DENSE_RANK() OVER(ORDER BY score DESC) AS \"rank\"\\nFROM\\n    scores\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    score,\\n    DENSE_RANK() OVER(ORDER BY score DESC) AS \"rank\"\\nFROM\\n    scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820791,
                "title": "simple-mysql-solution",
                "content": "```\\nselect score, dense_rank() over(order by score desc) \\'Rank\\' from scores\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect score, dense_rank() over(order by score desc) \\'Rank\\' from scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 792226,
                "title": "360-ms-simple-solution",
                "content": "```\\nselect Score, \\n    (select count(s2.Score) \\n     from (select distinct Score from Scores) s2 \\n     where s2.Score >= s1.Score\\n    ) \\'Rank\\'\\nfrom Scores s1 \\norder by Score desc;",
                "solutionTags": [],
                "code": "```\\nselect Score, \\n    (select count(s2.Score) \\n     from (select distinct Score from Scores) s2 \\n     where s2.Score >= s1.Score\\n    ) \\'Rank\\'\\nfrom Scores s1 \\norder by Score desc;",
                "codeTag": "Unknown"
            },
            {
                "id": 759504,
                "title": "using-row-number",
                "content": "```\\n\\nSELECT d.score, e.rank FROM scores d INNER JOIN\\n(SELECT e.score, ROW_NUMBER() OVER( ORDER BY score DESC) `rank` \\nFROM (SELECT DISTINCT score FROM scores) e) e \\nON d.score=e.score\\nORDER BY d.score DESC;\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSELECT d.score, e.rank FROM scores d INNER JOIN\\n(SELECT e.score, ROW_NUMBER() OVER( ORDER BY score DESC) `rank` \\nFROM (SELECT DISTINCT score FROM scores) e) e \\nON d.score=e.score\\nORDER BY d.score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751692,
                "title": "with-out-dense-rank",
                "content": "```\\nselect a.score,count(distinct b.score) as \\'rank\\'\\nfrom scores a, scores b\\nwhere a.score<=b.score\\ngroup by a.id\\norder by 2\\n```",
                "solutionTags": [],
                "code": "```\\nselect a.score,count(distinct b.score) as \\'rank\\'\\nfrom scores a, scores b\\nwhere a.score<=b.score\\ngroup by a.id\\norder by 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 629140,
                "title": "easy-to-understand-mysql-with-explanation",
                "content": "First, we need 2 tables: The original table and another table where we only have distinct scores\\nTable A: `SELECT A.id, A.score FROM Scores A`\\nTable B: `SELECT DISTINCT(score) as score FROM Scores B`\\n\\nThen we JOIN both the tables where the scores from Table A <= Table B:\\n```\\nSELECT A.id, A.score, B.score\\nFROM Scores A JOIN (SELECT DISTINCT(score) as score FROM Scores) B ON A.score<=B.score\\nORDER BY A.id, A.score DESC, B.score ASC\\n```\\nThe trick here is where A.score <= B.score.\\n\\nNow, we GROUP BY A.id, COUNT B.score and lastly order A.score in descending order.\\n```\\nSELECT A.score as Score, COUNT(B.score) as \\'Rank\\'\\nFROM Scores A JOIN (SELECT DISTINCT(score) as score FROM Scores) B ON A.score<=B.score\\nGROUP BY A.id\\nORDER BY A.score DESC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT A.id, A.score, B.score\\nFROM Scores A JOIN (SELECT DISTINCT(score) as score FROM Scores) B ON A.score<=B.score\\nORDER BY A.id, A.score DESC, B.score ASC\\n```\n```\\nSELECT A.score as Score, COUNT(B.score) as \\'Rank\\'\\nFROM Scores A JOIN (SELECT DISTINCT(score) as score FROM Scores) B ON A.score<=B.score\\nGROUP BY A.id\\nORDER BY A.score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 619623,
                "title": "mysql-using-subquery",
                "content": "```\\nSELECT \\n    score,\\n    (SELECT COUNT(DISTINCT score) FROM scores WHERE score > s.score) + 1 AS \\'Rank\\'\\nFROM Scores s\\nORDER BY score DESC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    score,\\n    (SELECT COUNT(DISTINCT score) FROM scores WHERE score > s.score) + 1 AS \\'Rank\\'\\nFROM Scores s\\nORDER BY score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508386,
                "title": "non-dense-rank-solution",
                "content": "\\n```\\nselect Score,\\n    (select COUNT(DISTINCT S2.Score)\\n    from Scores as S2\\n    where S2.Score > S1.Score) +1  as Rank\\nfrom Scores as S1\\norder by Rank\\n```",
                "solutionTags": [],
                "code": "```\\nselect Score,\\n    (select COUNT(DISTINCT S2.Score)\\n    from Scores as S2\\n    where S2.Score > S1.Score) +1  as Rank\\nfrom Scores as S1\\norder by Rank\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 501553,
                "title": "dense-rank",
                "content": "SELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\n    FROM Scores \\n    ORDER BY Score DESC",
                "solutionTags": [],
                "code": "SELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\n    FROM Scores \\n    ORDER BY Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 491921,
                "title": "solution-use-dense-rank-not-rank",
                "content": "```\\nSELECT\\n        Score,\\n        dense_rank() OVER (ORDER BY SCORE DESC) AS Rank\\nfrom Scores\\n```\\n\\nYou want to use `dense_rank()` instead of `rank()` because using `rank()` does not account for ties.\\n\\n![image](https://assets.leetcode.com/users/mahnillas/image_1580162909.png)\\n",
                "solutionTags": [],
                "code": "```\\nSELECT\\n        Score,\\n        dense_rank() OVER (ORDER BY SCORE DESC) AS Rank\\nfrom Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 386393,
                "title": "let-s-just-use-dense-rank-and-call-it-a-day",
                "content": "Hello All!\\nHere\\'s a solution via Dense_Rank():\\n```\\nSELECT\\nScore as Score,\\ndense_rank() over(order by Score desc) as Rank\\nFROM Scores\\nORDER BY 2;\\n```\\nPS. I used MS SQL Server for this one.\\n\\nCheers,\\nGeorge John Jordan Thomas Aquinas Hayward, Optimist <br>\\nhttps://ghayward.github.io\\n\\n[![GJJTAHO](https://i.ibb.co/wBjBb4G/gjjtah.jpg)](https://ghayward.github.io)\\n\\nThe Lord Always Delivers",
                "solutionTags": [],
                "code": "```\\nSELECT\\nScore as Score,\\ndense_rank() over(order by Score desc) as Rank\\nFROM Scores\\nORDER BY 2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 370393,
                "title": "ms-sql-with-and-without-dense-rank",
                "content": "```\\n\\nselect a.score,\\n        count(distinct b.score)AS rank\\n from Scores a\\n  inner join scores b\\n  on a.score<=b.score\\n group by a.id,a.score\\n order by score desc\\n\\n--with dense rank\\nselect \\n    Score,\\n    dense_rank() over (order by score desc) As Rank\\nfrom Scores\\norder by score desc\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "```\\n\\nselect a.score,\\n        count(distinct b.score)AS rank\\n from Scores a\\n  inner join scores b\\n  on a.score<=b.score\\n group by a.id,a.score\\n order by score desc\\n\\n--with dense rank\\nselect \\n    Score,\\n    dense_rank() over (order by score desc) As Rank\\nfrom Scores\\norder by score desc\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 331532,
                "title": "3-lines-easy-solution",
                "content": "```\\nSELECT Score,DENSE_RANK () OVER (ORDER BY Score DESC) AS Rank\\n  FROM Scores\\n ORDER BY Score DESC;",
                "solutionTags": [],
                "code": "```\\nSELECT Score,DENSE_RANK () OVER (ORDER BY Score DESC) AS Rank\\n  FROM Scores\\n ORDER BY Score DESC;",
                "codeTag": "Unknown"
            },
            {
                "id": 255124,
                "title": "easy-to-understand",
                "content": "```\\nSELECT Score, (\\n    SELECT COUNT(DISTINCT Score)\\n    FROM Scores\\n    WHERE Score >= s.Score\\n) as Rank\\nFROM Scores s\\nORDER BY Score desc\\n```\\n",
                "solutionTags": [],
                "code": "```\\nSELECT Score, (\\n    SELECT COUNT(DISTINCT Score)\\n    FROM Scores\\n    WHERE Score >= s.Score\\n) as Rank\\nFROM Scores s\\nORDER BY Score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 203972,
                "title": "using-dense-rank",
                "content": "Elegant solution that works in all modern normal systems:\\n```\\nselect Score, \\ndense_rank() over (partition by Id order by Score) as Rank\\nfrom Scores\\n```",
                "solutionTags": [],
                "code": "```\\nselect Score, \\ndense_rank() over (partition by Id order by Score) as Rank\\nfrom Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181899,
                "title": "ac-mysql-solution",
                "content": "First, we need a table which includes scores and the rank of the score.\\n```\\nSELECT Score, (SELECT COUNT(DISTINCT Score)  AS rank\\nFROM Scores\\nWHERE Score >= S1.Score) AS Rank\\nFROM Scores AS S1\\norder by Score desc\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Score, (SELECT COUNT(DISTINCT Score)  AS rank\\nFROM Scores\\nWHERE Score >= S1.Score) AS Rank\\nFROM Scores AS S1\\norder by Score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 179378,
                "title": "my-solution-is-75-ms",
                "content": "```\\nSELECT Score, \\n    (\\n        SELECT COUNT(DISTINCT b.Score) + 1 \\n        FROM Scores AS b \\n        WHERE b.Score > Scores.Score \\n        LIMIT 1\\n    ) AS Rank \\nFROM Scores order by Rank ;",
                "solutionTags": [],
                "code": "```\\nSELECT Score, \\n    (\\n        SELECT COUNT(DISTINCT b.Score) + 1 \\n        FROM Scores AS b \\n        WHERE b.Score > Scores.Score \\n        LIMIT 1\\n    ) AS Rank \\nFROM Scores order by Rank ;",
                "codeTag": "Unknown"
            },
            {
                "id": 172094,
                "title": "oracle-using-dense-rank",
                "content": "worked with Oracle. I just needed to round the decimal part of scores to 2\\n```select ROUND(sc.Score,2) Score, dense_rank() over (order by Score desc) Rank from Scores sc```",
                "solutionTags": [],
                "code": "```select ROUND(sc.Score,2) Score, dense_rank() over (order by Score desc) Rank from Scores sc```",
                "codeTag": "Unknown"
            },
            {
                "id": 136900,
                "title": "simple-approach",
                "content": "The following is an accepted and simple solution to the problem: \\n\\n1. Get a table of distinct scores ordered from highest to lowest. \\n2. Add a serial colum to the table from step 1, the values of the new column are incremented starting from zero and going down.\\n3. Merge the table from step 2 with the Scores table.\\n\\nExecution time < 200 ms. \\n\\n```\\nSELECT      Scores.Score, Rank \\nFROM        Scores \\nLEFT JOIN   (                                       -- Last: Join with original scores table on the score value.\\n                SELECT  Score, @a:=@a+1 Rank        -- Second: Add column of serial values starting from 1 to the ordered scores.\\n                FROM    (                           -- First: Get table of distinct scores ordered from highest to lowers.\\n                            SELECT DISTINCT Score\\n                            FROM Scores\\n                            ORDER BY Score DESC\\n                        ) AS orderedScores, (SELECT @a:= 0) AS a\\n            ) AS rankedScores ON (rankedScores.Score = Scores.Score)\\nORDER BY    Scores.Score DESC\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nSELECT      Scores.Score, Rank \\nFROM        Scores \\nLEFT JOIN   (                                       -- Last: Join with original scores table on the score value.\\n                SELECT  Score, @a:=@a+1 Rank        -- Second: Add column of serial values starting from 1 to the ordered scores.\\n                FROM    (                           -- First: Get table of distinct scores ordered from highest to lowers.\\n                            SELECT DISTINCT Score\\n                            FROM Scores\\n                            ORDER BY Score DESC\\n                        ) AS orderedScores, (SELECT @a:= 0) AS a\\n            ) AS rankedScores ON (rankedScores.Score = Scores.Score)\\nORDER BY    Scores.Score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 117265,
                "title": "dense-rank-throwing-error",
                "content": "```SELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank FROM Scores ORDER BY Score DESC; ```\n\nTrying to use Dense Rank function but keep getting this error - \"Line 1: SyntaxError: near '(ORDER BY Score DESC) AS Rank FROM Scores ORDER BY Score DESC\". Although the query works fine in sql server.",
                "solutionTags": [],
                "code": "```SELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank FROM Scores ORDER BY Score DESC; ```",
                "codeTag": "Unknown"
            },
            {
                "id": 3860654,
                "title": "pandas-dense-rank",
                "content": "```\\nimport pandas as pd\\n\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    scores[\\'rank\\'] = (\\n        scores\\n        .score\\n        .rank(method=\\'dense\\', ascending=False)\\n        .astype(int)\\n    )\\n\\n    scores.sort_values(\\'score\\', inplace=True, ascending=False)\\n\\n    return scores[[\\'score\\', \\'rank\\']]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    scores[\\'rank\\'] = (\\n        scores\\n        .score\\n        .rank(method=\\'dense\\', ascending=False)\\n        .astype(int)\\n    )\\n\\n    scores.sort_values(\\'score\\', inplace=True, ascending=False)\\n\\n    return scores[[\\'score\\', \\'rank\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3629436,
                "title": "178-rank-scores-java",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT s1.Score , \\n(SELECT COUNT(DISTINCT score) from Scores s2 where s1.score<=s2.score) as `Rank`\\nfrom Scores s1\\norder by s1.score desc;\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s1.Score , \\n(SELECT COUNT(DISTINCT score) from Scores s2 where s1.score<=s2.score) as `Rank`\\nfrom Scores s1\\norder by s1.score desc;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3245773,
                "title": "using-different-types-of-window-functions",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\n    SELECT score,\\n    DENSE_RANK() OVER(ORDER BY score DESC) AS \\'rank\\'\\n    FROM Scores\\n```\\n# DENSE_RANK()\\nDENSE_RANK() is a window function in SQL that is used to calculate the rank of each row within a result set. It works similarly to the RANK() function, but unlike RANK(), DENSE_RANK() doesn\\'t leave gaps between the ranks when there are ties.\\n\\nHere\\'s an example to illustrate the difference between RANK() and DENSE_RANK(). Suppose we have the following table:\\n\\n```\\n+------+-------+\\n| id   | score |\\n+------+-------+\\n| 1    | 90    |\\n| 2    | 85    |\\n| 3    | 80    |\\n| 4    | 80    |\\n| 5    | 75    |\\n+------+-------+\\n```\\nIf we use RANK() to calculate the ranks of the scores, we get the following:\\n\\n```\\nSELECT score, RANK() OVER (ORDER BY score DESC) AS \\'rank\\' FROM Scores;\\n```\\n\\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 90    | 1    |\\n| 85    | 2    |\\n| 80    | 3    |\\n| 80    | 3    |\\n| 75    | 5    |\\n+-------+------+\\n```\\nAs you can see, there is a gap between ranks 2 and 3 because there is a tie between scores 80 and 80.\\n\\nIf we use DENSE_RANK() instead, we get the following:\\n\\n\\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) AS \\'rank\\' FROM Scores;\\n```\\n\\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 90    | 1    |\\n| 85    | 2    |\\n| 80    | 3    |\\n| 80    | 3    |\\n| 75    | 4    |\\n+-------+------+\\n```\\nAs you can see, DENSE_RANK() assigns the same rank to the tied scores (80 and 80) and doesn\\'t leave any gaps between ranks.\\n\\nIn summary, DENSE_RANK() is a window function that calculates the rank of each row in a result set, but doesn\\'t leave gaps between the ranks when there are ties.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n    SELECT score,\\n    DENSE_RANK() OVER(ORDER BY score DESC) AS \\'rank\\'\\n    FROM Scores\\n```\n```\\n+------+-------+\\n| id   | score |\\n+------+-------+\\n| 1    | 90    |\\n| 2    | 85    |\\n| 3    | 80    |\\n| 4    | 80    |\\n| 5    | 75    |\\n+------+-------+\\n```\n```\\nSELECT score, RANK() OVER (ORDER BY score DESC) AS \\'rank\\' FROM Scores;\\n```\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 90    | 1    |\\n| 85    | 2    |\\n| 80    | 3    |\\n| 80    | 3    |\\n| 75    | 5    |\\n+-------+------+\\n```\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) AS \\'rank\\' FROM Scores;\\n```\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 90    | 1    |\\n| 85    | 2    |\\n| 80    | 3    |\\n| 80    | 3    |\\n| 75    | 4    |\\n+-------+------+\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2751622,
                "title": "dense-rank-solution",
                "content": "SELECT score, DENSE_RANK() OVER(ORDER BY score DESC) \"rank\"\\nFROM scores\\nORDER BY score DESC\\n\\nHere we just have to mention the rank in the \"\" as the rank word is a keyword and cannot be used as a identifier in MySQL. so to explicitly use it as an identifier we have to mention it in \"\".",
                "solutionTags": [],
                "code": "SELECT score, DENSE_RANK() OVER(ORDER BY score DESC) \"rank\"\\nFROM scores\\nORDER BY score DESC\\n\\nHere we just have to mention the rank in the \"\" as the rank word is a keyword and cannot be used as a identifier in MySQL. so to explicitly use it as an identifier we have to mention it in \"\".",
                "codeTag": "Unknown"
            },
            {
                "id": 2718259,
                "title": "mysql-ranking-functions-implementation-and-explanation",
                "content": "### Ranking functions in MySQL\\n\\n```\\nSELECT score, dense_rank() OVER (\\n                ORDER BY score DESC\\n            ) AS \\'rank\\'\\nFROM Scores;\\n```\\n\\n***REFERENCE***\\n[https://www.sqlshack.com/overview-of-sql-rank-functions/](http://)\\n***about ROWNUMBER(), RANK(), denserank(), NTILE(N)\\n\\nWe use DENSERANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\n\\nIn the SQL RANK function DENSERANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nLet\\u2019s execute the following query with the DENSERANK() function.\\n```\\nSELECT Studentname, \\n       Subject, \\n       Marks, \\n       DENSERANK() OVER(ORDER BY Marks DESC) Rank\\nFROM ExamResult\\nORDER BY Rank;\\n```\\nIn the output, you can see we have the same rank for both Lily and Isabella who scored 70 marks.***\\n\\n![image](https://assets.leetcode.com/users/images/8a8c58ed-64ee-40a5-b59a-efd8a59576d6_1666098734.50629.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score, dense_rank() OVER (\\n                ORDER BY score DESC\\n            ) AS \\'rank\\'\\nFROM Scores;\\n```\n```\\nSELECT Studentname, \\n       Subject, \\n       Marks, \\n       DENSERANK() OVER(ORDER BY Marks DESC) Rank\\nFROM ExamResult\\nORDER BY Rank;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2639499,
                "title": "faster-easy-to-understand-dense-rank",
                "content": "* ***Using dense_rank()***\\n\\n```\\nselect score,\\ndense_rank() over(order by score desc) as \\'rank\\'\\nfrom Scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect score,\\ndense_rank() over(order by score desc) as \\'rank\\'\\nfrom Scores;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570638,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567130,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567547,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1570938,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567402,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1569773,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1568565,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1568567,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567902,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1570217,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1570638,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567130,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567547,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1570938,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567402,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1569773,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1568565,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1568567,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567902,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1570217,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1569713,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1569526,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1729657,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576958,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576930,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576917,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576809,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576503,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576418,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576323,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1575483,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1575471,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1574629,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1574578,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1574096,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1574066,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1573703,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1576441,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1573457,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1573167,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1573163,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1572465,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1572400,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1572317,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1572085,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1570731,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1575671,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1573030,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 2045169,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 2036550,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 2030245,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 2012878,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1937632,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1921264,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1880387,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1812246,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1811065,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1787452,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1774146,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1773269,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1773252,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1766060,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1752287,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1751074,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1745965,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1741770,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1722521,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1716289,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1575697,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1576399,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            }
        ]
    },
    {
        "title": "First Bad Version",
        "question_content": "<p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>\n\n<p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p>\n\n<p>You are given an API <code>bool isBadVersion(version)</code> which returns whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5, bad = 4\n<strong>Output:</strong> 4\n<strong>Explanation:</strong>\ncall isBadVersion(3) -&gt; false\ncall isBadVersion(5)&nbsp;-&gt; true\ncall isBadVersion(4)&nbsp;-&gt; true\nThen 4 is the first bad version.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, bad = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bad &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 71311,
                "title": "a-good-warning-to-me-to-use-start-end-start-2-to-avoid-overflow",
                "content": "Before this problem, I have always use\\n\\n      mid = (start+end)) / 2;\\n\\nTo get the middle value, but this can caused OVERFLOW ! \\n\\nwhen start and end are all about INT_MAX , then (start+end) of course will be overflow !\\n\\nTo avoid the problem we can use\\n       \\n      mid =  start+(end-start)/2;\\n\\nHere is the AC implementation \\n\\n// Forward declaration of isBadVersion API.\\nbool isBadVersion(int version);\\n\\n    class Solution {\\n    public:\\n        int firstBadVersion(int n) {\\n            int start=0, end=n;\\n            cout<<end-start<<end;\\n            while(end-start>1){\\n                int mid=start+(end-start)/2;\\n                /** mid = (start+end)) / 2; **/\\n                if(isBadVersion(mid))  end=mid;\\n                else  start=mid;\\n            }\\n            return end;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int firstBadVersion(int n) {\\n            int start=0, end=n;\\n            cout<<end-start<<end;\\n            while(end-start>1){\\n                int mid=start+(end-start)/2;\\n                /** mid = (start+end)) / 2; **/\\n                if(isBadVersion(mid))  end=mid;\\n                else  start=mid;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 71296,
                "title": "o-lgn-simple-java-solution",
                "content": "**The binary search code:**\\n\\n\\tpublic int firstBadVersion(int n) {\\n\\t    int start = 1, end = n;\\n\\t    while (start < end) {\\n\\t        int mid = start + (end-start) / 2;\\n\\t        if (!isBadVersion(mid)) start = mid + 1;\\n\\t        else end = mid;            \\n\\t    }        \\n\\t    return start;\\n\\t}",
                "solutionTags": [],
                "code": "**The binary search code:**\\n\\n\\tpublic int firstBadVersion(int n) {\\n\\t    int start = 1, end = n;\\n\\t    while (start < end) {\\n\\t        int mid = start + (end-start) / 2;\\n\\t        if (!isBadVersion(mid)) start = mid + 1;\\n\\t        else end = mid;            \\n\\t    }        \\n\\t    return start;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 71366,
                "title": "python-simple-2-lines-solution",
                "content": "    import bisect\\n    class Solution():\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        self.__getitem__ = isBadVersion\\n        return bisect.bisect_left(self, True, 1, n)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    import bisect\\n    class Solution():\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        self.__getitem__ = isBadVersion\\n        return bisect.bisect_left(self, True, 1, n)",
                "codeTag": "Java"
            },
            {
                "id": 606080,
                "title": "java-binary-search-clean-code-o-logn",
                "content": "```java\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int left = 1, right = n, ans = -1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2; // to avoid overflow incase (left+right)>2147483647\\n            if (isBadVersion(mid)) {\\n                ans = mid; // record mid as current answer\\n                right = mid - 1; // try to find smaller version in the left side\\n            } else {\\n                left = mid + 1; // try to find in the right side\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(logN)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```java\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int left = 1, right = n, ans = -1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2; // to avoid overflow incase (left+right)>2147483647\\n            if (isBadVersion(mid)) {\\n                ans = mid; // record mid as current answer\\n                right = mid - 1; // try to find smaller version in the left side\\n            } else {\\n                left = mid + 1; // try to find in the right side\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71312,
                "title": "short-c-answer-and-minimize-api-calls",
                "content": "    class Solution {\\n    public:\\n        int firstBadVersion(int n) {\\n            int lower = 1, upper = n, mid;\\n            while(lower < upper) {\\n                mid = lower + (upper - lower) / 2;\\n                if(!isBadVersion(mid)) lower = mid + 1;   /* Only one call to API */\\n                else upper = mid;\\n            }\\n            return lower;   /* Because there will alway be a bad version, return lower here */\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int firstBadVersion(int n) {\\n            int lower = 1, upper = n, mid;\\n            while(lower < upper) {\\n                mid = lower + (upper - lower) / 2;\\n                if(!isBadVersion(mid)) lower = mid + 1;   /* Only one call to API */\\n                else upper = mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71324,
                "title": "python-understand-easily-from-binary-search-idea",
                "content": "    class Solution(object):\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        r = n-1\\n        l = 0\\n        while(l<=r):\\n            mid = l + (r-l)/2\\n            if isBadVersion(mid)==False:\\n                l = mid+1\\n            else:\\n                r = mid-1\\n        return l",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        r = n-1\\n        l = 0\\n        while(l<=r):\\n            mid = l + (r-l)/2\\n            if isBadVersion(mid)==False:\\n                l = mid+1\\n            else:\\n                r = mid-1\\n        return l",
                "codeTag": "Java"
            },
            {
                "id": 3112480,
                "title": "easy-solution-in-java",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a binary search algorithm to find the first bad version of a software.\\n\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n\\n    public int firstBadVersion(int n) {\\n        int low = 0;\\n        int high = n;\\n\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(isBadVersion(mid)==true && isBadVersion(mid-1)==false)   return mid;\\n            else if(isBadVersion(mid)==false ) low = mid+1;\\n            else high= mid;\\n        }     \\n        return -1;\\n    }\\n}\\n```\\n### If you like the solution then please upvote me it gives me encouragement to do more...........",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n\\n    public int firstBadVersion(int n) {\\n        int low = 0;\\n        int high = n;\\n\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(isBadVersion(mid)==true && isBadVersion(mid-1)==false)   return mid;\\n            else if(isBadVersion(mid)==false ) low = mid+1;\\n            else high= mid;\\n        }     \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71386,
                "title": "an-clear-way-to-use-binary-search",
                "content": "It is obvious that the version would looks like the following:\\nFFTTTT (The first two are correct version, the rest are bad ones)\\nSo we can use binary search to find the rightmost F or the leftmost T\\n\\nTo find the leftmost T\\n\\n    public int firstBadVersionLeft(int n) {\\n\\t\\tint i = 1;\\n\\t\\tint j = n;\\n\\n\\t\\twhile (i < j) {\\n\\n\\t\\t\\tint mid = i + (j - i) / 2;\\n\\n\\t\\t\\tif (isBadVersion(mid)) {\\n\\t\\t\\t\\tj = mid;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti = mid + 1;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn i;\\n\\n\\t}\\n\\nTo find the right most F we need to notice that since we are looking for the first bad version not the last correct version, we need to return the (position when the binary search stop) + 1\\n\\n    public int firstBadVersion(int n) {\\n\\n\\t\\tif (isBadVersion(1)) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tint i = 1;\\n\\t\\tint j = n;\\n\\n\\t\\twhile (i < j) {\\n\\t\\t\\tint mid = i + (j - i) / 2 + 1;\\n\\t\\t\\tif (!isBadVersion(mid)) {\\n\\t\\t\\t\\ti = mid;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tj = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn j + 1;\\n\\n\\t}\\n\\nBTW, understanding how to use binary search to find the most left target or the most right target (when the target is duplicated) is very useful to solve binary search related problems. =)",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "It is obvious that the version would looks like the following:\\nFFTTTT (The first two are correct version, the rest are bad ones)\\nSo we can use binary search to find the rightmost F or the leftmost T\\n\\nTo find the leftmost T\\n\\n    public int firstBadVersionLeft(int n) {\\n\\t\\tint i = 1;\\n\\t\\tint j = n;\\n\\n\\t\\twhile (i < j) {\\n\\n\\t\\t\\tint mid = i + (j - i) / 2;\\n\\n\\t\\t\\tif (isBadVersion(mid)) {\\n\\t\\t\\t\\tj = mid;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti = mid + 1;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn i;\\n\\n\\t}\\n\\nTo find the right most F we need to notice that since we are looking for the first bad version not the last correct version, we need to return the (position when the binary search stop) + 1\\n\\n    public int firstBadVersion(int n) {\\n\\n\\t\\tif (isBadVersion(1)) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tint i = 1;\\n\\t\\tint j = n;\\n\\n\\t\\twhile (i < j) {\\n\\t\\t\\tint mid = i + (j - i) / 2 + 1;\\n\\t\\t\\tif (!isBadVersion(mid)) {\\n\\t\\t\\t\\ti = mid;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tj = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn j + 1;\\n\\n\\t}\\n\\nBTW, understanding how to use binary search to find the most left target or the most right target (when the target is duplicated) is very useful to solve binary search related problems. =)",
                "codeTag": "Unknown"
            },
            {
                "id": 1591935,
                "title": "python-solution-easy-to-understand-binary-search-with-detailed-explanation",
                "content": "### Solution\\n```\\ndef firstBadVersion(self, n):\\n        i = 1\\n        j = n\\n        while (i < j):\\n            pivot = (i+j) // 2\\n            if (isBadVersion(pivot)):\\n                j = pivot       # keep track of the leftmost bad version\\n            else:\\n                i = pivot + 1   # the one after the rightmost good version\\n        return i\\n```\\n\\n### Remarks\\n* We use` i = 1` instead of `0` as base case because there\\'s no index operation involved and the product version starts from 1.\\n* We use `j` to keep track of the leftmost bad version we have checked, so that any version after` j `would not be the first bad version we want.\\n* We use `i `to keep track of the leftmost unknown version which has a good version before it, so that any version before` i` would be a good version.\\n* Therefore, `i` would move towards `j` step by step and stop when it becomes the first bad version.\\n\\n****Please upvote if you find this post useful, and welcome to any further discussion!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef firstBadVersion(self, n):\\n        i = 1\\n        j = n\\n        while (i < j):\\n            pivot = (i+j) // 2\\n            if (isBadVersion(pivot)):\\n                j = pivot       # keep track of the leftmost bad version\\n            else:\\n                i = pivot + 1   # the one after the rightmost good version\\n        return i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 71333,
                "title": "1-liner-in-ruby-python",
                "content": "**Python 3.10+**\\n\\nWoohoo, `bisect` has a `key` parameter now. So:\\n\\n    def firstBadVersion(self, n: int) -> int:\\n        return bisect_left(range(n), True, 1, key=isBadVersion)\\n\\n---\\n\\n**Ruby**\\n\\n    def first_bad_version(n)\\n      (1..n).bsearch { |i| is_bad_version(i) }\\n    end\\n\\nOr:\\n\\n    def first_bad_version(n)\\n      (1..n).bsearch(&method(:is_bad_version))\\n    end\\n\\n---\\n\\n**Python**\\n\\nIn Python I was only able to do it with a rather ugly wrapper:\\n\\n    def firstBadVersion(self, n):\\n        return bisect.bisect(type(\\'\\', (), {\\'__getitem__\\': lambda self, i: isBadVersion(i)})(), False, 0, n)\\n\\nNicer, more readable version:\\n\\n    def firstBadVersion(self, n):\\n        class Wrap:\\n            def __getitem__(self, i):\\n                return isBadVersion(i)\\n        return bisect.bisect(Wrap(), False, 0, n)",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "**Python 3.10+**\\n\\nWoohoo, `bisect` has a `key` parameter now. So:\\n\\n    def firstBadVersion(self, n: int) -> int:\\n        return bisect_left(range(n), True, 1, key=isBadVersion)\\n\\n---\\n\\n**Ruby**\\n\\n    def first_bad_version(n)\\n      (1..n).bsearch { |i| is_bad_version(i) }\\n    end\\n\\nOr:\\n\\n    def first_bad_version(n)\\n      (1..n).bsearch(&method(:is_bad_version))\\n    end\\n\\n---\\n\\n**Python**\\n\\nIn Python I was only able to do it with a rather ugly wrapper:\\n\\n    def firstBadVersion(self, n):\\n        return bisect.bisect(type(\\'\\', (), {\\'__getitem__\\': lambda self, i: isBadVersion(i)})(), False, 0, n)\\n\\nNicer, more readable version:\\n\\n    def firstBadVersion(self, n):\\n        class Wrap:\\n            def __getitem__(self, i):\\n                return isBadVersion(i)\\n        return bisect.bisect(Wrap(), False, 0, n)",
                "codeTag": "Java"
            },
            {
                "id": 3137516,
                "title": "easy-java-solution-runtime-1ms-beats-98-7",
                "content": "\\n\\n# Code\\n```java []\\n/* The isBadVersion API is already defined.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int f = 1, l = n;\\n        while(f<=l){\\n            int m = f+(l-f)/2;\\n            if(!isBadVersion(m)){\\n                f = m+1;\\n            }else{\\n                l = m-1;\\n            }\\n        }\\n        return f;\\n    }\\n}\\n```\\n`Please UPVOTE. It\\'s free.`\\n\\n![upvote1.png](https://assets.leetcode.com/users/images/4977788f-a408-4c63-bab3-064e18a1226c_1675881902.1163795.png)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```java []\\n/* The isBadVersion API is already defined.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int f = 1, l = n;\\n        while(f<=l){\\n            int m = f+(l-f)/2;\\n            if(!isBadVersion(m)){\\n                f = m+1;\\n            }else{\\n                l = m-1;\\n            }\\n        }\\n        return f;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454609,
                "title": "c-simple-and-short-solution-o-log-n-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int lo = 1, hi = n, mid;\\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2;\\n            if (isBadVersion(mid)) hi = mid;\\n            else lo = mid+1;\\n        }\\n        return lo;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int lo = 1, hi = n, mid;\\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2;\\n            if (isBadVersion(mid)) hi = mid;\\n            else lo = mid+1;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71344,
                "title": "javascript-solution-key-subtle-difference-from-other-languages",
                "content": "This is the standard binary search solution, but what's crucial is that in JS you need to use Math.floor on mid. That caught me out for a little bit. Otherwise you get a float mid which will cause wrong answers.\\n```\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        // binary search\\n       var start = 1, end = n;\\n       while(start < end){\\n           var mid = Math.floor(start + (end-start) / 2);\\n           if(isBadVersion(mid)){\\n                end = mid; // look on left side of mid\\n           }else{\\n               start = mid+1; // look on the right side of mid\\n           }\\n       }\\n       return start;\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        // binary search\\n       var start = 1, end = n;\\n       while(start < end){\\n           var mid = Math.floor(start + (end-start) / 2);\\n           if(isBadVersion(mid)){\\n                end = mid; // look on left side of mid\\n           }else{\\n               start = mid+1; // look on the right side of mid\\n           }\\n       }\\n       return start;\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575109,
                "title": "java-4-lines-code-log-n-time-space-o-1-binary-search",
                "content": "if u like this kindly upvote \\n\\n```\\n public class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l=1;\\n        while(l<=n){\\n            int m=l+(n-l)/2;\\n            if(isBadVersion(m)){\\n                n=m-1;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n public class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l=1;\\n        while(l<=n){\\n            int m=l+(n-l)/2;\\n            if(isBadVersion(m)){\\n                n=m-1;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500450,
                "title": "clear-concept-tle-overflow-mechanism-what-s-wrong-with-left-right-2",
                "content": "The only **trap** in this question is regarding *integer overflow.*\\nLet\\'s grab the underlying **OVERFLOW CONCEPT.**\\nInteger range in most of programming languages like C++, Java is **-2147483648 to 2147483647**.\\n\\nFor all those who used ```int mid = (left + right)/2;``` \\nWhen you check the reason of TLE, it says one of following test case: *2126753390  1702766719*\\nThe values for *left, right, and mid* in the subsequent iterations are:\\n\\n\\tleft = 1             right = 2126753390,  mid = 1063376695\\n\\tleft = 1063376696    right = 2126753390,  mid = -552418605\\n\\tleft = -552418604    right = 2126753390,  mid = 787167393\\n\\tleft = 787167394     right = 2126753390,  mid = -690523256\\n\\t.\\n\\t.\\n\\tand so on...\\n\\n### REASON OF TLE :\\nThe value of **mid** switches between positive and negative signs. **This will never stop, resulting in an infinite loop and hence TLE.**\\n\\n### WHY it behaves this way?\\nIn the second iteration, mathematically it should be\\n```(1063376696 + 2126753390) /2 = (3190130086) /2   = 1595065043```\\nbut but due to *overflows of the integer range*, it will be interpreted as\\n```(1063376696 + 2126753390) / 2 = (-1104837210) / 2   = -552418605```\\n\\nLet\\'s understand it in a more intuitive way, by taking easier example:\\nQue: **How can we store value 10 in a data structure which can hold values in range [-4,3] ?**\\nIt will overflow and handled by complier by its **overflow and underflow mechanism.**\\nThe following section describes its inner working.\\n# OVERFLOW MECHANISM :\\nThe range is specified as -4 to 3. If given num falls in this range, it will be stored as it is. \\nOtherwise it will start filling in cyclic manner from opposite end. \\nFor e.g., \\n-12, 4, 12 will be represented as -4,\\n-14, -6, 10 will be represented as 2, etc.\\n( Ans:- num=10, lower=-4, upper=3. Hence, representational value = 2 )\\n\\n![image](https://assets.leetcode.com/users/images/4d0e04b5-4879-4d5e-9e97-38094eb10bcb_1662454758.777058.png)\\n\\n(Above diagram shows 3-bit signed representation of a number)\\n\\nThis value can be calculated by recursive calls as follows: [RECURSIVE APPROACH]\\n```\\n public static long dataType(long num, long lower, long upper){\\n        long range = upper-lower+1;\\n        if(num > upper)              // num is greater than upper, so we substract the range\\n            return dataType(num - range, lower, upper);\\n        if(num < lower)              // num is lesser than lower, so we add the range\\n            return dataType(num + range, lower, upper);\\n\\t\\t\\t\\n\\t\\t// num lies between lower and upper, so we return it\\n\\t\\treturn num;          \\n    }\\n```\\nHowever, recursive calls may fill up memory. Using modular arithmetic, we can solve this in O(1) constant time.\\nSimilar function as below is called, each time you do TYPE CASTING - NARROWING.\\n\\n### Working of Type Casting (narrowing) :\\n```\\npublic static long dataType(long num, long lower, long upper){\\n        if(lower<=num && num<=upper)\\n            return num;                  // if num lies between lower and upper, we return it\\n            \\n        long range = upper-lower+1;     // size of window in which num can be stored\\n        long value = num % range;       // to bring the num in the range\\n        if(num > upper){\\n            if(value > upper) value -= range;  //if value exceeds, bring it back in range\\n        }\\n        if(num < lower){\\n            if(value < lower) value += range; //if value preceeds, bring it back in range\\n        }\\n        return value;  // the representational value of the num\\n    }\\n```\\n\\nNow, you can create your custom range data type with different lower and upper bounds and have fun :)\\nlike lower=69, upper=96, num=116 hehe!\\n\\nVoila, we have made an exellent *DISCOVERY !!*\\n**The data types in java, c++ etc. are nothing but an *special case* of our program.**\\nAny num can be taken and change in values of lower and upper given:\\n![image](https://assets.leetcode.com/users/images/8b365166-8a41-4310-902f-835adb7a4d60_1662460446.4986744.png)\\n\\n### FLAW in behaviour of mid :\\n*After an overflow, the compiler starts again from the least limit of value (i.e. -2147483648 in integer case) and adds the remaining surplus value.*\\n*[ num=3190130086, lower=-2147483648, upper=2147483647 ]*\\n\\nHere, 3190130086 - 2147483648 - 2147483648 = -1104837210. \\nThe limit has crossed twice here, followed by a division giving -552418605\\n\\n**Understand it like, you need to give someone 4.5 litre of water but you have only bottle of 1 litre. What will you do?\\nYou will reuse(or recycle) the bottle 4 times, then last time you give 500mL as per mark. *Compiler works the same way!***\\n\\n### isBadVersion( ) API working :\\nFor those who think, this is implemented using arrays, and accessing **-ve** value value from array will give *Runtime Error*(IndexOutOfBound)\\nIts not! **The inner working of API** is similar as follows, where *firstBadIndex* is passed by different method. \\n```\\nbool isBadVersion(int value, int firstBadIndex){\\n        if(value < firstBadIndex) return false;\\n        else return true;\\n    }\\n```\\n\\n#### HOW TO FIX?\\nTo solve this anomaly, an equivalent mathematical formula, which is,\\n```int mid = left + (right-left)/2;``` is used,\\n\\n```\\nRHS = left + (right-left)/2\\n    = left + right/2 - left/2\\n\\t= left/2 + right/2\\n    = (left + right)/2\\n```\\nThis equivalent formula ensures that `(right-left)/2` lies between the bounds of integer range and does not overflows.\\nKeep this formula in mind, as it also performs better in sorting techniques like quick sort and others.\\n\\nAlternatively, to avoid overflow, one can also use higher range limit data types like **long**. But then you will miss this beauty behind the code. \\n**Don\\'t waste unnecessary space by taking higher data range (some people make a habit to do so) instead, understand the underlying concept.**\\nMake program less space complex and yourself a better programmer. ; )\\n#keepGrinding #happyCoding",
                "solutionTags": [
                    "Java",
                    "C",
                    "Binary Search"
                ],
                "code": "```int mid = (left + right)/2;```\n```(1063376696 + 2126753390) /2 = (3190130086) /2   = 1595065043```\n```(1063376696 + 2126753390) / 2 = (-1104837210) / 2   = -552418605```\n```\\n public static long dataType(long num, long lower, long upper){\\n        long range = upper-lower+1;\\n        if(num > upper)              // num is greater than upper, so we substract the range\\n            return dataType(num - range, lower, upper);\\n        if(num < lower)              // num is lesser than lower, so we add the range\\n            return dataType(num + range, lower, upper);\\n\\t\\t\\t\\n\\t\\t// num lies between lower and upper, so we return it\\n\\t\\treturn num;          \\n    }\\n```\n```\\npublic static long dataType(long num, long lower, long upper){\\n        if(lower<=num && num<=upper)\\n            return num;                  // if num lies between lower and upper, we return it\\n            \\n        long range = upper-lower+1;     // size of window in which num can be stored\\n        long value = num % range;       // to bring the num in the range\\n        if(num > upper){\\n            if(value > upper) value -= range;  //if value exceeds, bring it back in range\\n        }\\n        if(num < lower){\\n            if(value < lower) value += range; //if value preceeds, bring it back in range\\n        }\\n        return value;  // the representational value of the num\\n    }\\n```\n```\\nbool isBadVersion(int value, int firstBadIndex){\\n        if(value < firstBadIndex) return false;\\n        else return true;\\n    }\\n```\n```int mid = left + (right-left)/2;```\n```\\nRHS = left + (right-left)/2\\n    = left + right/2 - left/2\\n\\t= left/2 + right/2\\n    = (left + right)/2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2700688,
                "title": "simple-python-solution-using-binary-search",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\nVisit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation: https://www.python-techs.com/\\n\\n**Solution:**\\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left = 1\\n        right = n\\n        result = 1\\n        \\n        while left<=right:\\n            mid = (left+right)//2\\n            if isBadVersion(mid) == False:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n                result = mid\\n                \\n        return result\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left = 1\\n        right = n\\n        result = 1\\n        \\n        while left<=right:\\n            mid = (left+right)//2\\n            if isBadVersion(mid) == False:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n                result = mid\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71342,
                "title": "what-s-the-difference-between-left-right-2-and-left-right-left-2",
                "content": "Below is my code, it got TLE. But I can't see the difference between my code and [this one][1] except for how I calculated mid. So is there any difference between \"(left + right) / 2\" and \"left + (right - left) / 2\"? \\n\\n    bool isBadVersion(int version);\\n    \\n    class Solution {\\n    public:\\n        int firstBadVersion(int n) {\\n            int left = 1;\\n            int right = n;\\n            int mid;\\n            while(left < right) {\\n                mid = (left + right) / 2;\\n                if(isBadVersion(mid)) {\\n                    right = mid - 1;\\n                }\\n                else {\\n                    left = mid + 1;\\n                }\\n            }\\n            return left;\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/discuss/56550/short-c-answer-and-minimize-api-calls",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int firstBadVersion(int n) {\\n            int left = 1;\\n            int right = n;\\n            int mid;\\n            while(left < right) {\\n                mid = (left + right) / 2;\\n                if(isBadVersion(mid)) {\\n                    right = mid - 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3324195,
                "title": "awesome-logic-with-binary-search",
                "content": "\\n# Binary Search\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left,right=0,n-1\\n        while left<=right:\\n            mid=(left+right)//2\\n            if isBadVersion(mid)==False:\\n                left=mid+1\\n            else:\\n                right=mid-1\\n        return left\\n            \\n//please upvote me it would encourage me alot\\n\\n        \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left,right=0,n-1\\n        while left<=right:\\n            mid=(left+right)//2\\n            if isBadVersion(mid)==False:\\n                left=mid+1\\n            else:\\n                right=mid-1\\n        return left\\n            \\n//please upvote me it would encourage me alot\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240775,
                "title": "c-easy-using-binary-search",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long long int start = 0 ; \\n        long long int end = n ; \\n        long long int minBadVersion ;\\n         \\n        while (start <= end)\\n        {\\n            long long int mid = (start + end) / 2 ; \\n\\n            if (isBadVersion(mid) == 1)\\n            {\\n                minBadVersion = mid ; \\n                end = mid - 1 ; \\n            }\\n            else\\n            {\\n                start = mid + 1 ; \\n            }\\n        }\\n        return minBadVersion ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/65eeb207-f2a9-4d1b-9d13-2c8573d657ed_1677603105.5077243.png)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long long int start = 0 ; \\n        long long int end = n ; \\n        long long int minBadVersion ;\\n         \\n        while (start <= end)\\n        {\\n            long long int mid = (start + end) / 2 ; \\n\\n            if (isBadVersion(mid) == 1)\\n            {\\n                minBadVersion = mid ; \\n                end = mid - 1 ; \\n            }\\n            else\\n            {\\n                start = mid + 1 ; \\n            }\\n        }\\n        return minBadVersion ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236373,
                "title": "278-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn this solution, we maintain two pointers left and right that represent the range of versions we are searching. We start with left = 1 and right = n. At each iteration of the while loop, we compute the midpoint mid of the range as (left + right) // 2, and we call the isBadVersion API to check whether version mid is bad or not.\\n\\nIf isBadVersion(mid) returns True, then we know that the first bad version must be in the range [left, mid], so we update right = mid. Otherwise, the first bad version must be in the range [mid+1, right], so we update left = mid + 1. We continue this process until left and right converge to a single version, which must be the first bad version.\\n\\nThis algorithm runs in logarithmic time and makes only O(1) calls to the isBadVersion API at each iteration, which minimizes the total number of calls to the API.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71356,
                "title": "simple-python-solution-binary-search-both-iterative-and-recursive-versions",
                "content": "Iterative version:\\n```\\ndef firstBadVersion(self, n):\\n        low = 1\\n        high = n\\n        while(low < high):\\n            mid = (low + high)/2\\n            if isBadVersion(mid) == True:\\n                high = mid\\n            else:\\n                low = mid + 1\\n        return high\\n```\\n\\nRecursive version:\\n```\\n    def firstBadVersion(self, n):\\n        return self.binarySearch(1, n)\\n    \\n    def binarySearch(self, low, high):\\n        if low == high:\\n            return low\\n        mid = (low + high)/2\\n        if isBadVersion(mid) == True:\\n            return self.binarySearch(low, mid)\\n        else:\\n            return self.binarySearch(mid + 1, high)",
                "solutionTags": [],
                "code": "```\\ndef firstBadVersion(self, n):\\n        low = 1\\n        high = n\\n        while(low < high):\\n            mid = (low + high)/2\\n            if isBadVersion(mid) == True:\\n                high = mid\\n            else:\\n                low = mid + 1\\n        return high\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 606739,
                "title": "javascript-clean-binary-search-solution",
                "content": "```javascript\\nvar solution = function(isBadVersion) {\\n    return function(n) {\\n        let min = null;\\n        let start = 1;\\n        let end = n;\\n        \\n        while(start <= end) {\\n            const mid = Math.floor((start + end) / 2);\\n            \\n            if(isBadVersion(mid)) {\\n                min = mid;\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return min;\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```javascript\\nvar solution = function(isBadVersion) {\\n    return function(n) {\\n        let min = null;\\n        let start = 1;\\n        let end = n;\\n        \\n        while(start <= end) {\\n            const mid = Math.floor((start + end) / 2);\\n            \\n            if(isBadVersion(mid)) {\\n                min = mid;\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return min;\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2724423,
                "title": "3-lines-binary-search-java-c",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nif(you like)\\n\\tplease please UPVOTE\\uD83D\\uDE0A\\uD83D\\uDE0A;\\n```\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int st = 1,end = n;\\n        while(st <= end){\\n            int mid = st + (end-st)/2;\\n            if(isBadVersion(mid) == false) st = mid+1;\\n            else end = mid-1;\\n        }\\n        return st;\\n    }\\n};\\n```\\n\\n# Java  Code\\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int st = 1,end = n;\\n        while(st <= end){\\n            int mid = st + (end-st)/2;\\n            if(isBadVersion(mid) == false) st = mid+1;\\n            else end = mid-1;\\n        }\\n        return st;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\nif(you like)\\n\\tplease please UPVOTE\\uD83D\\uDE0A\\uD83D\\uDE0A;\\n```\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int st = 1,end = n;\\n        while(st <= end){\\n            int mid = st + (end-st)/2;\\n            if(isBadVersion(mid) == false) st = mid+1;\\n            else end = mid-1;\\n        }\\n        return st;\\n    }\\n};\\n```\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int st = 1,end = n;\\n        while(st <= end){\\n            int mid = st + (end-st)/2;\\n            if(isBadVersion(mid) == false) st = mid+1;\\n            else end = mid-1;\\n        }\\n        return st;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1743709,
                "title": "python-simple-python-solution-using-binary-search",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 30 ms, faster than 93.38% of Python3 online submissions for First Bad Version.\\n# Memory Usage: 13.7 MB, less than 96.91% of Python3 online submissions for First Bad Version.\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\n\\tclass Solution:\\n\\t\\tdef firstBadVersion(self, n: int) -> int:\\n\\n\\t\\t\\tresult = 1\\n\\t\\t\\tstart, end = 1, n\\n\\n\\t\\t\\twhile start <= end:\\n\\n\\t\\t\\t\\tmid = (start + end) // 2\\n\\n\\t\\t\\t\\tif isBadVersion(mid) == False:\\n\\t\\t\\t\\t\\tstart = mid + 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tend = mid - 1\\n\\t\\t\\t\\t\\tresult = mid\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83D\\uDD25\\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 30 ms, faster than 93.38% of Python3 online submissions for First Bad Version.\\n# Memory Usage: 13.7 MB, less than 96.91% of Python3 online submissions for First Bad Version.\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\n\\tclass Solution:\\n\\t\\tdef firstBadVersion(self, n: int) -> int:\\n\\n\\t\\t\\tresult = 1\\n\\t\\t\\tstart, end = 1, n\\n\\n\\t\\t\\twhile start <= end:\\n\\n\\t\\t\\t\\tmid = (start + end) // 2\\n\\n\\t\\t\\t\\tif isBadVersion(mid) == False:\\n\\t\\t\\t\\t\\tstart = mid + 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tend = mid - 1\\n\\t\\t\\t\\t\\tresult = mid\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83D\\uDD25\\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "codeTag": "Java"
            },
            {
                "id": 1555825,
                "title": "java-tc-o-logn-sc-o-1-simple-binary-search-w-minimum-api-calls",
                "content": "```\\n/**\\n * Binary Search\\n *\\n * Time Complexity: O(log N). N = Number of versions.\\n *\\n * Space Complexity: O(1)\\n */\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        // If nth version is not a bad version, then all versions are good.\\n        if (n <= 0 || !isBadVersion(n)) {\\n            return -1;\\n        }\\n        // If first version is a bad version, then all versions are bad.\\n        if (isBadVersion(1)) {\\n            return 1;\\n        }\\n\\n        // Search space is from 1 to n (All possible version numbers)\\n        int start = 1;\\n        int end = n;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (isBadVersion(mid)) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Binary Search\\n *\\n * Time Complexity: O(log N). N = Number of versions.\\n *\\n * Space Complexity: O(1)\\n */\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        // If nth version is not a bad version, then all versions are good.\\n        if (n <= 0 || !isBadVersion(n)) {\\n            return -1;\\n        }\\n        // If first version is a bad version, then all versions are bad.\\n        if (isBadVersion(1)) {\\n            return 1;\\n        }\\n\\n        // Search space is from 1 to n (All possible version numbers)\\n        int start = 1;\\n        int end = n;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (isBadVersion(mid)) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433696,
                "title": "java-solution-with-comments",
                "content": "PLEASE UPVOTE IF IT\\'S HELPFUL-\\n\\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start=1, end=n;\\n        while(start<end){\\n\\t\\t\\n            //Implement binary search logic\\n            //get the mid and pass it to function isBadVersion()\\n            //If mid is bad version (false) -> then start will be mid+1\\n            //If mid is good version (true) -> then end is mid\\n\\t\\t\\t\\n            int mid=  start+(end-start)/2;\\n            if(!isBadVersion(mid))\\n                start=mid+1;\\n            else\\n                end=mid;\\n        }\\n        return start;\\n        \\n    }\\n}\\n```\\n\\n\\n**24 / 24 test cases passed.\\nStatus: Accepted\\nRuntime: 26 ms\\nMemory Usage: 40.1 MB**",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start=1, end=n;\\n        while(start<end){\\n\\t\\t\\n            //Implement binary search logic\\n            //get the mid and pass it to function isBadVersion()\\n            //If mid is bad version (false) -> then start will be mid+1\\n            //If mid is good version (true) -> then end is mid\\n\\t\\t\\t\\n            int mid=  start+(end-start)/2;\\n            if(!isBadVersion(mid))\\n                start=mid+1;\\n            else\\n                end=mid;\\n        }\\n        return start;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676519,
                "title": "python-binary-search-simple-solution",
                "content": "**Python :**\\n\\nTime complexity : *O(logn)*\\nSpace complexity :*O(1)*\\n\\n```\\ndef firstBadVersion(self, n):\\n\\t\"\"\"\\n\\t:type n: int\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tlow = 0\\n\\thigh = n - 1\\n\\n\\twhile low <= high:\\n\\t\\tmid = (low + high) // 2\\n\\t\\tif not isBadVersion(mid):\\n\\t\\t\\tlow = mid + 1\\n\\n\\t\\telse:\\n\\t\\t\\thigh = mid - 1\\n\\n\\treturn low\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\ndef firstBadVersion(self, n):\\n\\t\"\"\"\\n\\t:type n: int\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tlow = 0\\n\\thigh = n - 1\\n\\n\\twhile low <= high:\\n\\t\\tmid = (low + high) // 2\\n\\t\\tif not isBadVersion(mid):\\n\\t\\t\\tlow = mid + 1\\n\\n\\t\\telse:\\n\\t\\t\\thigh = mid - 1\\n\\n\\treturn low\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1475526,
                "title": "java-99-percent-faster-solution-easy-binary-search",
                "content": "Please upvote if it helped.\\n\\nThis is a problem associated with binary search\\nLets take an example\\n1-2-3-4-5\\nG-B-B-B-B\\n\\nOur objective is to find the first bad version. You can assume it is sorted array by substituting Good by zero and Bad by 1\\n1-2-3-4-5\\n0-1-1-1-1\\nWe have to find first 1. We start by find value 1. \\n```\\nmid = low + (high-low)/2; // First approach\\nmid = (low+high)/2 //second approach.\\n```\\nWe followed first approach as it would prevent integer overflow, i.e, if sum of low and high is more than the capacity of integer it would pick next number which can become negative. You can read more about it [here](https://en.wikipedia.org/wiki/Integer_overflow)\\n\\nWe are interested in finding lower bound where value becomes 1, i.e, Bad, so we need to track only **low**. When our function **isBadVersion** returns true. It means we can find lower bound or if the mid is the lower bound. If mid is lower bound, in next iterations, low will be assigned the value of current **mid**.\\n\\nIterations:\\n1. low=1, high=5, mid = 2, badversion = true\\n2. low =1, high = 2, mid = 1, badversion = false\\n3. low=2, high=2, it comes out of loop as low == high\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n       int low = 1, high = n;\\n        while(low<high){\\n            int mid = low + (high-low)/2;\\n            boolean answer = isBadVersion(mid);\\n            if(answer==false){\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid;\\n            }\\n        }\\n        \\n        return low;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nmid = low + (high-low)/2; // First approach\\nmid = (low+high)/2 //second approach.\\n```\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n       int low = 1, high = n;\\n        while(low<high){\\n            int mid = low + (high-low)/2;\\n            boolean answer = isBadVersion(mid);\\n            if(answer==false){\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid;\\n            }\\n        }\\n        \\n        return low;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606857,
                "title": "java-python-3-2-similar-o-logn-clean-codes-w-brief-explanation",
                "content": "**Method 1:**\\nUse `<=` in while loop condition, hence `l > r` is the termination condition; The code ends up with that `r` and `l` are last good and first bad versions, respectively.\\n```java\\n    public int firstBadVersion(int n) {\\n        int l = 0, r = n;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (isBadVersion(mid))\\n                r = mid - 1;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n```\\n```python\\n    def firstBadVersion(self, n):\\n        l, r =  1, n\\n        while l <= r:\\n            mid = (l + r) >> 1\\n            if isBadVersion(mid):\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return l\\n```\\n\\n----\\n\\n**Method 2:**\\nUse `<` in while loop condition, hence `l == r` is the termination condition; The code ends up with that both `r` and `l` are first bad version.\\n```java\\n    public int firstBadVersion(int n) {\\n        int l = 1, r = n;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (isBadVersion(mid)) {\\n                r = mid;\\n            }else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n```\\n```python\\n    def firstBadVersion(self, n):\\n        l, r =  1, n\\n        while l < r:\\n            mid = (l + r) >> 1\\n            if isBadVersion(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int firstBadVersion(int n) {\\n        int l = 0, r = n;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (isBadVersion(mid))\\n                r = mid - 1;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n```\n```python\\n    def firstBadVersion(self, n):\\n        l, r =  1, n\\n        while l <= r:\\n            mid = (l + r) >> 1\\n            if isBadVersion(mid):\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return l\\n```\n```java\\n    public int firstBadVersion(int n) {\\n        int l = 1, r = n;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (isBadVersion(mid)) {\\n                r = mid;\\n            }else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n```\n```python\\n    def firstBadVersion(self, n):\\n        l, r =  1, n\\n        while l < r:\\n            mid = (l + r) >> 1\\n            if isBadVersion(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2833450,
                "title": "python-binary-search-bonus-one-liner",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\n\\n**Python #1.** Binary search from scratch.\\n```\\nclass Solution:\\n    def firstBadVersion_(self, n, s = 1):\\n        \\n        while s < n:\\n            i = (n + s) // 2\\n            if isBadVersion(i) : n = i\\n            else               : s = i + 1\\n        return s\\n```\\n\\n**Python #2.** One-liner using a built-in *bisect_left*.\\n```\\nclass Solution:\\n    def firstBadVersion(self, n, s = 1):\\n        \\n        return bisect.bisect_left(range(n), True, key=lambda x: isBadVersion(x))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstBadVersion_(self, n, s = 1):\\n        \\n        while s < n:\\n            i = (n + s) // 2\\n            if isBadVersion(i) : n = i\\n            else               : s = i + 1\\n        return s\\n```\n```\\nclass Solution:\\n    def firstBadVersion(self, n, s = 1):\\n        \\n        return bisect.bisect_left(range(n), True, key=lambda x: isBadVersion(x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658129,
                "title": "java-simple-code-to-find-first-bad-version-using-binary-search",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int low = 0, high = n , mid = 0;\\n        while(low <= high){\\n            mid = low + (high - low) / 2;\\n            if(isBadVersion(mid)){\\n                high = mid - 1;\\n            }else{\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```\\n\\n## **If you find this helpful, please upvote \\uD83D\\uDE0A**",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int low = 0, high = n , mid = 0;\\n        while(low <= high){\\n            mid = low + (high - low) / 2;\\n            if(isBadVersion(mid)){\\n                high = mid - 1;\\n            }else{\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670019,
                "title": "elegant-o-log-n-python-solution-with-explanation",
                "content": "The solution is quite simple and elegant. Since we know the version numbers are distinct and are in ascending order, we can simply use binary search to search for the first bad version.\\n\\nSteps:\\n1. Start with how every binary search starts. With two pointers, one at the first element of the array and one at the last.\\n\\t```\\n\\tlow, high = 1, n\\n\\t```\\n2. Run a while loop as long as low is less than high. (The reason to check ```low < high ```  will be explained below)\\n\\t```\\n\\twhile low < high: mid = (low + high) // 2\\n\\t```\\n3. Next check if the low pointer is not a bad version then set ```low = mid + 1``` else ```high = mid ```. \\n\\n\\nThe reason to set `low = mid + 1` and `high = mid` and not `high = mid - 1`. Since the bad version is the second part of the array we can\\'t remove all the bad versions from the binary search since we have to return the recent bad version not the most stable version. The is the exact reason why we don\\'t check for low <= high in the while loop since it can cause an infinite loop. You can return both low and high since they will be both equal at the end of the binary search. \\n\\nSolution:\\n```\\nlow, high = 1, n\\nwhile low < high:\\n\\tmid = (low + high) // 2\\n\\tif not isBadVersion(mid):\\n\\t\\tlow = mid + 1\\n\\telse:\\n\\t\\thigh = mid \\nreturn high\\n```\\n\\nFirst solution in leetcode. Happy to help! Thanks for the great community :)",
                "solutionTags": [
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\n\\tlow, high = 1, n\\n\\t```\n```low < high ```\n```\\n\\twhile low < high: mid = (low + high) // 2\\n\\t```\n```low = mid + 1```\n```high = mid ```\n```\\nlow, high = 1, n\\nwhile low < high:\\n\\tmid = (low + high) // 2\\n\\tif not isBadVersion(mid):\\n\\t\\tlow = mid + 1\\n\\telse:\\n\\t\\thigh = mid \\nreturn high\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71408,
                "title": "java-simple-clean",
                "content": "it looks very simple, but actually a little tricky. Have to pay attention to the detail.\\n<br>\\nAlgo. 1 --\\n\\n      public int firstBadVersion(int n) {\\n        int lo = 1, hi = n;\\n        while (lo < hi) {\\n        \\tint med = lo + (hi -  lo)/2;\\n        \\tif (isBadVersion(med)) {\\n        \\t\\thi = med;\\n        \\t} else {\\n        \\t\\tlo = med + 1;\\n        \\t}\\n        }\\n        return lo;\\n    }\\n\\nAlgo.2 --\\n\\n        public int firstBadVersion(int n) {\\n        int lo = 1, hi = n;\\n        while (lo <= hi) {\\n        \\tint med = lo + (hi -  lo)/2;\\n        \\tif (isBadVersion(med)) {\\n        \\t\\tif (med == 1 || !isBadVersion(med-1))\\n        \\t\\t\\treturn med;\\n        \\t\\thi = med;\\n        \\t} else {\\n        \\t\\tlo = med + 1;\\n        \\t}\\n        }\\n        return -1; //no solution found.\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "it looks very simple, but actually a little tricky. Have to pay attention to the detail.\\n<br>\\nAlgo. 1 --\\n\\n      public int firstBadVersion(int n) {\\n        int lo = 1, hi = n;\\n        while (lo < hi) {\\n        \\tint med = lo + (hi -  lo)/2;\\n        \\tif (isBadVersion(med)) {\\n        \\t\\thi = med;\\n        \\t} else {\\n        \\t\\tlo = med + 1;\\n        \\t}\\n        }\\n        return lo;\\n    }\\n\\nAlgo.2 --\\n\\n        public int firstBadVersion(int n) {\\n        int lo = 1, hi = n;\\n        while (lo <= hi) {\\n        \\tint med = lo + (hi -  lo)/2;\\n        \\tif (isBadVersion(med)) {\\n        \\t\\tif (med == 1 || !isBadVersion(med-1))\\n        \\t\\t\\treturn med;\\n        \\t\\thi = med;\\n        \\t} else {\\n        \\t\\tlo = med + 1;\\n        \\t}\\n        }\\n        return -1; //no solution found.\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3347493,
                "title": "c-easy-using-binary-search-o-logn",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe call the `isBadVersion` function with `mid` as an argument. \\n\\nIf the **result** is `true`, it means that the bad version is in the lower half of the search range, so it updates `e = mid-1` and continues the search in the lower half.\\n\\n If the **result** is `false`, it means that the bad version is in the upper half of the search range, so it updates `s = mid+1` and continues the search in the upper half.\\n\\nThe function returns the value of `s`, which is the index of the **first bad version**.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s=1,e=n;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(isBadVersion(mid)){\\n                e=mid-1;\\n            }\\n            else if(!isBadVersion(mid)){\\n                 s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s=1,e=n;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(isBadVersion(mid)){\\n                e=mid-1;\\n            }\\n            else if(!isBadVersion(mid)){\\n                 s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924090,
                "title": "first-bad-version-binary-search-c-approach-explained",
                "content": "<hr/>\\n\\n### Approach:\\n1. Find the `mid` element from 1 to `n`\\n2. Check if `mid` is bad or not\\n3. If mid is bad, store it in variable and go to left part of array, because we need to find first bad version. **(end = mid-1)**\\n4. If number is not bad, go to right part of an array. **(start=mid+1)**\\n<hr/>\\n\\n### Code:\\n<hr/>\\n\\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s = 0;\\n        int e = n;\\n        int bad;\\n        while(s<=e){\\n            \\n            int mid = s + (e-s)/2;\\n            \\n            if(isBadVersion(mid)){\\n                bad = mid;\\n                e = mid-1;\\n            }\\n            else\\n                s = mid+1;\\n            \\n        }\\n        return bad;\\n    }\\n};\\n```\\nPlease **UPVOTE** if you find this helpful!\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s = 0;\\n        int e = n;\\n        int bad;\\n        while(s<=e){\\n            \\n            int mid = s + (e-s)/2;\\n            \\n            if(isBadVersion(mid)){\\n                bad = mid;\\n                e = mid-1;\\n            }\\n            else\\n                s = mid+1;\\n            \\n        }\\n        return bad;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705959,
                "title": "python-faster-than-regular-binary-search-100-faster-solution-optimal",
                "content": "\\n```\\n\\nclass Solution(object):\\n   \\n    def firstBadVersion(self, n):\\n        start =1\\n        end =n\\n        \\n        while start<=end:\\n            mid = (start+end)//2\\n            if (isBadVersion(mid) and not isBadVersion(mid-1)): #optimization using second parameter\\n                return mid\\n            elif(not isBadVersion(mid)):\\n                start = mid+1 \\n            else:\\n                end = (mid-1)\\n```\\n            \\n\\t\\t\\t\\n****\\t\\t\\tIf this solution helped you, please upvote****",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution(object):\\n   \\n    def firstBadVersion(self, n):\\n        start =1\\n        end =n\\n        \\n        while start<=end:\\n            mid = (start+end)//2\\n            if (isBadVersion(mid) and not isBadVersion(mid-1)): #optimization using second parameter\\n                return mid\\n            elif(not isBadVersion(mid)):\\n                start = mid+1 \\n            else:\\n                end = (mid-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71436,
                "title": "javascript-solution",
                "content": "    function solution(isBadVersion) {\\n      return function(n) {\\n        var left = 0;\\n        var right = n;\\n    \\n        while (right - left !== 1) {\\n          var mid = parseInt((left + right) / 2);\\n    \\n          if (isBadVersion(mid)) {\\n            right = mid;\\n          } else {\\n            left = mid;\\n          }\\n        }\\n        return right;\\n      };\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function solution(isBadVersion) {\\n      return function(n) {\\n        var left = 0;\\n        var right = n;\\n    \\n        while (right - left !== 1) {\\n          var mid = parseInt((left + right) / 2);\\n    \\n          if (isBadVersion(mid)) {\\n            right = mid;\\n          } else {\\n            left = mid;\\n          }\\n        }\\n        return right;\\n      };\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3601993,
                "title": "easy-and-optimum-solution-using-binary-search-beats-96-11",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe problem requires finding the first bad version in a given range of versions. A bad version indicates that all subsequent versions are also bad. We need to optimize the solution to minimize the number of calls to the isBadVersion() API.\\n\\n# Approach\\n1. Initially, we have the range of versions from 1 to n, where n is the total number of versions.\\n1. We want to find the first bad version, which indicates that all subsequent versions are also bad.\\n1. To optimize our search, we use a binary search algorithm.\\n1. We start with the middle version and check if it is a bad version.\\n1. If it is a bad version, we can conclude that all versions after it are also bad.\\n1. If it is not a bad version, we can conclude that all versions before it are good.\\n1. Based on this information, we update our search range accordingly.\\n1. If the middle version is bad, we search in the left half (lower versions).\\n1. If the middle version is good, we search in the right half (higher versions).\\n1. We repeat steps 4 and 5 until we narrow down the search range to a single version.\\n1. At this point, we have found the first bad version.\\n1. Finally, we return the index of the first bad version.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the binary search algorithm is $$O(log n)$$, where n is the number of versions. This is because we divide the range of versions in half at each step of the binary search, reducing the search space exponentially.\\n\\n- Space complexity:\\nThe space complexity is $$O(1)$$ since the solution uses only a constant amount of additional space to store the variables start, end, and mid.\\n\\n# Code\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n\\n        int start = 1; // Start of the search range\\n        int end = n; // End of the search range\\n        int mid = 0; // Variable to store the middle version\\n        \\n        while (start <= end) {\\n            mid = start + (end - start) / 2; // Calculate the middle version\\n\\n            if (isBadVersion(mid)) {\\n                end = mid - 1; // Adjust the end to search in the left half (lower versions)\\n            } else {\\n                // If the middle version is not bad, all versions before it are good\\n                start = mid + 1; // Adjust the start to search in the right half (higher versions)\\n            }\\n        }\\n\\n        return end + 1; // Return the index of the first bad version\\n    }\\n}\\n\\n```\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/6964a8ad-0038-4c2d-858d-a3700cdd2d03_1685993019.7458081.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n\\n        int start = 1; // Start of the search range\\n        int end = n; // End of the search range\\n        int mid = 0; // Variable to store the middle version\\n        \\n        while (start <= end) {\\n            mid = start + (end - start) / 2; // Calculate the middle version\\n\\n            if (isBadVersion(mid)) {\\n                end = mid - 1; // Adjust the end to search in the left half (lower versions)\\n            } else {\\n                // If the middle version is not bad, all versions before it are good\\n                start = mid + 1; // Adjust the start to search in the right half (higher versions)\\n            }\\n        }\\n\\n        return end + 1; // Return the index of the first bad version\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975645,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n         int lower = 1, upper = n, mid;\\n        while(lower < upper) {\\n            mid = lower + (upper - lower) / 2;\\n            if(!isBadVersion(mid))\\n             lower = mid + 1;\\n            else\\n             upper = mid;\\n        }\\n        return lower;   \\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n         int lower = 1, upper = n, mid;\\n        while(lower < upper) {\\n            mid = lower + (upper - lower) / 2;\\n            if(!isBadVersion(mid))\\n             lower = mid + 1;\\n            else\\n             upper = mid;\\n        }\\n        return lower;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688057,
                "title": "java-solution-with-o-log-n-time-complexity",
                "content": "```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start = 1, end = n, result = 0;\\n        while(start <= end) {\\n            int mid = start + (end - start)/2;\\n            if(isBadVersion(mid)) {\\n                result = mid;\\n                end = mid - 1;\\n            } else\\n                start = mid + 1;\\n        }\\n        return result;\\n    }\\n}\\n```\\nGuy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE.\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start = 1, end = n, result = 0;\\n        while(start <= end) {\\n            int mid = start + (end - start)/2;\\n            if(isBadVersion(mid)) {\\n                result = mid;\\n                end = mid - 1;\\n            } else\\n                start = mid + 1;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466178,
                "title": "first-bad-version-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long long int low=1, high=n, mid;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(isBadVersion(mid))\\n            {\\n                if(mid-1>=0 && !isBadVersion(mid-1))\\n                {\\n                    return mid;\\n                }\\n                high = mid-1;\\n            }\\n            else if(!isBadVersion(mid))\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return mid;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/b30dac90-160c-4547-b84b-504589b13664_1682772442.0565617.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long long int low=1, high=n, mid;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(isBadVersion(mid))\\n            {\\n                if(mid-1>=0 && !isBadVersion(mid-1))\\n                {\\n                    return mid;\\n                }\\n                high = mid-1;\\n            }\\n            else if(!isBadVersion(mid))\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return mid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081374,
                "title": "javascript-simple-upvote-if",
                "content": "```\\nvar solution = function(isBadVersion) {\\n    return function(n) {\\n        let nBad = n;\\n        let nGood = 0;\\n        while (nBad - nGood > 1) {\\n            let nCurr = Math.round((nBad + nGood)/2); // center\\n            if (isBadVersion(nCurr)) {                // only one API call\\n                nBad = nCurr;\\n            } else {\\n                nGood = nCurr;\\n            }\\n        }\\n        return nBad;\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar solution = function(isBadVersion) {\\n    return function(n) {\\n        let nBad = n;\\n        let nGood = 0;\\n        while (nBad - nGood > 1) {\\n            let nCurr = Math.round((nBad + nGood)/2); // center\\n            if (isBadVersion(nCurr)) {                // only one API call\\n                nBad = nCurr;\\n            } else {\\n                nGood = nCurr;\\n            }\\n        }\\n        return nBad;\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2668808,
                "title": "js-binary-search-with-explanation",
                "content": "A binary search algorithm is used to solve the problem. We check the average value of n(mid), if it is true(bad), then we do an additional check for a false value in front of it, if so, we return our mid, otherwise we continue our search.\\nIf our average value is false, we \"reject\" the half that comes before this value, and repeat the search again, already among the \"new\" half.\\n\\n```\\nvar solution = function (isBadVersion) {\\n\\n    return function (n) {\\n        let low = 1;\\n        let high = n;\\n        let mid;\\n        while (low <= high) {\\n            mid = ~~(low + (high - low) / 2);\\n            if (isBadVersion(mid)) {\\n                if (isBadVersion(mid - 1)) high = mid - 1;\\n                else return mid;\\n            } else low = mid + 1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nvar solution = function (isBadVersion) {\\n\\n    return function (n) {\\n        let low = 1;\\n        let high = n;\\n        let mid;\\n        while (low <= high) {\\n            mid = ~~(low + (high - low) / 2);\\n            if (isBadVersion(mid)) {\\n                if (isBadVersion(mid - 1)) high = mid - 1;\\n                else return mid;\\n            } else low = mid + 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2180671,
                "title": "python3-clean-code-faster-than-96",
                "content": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low,high = 1, n\\n        while low<=high:\\n            mid=(low+high)//2\\n            isBad = isBadVersion(mid)\\n            if(isBad):\\n                high = mid-1\\n            else:\\n                low = mid+1\\n        return low\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low,high = 1, n\\n        while low<=high:\\n            mid=(low+high)//2\\n            isBad = isBadVersion(mid)\\n            if(isBad):\\n                high = mid-1\\n            else:\\n                low = mid+1\\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767773,
                "title": "binary-search-template-solution-intuition-explained-in-detail-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhey every one i have made video playlist for binary search where i discuss a template solution and intuition behind it, this template solution will be very useful as this will help you solve many other questions in binary search this question is the part of that playlist:\\n\\nVideo link for question: https://youtu.be/EzCvKAnU5f0\\n\\nPlaylist ink: https://youtube.com/playlist?list=PLICVjZ3X1AcYYdde4GTp79zfdp_VACSkX\\n\\n\\n\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int left=1;\\n        int right=n;\\n        while(left<right){\\n            int mid= left+ (right-left)/2;\\n            if(isBadVersion(mid)){\\n                right=mid;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int left=1;\\n        int right=n;\\n        while(left<right){\\n            int mid= left+ (right-left)/2;\\n            if(isBadVersion(mid)){\\n                right=mid;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206120,
                "title": "finding-the-first-bad-version-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find the first bad version, we need to perform a search. However, we don\\'t want to search all the versions one by one because that would take a long time. Instead, we can use the binary search algorithm to search for the first bad version in a more efficient way.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOur approach will be to use binary search to search for the first bad version. We will start by initializing two pointers, left and right, to 1 and n, respectively. We will then find the middle version by computing the average of left and right, and call isBadVersion on the middle version. If it returns True, then we know that the first bad version is either the middle version or a version before it. So we will move the right pointer to the middle version. If it returns False, then we know that the first bad version is either the middle version or a version after it. So we will move the left pointer to the middle version + 1. We will repeat this process until left and right converge to the first bad version.\\n# Complexity\\n- Time complexity:$$O(log n)$$, where $$ n$$ is the number of versions.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$, because we are only using constant extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left = 1\\n        right = n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left = 1\\n        right = n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530017,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long int left = 1;\\n        long int right = n;\\n        long int mid;\\n        \\n        while(left <= right){\\n            mid = (left+right)/2;\\n            if(isBadVersion(mid)){\\n                right = mid-1;\\n            }\\n            else left = mid+1;\\n            \\n            if(isBadVersion(mid) && !(isBadVersion(mid - 1))){\\n                return mid;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long int left = 1;\\n        long int right = n;\\n        long int mid;\\n        \\n        while(left <= right){\\n            mid = (left+right)/2;\\n            if(isBadVersion(mid)){\\n                right = mid-1;\\n            }\\n            else left = mid+1;\\n            \\n            if(isBadVersion(mid) && !(isBadVersion(mid - 1))){\\n                return mid;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968674,
                "title": "binary-search-o-log-n-start-end-start-2-c-0ms-faster-than-100-easy-solution",
                "content": "**Best Approach C++**\\n\\n```\\nint firstBadVersion(int n) {\\n        int l=1,r=n;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2; // This is same as (l+r)/2 \\n            if(isBadVersion(mid))   // If this will return true then either this will be the first bad or first bad is in the left of it.\\n                r=mid-1;\\n            else\\n                l=mid+1;    // else bad on the right side.\\n        }\\n        if(isBadVersion(r)) // We have to check this condition because if we find true and then we assign r=mid-1 and this element will be false so we havbe to check this.\\n            return r;\\n        else\\n            return r+1;\\n    }\\n```\\n**If you find it helpful kindly UPVOTE**",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nint firstBadVersion(int n) {\\n        int l=1,r=n;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2; // This is same as (l+r)/2 \\n            if(isBadVersion(mid))   // If this will return true then either this will be the first bad or first bad is in the left of it.\\n                r=mid-1;\\n            else\\n                l=mid+1;    // else bad on the right side.\\n        }\\n        if(isBadVersion(r)) // We have to check this condition because if we find true and then we assign r=mid-1 and this element will be false so we havbe to check this.\\n            return r;\\n        else\\n            return r+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 204313,
                "title": "javascript",
                "content": "```\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        let left = 1, right = n\\n        while(left < right) {\\n            const mid = Math.floor((right + left) / 2)\\n            if(isBadVersion(mid)) {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        return right\\n    };\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        let left = 1, right = n\\n        while(left < right) {\\n            const mid = Math.floor((right + left) / 2)\\n            if(isBadVersion(mid)) {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        return right\\n    };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3397965,
                "title": "binary-search",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for isBadVersion()\\n * \\n * @param {integer} version number\\n * @return {boolean} whether the version is bad\\n * isBadVersion = function(version) {\\n *     ...\\n * };\\n */\\n\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\n  var solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n     \\n    return function(n) {\\n       let start = 1\\n       let end = n\\n       while (start <= end) {\\n           let mid = Math.floor((start + end) / 2)\\n           if (!isBadVersion(mid)) {\\n               start = mid + 1\\n           } else {\\n               end = mid - 1\\n           }\\n       }\\n       return start\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * Definition for isBadVersion()\\n * \\n * @param {integer} version number\\n * @return {boolean} whether the version is bad\\n * isBadVersion = function(version) {\\n *     ...\\n * };\\n */\\n\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\n  var solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n     \\n    return function(n) {\\n       let start = 1\\n       let end = n\\n       while (start <= end) {\\n           let mid = Math.floor((start + end) / 2)\\n           if (!isBadVersion(mid)) {\\n               start = mid + 1\\n           } else {\\n               end = mid - 1\\n           }\\n       }\\n       return start\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3181875,
                "title": "python-binary-search-clean-code-o-logn",
                "content": "# Complexity\\n- Time complexity:$$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l , r , ans = 1, n, -1\\n\\n        while l <= r:\\n            mid = (l + r) >> 1\\n            if isBadVersion(mid):\\n                ans = mid\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l , r , ans = 1, n, -1\\n\\n        while l <= r:\\n            mid = (l + r) >> 1\\n            if isBadVersion(mid):\\n                ans = mid\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072120,
                "title": "92-56-faster-binary-search-4-line-code",
                "content": "***PLEASE UPVOTE IF YOU LIKE THIS SOLUTION***\\n\\n# Code\\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int i = 0, j = n;\\n\\n        while(i <= j){\\n            int mid = i + (j - i)/2;\\n            if(isBadVersion(mid) == true && isBadVersion(mid - 1) == false) return mid;\\n            else if(isBadVersion(mid) == false) i = mid + 1;\\n            else j = mid - 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int i = 0, j = n;\\n\\n        while(i <= j){\\n            int mid = i + (j - i)/2;\\n            if(isBadVersion(mid) == true && isBadVersion(mid - 1) == false) return mid;\\n            else if(isBadVersion(mid) == false) i = mid + 1;\\n            else j = mid - 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600247,
                "title": "java-binary-search-solution",
                "content": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int s = 1;\\n        int e = n;\\n        int ans =0;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(isBadVersion(mid)){\\n                ans=mid;\\n                e = mid-1;\\n            }\\n            else{\\n                s = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int s = 1;\\n        int e = n;\\n        int ans =0;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(isBadVersion(mid)){\\n                ans=mid;\\n                e = mid-1;\\n            }\\n            else{\\n                s = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505675,
                "title": "python-easy-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        k, left, right = 0, 1, n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid - 1\\n                k = mid\\n            else:\\n                left = mid + 1\\n        return k\\n```\\nIf you found it useful please upvote, any comments are welcome!",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        k, left, right = 0, 1, n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid - 1\\n                k = mid\\n            else:\\n                left = mid + 1\\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375631,
                "title": "easy-c-solution-100-beat",
                "content": "# ***<<-- upvote***\\ntotal simple binary search type solution\\n\\n```\\nint firstBadVersion(int n) {\\n   long int f=1,mid;\\n    while(f<n) {\\n        mid = (f+n) / 2;\\n        if(isBadVersion(mid) == true) {\\n            n=mid;\\n        }\\n        else {\\n            f=mid+1;\\n        }\\n    }\\n    return f;\\n}\\n```\\n\\nbuddy don\\'t try for only using int for space efficient it needed long int \\u2665",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint firstBadVersion(int n) {\\n   long int f=1,mid;\\n    while(f<n) {\\n        mid = (f+n) / 2;\\n        if(isBadVersion(mid) == true) {\\n            n=mid;\\n        }\\n        else {\\n            f=mid+1;\\n        }\\n    }\\n    return f;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2102227,
                "title": "c-100-beats-0ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int start=1,end=n;\\n        while (start<=end) {\\n            int mid=start+(end-start)/2;\\n            if (isBadVersion(mid)) {\\n                if (mid==1||isBadVersion(mid-1)==false) return mid;\\n                else end=mid-1;\\n            }\\n            else start=mid+1;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int start=1,end=n;\\n        while (start<=end) {\\n            int mid=start+(end-start)/2;\\n            if (isBadVersion(mid)) {\\n                if (mid==1||isBadVersion(mid-1)==false) return mid;\\n                else end=mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1476803,
                "title": "beautiful-binary-search-application-o-n-to-o-log-n",
                "content": "Hi Everyone, \\n\\nIn this solution, we will move from ***Brute Force Solution Approach to Optimal Solution Approach***.\\n\\nIn Optimal Solution, we will see a ***beautiful application of Binary Search***.\\n\\n**Brute Force Approach**\\n\\nWe will do a simple scan from 1 till n and as soon as we find the first number which is a bad version, we return it. \\n\\n* ***Time Complexity - O(N)***\\n* ***Space Complexity - O(1)***\\n     \\n**Optimal Approach**\\n\\nSince we know that 1 to n is going to behave like a sorted array, let us fix our left to 1 and right to n. (Imagine 1,2,3,4.....n)\\n\\n**Applying Binary Search, suppose we have a mid and at this mid, our function says it is a good version**. \\n\\n* It means that the required first bad version will definitely lie towards right hand side, so do left = mid + 1.\\n\\n* Again, if the function says this mid is a bad version, then our answer can be this mid or somewhere before this. To check, we can check if (mid-1) is a good version or bad. If it is a good version, mid will be our answer. If it is a bad version, we will do right = mid - 1 as answer will definitely be before mid.\\n\\n* To handle edge cases, conditions are added below (when mid == 1)\\n\\n***Points to note*** : \\n***The given function returns True for a value, it means the version is bad.***\\n***mid = left + (right - left)// 2 is done to avoid integer overflow issues.***\\n\\n\\n* ***Time Complexity - O(log(N))***\\n* ***Space Complexity - O(1)***\\n        \\nHere is the code for Brute Force Approach - \\n```\\n\\tfor i in range(1, n+1):\\n\\t\\tif isBadVersion(i) == True:\\n\\t\\t\\treturn i\\n```\\n\\nHere is the code for Optimal Approach - \\n     \\n   ```\\n\\t\\tleft = 1\\n        right = n\\n        while left <= right:\\n            \\n            mid = left + (right - left) // 2\\n            \\n            if isBadVersion(mid) == False: #== if a version is not bad, answer will definitely lie after m\\n                left = mid + 1 \\n                \\n            else: #== if a version is bad \\n\\t\\t\\t\\n                #we will check (m-1)th number - if it is bad, we will do right = m - 1\\n                #if it is good, we will return answer\\n                if mid == 1:\\n                    return mid\\n\\t\\t\\t\\t\\t\\n                if isBadVersion(mid-1):\\n                    right = mid - 1\\n\\t\\t\\t\\t\\t\\n                else:\\n                    return mid\\n                \\n```\\n         \\n\\n     \\n#Time Complexity - O(log(N)) and Space Complexity - O(1)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\tfor i in range(1, n+1):\\n\\t\\tif isBadVersion(i) == True:\\n\\t\\t\\treturn i\\n```\n```\\n\\t\\tleft = 1\\n        right = n\\n        while left <= right:\\n            \\n            mid = left + (right - left) // 2\\n            \\n            if isBadVersion(mid) == False: #== if a version is not bad, answer will definitely lie after m\\n                left = mid + 1 \\n                \\n            else: #== if a version is bad \\n\\t\\t\\t\\n                #we will check (m-1)th number - if it is bad, we will do right = m - 1\\n                #if it is good, we will return answer\\n                if mid == 1:\\n                    return mid\\n\\t\\t\\t\\t\\t\\n                if isBadVersion(mid-1):\\n                    right = mid - 1\\n\\t\\t\\t\\t\\t\\n                else:\\n                    return mid\\n                \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 708387,
                "title": "yet-another-python-solution",
                "content": "```\\n# The isBadVersion API is already defined for you.\\n# @param version, an integer\\n# @return an integer\\n# def isBadVersion(version):\\n\\nclass Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        l,r=0,n\\n        while l<r:\\n            mid = (l+r)//2\\n            if isBadVersion(mid):\\n                r=mid\\n            else:\\n                l=mid+1\\n        return l   \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# @param version, an integer\\n# @return an integer\\n# def isBadVersion(version):\\n\\nclass Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        l,r=0,n\\n        while l<r:\\n            mid = (l+r)//2\\n            if isBadVersion(mid):\\n                r=mid\\n            else:\\n                l=mid+1\\n        return l   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590078,
                "title": "easiest-c-code-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int i,j,k,c=0;\\n        int h=n,l=0,m;\\n\\n        while(l<=h)\\n        {\\n            m=l+(h-l)/2;\\n            int res=isBadVersion(m);\\n            if(res==1 and (m==0 or isBadVersion(m-1)!=1)){\\n                return m;\\n            }\\n            else if(res==0){\\n                l=m+1;\\n            }else\\n            h=m-1;\\n        }\\n        return m;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int i,j,k,c=0;\\n        int h=n,l=0,m;\\n\\n        while(l<=h)\\n        {\\n            m=l+(h-l)/2;\\n            int res=isBadVersion(m);\\n            if(res==1 and (m==0 or isBadVersion(m-1)!=1)){\\n                return m;\\n            }\\n            else if(res==0){\\n                l=m+1;\\n            }else\\n            h=m-1;\\n        }\\n        return m;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467616,
                "title": "easy-to-understand-explained-with-example",
                "content": "# Intuition\\njust use Binary search\\n\\n# Approach\\nat first we took 3 variable \\'low\\',\\'high\\',\\'mid\\'. \\'Low\\' set at first ,\\'high\\' set at last of the index .\\nthen we used a while loop until low becomes \\'equal\\' of high.\\nthen we calculated the mid;\\n\\nwe checked if our mid is Bad .if then we will check the previous(mid-1) value is good or not .if previous is good then the bad starts from mid; ----------so return mid \\nfor example [low(good),mid-1(good),mid(bad),#(bad),high(bad)]\\n\\n\\nif mid is bad but the previous one(mid-1) is also bad \\nfor example [low(good),mid-1(bad),mid(bad),#(bad),high(bad)]\\nthen we will shift our high value to mid-1 position;\\n\\n\\nif mid is not bad\\nfor example [low(good),mid-1(good),mid(good),#(bad),high(bad)]\\nthen our \\'low\\' will be \\'mid+1\\'.because we dont have to check till mid because till mid is all good;\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long low=1;\\n        long high=n;\\n        long mid;\\n        \\n        while(low<=high){\\n            mid=(low+high)/2;\\n\\n            // if mid is bad\\n            if(isBadVersion(mid)){\\n\\n                if(!isBadVersion(mid-1)){ \\n                    return mid;\\n                }\\n                else high=mid-1;\\n            }\\n\\n            //if mid is not BAD\\n            else{\\n                low=mid+1;\\n                //our low will set in mid+1 position\\n            }\\n        }\\n        return mid;\\n    }\\n};\\n```\\n# Brother Please Upvote :(",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long low=1;\\n        long high=n;\\n        long mid;\\n        \\n        while(low<=high){\\n            mid=(low+high)/2;\\n\\n            // if mid is bad\\n            if(isBadVersion(mid)){\\n\\n                if(!isBadVersion(mid-1)){ \\n                    return mid;\\n                }\\n                else high=mid-1;\\n            }\\n\\n            //if mid is not BAD\\n            else{\\n                low=mid+1;\\n                //our low will set in mid+1 position\\n            }\\n        }\\n        return mid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320800,
                "title": "best-solution-in-java-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple Binary search approach\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start = 1;\\n        int end = n;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(isBadVersion(mid) == true && isBadVersion(mid-1) == false){\\n                return mid;\\n            }\\n            else if(isBadVersion(mid) == false){\\n                start = mid+1;\\n            }\\n            else {\\n                end = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\nplease upvote this for better solution of other questions![download.jfif](https://assets.leetcode.com/users/images/088df835-440e-4393-bbf4-8aa8e03aca02_1679330376.257638.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start = 1;\\n        int end = n;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(isBadVersion(mid) == true && isBadVersion(mid-1) == false){\\n                return mid;\\n            }\\n            else if(isBadVersion(mid) == false){\\n                start = mid+1;\\n            }\\n            else {\\n                end = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011922,
                "title": "binary-search-c",
                "content": "\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n       int l = 1, r = n;\\n       while(l<r)\\n       {\\n           int mid = l+(r-l)/2;\\n           if(isBadVersion(mid))\\n           r=mid;\\n           else\\n           l=mid+1;\\n       }\\n       return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n       int l = 1, r = n;\\n       while(l<r)\\n       {\\n           int mid = l+(r-l)/2;\\n           if(isBadVersion(mid))\\n           r=mid;\\n           else\\n           l=mid+1;\\n       }\\n       return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672082,
                "title": "python-binary-search-two-approaches",
                "content": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n  def firstBadVersion(self, n: int) -> int:\\n  \"\"\"Optimised version.\\n  \"\"\"\\n    left, right = 1, n\\n    while left <= right:\\n      mid = (left + right)//2\\n      if left == right:\\n        if isBadVersion(left) == True:\\n          return left\\n      elif isBadVersion(mid) == True:\\n        right = mid\\n      else:\\n        left = mid + 1\\n```\\n\\n\\n\\n```\\nclass Solution:\\n  def firstBadVersion(self, n: int) -> int:\\n    right, left = n, 1\\n    while left <= right:\\n      mid = (left + right)//2\\n      is_bad = isBadVersion(mid)\\n      if  is_bad == True:\\n        if isBadVersion(mid - 1) == False: # here we are checking if the previous version is good.\\n          return mid\\n        right = mid - 1 \\n      elif is_bad == False:\\n        left = mid + 1\\n```\\n\\nPlease upvote if you like my solution :) Thank you !",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n  def firstBadVersion(self, n: int) -> int:\\n  \"\"\"Optimised version.\\n  \"\"\"\\n    left, right = 1, n\\n    while left <= right:\\n      mid = (left + right)//2\\n      if left == right:\\n        if isBadVersion(left) == True:\\n          return left\\n      elif isBadVersion(mid) == True:\\n        right = mid\\n      else:\\n        left = mid + 1\\n```\n```\\nclass Solution:\\n  def firstBadVersion(self, n: int) -> int:\\n    right, left = n, 1\\n    while left <= right:\\n      mid = (left + right)//2\\n      is_bad = isBadVersion(mid)\\n      if  is_bad == True:\\n        if isBadVersion(mid - 1) == False: # here we are checking if the previous version is good.\\n          return mid\\n        right = mid - 1 \\n      elif is_bad == False:\\n        left = mid + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550677,
                "title": "binary-search-c",
                "content": "\\n\\nclass Solution {\\npublic:\\n\\n\\n    int firstBadVersion(int n) {\\n          if(n<1) return 1;\\n        int ans=1,l=1,r=n;\\n        while(l<=r){\\n           int m=l+(r-l)/2;\\n           if(isBadVersion(m)){\\n             ans=m;\\n             r=m-1;\\n           }\\n           else l=m+1;\\n       }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    int firstBadVersion(int n) {\\n          if(n<1) return 1;\\n        int ans=1,l=1,r=n;\\n        while(l<=r){\\n           int m=l+(r-l)/2;\\n           if(isBadVersion(m)){\\n             ans=m;\\n             r=m-1;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1498375,
                "title": "binary-search-on-the-answer-approach-with-lower-bound-built-in-function",
                "content": "[This is kind of a shitpost lol]\\nI\\'m creating a range iterator, which I\\'ll use with lower_bound to search for answer.\\n```cpp\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\n\\nclass range {\\n  using ll = long long;\\n  ll strt;\\n  ll last;\\n\\npublic:\\n  range(ll l, ll r) : strt(l), last(r) {}\\n\\n  struct const_iterator {\\n    using iterator_category = std::random_access_iterator_tag;\\n    using difference_type = std::ptrdiff_t;\\n    using value_type = ll;\\n    using pointer = ll;\\n    using reference = const ll &;\\n\\n    pointer m_ptr;\\n\\n    const_iterator() =default;\\n    const_iterator(pointer ptr) : m_ptr(ptr) {}\\n    const_iterator(const const_iterator &iter) = default;\\n\\n    reference operator*() const { return m_ptr; }\\n\\n    const_iterator &operator++() {\\n      m_ptr++;\\n      return *this;\\n    }\\n    const_iterator operator++(int) {\\n      auto tmp = *this;\\n      ++(*this);\\n      return tmp;\\n    }\\n\\n    const_iterator &operator--() {\\n      m_ptr--;\\n      return *this;\\n    }\\n\\n    const_iterator operator--(int) {\\n      auto tmp = *this;\\n      --(*this);\\n      return tmp;\\n    }\\n    friend const_iterator operator+(const const_iterator &self,\\n                                    const difference_type &other) {\\n      return const_iterator(self.m_ptr + other);\\n    }\\n    const_iterator operator+=(const difference_type &other) {\\n      return *this = *this + other;\\n    }\\n    difference_type operator-(const const_iterator &other) {\\n      return this->m_ptr - other.m_ptr;\\n    }\\n    difference_type operator-=(const const_iterator &other) {\\n      return this->m_ptr - other.m_ptr;\\n    }\\n\\n    bool operator<(const const_iterator &b) const {\\n      return this->m_ptr < b.m_ptr;\\n    }\\n    bool operator>(const const_iterator &b) const {\\n      return this->m_ptr > b.m_ptr;\\n    }\\n    friend bool operator==(const const_iterator &a, const const_iterator &b) {\\n      return a.m_ptr == b.m_ptr;\\n    }\\n\\n    friend bool operator!=(const const_iterator &a, const const_iterator &b) {\\n      return a.m_ptr != b.m_ptr;\\n    }\\n    bool operator<=(const const_iterator &b) const {\\n      return this->m_ptr < b.m_ptr;\\n    }\\n    bool operator>=(const const_iterator &b) const {\\n      return this->m_ptr > b.m_ptr;\\n    }\\n  };\\n\\n  const const_iterator cbegin() { return const_iterator(strt); }\\n  const const_iterator cend() { return const_iterator(last); }\\n  const const_iterator begin() { return const_iterator(strt); }\\n  const const_iterator end() { return const_iterator(last); }\\n};\\n\\nclass Solution {\\npublic:\\n  int firstBadVersion(int n) {\\n    auto rng = range(0, ((long long)n) + 1);\\n    auto it = std::lower_bound(rng.begin(), rng.end(), true, [](auto  x, bool y) {\\n      return isBadVersion(x) < y;\\n    });\\n    return it - rng.begin();\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\n\\nclass range {\\n  using ll = long long;\\n  ll strt;\\n  ll last;\\n\\npublic:\\n  range(ll l, ll r) : strt(l), last(r) {}\\n\\n  struct const_iterator {\\n    using iterator_category = std::random_access_iterator_tag;\\n    using difference_type = std::ptrdiff_t;\\n    using value_type = ll;\\n    using pointer = ll;\\n    using reference = const ll &;\\n\\n    pointer m_ptr;\\n\\n    const_iterator() =default;\\n    const_iterator(pointer ptr) : m_ptr(ptr) {}\\n    const_iterator(const const_iterator &iter) = default;\\n\\n    reference operator*() const { return m_ptr; }\\n\\n    const_iterator &operator++() {\\n      m_ptr++;\\n      return *this;\\n    }\\n    const_iterator operator++(int) {\\n      auto tmp = *this;\\n      ++(*this);\\n      return tmp;\\n    }\\n\\n    const_iterator &operator--() {\\n      m_ptr--;\\n      return *this;\\n    }\\n\\n    const_iterator operator--(int) {\\n      auto tmp = *this;\\n      --(*this);\\n      return tmp;\\n    }\\n    friend const_iterator operator+(const const_iterator &self,\\n                                    const difference_type &other) {\\n      return const_iterator(self.m_ptr + other);\\n    }\\n    const_iterator operator+=(const difference_type &other) {\\n      return *this = *this + other;\\n    }\\n    difference_type operator-(const const_iterator &other) {\\n      return this->m_ptr - other.m_ptr;\\n    }\\n    difference_type operator-=(const const_iterator &other) {\\n      return this->m_ptr - other.m_ptr;\\n    }\\n\\n    bool operator<(const const_iterator &b) const {\\n      return this->m_ptr < b.m_ptr;\\n    }\\n    bool operator>(const const_iterator &b) const {\\n      return this->m_ptr > b.m_ptr;\\n    }\\n    friend bool operator==(const const_iterator &a, const const_iterator &b) {\\n      return a.m_ptr == b.m_ptr;\\n    }\\n\\n    friend bool operator!=(const const_iterator &a, const const_iterator &b) {\\n      return a.m_ptr != b.m_ptr;\\n    }\\n    bool operator<=(const const_iterator &b) const {\\n      return this->m_ptr < b.m_ptr;\\n    }\\n    bool operator>=(const const_iterator &b) const {\\n      return this->m_ptr > b.m_ptr;\\n    }\\n  };\\n\\n  const const_iterator cbegin() { return const_iterator(strt); }\\n  const const_iterator cend() { return const_iterator(last); }\\n  const const_iterator begin() { return const_iterator(strt); }\\n  const const_iterator end() { return const_iterator(last); }\\n};\\n\\nclass Solution {\\npublic:\\n  int firstBadVersion(int n) {\\n    auto rng = range(0, ((long long)n) + 1);\\n    auto it = std::lower_bound(rng.begin(), rng.end(), true, [](auto  x, bool y) {\\n      return isBadVersion(x) < y;\\n    });\\n    return it - rng.begin();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462171,
                "title": "c-two-solutions-recursion-optimized-using-binary-search",
                "content": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\n///////Recursion//////\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n       if(n<1) return 1;\\n       if(!isBadVersion(n)) return n+1;\\n       return firstBadVersion(n-1);\\n    }\\n};\\n\\n\\n///////Binary Search//////\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n       if(n<1) return 1;\\n       int ans=1,l=1,r=n;\\n       while(l<=r){\\n           int m=l+(r-l)/2;\\n           if(isBadVersion(m)){\\n             ans=m;\\n             r=m-1;\\n           }\\n           else l=m+1;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\n///////Recursion//////\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n       if(n<1) return 1;\\n       if(!isBadVersion(n)) return n+1;\\n       return firstBadVersion(n-1);\\n    }\\n};\\n\\n\\n///////Binary Search//////\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n       if(n<1) return 1;\\n       int ans=1,l=1,r=n;\\n       while(l<=r){\\n           int m=l+(r-l)/2;\\n           if(isBadVersion(m)){\\n             ans=m;\\n             r=m-1;\\n           }\\n           else l=m+1;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606617,
                "title": "kotlin",
                "content": "```\\nclass Solution: VersionControl() {\\n    override fun firstBadVersion(number: Int) : Int {\\n        var high: Int = number\\n        var low: Int = 0\\n        \\n        while (low < high) {\\n            val mid: Int = low + ((high - low) / 2)\\n            val isBad: Boolean = isBadVersion(mid)\\n            \\n            if (isBad) {\\n                high = mid\\n            } else {\\n                low = mid + 1\\n            }\\n        }\\n        \\n        return high\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution: VersionControl() {\\n    override fun firstBadVersion(number: Int) : Int {\\n        var high: Int = number\\n        var low: Int = 0\\n        \\n        while (low < high) {\\n            val mid: Int = low + ((high - low) / 2)\\n            val isBad: Boolean = isBadVersion(mid)\\n            \\n            if (isBad) {\\n                high = mid\\n            } else {\\n                low = mid + 1\\n            }\\n        }\\n        \\n        return high\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340759,
                "title": "simple-binary-search-c-with-detailed-explanation",
                "content": "Since we need leftmost value, we can use another binary search that is setting high to mid and return low.\\n\\nThink about the case when mid is bad version, in that case the bad version started at some x <= mid, the required result will be in range [low, mid] so we set high to mid.\\n\\nThe terminating condition is low >= high, in that case low is first bad version since any elements below low are always good version.\\n\\n```csharp\\npublic int FirstBadVersion(int n) \\n{\\n\\tint low = 0;\\n\\tint high = n;\\n\\n\\twhile(low < high)\\n\\t{\\n\\t\\tint mid = low + (high - low)/2;\\n\\t\\tif(IsBadVersion(mid))\\n\\t\\t{\\n\\t\\t\\thigh = mid;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn low;\\n}\\n```\\n\\nIt can be re-written in general binary search, note that we update low in else branch, as follows:\\n\\n``` csharp\\npublic int FirstBadVersion(int n) \\n{\\n\\tint low = 0;\\n\\tint high = n - 1;\\n\\tint mid;\\n\\n\\twhile(low <= high)\\n\\t{\\n\\t\\tmid = low + (high - low)/2;\\n\\n\\t\\tif(IsBadVersion(mid))\\n\\t\\t{\\n\\t\\t\\thigh = mid - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlow = mid + 1;\\n\\t\\t}           \\n\\t}\\n\\treturn low;\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```csharp\\npublic int FirstBadVersion(int n) \\n{\\n\\tint low = 0;\\n\\tint high = n;\\n\\n\\twhile(low < high)\\n\\t{\\n\\t\\tint mid = low + (high - low)/2;\\n\\t\\tif(IsBadVersion(mid))\\n\\t\\t{\\n\\t\\t\\thigh = mid;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn low;\\n}\\n```\n``` csharp\\npublic int FirstBadVersion(int n) \\n{\\n\\tint low = 0;\\n\\tint high = n - 1;\\n\\tint mid;\\n\\n\\twhile(low <= high)\\n\\t{\\n\\t\\tmid = low + (high - low)/2;\\n\\n\\t\\tif(IsBadVersion(mid))\\n\\t\\t{\\n\\t\\t\\thigh = mid - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlow = mid + 1;\\n\\t\\t}           \\n\\t}\\n\\treturn low;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 215805,
                "title": "python-solution",
                "content": "Time complexity: `O(log n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        i = 1\\n        j = n\\n        while i < j:\\n            mid = i + (j-i) // 2\\n            if isBadVersion(mid):\\n                j = mid\\n            else:\\n                i = mid+1\\n        return i\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        i = 1\\n        j = n\\n        while i < j:\\n            mid = i + (j-i) // 2\\n            if isBadVersion(mid):\\n                j = mid\\n            else:\\n                i = mid+1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344962,
                "title": "java-code-beats-95-in-time-complexity",
                "content": "**Beats 95% in Time Complexity**\\n\\n# Code\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n       int start = 1;\\n            while(start <= n){ \\n                int mid = start+(n-start)/2;\\n                if(isBadVersion(mid)){\\n                    n = mid-1;\\n                }\\n                else start = mid+1;\\n            }\\n            return start;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n       int start = 1;\\n            while(start <= n){ \\n                int mid = start+(n-start)/2;\\n                if(isBadVersion(mid)){\\n                    n = mid-1;\\n                }\\n                else start = mid+1;\\n            }\\n            return start;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207455,
                "title": "first-bad-version-easy-solution-in-c",
                "content": "# Intuition\\n- Since we need to find the first bad product and all after that are same.\\n-  We can make use of binary search to shorten the no of products.\\n\\n# Approach\\n- Initialize s with 0 and e with end(n) and calculate mid using it\\n- Check if mid is a bad product, if its a bad product then check for mid-1 also\\n- If mid-1 is not a bad product then we can say that the previous products are good version and then return mid\\n- if mid-1 is bad product then follow the next conditions of binary search as given below\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s = 0;\\n        int e = n;\\n        int mid = s + (e-s)/2;\\n        while(s<=e){\\n            if(isBadVersion(mid)==true){\\n               if(isBadVersion(mid-1)==false){\\n                    return mid;\\n               }\\n            }\\n            if(isBadVersion(mid)==false){\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s)/2;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s = 0;\\n        int e = n;\\n        int mid = s + (e-s)/2;\\n        while(s<=e){\\n            if(isBadVersion(mid)==true){\\n               if(isBadVersion(mid-1)==false){\\n                    return mid;\\n               }\\n            }\\n            if(isBadVersion(mid)==false){\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s)/2;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145817,
                "title": "easy-binary-search-c-code-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int binarySearch(int n,int l,int r){\\n     \\n        if(r>=l){\\n            int mid=l+(r-l)/2;\\n            if(isBadVersion(mid-1)==false && isBadVersion(mid)==true){\\n                return mid;\\n            }\\n            if(isBadVersion(mid-1)==true && isBadVersion(mid)==true){\\n                return binarySearch(n,l,mid-1);\\n            }\\n            if(isBadVersion(mid)==false){\\n                return binarySearch(n,mid+1,r);\\n            }\\n\\n        }\\n        return -1;\\n    }\\n    int firstBadVersion(int n) {\\n       \\n       int l=1,r=n;\\n       return binarySearch(n,1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int binarySearch(int n,int l,int r){\\n     \\n        if(r>=l){\\n            int mid=l+(r-l)/2;\\n            if(isBadVersion(mid-1)==false && isBadVersion(mid)==true){\\n                return mid;\\n            }\\n            if(isBadVersion(mid-1)==true && isBadVersion(mid)==true){\\n                return binarySearch(n,l,mid-1);\\n            }\\n            if(isBadVersion(mid)==false){\\n                return binarySearch(n,mid+1,r);\\n            }\\n\\n        }\\n        return -1;\\n    }\\n    int firstBadVersion(int n) {\\n       \\n       int l=1,r=n;\\n       return binarySearch(n,1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065272,
                "title": "first-bad-version-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 58ms || beats: 91%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 41.2Mb || beats: 96% \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for isBadVersion()\\n * \\n * @param {integer} version number\\n * @return {boolean} whether the version is bad\\n * isBadVersion = function(version) {\\n *     ...\\n * };\\n */\\n\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        let start = 0;\\n        let end = n;\\n        let mid = Math.floor((start + end)/2);\\n        while(start < end) {\\n            if(isBadVersion(mid) && !isBadVersion(mid - 1)) return mid;\\n            else if(!isBadVersion(mid) && isBadVersion(mid + 1)) return mid + 1;\\n            else if(!isBadVersion(mid)) start = mid;\\n            else end = mid;\\n            mid = Math.floor((start + end)/2);\\n        }\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for isBadVersion()\\n * \\n * @param {integer} version number\\n * @return {boolean} whether the version is bad\\n * isBadVersion = function(version) {\\n *     ...\\n * };\\n */\\n\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        let start = 0;\\n        let end = n;\\n        let mid = Math.floor((start + end)/2);\\n        while(start < end) {\\n            if(isBadVersion(mid) && !isBadVersion(mid - 1)) return mid;\\n            else if(!isBadVersion(mid) && isBadVersion(mid + 1)) return mid + 1;\\n            else if(!isBadVersion(mid)) start = mid;\\n            else end = mid;\\n            mid = Math.floor((start + end)/2);\\n        }\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2984733,
                "title": "python3-while-loop-binary-search",
                "content": "https://leetcode.com/submissions/detail/869576931/\\nRuntime: 28 ms, faster than 93.52% of Python3 online submissions for First Bad Version.\\nMemory Usage: 13.8 MB, less than 62.32% of Python3 online submissions for First Bad Version.\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low, high = 1, n\\n        while low<high:\\n            mid = (low + high)//2\\n            if isBadVersion(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n        return low \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low, high = 1, n\\n        while low<high:\\n            mid = (low + high)//2\\n            if isBadVersion(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n        return low \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802692,
                "title": "python-simple-solution-to-find-the-first-bad-version-in-o-log-n-using-binary-search",
                "content": "# Intuition\\nUse Binary seach to solve the problem\\n\\n# Approach\\nFind whether the mid version is BadVersion or not, using Binary search, reduce the n versions to halves until the source of bad version found.\\n\\n# Complexity\\n- Time complexity: $$O(log n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        if n==1 and isBadVersion(n):\\n            return 1\\n        l = 1\\n        r = n\\n\\n        while l <= r:\\n            mid = l + (r-l) // 2\\n            if isBadVersion(mid):\\n                if isBadVersion(mid -1) == False:\\n                    return mid\\n                else:\\n                    r = mid-1\\n            else:\\n               l = mid + 1 \\n            \\n        return 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        if n==1 and isBadVersion(n):\\n            return 1\\n        l = 1\\n        r = n\\n\\n        while l <= r:\\n            mid = l + (r-l) // 2\\n            if isBadVersion(mid):\\n                if isBadVersion(mid -1) == False:\\n                    return mid\\n                else:\\n                    r = mid-1\\n            else:\\n               l = mid + 1 \\n            \\n        return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515933,
                "title": "python-simple-solution-faster-than-98-50",
                "content": "Simple python solution using binary search algorithm. Faster that 98.50% online solutions.\\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2016733,
                "title": "javascript-o-logn-understandable-solution",
                "content": "```\\nvar solution = function(isBadVersion) {\\n  \\n    return function(n) {\\n        let left = 0;\\n        let right = n;\\n        let mid = 0;\\n        while(right-left > 1){\\n            mid = Math.floor((right + left)/2);\\n            if(isBadVersion(mid)){\\n                right = mid;\\n            }else left = mid;\\n        }\\n        return right\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar solution = function(isBadVersion) {\\n  \\n    return function(n) {\\n        let left = 0;\\n        let right = n;\\n        let mid = 0;\\n        while(right-left > 1){\\n            mid = Math.floor((right + left)/2);\\n            if(isBadVersion(mid)){\\n                right = mid;\\n            }else left = mid;\\n        }\\n        return right\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1631094,
                "title": "278-first-bad-version-java-a-clean-and-simple-solution-with-explanation",
                "content": "```java\\npublic int firstBadVersion(int n) {\\n    // The basic idea can be illustrated below:\\n\\t// n = 6, firstBadVersion = 5\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t// |     |        |\\n\\t// l     m        r\\n\\t// isBadVersion(m) = false, move right\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//          |  |  |\\n\\t//          l  m  r\\n\\t// isBadVersion(m) = true, move left\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//          |  |\\n\\t//          l  r\\n\\t//          m\\n\\t// isBadVersion(m) = false, move right\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//             |\\n\\t//             r\\n\\t//             l\\n\\t//             m\\n\\t// return l\\n\\n\\t// Q: why do we need l = m + 1?\\n\\t// A: because l = m will end up to an infinite loop, for example:\\n\\t// n = 6, firstBadVersion = 5\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t// |     |        |\\n\\t// l     m        r\\n\\t// isBadVersion(m) = false, move right\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//       |  |     |\\n\\t//       l  m     r\\n\\t// isBadVersion(m) = false, move right\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//          |  |  |\\n\\t//          l  m  r\\n\\t// isBadVersion(m) = true, move left\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//          |  |\\n\\t//          l  r\\n\\t//          m\\n\\t// isBadVersion(m) = false, move right\\n\\t// at this point, if set l = m, then l will remain its current index and lead to an infinite loop.\\n\\n\\tif (isBadVersion(1)) {\\n\\t\\treturn 1;\\n\\t}\\n\\n\\tint l = 1;\\n\\tint r = n;\\n\\n\\twhile (l < r) {\\n\\t\\tint m = l + (r - l) / 2;\\n\\t\\tif (isBadVersion(m)) {\\n\\t\\t\\t// move left\\n\\t\\t\\tr = m;\\n\\t\\t} else {\\n\\t\\t\\t// move right\\n\\t\\t\\tl = m + 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn l;\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```java\\npublic int firstBadVersion(int n) {\\n    // The basic idea can be illustrated below:\\n\\t// n = 6, firstBadVersion = 5\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t// |     |        |\\n\\t// l     m        r\\n\\t// isBadVersion(m) = false, move right\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//          |  |  |\\n\\t//          l  m  r\\n\\t// isBadVersion(m) = true, move left\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//          |  |\\n\\t//          l  r\\n\\t//          m\\n\\t// isBadVersion(m) = false, move right\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//             |\\n\\t//             r\\n\\t//             l\\n\\t//             m\\n\\t// return l\\n\\n\\t// Q: why do we need l = m + 1?\\n\\t// A: because l = m will end up to an infinite loop, for example:\\n\\t// n = 6, firstBadVersion = 5\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t// |     |        |\\n\\t// l     m        r\\n\\t// isBadVersion(m) = false, move right\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//       |  |     |\\n\\t//       l  m     r\\n\\t// isBadVersion(m) = false, move right\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//          |  |  |\\n\\t//          l  m  r\\n\\t// isBadVersion(m) = true, move left\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//          |  |\\n\\t//          l  r\\n\\t//          m\\n\\t// isBadVersion(m) = false, move right\\n\\t// at this point, if set l = m, then l will remain its current index and lead to an infinite loop.\\n\\n\\tif (isBadVersion(1)) {\\n\\t\\treturn 1;\\n\\t}\\n\\n\\tint l = 1;\\n\\tint r = n;\\n\\n\\twhile (l < r) {\\n\\t\\tint m = l + (r - l) / 2;\\n\\t\\tif (isBadVersion(m)) {\\n\\t\\t\\t// move left\\n\\t\\t\\tr = m;\\n\\t\\t} else {\\n\\t\\t\\t// move right\\n\\t\\t\\tl = m + 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1615549,
                "title": "not-sure-what-this-is-asking-click-here-also-solution-for-js",
                "content": "This challenge confused me for the longest time in part beause I simply could not understand what the heck it was asking for.\\nWhen you run your code, there are two inputs. The first is the current version of the broken software (This is what is passed into your function as \\'n\\'.) The second number is the first broken version. i.e. The answer that you\\'re supposed to return. However, before you get too excited, it\\'s not accessible to you in the code. Wamp wamp.\\n\\nSo YOUR job is to start taking numbers between 1 and n (inclusive) and passing them into isBadVersion() one at a time. This will return a 1 or 0 (true/false) until you find the earliest broken version number. \\n\\nI found it helped to get a piece of paper and make a number line to work through it a couple times (Also to print the current left, mid, and right points in the loop so you could see what the heck was going on).\\n\\n```    \\n    return function(n) {\\n\\n        let left = 0\\n        let right = n\\n        let mid = n;\\n        while(left != (right-1)){\\n            mid = Math.floor((left + right)/2)\\n            if(isBadVersion(mid) == 0) {\\n                left = mid\\n            }\\n            else{\\n                right = mid\\n            }\\n        }\\n        return right\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "This challenge confused me for the longest time in part beause I simply could not understand what the heck it was asking for.\\nWhen you run your code, there are two inputs. The first is the current version of the broken software (This is what is passed into your function as \\'n\\'.) The second number is the first broken version. i.e. The answer that you\\'re supposed to return. However, before you get too excited, it\\'s not accessible to you in the code. Wamp wamp.\\n\\nSo YOUR job is to start taking numbers between 1 and n (inclusive) and passing them into isBadVersion() one at a time. This will return a 1 or 0 (true/false) until you find the earliest broken version number. \\n\\nI found it helped to get a piece of paper and make a number line to work through it a couple times (Also to print the current left, mid, and right points in the loop so you could see what the heck was going on).\\n\\n```    \\n    return function(n) {\\n\\n        let left = 0\\n        let right = n\\n        let mid = n;\\n        while(left != (right-1)){\\n            mid = Math.floor((left + right)/2)\\n            if(isBadVersion(mid) == 0) {\\n                left = mid\\n            }\\n            else{\\n                right = mid\\n            }\\n        }\\n        return right\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1514905,
                "title": "javascript-99-clean-binary-search",
                "content": "```\\nconst solution = isBadVersion => \\n  (n, l = 1, r = n) => {\\n    while (l <= r) {\\n      const mid = Math.floor((l + r) / 2);\\n      if (!isBadVersion(mid)) l = mid + 1;\\n      else r = mid - 1;\\n    }\\n    return l\\n  };\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst solution = isBadVersion => \\n  (n, l = 1, r = n) => {\\n    while (l <= r) {\\n      const mid = Math.floor((l + r) / 2);\\n      if (!isBadVersion(mid)) l = mid + 1;\\n      else r = mid - 1;\\n    }\\n    return l\\n  };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 913553,
                "title": "easy-solution",
                "content": "# if (FIND==USEFUL)\\n#  {\\n#  \\tcout<<UPVOTE;\\n#  }\\n#  else\\n#  {\\n#  \\tcout<<DOWNVOTE\\uD83D\\uDE22;\\n# }\\n\\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        \\n        int l=1;\\n        int h=n;\\n        \\n        while(l<=h)\\n        {\\n            int m=l + (h-l)/2;\\n            if(isBadVersion(m)==true)\\n            {\\n                h=m-1;;\\n            }\\n            else\\n            {\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        \\n        int l=1;\\n        int h=n;\\n        \\n        while(l<=h)\\n        {\\n            int m=l + (h-l)/2;\\n            if(isBadVersion(m)==true)\\n            {\\n                h=m-1;;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 344266,
                "title": "python3-first-bad-version-binary-search",
                "content": "```\\n# The isBadVersion API is already defined for you.\\n# @param version, an integer\\n# @return a bool\\n# def isBadVersion(version):\\n\\nclass Solution(object):\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        l,r = 0, n\\n        while l <=r:\\n            m = (l+r)//2\\n\\t\\t\\t# we find the target:\\n            if isBadVersion(m-1) == False and isBadVersion(m)== True:\\n                return m\\n\\t\\t\\t# we didn\\'t find the target, we eleminate the half that the target cannot lie\\n            else:\\n                if isBadVersion(m) == False:\\n                    l = m +1\\n                else:\\n                    r = m -1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# @param version, an integer\\n# @return a bool\\n# def isBadVersion(version):\\n\\nclass Solution(object):\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        l,r = 0, n\\n        while l <=r:\\n            m = (l+r)//2\\n\\t\\t\\t# we find the target:\\n            if isBadVersion(m-1) == False and isBadVersion(m)== True:\\n                return m\\n\\t\\t\\t# we didn\\'t find the target, we eleminate the half that the target cannot lie\\n            else:\\n                if isBadVersion(m) == False:\\n                    l = m +1\\n                else:\\n                    r = m -1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71298,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution(object):\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        start, end = 1, n\\n        while start < end:\\n            mid = start + (end - start) / 2\\n            if isBadVersion(mid):\\n                # if mid is bad, any version newer than mid is bad.\\n                end = mid\\n            else:\\n                # if mid is good, any version older than mid + 1 is good \\n                start = mid + 1\\n        return start\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        start, end = 1, n\\n        while start < end:\\n            mid = start + (end - start) / 2\\n            if isBadVersion(mid):\\n                # if mid is bad, any version newer than mid is bad.\\n                end = mid\\n            else:\\n                # if mid is good, any version older than mid + 1 is good \\n                start = mid + 1\\n        return start\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71430,
                "title": "c-o-logn-0-ms-solution",
                "content": "Basically the problem is a variant of **upper_bound()** / **lower_bound()** problem.\\n<BR>So we can follow the standard implementation to solve it.\\n\\n    int firstBadVersion(int n) {\\n        int lo = 1, hi = n, mid;\\n        while (lo < hi) {\\n            mid = lo + ((hi - lo) >> 1);\\n            isBadVersion(mid) ? (hi = mid) : (lo = mid + 1);\\n        }\\n        return hi;\\n    }",
                "solutionTags": [],
                "code": "Basically the problem is a variant of **upper_bound()** / **lower_bound()** problem.\\n<BR>So we can follow the standard implementation to solve it.\\n\\n    int firstBadVersion(int n) {\\n        int lo = 1, hi = n, mid;\\n        while (lo < hi) {\\n            mid = lo + ((hi - lo) >> 1);\\n            isBadVersion(mid) ? (hi = mid) : (lo = mid + 1);\\n        }\\n        return hi;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71426,
                "title": "java-binary-search-with-recursive-implement",
                "content": "/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n\\n    public int firstBadVersion(int n) {\\n        \\n        if(n==0) {\\n            return 0;\\n        }\\n    \\n       return helper(n,1,n);\\n    }\\n    \\n    \\n    public int helper(int n, int start, int end) {\\n        \\n        if(start>=end) {\\n            return start;\\n        }\\n        int middle = start+(end-start)/2;\\n        \\n        if(isBadVersion(middle)) {\\n            return helper(n,start,middle);\\n        } else {\\n            return helper(n,middle+1,end);\\n            \\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution extends VersionControl {\\n\\n    public int firstBadVersion(int n) {\\n        \\n        if(n==0) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3864389,
                "title": "leetcode-first-bad-version-efficient-binary-search-solution-in-c",
                "content": "# Intuition\\nThe problem can be solved using binary search, an efficient algorithm to find an element in a sorted array. In this case, we have a range of versions from 1 to n, and we need to find the first bad version. The versions are sorted in ascending order, and we want to minimize the number of checks (API calls) to determine whether a version is bad or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nThe binary search algorithm has a time complexity of O(log n), which is very efficient compared to a linear search that would have O(n) time complexity.\\n\\n- Space complexity:\\nThe space complexity of this approach is O(1), as we only use a constant amount of extra space for the pointers low and high.\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        if(n==1)\\n        return n;\\n\\n        int low=1,high=n;\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(isBadVersion(mid))\\n            high=mid;\\n            else\\n            low=mid+1;\\n\\n        }\\n        return low;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        if(n==1)\\n        return n;\\n\\n        int low=1,high=n;\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(isBadVersion(mid))\\n            high=mid;\\n            else\\n            low=mid+1;\\n\\n        }\\n        return low;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446112,
                "title": "binary-search-beats-98-56-with-explanation-and-proof",
                "content": "# Approach\\n- We will initialize two pointers left and right to 0, n respectively. \\n\\n- We will perfrom binary Search in order to find first bad version. \\n\\n- First we will check that if `isBadVersion(mid)` is True or not. If its True then version before mid will also be bad so we will set right pointer to mid and will search in left half.\\n\\n- If `isBadVersion(mid)` is not True then we will set left pointer to `mid+1` and will search in right half. Search will continue till left < right and at the end we will return left `l`\\n\\n- This Solution has Time Complexity of `O(log n)` as we are using binary search and Space Complexity of `O(1)` as we are using constant memory space. \\n\\n# Code\\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l, r = 0, n \\n        while l < r:\\n            mid = (l+r) // 2\\n            if isBadVersion(mid): r = mid\\n            else: l = mid+1\\n        return l\\n```\\n# Proof \\n\\n![Screenshot 2023-04-23 at 10.40.21 AM.png](https://assets.leetcode.com/users/images/930fe845-57cf-4f15-a9ef-27817fc8b354_1682226687.00638.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l, r = 0, n \\n        while l < r:\\n            mid = (l+r) // 2\\n            if isBadVersion(mid): r = mid\\n            else: l = mid+1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375529,
                "title": "100-runtime-66-25-memory-beats-with-explanation-using-binary-search",
                "content": "# Intuition\\nThis code implements a binary search algorithm to find the first \"bad\" version out of \"n\" versions given as an input. Here, \"bad\" implies a version that is to be avoided. \\n\\n# Approach\\nThe code starts with initializing the search space by keeping the left pointer as zero and the right pointer as n. Then, the code continuously partitions the search space into halves by calculating the midpoint and checks for bad versions. If a bad version is encountered, the code moves the right pointer to the midpoint and records this result as a candidate for the first bad version. On the other hand, if a good version is encountered, the code moves the left pointer to the midpoint+1 and records the maximum good version possible so far. The code repeats this process until the left and right pointers meet. Finally, the code checks if the maximum good version found so far is the second last version (good version) or the last version (bad version) and returns the corresponding result.\\n\\n\\n\\n# Complexity\\n- Time complexity O(log n):\\nThe time complexity of this algorithm is O(log n) as it uses binary search to find the first bad version, resulting in logarithmic time complexity.\\n\\n- Space complexity O(1):\\nThe space complexity of this algorithm is O(1) as it only uses constant space variables regardless of the size of input n.\\n\\n\\n\\n# Code\\n```\\n/**\\n * The knows API is defined in the parent class VersionControl.\\n *     func isBadVersion(_ version: Int) -> Bool{}\\n */\\n\\nclass Solution : VersionControl {\\n    func firstBadVersion(_ n: Int) -> Int {\\n       // Initialize left, right pointers and result variable.\\n        var left: Int = 0\\n        var right: Int = n\\n        var result: Int = 1\\n        // Initialize maxGoodVersion as 0.\\n        var maxGoodVersion = 0\\n        // While the left pointer is less than the right pointer.\\n        while left < right {\\n          // Find the midpoint of the current search space.\\n            var mid = (left + right)/2\\n            // Check if the current version is bad.\\n            if isBadVersion(mid){\\n                // If the current version is bad, move the right pointer to the midpoint, \\n                // record this value for future use and check if the previous version is the maximum good version.\\n                right = mid \\n                result = mid\\n                if result == maxGoodVersion + 1{\\n                    return result\\n                }\\n            }else{\\n                // If the current version is good, move the left pointer to the midpoint+1, \\n                // record the maximum good version so far, and repeat the process.\\n                maxGoodVersion = mid\\n                left = mid + 1\\n            }\\n        }\\n        // If the maximum good version found so far is the second last version, it is the answer.\\n        if maxGoodVersion == n - 1{\\n            return n\\n        }\\n        // Otherwise, return the candidate for the first bad version.\\n        return result\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\n/**\\n * The knows API is defined in the parent class VersionControl.\\n *     func isBadVersion(_ version: Int) -> Bool{}\\n */\\n\\nclass Solution : VersionControl {\\n    func firstBadVersion(_ n: Int) -> Int {\\n       // Initialize left, right pointers and result variable.\\n        var left: Int = 0\\n        var right: Int = n\\n        var result: Int = 1\\n        // Initialize maxGoodVersion as 0.\\n        var maxGoodVersion = 0\\n        // While the left pointer is less than the right pointer.\\n        while left < right {\\n          // Find the midpoint of the current search space.\\n            var mid = (left + right)/2\\n            // Check if the current version is bad.\\n            if isBadVersion(mid){\\n                // If the current version is bad, move the right pointer to the midpoint, \\n                // record this value for future use and check if the previous version is the maximum good version.\\n                right = mid \\n                result = mid\\n                if result == maxGoodVersion + 1{\\n                    return result\\n                }\\n            }else{\\n                // If the current version is good, move the left pointer to the midpoint+1, \\n                // record the maximum good version so far, and repeat the process.\\n                maxGoodVersion = mid\\n                left = mid + 1\\n            }\\n        }\\n        // If the maximum good version found so far is the second last version, it is the answer.\\n        if maxGoodVersion == n - 1{\\n            return n\\n        }\\n        // Otherwise, return the candidate for the first bad version.\\n        return result\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051362,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long long l = 1, r = n;\\n        while(l <= r) {\\n            long long mid = (l + r) / 2;\\n            if(isBadVersion(mid)) r = mid - 1;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long long l = 1, r = n;\\n        while(l <= r) {\\n            long long mid = (l + r) / 2;\\n            if(isBadVersion(mid)) r = mid - 1;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980298,
                "title": "cpp-python-binary-search-3ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- This problem is a version of binary search much like findind the first occurrence of element in sorted array containing duplicate elements.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Applying binary search, if a bad version is found we check if the number on the left ( mid-1 ) is also a bad version or not.\\n- If the number on the left is not a bad version then we can simply return the current number as it is the first bad version.\\n- If the number on the left is a bad version then we can set `r = mid-1` and continue with binary search.\\n- If current number is not a bad version then we can set `l = mid+1`.\\n\\n# Complexity\\n- Time complexity: **O(log n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nCPP / C++\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int l = 1, r = n;\\n\\n        while( l<=r ) {\\n            int mid = l + (r-l)/2;\\n            if( isBadVersion(mid) ) {\\n                if( isBadVersion(mid) != isBadVersion(mid-1) ) return mid;\\n                else r = mid-1;\\n            }\\n            else l = mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n---\\nPYTHON\\n```class Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l,r = 1, n\\n        while l<=r :\\n            mid = l + (r-l)//2\\n            if isBadVersion( mid ):\\n                if isBadVersion( mid )!=isBadVersion( mid-1 ) :\\n                    return mid\\n                else :\\n                    r = mid-1\\n            elif not isBadVersion( mid ):\\n                l = mid+1\\n        return 0\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int l = 1, r = n;\\n\\n        while( l<=r ) {\\n            int mid = l + (r-l)/2;\\n            if( isBadVersion(mid) ) {\\n                if( isBadVersion(mid) != isBadVersion(mid-1) ) return mid;\\n                else r = mid-1;\\n            }\\n            else l = mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```class Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l,r = 1, n\\n        while l<=r :\\n            mid = l + (r-l)//2\\n            if isBadVersion( mid ):\\n                if isBadVersion( mid )!=isBadVersion( mid-1 ) :\\n                    return mid\\n                else :\\n                    r = mid-1\\n            elif not isBadVersion( mid ):\\n                l = mid+1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808776,
                "title": "binary-search-easy-java-code",
                "content": "# Code\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start=1,end=n;\\n        \\n        while(start<end){\\n            int mid=start+ (end-start)/2;\\n            \\n            if(isBadVersion(mid)==true){\\n                end=mid;\\n                \\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start=1,end=n;\\n        \\n        while(start<end){\\n            int mid=start+ (end-start)/2;\\n            \\n            if(isBadVersion(mid)==true){\\n                end=mid;\\n                \\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666426,
                "title": "100-acceptance-optimal-approach-binary-search",
                "content": "![image](https://assets.leetcode.com/users/images/4c4ede0d-bda4-4bae-bde7-927ed2e07953_1665010789.3143034.png)\\n![image](https://assets.leetcode.com/users/images/62297faa-b6d3-42f4-b5ec-aea152030069_1665010808.5824919.gif)\\n\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        if(n == 1) if(isBadVersion(n)) return n;\\n        int i = 1, j = n;\\n        int ans;\\n        long int mid;\\n        while(i<=j){\\n            mid = i + (j-i)/2;\\n            if(isBadVersion(mid)){\\n                ans = mid;\\n                j = mid-1;\\n            }\\n            if(isBadVersion(mid) == false) i = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        if(n == 1) if(isBadVersion(n)) return n;\\n        int i = 1, j = n;\\n        int ans;\\n        long int mid;\\n        while(i<=j){\\n            mid = i + (j-i)/2;\\n            if(isBadVersion(mid)){\\n                ans = mid;\\n                j = mid-1;\\n            }\\n            if(isBadVersion(mid) == false) i = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453936,
                "title": "c-0ms-most-efficient-solution",
                "content": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n\\t\\t// Considering low as 1\\n\\t\\t// And high as n\\n        int low = 1;\\n        int high = n;\\n\\t\\t// Continuing in the loop until we found a answer\\n        while(true){\\n            int mid = low + (high - low)/2;\\n\\t\\t\\t// Checking the base conditin i.e, whether the first and the last values are bad or not\\n\\t\\t\\t// if so they are bad then it is understandable that we reached all the way through starting and ending\\n\\t\\t\\t// points so obviously they would be bad\\n            if((mid==n or mid==1) and isBadVersion(mid)==true) return mid;\\n\\t\\t\\t// checking for the current value is false and the next one is true, so the bad ones start from mid+1\\n            else if((isBadVersion(mid) == false) and (isBadVersion(mid+1) == true)) return mid+1;\\n\\t\\t\\t// checking if the mid value is false so as far we haven\\'t encountered any false value so we can start from \\n\\t\\t\\t// that position\\n            else if(isBadVersion(mid) == false) low = mid+1;\\n\\t\\t\\t// If we encountered true then the true value starts from some way before so we need to go back\\n            else high = mid-1;\\n        }\\n    }\\n};\\n\\n```\\n![image](https://assets.leetcode.com/users/images/64cdebab-4ac8-4998-ae98-62674d44841e_1661006300.890129.png)\\n\\n**upvote if you understood and if it helped you**\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n\\t\\t// Considering low as 1\\n\\t\\t// And high as n\\n        int low = 1;\\n        int high = n;\\n\\t\\t// Continuing in the loop until we found a answer\\n        while(true){\\n            int mid = low + (high - low)/2;\\n\\t\\t\\t// Checking the base conditin i.e, whether the first and the last values are bad or not\\n\\t\\t\\t// if so they are bad then it is understandable that we reached all the way through starting and ending\\n\\t\\t\\t// points so obviously they would be bad\\n            if((mid==n or mid==1) and isBadVersion(mid)==true) return mid;\\n\\t\\t\\t// checking for the current value is false and the next one is true, so the bad ones start from mid+1\\n            else if((isBadVersion(mid) == false) and (isBadVersion(mid+1) == true)) return mid+1;\\n\\t\\t\\t// checking if the mid value is false so as far we haven\\'t encountered any false value so we can start from \\n\\t\\t\\t// that position\\n            else if(isBadVersion(mid) == false) low = mid+1;\\n\\t\\t\\t// If we encountered true then the true value starts from some way before so we need to go back\\n            else high = mid-1;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428905,
                "title": "c-python-java-best-optimized-approach-using-binary-search",
                "content": "#### C++\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for First Bad Version.\\nMemory Usage: 6 MB, less than 22.67% of C++ online submissions for First Bad Version.\\n\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s = 1;\\n        int e = n;\\n        while(s<e) {\\n            int mid = s + (e-s)/2;\\n            if(isBadVersion(mid)){\\n                e = mid;\\n            }\\n            else {\\n                s = mid + 1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\nTime Complexity - O(logN)\\nSpace Complexity - O(1)\\n#### Java\\nRuntime: 20 ms, faster than 65.20% of Java online submissions for First Bad Version.\\nMemory Usage: 41.2 MB, less than 26.56% of Java online submissions for First Bad Version.\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int s = 1;\\n        int e = n;\\n        while(s<e) {\\n            int mid = s+(e-s)/2;\\n            if(isBadVersion(mid)) {\\n                e = mid;\\n            }\\n            \\n            else {\\n                s = mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```\\nTime Complexity - O(logN)\\nSpace Complexity - O(1)\\n\\n#### Python\\nRuntime: 56 ms, faster than 23.61% of Python3 online submissions for First Bad Version.\\nMemory Usage: 13.9 MB, less than 61.83% of Python3 online submissions for First Bad Version.\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        s = 1\\n        e = n\\n        while(s<e):\\n            mid = s+(e-s)//2\\n            if(isBadVersion(mid)):\\n                e = mid\\n                \\n            else:\\n                s = mid+1\\n        return s\\n```\\nTime Complexity - O(logN)\\nSpace Complexity - O(1)\\n\\n##### I hope that you\\'ve found this useful. If you like the solution and find it understandable, then do upvote it & Share it with others.\\n##### It only motivates me to write more such posts, If you found any error, any suggestions then do comment for any query\\n##### Thanks alot ! Cheers to your coding",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s = 1;\\n        int e = n;\\n        while(s<e) {\\n            int mid = s + (e-s)/2;\\n            if(isBadVersion(mid)){\\n                e = mid;\\n            }\\n            else {\\n                s = mid + 1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int s = 1;\\n        int e = n;\\n        while(s<e) {\\n            int mid = s+(e-s)/2;\\n            if(isBadVersion(mid)) {\\n                e = mid;\\n            }\\n            \\n            else {\\n                s = mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        s = 1\\n        e = n\\n        while(s<e):\\n            mid = s+(e-s)//2\\n            if(isBadVersion(mid)):\\n                e = mid\\n                \\n            else:\\n                s = mid+1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414671,
                "title": "c-solution",
                "content": "```\\npublic class Solution : VersionControl {\\n    public int FirstBadVersion(int n) {\\n            int bad = 0;\\n            int low = 1;\\n            int high = n;\\n            while (low <= high)\\n            {\\n                int mid = low + (high - low) / 2;\\n                if (IsBadVersion(mid))\\n                {\\n                    bad = mid;\\n                    high = mid - 1;\\n                }\\n                else\\n                    low = mid + 1;\\n            }\\n            return bad;\\n    }\\n}",
                "solutionTags": [
                    "C#",
                    "Binary Tree"
                ],
                "code": "class Solution : VersionControl {\\n    public int FirstBadVersion(int n) {\\n            int bad = 0;\\n            int low = 1;\\n            int high = n;\\n            while (low <= high)\\n            {\\n                int mid = low + (high - low) / 2;\\n                if (IsBadVersion(mid))\\n                {\\n                    bad = mid;\\n                    high = mid - 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2397117,
                "title": "31-ms-faster-than-92-46-of-python3",
                "content": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        beg = 1\\n        end = n\\n        while beg <= end:\\n            mid = (beg+end)//2\\n            if isBadVersion(mid) == True:\\n                end = mid-1\\n            else:\\n                beg = mid+1\\n        return beg\\n        \\n```\\n\\nupvote if you find this helps :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        beg = 1\\n        end = n\\n        while beg <= end:\\n            mid = (beg+end)//2\\n            if isBadVersion(mid) == True:\\n                end = mid-1\\n            else:\\n                beg = mid+1\\n        return beg\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330703,
                "title": "now-now-onwards-i-will-never-use-beg-end-2-again",
                "content": "using (beg + end)/2 instead of mid= beg+(end-beg)/2  can lead to overflows(beg + end > 2147483647) as was the case this time, or change all the int variable to the long variables \\n\\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        \\n        \\n        int beg= 1, end= n, mid, ans=-1;\\n        \\n        while( beg<= end){\\n            mid= (beg+(end-beg)/2);\\n            \\n            if( isBadVersion(mid)==true){\\n                end= mid-1;\\n                ans= mid;\\n            }\\n            else{\\n                beg=mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        \\n        \\n        int beg= 1, end= n, mid, ans=-1;\\n        \\n        while( beg<= end){\\n            mid= (beg+(end-beg)/2);\\n            \\n            if( isBadVersion(mid)==true){\\n                end= mid-1;\\n                ans= mid;\\n            }\\n            else{\\n                beg=mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319817,
                "title": "c-solution",
                "content": "```\\npublic class Solution : VersionControl {\\n    public int FirstBadVersion(int n) {\\n        int i = 1,\\n            j = n;\\n        \\n        while (i <= j)\\n        {\\n            int mid = i + (j - i) / 2;\\n            \\n            if (IsBadVersion(mid))\\n            {\\n                j = mid - 1;\\n            }\\n            else\\n            {\\n                i = mid + 1;\\n            }\\n        }\\n        \\n        return j + 1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution : VersionControl {\\n    public int FirstBadVersion(int n) {\\n        int i = 1,\\n            j = n;\\n        \\n        while (i <= j)\\n        {\\n            int mid = i + (j - i) / 2;\\n            \\n            if (IsBadVersion(mid))\\n            {\\n                j = mid - 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2021988,
                "title": "javascript-binary-search-solution-with-short-comment-99-21-faster",
                "content": "```\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        let start = 1;\\n        let end = n;\\n        let mid = 0;\\n        \\n        while(start <= end) {\\n            mid = Math.floor((start + end) / 2);\\n            \\n            if(isBadVersion(mid)) {\\n                if(isBadVersion(mid - 1)) end = mid - 1;  // if mid bad is not *first* bad version, set end point to mid - 1\\n                else return mid;  // if mid is first bad version\\n            }\\n            else start = mid + 1; // if mid is not bad version, set start point to mid + 1\\n        }\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        let start = 1;\\n        let end = n;\\n        let mid = 0;\\n        \\n        while(start <= end) {\\n            mid = Math.floor((start + end) / 2);\\n            \\n            if(isBadVersion(mid)) {\\n                if(isBadVersion(mid - 1)) end = mid - 1;  // if mid bad is not *first* bad version, set end point to mid - 1\\n                else return mid;  // if mid is first bad version\\n            }\\n            else start = mid + 1; // if mid is not bad version, set start point to mid + 1\\n        }\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1928828,
                "title": "php-simple-and-fast-solution-without-built-in-functions",
                "content": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      public function isBadVersion($version){} */\\n\\nclass Solution extends VersionControl {\\n    /**\\n     * @param Integer $n\\n     * @return Integer\\n     */\\n    function firstBadVersion($n) {\\n        $left = 1;\\n        $right = $n;\\n        $current = false;\\n        while($left != $right){\\n            $current = (int)(($left + $right) / 2);\\n      if ($this->isBadVersion($current)) {\\n                $right = $current;\\n            } else {\\n                $left = $current + 1;\\n            }\\n        }\\n        return $right;\\n      \\n    }\\n}\\n```\\nPlease upvote if you like the solution and feel free to ask for more information if you need-",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      public function isBadVersion($version){} */\\n\\nclass Solution extends VersionControl {\\n    /**\\n     * @param Integer $n\\n     * @return Integer\\n     */\\n    function firstBadVersion($n) {\\n        $left = 1;\\n        $right = $n;\\n        $current = false;\\n        while($left != $right){\\n            $current = (int)(($left + $right) / 2);\\n      if ($this->isBadVersion($current)) {\\n                $right = $current;\\n            } else {\\n                $left = $current + 1;\\n            }\\n        }\\n        return $right;\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869908,
                "title": "java-easy-and-intuitive-solution-with-explanation-binary-search",
                "content": "**Code**\\n```java\\npublic int firstBadVersion(int n) {\\n\\tint s = 1, e = n;\\n\\tint firstBad = Integer.MAX_VALUE;\\n\\twhile(s <= e) {\\n\\t\\tint mid = s + (e-s)/2;\\n\\t\\tif(!isBadVersion(mid)) {\\n\\t\\t\\ts = mid+1;\\n\\t\\t} else {\\n\\t\\t\\tfirstBad = Math.min(firstBad, mid);\\n\\t\\t\\te = mid-1;\\n\\t\\t}\\n\\t}\\n\\treturn firstBad;\\n}\\n```\\n\\n**Explanation**\\n1. The logic is to simply use binary search inorder to make as less calls to avaiable API as possible, another important constraint given to us is that the nums are in ascending order.\\n2. Two conditions occur:-\\n\\t1. If `mid` is not a bad version than that means no number lesser than mid will be bad, so move start index to mid+1.\\n\\t2. else if mid is bad version than move backward to find first bad version.\\n\\n![image](https://assets.leetcode.com/users/images/78e5328a-703c-46c7-a700-03dd301bfe81_1647858429.4432962.png)\\n\\nHope it helps\\nThanks\\nDo upvote",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```java\\npublic int firstBadVersion(int n) {\\n\\tint s = 1, e = n;\\n\\tint firstBad = Integer.MAX_VALUE;\\n\\twhile(s <= e) {\\n\\t\\tint mid = s + (e-s)/2;\\n\\t\\tif(!isBadVersion(mid)) {\\n\\t\\t\\ts = mid+1;\\n\\t\\t} else {\\n\\t\\t\\tfirstBad = Math.min(firstBad, mid);\\n\\t\\t\\te = mid-1;\\n\\t\\t}\\n\\t}\\n\\treturn firstBad;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1778578,
                "title": "go-benchmarking-and-profiling-different-versions",
                "content": "I was curious to see how small changes moved the constant factors. I benchmarked 4 similar variations of my own solution and one other Go solution chosen at random from the discussions:\\n\\n```\\nRunning tool: /home/jchase/sdk/go1.17.6/bin/go test -benchmem -run=^$ -coverprofile=/tmp/vscode-golEPwFj/go-code-cover -bench . badversion\\n\\ngoos: linux\\ngoarch: amd64\\npkg: badversion\\ncpu: AMD Ryzen 5 PRO 3500U w/ Radeon Vega Mobile Gfx\\nBenchmarkV1-8               \\t83998635\\t        14.15 ns/op\\t       0 B/op\\t       0 allocs/op\\nBenchmarkV2-8               \\t111287302\\t         9.916 ns/op\\t       0 B/op\\t       0 allocs/op\\nBenchmarkV3-8               \\t119297382\\t        10.10 ns/op\\t       0 B/op\\t       0 allocs/op\\nBenchmarkV4-8               \\t113270150\\t        11.38 ns/op\\t       0 B/op\\t       0 allocs/op\\nBenchmarkDiscuss1756768-8   \\t78179970\\t        14.65 ns/op\\t       0 B/op\\t       0 allocs/op\\nPASS\\ncoverage: 100.0% of statements\\nok  \\tbadversion\\t9.007s\\n```\\n\\n```go\\npackage main\\n\\nfunc isBadVersion(version int) bool {\\n\\treturn version >= 50\\n}\\n\\nfunc firstBadVersion(n int) int {\\n\\tstart := 0\\n\\tend := n\\n\\n\\tfor mid := (end + start) / 2; start < end; mid = (end + start) / 2 {\\n\\t\\tif isBadVersion(mid) {\\n\\t\\t\\tend = mid\\n\\t\\t} else {\\n\\t\\t\\tstart = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn start\\n}\\n\\nfunc firstBadVersionV2(n int) int {\\n\\tmaybeBad := 1\\n\\n\\tfor mid := (n + maybeBad) / 2; maybeBad < n; mid = (n + maybeBad) / 2 {\\n\\t\\tif isBadVersion(mid) {\\n\\t\\t\\tn = mid\\n\\t\\t} else {\\n\\t\\t\\tmaybeBad = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn n\\n}\\n\\nfunc firstBadVersionV3(n int) int {\\n\\tmaybeBad := 1\\n\\n\\tfor maybeBad < n {\\n\\t\\tif isBadVersion((n + maybeBad) / 2) {\\n\\t\\t\\tn = (n + maybeBad) / 2\\n\\t\\t} else {\\n\\t\\t\\tmaybeBad = (n+maybeBad)/2 + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn n\\n}\\n\\nfunc firstBadVersionV4(n int) int {\\n\\tstart := 1\\n\\tend := n\\n\\n\\tfor mid := (end + start) / 2; start < end; mid = (end + start) / 2 {\\n\\t\\tif isBadVersion(mid) {\\n\\t\\t\\tend = mid - 1\\n\\t\\t} else {\\n\\t\\t\\tstart = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn start\\n}\\n\\nfunc firstBadVersionDiscuss1756768(n int) int {\\n\\tleft, right := 1, n\\n\\tvar mid int\\n\\n\\tfor right >= left {\\n\\t\\tmid = left + (right-left)/2\\n\\t\\tif isBadVersion(mid) {\\n\\t\\t\\tright = mid - 1\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\treturn left\\n}\\n```\\n\\n```\\njchase@laptop:~/Dropbox/src/go/leetcode/278-first-bad-version_easy$ go test -bench=. -benchmem -memprofile memprofile.out -cpuprofile profile.out\\ngoos: linux\\ngoarch: amd64\\npkg: badversion\\ncpu: AMD Ryzen 5 PRO 3500U w/ Radeon Vega Mobile Gfx\\nBenchmarkV1-8                   149749778                8.078 ns/op           0 B/op          0 allocs/op\\nBenchmarkV2-8                   131324102                8.963 ns/op           0 B/op          0 allocs/op\\nBenchmarkV3-8                   151681826                8.575 ns/op           0 B/op          0 allocs/op\\nBenchmarkV4-8                   112265661               10.74 ns/op            0 B/op          0 allocs/op\\nBenchmarkDiscuss1756768-8       93514813                12.76 ns/op            0 B/op          0 allocs/op\\nPASS\\nok      badversion      9.431s\\njchase@laptop:~/Dropbox/src/go/leetcode/278-first-bad-version_easy$ go tool pprof profile.out\\nFile: badversion.test\\nType: cpu\\nTime: Feb 17, 2022 at 10:42am (EST)\\nDuration: 9.42s, Total samples = 9.33s (99.01%)\\nEntering interactive mode (type \"help\" for commands, \"o\" for options)\\n(pprof) list firstBadVersion\\nTotal: 9.33s\\nROUTINE ======================== badversion.firstBadVersion in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.75s      1.75s (flat, cum) 18.76% of Total\\n         .          .      6:\\n         .          .      7:func firstBadVersion(n int) int {\\n         .          .      8:   start := 0\\n         .          .      9:   end := n\\n         .          .     10:\\n     1.37s      1.37s     11:   for mid := (end + start) / 2; start < end; mid = (end + start) / 2 {\\n     380ms      380ms     12:           if isBadVersion(mid) {\\n         .          .     13:                   end = mid\\n         .          .     14:           } else {\\n         .          .     15:                   start = mid + 1\\n         .          .     16:           }\\n         .          .     17:   }\\nROUTINE ======================== badversion.firstBadVersionDiscuss1756768 in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.71s      2.06s (flat, cum) 22.08% of Total\\n         .          .     64:\\n         .          .     65:func firstBadVersionDiscuss1756768(n int) int {\\n         .          .     66:   left, right := 1, n\\n         .          .     67:   var mid int\\n         .          .     68:\\n     360ms      360ms     69:   for right >= left {\\n     760ms      760ms     70:           mid = left + (right-left)/2\\n     490ms      840ms     71:           if isBadVersion(mid) {\\n     100ms      100ms     72:                   right = mid - 1\\n         .          .     73:           } else {\\n         .          .     74:                   left = mid + 1\\n         .          .     75:           }\\n         .          .     76:   }\\n         .          .     77:   return left\\nROUTINE ======================== badversion.firstBadVersionV2 in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.76s      1.76s (flat, cum) 18.86% of Total\\n         .          .     20:}\\n         .          .     21:\\n         .          .     22:func firstBadVersionV2(n int) int {\\n         .          .     23:   maybeBad := 1\\n         .          .     24:\\n     1.17s      1.17s     25:   for mid := (n + maybeBad) / 2; maybeBad < n; mid = (n + maybeBad) / 2 {\\n     550ms      550ms     26:           if isBadVersion(mid) {\\n         .          .     27:                   n = mid\\n         .          .     28:           } else {\\n      40ms       40ms     29:                   maybeBad = mid + 1\\n         .          .     30:           }\\n         .          .     31:   }\\n         .          .     32:\\n         .          .     33:   return n\\n         .          .     34:}\\nROUTINE ======================== badversion.firstBadVersionV3 in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.75s      1.83s (flat, cum) 19.61% of Total\\n         .          .     34:}\\n         .          .     35:\\n         .          .     36:func firstBadVersionV3(n int) int {\\n         .          .     37:   maybeBad := 1\\n         .          .     38:\\n     330ms      330ms     39:   for maybeBad < n {\\n     1.42s      1.50s     40:           if isBadVersion((n + maybeBad) / 2) {\\n         .          .     41:                   n = (n + maybeBad) / 2\\n         .          .     42:           } else {\\n         .          .     43:                   maybeBad = (n+maybeBad)/2 + 1\\n         .          .     44:           }\\n         .          .     45:   }\\nROUTINE ======================== badversion.firstBadVersionV4 in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.83s      1.83s (flat, cum) 19.61% of Total\\n         .          .     49:\\n         .          .     50:func firstBadVersionV4(n int) int {\\n         .          .     51:   start := 1\\n         .          .     52:   end := n\\n         .          .     53:\\n     1.28s      1.28s     54:   for mid := (end + start) / 2; start < end; mid = (end + start) / 2 {\\n     460ms      460ms     55:           if isBadVersion(mid) {\\n      80ms       80ms     56:                   end = mid - 1\\n         .          .     57:           } else {\\n      10ms       10ms     58:                   start = mid + 1\\n         .          .     59:           }\\n         .          .     60:   }\\n         .          .     61:\\n         .          .     62:   return start\\n         .          .     63:}\\n(pprof)\\n```\\n\\n```go\\npackage main\\n\\nimport \"testing\"\\n\\nvar Result int\\n\\nfunc BenchmarkV1(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersion(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc BenchmarkV2(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersionV2(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc BenchmarkV3(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersionV3(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc BenchmarkV4(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersionV4(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc BenchmarkDiscuss1756768(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersionDiscuss1756768(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc Test_firstBadVersion(t *testing.T) {\\n\\ttype args struct {\\n\\t\\tn int\\n\\t}\\n\\ttests := []struct {\\n\\t\\tname string\\n\\t\\targs args\\n\\t\\twant int\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tname: \"example 1\",\\n\\t\\t\\twant: 50,\\n\\t\\t\\targs: args{\\n\\t\\t\\t\\tn: 100,\\n\\t\\t\\t},\\n\\t\\t},\\n\\t}\\n\\tfor _, tt := range tests {\\n\\t\\tt.Run(tt.name, func(t *testing.T) {\\n\\t\\t\\tif got := firstBadVersion(tt.args.n); got != tt.want {\\n\\t\\t\\t\\tt.Errorf(\"firstBadVersion() = %v, want %v\", got, tt.want)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nRunning tool: /home/jchase/sdk/go1.17.6/bin/go test -benchmem -run=^$ -coverprofile=/tmp/vscode-golEPwFj/go-code-cover -bench . badversion\\n\\ngoos: linux\\ngoarch: amd64\\npkg: badversion\\ncpu: AMD Ryzen 5 PRO 3500U w/ Radeon Vega Mobile Gfx\\nBenchmarkV1-8               \\t83998635\\t        14.15 ns/op\\t       0 B/op\\t       0 allocs/op\\nBenchmarkV2-8               \\t111287302\\t         9.916 ns/op\\t       0 B/op\\t       0 allocs/op\\nBenchmarkV3-8               \\t119297382\\t        10.10 ns/op\\t       0 B/op\\t       0 allocs/op\\nBenchmarkV4-8               \\t113270150\\t        11.38 ns/op\\t       0 B/op\\t       0 allocs/op\\nBenchmarkDiscuss1756768-8   \\t78179970\\t        14.65 ns/op\\t       0 B/op\\t       0 allocs/op\\nPASS\\ncoverage: 100.0% of statements\\nok  \\tbadversion\\t9.007s\\n```\n```go\\npackage main\\n\\nfunc isBadVersion(version int) bool {\\n\\treturn version >= 50\\n}\\n\\nfunc firstBadVersion(n int) int {\\n\\tstart := 0\\n\\tend := n\\n\\n\\tfor mid := (end + start) / 2; start < end; mid = (end + start) / 2 {\\n\\t\\tif isBadVersion(mid) {\\n\\t\\t\\tend = mid\\n\\t\\t} else {\\n\\t\\t\\tstart = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn start\\n}\\n\\nfunc firstBadVersionV2(n int) int {\\n\\tmaybeBad := 1\\n\\n\\tfor mid := (n + maybeBad) / 2; maybeBad < n; mid = (n + maybeBad) / 2 {\\n\\t\\tif isBadVersion(mid) {\\n\\t\\t\\tn = mid\\n\\t\\t} else {\\n\\t\\t\\tmaybeBad = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn n\\n}\\n\\nfunc firstBadVersionV3(n int) int {\\n\\tmaybeBad := 1\\n\\n\\tfor maybeBad < n {\\n\\t\\tif isBadVersion((n + maybeBad) / 2) {\\n\\t\\t\\tn = (n + maybeBad) / 2\\n\\t\\t} else {\\n\\t\\t\\tmaybeBad = (n+maybeBad)/2 + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn n\\n}\\n\\nfunc firstBadVersionV4(n int) int {\\n\\tstart := 1\\n\\tend := n\\n\\n\\tfor mid := (end + start) / 2; start < end; mid = (end + start) / 2 {\\n\\t\\tif isBadVersion(mid) {\\n\\t\\t\\tend = mid - 1\\n\\t\\t} else {\\n\\t\\t\\tstart = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn start\\n}\\n\\nfunc firstBadVersionDiscuss1756768(n int) int {\\n\\tleft, right := 1, n\\n\\tvar mid int\\n\\n\\tfor right >= left {\\n\\t\\tmid = left + (right-left)/2\\n\\t\\tif isBadVersion(mid) {\\n\\t\\t\\tright = mid - 1\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\treturn left\\n}\\n```\n```\\njchase@laptop:~/Dropbox/src/go/leetcode/278-first-bad-version_easy$ go test -bench=. -benchmem -memprofile memprofile.out -cpuprofile profile.out\\ngoos: linux\\ngoarch: amd64\\npkg: badversion\\ncpu: AMD Ryzen 5 PRO 3500U w/ Radeon Vega Mobile Gfx\\nBenchmarkV1-8                   149749778                8.078 ns/op           0 B/op          0 allocs/op\\nBenchmarkV2-8                   131324102                8.963 ns/op           0 B/op          0 allocs/op\\nBenchmarkV3-8                   151681826                8.575 ns/op           0 B/op          0 allocs/op\\nBenchmarkV4-8                   112265661               10.74 ns/op            0 B/op          0 allocs/op\\nBenchmarkDiscuss1756768-8       93514813                12.76 ns/op            0 B/op          0 allocs/op\\nPASS\\nok      badversion      9.431s\\njchase@laptop:~/Dropbox/src/go/leetcode/278-first-bad-version_easy$ go tool pprof profile.out\\nFile: badversion.test\\nType: cpu\\nTime: Feb 17, 2022 at 10:42am (EST)\\nDuration: 9.42s, Total samples = 9.33s (99.01%)\\nEntering interactive mode (type \"help\" for commands, \"o\" for options)\\n(pprof) list firstBadVersion\\nTotal: 9.33s\\nROUTINE ======================== badversion.firstBadVersion in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.75s      1.75s (flat, cum) 18.76% of Total\\n         .          .      6:\\n         .          .      7:func firstBadVersion(n int) int {\\n         .          .      8:   start := 0\\n         .          .      9:   end := n\\n         .          .     10:\\n     1.37s      1.37s     11:   for mid := (end + start) / 2; start < end; mid = (end + start) / 2 {\\n     380ms      380ms     12:           if isBadVersion(mid) {\\n         .          .     13:                   end = mid\\n         .          .     14:           } else {\\n         .          .     15:                   start = mid + 1\\n         .          .     16:           }\\n         .          .     17:   }\\nROUTINE ======================== badversion.firstBadVersionDiscuss1756768 in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.71s      2.06s (flat, cum) 22.08% of Total\\n         .          .     64:\\n         .          .     65:func firstBadVersionDiscuss1756768(n int) int {\\n         .          .     66:   left, right := 1, n\\n         .          .     67:   var mid int\\n         .          .     68:\\n     360ms      360ms     69:   for right >= left {\\n     760ms      760ms     70:           mid = left + (right-left)/2\\n     490ms      840ms     71:           if isBadVersion(mid) {\\n     100ms      100ms     72:                   right = mid - 1\\n         .          .     73:           } else {\\n         .          .     74:                   left = mid + 1\\n         .          .     75:           }\\n         .          .     76:   }\\n         .          .     77:   return left\\nROUTINE ======================== badversion.firstBadVersionV2 in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.76s      1.76s (flat, cum) 18.86% of Total\\n         .          .     20:}\\n         .          .     21:\\n         .          .     22:func firstBadVersionV2(n int) int {\\n         .          .     23:   maybeBad := 1\\n         .          .     24:\\n     1.17s      1.17s     25:   for mid := (n + maybeBad) / 2; maybeBad < n; mid = (n + maybeBad) / 2 {\\n     550ms      550ms     26:           if isBadVersion(mid) {\\n         .          .     27:                   n = mid\\n         .          .     28:           } else {\\n      40ms       40ms     29:                   maybeBad = mid + 1\\n         .          .     30:           }\\n         .          .     31:   }\\n         .          .     32:\\n         .          .     33:   return n\\n         .          .     34:}\\nROUTINE ======================== badversion.firstBadVersionV3 in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.75s      1.83s (flat, cum) 19.61% of Total\\n         .          .     34:}\\n         .          .     35:\\n         .          .     36:func firstBadVersionV3(n int) int {\\n         .          .     37:   maybeBad := 1\\n         .          .     38:\\n     330ms      330ms     39:   for maybeBad < n {\\n     1.42s      1.50s     40:           if isBadVersion((n + maybeBad) / 2) {\\n         .          .     41:                   n = (n + maybeBad) / 2\\n         .          .     42:           } else {\\n         .          .     43:                   maybeBad = (n+maybeBad)/2 + 1\\n         .          .     44:           }\\n         .          .     45:   }\\nROUTINE ======================== badversion.firstBadVersionV4 in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.83s      1.83s (flat, cum) 19.61% of Total\\n         .          .     49:\\n         .          .     50:func firstBadVersionV4(n int) int {\\n         .          .     51:   start := 1\\n         .          .     52:   end := n\\n         .          .     53:\\n     1.28s      1.28s     54:   for mid := (end + start) / 2; start < end; mid = (end + start) / 2 {\\n     460ms      460ms     55:           if isBadVersion(mid) {\\n      80ms       80ms     56:                   end = mid - 1\\n         .          .     57:           } else {\\n      10ms       10ms     58:                   start = mid + 1\\n         .          .     59:           }\\n         .          .     60:   }\\n         .          .     61:\\n         .          .     62:   return start\\n         .          .     63:}\\n(pprof)\\n```\n```go\\npackage main\\n\\nimport \"testing\"\\n\\nvar Result int\\n\\nfunc BenchmarkV1(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersion(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc BenchmarkV2(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersionV2(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc BenchmarkV3(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersionV3(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc BenchmarkV4(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersionV4(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc BenchmarkDiscuss1756768(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersionDiscuss1756768(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc Test_firstBadVersion(t *testing.T) {\\n\\ttype args struct {\\n\\t\\tn int\\n\\t}\\n\\ttests := []struct {\\n\\t\\tname string\\n\\t\\targs args\\n\\t\\twant int\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tname: \"example 1\",\\n\\t\\t\\twant: 50,\\n\\t\\t\\targs: args{\\n\\t\\t\\t\\tn: 100,\\n\\t\\t\\t},\\n\\t\\t},\\n\\t}\\n\\tfor _, tt := range tests {\\n\\t\\tt.Run(tt.name, func(t *testing.T) {\\n\\t\\t\\tif got := firstBadVersion(tt.args.n); got != tt.want {\\n\\t\\t\\t\\tt.Errorf(\"firstBadVersion() = %v, want %v\", got, tt.want)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1553233,
                "title": "ruby-94-faster-clean-and-simple",
                "content": "```\\ndef first_bad_version(n)\\n    left, right = 1, n\\n    \\n    until left == right do \\n      middle = left + ((right - left)/2) \\n      is_bad_version(middle) ? right = middle : left = middle + 1\\n    end\\n\\t\\n    left\\nend\\n```\\n\\nI know a lot of people dislike Ruby\\'s `until` and `unless` but I find them both to be very helpful and readable. In this case, using `until` the left and right pointers are the same was more readable and explicit to me than `while` the left pointer is less than the right pointer.",
                "solutionTags": [
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```\\ndef first_bad_version(n)\\n    left, right = 1, n\\n    \\n    until left == right do \\n      middle = left + ((right - left)/2) \\n      is_bad_version(middle) ? right = middle : left = middle + 1\\n    end\\n\\t\\n    left\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1550763,
                "title": "simple-java-solution-better-than-your-code",
                "content": "public class Solution extends VersionControl {\\n\\n\\n    public int firstBadVersion(int n) {\\n        int lo=1;\\n        int hi=n;\\n        int mid=lo+(hi-lo)/2;\\n        while(lo<hi){\\n            if(isBadVersion(mid)==true){\\n                if(mid!=0 && isBadVersion(mid-1)==false){\\n                    return mid;\\n                }\\n                hi=mid-1;\\n            }\\n            else if(isBadVersion(mid)==false){\\n                \\n               lo=mid+1; \\n            }\\n            \\n             mid=lo+(hi-lo)/2;\\n        }\\n        return mid;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution extends VersionControl {\\n\\n\\n    public int firstBadVersion(int n) {\\n        int lo=1;\\n        int hi=n;\\n        int mid=lo+(hi-lo)/2;\\n        while(lo<hi){\\n            if(isBadVersion(mid)==true){\\n                if(mid!=0 && isBadVersion(mid-1)==false){\\n                    return mid;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1539053,
                "title": "javascript-o-logn-simple-solution",
                "content": "```    \\nreturn function(n) {\\n\\tlet l = 1,\\n\\t\\tr = n,\\n\\t\\tm;\\n\\n\\twhile (l < r) {\\n\\t\\tm = ~~((l+r)/2);\\n\\t\\tif (isBadVersion(m)) r = m;\\n\\t\\telse l = m + 1;\\n\\t}\\n\\n\\treturn l;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```    \\nreturn function(n) {\\n\\tlet l = 1,\\n\\t\\tr = n,\\n\\t\\tm;\\n\\n\\twhile (l < r) {\\n\\t\\tm = ~~((l+r)/2);\\n\\t\\tif (isBadVersion(m)) r = m;\\n\\t\\telse l = m + 1;\\n\\t}\\n\\n\\treturn l;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1419848,
                "title": "easy-java-solution-using-binary-search",
                "content": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start = 1;\\n        int end = n;\\n\\n        while (start <= end){\\n            int mid = start + (end-start) / 2;\\n            boolean ans = isBadVersion(mid);\\n            if(ans == false){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid -1;\\n            }\\n            \\n        }return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start = 1;\\n        int end = n;\\n\\n        while (start <= end){\\n            int mid = start + (end-start) / 2;\\n            boolean ans = isBadVersion(mid);\\n            if(ans == false){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid -1;\\n            }\\n            \\n        }return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919971,
                "title": "kotlin-o-logn-time-and-o-1-space",
                "content": "\\n    override fun firstBadVersion(n: Int) : Int {\\n        // [a, b)\\n        var l: Long = 1\\n        var r: Long = n.toLong() + 1\\n        \\n\\t\\t// lower_boundry()\\n        while (l < r) {\\n            val m = l + (r - l) / 2\\n\\n            if (isBadVersion(m.toInt()))\\n                r = m\\n            else\\n                l = m + 1\\n        }\\n\\n        return l.toInt()\\n\\t}\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "\\n    override fun firstBadVersion(n: Int) : Int {\\n        // [a, b)\\n        var l: Long = 1\\n        var r: Long = n.toLong() + 1\\n        \\n\\t\\t// lower_boundry()\\n        while (l < r) {\\n            val m = l + (r - l) / 2\\n\\n            if (isBadVersion(m.toInt()))\\n                r = m\\n            else\\n                l = m + 1\\n        }\\n\\n        return l.toInt()\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 617226,
                "title": "o-logn-simple-c-solution-100-faster",
                "content": "```\\nint firstBadVersion(int n) {\\n        int min=1,max=n;\\n        while(min<=max){\\n            int mid = min + (max-min)/2;\\n            if(isBadVersion(mid)){\\n                max=mid-1;\\n            }\\n            else{\\n                min=mid+1;\\n            }\\n        }\\n        return min;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint firstBadVersion(int n) {\\n        int min=1,max=n;\\n        while(min<=max){\\n            int mid = min + (max-min)/2;\\n            if(isBadVersion(mid)){\\n                max=mid-1;\\n            }\\n            else{\\n                min=mid+1;\\n            }\\n        }\\n        return min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 606468,
                "title": "golang-o-logn-0-ms-solution",
                "content": "Golang solution with implementing **binary search** to find first bad version.\\n```\\nfunc firstBadVersion(n int) int {\\n\\tstart, end := 1, n\\n\\tfirstBadVersion := n\\n\\n\\tfor start < end {\\n\\t\\tmid := (start + end) / 2\\n\\t\\tresult := isBadVersion(mid)\\n\\n\\t\\tif result {\\n\\t\\t\\tend = mid\\n\\t\\t\\tfirstBadVersion = mid\\n\\t\\t} else {\\n\\t\\t\\tstart = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn firstBadVersion\\n}",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "Golang solution with implementing **binary search** to find first bad version.\\n```\\nfunc firstBadVersion(n int) int {\\n\\tstart, end := 1, n\\n\\tfirstBadVersion := n\\n\\n\\tfor start < end {\\n\\t\\tmid := (start + end) / 2\\n\\t\\tresult := isBadVersion(mid)\\n\\n\\t\\tif result {\\n\\t\\t\\tend = mid\\n\\t\\t\\tfirstBadVersion = mid\\n\\t\\t} else {\\n\\t\\t\\tstart = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn firstBadVersion\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 564117,
                "title": "swift-version",
                "content": "```\\nfunc firstBadVersion(_ n: Int) -> Int {\\n        var left = 1\\n        var right = n\\n        var mid = 0\\n        while left + 1 < right {\\n            mid = left + (right - mid) / 2\\n            if isBadVersion(mid) {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        if isBadVersion(left) {\\n            return left\\n        }\\n        return right\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc firstBadVersion(_ n: Int) -> Int {\\n        var left = 1\\n        var right = n\\n        var mid = 0\\n        while left + 1 < right {\\n            mid = left + (right - mid) / 2\\n            if isBadVersion(mid) {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        if isBadVersion(left) {\\n            return left\\n        }\\n        return right\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532447,
                "title": "unorthodox-yet-elegant-simple-binary-search-implementation-varying-step-sizes-is-all-you-need",
                "content": "Straightforward linear search solution like\\n```c++\\nint firstBadVersion(int n) {\\n    int version = n;\\n    while (version > 1 && isBadVersion(version - 1)) {\\n        version -= 1;\\n    }\\n    return version;\\n}\\n```\\n\\nturns into an efficient binary search with just a simple twist:\\n\\n```c++\\nint firstBadVersion(int n) {\\n    int version = n;\\n    for (int step = n; step >= 1; step /= 2) {\\n        while (version - step >= 1 && isBadVersion(version - step)) {\\n            version -= step;\\n        }\\n    }\\n    return version;\\n}\\n```\\n\\nNo need to maintain `left`, `right` variables and reason about happens to them on corner cases! Varying step sizes is all you need.",
                "solutionTags": [],
                "code": "```c++\\nint firstBadVersion(int n) {\\n    int version = n;\\n    while (version > 1 && isBadVersion(version - 1)) {\\n        version -= 1;\\n    }\\n    return version;\\n}\\n```\n```c++\\nint firstBadVersion(int n) {\\n    int version = n;\\n    for (int step = n; step >= 1; step /= 2) {\\n        while (version - step >= 1 && isBadVersion(version - step)) {\\n            version -= step;\\n        }\\n    }\\n    return version;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 497251,
                "title": "python-linear-iterative-recursive-and-binary-search",
                "content": "\\n\\n```\\ndef firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n\\n        \\n        \\'\\'\\'\\n        Recursive solution\\n        \\'\\'\\'\\n         if n == 1:\\n             return 1\\n         suspect = n-1\\n         if isBadVersion(suspect):\\n             return suspect\\n         return self.firstBadVersion(suspect)\\n        \\n        \\'\\'\\'\\n        linear -- O(n)\\n        \\'\\'\\'\\n         for i in range(n):\\n             if isBadVersion(i):\\n                 return i\\n         return n\\n        \\n        \\'\\'\\'\\n        binary search -- O(logn)\\n        \\'\\'\\'\\n        if n == 1:\\n            return 1\\n\\n        l, r = 0, n\\n        while l <= r:\\n            mid = (l+r)//2\\n            if isBadVersion(mid):\\n                version = mid  # --- update the most recent bad version so far\\n                r = mid-1\\n            else:\\n                l = mid+1\\n        return version\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\ndef firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n\\n        \\n        \\'\\'\\'\\n        Recursive solution\\n        \\'\\'\\'\\n         if n == 1:\\n             return 1\\n         suspect = n-1\\n         if isBadVersion(suspect):\\n             return suspect\\n         return self.firstBadVersion(suspect)\\n        \\n        \\'\\'\\'\\n        linear -- O(n)\\n        \\'\\'\\'\\n         for i in range(n):\\n             if isBadVersion(i):\\n                 return i\\n         return n\\n        \\n        \\'\\'\\'\\n        binary search -- O(logn)\\n        \\'\\'\\'\\n        if n == 1:\\n            return 1\\n\\n        l, r = 0, n\\n        while l <= r:\\n            mid = (l+r)//2\\n            if isBadVersion(mid):\\n                version = mid  # --- update the most recent bad version so far\\n                r = mid-1\\n            else:\\n                l = mid+1\\n        return version\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 279900,
                "title": "increase-speed-by-50-through-a-simple-change",
                "content": "calculation of mid #1: ```mid = start + ((end - start)/2);```\\ncalculation of mid #2: ```mid = start + ((end - start)>>1);```\\n\\nSpeed increased by almost 50% for calculation 2 because I eliminated the divide operation.",
                "solutionTags": [],
                "code": "```mid = start + ((end - start)/2);```\n```mid = start + ((end - start)>>1);```",
                "codeTag": "Unknown"
            },
            {
                "id": 71404,
                "title": "solution-with-using-low-high-2-and-not-low-high-low-2",
                "content": "     int firstBadVersion(int n) {\\n        long start=1,end=n;\\n        int res=-1;\\n        while(start<=end){\\n            long mid = (start+end)/2;\\n            if(isBadVersion(mid)){\\n                res=mid;\\n                end=mid-1;\\n            }\\n            else\\n                start=mid+1;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "     int firstBadVersion(int n) {\\n        long start=1,end=n;\\n        int res=-1;\\n        while(start<=end){\\n            long mid = (start+end)/2;\\n            if(isBadVersion(mid)){\\n                res=mid;\\n                end=mid-1;\\n            }\\n            else\\n                start=mid+1;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71429,
                "title": "share-my-java-solution-which-is-easy-to-understand",
                "content": "    public class Solution extends VersionControl {\\n        public int firstBadVersion(int n) {\\n            int lo = 1, hi = n;\\n            int last = 0;\\n            while(lo <= hi){\\n                int mid = lo + (hi - lo)/2;\\n                if(isBadVersion(mid)){\\n                    hi = mid - 1;\\n                    last = mid;\\n                }else{\\n                    lo = mid + 1;\\n                }\\n            }\\n            return last;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution extends VersionControl {\\n        public int firstBadVersion(int n) {\\n            int lo = 1, hi = n;\\n            int last = 0;\\n            while(lo <= hi){\\n                int mid = lo + (hi - lo)/2;\\n                if(isBadVersion(mid)){\\n                    hi = mid - 1;\\n                    last = mid;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 71420,
                "title": "my-0ms-c-solution-with-o-logn-time-and-o-1-space",
                "content": "    class Solution {\\n    public:\\n        int firstBadVersion(int n) {\\n            int from,to,mid;\\n            from=1;to=n;\\n            while(from!=to)\\n            {\\n                mid=((long long)from+to)/2;\\n                if(isBadVersion(mid)==true)\\n                {\\n                    to=mid;\\n                }\\n                else\\n                {\\n                    from=mid+1;\\n                }\\n            }\\n            return from;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int firstBadVersion(int n) {\\n            int from,to,mid;\\n            from=1;to=n;\\n            while(from!=to)\\n            {\\n                mid=((long long)from+to)/2;\\n                if(isBadVersion(mid)==true)\\n                {\\n                    to=mid;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3876062,
                "title": "binary-search-beginner-easy-to-understand-c-0ms-faster-than-100",
                "content": "# Intuition\\n\\n# Approach\\nusing exponential search and binary search.\\nyou should be familiar with BS and ES.\\n* first we find the range of bad solution using exponential search .\\n* we pass range to bs and we are going to found upper bound And upper bound is our required solution\\n* we are taking long i because when we multiply i*2 for big number it will cross 2^31-1 for if condition .\\n* ES --> BS.\\n\\n# Complexity\\n- Time complexity:\\nTC <= O(logn).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n  \\n  int bs(int n,int s,int e){\\n      int ans=e;  \\n     while(s<=e){\\n            int m=s+(e-s)/2;\\n         if(isBadVersion(m)==true){\\n             ans=m;\\n             e=m-1;\\n         }\\n         else {\\n             s=m+1;\\n         }\\n     }      \\n         return ans;\\n  }\\n  int exp_s(int n){\\n      if(isBadVersion(1)==true){\\n          return 1;\\n      }\\n      long i=1;\\n      while(i<n&&isBadVersion(i)==false){\\n          if(i*2>INT_MAX){\\n              i=n;\\n              break;\\n          }\\n            i*=2;\\n      }\\n      int min;\\n      if(i>n){\\n          min=n;\\n      }\\n      else{\\n          min=i;\\n      }\\n      return bs(n,i/2,min);\\n  }\\n    int firstBadVersion(int n) {\\n\\n      int ans=exp_s(n);\\n      return ans;\\n    }\\n};\\n```\\n# If you like the solution then please **upvote** me it gives me encouragement to do more...........\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n  \\n  int bs(int n,int s,int e){\\n      int ans=e;  \\n     while(s<=e){\\n            int m=s+(e-s)/2;\\n         if(isBadVersion(m)==true){\\n             ans=m;\\n             e=m-1;\\n         }\\n         else {\\n             s=m+1;\\n         }\\n     }      \\n         return ans;\\n  }\\n  int exp_s(int n){\\n      if(isBadVersion(1)==true){\\n          return 1;\\n      }\\n      long i=1;\\n      while(i<n&&isBadVersion(i)==false){\\n          if(i*2>INT_MAX){\\n              i=n;\\n              break;\\n          }\\n            i*=2;\\n      }\\n      int min;\\n      if(i>n){\\n          min=n;\\n      }\\n      else{\\n          min=i;\\n      }\\n      return bs(n,i/2,min);\\n  }\\n    int firstBadVersion(int n) {\\n\\n      int ans=exp_s(n);\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740256,
                "title": "easy-c-solution-simple-binary-search-approach-beats-100-in-both",
                "content": "# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int start = 1, end = n, mid = start+(end-start)/2, ans;\\n        while(start<=end)\\n        {\\n            if(isBadVersion(mid))\\n                ans = mid, end = mid-1;\\n            else\\n                start = mid+1;\\n            mid = start+(end-start)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int start = 1, end = n, mid = start+(end-start)/2, ans;\\n        while(start<=end)\\n        {\\n            if(isBadVersion(mid))\\n                ans = mid, end = mid-1;\\n            else\\n                start = mid+1;\\n            mid = start+(end-start)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544358,
                "title": "easy-to-understand-binary-search-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nO(n) too slow for big data (do not go for linear method)\\ninstead go with binary searching method to reduce api calling\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmodify and implement  binary search model to find the bad version which is \\nright to the good version (basically find only good,bad pair)\\n# Complexity\\n- Time complexity:O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        if n==1:\\n            return n if isBadVersion(n) else 0 \\n        left,right=0,n\\n        while left<right:\\n            mid=(right+left)//2\\n            if isBadVersion(mid):\\n                if isBadVersion(mid-1):\\n                    right=mid-1\\n                else:\\n                    return mid    \\n            else:\\n                if isBadVersion(mid+1):\\n                    return mid+1\\n                else:\\n                    left=mid+1     \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        if n==1:\\n            return n if isBadVersion(n) else 0 \\n        left,right=0,n\\n        while left<right:\\n            mid=(right+left)//2\\n            if isBadVersion(mid):\\n                if isBadVersion(mid-1):\\n                    right=mid-1\\n                else:\\n                    return mid    \\n            else:\\n                if isBadVersion(mid+1):\\n                    return mid+1\\n                else:\\n                    left=mid+1     \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513654,
                "title": "building-intuition-from-simple-binary-search-made-with",
                "content": "\\nThis question is a part of a Binary Search Roadmap that provides a comprehensive understanding of the topic. With this roadmap, you will be able to solve any question that comes your way. The roadmap consists of around 30 modules, each representing a concept. Each module is broken down into simpler components before building up to more complex concepts. If you find this solution helpful, please consider checking out the full roadmap on my blog, [ConstantTime](https://constanttime.io/) Thanks!.It is made with \\u2764\\uFE0F\\n\\n\\n\\n### Prerequsites : [Binary Search(Vanilla) ](https://constanttime.io/binary-search/binary-search-vanilla)\\n\\n### Laying the ground work using a simpler question. Find the First True in a Sorted Boolean Array \\n\\n### Question\\n\\nAn array bools is given, divided into two halves, the left half consists of all False values and the right with all True. Find the index of the first True Element. If there is no True value in the array return -1.\\n\\n`bools = [F,F,F,T,T,T]` \\n\\n`result = 3`\\n\\n![sec 1.png](https://assets.leetcode.com/users/images/2f25fe02-d98b-4e10-bbaf-d9e48ff25ef8_1683833042.0055177.png)\\n\\n\\n### Intuition\\n\\n1. Can we reduce the search space in an array with sorted false and true values?\\n2. During a binary search, we narrow down the search space by dividing it in half with each iteration. This is accomplished by removing either the entire right or left side of the search space, based on the location of the midpoint and its relationship with what we are looking for. How can that be applied to a sorted boolean array?\\n3. False values are positioned at the start (left side) of the array, followed by true values. As soon as we encounter a false value, we can safely discard all values to its left and focus only on the remaining true values to its right.\\n    \\n    ![sec 2.png](https://assets.leetcode.com/users/images/d4f4c7bb-7aa8-444f-95ba-ec29899ad262_1683833085.4226837.png)\\n    \\n4. At True Value, we have identified a potential value that can be stored, but we are unsure if it is the first True value. If the element we are on is not the first and all values to its right are True, then the first True value must be on the left side of it. Therefore, we can discard all values to the right. By iterating from right to left, we constantly update and obtain the most current and leftmost potential True value.\\n    \\n    \\n    ![sec 3.png](https://assets.leetcode.com/users/images/29ce7cb8-a83a-4b4a-8030-d6490e9e296b_1683833074.7744706.png)\\n    \\n\\n### Implementation\\n\\nUsing the base template used in [Binary Search(Vanilla) ](https://constanttime.io/binary-search/binary-search-vanilla) \\n\\n1. Left: lowest possible index, right: highest possible index\\n2. Using a while loop, based on the value we are on. If true, store the possible value and chop the range from the right side. If false, chop the range from the left side. Will return the possible value if found, else will return the default -1 as the possible value.\\n\\n### Keeping with the Vanilla Tradition Code\\n\\n```python\\nclass Solution:\\n\\n    def firstTrue(self, bools):\\n\\n        (left, right) = (0, len(bools) - 1)\\n        possibleValue = -1\\n\\n        while left <= right:\\n\\n            mid = left + (right - left) // 2\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# True\\n            if bools[mid]: \\n                possibleValue = mid\\n                right = mid - 1\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# False\\n            else:\\n                left = mid + 1\\n\\n        return possibleValue\\n```\\n\\n### [SandBox PythonTutor (Visualized)](https://pythontutor.com/visualize.html#code=class%20Solution%3A%0A%0A%20%20%20%20def%20firstTrue%28self,%20bools%29%3A%0A%0A%20%20%20%20%20%20%20%20%28left,%20right%29%20%3D%20%280,%20len%28bools%29%20-%201%29%0A%20%20%20%20%20%20%20%20possibleValue%20%3D%20-1%0A%0A%20%20%20%20%20%20%20%20while%20left%20%3C%3D%20right%3A%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20mid%20%3D%20left%20%2B%20%28right%20-%20left%29%20//%202%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20True%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20bools%5Bmid%5D%3A%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20possibleValue%20%3D%20mid%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20right%20%3D%20mid%20-%201%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20False%0A%20%20%20%20%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20left%20%3D%20mid%20%2B%201%0A%0A%20%20%20%20%20%20%20%20return%20possibleValue%0A%0A%0Aa1%20%3D%20%5BFalse,%20False,%20False,True%5D%0A%0A%23comment%20out%20to%20run%20these%20cases%0A%23____________________________________%0A%23%20a2%20%3D%20%5BTrue%5D%0A%23%20a3%20%3D%20%5BFalse,%20False,%20False,%20False,%20False,%20False,%20False,%20False,%20True%5D%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%0AS%3D%20Solution%28%29%0AS.firstTrue%28a1%29%0A%23comment%20out%20to%20run%20these%20cases%0A%23____________________________________%0A%23%20S.firstTrue%28a2%29%0A%23%20S.firstTrue%28a3%29&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false)\\n\\n![image.png](https://assets.leetcode.com/users/images/642769c5-5ba7-47ba-9dd8-9320006af2d8_1683833274.0109713.png)\\n\\n### Complexities\\n\\nTime Complexity:\\xA0`O(log(n))`\\n\\nSpace Complexity:\\xA0`O(1)`\\n\\n[Understanding Time Complexity of OLog(N): Math + Intuition](https://constanttime.io/binary-search/understanding-time-complexity-of-ologn-math-intuition) \\n\\n\\n### [****Find the First True in a Sorted Boolean Array (Optional Alternate Approach)****](https://constanttime.io/binary-search/find-the-first-true-in-a-sorted-boolean-array-optional-alternate-approach)\\n\\n### Building to this Question\\n\\nYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have\\xA0`n`\\xA0versions\\xA0`[1, 2, ..., n]`\\xA0and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API\\xA0`bool isBadVersion(version)`\\xA0which returns whether\\xA0`version`\\xA0is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\n### [Leetcode](https://leetcode.com/problems/first-bad-version/)\\n\\n### Implementation\\n\\n1. Question mascarading as [****Find the First True in a Sorted Boolean Array**** ](https://constanttime.io/binary-search/find-the-first-true-in-a-sorted-boolean-array)\\n2. Instead of a True value in an array it returns that from an API.\\n\\n### Regular Approach\\n\\n```python\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        \\n        left, right = 0,n\\n        possibleValue = -1\\n        \\n        \\n        while left <= right:\\n            \\n            mid = left + (right-left)//2\\n            PotentialTrue = isBadVersion(mid)\\n\\n\\t\\n            if PotentialTrue:\\n                possibleValue = mid\\n                right = mid -1\\n            \\n            else:\\n                left = mid + 1\\n                \\n        return possibleValue\\n```\\n\\n### Alternate Approach (Optional)\\n\\n```python\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        \\n        left, right = 0,n\\n      \\n        while left < right:\\n            \\n            mid = left + (right-left)//2\\n            PotentialTrue = isBadVersion(mid)\\n\\t\\n            if PotentialTrue:\\n                right = mid\\n            \\n            else:\\n                left = mid + 1\\n                \\n        return right if isBadVersion(right) == True else -1\\n```\\n\\n\\n### Follow-up\\nHow will you go about solving for the last true value, like the array below?\\n\\n`bools = [T,T,T,F,F,F]`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n\\n    def firstTrue(self, bools):\\n\\n        (left, right) = (0, len(bools) - 1)\\n        possibleValue = -1\\n\\n        while left <= right:\\n\\n            mid = left + (right - left) // 2\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# True\\n            if bools[mid]: \\n                possibleValue = mid\\n                right = mid - 1\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# False\\n            else:\\n                left = mid + 1\\n\\n        return possibleValue\\n```\n```python\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        \\n        left, right = 0,n\\n        possibleValue = -1\\n        \\n        \\n        while left <= right:\\n            \\n            mid = left + (right-left)//2\\n            PotentialTrue = isBadVersion(mid)\\n\\n\\t\\n            if PotentialTrue:\\n                possibleValue = mid\\n                right = mid -1\\n            \\n            else:\\n                left = mid + 1\\n                \\n        return possibleValue\\n```\n```python\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        \\n        left, right = 0,n\\n      \\n        while left < right:\\n            \\n            mid = left + (right-left)//2\\n            PotentialTrue = isBadVersion(mid)\\n\\t\\n            if PotentialTrue:\\n                right = mid\\n            \\n            else:\\n                left = mid + 1\\n                \\n        return right if isBadVersion(right) == True else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455012,
                "title": "beats-97-easy-java-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l=0,h=n,ans=n;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            if(isBadVersion(mid))\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l=0,h=n,ans=n;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            if(isBadVersion(mid))\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345447,
                "title": "easy-with-amazing-logic-using-binary-search",
                "content": "# \\uD83D\\uDD25Solution using Python and JavaScripit Both\\n\\n# Python\\n```\\n# The isBadVersion API is already defined for you.\\n# @param version, an integer\\n# @return a bool\\n# def isBadVersion(version):\\n\\nclass Solution(object):\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left=1\\n        right=n\\n        mid=(right+left)/2\\n        while left<right:\\n            mid=(right+left)/2\\n            if isBadVersion(mid): right=mid\\n            else: left=mid+1\\n        return left\\n\\n# please upvote me, it would encourage me alot. Thank you!\\n```\\n\\n# JavaScript \\n\\n```\\n/**\\n * Definition for isBadVersion()\\n * \\n * @param {integer} version number\\n * @return {boolean} whether the version is bad\\n * isBadVersion = function(version) {\\n *     ...\\n * };\\n */\\n\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        let left=1;\\n        let right=n;\\n        let mid=Math.floor((right+left)/2);\\n        while(left<right){\\n            mid=Math.floor((right+left)/2);\\n            if(isBadVersion(mid)){\\n                right=mid;\\n            }else{\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n    };\\n};\\n\\n# please upvote me, it would encourage me alot. Thank you!\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# @param version, an integer\\n# @return a bool\\n# def isBadVersion(version):\\n\\nclass Solution(object):\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left=1\\n        right=n\\n        mid=(right+left)/2\\n        while left<right:\\n            mid=(right+left)/2\\n            if isBadVersion(mid): right=mid\\n            else: left=mid+1\\n        return left\\n\\n# please upvote me, it would encourage me alot. Thank you!\\n```\n```\\n/**\\n * Definition for isBadVersion()\\n * \\n * @param {integer} version number\\n * @return {boolean} whether the version is bad\\n * isBadVersion = function(version) {\\n *     ...\\n * };\\n */\\n\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        let left=1;\\n        let right=n;\\n        let mid=Math.floor((right+left)/2);\\n        while(left<right){\\n            mid=Math.floor((right+left)/2);\\n            if(isBadVersion(mid)){\\n                right=mid;\\n            }else{\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n    };\\n};\\n\\n# please upvote me, it would encourage me alot. Thank you!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230406,
                "title": "ts-o-log-n-binary-search-algorithm-intuitive-solution-described",
                "content": "# Intuition\\nSince the versions are sorted in \\n\\n# Approach\\nBinary search is a search algorithm that finds the index of a target value in a sorted array.\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The knows API is defined in the parent class Relation.\\n * isBadVersion(version: number): boolean {\\n *     ...\\n * };\\n */\\n\\nvar solution = function(isBadVersion: (version: number) => boolean ) {\\n\\n    return function(n: number): number {\\n        let start = 0; // define start\\n        let end = n; // define end for binary search\\n        let lastBadVersion = 1; // We take the first bad version as 1\\n\\n        while (start <= end) {\\n            let mid = Math.floor((start + end) / 2);\\n             // Defining pivot, \\n             // so we are starting from the middle\\n             // of the versions provided\\n\\n            if (isBadVersion(mid)) { // Checking if our pivot is bad\\n                end = mid - 1; \\n                // getting rid of the versions\\n                // after our pivot version\\n                lastBadVersion = mid;\\n                // assigining the pivot as last bad version\\n            } else { \\n                // if pivot was not bad,\\n                start = mid + 1; \\n                // getting rid of\\n                // versions before pivot\\n            }\\n        }\\n\\n        return lastBadVersion;\\n    };\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * The knows API is defined in the parent class Relation.\\n * isBadVersion(version: number): boolean {\\n *     ...\\n * };\\n */\\n\\nvar solution = function(isBadVersion: (version: number) => boolean ) {\\n\\n    return function(n: number): number {\\n        let start = 0; // define start\\n        let end = n; // define end for binary search\\n        let lastBadVersion = 1; // We take the first bad version as 1\\n\\n        while (start <= end) {\\n            let mid = Math.floor((start + end) / 2);\\n             // Defining pivot, \\n             // so we are starting from the middle\\n             // of the versions provided\\n\\n            if (isBadVersion(mid)) { // Checking if our pivot is bad\\n                end = mid - 1; \\n                // getting rid of the versions\\n                // after our pivot version\\n                lastBadVersion = mid;\\n                // assigining the pivot as last bad version\\n            } else { \\n                // if pivot was not bad,\\n                start = mid + 1; \\n                // getting rid of\\n                // versions before pivot\\n            }\\n        }\\n\\n        return lastBadVersion;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078237,
                "title": "c-solution-o-log-n-binary-search",
                "content": "# Intuition\\nBinary Search\\n\\n# Approach\\nBinary Search\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long st=1;\\n        long et=n;\\n        long mid=(st+et)/2;\\n        while(st<=et)\\n        {\\n            mid=(st+et)/2;\\n            if(isBadVersion(mid)==true && isBadVersion(mid-1)==false)\\n                return mid;\\n            if(isBadVersion(mid)==true)\\n                et=mid-1;\\n            else\\n                st=mid+1;\\n        }\\n        return mid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long st=1;\\n        long et=n;\\n        long mid=(st+et)/2;\\n        while(st<=et)\\n        {\\n            mid=(st+et)/2;\\n            if(isBadVersion(mid)==true && isBadVersion(mid-1)==false)\\n                return mid;\\n            if(isBadVersion(mid)==true)\\n                et=mid-1;\\n            else\\n                st=mid+1;\\n        }\\n        return mid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053906,
                "title": "better-than-100-0ms-used-binary-search-easy-to-understand",
                "content": "\\n\\n# Approach--> Binary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s=0,e=n;\\n        \\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(isBadVersion(mid)==true and isBadVersion(mid-1)!=true)\\n                return mid;\\n            else if(isBadVersion(mid)!=true){\\n                s=mid+1;\\n                }\\n            else if(isBadVersion(mid)){\\n                e=mid-1;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s=0,e=n;\\n        \\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(isBadVersion(mid)==true and isBadVersion(mid-1)!=true)\\n                return mid;\\n            else if(isBadVersion(mid)!=true){\\n                s=mid+1;\\n                }\\n            else if(isBadVersion(mid)){\\n                e=mid-1;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024113,
                "title": "very-easy-solution-java-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l=1;\\n        int h=n;\\n\\n        while(l<=h){\\n            int mid=(l+(h-l)/2);\\n        \\n            if(isBadVersion(mid)==false){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return l;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l=1;\\n        int h=n;\\n\\n        while(l<=h){\\n            int mid=(l+(h-l)/2);\\n        \\n            if(isBadVersion(mid)==false){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return l;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860726,
                "title": "python-binary-search-beats-92",
                "content": "# :: IF YOU LIKE THE SOLUTION PLEASE UP-VOTE ::\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> We can exploit the fact that our search space is linearly increasing so we can use Binary-Search. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\n- We find our solution using Binary Search\\n- store that as answer\\n- discard the right half of search space\\n- try to find if there are answers to the left\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        start = 1\\n        end = n\\n        ans = n\\n        while start < end:\\n            mid = (start + end) // 2\\n\\n            if isBadVersion(mid):\\n                end = mid\\n                ans = mid\\n            else:\\n                start = mid + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        start = 1\\n        end = n\\n        ans = n\\n        while start < end:\\n            mid = (start + end) // 2\\n\\n            if isBadVersion(mid):\\n                end = mid\\n                ans = mid\\n            else:\\n                start = mid + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843329,
                "title": "simple-and-easy-kotlin-solution",
                "content": "```\\nclass Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var start = 1\\n        var end = n\\n        var result = -1\\n        \\n        while(start <= end) {\\n            var medium = start + (end - start) / 2\\n            var isBad = isBadVersion(medium)\\n            if (isBad) {\\n                result = medium\\n                end = medium - 1\\n            } else {\\n                start = medium + 1\\n            }\\n        }\\n        return result\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var start = 1\\n        var end = n\\n        var result = -1\\n        \\n        while(start <= end) {\\n            var medium = start + (end - start) / 2\\n            var isBad = isBadVersion(medium)\\n            if (isBad) {\\n                result = medium\\n                end = medium - 1\\n            } else {\\n                start = medium + 1\\n            }\\n        }\\n        return result\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830258,
                "title": "cpp-easy-to-understand-simple-and-clean",
                "content": "```class Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n         int s=1;\\n        int end=n;\\n        int ans=0;\\n               int  mid=s+(end-s)/2;\\n        while(s<=end)\\n        {\\n         bool flag=isBadVersion(mid);\\n            if(flag==false)\\n            {\\n                s=mid+1;\\n            }\\n            if(flag==true)\\n            {\\n                end=mid-1;\\n                ans=mid;\\n            }\\n            mid=s+(end-s)/2;\\n        }\\n        return ans;\\n    }\\n };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n         int s=1;\\n        int end=n;\\n        int ans=0;\\n               int  mid=s+(end-s)/2;\\n        while(s<=end)\\n        {\\n         bool flag=isBadVersion(mid);\\n            if(flag==false)\\n            {\\n                s=mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2695278,
                "title": "easy-c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int l = 0, r = n;\\n        while(l <= r){\\n            int mid = l + (r - l) / 2;\\n            if(isBadVersion(mid)){\\n                if(mid - 1 >= 0 and !isBadVersion(mid - 1)) return mid;\\n                else r = mid - 1;\\n            }\\n            else l = mid + 1;\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int l = 0, r = n;\\n        while(l <= r){\\n            int mid = l + (r - l) / 2;\\n            if(isBadVersion(mid)){\\n                if(mid - 1 >= 0 and !isBadVersion(mid - 1)) return mid;\\n                else r = mid - 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2609871,
                "title": "java-cpp-python-simple-clean-code",
                "content": "# Basically you have to find the first ocurrence of bad version out of many. This is a slight change from normal finding the Target value.\\n# As we encounter the bad one we\\'ll store that index and will shift the search space to left \\n# May be stored index was the first occurence and we moved to the left that\\'s the reason why we\\'re keeping that index.\\n```\\nint firstBadVersion(int n) {\\n        int left = 0;\\n        int right = n;\\n        int ans = 0;\\n        while(left<=right){\\n            \\n            int mid = left + (right-left)/2;\\n            if(isBadVersion(mid)){\\n                ans = mid;\\n                right = mid-1;\\n            }\\n            else left = mid+1;   \\n        }\\n        return ans;\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nint firstBadVersion(int n) {\\n        int left = 0;\\n        int right = n;\\n        int ans = 0;\\n        while(left<=right){\\n            \\n            int mid = left + (right-left)/2;\\n            if(isBadVersion(mid)){\\n                ans = mid;\\n                right = mid-1;\\n            }\\n            else left = mid+1;   \\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2515446,
                "title": "java-easy-to-understand-o-logn",
                "content": "## Java | Binary Search | O(logn)\\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        if(n==1) return 1;\\n        int l = 1;\\n        int r = n;\\n        while(l<=r){\\n            int m = l+(r-l)/2;\\n            if(isBadVersion(m)){\\n                r = m - 1;\\n            }else{\\n                l = m + 1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        if(n==1) return 1;\\n        int l = 1;\\n        int r = n;\\n        while(l<=r){\\n            int m = l+(r-l)/2;\\n            if(isBadVersion(m)){\\n                r = m - 1;\\n            }else{\\n                l = m + 1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508726,
                "title": "first-bad-version-solution-using-binary-search-with-100-efficiency-and-runtime",
                "content": "The problem asks for the **first occurrence** of the bad version, that is the **lower bound** of the bad version.\\n**Approach -\\n1. We will search whether the mid is bad or good.\\n2. If the mid version is bad, we will further check if it is the first bad version.\\n3. If it is the first bad version we will simply return the mid.\\n4. If it is not the first bad version we can simply call for (r=mid-1), i.e; the lower or first half.\\n5. If the mid version is good then it is clear that, all versions before it will also be good and we will search for the bad version in the upper or greater half, i.e; l = mid + 1.****\\n \\n ****This is simple implementation of finding first occurrence of an element in a sorted array. \\n\\n\\n**CODE:**\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution\\n{\\n    public:\\n        int firstBadVersion(int n)\\n        {\\n            int l = 1, r = n;\\n            while (l <= r)\\n            {\\n                int mid = l + (r - l) / 2;\\n                if (isBadVersion(mid))\\n                {\\n                    if (mid != 1 and isBadVersion(mid - 1))\\n                    {\\n                        r = mid - 1;\\n                    }\\n                    else\\n                    {\\n                        return mid;\\n                    }\\n                }\\n                else\\n                {\\n                    l = mid + 1;\\n                }\\n            }\\n            return r;\\n        }\\n};\\n```\\n\\n**Hope it helps :)          \\nTHANK YOU ! **\\n  **^^^^^^^^^^**",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution\\n{\\n    public:\\n        int firstBadVersion(int n)\\n        {\\n            int l = 1, r = n;\\n            while (l <= r)\\n            {\\n                int mid = l + (r - l) / 2;\\n                if (isBadVersion(mid))\\n                {\\n                    if (mid != 1 and isBadVersion(mid - 1))\\n                    {\\n                        r = mid - 1;\\n                    }\\n                    else\\n                    {\\n                        return mid;\\n                    }\\n                }\\n                else\\n                {\\n                    l = mid + 1;\\n                }\\n            }\\n            return r;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478814,
                "title": "c-0ms-100-faster-easy-binary-search-solution",
                "content": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        \\n        int start = 1;\\n        int end = n;\\n        int bad = n;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end-start)/2;\\n            \\n            if(isBadVersion(mid))\\n            {\\n                bad  = mid;\\n                end = mid-1;\\n            }\\n            else \\n                start = mid+1;\\n        }\\n        \\n        return bad;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/953ed303-3fda-495f-8edc-6ea6d6953329_1661436373.3437002.png)\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        \\n        int start = 1;\\n        int end = n;\\n        int bad = n;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end-start)/2;\\n            \\n            if(isBadVersion(mid))\\n            {\\n                bad  = mid;\\n                end = mid-1;\\n            }\\n            else \\n                start = mid+1;\\n        }\\n        \\n        return bad;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454981,
                "title": "python-c-java-beginner-level-as-simple-as-u-think-100-faster-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q278. First Bad Version***\\nYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API` bool isBadVersion(version)` which returns whether `version` is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        i,j = 1,n\\n        while (i < j):\\n            pivot = (i+j) // 2\\n            if (isBadVersion(pivot)):\\n                j = pivot       \\n            else:\\n                i = pivot + 1   \\n        return i\\n```\\n**Runtime:**  49 ms\\t\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start = 1, end = n;\\n        while (start < end) {\\n        int mid = start + (end-start) / 2;\\n        if (!isBadVersion(mid)) start = mid + 1;\\n        else end = mid;            \\n    }        \\n    return start;\\n    }\\n}\\n```\\n**Runtime:**  20ms\\t\\n**Memory Usage:**  40.4 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int start = 1, end = n;\\n        while (start < end) {\\n        int mid = start + (end-start) / 2;\\n        if (!isBadVersion(mid)) start = mid + 1;\\n        else end = mid;            \\n    }        \\n    return start;\\n    }\\n};\\n```\\n**Runtime:** 0 ms\\t\\t\\n**Memory Usage:**  5.9 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        i,j = 1,n\\n        while (i < j):\\n            pivot = (i+j) // 2\\n            if (isBadVersion(pivot)):\\n                j = pivot       \\n            else:\\n                i = pivot + 1   \\n        return i\\n```\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start = 1, end = n;\\n        while (start < end) {\\n        int mid = start + (end-start) / 2;\\n        if (!isBadVersion(mid)) start = mid + 1;\\n        else end = mid;            \\n    }        \\n    return start;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int start = 1, end = n;\\n        while (start < end) {\\n        int mid = start + (end-start) / 2;\\n        if (!isBadVersion(mid)) start = mid + 1;\\n        else end = mid;            \\n    }        \\n    return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425443,
                "title": "first-bad-version-java-solution-binary-search",
                "content": "```\\npublic int firstBadVersion(int n) {\\n        int start=1;\\n        int end=n;\\n       \\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            \\n            if(isBadVersion(mid))\\n            {\\n                if(isBadVersion(mid-1)==false)\\n                {\\n                    return mid;\\n                }\\n                end=mid;\\n            }else{\\n                \\n                if(isBadVersion(mid+1)==true)\\n                {\\n                    return mid+1;\\n                }\\n                start=mid;\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic int firstBadVersion(int n) {\\n        int start=1;\\n        int end=n;\\n       \\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            \\n            if(isBadVersion(mid))\\n            {\\n                if(isBadVersion(mid-1)==false)\\n                {\\n                    return mid;\\n                }\\n                end=mid;\\n            }else{\\n                \\n                if(isBadVersion(mid+1)==true)\\n                {\\n                    return mid+1;\\n                }\\n                start=mid;\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2375787,
                "title": "isbadversion-fast-simple-easy-c",
                "content": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n       int start=1,end=n,mid;\\n        while(start<end){\\n            mid=start+(end-start)/2;\\n            if(!isBadVersion(mid))\\n                start=mid+1;\\n            else\\n                end=mid;\\n            \\n        }return start;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n       int start=1,end=n,mid;\\n        while(start<end){\\n            mid=start+(end-start)/2;\\n            if(!isBadVersion(mid))\\n                start=mid+1;\\n            else\\n                end=mid;\\n            \\n        }return start;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336626,
                "title": "javascript-2-solutions-easy-understand",
                "content": "```\\n//First Solution -  Runtime is fast since O(logn)\\n\\nvar solution = function(isBadVersion) {\\n    return function(n) {\\n\\t\\tlet last = n, first = Math.floor((2+last)/2);\\n        if(isBadVersion(n) && !isBadVersion(n-1)) return n;\\n        while(!(isBadVersion(first) && !isBadVersion(first-1))) {\\n            if(isBadVersion(first)) {\\n                last = first;\\n                first = 1;\\n            }\\n            first = Math.floor((first+last)/2);\\n        }\\n        return first;\\n    };\\n};\\n\\n//Second solution -  Runtime is slow since it\\'s O(n)\\n\\nvar solution = function(isBadVersion) {\\n    return function(n) {\\n        let first = 1, last = n;\\n        while(first <= last) {\\n            if(isBadVersion(first)) return first;\\n            first++;\\n        }\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//First Solution -  Runtime is fast since O(logn)\\n\\nvar solution = function(isBadVersion) {\\n    return function(n) {\\n\\t\\tlet last = n, first = Math.floor((2+last)/2);\\n        if(isBadVersion(n) && !isBadVersion(n-1)) return n;\\n        while(!(isBadVersion(first) && !isBadVersion(first-1))) {\\n            if(isBadVersion(first)) {\\n                last = first;\\n                first = 1;\\n            }\\n            first = Math.floor((first+last)/2);\\n        }\\n        return first;\\n    };\\n};\\n\\n//Second solution -  Runtime is slow since it\\'s O(n)\\n\\nvar solution = function(isBadVersion) {\\n    return function(n) {\\n        let first = 1, last = n;\\n        while(first <= last) {\\n            if(isBadVersion(first)) return first;\\n            first++;\\n        }\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2330900,
                "title": "javascript-2-solutions-brute-force-binary-search",
                "content": "**Solution 1: Brute Force Solution ~ 10205 ms**\\n\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\n\\nvar solution = function(isBadVersion) {\\n\\n    return function(n) {\\n        for (let i = 1; i <= n; i++) {\\n            if(isBadVersion(i))\\n                return i;\\n        }\\n        \\n        return -1;\\n    };\\n};\\n```\\n\\n**Solution 2: Binary Search ~ 73 ms**\\n\\n```\\n// Time complexity: O(log n)\\n// Space complexity: O(1)\\n\\nvar solution = function(isBadVersion) {\\n\\n    return function(n) {\\n        let index = -1;\\n        let low = 1, high = n;\\n        \\n        while(low <= high) {\\n            const mid = low + parseInt((high - low) / 2);\\n            \\n            if(isBadVersion(mid)) {\\n                index = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        \\n        return index;\\n    };\\n};\\n```\\n\\n***Please upvote if you find this post useful. Happy Coding!***",
                "solutionTags": [],
                "code": "```\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\n\\nvar solution = function(isBadVersion) {\\n\\n    return function(n) {\\n        for (let i = 1; i <= n; i++) {\\n            if(isBadVersion(i))\\n                return i;\\n        }\\n        \\n        return -1;\\n    };\\n};\\n```\n```\\n// Time complexity: O(log n)\\n// Space complexity: O(1)\\n\\nvar solution = function(isBadVersion) {\\n\\n    return function(n) {\\n        let index = -1;\\n        let low = 1, high = n;\\n        \\n        while(low <= high) {\\n            const mid = low + parseInt((high - low) / 2);\\n            \\n            if(isBadVersion(mid)) {\\n                index = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        \\n        return index;\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2273392,
                "title": "c-runtime-0-ms-faster-than-100-00",
                "content": "\\n```\\nApproach: If mid is bad then it means first bad is on the left part of array including mid.\\n\\t\\t\\t\\tif Mid is not bad then the first bad must be on the right part of array.\\n```\\nWith this approach we can apply our simple binary search.\\n**Here we are assuming 1 to n numbers as array, just for understanding.**\\n\\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s = 1, e = n;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(isBadVersion(mid)){\\n                e = mid -1;\\n            }\\n            else{\\n                s = mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nApproach: If mid is bad then it means first bad is on the left part of array including mid.\\n\\t\\t\\t\\tif Mid is not bad then the first bad must be on the right part of array.\\n```\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s = 1, e = n;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(isBadVersion(mid)){\\n                e = mid -1;\\n            }\\n            else{\\n                s = mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238708,
                "title": "python-binary-search-runtime-beats-98-87",
                "content": "### Solution\\nInitially, we assign left pointer to the beginning of the array, and the right to the end. Then, we assign variable mid to the middle of the array. Afterwards, we check if mid is Bad:\\n* If so, we move the right pointer to the (mid - 1) position and change the index we need to the mid \\n\\t\\n\\tFor instance, we have TTTFFFF, where mid is F, so now we check the sub-array TTT to find the earliest bad version and assign bad index to the value of mid\\n* If mid is not Bad, we move left pointer to the (mid+1)\\n\\n\\tFor example, we have TTTTFFF, where mid is T; thus, we check the sub-array FFF to find the initial bad version.\\n\\n```class Solution:\\n    def firstBadVersion(self, n: int) -> int:   \\n        left, right, idx = 0, n, n//2\\n        while left <= right:\\n            mid = (left+right)//2\\n            \\n            if isBadVersion(mid) == True:\\n                right = mid - 1\\n                idx = mid\\n            else:\\n                left = mid + 1\\n       \\n        return idx\\n\\n\\t",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "### Solution\\nInitially, we assign left pointer to the beginning of the array, and the right to the end. Then, we assign variable mid to the middle of the array. Afterwards, we check if mid is Bad:\\n* If so, we move the right pointer to the (mid - 1) position and change the index we need to the mid \\n\\t\\n\\tFor instance, we have TTTFFFF, where mid is F, so now we check the sub-array TTT to find the earliest bad version and assign bad index to the value of mid\\n* If mid is not Bad, we move left pointer to the (mid+1)\\n\\n\\tFor example, we have TTTTFFF, where mid is T; thus, we check the sub-array FFF to find the initial bad version.\\n\\n```class Solution:\\n    def firstBadVersion(self, n: int) -> int:   \\n        left, right, idx = 0, n, n//2\\n        while left <= right:\\n            mid = (left+right)//2\\n            \\n            if isBadVersion(mid) == True:\\n                right = mid - 1\\n                idx = mid\\n            else:\\n                left = mid + 1\\n       \\n        return idx\\n\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 2200722,
                "title": "278-java-python-solution-learn-binary-search-more",
                "content": "Prefered Java ver : (case 2)\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l = 1, r = n;\\n        while (l < r) {\\n            int mid = l + (r-l)/2;\\n            if (isBadVersion(mid)) {\\n                // if mid is a bad version, it could possibly be the first bad ver\\n                // so the right bound of search range becomes mid\\n                r = mid;\\n            } else {\\n                // if mid is a good version, then we can just define the \\n                // left bound of search range as mid+1, since we want a bad version\\n                // and mid is obvious not what we want\\n                l = mid+1;\\n            }\\n        }\\n        // when out of loop, l == r, so we can return either l or r\\n        return l;\\n    }\\n}\\n```\\n\\nJava ver: (case 1)\\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l = 1, r = n, mid = 0;\\n        while (l<=r){\\n            // do not use this: mid = (l+r)/2; it causes int overflow\\n            mid = l + (r-l)/2;\\n            if (!isBadVersion(mid)) l = mid+1;\\n            else r = mid-1;\\n        }\\n        return l;\\n    }\\n}\\n```\\n----\\n## Case 1\\nThoughts:\\nWe have the same idea of binary search, but with differnt loop condition, there would be slightly different but meaningful modification.\\n\\nIn this case, when we go out from the loop, we have index r on the left of index l, which means r+1=l.\\n\\nNow the whole list is devided into 2 parts. nums[0...r] nums[l...n-1]. One part is all good, the other is all bad. So we should return index l.\\n\\t\\nConsider situation that before we go out of loop, if index m is bad, then we move r = m-1\\n\\t\\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l, r = 1, n\\n        while l <= r:\\n            m = (l+r)//2\\n            if isBadVersion(m):\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        return l\\n```\\n-------\\n### Case 2\\nIn this case, when out of loop, we have l=r, and the whole list is also diveded into two parts, with index l (equally index r) to be the pivot point. Before to figure out what to return, let\\'s think about how to update our search space:\\n\\nIf index m is bad version, we will keep the right search range r=m. Why not r=m-1? Because current index could possibly be the first bad version, which is what we want. So we include m itself in the right search range.\\nIf index m is good version, then we can directly move the left range as l = m+1, cause we will not miss the first bad version by doing this.\\nIn the last iteration of while loop, if that m index is bad version, we keep r=m, if it is good, we make l = m+1, and now l=r, we jump out the loop. So l or r must be the first bad version. \\nIn this case, return l or return r are both ok.\\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l, r = 1, n\\n        while l < r:\\n            m = (l+r)//2\\n            if isBadVersion(m):\\n                r = m\\n            else:\\n                l = m+1\\n        return r\\n\\t\\t# return l is also ok\\n```\\n-----\\n### Case 3\\nIn this solution, when out of loop, we have l + 1 = r, the list can be devided into nums[0...l] nums[r...n-1]\\nif index m is bad version, we make right search range shrink, but we have to include m itself in the range.\\nIf index m is good version, we also make left range shrink, included m itself. \\nIn the end, nums[0...l] will all be good, nums[r..n-1] all bad, so r is the index to return.\\nWait....what if the length of nums is 2 or even 1? If the length is 2, then l=0, r=1, we don\\'t even enter the loop, so we can\\'t start searching, which will not give us the correct anwser.\\nWhat if all versions are bad, then l and r cannot partition the list in a correct way. We will always have l=0, r=1, and if we return r like we said above, it would be the right answer, index l = 0 is the first bad version.\\n\\nSo here comes the special trick for this method only: we return either l or right depending on the condition we need. In this problem, we want first bad verision, so we check index l first, if it is bad, we return it. If index l is not bad, then index r must be the first bad version, so we return r instead.\\n\\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l, r = 1, n\\n        while l+1 < r:\\n            m = (l+r)//2\\n            if isBadVersion(m):\\n                r = m\\n            else:\\n                l = m\\n        if isBadVersion(l):\\n            return l\\n        else:\\n            return r\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l = 1, r = n;\\n        while (l < r) {\\n            int mid = l + (r-l)/2;\\n            if (isBadVersion(mid)) {\\n                // if mid is a bad version, it could possibly be the first bad ver\\n                // so the right bound of search range becomes mid\\n                r = mid;\\n            } else {\\n                // if mid is a good version, then we can just define the \\n                // left bound of search range as mid+1, since we want a bad version\\n                // and mid is obvious not what we want\\n                l = mid+1;\\n            }\\n        }\\n        // when out of loop, l == r, so we can return either l or r\\n        return l;\\n    }\\n}\\n```\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l = 1, r = n, mid = 0;\\n        while (l<=r){\\n            // do not use this: mid = (l+r)/2; it causes int overflow\\n            mid = l + (r-l)/2;\\n            if (!isBadVersion(mid)) l = mid+1;\\n            else r = mid-1;\\n        }\\n        return l;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l, r = 1, n\\n        while l <= r:\\n            m = (l+r)//2\\n            if isBadVersion(m):\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        return l\\n```\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l, r = 1, n\\n        while l < r:\\n            m = (l+r)//2\\n            if isBadVersion(m):\\n                r = m\\n            else:\\n                l = m+1\\n        return r\\n\\t\\t# return l is also ok\\n```\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l, r = 1, n\\n        while l+1 < r:\\n            m = (l+r)//2\\n            if isBadVersion(m):\\n                r = m\\n            else:\\n                l = m\\n        if isBadVersion(l):\\n            return l\\n        else:\\n            return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151932,
                "title": "simple-python-binary-search-solution",
                "content": "```class Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l=1\\n        h=n\\n        while(l<=h):\\n            m=(l+h)//2\\n            if(isBadVersion(m)):\\n                h=m-1\\n            else:\\n                l=m+1\\n        return l",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```class Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l=1\\n        h=n\\n        while(l<=h):\\n            m=(l+h)//2\\n            if(isBadVersion(m)):\\n                h=m-1\\n            else:\\n                l=m+1\\n        return l",
                "codeTag": "Java"
            },
            {
                "id": 2135817,
                "title": "python3-binary-search-solution-faster-than-87-41-easily-explained",
                "content": "# Python3 Binary Search Solution.\\n**Runtime: 31 ms, faster than 87.41%\\nMemory Usage: 13.8 MB, less than 60.20%**\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n\\t# We use left = 0, right = n and and check if the mid = (left + right) // 2 is bad that means\\n    # first bad is at left-er side so updating right = mid but if the mid is not bad that means\\n    # the first bad is at right-er side so we update our left = mid + 1; mid + 1 because we\\'ve\\n    # already seen the mid now we want to start from the next that\\'s why +1. And eventually\\n    # while loop exhausts and we find our first bad version at left pointer.\\n        left, right = 1, n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n## Give it a **Upvote** If You Like My Explanation.\\n### Have a Great Day/Night.",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n\\t# We use left = 0, right = n and and check if the mid = (left + right) // 2 is bad that means\\n    # first bad is at left-er side so updating right = mid but if the mid is not bad that means\\n    # the first bad is at right-er side so we update our left = mid + 1; mid + 1 because we\\'ve\\n    # already seen the mid now we want to start from the next that\\'s why +1. And eventually\\n    # while loop exhausts and we find our first bad version at left pointer.\\n        left, right = 1, n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109813,
                "title": "c-simple-binary-search-solution-explanation",
                "content": "# How I think and implement it?\\n(1) Set the range of L, R should be `1,n`\\n(2) write done the condition of matched case. In this problem, we have the condition\\n`isBadVersion(M)  && (M-1<1 || !isBadVersion(M-1))`\\n(3) When tha matched case is not happened, we need to decide search right-side or left-side.\\nSo , when the logic condition `isBadVersion(M)`  is true, then go to the left-side. \\nOtherwise, go to the right-side.\\n\\nSo we have th following code\\n```C++\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int L=1,R=n;\\n        while(L<=R) {\\n            int M = L+(R-L)/2;\\n            if(isBadVersion(M)  && (M-1<1 || !isBadVersion(M-1)) ) {\\n                return M;\\n            }\\n            if(isBadVersion(M)) \\n                R=M-1;\\n            else \\n                L=M+1;\\n        }\\n        return -1; //The code will not be wrong becuase so there\\'s no such case happened\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int L=1,R=n;\\n        while(L<=R) {\\n            int M = L+(R-L)/2;\\n            if(isBadVersion(M)  && (M-1<1 || !isBadVersion(M-1)) ) {\\n                return M;\\n            }\\n            if(isBadVersion(M)) \\n                R=M-1;\\n            else \\n                L=M+1;\\n        }\\n        return -1; //The code will not be wrong becuase so there\\'s no such case happened\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969275,
                "title": "easy-to-understand-java",
                "content": "```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start =0, end = n-1;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            if(isBadVersion(mid)){\\n                end = mid-1;\\n            } else\\n                start = mid+1;\\n        }\\n        return start;\\n    }\\n}\\n```\\nIf you have any **doubts**, feel **free to ask**...\\nIf you understand the **concept**. Don\\'t Forget to **upvote**\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start =0, end = n-1;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            if(isBadVersion(mid)){\\n                end = mid-1;\\n            } else\\n                start = mid+1;\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957600,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int first=1;\\n        int last=n;\\n        int output=0;\\n        while(first<=last){\\n            int mid=first+(last-first)/2;\\n         if(isBadVersion(mid)){\\n             output=mid; // we found the bad version but its not the first one so we will keep on reducing the last ele...\\n             last=mid-1;\\n         }else{\\n            first=mid+1;\\n    }}\\n            return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int first=1;\\n        int last=n;\\n        int output=0;\\n        while(first<=last){\\n            int mid=first+(last-first)/2;\\n         if(isBadVersion(mid)){\\n             output=mid; // we found the bad version but its not the first one so we will keep on reducing the last ele...\\n             last=mid-1;\\n         }else{\\n            first=mid+1;\\n    }}\\n            return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939030,
                "title": "rust-binary-search-and-notes-on-overflows",
                "content": "```\\nimpl Solution {\\n    pub fn first_bad_version(&self, n: i32) -> i32 {\\n        let mut low = 1i32;\\n        let mut high = n;\\n        let mut mid = low + (high - low)/2;\\n        \\n        while low <= high {\\n            if self.isBadVersion(mid) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n            mid = low + (high - low)/2;\\n        }\\n        high + 1\\n    }\\n}\\n```\\n\\nNote how ```mid``` is computed:```mid = low + (high - low)/2;```\\nThis is mathematically equivalent to ```mid = (low + high)/2;```\\nHowever, the latter will cause overflow on one of the test cases ([2126753390, 1702766719]) since we\\'re dealing with ```i32``` types.",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn first_bad_version(&self, n: i32) -> i32 {\\n        let mut low = 1i32;\\n        let mut high = n;\\n        let mut mid = low + (high - low)/2;\\n        \\n        while low <= high {\\n            if self.isBadVersion(mid) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n            mid = low + (high - low)/2;\\n        }\\n        high + 1\\n    }\\n}\\n```\n```mid```\n```mid = low + (high - low)/2;```\n```mid = (low + high)/2;```\n```i32```",
                "codeTag": "Unknown"
            },
            {
                "id": 1916083,
                "title": "python",
                "content": "\\n    def firstBadVersion(self, n):\\n        left, right = 1, n\\n        \\n        \\n        while left<=right:\\n            mid = (left+right)//2\\n            \\n            if isBadVersion(mid):\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n                \\n        return left",
                "solutionTags": [],
                "code": "\\n    def firstBadVersion(self, n):\\n        left, right = 1, n\\n        \\n        \\n        while left<=right:\\n            mid = (left+right)//2\\n            \\n            if isBadVersion(mid):\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n                \\n        return left",
                "codeTag": "Python3"
            },
            {
                "id": 1884753,
                "title": "first-bad-version-100-solutions",
                "content": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s=0; \\n        int e=n;\\n        int ans=0;\\n        int mid=s+(e-s)/2;\\n        while(s<=e){\\n            if(isBadVersion(mid)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n            mid=s+(e-s)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s=0; \\n        int e=n;\\n        int ans=0;\\n        int mid=s+(e-s)/2;\\n        while(s<=e){\\n            if(isBadVersion(mid)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n            mid=s+(e-s)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567767,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1570560,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1696954,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1564807,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1680905,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1566378,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1567940,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1569858,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1576911,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1568584,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1567767,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1570560,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1696954,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1564807,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1680905,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1566378,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1567940,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1569858,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1576911,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1568584,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1567241,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1779455,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1567765,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1568733,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1575357,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1570423,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1568721,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1791334,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1742580,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1694996,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1569053,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1576233,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1576804,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1576648,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1576327,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1575215,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1574727,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1573357,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1571520,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1571521,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1569856,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 1569449,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 1571519,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 2073213,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 2063610,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 2044421,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 2035858,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 2034330,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 2033025,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 2027396,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 2018854,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 2011885,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 2007884,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 2006656,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 2005791,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 1989693,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 1973557,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 1943972,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 1930649,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 1920014,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 1902683,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1898201,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1886485,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1884953,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1883324,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1870898,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1870544,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1867983,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1865839,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1863345,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1863313,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1862819,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1861451,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1856829,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1854891,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1851742,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1842932,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1833737,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1832438,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1826503,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1815492,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1809429,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1809332,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1809300,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1808438,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1807697,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1806473,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1804667,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1801168,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1801123,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1789465,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1784401,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1777815,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1776548,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1775407,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1770915,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1770231,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1763584,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1760316,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1760241,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1757920,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1748249,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1745076,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1737472,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1735619,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1734813,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1734714,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1733570,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1730439,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1729005,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1727436,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1726608,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1726167,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1725108,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1724918,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1723797,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1723186,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1707342,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1687710,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1681326,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            }
        ]
    },
    {
        "title": "Kth Smallest Element in a Sorted Matrix",
        "question_content": "<p>Given an <code>n x n</code> <code>matrix</code> where each of the rows and columns is sorted in ascending order, return <em>the</em> <code>k<sup>th</sup></code> <em>smallest element in the matrix</em>.</p>\n\n<p>Note that it is the <code>k<sup>th</sup></code> smallest element <strong>in the sorted order</strong>, not the <code>k<sup>th</sup></code> <strong>distinct</strong> element.</p>\n\n<p>You must find a solution with a memory complexity better than <code>O(n<sup>2</sup>)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n<strong>Output:</strong> 13\n<strong>Explanation:</strong> The elements in the matrix are [1,5,9,10,11,12,13,<u><strong>13</strong></u>,15], and the 8<sup>th</sup> smallest number is 13\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> matrix = [[-5]], k = 1\n<strong>Output:</strong> -5\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 300</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>\n\t<li>All the rows and columns of <code>matrix</code> are <strong>guaranteed</strong> to be sorted in <strong>non-decreasing order</strong>.</li>\n\t<li><code>1 &lt;= k &lt;= n<sup>2</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Could you solve the problem with a constant memory (i.e., <code>O(1)</code> memory complexity)?</li>\n\t<li>Could you solve the problem in <code>O(n)</code> time complexity? The solution may be too advanced for an interview but you may find reading <a href=\"http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf\" target=\"_blank\">this paper</a> fun.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1322101,
                "title": "c-java-python-maxheap-minheap-binary-search-picture-explain-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Max Heap keeps up to k elements**\\n- The easy approach is that we iterate all elements in the matrix and and add elements into the `maxHeap`. The `maxHeap` will keep up to `k` smallest elements (because when maxHeap is over size of k, we do remove the top of maxHeap which is the largest one). Finally, the top of the `maxHeap` is the **kth smallest element** in the matrix.\\n- This approach leads this problem become the same with [215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/1349609/), which doesn\\'t take the advantage that the matrix is already sorted by rows and by columns.\\n\\n<iframe src=\"https://leetcode.com/playground/iXdvR2BJ/shared\" frameBorder=\"0\" width=\"100%\" height=\"340\"></iframe>\\n\\n- Complexity:\\n\\t- Time: `O(M * N * logK)`, where `M <= 300` is the number of rows, `N <= 300` is the number of columns.\\n\\t- Space: `O(K)`, space for heap which stores up to `k` elements. \\n- - -\\n**\\u2714\\uFE0F Solution 2: Min Heap to find kth smallest element from amongst N sorted list**\\n- Since each of the rows in matrix are already sorted, we can understand the problem as finding the **kth smallest element** from amongst `M` sorted rows.\\n- We start the pointers to point to the beginning of each rows, then we iterate `k` times, for each time `ith`, the top of the `minHeap` is the `ith` smallest element in the matrix. We pop the `top` from the `minHeap` then add the next element which has the same row with that `top` to the `minHeap`.  \\n\\n![image](https://assets.leetcode.com/users/images/47843946-761b-49f9-a06f-5a973fca3ddc_1625719598.4144652.png)\\n<iframe src=\"https://leetcode.com/playground/gJuvFCz5/shared\" frameBorder=\"0\" width=\"100%\" height=\"370\"></iframe>\\n\\nComplexity:\\n- Time: `O(K * logK)`\\n- Space: `O(K)`\\n- - -\\n**\\u2714\\uFE0F Solution 3: Binary Search**\\n- **Idea** \\n\\t- We binary search to find **the smallest `ans`** in range `[minOfMatrix..maxOfMatrix]` such that **countLessOrEqual(ans) >= k**, where `countLessOrEqual(x)` is the number of elements less than or equal to `x`.\\n\\t- Why `ans` must be as smallest as possible?\\n\\t![image](https://assets.leetcode.com/users/images/804e1087-48b0-4a1c-a90b-d8b3bec20b5f_1625680618.3385735.png)\\n\\n\\t- Why `countLessOrEqual(ans) >= k` but not `countLessOrEqual(ans) == k`?\\n\\t![image](https://assets.leetcode.com/users/images/30391e13-562f-4b6d-a634-da4f1c285e29_1625680652.3568685.png)\\n\\n\\n- **Algorithm**\\n\\t- Start with `left = minOfMatrix = matrix[0][0]` and `right = maxOfMatrix = matrix[n-1][n-1]`.\\n\\t- Find the `mid` of the `left` and the `right`. This middle number is **NOT necessarily** an element in the matrix.\\n\\t- If `countLessOrEqual(mid) >= k`, we keep current `ans = mid` and try to find smaller value by searching in the left side. Otherwise, we search in the right side.\\n\\t- Since `ans` is the smallest value which `countLessOrEqual(ans) >= k`, so it\\'s the **k th smallest element in the matrix**.\\n- **How to count number of elements less or equal to `x` efficiently?**\\n\\t- Since our `matrix` is sorted in ascending order by rows and columns.\\n\\t- We use two pointers, one points to the rightmost column `c = n-1`, and one points to the lowest row `r = 0`.\\n\\t\\t- If `matrix[r][c] <= x` then the number of elements in row `r` less or equal to `x` is  `(c+1)` (Because row[r] is sorted in ascending order, so if matrix[r][c] <= x then matrix[r][c-1] is also <= x). Then we go to next row to continue counting.\\n\\t\\t- Else if `matrix[r][c] > x`, we decrease column `c` until `matrix[r][c] <= x ` (Because column is sorted in ascending order, so if matrix[r][c] > x then matrix[r+1][c] is also > x).\\n\\t- Time complexity for counting: `O(M+N)`.\\n\\t- It\\'s exactly the same idea with this problem: [240. Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/)\\n\\n![image](https://assets.leetcode.com/users/images/fc7abf43-7537-41ee-addc-7b73b219c9eb_1625657181.1571143.png)\\n\\n**Implementation**\\n<iframe src=\"https://leetcode.com/playground/VQgkL59y/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\n**Complexity**\\n- Time: `O((M+N) * logD)`, where `M <= 300` is the number of rows, `N <= 300` is the number of columns, `D <= 2*10^9` is the difference between the maximum element and the minimum element in the matrix.\\n- Space: `O(1)`.\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome**! Thanks.",
                "solutionTags": [
                    "Binary Search",
                    "Heap (Priority Queue)"
                ],
                "code": "**\\u2714\\uFE0F Solution 1: Max Heap keeps up to k elements**\\n- The easy approach is that we iterate all elements in the matrix and and add elements into the `maxHeap`. The `maxHeap` will keep up to `k` smallest elements (because when maxHeap is over size of k, we do remove the top of maxHeap which is the largest one). Finally, the top of the `maxHeap` is the **kth smallest element** in the matrix.\\n- This approach leads this problem become the same with [215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/1349609/), which doesn\\'t take the advantage that the matrix is already sorted by rows and by columns.\\n\\n<iframe src=\"https://leetcode.com/playground/iXdvR2BJ/shared\" frameBorder=\"0\" width=\"100%\" height=\"340\"></iframe>\\n\\n- Complexity:\\n\\t- Time: `O(M * N * logK)`, where `M <= 300` is the number of rows, `N <= 300` is the number of columns.\\n\\t- Space: `O(K)`, space for heap which stores up to `k` elements. \\n- - -\\n**\\u2714\\uFE0F Solution 2: Min Heap to find kth smallest element from amongst N sorted list**\\n- Since each of the rows in matrix are already sorted, we can understand the problem as finding the **kth smallest element** from amongst `M` sorted rows.\\n- We start the pointers to point to the beginning of each rows, then we iterate `k` times, for each time `ith`, the top of the `minHeap` is the `ith` smallest element in the matrix. We pop the `top` from the `minHeap` then add the next element which has the same row with that `top` to the `minHeap`.  \\n\\n![image](https://assets.leetcode.com/users/images/47843946-761b-49f9-a06f-5a973fca3ddc_1625719598.4144652.png)\\n<iframe src=\"https://leetcode.com/playground/gJuvFCz5/shared\" frameBorder=\"0\" width=\"100%\" height=\"370\"></iframe>\\n\\nComplexity:\\n- Time: `O(K * logK)`\\n- Space: `O(K)`\\n- - -\\n**\\u2714\\uFE0F Solution 3: Binary Search**\\n- **Idea** \\n\\t- We binary search to find **the smallest `ans`** in range `[minOfMatrix..maxOfMatrix]` such that **countLessOrEqual(ans) >= k**, where `countLessOrEqual(x)` is the number of elements less than or equal to `x`.\\n\\t- Why `ans` must be as smallest as possible?\\n\\t![image](https://assets.leetcode.com/users/images/804e1087-48b0-4a1c-a90b-d8b3bec20b5f_1625680618.3385735.png)\\n\\n\\t- Why `countLessOrEqual(ans) >= k` but not `countLessOrEqual(ans) == k`?\\n\\t![image](https://assets.leetcode.com/users/images/30391e13-562f-4b6d-a634-da4f1c285e29_1625680652.3568685.png)\\n\\n\\n- **Algorithm**\\n\\t- Start with `left = minOfMatrix = matrix[0][0]` and `right = maxOfMatrix = matrix[n-1][n-1]`.\\n\\t- Find the `mid` of the `left` and the `right`. This middle number is **NOT necessarily** an element in the matrix.\\n\\t- If `countLessOrEqual(mid) >= k`, we keep current `ans = mid` and try to find smaller value by searching in the left side. Otherwise, we search in the right side.\\n\\t- Since `ans` is the smallest value which `countLessOrEqual(ans) >= k`, so it\\'s the **k th smallest element in the matrix**.\\n- **How to count number of elements less or equal to `x` efficiently?**\\n\\t- Since our `matrix` is sorted in ascending order by rows and columns.\\n\\t- We use two pointers, one points to the rightmost column `c = n-1`, and one points to the lowest row `r = 0`.\\n\\t\\t- If `matrix[r][c] <= x` then the number of elements in row `r` less or equal to `x` is  `(c+1)` (Because row[r] is sorted in ascending order, so if matrix[r][c] <= x then matrix[r][c-1] is also <= x). Then we go to next row to continue counting.\\n\\t\\t- Else if `matrix[r][c] > x`, we decrease column `c` until `matrix[r][c] <= x ` (Because column is sorted in ascending order, so if matrix[r][c] > x then matrix[r+1][c] is also > x).\\n\\t- Time complexity for counting: `O(M+N)`.\\n\\t- It\\'s exactly the same idea with this problem: [240. Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/)\\n\\n![image](https://assets.leetcode.com/users/images/fc7abf43-7537-41ee-addc-7b73b219c9eb_1625657181.1571143.png)\\n\\n**Implementation**\\n<iframe src=\"https://leetcode.com/playground/VQgkL59y/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\n**Complexity**\\n- Time: `O((M+N) * logD)`, where `M <= 300` is the number of rows, `N <= 300` is the number of columns, `D <= 2*10^9` is the difference between the maximum element and the minimum element in the matrix.\\n- Space: `O(1)`.\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome**! Thanks.",
                "codeTag": "Unknown"
            },
            {
                "id": 85173,
                "title": "share-my-thoughts-and-clean-java-code",
                "content": "Solution 1 : Heap\\nHere is the step of my solution:\\n1. Build a minHeap of elements from the first row.\\n2. Do the following operations k-1 times : \\n  Every time when you poll out the root(Top Element in Heap),  you need to know the row number and column number of that element(so we can create a tuple class here), replace that root with the next element from the same column.\\n\\nAfter you finish this problem, thinks more :\\n1. For this question, you can also build a min Heap from the first column, and do the similar operations as above.(Replace the root with the next element from the same row)\\n2. What is more, this problem is exact the same with Leetcode373 Find K Pairs with Smallest Sums, I use the same code which beats 96.42%, after you solve this problem, you can check with this link:\\nhttps://discuss.leetcode.com/topic/52953/share-my-solution-which-beat-96-42\\n```\\npublic class Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        PriorityQueue<Tuple> pq = new PriorityQueue<Tuple>();\\n        for(int j = 0; j <= n-1; j++) pq.offer(new Tuple(0, j, matrix[0][j]));\\n        for(int i = 0; i < k-1; i++) {\\n            Tuple t = pq.poll();\\n            if(t.x == n-1) continue;\\n            pq.offer(new Tuple(t.x+1, t.y, matrix[t.x+1][t.y]));\\n        }\\n        return pq.poll().val;\\n    }\\n}\\n\\nclass Tuple implements Comparable<Tuple> {\\n    int x, y, val;\\n    public Tuple (int x, int y, int val) {\\n        this.x = x;\\n        this.y = y;\\n        this.val = val;\\n    }\\n    \\n    @Override\\n    public int compareTo (Tuple that) {\\n        return this.val - that.val;\\n    }\\n}\\n```\\n\\nSolution 2 : Binary Search\\nWe are done here, but let's think about this problem in another way:\\nThe key point for any binary search is to figure out the \"Search Space\". For me, I think there are two kind of \"Search Space\" -- index and range(the range from the smallest number to the biggest number). Most usually, when the array is sorted in one direction, we can use index as \"search space\", when the array is unsorted and we are going to find a specific number, we can use \"range\".\\n\\nLet me give you two examples of these two \"search space\"\\n1. index -- A bunch of examples -- https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/ ( the array is sorted)\\n2. range -- https://leetcode.com/problems/find-the-duplicate-number/ (Unsorted Array)\\n\\nThe reason why we did not use index as \"search space\" for this problem is the matrix is sorted in two directions, we can not find a linear way to map the number and its index.\\n```\\npublic class Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int lo = matrix[0][0], hi = matrix[matrix.length - 1][matrix[0].length - 1] + 1;//[lo, hi)\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int count = 0,  j = matrix[0].length - 1;\\n            for(int i = 0; i < matrix.length; i++) {\\n                while(j >= 0 && matrix[i][j] > mid) j--;\\n                count += (j + 1);\\n            }\\n            if(count < k) lo = mid + 1;\\n            else hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        PriorityQueue<Tuple> pq = new PriorityQueue<Tuple>();\\n        for(int j = 0; j <= n-1; j++) pq.offer(new Tuple(0, j, matrix[0][j]));\\n        for(int i = 0; i < k-1; i++) {\\n            Tuple t = pq.poll();\\n            if(t.x == n-1) continue;\\n            pq.offer(new Tuple(t.x+1, t.y, matrix[t.x+1][t.y]));\\n        }\\n        return pq.poll().val;\\n    }\\n}\\n\\nclass Tuple implements Comparable<Tuple> {\\n    int x, y, val;\\n    public Tuple (int x, int y, int val) {\\n        this.x = x;\\n        this.y = y;\\n        this.val = val;\\n    }\\n    \\n    @Override\\n    public int compareTo (Tuple that) {\\n        return this.val - that.val;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int lo = matrix[0][0], hi = matrix[matrix.length - 1][matrix[0].length - 1] + 1;//[lo, hi)\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int count = 0,  j = matrix[0].length - 1;\\n            for(int i = 0; i < matrix.length; i++) {\\n                while(j >= 0 && matrix[i][j] > mid) j--;\\n                count += (j + 1);\\n            }\\n            if(count < k) lo = mid + 1;\\n            else hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85170,
                "title": "o-n-from-paper-yes-o-rows",
                "content": "It's O(n) where n is the number of rows (and columns), not the number of elements. So it's very efficient. The algorithm is from the paper [Selection in X + Y and matrices with sorted rows and columns](http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf), which I first saw mentioned by @elmirap (thanks).\\n\\n**The basic idea:** Consider the submatrix you get by removing every second row and every second column. This has about a quarter of the elements of the original matrix. And the k-th element (k-th *smallest* I mean) of the original matrix is roughly the (k/4)-th element of the submatrix. So roughly get the (k/4)-th element of the submatrix and then use that to find the k-th element of the original matrix in O(n) time. It's recursive, going down to smaller and smaller submatrices until a trivial 2\\xd72 matrix. For more details I suggest checking out the paper, the first half is easy to read and explains things well. Or @zhiqing_xiao's [solution+explanation](https://discuss.leetcode.com/topic/54262/o-row-time-o-row-space-solution-with-detail-intuitive-explanation-c-accepted).\\n\\n**Cool:** It uses variants of [saddleback search](http://cs.geneseo.edu/~baldwin/math-thinking/saddleback.html) that you might know for example from the [Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/) problem. And it uses the [median of medians](https://en.wikipedia.org/wiki/Median_of_medians) algorithm for linear-time selection.\\n\\n**Optimization:** If k is less than n, we only need to consider the top-left k\\xd7k matrix. Similar if k is almost n<sup>2</sup>. So it's even O(min(n, k, n^2-k)), I just didn't mention that in the title because I wanted to keep it simple and because those few very small or very large k are unlikely, most of the time k will be \"medium\" (and average n<sup>2</sup>/2).\\n\\n**Implementation:** I implemented the submatrix by using an index list through which the actual matrix data gets accessed. If [0, 1, 2, ..., n-1] is the index list of the original matrix, then [0, 2, 4, ...] is the index list of the submatrix and [0, 4, 8, ...] is the index list of the subsubmatrix and so on. This also covers the above optimization by starting with [0, 1, 2, ..., **k**-1] when applicable.\\n\\n**Application:** I believe it can be used to easily solve the [Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/) problem in time O(k) instead of O(k log n), which I think is the best posted so far. I might try that later if nobody beats me to it (if you do, let me know :-). ***Update:*** I [did that now](https://discuss.leetcode.com/topic/53380/o-k-solution).\\n\\n```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n\\n        # The median-of-medians selection function.\\n        def pick(a, k):\\n            if k == 1:\\n                return min(a)\\n            groups = (a[i:i+5] for i in range(0, len(a), 5))\\n            medians = [sorted(group)[len(group) / 2] for group in groups]\\n            pivot = pick(medians, len(medians) / 2 + 1)\\n            smaller = [x for x in a if x < pivot]\\n            if k <= len(smaller):\\n                return pick(smaller, k)\\n            k -= len(smaller) + a.count(pivot)\\n            return pivot if k < 1 else pick([x for x in a if x > pivot], k)\\n\\n        # Find the k1-th and k2th smallest entries in the submatrix.\\n        def biselect(index, k1, k2):\\n\\n            # Provide the submatrix.\\n            n = len(index)\\n            def A(i, j):\\n                return matrix[index[i]][index[j]]\\n            \\n            # Base case.\\n            if n <= 2:\\n                nums = sorted(A(i, j) for i in range(n) for j in range(n))\\n                return nums[k1-1], nums[k2-1]\\n\\n            # Solve the subproblem.\\n            index_ = index[::2] + index[n-1+n%2:]\\n            k1_ = (k1 + 2*n) / 4 + 1 if n % 2 else n + 1 + (k1 + 3) / 4\\n            k2_ = (k2 + 3) / 4\\n            a, b = biselect(index_, k1_, k2_)\\n\\n            # Prepare ra_less, rb_more and L with saddleback search variants.\\n            ra_less = rb_more = 0\\n            L = []\\n            jb = n   # jb is the first where A(i, jb) is larger than b.\\n            ja = n   # ja is the first where A(i, ja) is larger than or equal to a.\\n            for i in range(n):\\n                while jb and A(i, jb - 1) > b:\\n                    jb -= 1\\n                while ja and A(i, ja - 1) >= a:\\n                    ja -= 1\\n                ra_less += ja\\n                rb_more += n - jb\\n                L.extend(A(i, j) for j in range(jb, ja))\\n                \\n            # Compute and return x and y.\\n            x = a if ra_less <= k1 - 1 else \\\\\\n                b if k1 + rb_more - n*n <= 0 else \\\\\\n                pick(L, k1 + rb_more - n*n)\\n            y = a if ra_less <= k2 - 1 else \\\\\\n                b if k2 + rb_more - n*n <= 0 else \\\\\\n                pick(L, k2 + rb_more - n*n)\\n            return x, y\\n\\n        # Set up and run the search.\\n        n = len(matrix)\\n        start = max(k - n*n + n-1, 0)\\n        k -= n*n - (n - start)**2\\n        return biselect(range(start, min(n, start+k)), k, k)[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n\\n        # The median-of-medians selection function.\\n        def pick(a, k):\\n            if k == 1:\\n                return min(a)\\n            groups = (a[i:i+5] for i in range(0, len(a), 5))\\n            medians = [sorted(group)[len(group) / 2] for group in groups]\\n            pivot = pick(medians, len(medians) / 2 + 1)\\n            smaller = [x for x in a if x < pivot]\\n            if k <= len(smaller):\\n                return pick(smaller, k)\\n            k -= len(smaller) + a.count(pivot)\\n            return pivot if k < 1 else pick([x for x in a if x > pivot], k)\\n\\n        # Find the k1-th and k2th smallest entries in the submatrix.\\n        def biselect(index, k1, k2):\\n\\n            # Provide the submatrix.\\n            n = len(index)\\n            def A(i, j):\\n                return matrix[index[i]][index[j]]\\n            \\n            # Base case.\\n            if n <= 2:\\n                nums = sorted(A(i, j) for i in range(n) for j in range(n))\\n                return nums[k1-1], nums[k2-1]\\n\\n            # Solve the subproblem.\\n            index_ = index[::2] + index[n-1+n%2:]\\n            k1_ = (k1 + 2*n) / 4 + 1 if n % 2 else n + 1 + (k1 + 3) / 4\\n            k2_ = (k2 + 3) / 4\\n            a, b = biselect(index_, k1_, k2_)\\n\\n            # Prepare ra_less, rb_more and L with saddleback search variants.\\n            ra_less = rb_more = 0\\n            L = []\\n            jb = n   # jb is the first where A(i, jb) is larger than b.\\n            ja = n   # ja is the first where A(i, ja) is larger than or equal to a.\\n            for i in range(n):\\n                while jb and A(i, jb - 1) > b:\\n                    jb -= 1\\n                while ja and A(i, ja - 1) >= a:\\n                    ja -= 1\\n                ra_less += ja\\n                rb_more += n - jb\\n                L.extend(A(i, j) for j in range(jb, ja))\\n                \\n            # Compute and return x and y.\\n            x = a if ra_less <= k1 - 1 else \\\\\\n                b if k1 + rb_more - n*n <= 0 else \\\\\\n                pick(L, k1 + rb_more - n*n)\\n            y = a if ra_less <= k2 - 1 else \\\\\\n                b if k2 + rb_more - n*n <= 0 else \\\\\\n                pick(L, k2 + rb_more - n*n)\\n            return x, y\\n\\n        # Set up and run the search.\\n        n = len(matrix)\\n        start = max(k - n*n + n-1, 0)\\n        k -= n*n - (n - start)**2\\n        return biselect(range(start, min(n, start+k)), k, k)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85182,
                "title": "my-solution-using-binary-search-in-c",
                "content": "```\\nclass Solution\\n{\\npublic:\\n\\tint kthSmallest(vector<vector<int>>& matrix, int k)\\n\\t{\\n\\t\\tint n = matrix.size();\\n\\t\\tint le = matrix[0][0], ri = matrix[n - 1][n - 1];\\n\\t\\tint mid = 0;\\n\\t\\twhile (le < ri)\\n\\t\\t{\\n\\t\\t\\tmid = le + (ri-le)/2;\\n\\t\\t\\tint num = 0;\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint pos = upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();\\n\\t\\t\\t\\tnum += pos;\\n\\t\\t\\t}\\n\\t\\t\\tif (num < k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tle = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tri = mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn le;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tint kthSmallest(vector<vector<int>>& matrix, int k)\\n\\t{\\n\\t\\tint n = matrix.size();\\n\\t\\tint le = matrix[0][0], ri = matrix[n - 1][n - 1];\\n\\t\\tint mid = 0;\\n\\t\\twhile (le < ri)\\n\\t\\t{\\n\\t\\t\\tmid = le + (ri-le)/2;\\n\\t\\t\\tint num = 0;\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint pos = upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();\\n\\t\\t\\t\\tnum += pos;\\n\\t\\t\\t}\\n\\t\\t\\tif (num < k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tle = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tri = mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn le;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85177,
                "title": "java-1ms-nlog-max-min-solution",
                "content": "Main loop is binary search of max - min.\\nSwap from left-bottom to right-top can get  count <= mid in O(n) time instead of O(nlogn), total complexity will be O(nlogm) while m = max - min.\\n\\n```\\npublic class Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        int lo = matrix[0][0], hi = matrix[n - 1][n - 1];\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int count = getLessEqual(matrix, mid);\\n            if (count < k) lo = mid + 1;\\n            else hi = mid - 1;\\n        }\\n        return lo;\\n    }\\n    \\n    private int getLessEqual(int[][] matrix, int val) {\\n        int res = 0;\\n        int n = matrix.length, i = n - 1, j = 0;\\n        while (i >= 0 && j < n) {\\n            if (matrix[i][j] > val) i--;\\n            else {\\n                res += i + 1;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        int lo = matrix[0][0], hi = matrix[n - 1][n - 1];\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int count = getLessEqual(matrix, mid);\\n            if (count < k) lo = mid + 1;\\n            else hi = mid - 1;\\n        }\\n        return lo;\\n    }\\n    \\n    private int getLessEqual(int[][] matrix, int val) {\\n        int res = 0;\\n        int n = matrix.length, i = n - 1, j = 0;\\n        while (i >= 0 && j < n) {\\n            if (matrix[i][j] > val) i--;\\n            else {\\n                res += i + 1;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167784,
                "title": "java-binary-search-with-explanations",
                "content": "To find the kth smallest is to the find the first one which is >= kth smallest, that is, the first one which has >= k non-bigger elements. We could apply lower-bound Binary Search among [min, max] for min is the topleft cell while max is the bottom right cell.\\n\\nIn the utility method `countNonBigger`, we can make use of the sorting feature of the matrix. That is, if we start at the bottomleft, for the bigger, we can only move right, for the smaller, we can only move up, and accumulate the number of elements upon the cell (inclusive) within the same column.\\n****\\n```\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length, lo = matrix[0][0], hi = matrix[n - 1][n - 1];\\n        \\n        while (lo <= hi) {\\n            int mi = lo + ((hi - lo) >> 1);\\n            int count = countNonBigger(mi, matrix);\\n            if (count < k) {\\n                lo = mi + 1;\\n            } else {\\n                hi = mi - 1;\\n            }\\n        }\\n        \\n        return lo;\\n    }\\n    \\n    private static int countNonBigger(int target, int[][] matrix) {\\n        int n = matrix.length, i = n - 1, j = 0, cnt = 0;\\n        while (i >= 0 && j < n) {\\n            if (matrix[i][j] > target) {\\n                i--;\\n            } else {\\n                cnt += i + 1;\\n                j++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n```\\n**(\\uFF89>\\u03C9<)\\uFF89 Vote up, please!**",
                "solutionTags": [],
                "code": "```\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length, lo = matrix[0][0], hi = matrix[n - 1][n - 1];\\n        \\n        while (lo <= hi) {\\n            int mi = lo + ((hi - lo) >> 1);\\n            int count = countNonBigger(mi, matrix);\\n            if (count < k) {\\n                lo = mi + 1;\\n            } else {\\n                hi = mi - 1;\\n            }\\n        }\\n        \\n        return lo;\\n    }\\n    \\n    private static int countNonBigger(int target, int[][] matrix) {\\n        int n = matrix.length, i = n - 1, j = 0, cnt = 0;\\n        while (i >= 0 && j < n) {\\n            if (matrix[i][j] > target) {\\n                i--;\\n            } else {\\n                cnt += i + 1;\\n                j++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85193,
                "title": "binary-search-heap-and-sorting-comparison-with-concise-code-and-1-liners-python-72-ms",
                "content": "For n X n matrix,\\n\\n**1. Binary search** (based on the [solution](https://discuss.leetcode.com/topic/52865/my-solution-using-binary-search-in-c) from @\\u5149\\u901f\\u5c0f\\u5b50) gives me 72 ms. \\n\\nThe time complexity is O(n * log(n) * log(N)), where N is the search space that ranges from the smallest element to the biggest element. You can argue that int implies N = 2^32, so log(N) is constant. In a way, this is an O(n * log(n)) solution.\\n\\nThe space complexity is constant.\\n\\nI thought this idea was weird for a while. Then I noticed the previous problem 377. Combination Sum IV is pretty much doing the same thing, so this idea may actually be intended.\\n\\nHere is a 8-liner implementation:\\n```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        lo, hi = matrix[0][0], matrix[-1][-1]\\n        while lo<hi:\\n            mid = (lo+hi)//2\\n            if sum(bisect.bisect_right(row, mid) for row in matrix) < k:\\n                lo = mid+1\\n            else:\\n                hi = mid\\n        return lo\\n```\\n\\n**2. Heap solution** gives me 176 ms. The time complexity is O(k * log n), so the worst-case and average-case time complexity is O(n^2 * log n). Space complexity is O(n).\\n\\n```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        heap = [(row[0], i, 0) for i, row in enumerate(matrix)]\\n        heapq.heapify(heap)\\n        ret = 0\\n        for _ in range(k):\\n            ret, i, j = heapq.heappop(heap)\\n            if j+1 < len(matrix[0]):\\n                heapq.heappush(heap, (matrix[i][j+1], i, j+1))\\n        return ret\\n```\\n\\n**3. Sorting** gives me 80ms. Time complexity of sorting an array of size n^2 is O(n^2 * log n). Space complexity is O(n^2).\\n\\nThe difference is that Timsort implemented in Python is capable of taking advantage of existing partial orderings. Moving sorted data in bulk is always faster than comparing and moving individual data elements, due to modern hardware architecture. Time complexity is the same because merging n sorted arrays of size n is still O(n^2 * log n) in the worst case.\\n \\n```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        l = []\\n        for row in matrix:\\n            l += row\\n        return sorted(l)[k-1]\\n```\\n\\nHere are some O(n^3) (slow due to list concatenation) 1-liners:\\n```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        return sorted(sum(matrix, []))[k-1]\\n```\\nand\\n```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        return sorted(reduce(lambda a,b:a+b, matrix))[k-1]\\n```\\n\\nHere are some O(n^2 * log n) 1-liners provided by @StefanPochmann \\n```\\n    return sorted(itertools.chain(*matrix))[k-1]\\n    return sorted(a for row in matrix for a in row)[k-1]\\n    return sorted(itertools.chain.from_iterable(matrix))[k-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        lo, hi = matrix[0][0], matrix[-1][-1]\\n        while lo<hi:\\n            mid = (lo+hi)//2\\n            if sum(bisect.bisect_right(row, mid) for row in matrix) < k:\\n                lo = mid+1\\n            else:\\n                hi = mid\\n        return lo\\n```\n```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        heap = [(row[0], i, 0) for i, row in enumerate(matrix)]\\n        heapq.heapify(heap)\\n        ret = 0\\n        for _ in range(k):\\n            ret, i, j = heapq.heappop(heap)\\n            if j+1 < len(matrix[0]):\\n                heapq.heappush(heap, (matrix[i][j+1], i, j+1))\\n        return ret\\n```\n```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        l = []\\n        for row in matrix:\\n            l += row\\n        return sorted(l)[k-1]\\n```\n```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        return sorted(sum(matrix, []))[k-1]\\n```\n```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        return sorted(reduce(lambda a,b:a+b, matrix))[k-1]\\n```\n```\\n    return sorted(itertools.chain(*matrix))[k-1]\\n    return sorted(a for row in matrix for a in row)[k-1]\\n    return sorted(itertools.chain.from_iterable(matrix))[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1547354,
                "title": "3-different-approaches-for-interview-with-comments",
                "content": "**Please Upvote,it helps a lot**\\n```\\n Approach 1 (Using Sorting) //it is the first approach that usually comes into mind\\n Time complexity : N * log(N);  //N == n^2\\n Auxiliary space complexity: O(N)\\n\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        int [] arr = new int[n*n];\\n        int idx = 0;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                arr[idx++] = matrix[i][j];\\n            }\\n        }\\n        \\n        Arrays.sort(arr);\\n        \\n        return arr[k - 1];\\n    }\\n}\\n```\\n\\n\\n```\\nApproach 2 (Using Priority Queue) //By reading that we have to return kth of something,this approach usually comes into mind\\nTime Complexity: N * log(K) //N== n^2\\nAuxiliary Space Complexity: O(K)\\n\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n       PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        int n = matrix.length;\\n        \\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(pq.size() < k){\\n                    pq.add(matrix[i][j]);\\n                }else{ //equal to k\\n                    if(matrix[i][j] < pq.peek()){ //if incoming element is less than peek\\n                        pq.poll();\\n                        pq.add(matrix[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return pq.peek();\\n    }\\n}\\n```\\n\\n\\n```\\nAppraoch 3 (Best Approach) /* By noticing the Sorted array, Binary Search \\nComes into play but , the implementation is a little different in 2d matrix\\ncase so if it is known beforehand then only it strikes*/\\n\\nTime Complexity:O(N) //N== n^2\\nAuxiliary Space Complexity: O(1)\\n\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int rows = matrix.length, cols = matrix[0].length;\\n        \\n        int lo = matrix[0][0], hi = matrix[rows - 1][cols - 1] ;\\n        while(lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int count = 0,  maxNum = lo;\\n           \\n            for (int r = 0, c = cols - 1; r < rows; r++) {\\n                while (c >= 0 && matrix[r][c] > mid) c--;   \\n                \\n                if (c >= 0) {\\n                    count += (c + 1); // count of nums <= mid in matrix\\n                    maxNum = Math.max(maxNum, matrix[r][c]); \\n         // mid might be value not in  matrix, we need to record the actually max num;\\n                }else{ //it means c < 0\\n                    break;\\n                } \\n            }\\n            \\n            // adjust search range\\n            if (count == k) return maxNum;\\n            else if (count < k) lo = mid + 1;\\n            else hi = mid - 1;\\n        }\\n        return lo;\\n    }\\n\\n}\\nThis Approach Code taken from : https://leetcode.com/meganlee/\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\n Approach 1 (Using Sorting) //it is the first approach that usually comes into mind\\n Time complexity : N * log(N);  //N == n^2\\n Auxiliary space complexity: O(N)\\n\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        int [] arr = new int[n*n];\\n        int idx = 0;\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                arr[idx++] = matrix[i][j];\\n            }\\n        }\\n        \\n        Arrays.sort(arr);\\n        \\n        return arr[k - 1];\\n    }\\n}\\n```\n```\\nApproach 2 (Using Priority Queue) //By reading that we have to return kth of something,this approach usually comes into mind\\nTime Complexity: N * log(K) //N== n^2\\nAuxiliary Space Complexity: O(K)\\n\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n       PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        int n = matrix.length;\\n        \\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                if(pq.size() < k){\\n                    pq.add(matrix[i][j]);\\n                }else{ //equal to k\\n                    if(matrix[i][j] < pq.peek()){ //if incoming element is less than peek\\n                        pq.poll();\\n                        pq.add(matrix[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return pq.peek();\\n    }\\n}\\n```\n```\\nAppraoch 3 (Best Approach) /* By noticing the Sorted array, Binary Search \\nComes into play but , the implementation is a little different in 2d matrix\\ncase so if it is known beforehand then only it strikes*/\\n\\nTime Complexity:O(N) //N== n^2\\nAuxiliary Space Complexity: O(1)\\n\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int rows = matrix.length, cols = matrix[0].length;\\n        \\n        int lo = matrix[0][0], hi = matrix[rows - 1][cols - 1] ;\\n        while(lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int count = 0,  maxNum = lo;\\n           \\n            for (int r = 0, c = cols - 1; r < rows; r++) {\\n                while (c >= 0 && matrix[r][c] > mid) c--;   \\n                \\n                if (c >= 0) {\\n                    count += (c + 1); // count of nums <= mid in matrix\\n                    maxNum = Math.max(maxNum, matrix[r][c]); \\n         // mid might be value not in  matrix, we need to record the actually max num;\\n                }else{ //it means c < 0\\n                    break;\\n                } \\n            }\\n            \\n            // adjust search range\\n            if (count == k) return maxNum;\\n            else if (count < k) lo = mid + 1;\\n            else hi = mid - 1;\\n        }\\n        return lo;\\n    }\\n\\n}\\nThis Approach Code taken from : https://leetcode.com/meganlee/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366981,
                "title": "c-java-full-explanation-using-6-method",
                "content": "**Brutforce**\\n\\n**Time Complexity:** `O(n*m lon(n*m))`\\n**Space Complexity:** `O(n*m)`\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int z) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        int a[n*m], k=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                a[k] = matrix[i][j];\\n                k++;\\n            }\\n        }\\n        sort(a, a+(n*m));\\n        return a[z-1];\\n    }\\n};\\n```\\n\\n**Using Unordered Map \\nIt\\'s give TLE \\u274C**\\n\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size(), start = matrix[0][0], end = matrix[n-1][n-1];\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                mp[matrix[i][j]]++;\\n        \\n        for(int i = start; i <= end; i++)\\n            if(mp.find(i) != mp.end()){\\n                for(int j = 0; j < mp[i]; j++){\\n                    k--;\\n                    if(k == 0) return i;\\n                }\\n            }\\n          return -1;  \\n    }\\n};\\n```\\n\\n***PLEASE UPVOTE IF YOU LIKE.***\\n**Optimal:\\nUsing Binary Search**\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& matrix, int mid){\\n        int count = 0, n = matrix.size(), i = n-1, j = 0;\\n        while(i >= 0 && j < n){\\n            if(matrix[i][j] > mid) i--;\\n            else{\\n                count += (i+1);\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size(), i = matrix[0][0], j = matrix[n-1][n-1];\\n        while(i < j){\\n            int mid = i + (j-i)/2;\\n            int posi = solve(matrix, mid);\\n            if(posi < k) i = mid+1;\\n            else j = mid;\\n        }\\n        return i;\\n    }  \\n};\\n```\\n![image](https://assets.leetcode.com/users/images/64b51ee9-1823-440a-81e3-0418a6ff1e2d_1659403057.5497289.png)\\n\\n***PLEASE UPVOTE IF YOU LIKE.***\\n**Optimal 2:\\nUsing Priority Queue**\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int>pq; int n = matrix.size();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++){\\n                pq.push(matrix[i][j]);\\n                if(pq.size() > k) pq.pop();\\n            }\\n        return pq.top();   \\n    }\\n};\\n```\\n# PLEASE UPVOTE IF YOU LIKE.\\n\\n# Java\\n@NarutoBaryonMode\\n\\n**Using PriorityQueue - This soultion is preferred if K < Length of one side of the matrix**\\n```\\n/**\\n * Using PriorityQueue\\n *\\n * Time Complexity:\\n *      O(min(N,K)*log(min(N,K))) -> To add initial min(N,K) elements, as we are adding the elements individually.\\n *                                   If we were adding all elements in one go, then the complexity would be O(min(N,K))\\n *                                   Refer: https://stackoverflow.com/a/34697891\\n *      O(2*(K-1)*log(min(N,K)) -> To poll K-1 elements and add next K-1 elements.\\n * Total Time Complexity: O((min(N,K) + 2*(K-1)) * log(min(N,K)) = O(K * log(min(N,K))\\n *\\n * Space Complexity: O(min(N, K))\\n *\\n * N = Length of one side of the matrix. K = input value k.\\n */\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if (matrix == null || k <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int n = matrix.length;\\n        if (k > n * n) {\\n            throw new NoSuchElementException(\"k is greater than number of elements in matrix\");\\n        }\\n        if (k == 1) {\\n            return matrix[0][0];\\n        }\\n        if (k == n * n) {\\n            return matrix[n - 1][n - 1];\\n        }\\n\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> (matrix[a[0]][a[1]] - matrix[b[0]][b[1]]));\\n\\n        for (int i = 0; i < Math.min(n, k); i++) {\\n            queue.offer(new int[] { i, 0 });\\n        }\\n        while (k > 1) {\\n            int[] cur = queue.poll();\\n            if (cur[1] < n - 1) {\\n                cur[1]++;\\n                queue.offer(cur);\\n            }\\n            k--;\\n        }\\n\\n        return matrix[queue.peek()[0]][queue.peek()[1]];\\n    }\\n}\\n```\\n\\n**Using Binary Search - This soultion is preferred if K > Length of one side of the matrix**\\n\\n```\\n/**\\n * Using Binary Search on the range of Min and Max values in the matrix\\n *\\n * Time Complexity: O(2*N * log(Max-Min))\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of one side of the matrix. Max = Maximum value in Matrix. Min = Minimum value in matrix.\\n */\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if (matrix == null || k <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int n = matrix.length;\\n        if (k > n * n) {\\n            throw new NoSuchElementException(\"k is greater than number of elements in matrix\");\\n        }\\n        if (k == 1) {\\n            return matrix[0][0];\\n        }\\n        if (k == n * n) {\\n            return matrix[n - 1][n - 1];\\n        }\\n\\n        int start = matrix[0][0];\\n        int end = matrix[n - 1][n - 1];\\n\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            int[] smallLargePair = { start, end };\\n            int count = countLessThanAndEqual(matrix, mid, smallLargePair);\\n            if (count == k) {\\n                return smallLargePair[0];\\n            }\\n            if (count < k) {\\n                start = smallLargePair[1]; // search higher\\n            } else {\\n                end = smallLargePair[0]; // search lower\\n            }\\n        }\\n\\n        return start;\\n    }\\n\\n    private int countLessThanAndEqual(int[][] matrix, int mid, int[] smallLargePair) {\\n        int count = 0;\\n        int n = matrix.length;\\n        int row = 0;\\n        int col = n - 1;\\n        while (row < n && col >= 0) {\\n            if (matrix[row][col] > mid) {\\n                // as matrix[row][col] is bigger than the mid, let\\'s keep track of the\\n                // smallest number greater than the mid\\n                smallLargePair[1] = Math.min(smallLargePair[1], matrix[row][col]);\\n                col--;\\n            } else {\\n                // as matrix[row][col] is less than or equal to the mid, let\\'s keep track of the\\n                // biggest number less than or equal to the mid\\n                smallLargePair[0] = Math.max(smallLargePair[0], matrix[row][col]);\\n                row++;\\n                count += col + 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# PLEASE UPVOTE IF YOU LIKE.\\n```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n*PLEASE UPVOTE IF YOU LIKE.*",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int z) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        int a[n*m], k=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                a[k] = matrix[i][j];\\n                k++;\\n            }\\n        }\\n        sort(a, a+(n*m));\\n        return a[z-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size(), start = matrix[0][0], end = matrix[n-1][n-1];\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                mp[matrix[i][j]]++;\\n        \\n        for(int i = start; i <= end; i++)\\n            if(mp.find(i) != mp.end()){\\n                for(int j = 0; j < mp[i]; j++){\\n                    k--;\\n                    if(k == 0) return i;\\n                }\\n            }\\n          return -1;  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& matrix, int mid){\\n        int count = 0, n = matrix.size(), i = n-1, j = 0;\\n        while(i >= 0 && j < n){\\n            if(matrix[i][j] > mid) i--;\\n            else{\\n                count += (i+1);\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size(), i = matrix[0][0], j = matrix[n-1][n-1];\\n        while(i < j){\\n            int mid = i + (j-i)/2;\\n            int posi = solve(matrix, mid);\\n            if(posi < k) i = mid+1;\\n            else j = mid;\\n        }\\n        return i;\\n    }  \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int>pq; int n = matrix.size();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++){\\n                pq.push(matrix[i][j]);\\n                if(pq.size() > k) pq.pop();\\n            }\\n        return pq.top();   \\n    }\\n};\\n```\n```\\n/**\\n * Using PriorityQueue\\n *\\n * Time Complexity:\\n *      O(min(N,K)*log(min(N,K))) -> To add initial min(N,K) elements, as we are adding the elements individually.\\n *                                   If we were adding all elements in one go, then the complexity would be O(min(N,K))\\n *                                   Refer: https://stackoverflow.com/a/34697891\\n *      O(2*(K-1)*log(min(N,K)) -> To poll K-1 elements and add next K-1 elements.\\n * Total Time Complexity: O((min(N,K) + 2*(K-1)) * log(min(N,K)) = O(K * log(min(N,K))\\n *\\n * Space Complexity: O(min(N, K))\\n *\\n * N = Length of one side of the matrix. K = input value k.\\n */\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if (matrix == null || k <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int n = matrix.length;\\n        if (k > n * n) {\\n            throw new NoSuchElementException(\"k is greater than number of elements in matrix\");\\n        }\\n        if (k == 1) {\\n            return matrix[0][0];\\n        }\\n        if (k == n * n) {\\n            return matrix[n - 1][n - 1];\\n        }\\n\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> (matrix[a[0]][a[1]] - matrix[b[0]][b[1]]));\\n\\n        for (int i = 0; i < Math.min(n, k); i++) {\\n            queue.offer(new int[] { i, 0 });\\n        }\\n        while (k > 1) {\\n            int[] cur = queue.poll();\\n            if (cur[1] < n - 1) {\\n                cur[1]++;\\n                queue.offer(cur);\\n            }\\n            k--;\\n        }\\n\\n        return matrix[queue.peek()[0]][queue.peek()[1]];\\n    }\\n}\\n```\n```\\n/**\\n * Using Binary Search on the range of Min and Max values in the matrix\\n *\\n * Time Complexity: O(2*N * log(Max-Min))\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of one side of the matrix. Max = Maximum value in Matrix. Min = Minimum value in matrix.\\n */\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if (matrix == null || k <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int n = matrix.length;\\n        if (k > n * n) {\\n            throw new NoSuchElementException(\"k is greater than number of elements in matrix\");\\n        }\\n        if (k == 1) {\\n            return matrix[0][0];\\n        }\\n        if (k == n * n) {\\n            return matrix[n - 1][n - 1];\\n        }\\n\\n        int start = matrix[0][0];\\n        int end = matrix[n - 1][n - 1];\\n\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            int[] smallLargePair = { start, end };\\n            int count = countLessThanAndEqual(matrix, mid, smallLargePair);\\n            if (count == k) {\\n                return smallLargePair[0];\\n            }\\n            if (count < k) {\\n                start = smallLargePair[1]; // search higher\\n            } else {\\n                end = smallLargePair[0]; // search lower\\n            }\\n        }\\n\\n        return start;\\n    }\\n\\n    private int countLessThanAndEqual(int[][] matrix, int mid, int[] smallLargePair) {\\n        int count = 0;\\n        int n = matrix.length;\\n        int row = 0;\\n        int col = n - 1;\\n        while (row < n && col >= 0) {\\n            if (matrix[row][col] > mid) {\\n                // as matrix[row][col] is bigger than the mid, let\\'s keep track of the\\n                // smallest number greater than the mid\\n                smallLargePair[1] = Math.min(smallLargePair[1], matrix[row][col]);\\n                col--;\\n            } else {\\n                // as matrix[row][col] is less than or equal to the mid, let\\'s keep track of the\\n                // biggest number less than or equal to the mid\\n                smallLargePair[0] = Math.max(smallLargePair[0], matrix[row][col]);\\n                row++;\\n                count += col + 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85201,
                "title": "c-o-n-time-o-n-space-solution-with-detail-intuitive-explanation",
                "content": "This thread is inspired by [**@StefanPochmann**'s thread](https://discuss.leetcode.com/topic/53126/o-n-from-paper-yes-o-rows), which mentioned [**Mirzaian** and **Arjoandi**'s paper](http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf).\\n\\n**Preparations**\\n1. When `n==1` (i.e. the matrix is `1x1`. `n` is the number of row), the problem is trival. Hencefore we only consider the case `n>=2`.\\n2. Rather than finding one `k`-th element from the matrix, we will select **TWO** elements (say, `k0`-th element and `k1`-th element) simultaneously, such that `0<=k0<=k1<n*n` and `k1-k0<=4n`. Obviously, if we can complete the aforementioned selection in *O*(n), we can find the `k`-th element in *O*(n) by simply letting `k=k0=k1`.\\nLet `x0` denote the `k0`-th element; let `x1` denote the `k1`-th element. Obviously we have `x0<=x1`.\\n\\nNow we will introduce how to select `x0` and `x1` in *O*(n).\\n\\n**General idea:**\\nFor an `nxn` matrix, where `n` is large, we try to select  `x0` and `x1` in a recursive way. \\n1. (**Determine submatrix**) This step constructs one submatrix, whose number of elements will be approximately a quarter of the original matrix. The submatrix is defined as every other row and every other column of the original matrix. The last row and the last column are included too (the reason will be stated in the sequel.) Then the dimension of the matrix is approximately `(n/2) x (n/2)`. The submatrix is recorded by the indices in the original matrix.\\n*Example 1:* *the original matrix has indices {0, 1, 2, 3, 4}, then the submatrix has indices {0, 2, 4}.*\\n*Example 2:* *the original matrix has indices {0,1, 2, 3, 4, 5}, then the submatrix has indices {0, 2,4, 5}.*\\n2. (**Determine new k's**)  This step determines two new k's (denoted as `k0_` and `k1_`) such that **(i)** `k0_` is the largest possible integer to ensure `k0_`-th element in the new submatrix (denoted as `x0_`) is not greater than `x0`; **(ii)** `k1_` is the smallest possible integer to ensure `k1_`-th element in the new submatrix (denoted as `x1_`) is not less than `x1`. This step is the most tricky step.\\n\\n\\t\\tk0_ = floor(k0 / 4)\\n\\t\\tk1_ = floor(k1 / 4) + n + 1 (when n is even)\\n\\t         floor((k1 + 2 * n + 1) / 4) (when n is odd)\\n\\n![Picture: the way to determine k0_ and k1_: https://drive.google.com/open?id=0By2m48ItFbTeeDFvaS1WcV9qSWM](https://drive.google.com/open?id=0By2m48ItFbTeeDFvaS1WcV9qSWM)\\n\\nThe picture can also be founded [here](https://drive.google.com/open?id=0By2m48ItFbTeeDFvaS1WcV9qSWM).\\n\\n   *Recall that we mentioned the last row and column shall always be included in the matrix. That is to ensure we can always found the* `x1_` *such that* `x1_ >= x1`.\\n3. (**Call recursively**) Obtain`x0_` and `x1_` by recursion.\\n4. (**Partition**)  Partition all elements in the original `nxn` elements into three parts: `P1={e: e < x0_}`, `P2={e: x0_ <= e < x1_ }`, `P3={e: x1_ < e} `. We only need to record the cardinality of `P1` and `P2` (denoted as `|P1|` and `|P2|` respectively), and the elements in `P2`. Obviously, the cardinality of `P2` is *O*(n).\\n5. (**Get x0 and x1**) From the definition of `k0_` and `k1_`, we have `|P1| < k0 <= |P1|+|P2|`. When `|P1| < k0 < |P1|+|P2|`, `x0` is the `k0-|P1|`-th element of P2; otherwise `x0=x1_`. `x1` can be determined in a similar way. This action is also *O*(n).\\n    \\n------------------------------------------------\\n**Complexities:**\\n- Time: *O*(n) -----   *Apply* `T(n) = T(n/2) + O(n)` *in the Master's Theorem.*\\n- Space: *O*(n)\\n------------------------------------------------\\n**C++ Accepted Code:**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint kthSmallest(const std::vector<std::vector<int>> & matrix, int k)\\n\\t\\t{\\n\\t\\t\\tif (k == 1) // guard for 1x1 matrix\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn matrix.front().front();\\n\\t\\t\\t}\\n\\n\\t\\t\\tsize_t n = matrix.size();\\n\\t\\t\\tstd::vector<size_t> indices(n);\\n\\t\\t\\tstd::iota(indices.begin(), indices.end(), 0);\\n\\t\\t\\tstd::array<size_t, 2> ks = { k - 1, k - 1 }; // use zero-based indices\\n\\t\\t\\tstd::array<int, 2> results = biSelect(matrix, indices, ks);\\n\\t\\t\\treturn results[0];\\n\\t\\t}\\n\\n\\tprivate:\\n\\t\\t// select two elements from four elements, recursively\\n\\t\\tstd::array<int, 2> biSelect(\\n\\t\\t\\tconst std::vector<std::vector<int>> & matrix,\\n\\t\\t\\tconst std::vector<size_t> & indices,\\n\\t\\t\\tconst std::array<size_t, 2> & ks)\\n\\t\\t// Select both ks[0]-th element and ks[1]-th element in the matrix,\\n\\t\\t// where k0 = ks[0] and k1 = ks[1] and n = indices.size() satisfie\\n\\t\\t// 0 <= k0 <= k1 < n*n  and  k1 - k0 <= 4n-4 = O(n)   and  n>=2\\n\\t\\t{\\n\\t\\t\\tsize_t n = indices.size();\\t\\t\\n\\t\\t\\tif (n == 2u) // base case of resursion\\n\\t\\t\\t{\\t\\t\\t\\n\\t\\t\\t\\treturn biSelectNative(matrix, indices, ks);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// update indices\\n\\t\\t\\tstd::vector<size_t> indices_;\\n\\t\\t\\tfor (size_t idx = 0; idx < n; idx += 2)\\n\\t\\t\\t{\\n\\t\\t\\t\\tindices_.push_back(indices[idx]);\\n\\t\\t\\t}\\n\\t\\t\\tif (n % 2 == 0) // ensure the last indice is included\\n\\t\\t\\t{\\n\\t\\t\\t\\tindices_.push_back(indices.back());\\n\\t\\t\\t}\\n\\n\\t\\t\\t// update ks\\n\\t\\t\\t// the new interval [xs_[0], xs_[1]] should contain [xs[0], xs[1]]\\n\\t\\t\\t// but the length of the new interval should be as small as possible\\n\\t\\t\\t// therefore, ks_[0] is the largest possible index to ensure xs_[0] <= xs[0]\\n\\t\\t\\t// ks_[1] is the smallest possible index to ensure xs_[1] >= xs[1]\\n\\t\\t\\tstd::array<size_t, 2> ks_ = { ks[0] / 4, 0 };\\n\\t\\t\\tif (n % 2 == 0) // even\\n\\t\\t\\t{\\n\\t\\t\\t\\tks_[1] = ks[1] / 4 + n + 1;\\n\\t\\t\\t}\\n\\t\\t\\telse // odd\\n\\t\\t\\t{\\n\\t\\t\\t\\tks_[1] = (ks[1] + 2 * n + 1) / 4;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// call recursively\\n\\t\\t\\tstd::array<int, 2> xs_ = biSelect(matrix, indices_, ks_);\\n\\n\\t\\t\\t// Now we partipate all elements into three parts:\\n\\t\\t\\t// Part 1: {e : e < xs_[0]}.  For this part, we only record its cardinality\\n\\t\\t\\t// Part 2: {e : xs_[0] <= e < xs_[1]}. We store the set elementsBetween\\n\\t\\t\\t// Part 3: {e : x >= xs_[1]}. No use. Discard.\\n\\t\\t\\tstd::array<int, 2> numbersOfElementsLessThanX = { 0, 0 };\\n\\t\\t\\tstd::vector<int> elementsBetween; // [xs_[0], xs_[1])\\n\\n\\t\\t\\tstd::array<size_t, 2> cols = { n, n }; // column index such that elem >= x\\n\\t\\t\\t // the first column where matrix(r, c) > b\\n\\t\\t\\t // the first column where matrix(r, c) >= a\\n\\t\\t\\tfor (size_t row = 0; row < n; ++row)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsize_t row_indice = indices[row];\\n\\t\\t\\t\\tfor (size_t idx : {0, 1})\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\twhile ((cols[idx] > 0)\\n\\t\\t\\t\\t\\t\\t&& (matrix[row_indice][indices[cols[idx] - 1]] >= xs_[idx]))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t--cols[idx];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnumbersOfElementsLessThanX[idx] += cols[idx];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (size_t col = cols[0]; col < cols[1]; ++col)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\telementsBetween.push_back(matrix[row_indice][indices[col]]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tstd::array<int, 2> xs; // the return value\\n\\t\\t\\tfor (size_t idx : {0, 1})\\n\\t\\t\\t{\\n\\t\\t\\t\\tsize_t k = ks[idx];\\n\\t\\t\\t\\tif (k < numbersOfElementsLessThanX[0]) // in the Part 1\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\txs[idx] = xs_[0];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if (k < numbersOfElementsLessThanX[1]) // in the Part 2\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsize_t offset = k - numbersOfElementsLessThanX[0];\\n\\t\\t\\t\\t\\tstd::vector<int>::iterator nth = std::next(elementsBetween.begin(), offset);\\n\\t\\t\\t\\t\\tstd::nth_element(elementsBetween.begin(), nth, elementsBetween.end());\\n\\t\\t\\t\\t\\txs[idx] = (*nth);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse // in the Part 3\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\txs[idx] = xs_[1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn xs;\\n\\t\\t}\\n\\n\\t\\t// select two elements from four elements, using native way\\n\\t\\tstd::array<int, 2> biSelectNative(\\n\\t\\t\\tconst std::vector<std::vector<int>> & matrix,\\n\\t\\t\\tconst std::vector<size_t> & indices,\\n\\t\\t\\tconst std::array<size_t, 2> & ks)\\n\\t\\t{\\n\\t\\t\\tstd::vector<int> allElements;\\n\\t\\t\\tfor (size_t r : indices)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (size_t c : indices)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tallElements.push_back(matrix[r][c]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tstd::sort(allElements.begin(), allElements.end());\\n\\t\\t\\tstd::array<int, 2> results;\\n\\t\\t\\tfor (size_t idx : {0, 1})\\n\\t\\t\\t{\\n\\t\\t\\t\\tresults[idx] = allElements[ks[idx]];\\n\\t\\t\\t}\\n\\t\\t\\treturn results;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint kthSmallest(const std::vector<std::vector<int>> & matrix, int k)\\n\\t\\t{\\n\\t\\t\\tif (k == 1) // guard for 1x1 matrix\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn matrix.front().front();\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 394294,
                "title": "using-binary-search-in-java-and-analysis",
                "content": "Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix, and k is always valid, 1<= k <= n^2. \\n\\nSo, the kth smallest element is between matrix[0][0] and matrix[m - 1][n - 1], where m is number of rows of the matrix, n is number of columns of the matrix. Let low = matrix[0][0], and high = matrix[m - 1][n - 1], using binary search to calculate mid value, and find the count of elements which are less than and equal to mid. \\n\\nNotice that the mid is just a value calculated by using low and high, not a true element in the matrix, so when count  < k, it means that the mid is small, let low = mid + 1 to find the true element in matrix one by one. And when count > k, it means that the mid is big enough, let high = mid to ensure the element we need is between low and high(mid). And when count = k, it means that there are k elements less than or equal to mid in the matrix, but we don\\'t know whether the element we need is equal to mid. So let high = mid, it can ensure that the element we need is between low and high(mid). \\n\\nFor example, given a matrix and k = 8,\\n[[ 1,  5,  9],\\n[10, 11, 13],\\n[12, 13, 15]],\\n\\n* low = matrix[0][0] = 1, high = matrix[2][2] = 15, mid = 8, count is element number of set {1, 5} = 2, count < k, let low = mid + 1 = 9;\\n* low = 9, high = 15, mid = 12, count is element number of set {1, 5, 9, 10, 11, 12} = 6, count < k, let low = mid + 1 = 13;\\n* low = 13, high = 15, mid = 14, count is element number of set {1, 5, 9, 10, 11, 12, 13, 13} = 8, count = k, but the element we need is 13, not the mid(14), so let high = mid = 14 to narrow the search gap.\\n* low = 13, high = 14, mid = 13, count = 8, count = k, let high = mid = 13, \\n* low = 13, high = 13, low and high are meet, now return low.\\n\\nNotice that using (low < high) in while loop rather than using (low <= high) to avoid stay in the loop. It takes log(m * n) times to find mid, and using (m + n) times to get count in each loop, so time complexity is *O*((m + n) log (m * n)). The matrix is n x n, So the time complexity is *O*(n log (n^2)).\\n\\nThis problem is similar to problem 668. Kth Smallest Number in Multiplication Table. \\nHere is the link: [https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/)\\n```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int low = matrix[0][0], high = matrix[m - 1][n - 1];\\n        while (low < high) {\\n            int mid = (high - low) / 2 + low;\\n            int count = 0; \\n            int j = n - 1;\\n            for (int i = 0; i < m; i++) {\\n                while (j >= 0 && matrix[i][j] > mid)\\n                    j--;\\n                count += j + 1;\\n            }\\n            if (count < k)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int low = matrix[0][0], high = matrix[m - 1][n - 1];\\n        while (low < high) {\\n            int mid = (high - low) / 2 + low;\\n            int count = 0; \\n            int j = n - 1;\\n            for (int i = 0; i < m; i++) {\\n                while (j >= 0 && matrix[i][j] > mid)\\n                    j--;\\n                count += j + 1;\\n            }\\n            if (count < k)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2367160,
                "title": "java-easy-solution-100-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n= matrix.length;\\n        int low = matrix[0][0];\\n        int high = matrix[n-1][n-1];\\n        \\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            int count = lessEqual(matrix,mid);\\n            if(count < k){\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid;\\n            }\\n        }\\n        return low;\\n        \\n    }\\n    \\n    //from left bottom or right top we can count how many numbers are equal or less than our target\\n    \\n    public int lessEqual(int[][] matrix, int target){\\n        int count = 0 , len = matrix.length, i = len-1, j=0;\\n        \\n        while(i >=0 && j<len){\\n            if(matrix[i][j] > target){\\n                i--;\\n            }\\n            else\\n            {\\n                count = count + i +1;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n= matrix.length;\\n        int low = matrix[0][0];\\n        int high = matrix[n-1][n-1];\\n        \\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            int count = lessEqual(matrix,mid);\\n            if(count < k){\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid;\\n            }\\n        }\\n        return low;\\n        \\n    }\\n    \\n    //from left bottom or right top we can count how many numbers are equal or less than our target\\n    \\n    public int lessEqual(int[][] matrix, int target){\\n        int count = 0 , len = matrix.length, i = len-1, j=0;\\n        \\n        while(i >=0 && j<len){\\n            if(matrix[i][j] > target){\\n                i--;\\n            }\\n            else\\n            {\\n                count = count + i +1;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85222,
                "title": "c-priority-queue-solution-o-klogn",
                "content": "```\\nclass Solution {\\npublic:\\nstruct compare\\n{\\n    bool operator()(const pair<int,pair<int, int> >& a, const pair<int,pair<int, int> >& b)\\n    {\\n        return a.first>b.first;\\n    }\\n};\\n    int kthSmallest(vector<vector<int>>& arr, int k) {\\n        \\n        int n=arr.size(),m=arr[0].size();\\n        \\n        priority_queue< pair<int,pair<int, int> >, vector<pair<int, pair<int, int> > >, compare > p;\\n        \\n        for(int i=0;i<n;i++)\\n        p.push(make_pair(arr[i][0],make_pair(i,0)));\\n        \\n        int x=k,ans;\\n        while(x--)\\n        {\\n            int e=p.top().first;\\n            int i=p.top().second.first;\\n            int j=p.top().second.second;\\n            ans=e;\\n            p.pop();\\n            if(j!=m-1)\\n            p.push(make_pair(arr[i][j+1],make_pair(i,j+1)));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nstruct compare\\n{\\n    bool operator()(const pair<int,pair<int, int> >& a, const pair<int,pair<int, int> >& b)\\n    {\\n        return a.first>b.first;\\n    }\\n};\\n    int kthSmallest(vector<vector<int>>& arr, int k) {\\n        \\n        int n=arr.size(),m=arr[0].size();\\n        \\n        priority_queue< pair<int,pair<int, int> >, vector<pair<int, pair<int, int> > >, compare > p;\\n        \\n        for(int i=0;i<n;i++)\\n        p.push(make_pair(arr[i][0],make_pair(i,0)));\\n        \\n        int x=k,ans;\\n        while(x--)\\n        {\\n            int e=p.top().first;\\n            int i=p.top().second.first;\\n            int j=p.top().second.second;\\n            ans=e;\\n            p.pop();\\n            if(j!=m-1)\\n            p.push(make_pair(arr[i][j+1],make_pair(i,j+1)));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321862,
                "title": "python-binary-search-solution-explained",
                "content": "The idea is for number `X` find number of elements which are less or equal than `X`, which can be done in `O(n)`, idea is similar to problem **240: Search a 2D Matrix II**: we can start with the top right element and move only down and to the left, counting number of elements `<X` in each row. We start with the smallest and the biggest elements in our table and do binary search, each time asking question: is number of elements `< X` is more than `k`? We do binary search and stop when `end` become equal to `beg`.\\n\\n#### Complexity\\nTime complexity is `O(n *  log(A))`, where `A` is difference between maximum and minimum values in our matrix.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def kthSmallest(self, matrix, k):\\n        n, beg, end = len(matrix), matrix[0][0], matrix[-1][-1]\\n        \\n        def check(m):\\n            i, j, cnt = 0, n-1, 0\\n            for i in range(n):\\n                while j >= 0 and matrix[i][j] > m: j -= 1\\n                cnt += (j + 1)\\n            return cnt\\n         \\n        while beg < end:\\n            mid = (beg + end)//2\\n            if check(mid) < k:\\n                beg = mid + 1\\n            else:\\n                end = mid\\n                \\n        return beg\\n```\\n\\n#### Remark\\nThere is also solution, based on the problem **373: Find K Pairs with Smallest Sums**, using heaps with complexity `O(k * log k)`. Depending on matrix it can be bigger or smaller than previous approach.\\n\\nFinally, there is `O(n)` time complexity algorithm with the idea of median of medians expanded for `2d` matrices, you can find it here https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85170/O(n)-from-paper.-Yes-O(rows), It is very difficult but I enjoyed to read it.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def kthSmallest(self, matrix, k):\\n        n, beg, end = len(matrix), matrix[0][0], matrix[-1][-1]\\n        \\n        def check(m):\\n            i, j, cnt = 0, n-1, 0\\n            for i in range(n):\\n                while j >= 0 and matrix[i][j] > m: j -= 1\\n                cnt += (j + 1)\\n            return cnt\\n         \\n        while beg < end:\\n            mid = (beg + end)//2\\n            if check(mid) < k:\\n                beg = mid + 1\\n            else:\\n                end = mid\\n                \\n        return beg\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685550,
                "title": "here-s-why-binary-search-works-explain-it-to-me-like-i-m-5",
                "content": "If you haven\\'t checked out the binary search solution to this problem, refer to the second solution of  this post.\\n**Prerequisite: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85173/Share-my-thoughts-and-Clean-Java-Code**\\n\\nThe binary search solution looks incorrect at first. How is it making sure if the element is in the matrix or not? Lets find out.\\n\\nFor the sake of simplicity lets assume we have a ```blackbox``` that returs to us the number of elements in the matrix less than or equal to a given number.\\n\\nOur matrix: \\n\\n\\t\\t\\t\\t1    5    7\\n\\t\\t\\t\\t10   11   13\\n\\t\\t\\t\\t12   14   18\\n\\t\\t\\t\\nSuppose we want to find number of elements less or equal to ```7```, the blackbox will return value 3. \\nNow, lets say we call the blackbox for ```9```, it again gives us the value 3.\\nObservation: If ```k = 3```,  then ```7``` is the first number that gives us a value equal to ```k``` when we call the blackbox.\\n\\nNow, lets dry run the binary search with ```k = 3``` on our matrix.\\n\\nWe have, ```low = 1``` and ```high = 18```\\n\\n*Iteration 1*: \\n```mid = (1 + 18)/2 = 9```\\nlets find how many numbers are less or equal to 9 and store it in a variable ```count```.\\n```count = blackbox( mid )``` ===> ```count = 3```\\n\\nWe have ```count == k```, does this mean we have our answer? NO. \\nIt means that we have potential answer. We dont know yet if ```9``` is the smallest number for which number of elements in the matrix is less or equal to 3.\\n\\nSo, we set ```high = mid``` (**NOT ```mid-1```**), as ```9``` is very much a potential answer, we cannot exclude it from our range of interest.\\n\\n*Iteration 2*:\\n```low = 1 and high = 9```\\nso, ```mid = (1 + 9)/2 = 5```\\nlets find how many numbers are less or equal to ```5```.\\n```count = blackbox( mid )``` ===> ```count = 2```\\n\\nThis time we have ```count < k```, hence we are sure that ```5``` or any number before this in the matrix **cannot** be our answer.\\nTherefore,  we set ```low = mid+1```\\n\\n*Iteration 3*:\\n```low = 6 and high = 9```\\nso, ```mid = (6 + 9)/2 = 7```\\nlets find how many numbers are less or equal to ```7```.\\n```count = blackbox( mid )``` ===> ```count = 3```\\n\\nAgain, ```count == k```. Since we want ony the first element that is smaller than or equal to k. We will move our ```high``` pointer from ```9``` to ```7```.\\n\\nSo, we set ```high = mid```\\n\\n*Iteration 4*:\\n```low = 6 and high = 7```\\nso, ```mid = (6 + 7)/2 = 6```\\nlets find how many numbers are less or equal to ```6```.\\n```count = blackbox( mid )``` ===> ```count = 2```\\n\\nAgain we have ```count < k```, hence we move our ```low``` pointer forward.\\nWe set ```low  = mid+1```\\n\\n*Iteration 5*: ```low = 7 and high = 7```. \\nSince ```low == high```, we break out of the while loop.\\n\\nBasically, we are trying to position our ```low``` pointer such that it is **the first element** that gives ```count == k``` by the end of the iterations.  \\n\\nWhy the first element? \\nIf you look at the matrix, any number itself will always be the first element that gives a particular value for ```blackbox```. In our example, ```7``` will be the first element that gives ```count = 3```, thats how we know its in the matrix.\\n\\nHence Binary Search can safely be used here.\\n\\nDo upvote if it helped ^^",
                "solutionTags": [
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```blackbox```\n```7```\n```9```\n```k = 3```\n```7```\n```k```\n```k = 3```\n```low = 1```\n```high = 18```\n```mid = (1 + 18)/2 = 9```\n```count```\n```count = blackbox( mid )```\n```count = 3```\n```count == k```\n```9```\n```high = mid```\n```mid-1```\n```9```\n```low = 1 and high = 9```\n```mid = (1 + 9)/2 = 5```\n```5```\n```count = blackbox( mid )```\n```count = 2```\n```count < k```\n```5```\n```low = mid+1```\n```low = 6 and high = 9```\n```mid = (6 + 9)/2 = 7```\n```7```\n```count = blackbox( mid )```\n```count = 3```\n```count == k```\n```high```\n```9```\n```7```\n```high = mid```\n```low = 6 and high = 7```\n```mid = (6 + 7)/2 = 6```\n```6```\n```count = blackbox( mid )```\n```count = 2```\n```count < k```\n```low```\n```low  = mid+1```\n```low = 7 and high = 7```\n```low == high```\n```low```\n```count == k```\n```blackbox```\n```7```\n```count = 3```",
                "codeTag": "Unknown"
            },
            {
                "id": 1321834,
                "title": "c-simple-clean-and-short-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int lo = matrix[0][0], hi = matrix[n-1][n-1] + 1, mid, count, tmp;\\n        \\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2, tmp = n - 1, count = 0;\\n            \\n\\t\\t\\t// For each row, we count the elements that are smaller then mid\\n            for (int i = 0; i < n; i++) {\\n                while (tmp >= 0 && matrix[i][tmp] > mid) tmp--;\\n                count += tmp + 1;\\n            }\\n            \\n            if (count < k) lo = mid + 1;\\n            else hi = mid;\\n        }\\n        \\n        return lo;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int lo = matrix[0][0], hi = matrix[n-1][n-1] + 1, mid, count, tmp;\\n        \\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2, tmp = n - 1, count = 0;\\n            \\n\\t\\t\\t// For each row, we count the elements that are smaller then mid\\n            for (int i = 0; i < n; i++) {\\n                while (tmp >= 0 && matrix[i][tmp] > mid) tmp--;\\n                count += tmp + 1;\\n            }\\n            \\n            if (count < k) lo = mid + 1;\\n            else hi = mid;\\n        }\\n        \\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369163,
                "title": "c-binary-search-easy-explanation-simple-solution",
                "content": "**Kindly Upvote , if you like the solution\\uD83D\\uDC4D**\\n\\n\\nThe Approach used here is  **BINARY SEARCH**\\n1. We will take l as matrix[0][0] and h as matrix[m-1][m-1] where m are the rows in matrix\\n2. Then find mid and count the no of elements < mid in each row \\n3. if count < k means we have to find the greater mid so that count can become equal to k\\n4. else h =mid;\\n5. return l\\n\\n**Acc to EXAMPLE 1 of testcase : l =1 and h=15 mid==>8 \\nthen in matrix , we found that there are only 2 element lesser than mid but we have to find k elements , therefore we have to increment l by mid+1\\nelse if count >k then decrement h by mid\\nif count == k return l**\\n\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        \\n int n= matrix.size();        \\n        int l=matrix[0][0];\\n        int h = matrix[n-1][n-1];\\n        int mid;\\n        int count;\\n        while(l<h)\\n        {\\n            count=0;\\n            mid = l + (h-l)/2;\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                \\n             count += upper_bound(matrix[i].begin() , matrix[i].end(),mid) - matrix[i].begin();\\n                \\n            }\\n            \\n                if(count<k)\\n            {\\n                l =mid+1;\\n            }\\n            else\\n            {\\n                h=mid;\\n            }\\n            }\\n           \\n    \\n        \\n        return l;\\n\\t\\t\\n\\t\\t   }\\n};\\n```\\n\\n**1st Approach Link** :- https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/2369108/Easy-C%2B%2B-Solution-Using-Priority-Queue-oror-Explanation-oror-Comments",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        \\n int n= matrix.size();        \\n        int l=matrix[0][0];\\n        int h = matrix[n-1][n-1];\\n        int mid;\\n        int count;\\n        while(l<h)\\n        {\\n            count=0;\\n            mid = l + (h-l)/2;\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                \\n             count += upper_bound(matrix[i].begin() , matrix[i].end(),mid) - matrix[i].begin();\\n                \\n            }\\n            \\n                if(count<k)\\n            {\\n                l =mid+1;\\n            }\\n            else\\n            {\\n                h=mid;\\n            }\\n            }\\n           \\n    \\n        \\n        return l;\\n\\t\\t\\n\\t\\t   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85219,
                "title": "python-solution-o-klogk-similar-to-problem-373",
                "content": "```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        result, heap = None, []\\n        heapq.heappush(heap, (matrix[0][0], 0, 0))\\n        while k > 0:\\n            result, i, j = heapq.heappop(heap)\\n            if i == 0 and j + 1 < len(matrix):\\n                heapq.heappush(heap, (matrix[i][j + 1], i, j + 1))\\n            if i + 1 < len(matrix):\\n                heapq.heappush(heap, (matrix[i + 1][j], i + 1, j))\\n            k -= 1\\n        return result\\n```\\nSince the matrix is sorted, we do not need to put all the elements in heap at one time. We can simply pop and put for k times. By observation, if we look at the matrix diagonally, we can tell that if we do not pop matrix[i][j], we do not need to put on matrix[i][j + 1] and matrix[i + 1][j] since they are bigger.\\n\\ne.g., given the matrix below:\\n1 2 4\\n3 5 7\\n6 8 9\\nWe put 1 first, then pop 1 and put 2 and 3, then pop 2 and put 4 and 5, then pop 3 and put 6...",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        result, heap = None, []\\n        heapq.heappush(heap, (matrix[0][0], 0, 0))\\n        while k > 0:\\n            result, i, j = heapq.heappop(heap)\\n            if i == 0 and j + 1 < len(matrix):\\n                heapq.heappush(heap, (matrix[i][j + 1], i, j + 1))\\n            if i + 1 < len(matrix):\\n                heapq.heappush(heap, (matrix[i + 1][j], i + 1, j))\\n            k -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2367785,
                "title": "97-16-faster-python-binary-search-brute-force",
                "content": "# Two Solutions: \\n`BRUTE FORCE`: Here we literally take every element from matrix and sort them and then return k-1th element, as indexing starts from 0 in our Python.\\n`Time:` O(n\\xB2 * (log n)\\xB2), feel free to correct me if I\\'m wrong.\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        temp = []\\n        \\n        for row in matrix:\\n            temp.extend(row)\\n        temp.sort()\\n        return temp[k-1]\\n```\\n\\n`BINARY SEARCH`: Let\\'s take advantage of that fact that each row is sorted.\\nSo one of the few things we know about this matrix is that top left right and the bottom right\\nare going to be minimum and maximum respectively.\\nSo the gap between the min and max that\\'s going to be our range \\nwhile doing a binary search and we\\'re going to do another binary search through each row to find\\nhow many elements are less than the element we\\'re searching for(bisect_right). As soon as we\\nfind our left and right range equal to another, then we could return l or r whatever.\\n`If the n is really large this solution would work much better. `\\n`Mine\\uD83D\\uDC49:` **178 ms, faster than 97.16% & 18.6 MB, less than 97.87%**\\n`Time:` maybe O((n log n) * (log m) ), feel free to correct me.\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        l, r, N = matrix[0][0], matrix[-1][-1], len(matrix)\\n        \\n        def less_k(m):\\n            cnt = 0 # count\\n            for r in range(N):\\n                # binary search \\n                x = bisect_right(matrix[r], m)\\n                cnt += x\\n            return cnt\\n        \\n        while l<r:\\n            mid = (l+r) // 2\\n            \\n            if less_k(mid) < k:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n```\\n## Give it a **Upvote** If You Like My Explanation.\\n### Have a Great Day/Night.",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        temp = []\\n        \\n        for row in matrix:\\n            temp.extend(row)\\n        temp.sort()\\n        return temp[k-1]\\n```\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        l, r, N = matrix[0][0], matrix[-1][-1], len(matrix)\\n        \\n        def less_k(m):\\n            cnt = 0 # count\\n            for r in range(N):\\n                # binary search \\n                x = bisect_right(matrix[r], m)\\n                cnt += x\\n            return cnt\\n        \\n        while l<r:\\n            mid = (l+r) // 2\\n            \\n            if less_k(mid) < k:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861912,
                "title": "sharing-my-both-c-sol-using-binary-search-heap",
                "content": "Using Binary Search :-  If the matrix is sorted, then in most of the cases you can use binary search to find your answer. \\nFirst setting the lower and upper bound value. We know smallest value is present in Row 1 and Column 1, and largest value is present in Last Row and Last column.\\nNow in the kth smallest function the logic is of binary search. We find mid value, and then we manipulate our Lower bound, upper bound to get answer. \\nIn the Count function,basically we are counting how many values are less than or equal to our target(MID value) in the matrix and according to that we are changing our lower and upper bound. \\nHere if we  start from the last row and first column to check how many values are there which are less than or equal to our target(mid value), then the steps are as follows:-\\n1. If the value[curr_row,curr_col] is less than or equal to the  target, then we know that the values [ from Row 0 to current _row ] are also going to be less than the target(becuse column is sorted). Therefore, we can move to next column and count the elements that are less than or equal to target using formula(curr_row+1).\\n2. If the value is greater than the current row and current column then we can move upwards i.e., (curr_row--), becasue there might be a chance we can find a value less than or equal to the target. And when we are moving upwards we are not going to miss any value less than or equal to target because row is sorted(means we are going to get greater value than target only).\\nOnce we get the count, we can check if we have count greater than K then we can decrease our range. \\nElse increase it because for kth smallest element you should have (K-1) elements before to reach Kth smallest.\\n[I know this solution is little bit tricky, You have to debug it in 3-4 examples to get what actually is happening].\\nTime Complexity:- O(NlogN)\\nSpace Complexity:- O(1)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& mat, int k) {\\n        \\n        int n=mat.size(),lb=mat[0][0],ub=mat[n-1][n-1];\\n        \\n        while(lb<ub)\\n        {\\n            int mid=lb-(lb-ub)/2;\\n            int res=count(mat,n,mid);\\n            if(res>=k)\\n                ub=mid;\\n            else\\n                lb=mid+1;\\n        }\\n        return ub;\\n    }\\n    int count(vector<vector<int>> &mat, int n,int target)\\n    {\\n        int curr_row=n-1,curr_col=0,count=0;\\n        while(curr_row>=0 && curr_col<n)\\n        {\\n            if(mat[curr_row][curr_col]<=target)\\n            {\\n                count+=(curr_row+1);\\n                curr_col++;\\n            }\\n            else\\n                curr_row--;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**Note:- **If you have learned the BInary Search approach, you can solve one more similar qs which is Finding the Median in a Matrix where rows are sorted. In this case you have to find, the kth element, and the kth Element will be the \"mid\" element if the matrix is put in the form a 1-D Array. And handle odd & even case to get the median. \\n\\nUsing Heap :-  Here, we know that the row  and column is already sorted. Therefore, instead of traversing in the entire matrix we can take advantage of that. We can take a Min Heap and push the First row(value, indexes) into Min heap.  You can push first column also, and write your answer according to that. \\nNow,follow these steps:-\\n1. pop the element from min heap and \\n2. check whether it is the Kth smallest element, if it is return the value,  \\n3. else push the next row value (Note:- column is going to remain same). \\nThe reason behind this logic is , when we remove the smallest element from Min Heap (i.e our 1st smallest element, which is always present in the 1st row and 1st column), then the 2nd smallest element may lie in that  2nd row and 1st column or it may be present in the First Row and  column greater than 1.\\nTime Complexity:- O(NlogN)\\nSpace Complexity:- O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& mat, int k) {\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>> , greater<pair<int,pair<int,int>>> > pq;\\n        int n=mat.size();\\n        for(int i=0; i<n; ++i)\\n            pq.push({mat[0][i],{0,i}});\\n        \\n        int ans;\\n        while(k--)\\n        {\\n            int val=pq.top().first;\\n            int row=pq.top().second.first;\\n            int col=pq.top().second.second;\\n            pq.pop();\\n            ans=val;\\n            if(row!=n-1)\\n                pq.push({mat[row+1][col],{row+1,col}});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& mat, int k) {\\n        \\n        int n=mat.size(),lb=mat[0][0],ub=mat[n-1][n-1];\\n        \\n        while(lb<ub)\\n        {\\n            int mid=lb-(lb-ub)/2;\\n            int res=count(mat,n,mid);\\n            if(res>=k)\\n                ub=mid;\\n            else\\n                lb=mid+1;\\n        }\\n        return ub;\\n    }\\n    int count(vector<vector<int>> &mat, int n,int target)\\n    {\\n        int curr_row=n-1,curr_col=0,count=0;\\n        while(curr_row>=0 && curr_col<n)\\n        {\\n            if(mat[curr_row][curr_col]<=target)\\n            {\\n                count+=(curr_row+1);\\n                curr_col++;\\n            }\\n            else\\n                curr_row--;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& mat, int k) {\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>> , greater<pair<int,pair<int,int>>> > pq;\\n        int n=mat.size();\\n        for(int i=0; i<n; ++i)\\n            pq.push({mat[0][i],{0,i}});\\n        \\n        int ans;\\n        while(k--)\\n        {\\n            int val=pq.top().first;\\n            int row=pq.top().second.first;\\n            int col=pq.top().second.second;\\n            pq.pop();\\n            ans=val;\\n            if(row!=n-1)\\n                pq.push({mat[row+1][col],{row+1,col}});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323090,
                "title": "c-solution",
                "content": "**Using Priority Queue (All Testcases Passed) \\u2714\\uFE0F**\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int>pq; int n = matrix.size();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++){\\n                pq.push(matrix[i][j]);\\n                if(pq.size() > k) pq.pop();\\n            }\\n        return pq.top();   \\n    }\\n};\\n```\\n**Using Binary Search | All Testcases Passed | 100% faster \\u2714\\uFE0F**\\n```\\nclass Solution {\\npublic:\\n    //from left-bottom or right-top, count how many numbers are less equal than mid\\n    int solve(vector<vector<int>>& matrix, int mid){\\n        int count = 0, n = matrix.size(), i = n-1, j = 0;\\n        while(i >= 0 && j < n){\\n            if(matrix[i][j] > mid) i--;\\n            else{\\n                count += (i+1);\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size(), i = matrix[0][0], j = matrix[n-1][n-1];\\n        while(i < j){\\n            int mid = i + (j-i)/2;\\n            int posi = solve(matrix, mid);\\n            if(posi < k) i = mid+1;\\n            else j = mid;\\n        }\\n        return i;\\n    }  \\n};\\n```\\n\\n**Using Unordered Map | 82/85 Testcases Passed | TLE \\u274C**\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size(), start = matrix[0][0], end = matrix[n-1][n-1];\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                mp[matrix[i][j]]++;\\n        \\n        for(int i = start; i <= end; i++)\\n            if(mp.find(i) != mp.end()){\\n                for(int j = 0; j < mp[i]; j++){\\n                    k--;\\n                    if(k == 0) return i;\\n                }\\n            }\\n          return -1;  \\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int>pq; int n = matrix.size();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++){\\n                pq.push(matrix[i][j]);\\n                if(pq.size() > k) pq.pop();\\n            }\\n        return pq.top();   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //from left-bottom or right-top, count how many numbers are less equal than mid\\n    int solve(vector<vector<int>>& matrix, int mid){\\n        int count = 0, n = matrix.size(), i = n-1, j = 0;\\n        while(i >= 0 && j < n){\\n            if(matrix[i][j] > mid) i--;\\n            else{\\n                count += (i+1);\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size(), i = matrix[0][0], j = matrix[n-1][n-1];\\n        while(i < j){\\n            int mid = i + (j-i)/2;\\n            int posi = solve(matrix, mid);\\n            if(posi < k) i = mid+1;\\n            else j = mid;\\n        }\\n        return i;\\n    }  \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size(), start = matrix[0][0], end = matrix[n-1][n-1];\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                mp[matrix[i][j]]++;\\n        \\n        for(int i = start; i <= end; i++)\\n            if(mp.find(i) != mp.end()){\\n                for(int j = 0; j < mp[i]; j++){\\n                    k--;\\n                    if(k == 0) return i;\\n                }\\n            }\\n          return -1;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321898,
                "title": "kth-smallest-element-c-python-space-o-1-comented",
                "content": "**If you find it helpful, plz upvote**\\n```\\nint kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int low = matrix[0][0], high = matrix[n-1][n-1];    // lowest element = first elemnt of mat, highest element = last element of mat\\n\\t\\t// required element will be in between these to element\\n\\t\\t// we can binary search in terms of condtion that how many number are less than the mid\\n        while(low < high){\\n            int mid = low + (high-low)/2;\\n            int cnt = 0;\\n            for(int i=0; i<n; i++){\\n                cnt += upper_bound(matrix[i].begin(), matrix[i].end(), mid)-matrix[i].begin();\\n            }\\n            if(cnt < k){\\n                low = mid+1;\\n            }\\n            else high = mid;\\n        }\\n        return low;\\n    }\\n```\\n**Python**\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        n = len(matrix)\\n        high, low = matrix[n-1][n-1], matrix[0][0]\\n        while low < high:\\n            cnt = 0\\n            mid = low + (high-low)//2\\n            for i in range(0, n):\\n                cnt += bisect_right(matrix[i], mid)\\n            if cnt < k:\\n                low = mid+1\\n            else:\\n                high = mid\\n        return low\\n```\\n\\n**Time Complexity**\\nFor binary search we have take low limit as the **lowest element** of the matrix and high as the **highest element** of the matrix lets A = highest - lowest , our ans will be within These limits\\nThen, for binary search O(log(A))\\nInside Binary search,\\nfor loop => O(n) , Upper_bound => O(log(n))\\nSo total time => **O(log(A)nlog(n))**\\nin many of the cases, upper_bound terminate very early\\nSo we can say thatt amortized time complexity **O(nLog(A))**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int low = matrix[0][0], high = matrix[n-1][n-1];    // lowest element = first elemnt of mat, highest element = last element of mat\\n\\t\\t// required element will be in between these to element\\n\\t\\t// we can binary search in terms of condtion that how many number are less than the mid\\n        while(low < high){\\n            int mid = low + (high-low)/2;\\n            int cnt = 0;\\n            for(int i=0; i<n; i++){\\n                cnt += upper_bound(matrix[i].begin(), matrix[i].end(), mid)-matrix[i].begin();\\n            }\\n            if(cnt < k){\\n                low = mid+1;\\n            }\\n            else high = mid;\\n        }\\n        return low;\\n    }\\n```\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        n = len(matrix)\\n        high, low = matrix[n-1][n-1], matrix[0][0]\\n        while low < high:\\n            cnt = 0\\n            mid = low + (high-low)//2\\n            for i in range(0, n):\\n                cnt += bisect_right(matrix[i], mid)\\n            if cnt < k:\\n                low = mid+1\\n            else:\\n                high = mid\\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85178,
                "title": "java-heap-klog-k",
                "content": "Similar to [Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/).\\n```\\npublic class Solution {\\n    public int kthSmallest(final int[][] matrix, int k) {\\n        int c = 0;\\n        PriorityQueue<int[]> queue = new PriorityQueue<>(\\n            k, (o1, o2) -> matrix[o1[0]][o1[1]] - matrix[o2[0]][o2[1]]);\\n        queue.offer(new int[] {0, 0});\\n        while (true) {\\n            int[] pair = queue.poll();\\n            if (++c == k) {\\n                return matrix[pair[0]][pair[1]];\\n            }\\n            if (pair[0] == 0 && pair[1] + 1 < matrix[0].length) {\\n                queue.offer(new int[] {0, pair[1] + 1});\\n            }\\n            if (pair[0] + 1 < matrix.length) {\\n                queue.offer(new int[] {pair[0] + 1, pair[1]});\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int kthSmallest(final int[][] matrix, int k) {\\n        int c = 0;\\n        PriorityQueue<int[]> queue = new PriorityQueue<>(\\n            k, (o1, o2) -> matrix[o1[0]][o1[1]] - matrix[o2[0]][o2[1]]);\\n        queue.offer(new int[] {0, 0}",
                "codeTag": "Java"
            },
            {
                "id": 440927,
                "title": "python-max-heap-beats-88",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        if not matrix or not matrix[0]:\\n            return -1\\n        heap = []\\n        for row in range(len(matrix)):\\n            for col in range(len(matrix[0])):\\n                nextVal = -matrix[row][col]\\n                if len(heap) < k:\\n                    heapq.heappush(heap, nextVal)\\n                elif nextVal > heap[0]:\\n                    heapq.heappushpop(heap, nextVal)\\n        return -heap[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        if not matrix or not matrix[0]:\\n            return -1\\n        heap = []\\n        for row in range(len(matrix)):\\n            for col in range(len(matrix[0])):\\n                nextVal = -matrix[row][col]\\n                if len(heap) < k:\\n                    heapq.heappush(heap, nextVal)\\n                elif nextVal > heap[0]:\\n                    heapq.heappushpop(heap, nextVal)\\n        return -heap[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85225,
                "title": "quick-select-and-binary-search-detailed-notes",
                "content": "### Quick Select\\n\\nThe first solution comes into my mind is Quick Select, which flattens the matrix into an array with `n^2` elements. Hence, the time complexity is `O(n^2)`.\\n\\n```ruby\\n  # O(n^2) where n is the rows count\\n  def kth_smallest(matrix, k)\\n    nums = matrix.flatten\\n\\n    shuffle!(nums)\\n\\n    k -= 1\\n\\n    lo, hi = 0, nums.count-1\\n\\n    loop do\\n      break if lo >= hi\\n      j = partition(nums, lo, hi)\\n\\n      if j == k\\n        return nums[k]\\n      elsif j < k\\n        lo = j + 1\\n      else\\n        hi = j - 1\\n      end\\n    end\\n\\n    nums[k]\\n  end\\n\\n  def shuffle!(nums)\\n    (1..nums.count-1).each do |i|\\n      j = rand(i+1)\\n      swap(nums, i, j)\\n    end\\n  end\\n\\n  def partition(array, lo, hi)\\n    v = lo\\n    i, j = lo, hi+1\\n\\n    loop do\\n      loop do\\n        i += 1\\n        break if i == hi or array[i] >= array[v]\\n      end\\n\\n      loop do\\n        j -= 1\\n        break if j == lo or array[j] <= array[v]\\n      end\\n\\n      break if i >= j\\n      swap(array, i, j)\\n    end\\n\\n    swap(array, j, v)\\n    return j\\n  end\\n\\n  def swap(array, i, j)\\n    t = array[i]; array[i] = array[j]; array[j] = t\\n  end\\n\\n```\\n\\n### Binary Search (solution)\\n\\nWhile the Quick Select solution doesn't make good use of the properties the matrix has, I browsed the discussion to see this solution. To be honest, it's kind of new to me. I put some effort on it to learn about the idea.\\n\\n```ruby\\n  # Binary Search on values - O(logN n logn) where n is the rows count and N is the largest element\\n  def kth_smallest(matrix, k)\\n    lo, hi = matrix[0][0], matrix[-1][-1]\\n\\n    p = ->(x) {\\n      count = 0\\n      matrix.each do |row|\\n        # b-searching (equals: count += row.count {|num| num <= x})\\n        count += ( (0..row.count-1).bsearch{|i| row[i] > x } or row.count )\\n      end\\n\\n      count >= k\\n    }\\n\\n    while lo < hi\\n      mid = (lo+hi)/2\\n\\n      if p[mid]\\n        hi = mid\\n      else\\n        lo = mid + 1\\n      end\\n    end\\n\\n    return lo\\n  end\\n```\\n\\n### Binary Search (notes)\\n\\nI happened to read the article [Binary Search - topcoder](https://www.topcoder.com/community/data-science/data-science-tutorials/binary-search/), which really helped me get a better understanding about Binary Search. So I made some notes here:\\n\\n#### What I know before\\n![0_1480565606773_upload-6a3c67a2-7025-43c8-a323-5445cd827d4c](/uploads/files/1480565611163-upload-6a3c67a2-7025-43c8-a323-5445cd827d4c.png) \\n\\n#### Search Space\\n\\nBinary search maintains a contiguous subsequence of the starting sequence where the target value is surely located. This is called the **search space**. The search space is initially the entire sequence. At each step, the algorithm compares the median value in the search space to the target value. Based on the comparison and because the sequence is sorted, it can then eliminate half of the search space.\\n\\n#### Beyond arrays: the discrete binary search\\n\\nA sequence (array) is really just a function which associates integers (indices) with the corresponding values. However, there is no reason to restrict our usage of binary search to tangible sequences. In fact, we can use the same algorithm described above on any monotonic function f whose domain is the set of integers. The only difference is that we replace an array lookup with a function evaluation: we are now looking for some x such that f(x) is equal to the target value.\\n\\n![0_1480565648520_upload-bfdd4f36-1165-4a4f-90df-f8aa0b4e782e](/uploads/files/1480565648725-upload-bfdd4f36-1165-4a4f-90df-f8aa0b4e782e.png) \\n\\n#### Taking it further: the main theorem\\n\\nBinary search can be used **if and only if for all x in S, p(x) implies p(y) for all y > x**.\\n\\n![0_1480565671955_upload-dda6d146-b78b-4861-98dd-594b45b2628e](/uploads/files/1480565672118-upload-dda6d146-b78b-4861-98dd-594b45b2628e.png) \\n\\nThese two parts are most often interleaved: when we think a problem can be solved by binary search, we aim to **design the predicate so that it satisfies the condition in the main theorem.**\\n\\n#### Implementing the discrete algorithm\\n\\nThe idea is **always making sure the search space contains what you aim to find**. (when you adjust lo and hi)\\n\\nFind the first `x` for which `p(x)` is true:\\n\\n![0_1480565728997_upload-fcfae7e6-b2be-4da2-85a4-89798f52b1ba](/uploads/files/1480565730107-upload-fcfae7e6-b2be-4da2-85a4-89798f52b1ba.png) \\n\\nThe two crucial lines are `hi = mid` and `lo = mid+1`. When `p(mid)` is true, we can discard the second half of the search space, since the predicate is true for all elements in it (by the main theorem). However, we can not discard `mid` itself, since it may well be the first element for which `p` is true. This is why moving the upper bound to mid is as aggressive as we can do without introducing bugs.\\nIn a similar vein, if `p(mid)` is false, we can discard the first half of the search space, but this time including `mid`. `p(mid)` is false so we don\\u2019t need it in our search space. This effectively means we can move the lower bound to `mid+1`.\\n\\n*Q. Why use `lo < hi` rather than `lo <= hi`?*\\n\\nBecause the `hi = mid` when `p(mid)` is true. Think of the situation when `lo == hi`, it would be lost in the loop.\\n\\nFind the last `x` for which `p(x)` is false:\\n\\n![0_1480565748645_upload-ef26dc31-1529-4c33-9cb6-6339b0cbeb3a](/uploads/files/1480565749648-upload-ef26dc31-1529-4c33-9cb6-6339b0cbeb3a.png) \\n\\nThe bug is the code would be lost in loop when\\n\\n![0_1480565766425_upload-cf312d3a-75bf-4f3a-8754-07248338b1ce](/uploads/files/1480565766615-upload-cf312d3a-75bf-4f3a-8754-07248338b1ce.png) \\n\\nWhy?\\n\\n*Q. What does `mid = lo + (hi-lo)/2` mean?*\\n\\nThe answer is it always round down. So to fix the bug, we would use `mid = lo + (hi-lo+1)/2` to round up.\\n\\n![0_1480565787293_upload-8b103094-76fc-4d75-8ee3-9c03dfe9c1f5](/uploads/files/1480565787443-upload-8b103094-76fc-4d75-8ee3-9c03dfe9c1f5.png) \\n\\n*Q. Why don\\u2019t we just use `mid = (lo+hi)/2` instead?*\\n\\nThis is to avoid another potential rounding bug: when `lo+hi` would be negative, it would start rounding towards the higher bound.\\n\\n![0_1480565806172_upload-dfe77566-7797-4adf-ba82-45adf207f3e2](/uploads/files/1480565806362-upload-dfe77566-7797-4adf-ba82-45adf207f3e2.png) \\n\\n\\nThe takeaway of these question: **always check on two-element set**.\\n\\n#### Conclusion\\n\\n- **Design a predicate** which can be efficiently evaluated and so that binary search can be applied\\n- Decide on what you\\u2019re looking for and code so that **make sure the search space always contains that** (if it exists)\\n- If the search space consists only of integers, **test your algorithm on a two-element set** to be sure it doesn\\u2019t lock up\\n- **Verify that the lower and upper bounds** are not overly constrained: it\\u2019s usually better to relax them as long as it doesn\\u2019t break the predicate\\n\\n#### What I know after\\n\\n- Design the predict if I\\u2019m about to use Binary Search.\\n- When adjusting `lo` and `hi`, always make sure the Search Space contains the target (if exists)\\n- Think about two-element situation, and adjust the loop condition, like whether is `lo < hi` or `lo <= hi`.",
                "solutionTags": [
                    "Ruby",
                    "Binary Tree",
                    "Quickselect"
                ],
                "code": "```ruby\\n  # O(n^2) where n is the rows count\\n  def kth_smallest(matrix, k)\\n    nums = matrix.flatten\\n\\n    shuffle!(nums)\\n\\n    k -= 1\\n\\n    lo, hi = 0, nums.count-1\\n\\n    loop do\\n      break if lo >= hi\\n      j = partition(nums, lo, hi)\\n\\n      if j == k\\n        return nums[k]\\n      elsif j < k\\n        lo = j + 1\\n      else\\n        hi = j - 1\\n      end\\n    end\\n\\n    nums[k]\\n  end\\n\\n  def shuffle!(nums)\\n    (1..nums.count-1).each do |i|\\n      j = rand(i+1)\\n      swap(nums, i, j)\\n    end\\n  end\\n\\n  def partition(array, lo, hi)\\n    v = lo\\n    i, j = lo, hi+1\\n\\n    loop do\\n      loop do\\n        i += 1\\n        break if i == hi or array[i] >= array[v]\\n      end\\n\\n      loop do\\n        j -= 1\\n        break if j == lo or array[j] <= array[v]\\n      end\\n\\n      break if i >= j\\n      swap(array, i, j)\\n    end\\n\\n    swap(array, j, v)\\n    return j\\n  end\\n\\n  def swap(array, i, j)\\n    t = array[i]; array[i] = array[j]; array[j] = t\\n  end\\n\\n```\n```ruby\\n  # Binary Search on values - O(logN n logn) where n is the rows count and N is the largest element\\n  def kth_smallest(matrix, k)\\n    lo, hi = matrix[0][0], matrix[-1][-1]\\n\\n    p = ->(x) {\\n      count = 0\\n      matrix.each do |row|\\n        # b-searching (equals: count += row.count {|num| num <= x})\\n        count += ( (0..row.count-1).bsearch{|i| row[i] > x } or row.count )\\n      end\\n\\n      count >= k\\n    }\\n\\n    while lo < hi\\n      mid = (lo+hi)/2\\n\\n      if p[mid]\\n        hi = mid\\n      else\\n        lo = mid + 1\\n      end\\n    end\\n\\n    return lo\\n  end\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1524783,
                "title": "java-two-solutions-binary-search-priorityqueue",
                "content": "**Using PriorityQueue - This soultion is preferred if K < Length of one side of the matrix**\\n\\n```java\\n/**\\n * Using PriorityQueue\\n *\\n * Time Complexity:\\n *      O(min(N,K)*log(min(N,K))) -> To add initial min(N,K) elements, as we are adding the elements individually.\\n *                                   If we were adding all elements in one go, then the complexity would be O(min(N,K))\\n *                                   Refer: https://stackoverflow.com/a/34697891\\n *      O(2*(K-1)*log(min(N,K)) -> To poll K-1 elements and add next K-1 elements.\\n * Total Time Complexity: O((min(N,K) + 2*(K-1)) * log(min(N,K)) = O(K * log(min(N,K))\\n *\\n * Space Complexity: O(min(N, K))\\n *\\n * N = Length of one side of the matrix. K = input value k.\\n */\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if (matrix == null || k <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int n = matrix.length;\\n        if (k > n * n) {\\n            throw new NoSuchElementException(\"k is greater than number of elements in matrix\");\\n        }\\n        if (k == 1) {\\n            return matrix[0][0];\\n        }\\n        if (k == n * n) {\\n            return matrix[n - 1][n - 1];\\n        }\\n\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> (matrix[a[0]][a[1]] - matrix[b[0]][b[1]]));\\n\\n        for (int i = 0; i < Math.min(n, k); i++) {\\n            queue.offer(new int[] { i, 0 });\\n        }\\n        while (k > 1) {\\n            int[] cur = queue.poll();\\n            if (cur[1] < n - 1) {\\n                cur[1]++;\\n                queue.offer(cur);\\n            }\\n            k--;\\n        }\\n\\n        return matrix[queue.peek()[0]][queue.peek()[1]];\\n    }\\n}\\n```\\n\\n----\\n**Using Binary Search - This soultion is preferred if K > Length of one side of the matrix**\\n\\n```java\\n/**\\n * Using Binary Search on the range of Min and Max values in the matrix\\n *\\n * Time Complexity: O(2*N * log(Max-Min))\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of one side of the matrix. Max = Maximum value in Matrix. Min = Minimum value in matrix.\\n */\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if (matrix == null || k <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int n = matrix.length;\\n        if (k > n * n) {\\n            throw new NoSuchElementException(\"k is greater than number of elements in matrix\");\\n        }\\n        if (k == 1) {\\n            return matrix[0][0];\\n        }\\n        if (k == n * n) {\\n            return matrix[n - 1][n - 1];\\n        }\\n\\n        int start = matrix[0][0];\\n        int end = matrix[n - 1][n - 1];\\n\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            int[] smallLargePair = { start, end };\\n            int count = countLessThanAndEqual(matrix, mid, smallLargePair);\\n            if (count == k) {\\n                return smallLargePair[0];\\n            }\\n            if (count < k) {\\n                start = smallLargePair[1]; // search higher\\n            } else {\\n                end = smallLargePair[0]; // search lower\\n            }\\n        }\\n\\n        return start;\\n    }\\n\\n    private int countLessThanAndEqual(int[][] matrix, int mid, int[] smallLargePair) {\\n        int count = 0;\\n        int n = matrix.length;\\n        int row = 0;\\n        int col = n - 1;\\n        while (row < n && col >= 0) {\\n            if (matrix[row][col] > mid) {\\n                // as matrix[row][col] is bigger than the mid, let\\'s keep track of the\\n                // smallest number greater than the mid\\n                smallLargePair[1] = Math.min(smallLargePair[1], matrix[row][col]);\\n                col--;\\n            } else {\\n                // as matrix[row][col] is less than or equal to the mid, let\\'s keep track of the\\n                // biggest number less than or equal to the mid\\n                smallLargePair[0] = Math.max(smallLargePair[0], matrix[row][col]);\\n                row++;\\n                count += col + 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Heap (Priority Queue)",
                    "Matrix",
                    "Binary Tree"
                ],
                "code": "```java\\n/**\\n * Using PriorityQueue\\n *\\n * Time Complexity:\\n *      O(min(N,K)*log(min(N,K))) -> To add initial min(N,K) elements, as we are adding the elements individually.\\n *                                   If we were adding all elements in one go, then the complexity would be O(min(N,K))\\n *                                   Refer: https://stackoverflow.com/a/34697891\\n *      O(2*(K-1)*log(min(N,K)) -> To poll K-1 elements and add next K-1 elements.\\n * Total Time Complexity: O((min(N,K) + 2*(K-1)) * log(min(N,K)) = O(K * log(min(N,K))\\n *\\n * Space Complexity: O(min(N, K))\\n *\\n * N = Length of one side of the matrix. K = input value k.\\n */\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if (matrix == null || k <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int n = matrix.length;\\n        if (k > n * n) {\\n            throw new NoSuchElementException(\"k is greater than number of elements in matrix\");\\n        }\\n        if (k == 1) {\\n            return matrix[0][0];\\n        }\\n        if (k == n * n) {\\n            return matrix[n - 1][n - 1];\\n        }\\n\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> (matrix[a[0]][a[1]] - matrix[b[0]][b[1]]));\\n\\n        for (int i = 0; i < Math.min(n, k); i++) {\\n            queue.offer(new int[] { i, 0 });\\n        }\\n        while (k > 1) {\\n            int[] cur = queue.poll();\\n            if (cur[1] < n - 1) {\\n                cur[1]++;\\n                queue.offer(cur);\\n            }\\n            k--;\\n        }\\n\\n        return matrix[queue.peek()[0]][queue.peek()[1]];\\n    }\\n}\\n```\n```java\\n/**\\n * Using Binary Search on the range of Min and Max values in the matrix\\n *\\n * Time Complexity: O(2*N * log(Max-Min))\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of one side of the matrix. Max = Maximum value in Matrix. Min = Minimum value in matrix.\\n */\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if (matrix == null || k <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int n = matrix.length;\\n        if (k > n * n) {\\n            throw new NoSuchElementException(\"k is greater than number of elements in matrix\");\\n        }\\n        if (k == 1) {\\n            return matrix[0][0];\\n        }\\n        if (k == n * n) {\\n            return matrix[n - 1][n - 1];\\n        }\\n\\n        int start = matrix[0][0];\\n        int end = matrix[n - 1][n - 1];\\n\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            int[] smallLargePair = { start, end };\\n            int count = countLessThanAndEqual(matrix, mid, smallLargePair);\\n            if (count == k) {\\n                return smallLargePair[0];\\n            }\\n            if (count < k) {\\n                start = smallLargePair[1]; // search higher\\n            } else {\\n                end = smallLargePair[0]; // search lower\\n            }\\n        }\\n\\n        return start;\\n    }\\n\\n    private int countLessThanAndEqual(int[][] matrix, int mid, int[] smallLargePair) {\\n        int count = 0;\\n        int n = matrix.length;\\n        int row = 0;\\n        int col = n - 1;\\n        while (row < n && col >= 0) {\\n            if (matrix[row][col] > mid) {\\n                // as matrix[row][col] is bigger than the mid, let\\'s keep track of the\\n                // smallest number greater than the mid\\n                smallLargePair[1] = Math.min(smallLargePair[1], matrix[row][col]);\\n                col--;\\n            } else {\\n                // as matrix[row][col] is less than or equal to the mid, let\\'s keep track of the\\n                // biggest number less than or equal to the mid\\n                smallLargePair[0] = Math.max(smallLargePair[0], matrix[row][col]);\\n                row++;\\n                count += col + 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 418543,
                "title": "javascript-binary-search-solution-w-explanation",
                "content": "#### The Idea\\nWhen we have a regular sorted 2d array, we use range of index to find our target. for example, lo = 0, hi = length-1, mid = (lo+hi)/2. if the target is greater than the number at index mid, then we search the right portion, if it\\'s smaller, we search the left.\\nHowever, in this 2d matrix sorted array, it is impossible to find such mid index. The intuition here is to use a range of numbers to test against our k. We know the first number is the smallest and the last number is the largest, this means our target number must be something in between. We can use those two numbers as our lo and hi, and set our mid to be the number in between, and check how many of the numbers in the matrix are smaller than that number and adjust lo and hi accordingly. When we get exactly k numbers, we know we have found our answer.\\nThe extremely tricky part here is that just by looking at how we calculate mid, a lot of times the number we are testing agaist may not even in the matrix, because in the end, the numbers we are using are just arbitrary numbers.\\nTo explain this we need to imagine that our program is at a stage where lo and hi are almost going to hit each other. if we counted less numbers than expected, we will set `lo=mid+1`, this potentially just increment our mid by 1. And by increment our mid 1 by 1, We can make sure the numbers is included in the matrix. \\n\\n``` javascript\\nvar kthSmallest = function(matrix, k) {\\n    let lo = matrix[0][0], hi = matrix[matrix.length-1][matrix[0].length-1] + 1; // +1 because we don\\'t want to forget the last number\\n    while (lo < hi) {\\n        let mid = lo + Math.floor((hi-lo)/2);\\n        let count = 0;\\n        for (let i = 0;i<matrix.length;i++) {\\n            for (let j=0;j<matrix.length;j++) {\\n                if (matrix[i][j] <= mid) count++;\\n                else break;\\n            }\\n        }\\n        if (count < k) lo = mid+1;\\n        else hi = mid;\\n    }\\n    return lo\\n};\\n```\\nI found [**this**](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/301357/Simple-to-understand-solutions-using-Heap-and-Binary-Search-JavaPython) to be a extremely clear post .",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar kthSmallest = function(matrix, k) {\\n    let lo = matrix[0][0], hi = matrix[matrix.length-1][matrix[0].length-1] + 1; // +1 because we don\\'t want to forget the last number\\n    while (lo < hi) {\\n        let mid = lo + Math.floor((hi-lo)/2);\\n        let count = 0;\\n        for (let i = 0;i<matrix.length;i++) {\\n            for (let j=0;j<matrix.length;j++) {\\n                if (matrix[i][j] <= mid) count++;\\n                else break;\\n            }\\n        }\\n        if (count < k) lo = mid+1;\\n        else hi = mid;\\n    }\\n    return lo\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85230,
                "title": "share-my-python-solution-using-heap",
                "content": "**Algorithm**\\n\\n1. ``h``: list of tuple ``(element, row, index)``, which is initialised with first element of each row in the matrix.\\n2. We maintain a heap. In the for loop, we get the smallest element ``v`` which is in row ``r``, and replace ``v`` with the next element in the row ``r``\\n\\n**Time Complexity**\\n\\n- insert an element into heap: O(log(n)), where n is the width of the matrix\\n- find k the k-th element O(k)\\n- Overall: O(klog(n))   \\n\\n```python\\nfrom heapq import heappush, heappop, heapreplace, heapify\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        h = [(row[0], row, 1) for row in matrix]\\n        heapify(h)\\n\\n        # Since we want to find kth, we pop the first k elements \\n        for _ in xrange(k - 1):\\n            v, r, i = h[0]\\n            if i < len(r):\\n                heapreplace(h, (r[i], r, i + 1))\\n            else:\\n                heappop(h)\\n\\n        return h[0][0]\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom heapq import heappush, heappop, heapreplace, heapify\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        h = [(row[0], row, 1) for row in matrix]\\n        heapify(h)\\n\\n        # Since we want to find kth, we pop the first k elements \\n        for _ in xrange(k - 1):\\n            v, r, i = h[0]\\n            if i < len(r):\\n                heapreplace(h, (r[i], r, i + 1))\\n            else:\\n                heappop(h)\\n\\n        return h[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385771,
                "title": "python-detailed-explanation-easy-understand-binarysearch",
                "content": "```\\nclass Solution:\\n    def countSmallerThanMid(self, matrix, mid_value, num_of_rows):\\n        column = num_of_rows - 1\\n        row = 0\\n        count = 0\\n        while column >= 0 and row < num_of_rows:\\n            if matrix[row][column] > mid_value:\\n                column -= 1\\n            else:\\n                count += column + 1\\n                row += 1\\n        \\n        return count\\n\\n\\n    def kthSmallest(self, matrix, k):\\n        num_of_rows = len(matrix)\\n        min_value = matrix[0][0]\\n        max_value = matrix[-1][-1]\\n\\n        while min_value < max_value:\\n            mid_value = min_value + int((max_value - min_value) / 2)\\n            if self.countSmallerThanMid(matrix, mid_value, num_of_rows) < k:\\n                min_value = mid_value + 1\\n            else:\\n                max_value = mid_value\\n        return min_value\\n```\\n**Time complexity**: O((n log(n)) * (log(m)))\\n**Space complexity**: O(1)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countSmallerThanMid(self, matrix, mid_value, num_of_rows):\\n        column = num_of_rows - 1\\n        row = 0\\n        count = 0\\n        while column >= 0 and row < num_of_rows:\\n            if matrix[row][column] > mid_value:\\n                column -= 1\\n            else:\\n                count += column + 1\\n                row += 1\\n        \\n        return count\\n\\n\\n    def kthSmallest(self, matrix, k):\\n        num_of_rows = len(matrix)\\n        min_value = matrix[0][0]\\n        max_value = matrix[-1][-1]\\n\\n        while min_value < max_value:\\n            mid_value = min_value + int((max_value - min_value) / 2)\\n            if self.countSmallerThanMid(matrix, mid_value, num_of_rows) < k:\\n                min_value = mid_value + 1\\n            else:\\n                max_value = mid_value\\n        return min_value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698715,
                "title": "c-solution-binary-search",
                "content": "**Using Binary Search: O(N\\u2217log(max\\u2212min))**\\nSince each row and column of the matrix is sorted, is it possible to use Binary Search to find the Kth smallest number?\\n\\nThe biggest problem to use Binary Search in this case is that we don\\u2019t have a straightforward sorted array, instead we have a matrix. As we remember, in Binary Search, we calculate the middle index of the search space (\\u20181\\u2019 to \\u2018N\\u2019) and see if our required number is pointed out by the middle index; if not we either search in the lower half or the upper half. In a sorted matrix, we can\\u2019t really find a middle. Even if we do consider some index as middle, it is not straightforward to find the search space containing numbers bigger or smaller than the number pointed out by the middle index.\\n\\nAn alternate could be to apply the Binary Search on the \\u201Cnumber range\\u201D instead of the \\u201Cindex range\\u201D. As we know that the smallest number of our matrix is at the top left corner and the biggest number is at the bottom lower corner. These two number can represent the \\u201Crange\\u201D i.e., the start and the end for the Binary Search. Here is how our algorithm will work:\\n\\n1. Start the Binary Search with start = matrix[0][0] and end = matrix[n-1][n-1].\\n2. Find middle of the start and the end. This middle number is NOT necessarily an element in the matrix.\\n3. Count all the numbers smaller than or equal to middle in the matrix. As the matrix is sorted, we can do this in O(N).\\n4. While counting, we can keep track of the \\u201Csmallest number greater than the middle\\u201D (let\\u2019s call it n1) and at the same time the \\u201Cbiggest number less than or equal to the middle\\u201D (let\\u2019s call it n2). These two numbers will be used to adjust the \"number range\" for the Binary Search in the next iteration.\\nIf the count is equal to \\u2018K\\u2019, n1 will be our required number as it is the \\u201Cbiggest number less than or equal to the middle\\u201D, and is definitely present in the matrix.\\n5. If the count is less than \\u2018K\\u2019, we can update start = n2 to search in the higher part of the matrix and if the count is greater than \\u2018K\\u2019, we can update end = n1 to search in the lower part of the matrix in the next iteration.\\n Here is the visual representation of this algorithm:\\n![image](https://assets.leetcode.com/users/images/19d7ee3a-3833-4c4b-b6b0-9a3fe443eec8_1592750457.2327614.png)\\n\\n**The algorithm runs in constant space O(1).\\nThe above solution was taken from *** the Coding Interview.**\\n\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        if(matrix.empty()) return 0;\\n        int N = matrix.size();\\n        int left = matrix[0][0];\\n        int right = matrix[N-1][N-1];\\n        while(left < right) {\\n            int mid = left + (right - left)/2;\\n            int count = 0;\\n            for(int i=0; i<N; i++) {\\n                count += upper_bound(matrix[i].begin(),matrix[i].end(),mid) - matrix[i].begin();\\n            }\\n            if(count < k) left = mid + 1;\\n            else right = mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        if(matrix.empty()) return 0;\\n        int N = matrix.size();\\n        int left = matrix[0][0];\\n        int right = matrix[N-1][N-1];\\n        while(left < right) {\\n            int mid = left + (right - left)/2;\\n            int count = 0;\\n            for(int i=0; i<N; i++) {\\n                count += upper_bound(matrix[i].begin(),matrix[i].end(),mid) - matrix[i].begin();\\n            }\\n            if(count < k) left = mid + 1;\\n            else right = mid;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944312,
                "title": "python-binary-search-super-simple-complexity-explained",
                "content": "1. bisect.bisect(array, x): returns an insertion point which comes after (to the right of) any existing entries of x in array\\n2. Time: O(nlog(max-min)logn) where n is number of rows. Please comment below if you believe otherwise.\\n\\ta. log(max-min) for while loop\\n\\tb. n for for row in matrix\\n\\tc. logn for bisect.bisect()\\n3. Space: O(1)\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        \\'\\'\\'\\n        Binary search\\n        \\'\\'\\'\\n        l = matrix[0][0]\\n        r = matrix[-1][-1]\\n        \\n        while l < r:\\n            m = l + (r - l) // 2\\n            if sum(bisect.bisect(row, m) for row in matrix) < k:   # calculate how many numbers are on the left of middle number\\n                l = m + 1\\n            else:\\n                r = m\\n        return l\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        \\'\\'\\'\\n        Binary search\\n        \\'\\'\\'\\n        l = matrix[0][0]\\n        r = matrix[-1][-1]\\n        \\n        while l < r:\\n            m = l + (r - l) // 2\\n            if sum(bisect.bisect(row, m) for row in matrix) < k:   # calculate how many numbers are on the left of middle number\\n                l = m + 1\\n            else:\\n                r = m\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355233,
                "title": "python-binary-search-o-n-time-with-explanation",
                "content": "If we are not looking for the kth element, but looking for an exact element value, then this can be done in O(n) using the way in [leetcode 240: Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/). The tricky part here is converting kth element search into exact value search. \\nWe find the smallest and biggest value in the whole matrix, looking for its middle value. This is a value search and takes O(n). During search, we can find how many values smaller than the searching value. If the number is bigger than k, that means the searching value is too big, if smaller than k, that means the searching value is too small. This is a typical binary search.\\nTime complexity O(nlgm), where \"m\" is \"max-min\" value in the matrix. Since this value is int32, it actually takes O(nlg2^32), which is O(32n), which is O(n)\\n\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        n,m=len(matrix),len(matrix[0])\\n        def countSmaller(num):\\n            i,j,cnt=0,m-1,0\\n            while i<n and j>=0:\\n                if matrix[i][j]<num:\\n                    cnt+=j+1\\n                    i+=1\\n                else:\\n                    j-=1\\n            return cnt\\n        def helper():\\n            lo,hi=matrix[0][0],matrix[-1][-1]\\n            while lo<=hi:\\n                mid=(lo+hi)//2\\n                if countSmaller(mid)>=k:\\n                    hi=mid-1\\n                else:\\n                    lo=mid+1\\n            return hi\\n        return helper()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        n,m=len(matrix),len(matrix[0])\\n        def countSmaller(num):\\n            i,j,cnt=0,m-1,0\\n            while i<n and j>=0:\\n                if matrix[i][j]<num:\\n                    cnt+=j+1\\n                    i+=1\\n                else:\\n                    j-=1\\n            return cnt\\n        def helper():\\n            lo,hi=matrix[0][0],matrix[-1][-1]\\n            while lo<=hi:\\n                mid=(lo+hi)//2\\n                if countSmaller(mid)>=k:\\n                    hi=mid-1\\n                else:\\n                    lo=mid+1\\n            return hi\\n        return helper()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85188,
                "title": "python-one-line-solution",
                "content": " life is too short to figure out more intelligent solution...\\n```\\nimport heapq\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        return list(heapq.merge(*matrix))[k-1]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        return list(heapq.merge(*matrix))[k-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380187,
                "title": "python-two-solution-heap-or-sorting",
                "content": "```\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        a, res = [], -1\\n        for r in matrix:\\n            for e in r:\\n                heappush(a, e)\\n\\n        for _ in range(k):\\n            res = heappop(a)    \\n        return res\\n```\\n\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:        \\n        res = []\\n        for r in matrix:\\n            res += r\\n        return sorted(res)[k-1]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        a, res = [], -1\\n        for r in matrix:\\n            for e in r:\\n                heappush(a, e)\\n\\n        for _ in range(k):\\n            res = heappop(a)    \\n        return res\\n```\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:        \\n        res = []\\n        for r in matrix:\\n            res += r\\n        return sorted(res)[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012750,
                "title": "100-bin-search-i-guess-my-comments-could-help",
                "content": "```\\n/*\\nUse Binary Searrch.\\nThe low is matrix[0][0], and the high is matrix[n-1][n-1].\\n\\nm is the value between min and max, if there are k elements smaller or equal\\nthan m at any point, then we can return m since it is the kth smallest element\\n\\nif there are less than k elemenst smaller or equal than m at any point, we update\\nl to be l = m + 1. This means m is still too small to have k elements smaller or equal\\nto it. So we want l bigger so that next time m could also be bigger after calculating\\nm = l + (r - l) / 2. \\n\\nHow does this guarantee l, r and m are actually in the matrix during traversing?\\n\\n\\n*/\\nclass Solution {\\n    // O(n^2 * log(max - min)), where n^2 comes from function smallerOrEqual()\\n    // assume k is valid, meaning n*n >= k\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if(matrix ==  null || matrix[0].length == 0 || \\n           matrix[0] == null || matrix[0].length == 0)\\n            return 0;\\n        \\n        int n = matrix.length;\\n        int l = matrix[0][0], r = matrix[n-1][n-1];\\n        \\n        while(l < r){\\n            int m = l + (r - l) / 2;\\n\\t\\t\\t// find the number of elements <= m in matrix\\n            if(smallerOrEqual(matrix, m, n) < k) // Note don\\'t do <= k\\n                l = m + 1;\\n            else\\n                r = m;\\n        }\\n        \\n        return l; // or return r\\n    }\\n    \\n    // start from top-right. Does this ring any bell?\\n    // It is the problem 240. Search a 2D Matrix II\\n    // https://leetcode.com/problems/search-a-2d-matrix-ii/\\n    // We search for the value but do not return the boolean,\\n    // what we do is to find num of elements that are\\n    // smaller or equal to the target number: m\\n    public int smallerOrEqual(int[][] matrix, int m, int n){\\n        int row = 0, col = n - 1, count = 0;\\n        while(row < n && col >= 0){\\n            if(matrix[row][col] <= m){ // then everything to matrix[row][col]\\'s left is <= m\\n                row++;\\n                count += (col + 1); // note index start at 0, so col+1\\n            }else{\\n                col--;\\n            }\\n        }\\n        return count; // number of elements smaller or equal than m\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\nUse Binary Searrch.\\nThe low is matrix[0][0], and the high is matrix[n-1][n-1].\\n\\nm is the value between min and max, if there are k elements smaller or equal\\nthan m at any point, then we can return m since it is the kth smallest element\\n\\nif there are less than k elemenst smaller or equal than m at any point, we update\\nl to be l = m + 1. This means m is still too small to have k elements smaller or equal\\nto it. So we want l bigger so that next time m could also be bigger after calculating\\nm = l + (r - l) / 2. \\n\\nHow does this guarantee l, r and m are actually in the matrix during traversing?\\n\\n\\n*/\\nclass Solution {\\n    // O(n^2 * log(max - min)), where n^2 comes from function smallerOrEqual()\\n    // assume k is valid, meaning n*n >= k\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if(matrix ==  null || matrix[0].length == 0 || \\n           matrix[0] == null || matrix[0].length == 0)\\n            return 0;\\n        \\n        int n = matrix.length;\\n        int l = matrix[0][0], r = matrix[n-1][n-1];\\n        \\n        while(l < r){\\n            int m = l + (r - l) / 2;\\n\\t\\t\\t// find the number of elements <= m in matrix\\n            if(smallerOrEqual(matrix, m, n) < k) // Note don\\'t do <= k\\n                l = m + 1;\\n            else\\n                r = m;\\n        }\\n        \\n        return l; // or return r\\n    }\\n    \\n    // start from top-right. Does this ring any bell?\\n    // It is the problem 240. Search a 2D Matrix II\\n    // https://leetcode.com/problems/search-a-2d-matrix-ii/\\n    // We search for the value but do not return the boolean,\\n    // what we do is to find num of elements that are\\n    // smaller or equal to the target number: m\\n    public int smallerOrEqual(int[][] matrix, int m, int n){\\n        int row = 0, col = n - 1, count = 0;\\n        while(row < n && col >= 0){\\n            if(matrix[row][col] <= m){ // then everything to matrix[row][col]\\'s left is <= m\\n                row++;\\n                count += (col + 1); // note index start at 0, so col+1\\n            }else{\\n                col--;\\n            }\\n        }\\n        return count; // number of elements smaller or equal than m\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630785,
                "title": "c-both-priority-queue-and-binary-search-approaches",
                "content": "### Approach 1: Priority Queue - O(n^2log(n)) time\\n\\n- Traverse the whole matrix and put all elements in priority queue.\\n- Pop k - 1 elements from priority queue and return the top element.\\n\\nCode for approach 1:\\n\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int , vector<int> , greater<int>> pq;\\n        for(int i = 0 ; i < matrix.size() ; ++i){\\n            for(int j = 0 ; j < matrix[0].size() ; ++j){\\n                pq.push(matrix[i][j]);\\n            }    \\n        }\\n        k = k - 1;\\n        while(k--){\\n            pq.pop();\\n        }\\n        return pq.top();\\n    }\\n};\\n```\\n\\n### Approach 2 : Binary Search - O(log(nlog(n)) time\\n\\nPerform binary search to count all numbers, till count < k. Limits of binary search space would be smallest number in matrix ( i.e. matrix[0][0]) and highest number in matrix ( i.e. matrix[n][n]). \\n\\nCode for approach 2:\\n\\n```\\nclass Solution {\\npublic:\\n    // Binary Search Function which returns the count of numbers smaller than target.\\n    long long get_smallers(vector<int>& numbers , long long target){\\n        long long low = 0 , high = numbers.size() - 1;\\n        while(low <= high){\\n            long long mid = low + (high - low)/2;\\n            if(numbers[mid] <= target){\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return low;\\n    }\\n    \\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        long long low = matrix[0][0] , high = matrix[n - 1][n - 1];\\n        int smallers = 0;\\n        while(low <= high){\\n            long long mid = low + (high - low)/2;\\n            smallers = 0;\\n            for(int i = 0 ; i < matrix.size() ; ++i){\\n                smallers += get_smallers(matrix[i] , mid);\\n            }\\n            if(smallers < k){\\n                low = mid + 1;    // Mid is too small to be compared, look for a larger mid so that count >= k.\\n            } else {\\n                high = mid - 1;  // Mid is too large to be compared, look for a smaller mid, so that count <= k.\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```\\n\\n**IF YOU LIKE THE SOLUTION, PLEASE UPVOTE, IT REALLY MOTIVATES :)**",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int , vector<int> , greater<int>> pq;\\n        for(int i = 0 ; i < matrix.size() ; ++i){\\n            for(int j = 0 ; j < matrix[0].size() ; ++j){\\n                pq.push(matrix[i][j]);\\n            }    \\n        }\\n        k = k - 1;\\n        while(k--){\\n            pq.pop();\\n        }\\n        return pq.top();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // Binary Search Function which returns the count of numbers smaller than target.\\n    long long get_smallers(vector<int>& numbers , long long target){\\n        long long low = 0 , high = numbers.size() - 1;\\n        while(low <= high){\\n            long long mid = low + (high - low)/2;\\n            if(numbers[mid] <= target){\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return low;\\n    }\\n    \\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        long long low = matrix[0][0] , high = matrix[n - 1][n - 1];\\n        int smallers = 0;\\n        while(low <= high){\\n            long long mid = low + (high - low)/2;\\n            smallers = 0;\\n            for(int i = 0 ; i < matrix.size() ; ++i){\\n                smallers += get_smallers(matrix[i] , mid);\\n            }\\n            if(smallers < k){\\n                low = mid + 1;    // Mid is too small to be compared, look for a larger mid so that count >= k.\\n            } else {\\n                high = mid - 1;  // Mid is too large to be compared, look for a smaller mid, so that count <= k.\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542041,
                "title": "java-heap",
                "content": "Time:  O(k * logN), where N is number of rows;\\n```\\npublic int kthSmallest(int[][] mx, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> mx[a[0]][a[1]] - mx[b[0]][b[1]]);\\n        for (int i = 0; i < mx.length; i++) {\\n            pq.offer(new int[] {i, 0});\\n        }\\n        while (k > 0) {\\n            int[] curr = pq.poll();\\n            k--;\\n            if (k == 0) return mx[curr[0]][curr[1]];\\n            if (curr[1] + 1 < mx[0].length) pq.offer(new int[] {curr[0], curr[1] + 1});\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int kthSmallest(int[][] mx, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> mx[a[0]][a[1]] - mx[b[0]][b[1]]);\\n        for (int i = 0; i < mx.length; i++) {\\n            pq.offer(new int[] {i, 0});\\n        }\\n        while (k > 0) {\\n            int[] curr = pq.poll();\\n            k--;\\n            if (k == 0) return mx[curr[0]][curr[1]];\\n            if (curr[1] + 1 < mx[0].length) pq.offer(new int[] {curr[0], curr[1] + 1});\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3252898,
                "title": "378-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo find the kth smallest element in a sorted matrix, we can use the binary search algorithm. First, we set the range of the search to be between the smallest element in the matrix and the largest element in the matrix. Then, we find the mid-point of the range and count the number of elements in the matrix that are less than or equal to the mid-point. If the count is less than k, then we know that the kth smallest element must be in the upper half of the range, so we update the range to be between the mid-point + 1 and the largest element in the matrix. If the count is greater than or equal to k, then we know that the kth smallest element must be in the lower half of the range, so we update the range to be between the smallest element in the matrix and the mid-point.\\n\\nWe repeat this process until we have narrowed down the range to a single element, which must be the kth smallest element.\\n\\n# Complexity\\n- Time complexity:\\n89.29%\\n\\n- Space complexity:\\n71.50%\\n\\n# Code\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        n = len(matrix)\\n        # Set the range of the search to be between the smallest element\\n        # and the largest element in the matrix\\n        left, right = matrix[0][0], matrix[n-1][n-1]\\n        \\n        # Binary search for the kth smallest element\\n        while left < right:\\n            mid = (left + right) // 2\\n            count = 0\\n            j = n - 1\\n            # Count the number of elements in the matrix that are less than or equal to mid\\n            for i in range(n):\\n                while j >= 0 and matrix[i][j] > mid:\\n                    j -= 1\\n                count += j + 1\\n            # Update the range of the search\\n            if count < k:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        \\n        return left\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        n = len(matrix)\\n        # Set the range of the search to be between the smallest element\\n        # and the largest element in the matrix\\n        left, right = matrix[0][0], matrix[n-1][n-1]\\n        \\n        # Binary search for the kth smallest element\\n        while left < right:\\n            mid = (left + right) // 2\\n            count = 0\\n            j = n - 1\\n            # Count the number of elements in the matrix that are less than or equal to mid\\n            for i in range(n):\\n                while j >= 0 and matrix[i][j] > mid:\\n                    j -= 1\\n                count += j + 1\\n            # Update the range of the search\\n            if count < k:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        \\n        return left\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2367234,
                "title": "python-easiest-one-liner-explained-simple-approach",
                "content": "In python, we can easily convert 2D list into 1D using ```sum(matrix, [])```\\nthis works because the ```+``` operator happens to be the concatenation operator for lists, and you\\'ve told it that the starting value is ```[]``` - an empty list.\\n\\nOne line code:\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        return sorted(sum(matrix,[]))[k-1] \\n```\\nPlease UPVOTE if you like !!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```sum(matrix, [])```\n```+```\n```[]```\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        return sorted(sum(matrix,[]))[k-1] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2367173,
                "title": "1-ms-faster-than-92-44-using-binary-search",
                "content": "***UPVOTE IF U find it useful***            \\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\tclass Solution {\\n                  public int kthSmallest(int[][] matrix, int k) {\\n                       int n = matrix.length;\\n        \\n\\t\\t\\t\\t\\t\\tint low = matrix[0][0]; // first element\\n\\t\\t\\t\\t\\t\\tint high = matrix[n-1][n-1]; // Last element\\n\\n\\t\\t\\t\\t\\t\\tint mid, temp, count;\\n\\n\\t\\t\\t\\t\\t\\twhile(low < high){\\n\\t\\t\\t\\t\\t\\t\\tmid = low + (high-low)/2;\\n\\t\\t\\t\\t\\t\\t\\ttemp = n - 1;\\n\\t\\t\\t\\t\\t\\t\\tcount = 0;\\n\\n\\t\\t\\t\\t\\t\\t\\t// For each row count the elements that are smaller than mid\\n\\t\\t\\t\\t\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\n\\t\\t\\t\\t\\t\\t\\t\\twhile(temp >= 0 && matrix[i][temp] > mid){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttemp--;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tcount+= (temp+1);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif(count < k){\\n\\t\\t\\t\\t\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\t\\thigh = mid;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn low;\\n\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n                  public int kthSmallest(int[][] matrix, int k) {\\n                       int n = matrix.length;\\n        \\n\\t\\t\\t\\t\\t\\tint low = matrix[0][0]; // first element\\n\\t\\t\\t\\t\\t\\tint high = matrix[n-1][n-1]; // Last element\\n\\n\\t\\t\\t\\t\\t\\tint mid, temp, count;\\n\\n\\t\\t\\t\\t\\t\\twhile(low < high){\\n\\t\\t\\t\\t\\t\\t\\tmid = low + (high-low)/2;\\n\\t\\t\\t\\t\\t\\t\\ttemp = n - 1;\\n\\t\\t\\t\\t\\t\\t\\tcount = 0;\\n\\n\\t\\t\\t\\t\\t\\t\\t// For each row count the elements that are smaller than mid\\n\\t\\t\\t\\t\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\n\\t\\t\\t\\t\\t\\t\\t\\twhile(temp >= 0 && matrix[i][temp] > mid){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttemp--;\\n\\t\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 85296,
                "title": "shortest-possible-solution-in-python-seriously",
                "content": "```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        return list(heapq.merge(*matrix)][k-1]\\n```\\nOk, kidding aside. This is `O(klog(n))`.\\n\\n```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        heap, res = [(row[0], r, 0) \\n                    for r, row in enumerate(matrix) \\n                    if row], 0\\n\\n        heapq.heapify(heap)\\n        for k in range(1, k + 1):\\n            res, row, col = heapq.heappop(heap)\\n            if col + 1 < len(matrix[row]):\\n                heapq.heappush(heap, (matrix[row][col + 1], row, col + 1))\\n        return res\\n```\\nThis is `O(klog(k))`\\n\\n```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        heap, res, n = [(matrix[0][0], 0, 0)], 0, len(matrix)\\n        for k in range(1, k + 1):\\n            res, row, col = heapq.heappop(heap)\\n            if not row and col < n - 1:\\n                heapq.heappush(heap, (matrix[row][col + 1], row, col + 1))\\n            if row < n - 1:\\n                heapq.heappush(heap, (matrix[row + 1][col], row + 1, col))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        return list(heapq.merge(*matrix)][k-1]\\n```\n```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        heap, res = [(row[0], r, 0) \\n                    for r, row in enumerate(matrix) \\n                    if row], 0\\n\\n        heapq.heapify(heap)\\n        for k in range(1, k + 1):\\n            res, row, col = heapq.heappop(heap)\\n            if col + 1 < len(matrix[row]):\\n                heapq.heappush(heap, (matrix[row][col + 1], row, col + 1))\\n        return res\\n```\n```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        heap, res, n = [(matrix[0][0], 0, 0)], 0, len(matrix)\\n        for k in range(1, k + 1):\\n            res, row, col = heapq.heappop(heap)\\n            if not row and col < n - 1:\\n                heapq.heappush(heap, (matrix[row][col + 1], row, col + 1))\\n            if row < n - 1:\\n                heapq.heappush(heap, (matrix[row + 1][col], row + 1, col))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248424,
                "title": "python-o-klogk",
                "content": "Time Complexity O(klogk)\\nMemory  O(k)\\n\\n```\\nimport heapq\\n\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        n = len(matrix)\\n        \\n        # cell (value, row, column)\\n        min_heap = [(matrix[0][0], 0, 0)]\\n        visited = set([0,0])\\n        \\n        \\n        kSmallest = None\\n        directions = [[1, 0], [0, 1]]\\n        \\n        for i in range(k):\\n            kSmallest, row, col = heapq.heappop(min_heap)\\n            for dx,dy in directions: \\n                r = row + dx\\n                c = col + dy \\n                if r == n or c == n or (r,c) in visited:\\n                    continue\\n                \\n                heapq.heappush(min_heap, (matrix[r][c], r, c))\\n                visited.add((r,c))\\n            \\n        return kSmallest\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        n = len(matrix)\\n        \\n        # cell (value, row, column)\\n        min_heap = [(matrix[0][0], 0, 0)]\\n        visited = set([0,0])\\n        \\n        \\n        kSmallest = None\\n        directions = [[1, 0], [0, 1]]\\n        \\n        for i in range(k):\\n            kSmallest, row, col = heapq.heappop(min_heap)\\n            for dx,dy in directions: \\n                r = row + dx\\n                c = col + dy \\n                if r == n or c == n or (r,c) in visited:\\n                    continue\\n                \\n                heapq.heappush(min_heap, (matrix[r][c], r, c))\\n                visited.add((r,c))\\n            \\n        return kSmallest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368041,
                "title": "java-1-liner",
                "content": "##### Yes, this brute force doesn\\'t work that fast\\n\\n```\\npublic int kthSmallest(int[][] matrix, int k) {\\n        return Arrays.stream(matrix).flatMapToInt(Arrays::stream).sorted().toArray()[k - 1];\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int kthSmallest(int[][] matrix, int k) {\\n        return Arrays.stream(matrix).flatMapToInt(Arrays::stream).sorted().toArray()[k - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 793702,
                "title": "evolve-from-intuition-to-optimal-a-review-of-the-solutions",
                "content": "**1. MaxHeap**\\nO(n^2log(k)). This does not use the fact that the matrix is sorted.\\n```\\n public int kthSmallest(int[][] matrix, int k) {\\n        Queue<Integer> pq=new PriorityQueue<>((a,b)->b-a);  \\n        for(int[] r:matrix)\\n            for(int n:r) {\\n                pq.add(n);\\n                if(pq.size()>k) pq.poll();\\n            }\\n        return pq.peek();\\n    }\\n```\\n**2. Merge k sorted lists**\\nO(min(n,k)+klog(min(n,k))). Build heap from array is linear. You can use make_heap in c++. In java, adding each element to priority queue is nlogn. This approach uses the fact that the first row is sorted and the columns are sorted. So something is still missing.\\n```\\n\\tpublic int kthSmallest(int[][] matrix, int k) {\\n        Queue<int[]> pq=new PriorityQueue<>((a,b)->a[0]-b[0]);  \\n        for(int i=0;i<Math.min(matrix[0].length,k);i++)\\n            pq.add(new int[]{matrix[0][i],0,i}); \\n        for(int i=1;i<k;i++) {\\n            int[] arr=pq.poll(); \\n            if(arr[1]<matrix.length-1) {\\n                pq.add(new int[]{matrix[arr[1]+1][arr[2]],arr[1]+1,arr[2]});  \\n            }\\n        }\\n        return pq.peek()[0];\\n    }\\n```\\n**3. Binary search** \\nTime complexity nlog(max-min). It is better than #2 because k could be n^2 in the worst case.\\n1) Loop invariance\\nFor x<l, rank(x)<k, for x>=r, rank(x)>=k\\nSo when l==r, x is the smallest number with rank k.\\n2) Why l exists in the matirx in the end.\\nMost binary search we can check target==mid during the search and return. But this one we cannot because the first mid we find with rank k might not exist in the matrix. Continuing the binary search finds the smallest number with rank k. For example, rank(l-1)=k-1 and rank(l)=k. If l is not in the matrix, then rank(l-1)=rank(l). So the smallest number that ranks k in the matrix must exist in the matrix.\\n3) getRank is same as 240. Search a 2D Matrix II. Now all the given conditions are used.\\n```\\npublic int kthSmallest(int[][] matrix, int k) {\\n        int l=matrix[0][0], r=matrix[matrix.length-1][matrix[0].length-1];\\n        while(l<r) {\\n            int mid=(l+r)/2;\\n            int rank=getRank(mid,matrix);\\n            if(rank<k) l=mid+1;\\n            else r=mid;\\n        }\\n        return r;\\n    }\\n    private int getRank(int num, int[][] matrix) {\\n        int rank=0, i=0, j=matrix[0].length-1;\\n        while(i<matrix.length && j>=0) {\\n            if(matrix[i][j]<=num) {\\n                rank+=j+1;\\n                i++;\\n            } else j--;\\n        }\\n        return rank;\\n    }\\n```\\n\\n**4. Some paper**\\nO(m+n). Check [StefanPochmann\\'s post](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85170/O(n)-from-paper.-Yes-O(rows).) if interested.",
                "solutionTags": [],
                "code": "```\\n public int kthSmallest(int[][] matrix, int k) {\\n        Queue<Integer> pq=new PriorityQueue<>((a,b)->b-a);  \\n        for(int[] r:matrix)\\n            for(int n:r) {\\n                pq.add(n);\\n                if(pq.size()>k) pq.poll();\\n            }\\n        return pq.peek();\\n    }\\n```\n```\\n\\tpublic int kthSmallest(int[][] matrix, int k) {\\n        Queue<int[]> pq=new PriorityQueue<>((a,b)->a[0]-b[0]);  \\n        for(int i=0;i<Math.min(matrix[0].length,k);i++)\\n            pq.add(new int[]{matrix[0][i],0,i}); \\n        for(int i=1;i<k;i++) {\\n            int[] arr=pq.poll(); \\n            if(arr[1]<matrix.length-1) {\\n                pq.add(new int[]{matrix[arr[1]+1][arr[2]],arr[1]+1,arr[2]});  \\n            }\\n        }\\n        return pq.peek()[0];\\n    }\\n```\n```\\npublic int kthSmallest(int[][] matrix, int k) {\\n        int l=matrix[0][0], r=matrix[matrix.length-1][matrix[0].length-1];\\n        while(l<r) {\\n            int mid=(l+r)/2;\\n            int rank=getRank(mid,matrix);\\n            if(rank<k) l=mid+1;\\n            else r=mid;\\n        }\\n        return r;\\n    }\\n    private int getRank(int num, int[][] matrix) {\\n        int rank=0, i=0, j=matrix[0].length-1;\\n        while(i<matrix.length && j>=0) {\\n            if(matrix[i][j]<=num) {\\n                rank+=j+1;\\n                i++;\\n            } else j--;\\n        }\\n        return rank;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85221,
                "title": "javascript-binary-search-beats-94",
                "content": "```\\nvar kthSmallest = function(matrix, k) {\\n    var n = matrix.length, lo = matrix[0][0]\\n    var hi = matrix[n-1][n-1];\\n    var mid, count;\\n    \\n    while(lo < hi) {\\n        mid = (lo + (hi - lo) / 2) >> 0;\\n        count = countLEQ(matrix, mid);\\n        if (count < k) {\\n            lo = mid + 1;\\n        } else {\\n            hi = mid;\\n        }\\n    }\\n    return lo;\\n};\\n\\nvar countLEQ = function (matrix, x) {\\n    var n = matrix.length;\\n    var count = 0;\\n    var j;\\n    \\n    matrix.forEach(function(row){\\n        for(j = 0; j < n && row[j] <= x; j++){ ;}\\n        count += j\\n    });\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nvar kthSmallest = function(matrix, k) {\\n    var n = matrix.length, lo = matrix[0][0]\\n    var hi = matrix[n-1][n-1];\\n    var mid, count;\\n    \\n    while(lo < hi) {\\n        mid = (lo + (hi - lo) / 2) >> 0;\\n        count = countLEQ(matrix, mid);\\n        if (count < k) {\\n            lo = mid + 1;\\n        } else {\\n            hi = mid;\\n        }\\n    }\\n    return lo;\\n};\\n\\nvar countLEQ = function (matrix, x) {\\n    var n = matrix.length;\\n    var count = 0;\\n    var j;\\n    \\n    matrix.forEach(function(row){\\n        for(j = 0; j < n && row[j] <= x; j++){ ;}\\n        count += j\\n    });\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 471169,
                "title": "c-solution-using-priority-queue-as-max-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue <int> pq;\\n        for(int i = 0; i < matrix.size() ;i++){\\n            for(int j = 0; j < matrix[0].size() ; j++)\\n                pq.push(matrix[i][j]);\\n        }\\n        while(pq.size()!=k)\\n            pq.pop();\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue <int> pq;\\n        for(int i = 0; i < matrix.size() ;i++){\\n            for(int j = 0; j < matrix[0].size() ; j++)\\n                pq.push(matrix[i][j]);\\n        }\\n        while(pq.size()!=k)\\n            pq.pop();\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401830,
                "title": "easy-to-understand-c-solution-36ms-beats-94",
                "content": "Runtime: 36 ms, faster than 94.29% of C++ online submissions for Kth Smallest Element in a Sorted Matrix.\\nMemory Usage: 11.9 MB, less than 100.00% of C++ online submissions for Kth Smallest Element in a Sorted Matrix.\\n\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        \\n        int n = matrix.size();\\n        int low = matrix[0][0];\\n        int high = matrix[n-1][n-1];\\n        \\n        while(low < high)\\n        {\\n            int mid = low + (high - low)/2;\\n            int place = 0;\\n            \\n            for(int i=0; i<n; i++)\\n            {\\n                place += upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();\\n            }\\n            \\n            if(k > place) low = mid+1;\\n            else high = mid;\\n        }\\n        \\n        return low;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        \\n        int n = matrix.size();\\n        int low = matrix[0][0];\\n        int high = matrix[n-1][n-1];\\n        \\n        while(low < high)\\n        {\\n            int mid = low + (high - low)/2;\\n            int place = 0;\\n            \\n            for(int i=0; i<n; i++)\\n            {\\n                place += upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 313135,
                "title": "cpp-faster-than-100-binarysearch",
                "content": "* The idea is to find the **number of elements** greater than the target.\\n* We need to minimise this number using binarySearch.\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    int countGreater(vector<vector<int>>& a, int k){\\n        int n = a.size();\\n        int count = 0;\\n        int i = 0, j = n - 1;\\n        while(i < n && j >= 0){\\n            if(a[i][j] > k) j --;\\n            else{\\n                count += j + 1;  // +1 because it\\'s zero based indexing\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\npublic:\\n    int kthSmallest(vector<vector<int>>& a, int k) {\\n        if(a.size() == 0) return -1;\\n        int result = -1;\\n        int low = a[0][0], high = a[a.size()-1][a.size()-1];\\n        while(low <= high){\\n            int mid = low + ((high - low) >> 1);\\n            if(countGreater(a, mid) >= k){\\n                result = mid;\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    int countGreater(vector<vector<int>>& a, int k){\\n        int n = a.size();\\n        int count = 0;\\n        int i = 0, j = n - 1;\\n        while(i < n && j >= 0){\\n            if(a[i][j] > k) j --;\\n            else{\\n                count += j + 1;  // +1 because it\\'s zero based indexing\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\npublic:\\n    int kthSmallest(vector<vector<int>>& a, int k) {\\n        if(a.size() == 0) return -1;\\n        int result = -1;\\n        int low = a[0][0], high = a[a.size()-1][a.size()-1];\\n        while(low <= high){\\n            int mid = low + ((high - low) >> 1);\\n            if(countGreater(a, mid) >= k){\\n                result = mid;\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366932,
                "title": "3-approaches-sorting-merge-sort-binary-search",
                "content": "[Leetcode](https://leetcode-cn.com/) [378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/).\\n\\nHere shows **3** Approaches to slove this problem: Sorting, Merge Sort, Binary Search.\\n\\n# Sorting\\n\\n```java\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        int[] array = new int[n * n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                array[i * n + j] = matrix[i][j];\\n            }\\n        }\\n\\n        Arrays.sort(array);\\n\\n        return array[k - 1];  \\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: `O(n^2logn)`\\n- **Space Complexity**: `O(n^2)`\\n\\n# Merge Sort\\n\\n```java\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);\\n\\n        for (int i = 0; i < n; i++) {\\n            pq.offer(new int[]{matrix[i][0], i, 0});\\n        }\\n\\n        for (int i = 0; i < k - 1; i++) {\\n            int[] cur = pq.poll();\\n\\n            if (cur[2] != n - 1) {\\n                pq.offer(new int[]{matrix[cur[1]][cur[2] + 1], cur[1], cur[2] + 1});\\n            }\\n        }\\n\\n        return pq.poll()[0];\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: `O(klogn)`\\n- **Space Complexity**: `O(n)`\\n\\n# Binary Search\\n\\n![image](https://assets.leetcode.com/users/images/18b54c12-4490-47fa-9698-8408de7f8e24_1659400970.8174334.png)\\n\\n\\n```java\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n\\n        int left = matrix[0][0];\\n        int right = matrix[n - 1][n - 1];\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (check(matrix, mid, k, n)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n\\n    private static boolean check(int[][] matrix, int target, int k, int n) {\\n        int i = n - 1;\\n        int j = 0;\\n        int num = 0;\\n\\n        while (i >= 0 && j < n) {\\n            if (matrix[i][j] <= target) {\\n                num += i + 1;\\n                j++;\\n            } else {\\n                i--;\\n            }\\n        }\\n        \\n        return num >= k;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: `O(nlog(r-l)`\\n- **Space Complexity**: `O(1)`\\n\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```java\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        int[] array = new int[n * n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                array[i * n + j] = matrix[i][j];\\n            }\\n        }\\n\\n        Arrays.sort(array);\\n\\n        return array[k - 1];  \\n    }\\n```\n```java\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);\\n\\n        for (int i = 0; i < n; i++) {\\n            pq.offer(new int[]{matrix[i][0], i, 0});\\n        }\\n\\n        for (int i = 0; i < k - 1; i++) {\\n            int[] cur = pq.poll();\\n\\n            if (cur[2] != n - 1) {\\n                pq.offer(new int[]{matrix[cur[1]][cur[2] + 1], cur[1], cur[2] + 1});\\n            }\\n        }\\n\\n        return pq.poll()[0];\\n    }\\n```\n```java\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n\\n        int left = matrix[0][0];\\n        int right = matrix[n - 1][n - 1];\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (check(matrix, mid, k, n)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return left;\\n    }\\n\\n    private static boolean check(int[][] matrix, int target, int k, int n) {\\n        int i = n - 1;\\n        int j = 0;\\n        int num = 0;\\n\\n        while (i >= 0 && j < n) {\\n            if (matrix[i][j] <= target) {\\n                num += i + 1;\\n                j++;\\n            } else {\\n                i--;\\n            }\\n        }\\n        \\n        return num >= k;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2233868,
                "title": "simple-yet-best-interview-code-python-code-beats-90",
                "content": "![image](https://assets.leetcode.com/users/images/5cb6c6a9-e9c5-4f44-b97b-7f888b6dd204_1656876943.667779.png)\\n\\n\\n# Kth smallest number\\'s unique property:\\n**There are total K numbers in matrix that are less than Kth number**\\n\\n* Also realize that the count of elements less than ith element is a monotonic property for a sorted array and sorted matrix\\n\\n* As monotonicity is found we can use Binary Search\\n\\n* Min value Kth element can have is when K = 0 or low = matrix[0][0]\\n\\n* Max value Kth element can have is when K = n * n or low = matrix[n-1][n-1]\\n\\n* Now we will run a binary search and for each mid (m) value we will find it\\'s count, which got easy as matrix is sorted\\n\\n* Understand that m can be element which is not present in matrix but it will not affect our logic\\n\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        def count(m):\\n            c = 0                   # count of element less than equals to \\'m\\'\\n            i = n-1\\n            j = 0\\n            \\n            while i >= 0 and j < n:\\n                if matrix[i][j] > m:\\n                    i -= 1\\n                else:\\n                    c += i+1\\n                    j += 1\\n            return c\\n           \\n        \\n        low = matrix[0][0]\\n        high = matrix[n-1][n-1]\\n        \\n        while low <= high:\\n            m = (low+high)//2\\n            cnt = count(m)\\n            if cnt < k:\\n                low = m + 1\\n            else:\\n                cnt1 = count(m-1)\\n                if cnt1 < k:\\n                    return m\\n                high = m-1\\n        return 0\\n    \\n```\\nFor log(max-min) elements we will perform count in Matrix which is O(N)\\n**Time Complexity: O( Nlog(max-min) * log(max-min) )**\\n**Space Complexity: O(1)**\\n\\n***If there is any error in explanation, time-complexity analysis, please mention below and I will make update***\\n\\n***I hope this explanation was helpful, please make sure to UPVOTE so that it can rank higher in discussion***\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])\\n        \\n        def count(m):\\n            c = 0                   # count of element less than equals to \\'m\\'\\n            i = n-1\\n            j = 0\\n            \\n            while i >= 0 and j < n:\\n                if matrix[i][j] > m:\\n                    i -= 1\\n                else:\\n                    c += i+1\\n                    j += 1\\n            return c\\n           \\n        \\n        low = matrix[0][0]\\n        high = matrix[n-1][n-1]\\n        \\n        while low <= high:\\n            m = (low+high)//2\\n            cnt = count(m)\\n            if cnt < k:\\n                low = m + 1\\n            else:\\n                cnt1 = count(m-1)\\n                if cnt1 < k:\\n                    return m\\n                high = m-1\\n        return 0\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883726,
                "title": "javascript-max-heap-solution",
                "content": "```\\nconst kthSmallest = function(matrix, k) {\\n    const q = new MaxPriorityQueue();\\n    \\n    for(let i = 0; i < matrix.length; i++)\\n        for(let j = 0; j < matrix.length; j++){\\n            q.enqueue(matrix[i][j]);\\n            if(q.size() > k) q.dequeue();\\n        }\\n\\n    return q.front().element;\\n};\\n```\\nNote that **MaxPriorityQueue** is already included in Leetcode\\'s js environment:\\nhttps://support.leetcode.com/hc/en-us/articles/360011833974-What-are-the-environments-for-the-programming-languages-",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nconst kthSmallest = function(matrix, k) {\\n    const q = new MaxPriorityQueue();\\n    \\n    for(let i = 0; i < matrix.length; i++)\\n        for(let j = 0; j < matrix.length; j++){\\n            q.enqueue(matrix[i][j]);\\n            if(q.size() > k) q.dequeue();\\n        }\\n\\n    return q.front().element;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822363,
                "title": "multiple-approches-c-with-explanation",
                "content": "**Approach1: Brute Force**\\nPut all elements in an array of size n^2. Sort it and return kth element in the array.\\nTC: (n^2 logn) [Sorting]\\nSC: (n^2)\\n\\n**Approach2: Using Heap.**\\nBuild heap of n elements and perform min heapify k times. Put all the values in first row in a min heap. Now, extract the min element and put the greater value (element present in same column and next row) in the heap. We\\'ll do this k times. And, the element extracted from heap kth time will be the answer. \\n\\nTC: O(n + klogn) [Build heap of n elements, and perform min heapify operation k times]\\nSC: O(n) [Heap of size n]\\n\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int val;\\n        priority_queue<pair<int, pair<int,int>>, vector<pair<int, pair<int,int>>>, greater<pair<int, pair<int,int>>>> pq;\\n        \\n        for(int j=0;j<matrix.size();j++) \\n            pq.push({matrix[0][j], {0, j}});\\n        \\n        for(int i=0;i<k;i++) {\\n            int x, y;\\n            val = pq.top().first;\\n            x = pq.top().second.first;\\n            y = pq.top().second.second;\\n            pq.pop();\\n            \\n            if(x < matrix.size()-1)\\n                pq.push({matrix[x+1][y], {x+1, y}});\\n        }\\n        return val;\\n    }\\n};\\n```\\n\\n**Approach3: Binary Search**\\nThe ans will lie between marix[0][0] & matrix[n-1][n-1]. Do binary search on this range. For every mid value, we find the number of elements (say, count) that are lesser or equal to that value, and search in left or right half accordingly.\\n\\nTC: O(log(y-x) * nlogn) where y and x are largest and smallest elements in matrix [Binary search, and find count]\\nSC: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size(), l = matrix[0][0], r = matrix[n-1][n-1];\\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            int count = smallerOrEqualElements(matrix, mid);\\n            if(count >= k)\\n                r = mid - 1;\\n            else \\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n    \\n    int smallerOrEqualElements(vector<vector<int>>& matrix, int val) {\\n        int ans = 0;\\n        for(int i=0;i<matrix.size();i++) { //Check number of smaller or equal elements for each row\\n            if(val < matrix[i][0])\\n                return ans;\\n            ans += upper_bound(matrix[i].begin(), matrix[i].end(), val) - matrix[i].begin();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**Please Upvote!!**",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int val;\\n        priority_queue<pair<int, pair<int,int>>, vector<pair<int, pair<int,int>>>, greater<pair<int, pair<int,int>>>> pq;\\n        \\n        for(int j=0;j<matrix.size();j++) \\n            pq.push({matrix[0][j], {0, j}});\\n        \\n        for(int i=0;i<k;i++) {\\n            int x, y;\\n            val = pq.top().first;\\n            x = pq.top().second.first;\\n            y = pq.top().second.second;\\n            pq.pop();\\n            \\n            if(x < matrix.size()-1)\\n                pq.push({matrix[x+1][y], {x+1, y}});\\n        }\\n        return val;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size(), l = matrix[0][0], r = matrix[n-1][n-1];\\n        while(l <= r) {\\n            int mid = (l + r)/2;\\n            int count = smallerOrEqualElements(matrix, mid);\\n            if(count >= k)\\n                r = mid - 1;\\n            else \\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n    \\n    int smallerOrEqualElements(vector<vector<int>>& matrix, int val) {\\n        int ans = 0;\\n        for(int i=0;i<matrix.size();i++) { //Check number of smaller or equal elements for each row\\n            if(val < matrix[i][0])\\n                return ans;\\n            ans += upper_bound(matrix[i].begin(), matrix[i].end(), val) - matrix[i].begin();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265079,
                "title": "easy-java-5-lines-of-code-simple",
                "content": "```\\npublic int kthSmallest(int[][] matrix, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(int i=0; i< matrix.length; i++){\\n            for(int j=0; j< matrix[0].length; j++){\\n                pq.add(matrix[i][j]);\\n            }\\n        }\\n        while(k-- > 1) pq.poll();\\n        return pq.poll();\\n    }\\n\\t\\nIf you like it please upvote!",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int kthSmallest(int[][] matrix, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(int i=0; i< matrix.length; i++){\\n            for(int j=0; j< matrix[0].length; j++){\\n                pq.add(matrix[i][j]);\\n            }\\n        }\\n        while(k-- > 1) pq.poll();\\n        return pq.poll();\\n    }\\n\\t\\nIf you like it please upvote!",
                "codeTag": "Unknown"
            },
            {
                "id": 820682,
                "title": "python-heap-solution-o-n-klogn",
                "content": "The idea is to put each row in a min heap prioritized by the element. Then get the lowest k amount of times.\\n\\n```\\nclass Solution:\\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\\n        N = len(mat)\\n        min_heap = []\\n        for i in range(N):\\n            heappush(min_heap, (mat[i][0], 0, mat[i][:]))\\n            \\n        while k > 0:\\n            k -= 1\\n            number, i, row = heappop(min_heap)\\n            if i + 1 < N:\\n                heappush(min_heap, (row[i+1], i+1, row))\\n            \\n        return number\\n```\\n\\nIt\\'s not as fancy as some like from [this paper](http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf) posted by stefan [here](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85170/O(n)-from-paper.-Yes-O(rows).), but none of those seem attainable without prior knowledge in a 45min interview.\\n\\nYou can also use this technique for [merge k sorted lists](https://leetcode.com/problems/merge-k-sorted-lists/)",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, mat: List[List[int]], k: int) -> int:\\n        N = len(mat)\\n        min_heap = []\\n        for i in range(N):\\n            heappush(min_heap, (mat[i][0], 0, mat[i][:]))\\n            \\n        while k > 0:\\n            k -= 1\\n            number, i, row = heappop(min_heap)\\n            if i + 1 < N:\\n                heappush(min_heap, (row[i+1], i+1, row))\\n            \\n        return number\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759388,
                "title": "c-binary-search-time-complexity-o-nlog-max-min",
                "content": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int left = matrix[0][0];\\n        int right = matrix[n - 1][n - 1];\\n        \\n        while (left < right) {\\n            int middle = (left + right) / 2;\\n            int count = 0;\\n            int row = n - 1;\\n            int col = 0;\\n            \\n            while (col < n and row >= 0) {\\n                if (matrix[row][col] <= middle) {\\n                    count += row + 1;\\n                    col += 1;\\n                }\\n                else {\\n                    row -= 1;\\n                }\\n            }\\n            \\n            if (count < k) left = middle + 1;\\n            else right = middle;\\n        }\\n        \\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int left = matrix[0][0];\\n        int right = matrix[n - 1][n - 1];\\n        \\n        while (left < right) {\\n            int middle = (left + right) / 2;\\n            int count = 0;\\n            int row = n - 1;\\n            int col = 0;\\n            \\n            while (col < n and row >= 0) {\\n                if (matrix[row][col] <= middle) {\\n                    count += row + 1;\\n                    col += 1;\\n                }\\n                else {\\n                    row -= 1;\\n                }\\n            }\\n            \\n            if (count < k) left = middle + 1;\\n            else right = middle;\\n        }\\n        \\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350112,
                "title": "python-binary-search-and-min-heap",
                "content": "## 1. Binary Search\\n```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        def findOrd(matrix, val):\\n            order = 0\\n            for row in matrix:\\n                for col in row:\\n                    if col <= val: order += 1\\n            return order\\n        \\n        l, r = matrix[0][0], matrix[-1][-1]\\n        while l < r:\\n            mid = (l + r) // 2\\n            order = findOrd(matrix, mid)\\n            if order >= k:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n```\\n\\n## 2. Min Heap\\n```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        import heapq\\n        vals = [val for row in matrix for val in row]\\n        heapq.heapify(vals)\\n        for _ in range(k):\\n            ans = heapq.heappop(vals)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        def findOrd(matrix, val):\\n            order = 0\\n            for row in matrix:\\n                for col in row:\\n                    if col <= val: order += 1\\n            return order\\n        \\n        l, r = matrix[0][0], matrix[-1][-1]\\n        while l < r:\\n            mid = (l + r) // 2\\n            order = findOrd(matrix, mid)\\n            if order >= k:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n```\n```\\nclass Solution(object):\\n    def kthSmallest(self, matrix, k):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        import heapq\\n        vals = [val for row in matrix for val in row]\\n        heapq.heapify(vals)\\n        for _ in range(k):\\n            ans = heapq.heappop(vals)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691334,
                "title": "binary-search-fully-explained-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the matrix is sorted, there comes the intuition of Binary Search.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. In binary search, the minimum element possible is the 1st element of the matrix, store it in left.\\nMaximum element possible is the last element of the matrix, store it in right.\\n\\n2. Find the mid element.\\nNow count the number of elements less than or equal to \\'k\\' in each row.\\nHow to do this?\\nUse upper_bound in each row, now since upper bound gives address of just bigger element, we\\'ll subtract the initial index of that particular row, so we\\'ll get the number of elements less than equal to k in that particular row.\\n\\n3. For ex: [[1,5,9],[10,11,13],[12,13,15]], k = 8\\n- applying upper_bound in first row: here, mid = (1 + 15)/2 = 8\\nwe get address of 9, which is 2.\\nNow subtract the initial index of this particular row from 2 i.e, 2 - 0 = 2 elements less than of equal to 8.\\n- applying upper_bound in second row:\\nwe get address of 10, which is 0.\\nNow subtract 0 from 0 i.e. 0 - 0 = 0 elements less than or equal to 8.\\n- applying upper_bound in third row:\\nwe get address of 12, which is 0.\\nNow subtract 0 from 0 i.e. 0 - 0 = 0 elements less than or equal to 8.\\n4. In total we get 2 + 0 + 0 = 2 elements less than equal to 8, so mid = 8 is not the feasible answer, as we need minimum 8 elements less than equal to mid.\\n5.  Since 2 < 8, so we\\'ll make left as mid + 1 and continue the same process.\\n\\n# Complexity\\n- Time complexity: **O(n logn logn)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        //Using BINARY SEARCH\\n\\n        int left = matrix[0][0], right = matrix[row - 1][col - 1];\\n\\n        while(left <= right)\\n        {\\n            int mid = left + (right - left)/2;\\n\\n            int cnt = 0;\\n            for(int i = 0; i < col; i++)\\n            {\\n                cnt += upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin(); \\n            }\\n\\n            if(cnt < k) left = mid + 1;\\n            else right =  mid - 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        //Using BINARY SEARCH\\n\\n        int left = matrix[0][0], right = matrix[row - 1][col - 1];\\n\\n        while(left <= right)\\n        {\\n            int mid = left + (right - left)/2;\\n\\n            int cnt = 0;\\n            for(int i = 0; i < col; i++)\\n            {\\n                cnt += upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin(); \\n            }\\n\\n            if(cnt < k) left = mid + 1;\\n            else right =  mid - 1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298138,
                "title": "easy-to-understand-soln-in-java-using-binary-search-and-optimized-counting-and-heap-similar-ques",
                "content": "# Intuition using Priority queue\\nWe are maintaining a max heap of size k. whenever it is exceeding size k we are polling the top element which is the max element.this way in the end we will be left with only k elements and and we will return it will give us the max of all k elements which is the kth largest.\\n\\n# Approach 1 using Priority queue (Not preferred)\\nIn this approach we will use a maxHeap of size k. The algorithm is as follows:\\n1. Traverse over all the elements in O(n^2) time and add it to the priority queue. if the size of the max heap exceeds k. poll the element from the maxHeap.\\n2. return the top element of the maxheap once the traversal is done.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2log(k))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) (max value of k can be n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n```\\nclass Solution {\\n    // TC : O(n^2logk)\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length+matrix[0].length;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i=0;i<matrix.length;i++)\\n            for(int j=0;j<matrix[0].length;j++)\\n            {\\n                \\n                pq.add(matrix[i][j]);\\n                if(pq.size()>k)\\n                    pq.poll();\\n\\n            }\\n            return pq.poll();\\n    }\\n}\\n```\\n# Intuition 2 using binary search and optimized counting\\nWe know that the kth largest number will lie somewhere in between the top left element and bottom right element. we will take the two numbers.\\nwe can omit a large portion of the array each time using the binary search. \\n\\n# Approach 2 using binary search and optimized counting\\nIn this approach we will take the smallest and biggest element of the matrix and perform binary search each time with some some special operation other than just searching.\\nwe will count the number of elements smaller than or equal to mid each time instead of just equating in normal binary search.\\n**The algorithm for binary search is as follows:**\\n1. take the smallest element of matrix as low and highest as high.\\n2. find the mid of the low and high and count the number of elements smaller then or equal to it in the matrix using the optimized counting approach in \\nO(n+n) time.\\n    ****if(the count of smaller elements is greater than or equal to k):****\\n        then we need to shorten out search and move towards left side on the range:: high =mid-1\\n\\n    ****else:****\\n        shorten the search and move to right part :: low=mid+1 \\n\\nONE OBVIOUS QUESTION:\\nif we get count of smaller or equal element   in matrix equal to k then why dont we stop.\\nBeacuse we wan to find the value which exists in the matrix.\\n\\n****we are considering the range between the smallest and the highest element in the matrix. ****\\n\\n\\n**The algorithm for optimized counting of elements in matrix smaller than or equal to mid is as follows:**\\nWe know that the matrix is sorted in row wise and column wise. \\nhence,\\n1. all the elements to the bottom of an element is bigger than the element \\n2.  all the elements to the right of the array will also be bigger than the element\\nwe will use this concept to get the count number of smaller and equal to elements in the matrix in O(n+n)time.\\n\\nThe algorithm is as follows :\\n1. start from the top right element of the matrix.\\n    if (it is smaller than mid): \\n    {\\n        then move to next row(r++);\\n        count all the elements of the row skipped(count =count+c+1) [0 based index hence add 1]\\n    }   \\n    else:\\n    {\\n        move to left unless an element less than k is found(\\n            while(c>=0 && matrix[r][c]>mid)\\n                c--;\\n        )\\n        count all the elements (count=count+c+1;)\\n        move to the next row; (r++)\\n    }\\n\\n> Refer this question for more information and more detailed thought process:\\n 74. Search a 2D Matrix: https://leetcode.com/problems/search-a-2d-matrix/solutions/3290096/easy-to-understand-solution-in-java-using-both-the-approaches-binary-search-optimized-brute-force/ \\n\\nTO GET A BETTER UNDERSTANDING DRY RUN IT ON THE MATRIX:\\n1  5  9 \\n7  11 13\\n12 13 15\\ncount all elements in the matrix less than 8.\\nmid=8 ans to be 4.\\nif k=13 ans to be 8\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nOptimised counting required at max traversal of equal to sum of rows and columns O(n+n)\\n- Time complexity: O(log(width of binary search)*O(count))\\n-                   O(n*log(max-min))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] matrix;\\n    int n;\\n    public int kthSmallest(int[][] matrix, int k) {\\n        this.matrix=matrix;\\n        n = matrix.length;\\n        int low = matrix[0][0];\\n        int high = matrix[n-1][n-1];\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            int mid = low+(high-low)/2;\\n            if(count(mid)>=k)\\n            {\\n                ans=mid;\\n                high =mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int count(int mid)\\n    {\\n        int r=0;\\n        int c=n-1;\\n        int count=0;\\n        while(r<n && c>=0)\\n        {\\n            if(matrix[r][c]<mid)\\n            {\\n                r++;\\n                count=count+1+c;\\n            }\\n            else\\n            {\\n                while(c>=0 && matrix[r][c]>mid)\\n                    c--;\\n                count=count+c+1;\\n                r++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n}\\n```\\n\\n\\n# SIMILAR QUESTIONS:\\n\\n378  Kth Smallest Element in a Sorted Matrix: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/solutions/3298138/easy-to-understand-solution-in-java-using-2approaches-binary-search-and-optimized-counting-and-heap/ \\n\\n668  Kth Smallest Number in Multiplication Table:  https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/solutions/3298180/easy-to-understand-solution-in-java-using-binary-search-and-optimized-count-algorithm/?orderBy=most_votes\\n\\n719 . Find K-th Smallest Pair Distance: https://leetcode.com/problems/find-k-th-smallest-pair-distance/solutions/3300407/easy-to-understand-solution-in-java-using-binary-search-and-optimized-counting/?orderBy=most_votes\\n\\n875 . Koko Eating Bananas:  https://leetcode.com/problems/koko-eating-bananas/solutions/3302099/easy-to-understand-solution-in-java-using-binary-search-and-optimized-counting/?orderBy=most_votes\\n\\n1011 . Capacity To Ship Packages Within D Days: https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/solutions/3302089/easy-to-understand-solution-in-java-using-binary-search-and-optimized-counting-approach/\\n\\n1283 . Find the Smallest Divisor Given a Threshold:\\nhttps://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/solutions/3783267/easy-to-understand-solution-in-java-using-binary-search-with-similar-questions/\\n\\n1482 . Minimum Number of Days to Make m Bouquets:\\nhttps://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/solutions/3312484/easy-to-understand-solution-in-java-using-binary-search-and-optimized-counting-approach/\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    // TC : O(n^2logk)\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length+matrix[0].length;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i=0;i<matrix.length;i++)\\n            for(int j=0;j<matrix[0].length;j++)\\n            {\\n                \\n                pq.add(matrix[i][j]);\\n                if(pq.size()>k)\\n                    pq.poll();\\n\\n            }\\n            return pq.poll();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[][] matrix;\\n    int n;\\n    public int kthSmallest(int[][] matrix, int k) {\\n        this.matrix=matrix;\\n        n = matrix.length;\\n        int low = matrix[0][0];\\n        int high = matrix[n-1][n-1];\\n        int ans=0;\\n        while(low<=high)\\n        {\\n            int mid = low+(high-low)/2;\\n            if(count(mid)>=k)\\n            {\\n                ans=mid;\\n                high =mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int count(int mid)\\n    {\\n        int r=0;\\n        int c=n-1;\\n        int count=0;\\n        while(r<n && c>=0)\\n        {\\n            if(matrix[r][c]<mid)\\n            {\\n                r++;\\n                count=count+1+c;\\n            }\\n            else\\n            {\\n                while(c>=0 && matrix[r][c]>mid)\\n                    c--;\\n                count=count+c+1;\\n                r++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2367079,
                "title": "12-ms-faster-than-96-99-of-c-online-submissions-for-kth-smallest-element-in-a-sorted-matrix",
                "content": "# **[@iprincekumark](https://leetcode.com/iprincekumark/)**\\nVISIT MY PROFILE \\n## Explanation Video -\\n\\n[Kth Smallest Element in a Sorted Matrix](https://www.youtube.com/watch?v=xsqUgiqRkSI)\\n\\n# CODE :\\n```\\nint kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int> pq;\\n        for(int i=0; i<matrix.size(); i++) {\\n            for(int j=0; j<matrix[0].size(); j++) {\\n                pq.push(matrix[i][j]);\\n                if(pq.size() > k)\\n                    pq.pop();\\n            }\\n        }\\n        return pq.top();\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int> pq;\\n        for(int i=0; i<matrix.size(); i++) {\\n            for(int j=0; j<matrix[0].size(); j++) {\\n                pq.push(matrix[i][j]);\\n                if(pq.size() > k)\\n                    pq.pop();\\n            }\\n        }\\n        return pq.top();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2028235,
                "title": "c-priority-queue-simple-solution",
                "content": "**C++ Simple Solution Using piority_queue**\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        priority_queue<int> p;\\n        // We Will Push k elements in priority queue\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(k>0)  //  pushing k elements\\n                    p.push(matrix[i][j]),k--;\\n                \\n                // If next element is smaller than top() of priority_queue\\n                // then we will pop() top element and push next element;\\n                else if(p.top()>matrix[i][j]) \\n\\t\\t\\t\\t\\tp.pop(),p.push(matrix[i][j]);\\n            \\n                // Else if top() element of priority queue is smaller than next element.\\n                // Then we will break this loop because in this row next all elements will be greater.\\n                else \\n                    break;\\n            }\\n        }\\n        return p.top();\\n    }\\n};\\n```\\n**If You Find it Hepful Kindly UPVOTE**",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        priority_queue<int> p;\\n        // We Will Push k elements in priority queue\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(k>0)  //  pushing k elements\\n                    p.push(matrix[i][j]),k--;\\n                \\n                // If next element is smaller than top() of priority_queue\\n                // then we will pop() top element and push next element;\\n                else if(p.top()>matrix[i][j]) \\n\\t\\t\\t\\t\\tp.pop(),p.push(matrix[i][j]);\\n            \\n                // Else if top() element of priority queue is smaller than next element.\\n                // Then we will break this loop because in this row next all elements will be greater.\\n                else \\n                    break;\\n            }\\n        }\\n        return p.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774396,
                "title": "c-solution-using-binary-search-faster-than-99",
                "content": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& a, int k) {\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        int start = a[0][0];\\n        int end = a[rows-1][cols-1];\\n        while(start<end) {\\n            int mid = (start+end)/2;\\n            int j = cols-1;\\n            int cnt = 0;\\n            for (int i = 0; i<rows; i++) {\\n                while(j>=0 and a[i][j] > mid) {\\n                    j--;\\n                }\\n                cnt += (j+1);\\n            }\\n            if (cnt < k) {\\n                start = mid+1;\\n            }\\n            else {\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& a, int k) {\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        int start = a[0][0];\\n        int end = a[rows-1][cols-1];\\n        while(start<end) {\\n            int mid = (start+end)/2;\\n            int j = cols-1;\\n            int cnt = 0;\\n            for (int i = 0; i<rows; i++) {\\n                while(j>=0 and a[i][j] > mid) {\\n                    j--;\\n                }\\n                cnt += (j+1);\\n            }\\n            if (cnt < k) {\\n                start = mid+1;\\n            }\\n            else {\\n                end = mid;\\n            }\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412502,
                "title": "simple-binary-search-solution-for-slow-learners-like-myself",
                "content": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 \\n           || matrix[0] == null || matrix[0].length == 0)\\n            return -1;\\n        \\n        int m = matrix.length, n = matrix[0].length;\\n        int left = matrix[0][0], right = matrix[m - 1][n - 1];\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2, count = getCountLessThanOrEqualToTarget(matrix, mid);\\n            if (count < k)\\n                left = mid + 1; //we have not met our quota k so expand our search space\\n            else\\n                right = mid;\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private int getCountLessThanOrEqualToTarget(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length, count = 0, j = n - 1;\\n        for (int i = 0; i < m; i++) {\\n            while (j >= 0 && matrix[i][j] > target)\\n                j--;\\n            count += j + 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if (matrix == null || matrix.length == 0 \\n           || matrix[0] == null || matrix[0].length == 0)\\n            return -1;\\n        \\n        int m = matrix.length, n = matrix[0].length;\\n        int left = matrix[0][0], right = matrix[m - 1][n - 1];\\n        \\n        while (left < right) {\\n            int mid = left + (right - left) / 2, count = getCountLessThanOrEqualToTarget(matrix, mid);\\n            if (count < k)\\n                left = mid + 1; //we have not met our quota k so expand our search space\\n            else\\n                right = mid;\\n        }\\n        \\n        return left;\\n    }\\n    \\n    private int getCountLessThanOrEqualToTarget(int[][] matrix, int target) {\\n        int m = matrix.length, n = matrix[0].length, count = 0, j = n - 1;\\n        for (int i = 0; i < m; i++) {\\n            while (j >= 0 && matrix[i][j] > target)\\n                j--;\\n            count += j + 1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85200,
                "title": "my-clean-clear-java-solution",
                "content": "public class Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        \\n        PriorityQueue<Integer> pq= new PriorityQueue(k, Collections.reverseOrder());\\n        \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(pq.size()<k)\\n                    pq.add(matrix[i][j]);\\n                else{\\n                    int temp=pq.peek();\\n                    if(temp>matrix[i][j]){\\n                        pq.poll();\\n                        pq.offer(matrix[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return pq.poll();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        \\n        PriorityQueue<Integer> pq= new PriorityQueue(k, Collections.reverseOrder());\\n        \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(pq.size()<k)\\n                    pq.add(matrix[i][j]);\\n                else{\\n                    int temp=pq.peek();\\n                    if(temp>matrix[i][j]){\\n                        pq.poll();\\n                        pq.offer(matrix[i][j]);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3489170,
                "title": "c-solution-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        vector<int> elements;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                elements.push_back(matrix[i][j]);\\n            }\\n        }\\n        if (elements.size() < k) {\\n            return -1;\\n        }\\n        sort(elements.begin(), elements.end());\\n        return elements[k-1];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        vector<int> elements;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                elements.push_back(matrix[i][j]);\\n            }\\n        }\\n        if (elements.size() < k) {\\n            return -1;\\n        }\\n        sort(elements.begin(), elements.end());\\n        return elements[k-1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378200,
                "title": "1-ms-java-easiest-solution",
                "content": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n    int n = matrix.length;\\n \\n    int lower = matrix[0][0];\\n    int upper = matrix[n-1][n-1];\\n \\n    while(lower<upper){\\n        int mid = lower + ((upper-lower)>>1);\\n        int count = count(matrix, mid);\\n        if(count<k){\\n            lower=mid+1;\\n        }else{\\n            upper=mid;\\n        }\\n    }\\n \\n    return upper;\\n}\\n \\nprivate int count(int[][] matrix, int target){\\n    int m=matrix.length;\\n    int i=m-1;\\n    int j=0;\\n    int count = 0;\\n \\n    while(i>=0&&j<m){\\n        if(matrix[i][j]<=target){\\n            count += i+1;\\n            j++;\\n        }else{\\n            i--;\\n        }\\n    }\\n \\n    return count;\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n    int n = matrix.length;\\n \\n    int lower = matrix[0][0];\\n    int upper = matrix[n-1][n-1];\\n \\n    while(lower<upper){\\n        int mid = lower + ((upper-lower)>>1);\\n        int count = count(matrix, mid);\\n        if(count<k){\\n            lower=mid+1;\\n        }else{\\n            upper=mid;\\n        }\\n    }\\n \\n    return upper;\\n}\\n \\nprivate int count(int[][] matrix, int target){\\n    int m=matrix.length;\\n    int i=m-1;\\n    int j=0;\\n    int count = 0;\\n \\n    while(i>=0&&j<m){\\n        if(matrix[i][j]<=target){\\n            count += i+1;\\n            j++;\\n        }else{\\n            i--;\\n        }\\n    }\\n \\n    return count;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2367482,
                "title": "c-o-1-memory-space-binary-search-easy-solution-without-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& arr, int k) {\\n        \\n        int n = arr.size();\\n        int l = arr[0][0],r = arr[n-1][n-1],ans = 0;\\n        while(l <= r){\\n            int mid = (l+r)/2;\\n            int cnt = 0;\\n            for(int i = 0;i < n;i++){\\n                auto it = upper_bound(arr[i].begin(), arr[i].end(), mid); // counting elements less than equal to mid\\n                cnt += (it - arr[i].begin());\\n            }\\n            if(cnt >= k){ // if number of elements smaller than/ equal to are greater than equal to k, then mid can be our answer\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& arr, int k) {\\n        \\n        int n = arr.size();\\n        int l = arr[0][0],r = arr[n-1][n-1],ans = 0;\\n        while(l <= r){\\n            int mid = (l+r)/2;\\n            int cnt = 0;\\n            for(int i = 0;i < n;i++){\\n                auto it = upper_bound(arr[i].begin(), arr[i].end(), mid); // counting elements less than equal to mid\\n                cnt += (it - arr[i].begin());\\n            }\\n            if(cnt >= k){ // if number of elements smaller than/ equal to are greater than equal to k, then mid can be our answer\\n                ans = mid;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366991,
                "title": "whenever-you-see-a-k-problem-recall-thy-h-e-a-p",
                "content": "```\\nclass Solution:\\n    def kthSmallest(self, matrix, k: int) -> int:\\n        min_heap = []\\n        for row in range(len(matrix)):\\n            for col in range(len(matrix[0])):\\n                heapq.heappush(min_heap, matrix[row][col])\\n        for _ in range(k-1):\\n            heapq.heappop(min_heap)\\n        \\n        return min_heap[0]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, matrix, k: int) -> int:\\n        min_heap = []\\n        for row in range(len(matrix)):\\n            for col in range(len(matrix[0])):\\n                heapq.heappush(min_heap, matrix[row][col])\\n        for _ in range(k-1):\\n            heapq.heappop(min_heap)\\n        \\n        return min_heap[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366874,
                "title": "daily-leetcoding-challenge-august-day-2",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Min-Heap approach\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2195145,
                "title": "c-easy-solution-optimal-and-best-approach-both-o-1-space-complexity",
                "content": "**Please Upvote the solution if it helped you because a single upvote motivate the creator\\'s like us to create more content..........**\\n\\nApproach 1->\\nO(n) Space Complexity\\n\\nCode->\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        // O(k) SPACE COMPLEXITY\\n        //Heap Apporach\\n        priority_queue<int> pq;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                pq.push(matrix[i][j]);\\n                if(pq.size()>k)\\n                    pq.pop();\\n            }\\n        }\\n        return pq.top();\\n    }\\n};\\n```\\n\\nApproach 2->\\nO(1) Space Complexity\\nCode->\\n\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int low=matrix[0][0];\\n        int high=matrix[n-1][n-1];\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            int count=0;\\n            for(int i=0;i<n;i++){\\n                count+=upper_bound(matrix[i].begin(),matrix[i].end(),mid)-matrix[i].begin();\\n            }\\n            if(count<k)\\n                low=mid+1;\\n            else\\n                high=mid;\\n            \\n        }\\n        return low;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        // O(k) SPACE COMPLEXITY\\n        //Heap Apporach\\n        priority_queue<int> pq;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                pq.push(matrix[i][j]);\\n                if(pq.size()>k)\\n                    pq.pop();\\n            }\\n        }\\n        return pq.top();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int low=matrix[0][0];\\n        int high=matrix[n-1][n-1];\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            int count=0;\\n            for(int i=0;i<n;i++){\\n                count+=upper_bound(matrix[i].begin(),matrix[i].end(),mid)-matrix[i].begin();\\n            }\\n            if(count<k)\\n                low=mid+1;\\n            else\\n                high=mid;\\n            \\n        }\\n        return low;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970533,
                "title": "c-sortedset-with-tuple-as-min-heap-pq",
                "content": "```\\npublic class Solution {\\n    public int KthSmallest(int[][] M, int k) {\\n            if(M.Length==0) return 0;                    \\n            var rows = M.Length;\\n            var cols = M[0].Length;\\n            var set = new SortedSet<(int val, int row, int col)>();\\n            var ans = 0;\\n            for (int i = 0; i < rows; i++)\\n                set.Add((M[i][0], i, 0)); // add each row first col\\n        \\n            while (k > 0){\\n                var min= set.Min; // Min Heap if you Max it will be Max Heap ... C# PQ ->SortedSet with Tuple.\\n                var key = min.val;\\n                var row = min.row;\\n                var col = min.col;\\n                ans=key;\\n                set.Remove(min);\\n                if (col < cols - 1)\\n                    set.Add((M[row][col+1],row,col+1)); // next col;                    \\n                k--;\\n            }\\n            return ans;\\n    }\\n      \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int KthSmallest(int[][] M, int k) {\\n            if(M.Length==0) return 0;                    \\n            var rows = M.Length;\\n            var cols = M[0].Length;\\n            var set = new SortedSet<(int val, int row, int col)>();\\n            var ans = 0;\\n            for (int i = 0; i < rows; i++)\\n                set.Add((M[i][0], i, 0)); // add each row first col\\n        \\n            while (k > 0){\\n                var min= set.Min; // Min Heap if you Max it will be Max Heap ... C# PQ ->SortedSet with Tuple.\\n                var key = min.val;\\n                var row = min.row;\\n                var col = min.col;\\n                ans=key;\\n                set.Remove(min);\\n                if (col < cols - 1)\\n                    set.Add((M[row][col+1],row,col+1)); // next col;                    \\n                k--;\\n            }\\n            return ans;\\n    }\\n      \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320506,
                "title": "c-using-priority-queue",
                "content": "\\n\\tint kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        if(n==0){\\n            return 0;\\n        }\\n        priority_queue<int> q;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(q.size()<k){\\n                    q.push(matrix[i][j]);\\n                }\\n                else{\\n                    if(matrix[i][j]<q.top()){\\n                        q.pop();\\n                        q.push(matrix[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return q.top();\\n    }",
                "solutionTags": [],
                "code": "\\n\\tint kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        if(n==0){\\n            return 0;\\n        }\\n        priority_queue<int> q;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(q.size()<k){\\n                    q.push(matrix[i][j]);\\n                }\\n                else{\\n                    if(matrix[i][j]<q.top()){\\n                        q.pop();\\n                        q.push(matrix[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return q.top();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 85238,
                "title": "clean-solution-with-detailed-explanation-in-c",
                "content": "### Solution\\n\\n#### Analysis\\nSince the matrix is sorted in two directions, using binary search to find the kth smallest is an intuitive method. Since we are searching for the number, so the searching space should be the space ranging from the smallest to the biggest number in the matrix. \\n\\n> Note that the index here cannot be used to form the searching space since it's not linear to the numbers in the matrix, whose order lies in two directions unlike the index from 0 to size(size-1).\\n\\n> Take [[1,4],[3,5]] 2 as an example. If we use the index range as the searching space, `l=0, r=3, m=(0+3)/2=1` in the first round and then the numbers smaller than or equal to its number, `matrix[m/size][m%size]=matrix[1/2][1%2]=matrix[0][1]=4,` are 3 (1, 4 and 3 respectively) and then we will set r=m=1. Just now we have eliminated the potential answer number 3, whose index should be 2 matrix[2/2][2%2]=matrix[1][0]. All of these are because the index sequence is not linear to the matrix numbers whose order lies in two directions.\\n\\n#### Details\\n- Start with half of the smallest and biggest of the matrix, and then count how many numbers are smaller than or equal to it row by row;\\n- K directly becomes the comparison determining which direction we will go in the next round, left part or the right part;\\n- Keep the answer number within the range [l, r] in each round.\\n\\nThe time complexity will be O(nlognlogm) while n is the number of rows in the matrix and m is the gap between the smallest and the biggest number in the matrix.\\n\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) \\n    {\\n        int size = matrix.size(), l = matrix[0][0], r = matrix[size-1][size-1];\\n        while(l < r)\\n        {\\n            int smaller = 0, m = l+((r-l)>>1);\\n            for(int i = 0; i < size; ++i) \\n                smaller += upper_bound(matrix[i].begin(), matrix[i].end(), m)-matrix[i].begin();\\n            smaller<k? l=m+1 : r=m;\\n        }\\n        return r;\\n    }\\n};\\n```\\n\\nAlways welcome new ideas and `practical` tricks, just leave them in the comments!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) \\n    {\\n        int size = matrix.size(), l = matrix[0][0], r = matrix[size-1][size-1];\\n        while(l < r)\\n        {\\n            int smaller = 0, m = l+((r-l)>>1);\\n            for(int i = 0; i < size; ++i) \\n                smaller += upper_bound(matrix[i].begin(), matrix[i].end(), m)-matrix[i].begin();\\n            smaller<k? l=m+1 : r=m;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85301,
                "title": "java-priorityqueue-solution",
                "content": "32ms, O(k*log(k) time complexity, used inner class to simplify things and created a custom comparator for it.\\n\\nExplanation: Basically, we create a priorityqueue which will sort the inserted elements based on lowest matrix[][] value. At first, we insert the smallest value which is at matrix[0][0]. To iteratively find the next smallest element, we need to take out the smallest value from the priorityqueue, and add the value toward its right / bottom(if we are at the first row) into the priorityqueue (as long as they are within range). The next smallest value must be either already inside the priorityqueue, or be to the right/bottom of the current smallest value. Either way, the priorityqueue will make the correct ordering so that the next smallest value is ready to be removed. We do this loop k-1 times, and remove the kth smallest from the priorityqueue in the end.\\n```\\npublic class Solution {\\n    public class Point {\\n        int val;\\n        int x;\\n        int y;\\n        public Point(int val, int x, int y) {\\n            this.val = val;\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if(matrix.length == 0) return 0;\\n        PriorityQueue<Point> pq = new PriorityQueue<Point>(new Comparator<Point>(){\\n           @Override\\n           public int compare(Point a, Point b) {\\n               return a.val - b.val;\\n           }\\n        });\\n        pq.offer(new Point(matrix[0][0], 0, 0));\\n        for(int i = 1; i < k; i++) {\\n            Point p = pq.poll();\\n            if((p.x+1) < matrix.length) {\\n                pq.offer(new Point(matrix[p.x+1][p.y], p.x+1, p.y));\\n            }\\n            if(p.x == 0 && (p.y+1) < matrix.length) {\\n                pq.offer(new Point(matrix[p.x][p.y+1], p.x, p.y+1));\\n            }\\n        }\\n        return pq.poll().val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public class Point {\\n        int val;\\n        int x;\\n        int y;\\n        public Point(int val, int x, int y) {\\n            this.val = val;\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if(matrix.length == 0) return 0;\\n        PriorityQueue<Point> pq = new PriorityQueue<Point>(new Comparator<Point>(){\\n           @Override\\n           public int compare(Point a, Point b) {\\n               return a.val - b.val;\\n           }\\n        });\\n        pq.offer(new Point(matrix[0][0], 0, 0));\\n        for(int i = 1; i < k; i++) {\\n            Point p = pq.poll();\\n            if((p.x+1) < matrix.length) {\\n                pq.offer(new Point(matrix[p.x+1][p.y], p.x+1, p.y));\\n            }\\n            if(p.x == 0 && (p.y+1) < matrix.length) {\\n                pq.offer(new Point(matrix[p.x][p.y+1], p.x, p.y+1));\\n            }\\n        }\\n        return pq.poll().val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85316,
                "title": "java-heap-solution-time-complexity-klog-k",
                "content": "In heap, element is an array\\nint[0] represents matrix[i][j] value\\nint[1] represents i\\nint[2] represents j\\nWhenever an element is poll() from heap, push the element below it to heap, only push the element right to it to heap when it's in first row. So we can avoid duplicates.\\n```\\npublic int kthSmallest(int[][] matrix, int k) {\\n        PriorityQueue<int[]> heap = new PriorityQueue<int[]>(10000,new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] a,int[] b){\\n                return a[0]-b[0];\\n            }\\n        });\\n        if(matrix.length==0||k==0){\\n            return -1;\\n        }\\n        heap.offer(new int[]{matrix[0][0],0,0});\\n        int[] peak = new int[3];\\n        while(k-->0){\\n            peak = heap.poll();\\n            if(peak[1]+1<matrix.length){\\n                heap.offer(new int[]{matrix[peak[1]+1][peak[2]],peak[1]+1,peak[2]});\\n            }\\n            if(peak[1]==0&&peak[2]+1<matrix[0].length){\\n                heap.offer(new int[]{matrix[peak[1]][peak[2]+1],peak[1],peak[2]+1});\\n            }\\n        }\\n        return peak[0];\\n    }\\n```\\n\\nStill thinking about binary search solution.",
                "solutionTags": [],
                "code": "```\\npublic int kthSmallest(int[][] matrix, int k) {\\n        PriorityQueue<int[]> heap = new PriorityQueue<int[]>(10000,new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] a,int[] b){\\n                return a[0]-b[0];\\n            }\\n        });\\n        if(matrix.length==0||k==0){\\n            return -1;\\n        }\\n        heap.offer(new int[]{matrix[0][0],0,0});\\n        int[] peak = new int[3];\\n        while(k-->0){\\n            peak = heap.poll();\\n            if(peak[1]+1<matrix.length){\\n                heap.offer(new int[]{matrix[peak[1]+1][peak[2]],peak[1]+1,peak[2]});\\n            }\\n            if(peak[1]==0&&peak[2]+1<matrix[0].length){\\n                heap.offer(new int[]{matrix[peak[1]][peak[2]+1],peak[1],peak[2]+1});\\n            }\\n        }\\n        return peak[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3670211,
                "title": "c-easy-explained-2-solutions-using-min-heap-max-heap",
                "content": "# Intuition\\nUsing **Min Heap** - *in Min Heap, for every node, the value of node is lesser than it\\'s child nodes. And the ROOT is the smallest value in the Heap.* \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- *Store the entire matrix into a Min Heap.* \\n- The **Topmost element** of the heap is the **smallest element** of the array.\\n- So, ***if we delete K-1 elements from the heap, then the element at the top will be the Kth Smallest Element.*** \\n- Iterate till **K is greater than one** *(Take K or take a counter variable equal to 1 & iterate till it is not equal to K)*\\n    - In each iteration \\n        - *Pop from the heap.*\\n        - *Decrease value of K by one.*\\n- The element at the **top of the heap is Kth smallest element**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n\\n        priority_queue<int, vector<int>, greater<int> > minHeap ; \\n\\n        int row = matrix.size() ; \\n        int col = matrix[0].size() ;\\n\\n        for (int i = 0 ; i < row ; i ++)\\n        {\\n            for (int j = 0 ; j < col ; j ++)\\n            {\\n                minHeap.push(matrix[i][j]) ;\\n            }\\n        }\\n\\n        while (k > 1)\\n        {\\n            minHeap.pop() ; \\n            k -- ; \\n        }\\n\\n        return minHeap.top() ; \\n    }\\n};\\n```\\n---\\n# Intuition\\nUsing **Max Heap** - *in Max Heap, for every node, the value of node is greater than it\\'s child nodes. And the ROOT is the largest value in the Heap.* \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- *Store the entire matrix into a Max Heap.* \\n- The **Topmost element** of the heap is the **greatest element** of the array.\\n- So, ***if we reduce the size of the maxHeap priority queue to K elements*** \\n- Iterate till **Size of Max Heap is greater than K** \\n    - In each iteration \\n        - *Pop from the heap.*\\n- Now, *the size of our Heap is equal to K and only the K smallest elements are stored in it*\\n- The **Kth smallest element is the largest element out of these K elements and is stored at the top.**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        \\n        priority_queue<int> maxHeap ; \\n\\n        int row = matrix.size() ; \\n        int col = matrix[0].size() ;\\n\\n        for (int i = 0 ; i < row ; i ++)\\n        {\\n            for (int j = 0 ; j < col ; j ++)\\n            {\\n                maxHeap.push(matrix[i][j]) ;\\n            }\\n        }\\n\\n        while (maxHeap.size() > k)\\n        {\\n            maxHeap.pop() ; \\n        }\\n\\n        return maxHeap.top() ; \\n    }\\n};\\n\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/e47c1b8e-a984-4297-9847-1a017f58de2e_1687445444.2937531.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n\\n        priority_queue<int, vector<int>, greater<int> > minHeap ; \\n\\n        int row = matrix.size() ; \\n        int col = matrix[0].size() ;\\n\\n        for (int i = 0 ; i < row ; i ++)\\n        {\\n            for (int j = 0 ; j < col ; j ++)\\n            {\\n                minHeap.push(matrix[i][j]) ;\\n            }\\n        }\\n\\n        while (k > 1)\\n        {\\n            minHeap.pop() ; \\n            k -- ; \\n        }\\n\\n        return minHeap.top() ; \\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        \\n        priority_queue<int> maxHeap ; \\n\\n        int row = matrix.size() ; \\n        int col = matrix[0].size() ;\\n\\n        for (int i = 0 ; i < row ; i ++)\\n        {\\n            for (int j = 0 ; j < col ; j ++)\\n            {\\n                maxHeap.push(matrix[i][j]) ;\\n            }\\n        }\\n\\n        while (maxHeap.size() > k)\\n        {\\n            maxHeap.pop() ; \\n        }\\n\\n        return maxHeap.top() ; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401489,
                "title": "easy-c-solution-using-priority-queue-stl",
                "content": "\\nThis is a C++ code that aims to find the kth smallest element in a 2D matrix by using a priority queue data structure.\\n\\nThe code first creates an empty max heap using the priority_queue container with the default comparator (which is std::less). Then, it loops through each element in the matrix and inserts them into the max heap.\\n\\nIf the size of the max heap exceeds k, it removes the top element (which is the maximum element in the heap). Since we want to find the kth smallest element, we only keep the k smallest elements in the max heap.\\n\\nFinally, the function returns the top element of the max heap, which is the kth smallest element in the matrix.\\n\\nTherefore, the code has a time complexity of O(N log k), where N is the total number of elements in the matrix, and k is the input parameter indicating the kth smallest element to be found.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N log k),\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int>max_h;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[i].size();j++)\\n            {\\n                max_h.push(matrix[i][j]);\\n                if(max_h.size()>k)\\n                max_h.pop();\\n            }\\n        }\\n        return max_h.top();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int>max_h;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[i].size();j++)\\n            {\\n                max_h.push(matrix[i][j]);\\n                if(max_h.size()>k)\\n                max_h.pop();\\n            }\\n        }\\n        return max_h.top();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2371454,
                "title": "clean-binary-search-beats-97-47-c",
                "content": "Before Going over this approach please go though the following Question - Search a 2D Matrix II.\\nThe matrix is sorted row and column wise.\\nSo - the min element will we the matrix[0][0] and max element will be matrix [n-1][n-1]\\n\\nNow we apply binary search operation till we find the mid element which is kth smallest element in the matrix.\\nWe calculate mid, and check in matrix for total number of elements less than or equal to mid ( O(n+n) time [check the mentioned question above] ).\\nWe binary search till we find mid being in kth smallest position.\\n\\nhttps://leetcode.com/problems/search-a-2d-matrix-ii/\\n\\n```\\nint kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size(), ans;\\n        int low = matrix[0][0], high = matrix[n-1][n-1];\\n        while(low<=high){\\n            int mid = (low + high)/2;\\n            int i = 0, j = n-1, count =0;\\n            while(i<n && j >= 0){\\n                if (mid < matrix[i][j]){\\n                    j--;\\n                }else if (mid >= matrix[i][j]){\\n                    count += j+1;\\n                    i++;   \\n                }    \\n            }\\n            if(count>=k){\\n                ans = mid;\\n                high = mid-1;\\n            }else if(count<k){\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n```\\n\\n**Time Complexity   = O(n+n) log d**   here,  d = max element - min element \\n**Space Complexity = 0(1)**\\n\\n![image](https://assets.leetcode.com/users/images/d37cdc7a-f084-4e14-af23-1a93b3a6e23d_1659474989.2736573.png)\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size(), ans;\\n        int low = matrix[0][0], high = matrix[n-1][n-1];\\n        while(low<=high){\\n            int mid = (low + high)/2;\\n            int i = 0, j = n-1, count =0;\\n            while(i<n && j >= 0){\\n                if (mid < matrix[i][j]){\\n                    j--;\\n                }else if (mid >= matrix[i][j]){\\n                    count += j+1;\\n                    i++;   \\n                }    \\n            }\\n            if(count>=k){\\n                ans = mid;\\n                high = mid-1;\\n            }else if(count<k){\\n                low = mid+1;\\n            }\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2369108,
                "title": "easy-c-solution-using-priority-queue-explanation-comments",
                "content": "**Kindly Upvote if you like the solution \\uD83D\\uDC4D**\\n\\n*1. Push all elements of the matrix in the priority queue (MAX-HEAP)\\n2.  If the pq.size() > k , then pop the element\\n3.  The kth smallest element will remain on the top of queue will be the answer.*\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        \\n        priority_queue<int>pq;\\n        \\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                pq.push(matrix[i][j]);\\n                if(pq.size()> k )\\n                {\\n                    pq.pop();\\n                }\\n            \\n            }\\n        }\\n        \\n        return pq.top();        \\n    }\\n    \\n};\\n```\\n\\n**2nd approach discussed here** :- https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/2369163/C%2B%2B-oror-Binary-Search-Easy-Explanation-oror-Simple-Solution",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        \\n        priority_queue<int>pq;\\n        \\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                pq.push(matrix[i][j]);\\n                if(pq.size()> k )\\n                {\\n                    pq.pop();\\n                }\\n            \\n            }\\n        }\\n        \\n        return pq.top();        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344509,
                "title": "c-3-approach-worst-to-best-time-complexity",
                "content": "Approach 1: Brute Force\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<int> vt;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                vt.push_back(matrix[i][j]);\\n            }\\n        }\\n        sort(vt.begin(),vt.end());\\n        return vt[k-1];\\n    }\\n};\\n```\\nApproach 2: O(n) Space\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                pq.push(matrix[i][j]);\\n                if(pq.size() > k)\\n                {\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        return pq.top();\\n    }\\n};\\n```\\nApproach 3: Constant Space O(1)\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int low = matrix[0][0];\\n        int high = matrix[n-1][n-1];\\n        while(low < high)\\n        {\\n            int mid = low + (high - low)/2;\\n            int count = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                count += upper_bound(matrix[i].begin(),matrix[i].end(),mid)-matrix[i].begin();\\n            }\\n            if(count < k)\\n            {\\n                low = mid+1;\\n            }\\n            else\\n            {\\n                high = mid;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```\\n# Please Upvote !!",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<int> vt;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                vt.push_back(matrix[i][j]);\\n            }\\n        }\\n        sort(vt.begin(),vt.end());\\n        return vt[k-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                pq.push(matrix[i][j]);\\n                if(pq.size() > k)\\n                {\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        return pq.top();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int low = matrix[0][0];\\n        int high = matrix[n-1][n-1];\\n        while(low < high)\\n        {\\n            int mid = low + (high - low)/2;\\n            int count = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                count += upper_bound(matrix[i].begin(),matrix[i].end(),mid)-matrix[i].begin();\\n            }\\n            if(count < k)\\n            {\\n                low = mid+1;\\n            }\\n            else\\n            {\\n                high = mid;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875205,
                "title": "1ms-runtime-java-easy-solution-using-binary-search",
                "content": "```\\nclass Solution {\\n    public int kthSmallest(int[][] arr, int k) {\\n        int n = arr.length;\\n        int min = arr[0][0];\\n        int max = arr[n-1][n-1];\\n        \\n        while(min!=max){\\n            int mid = min+(max-min)/2;\\n            int count = count(arr,mid);\\n            if(count<k){\\n                min = mid+1;\\n            }else{\\n                max = mid;\\n            }\\n        }\\n        return min;\\n    }\\n    public int count(int[][] arr, int k){\\n        int c=0;\\n        int row = 0;\\n        int col = arr.length-1;\\n        while(row <arr.length && col>=0){\\n            if(arr[row][col] <= k){\\n                c+=col+1;\\n                row++;\\n            }else{\\n                col--;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int kthSmallest(int[][] arr, int k) {\\n        int n = arr.length;\\n        int min = arr[0][0];\\n        int max = arr[n-1][n-1];\\n        \\n        while(min!=max){\\n            int mid = min+(max-min)/2;\\n            int count = count(arr,mid);\\n            if(count<k){\\n                min = mid+1;\\n            }else{\\n                max = mid;\\n            }\\n        }\\n        return min;\\n    }\\n    public int count(int[][] arr, int k){\\n        int c=0;\\n        int row = 0;\\n        int col = arr.length-1;\\n        while(row <arr.length && col>=0){\\n            if(arr[row][col] <= k){\\n                c+=col+1;\\n                row++;\\n            }else{\\n                col--;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618612,
                "title": "c-binary-search-with-proper-explanation",
                "content": "```\\n// here we use binary search on elements rather than index\\n// consider the example 1 given in question\\n// we calculate mid = (1 + 15) / 2 --> 8\\n// now if 8 is the kth smallest i.e 8th smallest element then there must be 7 elements \\n//smaller than 8 in the given matrix\\n// but that is not the case. \\n// there are only 2 elements smaller than 8 in the given matrix which means\\n// 8 is not the 8th smallest element in the given matrix\\n// by that i mean in the question it is given that k = 8 which means the element which will the 8th smallest\\n// element will have 7 elements before it which are smaller than it\\n// so we use count to calculate no of elements which are smaller than given kth smallest element\\n// so the element at which our count will give a value of 7 which means 7 elements are smaller than \\n// this element that means that element will be our kth smallest element\\n\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = (int) matrix.size();\\n        int low = matrix[0][0];\\n        int high = matrix[n - 1][n - 1];\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            int count = 0;\\n            for (int i = 0; i < n; ++i) {\\n                count += upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();\\n            }\\n            if (count < k) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// here we use binary search on elements rather than index\\n// consider the example 1 given in question\\n// we calculate mid = (1 + 15) / 2 --> 8\\n// now if 8 is the kth smallest i.e 8th smallest element then there must be 7 elements \\n//smaller than 8 in the given matrix\\n// but that is not the case. \\n// there are only 2 elements smaller than 8 in the given matrix which means\\n// 8 is not the 8th smallest element in the given matrix\\n// by that i mean in the question it is given that k = 8 which means the element which will the 8th smallest\\n// element will have 7 elements before it which are smaller than it\\n// so we use count to calculate no of elements which are smaller than given kth smallest element\\n// so the element at which our count will give a value of 7 which means 7 elements are smaller than \\n// this element that means that element will be our kth smallest element\\n\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = (int) matrix.size();\\n        int low = matrix[0][0];\\n        int high = matrix[n - 1][n - 1];\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            int count = 0;\\n            for (int i = 0; i < n; ++i) {\\n                count += upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();\\n            }\\n            if (count < k) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479097,
                "title": "simple-java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        int left = matrix[0][0];\\n        int right = matrix[n-1][n-1];\\n        while(left < right){\\n            int mid = left + (right - left)/2;\\n            int count = seachMatrix(matrix,mid);    //find how many numbers are smaller than mid element\\n            if(count < k){\\n                left = mid+1;\\n            }\\n            else{\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n    \\n    //leetcode 240\\n    public int seachMatrix(int[][] matrix, int target) {\\n        //start from last column of first row.\\n        int count = 0;\\n        int row = 0;\\n        int col_max = matrix[0].length-1;\\n        \\n        //move down or left to find the element\\n        while(row < matrix.length && col_max >= 0){\\n            if(matrix[row][col_max] > target) col_max--;\\n            else {\\n                count = count + col_max + 1;\\n                row++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        int left = matrix[0][0];\\n        int right = matrix[n-1][n-1];\\n        while(left < right){\\n            int mid = left + (right - left)/2;\\n            int count = seachMatrix(matrix,mid);    //find how many numbers are smaller than mid element\\n            if(count < k){\\n                left = mid+1;\\n            }\\n            else{\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n    \\n    //leetcode 240\\n    public int seachMatrix(int[][] matrix, int target) {\\n        //start from last column of first row.\\n        int count = 0;\\n        int row = 0;\\n        int col_max = matrix[0].length-1;\\n        \\n        //move down or left to find the element\\n        while(row < matrix.length && col_max >= 0){\\n            if(matrix[row][col_max] > target) col_max--;\\n            else {\\n                count = count + col_max + 1;\\n                row++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248159,
                "title": "explained-binary-search-solution-o-n-log-m-log-max-min",
                "content": "-> The range of our ans lies within the minimum and maximum of given matrix.\\n-> Our answer is the kth smallest number in matrix, which means count of numbers smaller than or equal to answer will be greater than or equal to k . \\n\\t\\t*Why greater than or equal to and not equal to ?*\\n\\t\\t*-> Because we can have duplicate numbers in our matrix.*\\n\\nLet\\'s say we have a function check(x) which returns true if count of numbers smaller than or equal to x (in matrix) is greater than or equal to k, otherwise returns false.\\n\\n-> **check(x) will be true for our answer (kth smallest number) and any number greater than our answer.**\\n\\n\\ti.e check(x) is a **monotonic function**, which can be represented as : - \\n\\tFFFFFFFFFFFFFFFFF**T**TTTTTTTTTTT\\n\\tand the smallest x for which check(x) returns T (true) is our required answer (kth smallest number in matrix).\\n\\n-> We can use binary search to find our answer (x, s.t check(x)==true and check(x-1)==false)\\n-> range for our binary search will be [min(matrix), max(matrix]\\n-> At each step of binary search, we calculate the mid element and find where check(mid) is true false\\n-> check(mid) can be computed in O(nlogn) time using upper_bound on each row of matrix\\n-> if check(mid) is true then we store it in our answer variable and update our range :  end = mid-1\\n-> if check(mid) is false then we do not store it and update our range : start = mid+1\\nafter the complete iteration of binary search answer variable will store kth smallest number.\\n**Code **\\n\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<vector<int>>& matrix,int mid,int k){\\n        int ans = 0;\\n        for(int i=0;i<matrix.size();++i){\\n            ans+=upper_bound(matrix[i].begin(),matrix[i].end(),mid) - matrix[i].begin();\\n        }\\n        return (ans>=k);\\n    }\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n\\t\\t// start : starting point our current range for binary search\\n        int start = matrix[0][0], end = matrix[n-1][n-1];\\n\\t\\t\\n\\t\\t// ans variable will store kth smallest number\\n        int ans;\\n        while(end>=start){\\n            int mid = start + (end-start)/2;\\n            if(check(matrix,mid,k)){\\n\\t\\t\\t// mid is a probable answer store it and look for numbers left to it\\n\\t\\t\\t// we want to find smallest x s.t check(x)==true\\n                ans = mid;\\n                end = mid-1;\\n            }\\n            else{\\n\\t\\t\\t// ans lies to right of mid\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<vector<int>>& matrix,int mid,int k){\\n        int ans = 0;\\n        for(int i=0;i<matrix.size();++i){\\n            ans+=upper_bound(matrix[i].begin(),matrix[i].end(),mid) - matrix[i].begin();\\n        }\\n        return (ans>=k);\\n    }\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n\\t\\t// start : starting point our current range for binary search\\n        int start = matrix[0][0], end = matrix[n-1][n-1];\\n\\t\\t\\n\\t\\t// ans variable will store kth smallest number\\n        int ans;\\n        while(end>=start){\\n            int mid = start + (end-start)/2;\\n            if(check(matrix,mid,k)){\\n\\t\\t\\t// mid is a probable answer store it and look for numbers left to it\\n\\t\\t\\t// we want to find smallest x s.t check(x)==true\\n                ans = mid;\\n                end = mid-1;\\n            }\\n            else{\\n\\t\\t\\t// ans lies to right of mid\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132467,
                "title": "binary-search-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n\\t\\tint left = matrix[0][0];\\n        int right = matrix[n - 1][n - 1];\\n    \\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n                \\n            int res = 0;\\n            for(int i = 0; i < n; i++) {\\n                 res += upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();\\n                \\n            }\\n            \\n            if(res < k) {\\n                    left = mid + 1;\\n            }else {\\n                    right = mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n\\t\\tint left = matrix[0][0];\\n        int right = matrix[n - 1][n - 1];\\n    \\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n                \\n            int res = 0;\\n            for(int i = 0; i < n; i++) {\\n                 res += upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();\\n                \\n            }\\n            \\n            if(res < k) {\\n                    left = mid + 1;\\n            }else {\\n                    right = mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1118644,
                "title": "java-simple-and-easy-to-understand-solution-using-maxheap-clean-code-with-comments",
                "content": "****\\n\\n\\n```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        //Max Heap\\n        //The root node has the maximum value.\\n\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>((a, b) -> (b - a));\\n        \\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                \\n                //store in maxHeap\\n                maxHeap.add(matrix[i][j]);\\n                \\n                //remove the largest elemet,\\n                //if size is greater than k \\n                if(maxHeap.size() > k) maxHeap.remove();\\n            }\\n        }\\n        return maxHeap.peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        //Max Heap\\n        //The root node has the maximum value.\\n\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>((a, b) -> (b - a));\\n        \\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                \\n                //store in maxHeap\\n                maxHeap.add(matrix[i][j]);\\n                \\n                //remove the largest elemet,\\n                //if size is greater than k \\n                if(maxHeap.size() > k) maxHeap.remove();\\n            }\\n        }\\n        return maxHeap.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004232,
                "title": "python-solution-with-thinking-process",
                "content": "Solution 1:\\nPlease see my solutions for these similar problems.\\n[373. Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/discuss/1010012/Python-solution-with-thinking-process)\\n[378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/1004232/Python-solution-with-thinking-process)\\nheap: list of tuple (matrix[i][j], i, j), which is initialized with first row in the matrix.\\nWe maintain a heap. In the while loop, we pop the smallest element (matrix[i][j], i, j) from the heap, and push (matrix[i+1], i+1, j) to the heap if it exists.\\n```\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        n, m = len(matrix), len(matrix[0])\\n        heap = [(matrix[0][j], 0, j) for j in range(m)]\\n        heapq.heapify(heap)\\n        while k > 0:\\n            result, i, j = heapq.heappop(heap)\\n            if i + 1 < n:\\n                heapq.heappush(heap, (matrix[i+1][j], i + 1, j))\\n            k -= 1\\n        return result\\n```\\nTime complexity: O(m + k log(m))\\n\\nSolution 2: binary solution if all elements are integers\\nPlease see my solutions for these similar problems.\\n\\nFor these problems, it\\'s relatively easy to solve the subproblem:\\ngiven a specific guess, determine whether it\\'s possible to xxx?\\nFurthermore, the range of guess is limited, and the boolean answer of the above subproblem has the pattern\\nF...FT...T or T...TF...F.\\nThus, we can use binary search to find the minimal/maximal value such that the boolean answer is True.\\n[378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/1004232/Python-solution-with-thinking-process)\\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/discuss/1714072/Simple-Python-Binary-Search-(similar-problem-listed))\\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/discuss/326747/Python-solutions-with-thinking-process)\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/390359/Simple-Python-Binary-Search)\\n[1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/409956/Simple-Python-Binary-Search-(similar-problem-listed))\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/390523/Simple-Python-Binary-Search)\\n[774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/390526/Simple-Python-Binary-Search)\\n[1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/discuss/390530/Simple-Python-Binary-Search)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/1714075/Simple-Python-Binary-Search-(similar-problem-listed))\\n[1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/discuss/2361972/Python-Binary-search-solution-(similar-problems-listed))\\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/discuss/1698346/Python-Binary-search-solution-(similar-problems-listed))\\n\\n1. All integers are in the range [matrix[0][0], matrix[n-1][m-1]], we can use binary search to find the k-th smallest element\\n2.  Similar to [240. Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/), further use binary search to define a helper function count_non_bigger(matrix, target) for step 1\\n\\n```\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:      \\n        def count_non_bigger(matrix, target):\\n            n, m = len(matrix), len(matrix[0])\\n            cnt = 0\\n            i, j = n - 1, 0\\n            while i >= 0 and j < m:\\n                if matrix[i][j] > target:\\n                    i -= 1\\n                else:\\n                    j += 1\\n                    cnt += i + 1\\n            return cnt\\n        \\n        n, m = len(matrix), len(matrix[0])\\n        low, high = matrix[0][0], matrix[n-1][m-1]\\n        while low < high:\\n            mid = low + (high - low) // 2\\n            count = count_non_bigger(matrix, mid)\\n            if count < k:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n```",
                "solutionTags": [],
                "code": "```\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        n, m = len(matrix), len(matrix[0])\\n        heap = [(matrix[0][j], 0, j) for j in range(m)]\\n        heapq.heapify(heap)\\n        while k > 0:\\n            result, i, j = heapq.heappop(heap)\\n            if i + 1 < n:\\n                heapq.heappush(heap, (matrix[i+1][j], i + 1, j))\\n            k -= 1\\n        return result\\n```\n```\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:      \\n        def count_non_bigger(matrix, target):\\n            n, m = len(matrix), len(matrix[0])\\n            cnt = 0\\n            i, j = n - 1, 0\\n            while i >= 0 and j < m:\\n                if matrix[i][j] > target:\\n                    i -= 1\\n                else:\\n                    j += 1\\n                    cnt += i + 1\\n            return cnt\\n        \\n        n, m = len(matrix), len(matrix[0])\\n        low, high = matrix[0][0], matrix[n-1][m-1]\\n        while low < high:\\n            mid = low + (high - low) // 2\\n            count = count_non_bigger(matrix, mid)\\n            if count < k:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 901248,
                "title": "binary-search-java-0ms-solution-o-1-space",
                "content": "Approach:\\nIn the matrix, we know that the smallest and largest elements are (the upperleft and the lowerright respectively).\\nLet `lowerBound` and `upperBound` be the smallest and largest element respectively. All elements in the matrix will lie in the range `[lowerBound, upperBound]`.\\n\\nWe then find the `mid` value of them (the average value) and then find the number of elements in the matrix that are smaller or equal to `mid`. Let\\'s call that number `rank`.\\n\\nIf `rank` < k, we know that the wanted element must be larger than `mid` so we search to the right of `mid` (thus `lowerBound = mid + 1`).\\nOtherwise, we know that the wanted element must be on the left of `mid` or `mid` itself, therefore we limit the search range from `[lowerBound, mid]`.\\n\\nWe keep doing that until the search range only has 1 item left.\\n\\nCode:\\n```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int cols = matrix[0].length;\\n        int rows = matrix.length;\\n        \\n        // The upper left element will be the smallest item\\n        int lowerBound = matrix[0][0];\\n        // The lower right element will be the larget item\\n        // Together with the lowerBound, we have to largest range in the matrix\\n        int upperBound = matrix[rows - 1][cols - 1];\\n        \\n        while (lowerBound < upperBound) {\\n            int mid = (lowerBound + upperBound) / 2;\\n            int rank = rank(matrix, mid);\\n            \\n            // If there are at least k elements in the matrix\\n            // that are smaller than mid, we need to reduce the range to the left\\n            if (rank >= k)\\n                upperBound = mid;\\n            \\n            // Other wise we search to the right to get a larger rank\\n            else\\n                lowerBound = mid + 1;\\n        }\\n        \\n        return lowerBound;\\n    }\\n    \\n    /* Find the total number of items in the matrix that are less than or equal to the target */\\n    private int rank(int[][] matrix, int target) {\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        \\n        int row = rows - 1;\\n        int col = 0;\\n        \\n        int count = 0;\\n        // Start from the bottom left element where we have the largest item\\n        // of the first column and the smallest item in the last row\\n        while (row >= 0 && col < cols) {\\n            \\n            // If the current item is less than the target\\n            // we move to the right to test the larger element\\n            // and we know that all elements in that same column\\n            // will also smaller than target, so we add them all to count and don\\'t\\n            // go back to that column again\\n            \\n            if (matrix[row][col] <= target) {\\n                col++;\\n                count = count + (row + 1);\\n            }\\n            \\n            // If the current item is larger than target\\n            // we know that all items to the right on the same row\\n            // will be also larger than target, so we don\\'t search that row anymore\\n            // but instead move to the upper row\\n            \\n            else {\\n                row--;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int cols = matrix[0].length;\\n        int rows = matrix.length;\\n        \\n        // The upper left element will be the smallest item\\n        int lowerBound = matrix[0][0];\\n        // The lower right element will be the larget item\\n        // Together with the lowerBound, we have to largest range in the matrix\\n        int upperBound = matrix[rows - 1][cols - 1];\\n        \\n        while (lowerBound < upperBound) {\\n            int mid = (lowerBound + upperBound) / 2;\\n            int rank = rank(matrix, mid);\\n            \\n            // If there are at least k elements in the matrix\\n            // that are smaller than mid, we need to reduce the range to the left\\n            if (rank >= k)\\n                upperBound = mid;\\n            \\n            // Other wise we search to the right to get a larger rank\\n            else\\n                lowerBound = mid + 1;\\n        }\\n        \\n        return lowerBound;\\n    }\\n    \\n    /* Find the total number of items in the matrix that are less than or equal to the target */\\n    private int rank(int[][] matrix, int target) {\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        \\n        int row = rows - 1;\\n        int col = 0;\\n        \\n        int count = 0;\\n        // Start from the bottom left element where we have the largest item\\n        // of the first column and the smallest item in the last row\\n        while (row >= 0 && col < cols) {\\n            \\n            // If the current item is less than the target\\n            // we move to the right to test the larger element\\n            // and we know that all elements in that same column\\n            // will also smaller than target, so we add them all to count and don\\'t\\n            // go back to that column again\\n            \\n            if (matrix[row][col] <= target) {\\n                col++;\\n                count = count + (row + 1);\\n            }\\n            \\n            // If the current item is larger than target\\n            // we know that all items to the right on the same row\\n            // will be also larger than target, so we don\\'t search that row anymore\\n            // but instead move to the upper row\\n            \\n            else {\\n                row--;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758235,
                "title": "python-3-one-liner-flatten-2d-to-1d",
                "content": "Explaination:\\n1. ```sum(matrix, [])``` is used for flattening a 2D matrix into a 1D array.\\n2. The array is sorted and the ```array[k-1]``` is returned.\\n\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        return sorted(sum(matrix, []))[k-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```sum(matrix, [])```\n```array[k-1]```\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        return sorted(sum(matrix, []))[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 614591,
                "title": "java-optimized-min-k-n-k-log-n-heap",
                "content": "**Optimized Approach**\\n**Time complexity = O( min(k, n) + k * log n )**\\n```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n\\t\\t\\tclass Node {            // Inner class for combining row and column into single object\\n            int row, col;\\n            Node(int r, int c){\\n                row = r;\\n                col = c;\\n            }\\n        }\\n        \\n        Queue<Node> heap = new PriorityQueue<>( (a, b) -> matrix[a.row][a.col] - matrix[b.row][b.col]);\\n                                                 \\n        for(int j = 0; j < matrix[0].length && j < k ; j++){\\n            heap.add( new Node(0, j) );\\n        }\\n        \\n        while( k > 1){\\n            Node node = heap.poll();\\n            if( node.row +1 < matrix.length )\\n                heap.add(new Node(node.row +1, node.col));\\n            k--;\\n        }\\n        \\n        return matrix[heap.peek().row][heap.peek().col];\\n        \\n    }\\n}\\n```\\n**Brute Force Approach**\\n**Time = O( m * n * log k )**\\n```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        Queue<Integer> heap = new PriorityQueue<>( (a, b) -> b-a );     \\n        for(int []  a : matrix ){\\n            for(int i : a){\\n                heap.add(i);\\n                \\n                if( heap.size() > k){\\n                    heap.poll();\\n                }\\n            }\\n        }\\n        return heap.peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n\\t\\t\\tclass Node {            // Inner class for combining row and column into single object\\n            int row, col;\\n            Node(int r, int c){\\n                row = r;\\n                col = c;\\n            }\\n        }\\n        \\n        Queue<Node> heap = new PriorityQueue<>( (a, b) -> matrix[a.row][a.col] - matrix[b.row][b.col]);\\n                                                 \\n        for(int j = 0; j < matrix[0].length && j < k ; j++){\\n            heap.add( new Node(0, j) );\\n        }\\n        \\n        while( k > 1){\\n            Node node = heap.poll();\\n            if( node.row +1 < matrix.length )\\n                heap.add(new Node(node.row +1, node.col));\\n            k--;\\n        }\\n        \\n        return matrix[heap.peek().row][heap.peek().col];\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        Queue<Integer> heap = new PriorityQueue<>( (a, b) -> b-a );     \\n        for(int []  a : matrix ){\\n            for(int i : a){\\n                heap.add(i);\\n                \\n                if( heap.size() > k){\\n                    heap.poll();\\n                }\\n            }\\n        }\\n        return heap.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413306,
                "title": "java-solution-with-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\\n        for (int i = 0; i < matrix.length; i++){\\n            for (int j = 0; j < matrix.length; j++){\\n                pq.add(matrix[i][j]);\\n                if (pq.size() > k) pq.poll();\\n            }\\n        }\\n        return pq.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\\n        for (int i = 0; i < matrix.length; i++){\\n            for (int j = 0; j < matrix.length; j++){\\n                pq.add(matrix[i][j]);\\n                if (pq.size() > k) pq.poll();\\n            }\\n        }\\n        return pq.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327593,
                "title": "verbosely-commented-python-binary-search",
                "content": "`Runtime: O(N lg N + N lg M)`.\\n\\n`O(N log N)` for the initial sort of `nums` +\\n`possible()` does 2N passes, i.e. O(N), and we call it lg M times, where M is the max distance possible, i.e. max num - min num. Therefore `O(N * lg M)`\\n\\nSpace: `O(1)`\\n\\n```python\\n    def kthSmallest(self, matrix, k):\\n        \\n        def count_le(num):\\n            \"\"\"How many elements are less than or equal to `num`?\"\"\"\\n            count = 0\\n            # Note that `col` is not reset for each row: we continue\\n            # on because the columns are sorted as well. i.e. the\\n            # cell one up is guaranteed to be smaller-or-equal to\\n            # current cell.\\n            col = 0\\n            \\n            # We start at bottom left, going up and right as necessary.\\n            # If we started at top-left, imagine we go right because numbers\\n            # are less-than-equal to num, when that condition breaks and we\\n            # must go a row down, that number is even bigger! At that point we\\n            # don\\'t know if actually the number to the left of this one is also\\n            # bigger (and thus should not be counted.)\\n            for row in reversed(matrix):\\n                # Go left to right until we reach an element\\n                # that is not less than or equal to `num`.\\n                while col < cols and row[col] <= num: \\n                    col += 1\\n                # All the elemnts to the left are less than\\n                # `num`, so we count them.\\n                count += col\\n            return count\\n        \\n        rows = cols = len(matrix)\\n        lo = matrix[0][0]  # Min number in matrix\\n        hi = matrix[rows - 1][cols - 1]  # Max number in matrix\\n        \\n        while lo < hi:\\n            guess = (lo + hi) // 2\\n            if count_le(guess) < k:\\n                lo = guess + 1\\n            else:\\n                # Not guess-1, because this `guess` might be == k, \\n                # and end up being the correct answer.\\n                hi = guess\\n        return lo\\n```",
                "solutionTags": [],
                "code": "```python\\n    def kthSmallest(self, matrix, k):\\n        \\n        def count_le(num):\\n            \"\"\"How many elements are less than or equal to `num`?\"\"\"\\n            count = 0\\n            # Note that `col` is not reset for each row: we continue\\n            # on because the columns are sorted as well. i.e. the\\n            # cell one up is guaranteed to be smaller-or-equal to\\n            # current cell.\\n            col = 0\\n            \\n            # We start at bottom left, going up and right as necessary.\\n            # If we started at top-left, imagine we go right because numbers\\n            # are less-than-equal to num, when that condition breaks and we\\n            # must go a row down, that number is even bigger! At that point we\\n            # don\\'t know if actually the number to the left of this one is also\\n            # bigger (and thus should not be counted.)\\n            for row in reversed(matrix):\\n                # Go left to right until we reach an element\\n                # that is not less than or equal to `num`.\\n                while col < cols and row[col] <= num: \\n                    col += 1\\n                # All the elemnts to the left are less than\\n                # `num`, so we count them.\\n                count += col\\n            return count\\n        \\n        rows = cols = len(matrix)\\n        lo = matrix[0][0]  # Min number in matrix\\n        hi = matrix[rows - 1][cols - 1]  # Max number in matrix\\n        \\n        while lo < hi:\\n            guess = (lo + hi) // 2\\n            if count_le(guess) < k:\\n                lo = guess + 1\\n            else:\\n                # Not guess-1, because this `guess` might be == k, \\n                # and end up being the correct answer.\\n                hi = guess\\n        return lo\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 85202,
                "title": "c-version-by-sortedlist",
                "content": "Inspired by selection sort, we use priority queue (SortedList in C#). The special thing here is to deal with duplicates.\\n\\n    public class Solution {\\n        public int KthSmallest(int[,] matrix, int k) {\\n            int r = 0;\\n            SortedList<int, Tuple<int, int>> s = new SortedList<int, Tuple<int, int>>(new DuplicateKeyComparer<int>());\\n            for (int i = 0; i < matrix.GetLength(0); i++)\\n            {\\n                s.Add(matrix[i, 0], new Tuple<int, int>(i, 0));\\n            }\\n            while (k-- > 0)\\n            {\\n                r = s.First().Key;\\n                int x = s.First().Value.Item1, y = s.First().Value.Item2;\\n                s.RemoveAt(0);\\n                if (y < matrix.GetLength(0) - 1)\\n                {\\n                    s.Add(matrix[x, y + 1], new Tuple<int, int>(x, y + 1));\\n                }\\n            }\\n            return r;\\n        }\\n    }\\n\\n    public class DuplicateKeyComparer<TKey> : IComparer<TKey> where TKey : IComparable\\n    {\\n        public int Compare(TKey x, TKey y)\\n        {\\n            int result = x.CompareTo(y);\\n            return result == 0 ? 1 : result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int KthSmallest(int[,] matrix, int k) {\\n            int r = 0;\\n            SortedList<int, Tuple<int, int>> s = new SortedList<int, Tuple<int, int>>(new DuplicateKeyComparer<int>());\\n            for (int i = 0; i < matrix.GetLength(0); i++)\\n            {\\n                s.Add(matrix[i, 0], new Tuple<int, int>(i, 0));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 85312,
                "title": "c-solution-same-as-find-k-pairs-with-smaller-sums",
                "content": "\\n\\nclass Solution {\\npublic:\\n\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        auto comp = [&matrix](pair<int, int> p1, pair<int, int> p2){\\n            return matrix[p1.first][p1.second] > matrix[p2.first][p2.second];\\n        };\\n        priority_queue<pair<int, int>, vector<pair<int,int>>, decltype(comp)> que(comp);\\n        que.push(make_pair(0, 0));\\n        int count = 1;\\n        while(count < k){\\n             auto temp = que.top();\\n             que.pop();\\n             if(temp.first+1 < matrix.size()){\\n                 que.push(make_pair(temp.first+1, temp.second));\\n             }\\n             if(temp.first == 0 && temp.second+1 < matrix[0].size()){\\n                 que.push(make_pair(temp.first, temp.second+1));\\n             }\\n             count++;\\n        }\\n        auto t = que.top();\\n        return matrix[t.first][t.second];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        auto comp = [&matrix](pair<int, int> p1, pair<int, int> p2){\\n            return matrix[p1.first][p1.second] > matrix[p2.first][p2.second];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3332133,
                "title": "o-numrows-space-python-solution-using-minheap",
                "content": "[Refer Here for the original Post](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/solutions/1322101/c-java-python-maxheap-minheap-binary-search-picture-explain-clean-concise)\\n1. Put all the elements of the first column in a minheap \\n2. Each element in heap is like [value,i index , j index ]\\n3. We Remove the min element from heap and place the next element of that row if exists in the heap.\\n4. Also we keep track of how many elments we have removed from the heap, we do it k-1 time, kth time is our resulting value.\\n\\n\\n```\\n  def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n      \\n      heap = []\\n      n,m = len(matrix),len(matrix[0])\\n      for i in range(0,n):\\n          heapq.heappush(heap,[matrix[i][0],i,0])\\n\\n      count = 0 ;\\n      while(count < k-1 ):\\n          _,idx,idy = heapq.heappop(heap)\\n          if( idy+1 < m ):\\n              heapq.heappush(heap,[ matrix[idx][idy+1],idx,idy+1 ])    \\n          count += 1\\n      return heap[0][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n  def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n      \\n      heap = []\\n      n,m = len(matrix),len(matrix[0])\\n      for i in range(0,n):\\n          heapq.heappush(heap,[matrix[i][0],i,0])\\n\\n      count = 0 ;\\n      while(count < k-1 ):\\n          _,idx,idy = heapq.heappop(heap)\\n          if( idy+1 < m ):\\n              heapq.heappush(heap,[ matrix[idx][idy+1],idx,idy+1 ])    \\n          count += 1\\n      return heap[0][0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3155498,
                "title": "10-ms-but-easy-to-undersatnd-java-solution-brute-force",
                "content": "# Intuition\\n```\\n// --------------- Don\\'t Forget to upvote -------------\\n```\\n\\n# Code\\n```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        int[] temp = new int[n*n];\\n        int point = 0;\\n        for(int i = 0; i<matrix.length; i++){\\n            for(int j:matrix[i]){\\n                temp[point++] = j;\\n            }\\n        }\\n        Arrays.sort(temp);\\n\\n        return temp[k-1];\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// --------------- Don\\'t Forget to upvote -------------\\n```\n```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        int[] temp = new int[n*n];\\n        int point = 0;\\n        for(int i = 0; i<matrix.length; i++){\\n            for(int j:matrix[i]){\\n                temp[point++] = j;\\n            }\\n        }\\n        Arrays.sort(temp);\\n\\n        return temp[k-1];\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989913,
                "title": "different-approaches-brute-force-heap-priority-queue-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thing that comes to the mind is the book keeping of all elements in an array of size `N` = $$n^2$$, sorting and returning the `k-1`th element. **(Approach 1 below)**\\n\\nAnd when you read that return the `k`th smallest or so element, Priority Queue/Heap automatically comes in to play. **(Approach 2 below)**\\n\\n# Approach 1 - Brute Force | sort()\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N * log(N))$$ = $$O(n^2 * log(n^2))$$ # $$N = n^2$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        arr = []\\n        for row in matrix:\\n            for col in row:\\n                arr.append(col)\\n        arr.sort()\\n        return arr[k-1]\\n```\\n\\n# Approach 2 - Using Heap\\n<!-- Describe your approach to solving the problem. -->\\nWe will use a maxHeap and push to it until the size of the maxHeap is equal to `k`. Then after that we will replace the maximum in the heap whenever we have found a one that exceeds it from the rest of the elements in the matrix.\\n\\n> **Hint:** Negate the elements pushed to the heap to turn the minHeap of the `heapq` class into a maxHeap.\\n\\n# Complexity\\n- Time complexity: $$O(N * log(k))$$ = $$O(n^2 * log(k))$$ # $$N = n^2$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        heap = []\\n        for row in matrix:\\n            for col in row:\\n                if len(heap) < k:\\n                    heapq.heappush(heap, -col)\\n                else:\\n                    if -col > heap[0]:\\n                        heapq.heapreplace(heap, -col)\\n        return -1 * heap[0]\\n```\\nUPVOTE or DOWNVOTE or COMMENT, yo just do something :)",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        arr = []\\n        for row in matrix:\\n            for col in row:\\n                arr.append(col)\\n        arr.sort()\\n        return arr[k-1]\\n```\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        heap = []\\n        for row in matrix:\\n            for col in row:\\n                if len(heap) < k:\\n                    heapq.heappush(heap, -col)\\n                else:\\n                    if -col > heap[0]:\\n                        heapq.heapreplace(heap, -col)\\n        return -1 * heap[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406535,
                "title": "easy-understandable-java-solution-faster-than-64",
                "content": "**Please Upvote if you like my approach**\\n\\n```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int[] arr = new int[matrix.length * matrix.length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix.length; j++) {\\n                arr[(i * matrix.length) + j] = matrix[i][j];\\n            }\\n        }\\n        Arrays.sort(arr);\\n        if (arr.length < k-1) {\\n            return arr[0];\\n        }\\n        return arr[k-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int[] arr = new int[matrix.length * matrix.length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix.length; j++) {\\n                arr[(i * matrix.length) + j] = matrix[i][j];\\n            }\\n        }\\n        Arrays.sort(arr);\\n        if (arr.length < k-1) {\\n            return arr[0];\\n        }\\n        return arr[k-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369167,
                "title": "javascript-one-liner-solution",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} k\\n * @return {number}\\n */\\nvar kthSmallest = function(matrix, k) {\\n    return matrix.flat().sort((a, b) => a - b)[k - 1];\\n};\\n```\\nThe `flat()` function basically allows you to create a new array with all sub-array elements concatenated together upto a certain depth.\\n\\nBy flattening the matrix, we get a single array with all it\\'s elements. Since it is not necessary that the new array has all elements sorted given that only the sub-array and their elements were sorted initially, we need to sort the new array too. Then we return the **(k - 1)th** element in the sorted array.\\n\\n![image](https://assets.leetcode.com/users/images/ef196ffc-59dd-47e2-a2a5-887a0a73ab6c_1659441213.9623349.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} k\\n * @return {number}\\n */\\nvar kthSmallest = function(matrix, k) {\\n    return matrix.flat().sort((a, b) => a - b)[k - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2369156,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n      int n=matrix.size();\\n        int l=matrix[0][0];int r=matrix[n-1][n-1];\\n        int mid=0;\\n        while(l<r){\\n            mid=(l+r)>>1;\\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                cnt+=upper_bound(matrix[i].begin(),matrix[i].end(),mid)-matrix[i].begin();\\n            }\\n            \\n            if(cnt<k) l=mid+1;\\n            else r=mid;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n      int n=matrix.size();\\n        int l=matrix[0][0];int r=matrix[n-1][n-1];\\n        int mid=0;\\n        while(l<r){\\n            mid=(l+r)>>1;\\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                cnt+=upper_bound(matrix[i].begin(),matrix[i].end(),mid)-matrix[i].begin();\\n            }\\n            \\n            if(cnt<k) l=mid+1;\\n            else r=mid;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2367377,
                "title": "python-heap-explained-heapq",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        \\n        m = sum(matrix, [])         # convert matrix into 1D array\\n        heapq.heapify(m)            # heapify() to turn m into a heap\\n        \\n        for i in range(k - 1):      # pop (k - 1) elements so that we can find kth element\\n            heapq.heappop(m)\\n            \\n        return heapq.heappop(m)\\n```\\nPlease UPVOTE if you like !!",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        \\n        m = sum(matrix, [])         # convert matrix into 1D array\\n        heapq.heapify(m)            # heapify() to turn m into a heap\\n        \\n        for i in range(k - 1):      # pop (k - 1) elements so that we can find kth element\\n            heapq.heappop(m)\\n            \\n        return heapq.heappop(m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366889,
                "title": "c-simple-approach-priority-queue",
                "content": "**C++ simple approach || Priority Queue **\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue <int, vector<int>, greater<int>> pq ;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix.size();j++){\\n                pq.push(matrix[i][j]);\\n            }\\n        }\\n        while(k>1){\\n            pq.pop();\\n            k--;\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue <int, vector<int>, greater<int>> pq ;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix.size();j++){\\n                pq.push(matrix[i][j]);\\n            }\\n        }\\n        while(k>1){\\n            pq.pop();\\n            k--;\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303769,
                "title": "c-easy-explanation-binary-search-o-nlogn",
                "content": "```\\nint kthSmallest(vector<vector<int>> &matrix, int k)\\n{\\n    //Matrix given to us is sorted so we can apply BINARY SEARCH\\n    //This implementation will be very much similar to applying\\n    //BINARY SEARCH in a 1-D Array\\n\\n    \\n    int n = matrix.size();\\n    //Size of matrix(No of rows)\\n    int starting = matrix[0][0];\\n    //First element\\n    int middle = 0;\\n    int ending = matrix[n - 1][n - 1] + 1;\\n    //Added 1 because k can be last element also\\n    int tempColCount;\\n    //Temporary pointer pointing to column index in a row\\n    int tempSmallElemCount;\\n    //Elements less than the middle element in the matrix\\n\\n    while (starting < ending)\\n    {\\n        middle = starting + (ending - starting) / 2;\\n        tempColCount = n - 1;\\n        tempSmallElemCount = 0;\\n        for (int rowIndex = 0; rowIndex < n; rowIndex++)\\n        {\\n        //We are checking for each row \\n        //For each row, we count the elements that are smaller then middle\\n            while (tempColCount >= 0 && matrix[rowIndex][tempColCount] > middle)\\n                tempColCount--;\\n\\t\\t//Reducing the column index if the element is greater than middle\\n\\n            tempSmallElemCount += tempColCount + 1;\\n        //We are counting the elements less than middle\\n        }\\n        if (tempSmallElemCount < k)\\n        //If we have not reached the kth elem\\n            starting = middle + 1;\\n        else\\n            ending = middle;\\n        //If we have exceeded kth element\\n    }\\n    return starting;\\n}\\n```\\n- TC - O(NlogN)\\n\\n**Thank You!** for reading .Do upvote\\uD83D\\uDC4Dif you like the explanantion and if there is any scope of improvement do post it in comment section \\uD83D\\uDE01.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nint kthSmallest(vector<vector<int>> &matrix, int k)\\n{\\n    //Matrix given to us is sorted so we can apply BINARY SEARCH\\n    //This implementation will be very much similar to applying\\n    //BINARY SEARCH in a 1-D Array\\n\\n    \\n    int n = matrix.size();\\n    //Size of matrix(No of rows)\\n    int starting = matrix[0][0];\\n    //First element\\n    int middle = 0;\\n    int ending = matrix[n - 1][n - 1] + 1;\\n    //Added 1 because k can be last element also\\n    int tempColCount;\\n    //Temporary pointer pointing to column index in a row\\n    int tempSmallElemCount;\\n    //Elements less than the middle element in the matrix\\n\\n    while (starting < ending)\\n    {\\n        middle = starting + (ending - starting) / 2;\\n        tempColCount = n - 1;\\n        tempSmallElemCount = 0;\\n        for (int rowIndex = 0; rowIndex < n; rowIndex++)\\n        {\\n        //We are checking for each row \\n        //For each row, we count the elements that are smaller then middle\\n            while (tempColCount >= 0 && matrix[rowIndex][tempColCount] > middle)\\n                tempColCount--;\\n\\t\\t//Reducing the column index if the element is greater than middle\\n\\n            tempSmallElemCount += tempColCount + 1;\\n        //We are counting the elements less than middle\\n        }\\n        if (tempSmallElemCount < k)\\n        //If we have not reached the kth elem\\n            starting = middle + 1;\\n        else\\n            ending = middle;\\n        //If we have exceeded kth element\\n    }\\n    return starting;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2029680,
                "title": "super-fast-java-code-with-beginner-friendly-explanation-no-heap",
                "content": "Solution by [@YuanGao ](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85173/Share-my-thoughts-and-Clean-Java-Code)\\n\\nPlease upvote if you liked the explanation. Best of luck!!\\n\\n1. Brute-force approach\\nUse a min heap and add the values of the matrix to that heap and just return the kth value. \\nTime complexity - O(N^2) for traversing the complete matrix \\nSpace complexity - O(N^2) for min heap\\n\\n2. Binary search solution\\nThis is the tricky solution. Before doing this solution it\\'s a prerequisite that you\\'ve solved [this](https://leetcode.com/problems/search-a-2d-matrix-ii/) problem.\\nNow that you\\'ve solved the above problem you now know that for a sorted matrix we start from the top-right end to search an element. We can use that same approach here. We know that the kth smallest element will be in the range of matrix[0][0] and matrix[row-1][col-1]. So we can apply binary search in this range and find the rank of the mid and proceed accordingly. \\nThe tricky part is how to calculate that?? \\nWe can do that by using column. So whenever we change the row we know that all the elements above are smaller that\\'s why we chaged the row in first place. So we\\'ll just increase the rank by col+1 (1 because it\\'s 0 indexed).\\n\\n```java\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int start = matrix[0][0];\\n        int end = matrix[row-1][col-1];\\n        while (start<end) {\\n            int count = 0;\\n            int mid = start+(end-start)/2;\\n            int j = col-1;\\n            for (int i = 0; i<row; i++) {\\n                while (j>=0 && matrix[i][j]>mid) j--;\\n                count += j+1;\\n            }\\n            if (count<k) start = mid+1;\\n            else end = mid;\\n        }\\n        return end;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int start = matrix[0][0];\\n        int end = matrix[row-1][col-1];\\n        while (start<end) {\\n            int count = 0;\\n            int mid = start+(end-start)/2;\\n            int j = col-1;\\n            for (int i = 0; i<row; i++) {\\n                while (j>=0 && matrix[i][j]>mid) j--;\\n                count += j+1;\\n            }\\n            if (count<k) start = mid+1;\\n            else end = mid;\\n        }\\n        return end;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893843,
                "title": "easiest-c-explanation-ever-min-heap-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        // creating a min heap , that will give the minimum element on the top\\n        priority_queue <int, vector<int>, greater<int> > pq;\\n        int n=matrix.size();\\n        // pushing all elements into the min heap\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                pq.push(matrix[i][j]);\\n            }\\n        }\\n        // popping k-1 elements from the top of queue and hence k th element will be the kth smallest element in matrix\\n        int x=k-1;\\n        while(x--)\\n        {\\n            pq.pop();\\n        }\\n        return pq.top();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        // creating a min heap , that will give the minimum element on the top\\n        priority_queue <int, vector<int>, greater<int> > pq;\\n        int n=matrix.size();\\n        // pushing all elements into the min heap\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                pq.push(matrix[i][j]);\\n            }\\n        }\\n        // popping k-1 elements from the top of queue and hence k th element will be the kth smallest element in matrix\\n        int x=k-1;\\n        while(x--)\\n        {\\n            pq.pop();\\n        }\\n        return pq.top();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773873,
                "title": "python3-explained-binary-search",
                "content": "Test-case -> [[1,5,9],[10,11,13],[12,13,15]], k = 8\\n\\nApprorach is you try to binary search on answer like you take low and high and find mid,\\nlet say mid=14 , so find how many numbers are there less than or equal to 14, let\\'s say there are k numbers , so mid could be our answer, but it is possible that mid is not present in matrix so we need to check for numbers less than mid so we store mid in ans as it could be possible answer and do high=mid to check for numbers<mid . now lets say mid=13 and still numbers less than equal to mid is k , this means that previous mid that is 14 is not present in matrix because if it would have then numbers <= 14 would have come greater than k , and if numbers are less than k then we need to increase value for mid  , so do low=mid+1 .\\n```\\nimport bisect\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        n=len(matrix)\\n        low,high=matrix[0][0],matrix[n-1][n-1]\\n        ans=0\\n        while low<=high:\\n            mid=(low+high)>>1\\n            smallerElements=0\\n            for i in matrix:\\n                smallerElements+=bisect.bisect(i,mid)\\n            if smallerElements<k:\\n                low=mid+1\\n            else:\\n                ans=mid\\n                high=mid-1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nimport bisect\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        n=len(matrix)\\n        low,high=matrix[0][0],matrix[n-1][n-1]\\n        ans=0\\n        while low<=high:\\n            mid=(low+high)>>1\\n            smallerElements=0\\n            for i in matrix:\\n                smallerElements+=bisect.bisect(i,mid)\\n            if smallerElements<k:\\n                low=mid+1\\n            else:\\n                ans=mid\\n                high=mid-1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670370,
                "title": "two-method-using-extra-memory-priority-queue",
                "content": "1.> Using Extra Space\\n    class Solution {\\n\\tpublic:\\n\\t\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        vector<int> ans;\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                ans.push_back(matrix[i][j]);\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[k-1];\\n    }\\n};\\n\\n\\n2.> Priority Queue\\n       class Solution {\\n       public:\\n\\t   \\n\\t   int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int> pq;\\n        for(int i = 0;i<matrix.size();i++)\\n        {\\n            for(int j = 0;j<matrix[i].size();j++)\\n            {\\n                pq.push(matrix[i][j]);\\n                if(pq.size() >k)\\n                    pq.pop();\\n            }\\n        }\\n        return pq.top();\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        vector<int> ans;\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                ans.push_back(matrix[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1502739,
                "title": "c-o-n-log-range-binary-search",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// count of number of elements smaller than current possible candidate for answer\\n    bool possible(vector<vector<int>>& grid, int k, int val){\\n        int n=grid.size();\\n        \\n        int i=0, j=n-1;\\n        int c=0;\\n        while(i<n && j>=0){\\n            if(grid[i][j]>val){\\n                j--;\\n            }else{\\n                c+=j+1;\\n                i++;\\n            }\\n        }\\n        return (c>=k);\\n    }\\n    int kthSmallest(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int l=grid[0][0], r=grid[n-1][n-1];  // minimum and maximum values possible in grid\\n        \\n        while(l<r){\\n            int m=l+(r-l)/2;\\n            if(possible(grid,k,m)){\\n                r=m;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// count of number of elements smaller than current possible candidate for answer\\n    bool possible(vector<vector<int>>& grid, int k, int val){\\n        int n=grid.size();\\n        \\n        int i=0, j=n-1;\\n        int c=0;\\n        while(i<n && j>=0){\\n            if(grid[i][j]>val){\\n                j--;\\n            }else{\\n                c+=j+1;\\n                i++;\\n            }\\n        }\\n        return (c>=k);\\n    }\\n    int kthSmallest(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int l=grid[0][0], r=grid[n-1][n-1];  // minimum and maximum values possible in grid\\n        \\n        while(l<r){\\n            int m=l+(r-l)/2;\\n            if(possible(grid,k,m)){\\n                r=m;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458791,
                "title": "kth-smallest-easy-to-understand-by-both-max-heap-as-wll-as-binary-search-optimal-sol",
                "content": "class Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n     /*   \\n        //by binary search \\n        int n=matrix.size();\\n        int low=matrix[0][0];\\n        int high=matrix[n-1][n-1];\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int cnt=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                cnt += upper_bound(matrix[i].begin(),matrix[i].end(),mid)-matrix[i].begin();\\n                \\n            }\\n            if(cnt<k)\\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid;\\n            }\\n        }\\n        return low;\\n        */\\n        \\n        //using max-heap\\n        priority_queue<int>pq;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix.size();j++)\\n            {\\n                pq.push(matrix[i][j]);\\n                if(pq.size()>k)\\n                {\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        return pq.top();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n     /*   \\n        //by binary search \\n        int n=matrix.size();\\n        int low=matrix[0][0];\\n        int high=matrix[n-1][n-1];\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int cnt=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                cnt += upper_bound(matrix[i].begin(),matrix[i].end(),mid)-matrix[i].begin();\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1339211,
                "title": "c-solution-using-binary-search-simple-and-clear",
                "content": "```\\n\\nint kthSmallest(vector<vector<int>>& matrix, int k)\\n    {\\n        int n = matrix.size();\\n        int low = matrix[0][0];\\n        int high = matrix[n - 1][n - 1];\\n        \\n        while(low < high)\\n        {\\n            int mid = (low + high) / 2;\\n            int count = 0;\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                count += upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();\\n            }\\n            \\n            if(count >= k)\\n            {\\n                high = mid;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return high;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\nint kthSmallest(vector<vector<int>>& matrix, int k)\\n    {\\n        int n = matrix.size();\\n        int low = matrix[0][0];\\n        int high = matrix[n - 1][n - 1];\\n        \\n        while(low < high)\\n        {\\n            int mid = (low + high) / 2;\\n            int count = 0;\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                count += upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();\\n            }\\n            \\n            if(count >= k)\\n            {\\n                high = mid;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return high;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1324393,
                "title": "python-merging-arrays-sorted-manner",
                "content": "My approach uses merging n arrays two at a time to get a linear sorted array of n x n elements and then kth index is our answer.\\n\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        def merge_two(a, b):\\n            (m, n) = (len(a), len(b))\\n            i = j = 0\\n            d = []\\n            while i < m and j < n:\\n                if a[i] <= b[j]:\\n                    d.append(a[i])\\n                    i += 1\\n                else:\\n                    d.append(b[j])\\n                    j += 1\\n            while i < m:\\n                d.append(a[i])\\n                i += 1\\n            while j < n:\\n                d.append(b[j])\\n                j += 1\\n\\n            return d\\n        \\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][k-1]\\n        ans = list(merge(matrix[0],matrix[1]))\\n        for i in range(2,n):\\n            ans=list(merge(ans,matrix[i]))\\n        return ans[k-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        def merge_two(a, b):\\n            (m, n) = (len(a), len(b))\\n            i = j = 0\\n            d = []\\n            while i < m and j < n:\\n                if a[i] <= b[j]:\\n                    d.append(a[i])\\n                    i += 1\\n                else:\\n                    d.append(b[j])\\n                    j += 1\\n            while i < m:\\n                d.append(a[i])\\n                i += 1\\n            while j < n:\\n                d.append(b[j])\\n                j += 1\\n\\n            return d\\n        \\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][k-1]\\n        ans = list(merge(matrix[0],matrix[1]))\\n        for i in range(2,n):\\n            ans=list(merge(ans,matrix[i]))\\n        return ans[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321856,
                "title": "java-easy-to-understand-simple-code",
                "content": "```\\nThe idea is to keep all values in heap, if heap size exceeds k, \\nthen remove one element from heap.\\nAt last, return peek number. that is the kth smallest number.\\n\\nNote:- This is one of the accepted solutions, but not the best one. \\n\\nTime: O(N * N * logN)\\nSpace: O(k)\\n```\\n```\\n\\nclass Solution {\\n    public int kthSmallest(int[][] M, int k) {\\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a, b) -> b - a);\\n        for(int[] R : M){\\n            for(int a : R){\\n                heap.add(a);\\n                if(heap.size() > k)\\n                    heap.poll();\\n            }\\n        }\\n        return heap.peek();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nThe idea is to keep all values in heap, if heap size exceeds k, \\nthen remove one element from heap.\\nAt last, return peek number. that is the kth smallest number.\\n\\nNote:- This is one of the accepted solutions, but not the best one. \\n\\nTime: O(N * N * logN)\\nSpace: O(k)\\n```\n```\\n\\nclass Solution {\\n    public int kthSmallest(int[][] M, int k) {\\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a, b) -> b - a);\\n        for(int[] R : M){\\n            for(int a : R){\\n                heap.add(a);\\n                if(heap.size() > k)\\n                    heap.poll();\\n            }\\n        }\\n        return heap.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321850,
                "title": "c-clean-brute-force-solution",
                "content": "**Time Complexity:** ```O((N ^ 2) * log(N))```\\nwhere ```N``` is the number of rows and columns.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        \\n        //This question requires direct brute-force approach....\\n        int n = matrix.size();\\n        n *= n;\\n        \\n        vector<int> v(n);\\n        int cz = 0;\\n\\t\\t\\n        //Push all elements of matrix into a vector\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[i].size(); j++){\\n                v[cz] = matrix[i][j];\\n\\t\\t\\t\\tcz++;\\n            }\\n        }\\n        \\n        //Sort the elements and print the k-th element...\\n        sort(v.begin(), v.end());\\n        return v[k - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```O((N ^ 2) * log(N))```\n```N```\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        \\n        //This question requires direct brute-force approach....\\n        int n = matrix.size();\\n        n *= n;\\n        \\n        vector<int> v(n);\\n        int cz = 0;\\n\\t\\t\\n        //Push all elements of matrix into a vector\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[i].size(); j++){\\n                v[cz] = matrix[i][j];\\n\\t\\t\\t\\tcz++;\\n            }\\n        }\\n        \\n        //Sort the elements and print the k-th element...\\n        sort(v.begin(), v.end());\\n        return v[k - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829764,
                "title": "kotlin-1-line-is-enough",
                "content": "```\\nfun kthSmallest(matrix: Array<IntArray>, k: Int) = matrix.flatMap { it.toList() }.sorted()[k-1]\\n```",
                "solutionTags": [],
                "code": "```\\nfun kthSmallest(matrix: Array<IntArray>, k: Int) = matrix.flatMap { it.toList() }.sorted()[k-1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 827290,
                "title": "python-saddleback-binary-search-140-148-ms-95-99",
                "content": "This is a variant of [240. Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/). The key point is that for given value ```mid```, it takes only ```O(n)``` times (because it is proprotional to the length of the diagonal) to determine how many elements less than ```mid```. Bearing this in mind, one should be able to make the concept into a code:\\n```\\ndef kthSmallest(self, matrix, k):\\n        n = len(matrix)\\n        lo, hi = matrix[0][0], matrix[-1][-1]\\n        \\n        while lo < hi:\\n            mid = (lo+hi) // 2\\n\\t\\t\\t\\n\\t\\t\\t# saddleback search\\n            p, q, c = n-1, 0, 0 #(p,q) moving point, c: count\\n            while 0<=p and q < n:\\n                if matrix[p][q] > mid:\\n                    p -= 1\\n                else:\\n                    c += p + 1 # update number of elm < mid; 1 is bec p being an ind\\n                    q += 1\\n                    \\n            # binary search\\n            if c < k:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n            \\n        return lo\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```mid```\n```O(n)```\n```mid```\n```\\ndef kthSmallest(self, matrix, k):\\n        n = len(matrix)\\n        lo, hi = matrix[0][0], matrix[-1][-1]\\n        \\n        while lo < hi:\\n            mid = (lo+hi) // 2\\n\\t\\t\\t\\n\\t\\t\\t# saddleback search\\n            p, q, c = n-1, 0, 0 #(p,q) moving point, c: count\\n            while 0<=p and q < n:\\n                if matrix[p][q] > mid:\\n                    p -= 1\\n                else:\\n                    c += p + 1 # update number of elm < mid; 1 is bec p being an ind\\n                    q += 1\\n                    \\n            # binary search\\n            if c < k:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n            \\n        return lo\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 780693,
                "title": "java-binary-search-100-time",
                "content": "Similar concepts used in this question https://leetcode.com/problems/search-a-2d-matrix-ii/\\nSolution for above question https://leetcode.com/problems/search-a-2d-matrix-ii/discuss/780711/Java-Binary-Search\\n\\n```\\nclass Solution {\\n    \\n    public int kthSmallest(int[][] matrix, int k) {\\n\\t    //top left is the smallest value, bottom right is the largest value in this matrix\\n        int smallest = matrix[0][0];\\n        int largest = matrix[matrix.length-1][matrix[0].length-1];        \\n        while (smallest < largest) {\\n            int medVal = smallest + (largest - smallest) / 2;\\n            if (getNumberOfElementsSmallerThenMedVal(matrix, medVal) >= k) {  //not return even count == k, since medVal might not exist in this matrix.\\n                largest = medVal;\\n            } else {  //count < k\\n                smallest = medVal + 1;\\n            }\\n        }\\n        return smallest;\\n    }\\n    \\n    private int getNumberOfElementsSmallerThenMedVal(int[][] matrix, int target) {\\n        int count = 0;\\n        int i = 0;\\n        int j = matrix.length - 1;\\n        while (i < matrix.length && j >= 0) {\\n            if (matrix[i][j] <= target) {\\n                count = count + j + 1;  //all the elements on the left hand side in this row are <= target\\n                i++;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public int kthSmallest(int[][] matrix, int k) {\\n\\t    //top left is the smallest value, bottom right is the largest value in this matrix\\n        int smallest = matrix[0][0];\\n        int largest = matrix[matrix.length-1][matrix[0].length-1];        \\n        while (smallest < largest) {\\n            int medVal = smallest + (largest - smallest) / 2;\\n            if (getNumberOfElementsSmallerThenMedVal(matrix, medVal) >= k) {  //not return even count == k, since medVal might not exist in this matrix.\\n                largest = medVal;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 754318,
                "title": "brute-force-to-optimal-clear-code-c",
                "content": "**1. Sorting:** \\n\\n**Approach:** Store them in a vector, sort them and return k-1 th elemnt in the array.\\n\\ttime: O(n^2 log(n^2)) space: O(n^2)\\n\\t\\n**2. Using minheap**\\n\\n**Approach:** Start with first row in the minheap and gradually pop and push the next element in same row\\nTime complexity : O(n* klogn) space : O(n)\\n```\\nstruct comp{\\n     bool operator()(pair<int, pair<int, int>>&p1, pair<int, pair<int, int>>&p2){\\n        return p1.first > p2.first;\\n    }\\n };\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        if(n == 0)return -1;\\n        // build a minheap\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, comp>q;\\n        // push the first element of each row in the heap\\n        for(int i = 0; i < n; ++i){\\n            q.push({matrix[i][0], {i, 0}});\\n        }\\n        int ans = -1;\\n        while(k--){\\n            pair<int, pair<int, int>> p = q.top(); q.pop();\\n            int i = p.second.first;\\n            int j = p.second.second;\\n            ans = p.first;\\n            if(j >= n-1)continue;\\n            q.push({matrix[i][j+1], {i, j+1}});\\n        }\\n        while(!q.empty())q.pop();\\n        return ans;\\n    }\\n};\\n```\\n**3. Binary search on the range** (Explained through comment)\\nTime: O(2n* log(maxElement in the matrix)))\\n```\\nclass Solution {\\npublic:\\n    int lesserThanEqualToMid(vector<vector<int>>& matrix, int num, int n){\\n        int count = 0;\\n        int row = n-1, col = 0; // start from right left corner\\n        while(row >= 0 && col < n){\\n            if(matrix[row][col] > num){\\n                row--; // that row is useless\\n            }\\n            else { // if lesserThanEqualToMid, all the above row elements in that col will be smaller or equal \\n                count += row+1;\\n                col++; // move to next col in same row\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        if(n == 0)return -1;\\n        int low = matrix[0][0], high = matrix[n-1][n-1], ans = -1;\\n        while(low <= high){\\n            int mid = low + ((high-low)>>1);\\n            int count = lesserThanEqualToMid(matrix, mid, n); // takes O(n+n time)\\n            cout<<count<<endl;\\n            if(count < k){\\n                low = mid+1;\\n            }\\n            else if(count == k){ // storing the mid as the ans because this mid can be or not in the matrix\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else if(count > k) { // to understand why ans is stored this time, use this eg: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 7, the reason is due to multiple occurences of 13, count will remain 8 finally so ans = -1\\n                ans = mid;\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Using stl for counting**\\n```\\n// binary search approach (time: O(2n* log(maxElement in the matrix)))\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        if(n == 0)return -1;\\n        int low = matrix[0][0], high = matrix[n-1][n-1], ans = -1;\\n        while(low <= high){\\n            int mid = low + ((high-low)>>1);\\n            int count = 0;\\n            for(int i = 0; i < n; ++i){\\n                count += upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin(); // stl is very helpful\\n            }\\n            if(count < k){\\n                low = mid+1;\\n            }\\n            else if(count == k){ // storing the mid as the ans because this mid can be or not in the matrix\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else if(count > k) { // to understand why ans is stored this time, use this eg: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 7, the reason is due to multiple occurences of 13, count will remain 8 finally so ans = -1\\n                ans = mid;\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nstruct comp{\\n     bool operator()(pair<int, pair<int, int>>&p1, pair<int, pair<int, int>>&p2){\\n        return p1.first > p2.first;\\n    }\\n };\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        if(n == 0)return -1;\\n        // build a minheap\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, comp>q;\\n        // push the first element of each row in the heap\\n        for(int i = 0; i < n; ++i){\\n            q.push({matrix[i][0], {i, 0}});\\n        }\\n        int ans = -1;\\n        while(k--){\\n            pair<int, pair<int, int>> p = q.top(); q.pop();\\n            int i = p.second.first;\\n            int j = p.second.second;\\n            ans = p.first;\\n            if(j >= n-1)continue;\\n            q.push({matrix[i][j+1], {i, j+1}});\\n        }\\n        while(!q.empty())q.pop();\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lesserThanEqualToMid(vector<vector<int>>& matrix, int num, int n){\\n        int count = 0;\\n        int row = n-1, col = 0; // start from right left corner\\n        while(row >= 0 && col < n){\\n            if(matrix[row][col] > num){\\n                row--; // that row is useless\\n            }\\n            else { // if lesserThanEqualToMid, all the above row elements in that col will be smaller or equal \\n                count += row+1;\\n                col++; // move to next col in same row\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        if(n == 0)return -1;\\n        int low = matrix[0][0], high = matrix[n-1][n-1], ans = -1;\\n        while(low <= high){\\n            int mid = low + ((high-low)>>1);\\n            int count = lesserThanEqualToMid(matrix, mid, n); // takes O(n+n time)\\n            cout<<count<<endl;\\n            if(count < k){\\n                low = mid+1;\\n            }\\n            else if(count == k){ // storing the mid as the ans because this mid can be or not in the matrix\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else if(count > k) { // to understand why ans is stored this time, use this eg: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 7, the reason is due to multiple occurences of 13, count will remain 8 finally so ans = -1\\n                ans = mid;\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// binary search approach (time: O(2n* log(maxElement in the matrix)))\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        if(n == 0)return -1;\\n        int low = matrix[0][0], high = matrix[n-1][n-1], ans = -1;\\n        while(low <= high){\\n            int mid = low + ((high-low)>>1);\\n            int count = 0;\\n            for(int i = 0; i < n; ++i){\\n                count += upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin(); // stl is very helpful\\n            }\\n            if(count < k){\\n                low = mid+1;\\n            }\\n            else if(count == k){ // storing the mid as the ans because this mid can be or not in the matrix\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else if(count > k) { // to understand why ans is stored this time, use this eg: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 7, the reason is due to multiple occurences of 13, count will remain 8 finally so ans = -1\\n                ans = mid;\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 85254,
                "title": "c-priority-queue-ac-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        priority_queue<int, vector<int>> pq;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                pq.emplace(matrix[i][j]);\\n                if (pq.size() > k) {\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        int result = pq.top();\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        priority_queue<int, vector<int>> pq;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                pq.emplace(matrix[i][j]);\\n                if (pq.size() > k) {\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        int result = pq.top();\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634064,
                "title": "c-easy-priority-queue-very-short-solution",
                "content": "# Approach\\n- Create a priority queue.\\n- Simply iterate through all the elements in the matrix:\\n  1) For each element, push it into the priority queue.\\n  2) If the size of the priority queue exceeds k, remove the largest element using q.pop().\\n- Retrun the top element of the priority queue, which is the kth smallest element.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(Nlogk) where N is number of elements in matrix.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        priority_queue<int> q;\\n        for(int r=0;r<n;r++){\\n            for(int c=0;c<n;c++){\\n                q.push(matrix[r][c]);\\n                if(q.size()>k)q.pop();\\n            }\\n        }\\n        return q.top();\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        priority_queue<int> q;\\n        for(int r=0;r<n;r++){\\n            for(int c=0;c<n;c++){\\n                q.push(matrix[r][c]);\\n                if(q.size()>k)q.pop();\\n            }\\n        }\\n        return q.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928449,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int lo = matrix[0][0];\\n        int hi = matrix[m-1][n-1]+1;\\n        while(lo < hi)\\n        {\\n            int mid = lo + (hi - lo) / 2;\\n            int count = 0,  j=n-1;\\n            for(int i = 0; i<m; i++)\\n            {\\n                while(j >= 0 && matrix[i][j] > mid)\\n                    j--;\\n                count += (j + 1);\\n            }\\n            if(count < k)\\n             lo=mid+1;\\n            else\\n            hi=mid;\\n        }\\n        return lo;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int lo = matrix[0][0];\\n        int hi = matrix[m-1][n-1]+1;\\n        while(lo < hi)\\n        {\\n            int mid = lo + (hi - lo) / 2;\\n            int count = 0,  j=n-1;\\n            for(int i = 0; i<m; i++)\\n            {\\n                while(j >= 0 && matrix[i][j] > mid)\\n                    j--;\\n                count += (j + 1);\\n            }\\n            if(count < k)\\n             lo=mid+1;\\n            else\\n            hi=mid;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835980,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        vector<int> ans;\\n        int t = matrix.size();\\n\\n         for(int i = 0; i<t;i++)\\n      {\\n          for(int j = 0; j<t;j++)\\n         {\\n            ans.push_back(matrix[i][j]);\\n         }\\n      }\\n      sort(ans.begin(), ans.end());\\n      return ans[k-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        vector<int> ans;\\n        int t = matrix.size();\\n\\n         for(int i = 0; i<t;i++)\\n      {\\n          for(int j = 0; j<t;j++)\\n         {\\n            ans.push_back(matrix[i][j]);\\n         }\\n      }\\n      sort(ans.begin(), ans.end());\\n      return ans[k-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787495,
                "title": "c-easy-and-fast-solution-using-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int> pq;\\n        int n = matrix.size();\\n\\n        for(int i=0;i<k;i++)\\n        pq.push(matrix[i/n][i%n]);\\n\\n        int r = k/n, c = k%n;\\n\\n        for(int i=r;i<n;i++)\\n        {\\n            for(int j=c;j<n;j++)\\n            {\\n                if(matrix[i][j]<pq.top())\\n                {\\n                    pq.pop();\\n                    pq.push(matrix[i][j]);\\n                }\\n                else\\n                break;\\n            }\\n            c=0;\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int> pq;\\n        int n = matrix.size();\\n\\n        for(int i=0;i<k;i++)\\n        pq.push(matrix[i/n][i%n]);\\n\\n        int r = k/n, c = k%n;\\n\\n        for(int i=r;i<n;i++)\\n        {\\n            for(int j=c;j<n;j++)\\n            {\\n                if(matrix[i][j]<pq.top())\\n                {\\n                    pq.pop();\\n                    pq.push(matrix[i][j]);\\n                }\\n                else\\n                break;\\n            }\\n            c=0;\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706987,
                "title": "easy-beginner-friendly-solution",
                "content": "# Intuition\\nPushed back all the element in a vector.Then sorted it and found the Kth smallest element.\\n\\n# Approach\\nBrute Force\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        \\n        vector<int> v;\\n        for(int i = 0; i<matrix.size();i++){\\n            for(int j =0 ; j<matrix.size();j++){\\n                v.push_back(matrix[i][j]);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        return v[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        \\n        vector<int> v;\\n        for(int i = 0; i<matrix.size();i++){\\n            for(int j =0 ; j<matrix.size();j++){\\n                v.push_back(matrix[i][j]);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        return v[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468435,
                "title": "c-o-n-upper-bound-binary-search",
                "content": "**Please upvote if you like this solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n       int low = matrix[0][0], n = matrix.size(), high = matrix[n-1][n-1],mid;\\n       \\n        while(low<high){\\n            mid = low + (high-low)/2;\\n            int count=0;\\n            for(int i=0;i<n;i++){\\n                count += upper_bound(matrix[i].begin(),matrix[i].end(),mid)-matrix[i].begin();\\n            }\\n            if(count<k){\\n                low = mid+1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        \\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n       int low = matrix[0][0], n = matrix.size(), high = matrix[n-1][n-1],mid;\\n       \\n        while(low<high){\\n            mid = low + (high-low)/2;\\n            int count=0;\\n            for(int i=0;i<n;i++){\\n                count += upper_bound(matrix[i].begin(),matrix[i].end(),mid)-matrix[i].begin();\\n            }\\n            if(count<k){\\n                low = mid+1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        \\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369122,
                "title": "beats-100-other-s-solutions",
                "content": "```\\nfrom bisect import bisect_right\\n\\nclass Solution:\\n    def countSmallerEqual(self, matrix, val):\\n        \"\"\"count number of values in a (horizontally and vertically sorted) matrix smaller or equal to the given value\"\"\"\\n        # # # Approach 1a : do binary search in each row (O(m log n) time) to count in each row how many values are less than or equal to the number in question\\n        # cnt = 0\\n        # n = len(matrix)\\n        # for row in matrix:\\n        #     print(row, cnt)\\n        #     low = 0\\n        #     high = n - 1\\n        #     if val >= row[high]:\\n        #         cnt += n\\n        #         continue\\n        #     elif val < row[0]:\\n        #         continue\\n        #     while low <= high:\\n        #         mid = (low + high) // 2\\n        #         if row[mid]==val and (mid == n-1 or row[mid+1] > row[mid]):\\n        #             cnt += mid + 1 # return mid+1\\n        #             break\\n        #         elif row[mid] < val and (mid < n and row[mid+1] > val):\\n        #             cnt += mid + 1 # return mid+1\\n        #             break      \\n        #         elif row[mid]==val or row[mid] < val:\\n        #             low = mid + 1\\n        #         else: # elif row[mid] > val\\n        #             high = mid - 1\\n        # return cnt\\n        #\\n        #\\n        # # Approach 1b : do binary search in each row (O(m log n) time) as in 1a but use bisect_right to make things easier!\\n        # n = len(matrix)\\n        # cnt = 0\\n        # for row_num in range(n):\\n        #     row = matrix[row_num]\\n        #     cnt += bisect_right(row, val)\\n        # return cnt\\n        #\\n        #\\n        # Approach 2: start top right and go left and down as appropriate (O(n) time)\\n        cnt = 0\\n        n = len(matrix)\\n        row_num = 0\\n        col_num = n-1\\n        while row_num < n and col_num >= 0:\\n            if val >= matrix[row_num][col_num]:\\n                cnt += col_num + 1\\n                row_num += 1\\n            else:\\n                col_num -= 1\\n        return cnt\\n        \\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        # 1  5  9\\n        # 10 11 13\\n        # 12 13 15\\n        \\n        # you can also use binary search and saddle search (special search in sorted matrix - used alone in e.g. https://leetcode.com/problems/search-a-2d-matrix-ii/)\\n        # you look at smallest and largest elements in the matrix and find the value in the middle, then see what k the number could take (i.e. how many numbers are smaller than it and how many larger than it - you can get this by counting the number less/more than it in each row using binary search) and then changing the range in which you are searching until you find it\\n        \\n        # get mid point\\n        low = matrix[0][0]\\n        high = matrix[-1][-1]\\n        while low < high:\\n            mid = (low+high) // 2\\n            rank = self.countSmallerEqual(matrix, mid)\\n            if rank < k:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        \\n        return low # or high, as they\\'ll be the same\\n        \\n        \\n        \\n        \\n        \\n        \\n        # # use a heap, but don\\'t populate all at once (otherwise that would be n**2 memory complexity)\\n        # # https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/1080253/Illustration-of-Solution-with-MinHeap\\n        # turns = 0\\n        # heap = [(matrix[0][0], 0, 0)]\\n        # visited = set((0,0))\\n        # while True:\\n        #     # 1  5  9\\n        #     # 10 11 13\\n        #     # 12 13 15\\n        #     turns += 1\\n        #     curr, i, j = heapq.heappop(heap)\\n        #     if turns == k:\\n        #         break\\n        #     # push onto heap the element below and to the right (as they will be next bigger)\\n        #     below = (i+1, j)\\n        #     if below not in visited and below[0] < len(matrix):\\n        #         heapq.heappush(heap, (matrix[below[0]][below[1]], below[0], below[1]))\\n        #         visited.add(below)\\n        #     right = (i, j+1)\\n        #     if right not in visited and right[1] < len(matrix[0]):\\n        #         heapq.heappush(heap, (matrix[right[0]][right[1]], right[0], right[1]))\\n        #         visited.add(right)        \\n        # return curr\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_right\\n\\nclass Solution:\\n    def countSmallerEqual(self, matrix, val):\\n        \"\"\"count number of values in a (horizontally and vertically sorted) matrix smaller or equal to the given value\"\"\"\\n        # # # Approach 1a : do binary search in each row (O(m log n) time) to count in each row how many values are less than or equal to the number in question\\n        # cnt = 0\\n        # n = len(matrix)\\n        # for row in matrix:\\n        #     print(row, cnt)\\n        #     low = 0\\n        #     high = n - 1\\n        #     if val >= row[high]:\\n        #         cnt += n\\n        #         continue\\n        #     elif val < row[0]:\\n        #         continue\\n        #     while low <= high:\\n        #         mid = (low + high) // 2\\n        #         if row[mid]==val and (mid == n-1 or row[mid+1] > row[mid]):\\n        #             cnt += mid + 1 # return mid+1\\n        #             break\\n        #         elif row[mid] < val and (mid < n and row[mid+1] > val):\\n        #             cnt += mid + 1 # return mid+1\\n        #             break      \\n        #         elif row[mid]==val or row[mid] < val:\\n        #             low = mid + 1\\n        #         else: # elif row[mid] > val\\n        #             high = mid - 1\\n        # return cnt\\n        #\\n        #\\n        # # Approach 1b : do binary search in each row (O(m log n) time) as in 1a but use bisect_right to make things easier!\\n        # n = len(matrix)\\n        # cnt = 0\\n        # for row_num in range(n):\\n        #     row = matrix[row_num]\\n        #     cnt += bisect_right(row, val)\\n        # return cnt\\n        #\\n        #\\n        # Approach 2: start top right and go left and down as appropriate (O(n) time)\\n        cnt = 0\\n        n = len(matrix)\\n        row_num = 0\\n        col_num = n-1\\n        while row_num < n and col_num >= 0:\\n            if val >= matrix[row_num][col_num]:\\n                cnt += col_num + 1\\n                row_num += 1\\n            else:\\n                col_num -= 1\\n        return cnt\\n        \\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        # 1  5  9\\n        # 10 11 13\\n        # 12 13 15\\n        \\n        # you can also use binary search and saddle search (special search in sorted matrix - used alone in e.g. https://leetcode.com/problems/search-a-2d-matrix-ii/)\\n        # you look at smallest and largest elements in the matrix and find the value in the middle, then see what k the number could take (i.e. how many numbers are smaller than it and how many larger than it - you can get this by counting the number less/more than it in each row using binary search) and then changing the range in which you are searching until you find it\\n        \\n        # get mid point\\n        low = matrix[0][0]\\n        high = matrix[-1][-1]\\n        while low < high:\\n            mid = (low+high) // 2\\n            rank = self.countSmallerEqual(matrix, mid)\\n            if rank < k:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        \\n        return low # or high, as they\\'ll be the same\\n        \\n        \\n        \\n        \\n        \\n        \\n        # # use a heap, but don\\'t populate all at once (otherwise that would be n**2 memory complexity)\\n        # # https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/1080253/Illustration-of-Solution-with-MinHeap\\n        # turns = 0\\n        # heap = [(matrix[0][0], 0, 0)]\\n        # visited = set((0,0))\\n        # while True:\\n        #     # 1  5  9\\n        #     # 10 11 13\\n        #     # 12 13 15\\n        #     turns += 1\\n        #     curr, i, j = heapq.heappop(heap)\\n        #     if turns == k:\\n        #         break\\n        #     # push onto heap the element below and to the right (as they will be next bigger)\\n        #     below = (i+1, j)\\n        #     if below not in visited and below[0] < len(matrix):\\n        #         heapq.heappush(heap, (matrix[below[0]][below[1]], below[0], below[1]))\\n        #         visited.add(below)\\n        #     right = (i, j+1)\\n        #     if right not in visited and right[1] < len(matrix[0]):\\n        #         heapq.heappush(heap, (matrix[right[0]][right[1]], right[0], right[1]))\\n        #         visited.add(right)        \\n        # return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368698,
                "title": "faster-than-98-81-using-python3-5-lines",
                "content": "```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        temp_arr=[]\\n        for i in matrix:\\n            temp_arr.extend(i)\\n        temp_arr.sort()\\n        return temp_arr[k-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        temp_arr=[]\\n        for i in matrix:\\n            temp_arr.extend(i)\\n        temp_arr.sort()\\n        return temp_arr[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368632,
                "title": "c-max-heap-binary-search-two-solutions-easy-solution",
                "content": "**Approach 1:  Max Heap keeps up to k elements \\u2705AC**\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int> pq; // Max-heap\\n        for(int i=0;i < matrix.size();i++){\\n            for(int j=0;j< matrix[0].size();j++){\\n                pq.push(matrix[i][j]);\\n                if(pq.size() > k){\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        return pq.top();\\n    }\\n};\\n\\nComplexity:\\nTime: O(M * N * logK), where M <= 300 is the number of rows, N <= 300 is the number of columns.\\nSpace: O(K), space for heap which stores up to k elements.\\n\\n```\\n\\n**Approach 2: Binary Search \\u2705AC**\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int low = matrix[0][0];\\n        int high = matrix[n-1][n-1];\\n        while(low < high){\\n            int mid  = low + (high - low)/2;\\n            int count = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                count += upper_bound(matrix[i].begin(),matrix[i].end(),mid) - matrix[i].begin();\\n            }\\n            \\n            if(count < k){\\n                low = mid+1;\\n            }\\n            else\\n            {\\n                high = mid;\\n            }\\n        }\\n        \\n        return low;\\n        \\n    }\\n};\\n\\nComplexity\\n\\nTime: O((M+N) * logD), where M <= 300 is the number of rows, N <= 300 is the number of columns, D <= 2*10^9 is the difference between the maximum element and the minimum element in the matrix.\\nSpace: O(1).\\n```\\n\\n**Do not forget to upvote if you like the post**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int> pq; // Max-heap\\n        for(int i=0;i < matrix.size();i++){\\n            for(int j=0;j< matrix[0].size();j++){\\n                pq.push(matrix[i][j]);\\n                if(pq.size() > k){\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        return pq.top();\\n    }\\n};\\n\\nComplexity:\\nTime: O(M * N * logK), where M <= 300 is the number of rows, N <= 300 is the number of columns.\\nSpace: O(K), space for heap which stores up to k elements.\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n = matrix.size();\\n        int low = matrix[0][0];\\n        int high = matrix[n-1][n-1];\\n        while(low < high){\\n            int mid  = low + (high - low)/2;\\n            int count = 0;\\n            for(int i=0;i<n;i++)\\n            {\\n                count += upper_bound(matrix[i].begin(),matrix[i].end(),mid) - matrix[i].begin();\\n            }\\n            \\n            if(count < k){\\n                low = mid+1;\\n            }\\n            else\\n            {\\n                high = mid;\\n            }\\n        }\\n        \\n        return low;\\n        \\n    }\\n};\\n\\nComplexity\\n\\nTime: O((M+N) * logD), where M <= 300 is the number of rows, N <= 300 is the number of columns, D <= 2*10^9 is the difference between the maximum element and the minimum element in the matrix.\\nSpace: O(1).\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2367164,
                "title": "c-linq-shortest",
                "content": "```\\npublic class Solution {\\n    public int KthSmallest(int[][] matrix, int k) {\\n        return matrix.SelectMany(x => x)\\n                    .OrderBy(x => x)\\n                    .ElementAt(k - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int KthSmallest(int[][] matrix, int k) {\\n        return matrix.SelectMany(x => x)\\n                    .OrderBy(x => x)\\n                    .ElementAt(k - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119437,
                "title": "cpp-binary-search-easy-solution",
                "content": "```\\nint binarySearch(vector<int>arr, int target){\\n        int low=0, high=arr.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(arr[mid]<=target){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return low;\\n    }\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int low=matrix[0][0];\\n        int high=matrix[n-1][n-1];\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            int count=0;\\n            for(int i=0;i<n;i++){\\n                count+=binarySearch(matrix[i],mid);\\n            }\\n            if(count<k){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return low;\\n    }",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nint binarySearch(vector<int>arr, int target){\\n        int low=0, high=arr.size()-1;\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(arr[mid]<=target){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return low;\\n    }\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int low=matrix[0][0];\\n        int high=matrix[n-1][n-1];\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            int count=0;\\n            for(int i=0;i<n;i++){\\n                count+=binarySearch(matrix[i],mid);\\n            }\\n            if(count<k){\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return low;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1898440,
                "title": "using-max-heap-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k){\\n        \\n       priority_queue<int>maxH;\\n        \\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                \\n                maxH.push(matrix[i][j]);\\n                \\n                if(maxH.size()>k){\\n                    maxH.pop();\\n                }\\n                \\n            }\\n        }\\n        return maxH.top();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k){\\n        \\n       priority_queue<int>maxH;\\n        \\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                \\n                maxH.push(matrix[i][j]);\\n                \\n                if(maxH.size()>k){\\n                    maxH.pop();\\n                }\\n                \\n            }\\n        }\\n        return maxH.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875885,
                "title": "c-clean-simple",
                "content": "\\n\\n``\\n\\n    class three\\n    {\\n        public:\\n        int val,row,col;  \\n    };\\n    \\n    class cmp\\n    {\\n        public:\\n        bool operator()(three a,three b)\\n        {\\n            return a.val>b.val;\\n        }\\n        \\n    };\\n    \\n    int kthSmallest(vector<vector<int>>&v, int k) \\n    {\\n        int n=v.size();\\n        priority_queue<three,vector<three>,cmp> pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            three num;\\n            num.val=v[i][0];\\n            num.row=i;\\n            num.col=0;\\n            pq.push(num);\\n        }\\n        \\n        while(k--)\\n        {\\n            if(k==0)\\n            {\\n                return pq.top().val;\\n            }\\n            three x=pq.top();\\n            pq.pop();\\n            int row=x.row;\\n            int col=x.col;\\n            if(col+1<n)\\n            {\\n                three num;\\n                num.val=v[row][col+1];\\n                num.row=row;\\n                num.col=col+1;\\n                pq.push(num);\\n            }\\n        }\\n        return 1;\\n    }",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "\\n\\n``\\n\\n    class three\\n    {\\n        public:\\n        int val,row,col;  \\n    };\\n    \\n    class cmp\\n    {\\n        public:\\n        bool operator()(three a,three b)\\n        {\\n            return a.val>b.val;\\n        }\\n        \\n    };\\n    \\n    int kthSmallest(vector<vector<int>>&v, int k) \\n    {\\n        int n=v.size();\\n        priority_queue<three,vector<three>,cmp> pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            three num;\\n            num.val=v[i][0];\\n            num.row=i;\\n            num.col=0;\\n            pq.push(num);\\n        }\\n        \\n        while(k--)\\n        {\\n            if(k==0)\\n            {\\n                return pq.top().val;\\n            }\\n            three x=pq.top();\\n            pq.pop();\\n            int row=x.row;\\n            int col=x.col;\\n            if(col+1<n)\\n            {\\n                three num;\\n                num.val=v[row][col+1];\\n                num.row=row;\\n                num.col=col+1;\\n                pq.push(num);\\n            }\\n        }\\n        return 1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1741704,
                "title": "python-heap-priority-queue-ii-very-easy-code",
                "content": "Kth Smallest Element in row-column sorted matrix-\\n**Explanation**\\nFor explanation refers: (http://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/1080253/Illustration-of-Solution-with-MinHeap)\\n**Code**\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        from heapq import heappush,heappop,heapify\\n        m,n=len(matrix),len(matrix[0])\\n        heap=[]\\n        s=set()\\n        heapify(heap)\\n        heappush(heap,(matrix[0][0],0,0))\\n        s.add((0,0))\\n        while k>1:\\n            _,i,j=heappop(heap)\\n            if j+1<n and (i,j+1) not in s:\\n                heappush(heap,(matrix[i][j+1],i,j+1))\\n                s.add((i,j+1))\\n            if i+1<m and (i+1,j) not in s:\\n                heappush(heap,(matrix[i+1][j],i+1,j))\\n                s.add((i+1,j))\\n            k-=1\\n        return heap[0][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        from heapq import heappush,heappop,heapify\\n        m,n=len(matrix),len(matrix[0])\\n        heap=[]\\n        s=set()\\n        heapify(heap)\\n        heappush(heap,(matrix[0][0],0,0))\\n        s.add((0,0))\\n        while k>1:\\n            _,i,j=heappop(heap)\\n            if j+1<n and (i,j+1) not in s:\\n                heappush(heap,(matrix[i][j+1],i,j+1))\\n                s.add((i,j+1))\\n            if i+1<m and (i+1,j) not in s:\\n                heappush(heap,(matrix[i+1][j],i+1,j))\\n                s.add((i+1,j))\\n            k-=1\\n        return heap[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667400,
                "title": "java-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if(matrix == null || matrix.length == 0) {\\n            return 0;\\n        }\\n        int row = matrix.length, col = matrix[0].length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (a[0] - b[0]));\\n        for(int i=0; i<col; i++) {\\n            pq.offer(new int[]{matrix[0][i], 0, i});\\n        }\\n        while(!pq.isEmpty() && k-1 > 0) {\\n            int[] curr = pq.poll();\\n            int x = curr[1], y = curr[2];\\n            if(x+1 < row) {\\n                pq.offer(new int[]{matrix[x+1][y], x+1, y});\\n            }\\n            k--;\\n        }\\n        return pq.peek()[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        if(matrix == null || matrix.length == 0) {\\n            return 0;\\n        }\\n        int row = matrix.length, col = matrix[0].length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (a[0] - b[0]));\\n        for(int i=0; i<col; i++) {\\n            pq.offer(new int[]{matrix[0][i], 0, i});\\n        }\\n        while(!pq.isEmpty() && k-1 > 0) {\\n            int[] curr = pq.poll();\\n            int x = curr[1], y = curr[2];\\n            if(x+1 < row) {\\n                pq.offer(new int[]{matrix[x+1][y], x+1, y});\\n            }\\n            k--;\\n        }\\n        return pq.peek()[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662483,
                "title": "c-min-heap-tc-o-klogn",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    typedef pair<int, pair<int, int>> ppi;\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<ppi, vector<ppi>, greater<ppi>> Q;\\n        int n = matrix.size();\\n        for (int i = 0; i < n; ++i) {\\n            Q.push({matrix[i][0], {i, 0}});\\n        }\\n        --k;\\n        while(k--) {\\n            auto node = Q.top();\\n            Q.pop();\\n            if (node.second.second + 1 < n) {\\n                Q.push({matrix[node.second.first][node.second.second + 1], {node.second.first, node.second.second + 1}});\\n            }\\n        }\\n        return Q.top().first;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    typedef pair<int, pair<int, int>> ppi;\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<ppi, vector<ppi>, greater<ppi>> Q;\\n        int n = matrix.size();\\n        for (int i = 0; i < n; ++i) {\\n            Q.push({matrix[i][0], {i, 0}});\\n        }\\n        --k;\\n        while(k--) {\\n            auto node = Q.top();\\n            Q.pop();\\n            if (node.second.second + 1 < n) {\\n                Q.push({matrix[node.second.first][node.second.second + 1], {node.second.first, node.second.second + 1}});\\n            }\\n        }\\n        return Q.top().first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457186,
                "title": "o-n-log-max-log-n-binary-search",
                "content": "We know that each element lies in [-1e9, 1e9] so we can Binary Search for the element in this range.\\n```\\n#define ll long long int\\nclass Solution {\\n    ll n,ans;\\npublic:\\n    bool check(vector<vector<int>>& a,ll k,ll m){\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i][n-1]<=m)\\n                cnt+=n;\\n            else{\\n                int ind=lower_bound(a[i].begin(),a[i].end(),m+1)-a[i].begin();\\n                cnt+=ind;\\n            }\\n        }\\n        if(cnt>=k)\\n            ans=min(ans,m);\\n        return cnt>=k;\\n    }\\n    \\n    int kthSmallest(vector<vector<int>>& a, int k) {\\n        ll h=1e9+10;\\n        ll l=(-1*h);\\n        n=a.size();\\n        ans=h;\\n        while(l<=h){\\n            ll m=l+(h-l)/2;\\n            if(check(a,k,m))\\n                h=m-1;\\n            else\\n                l=m+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\n    ll n,ans;\\npublic:\\n    bool check(vector<vector<int>>& a,ll k,ll m){\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i][n-1]<=m)\\n                cnt+=n;\\n            else{\\n                int ind=lower_bound(a[i].begin(),a[i].end(),m+1)-a[i].begin();\\n                cnt+=ind;\\n            }\\n        }\\n        if(cnt>=k)\\n            ans=min(ans,m);\\n        return cnt>=k;\\n    }\\n    \\n    int kthSmallest(vector<vector<int>>& a, int k) {\\n        ll h=1e9+10;\\n        ll l=(-1*h);\\n        n=a.size();\\n        ans=h;\\n        while(l<=h){\\n            ll m=l+(h-l)/2;\\n            if(check(a,k,m))\\n                h=m-1;\\n            else\\n                l=m+1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370437,
                "title": "binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n        \\n    int searchMatrix(vector<vector<int>>& matrix,int n,int target) {\\n            \\n           int i=n-1,j=0,cnt=0; \\n            \\n           while(i>=0 && j<n){\\n              if(matrix[i][j]>target){\\n                   i--;   \\n              }\\n              else{\\n                  cnt+=i+1;   \\n                  j++;    \\n              }\\n           } \\n            \\n      return cnt;          \\n    }\\n        \\n    int kthSmallest(vector<vector<int>>& matrix,int k) {\\n       \\n         int n=matrix.size();\\n         int start=matrix[0][0],end=matrix[n-1][n-1]; \\n            \\n         while(start<end){\\n                \\n           int mid=start+(end-start)/2;\\n           int idx=searchMatrix(matrix,n,mid);\\n                 \\n           if(idx<k){\\n              start=mid+1;\\n           }\\n           else\\n              end=mid;      \\n         }  \\n            \\n    return start; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        \\n    int searchMatrix(vector<vector<int>>& matrix,int n,int target) {\\n            \\n           int i=n-1,j=0,cnt=0; \\n            \\n           while(i>=0 && j<n){\\n              if(matrix[i][j]>target){\\n                   i--;   \\n              }\\n              else{\\n                  cnt+=i+1;   \\n                  j++;    \\n              }\\n           } \\n            \\n      return cnt;          \\n    }\\n        \\n    int kthSmallest(vector<vector<int>>& matrix,int k) {\\n       \\n         int n=matrix.size();\\n         int start=matrix[0][0],end=matrix[n-1][n-1]; \\n            \\n         while(start<end){\\n                \\n           int mid=start+(end-start)/2;\\n           int idx=searchMatrix(matrix,n,mid);\\n                 \\n           if(idx<k){\\n              start=mid+1;\\n           }\\n           else\\n              end=mid;      \\n         }  \\n            \\n    return start; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334402,
                "title": "java-binary-search-0ms-beats-100-t-c-o-nlog-max-min-s-c-o-1",
                "content": "\\n    public int kthSmallest(int[][] matrix, int k) {\\n        \\n        int n = matrix.length, lo = matrix[0][0], hi = matrix[n - 1][n - 1], ans = -1;\\n        \\n        while(lo <= hi){\\n            \\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if(isPossible(matrix, mid, n, k)){\\n                ans = mid;\\n                hi = mid - 1;\\n            }else\\n                lo = mid + 1;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean isPossible(int[][] matrix, int d, int n, int k){\\n        \\n        int count = 0, i = n - 1, j = 0;\\n        \\n        while(i >= 0 && j < n){\\n            \\n            int val = matrix[i][j];\\n            if(val > d)\\n                i--;\\n            else{\\n                j++;\\n                count += i + 1;\\n            }\\n        }\\n        \\n        return count >= k;\\n    }",
                "solutionTags": [],
                "code": "\\n    public int kthSmallest(int[][] matrix, int k) {\\n        \\n        int n = matrix.length, lo = matrix[0][0], hi = matrix[n - 1][n - 1], ans = -1;\\n        \\n        while(lo <= hi){\\n            \\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if(isPossible(matrix, mid, n, k)){\\n                ans = mid;\\n                hi = mid - 1;\\n            }else\\n                lo = mid + 1;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean isPossible(int[][] matrix, int d, int n, int k){\\n        \\n        int count = 0, i = n - 1, j = 0;\\n        \\n        while(i >= 0 && j < n){\\n            \\n            int val = matrix[i][j];\\n            if(val > d)\\n                i--;\\n            else{\\n                j++;\\n                count += i + 1;\\n            }\\n        }\\n        \\n        return count >= k;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1323334,
                "title": "python-making-1d-list-then-sort-and-that-beats-97-runtime",
                "content": "1. Traverse the matrix and add the element in a 1D list\\n2. Sort the list in ascending order\\n3. return the (k-1)th element from the sorted list\\n\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        ans=[]\\n\\t\\t\\n        for i in matrix:\\n            for j in i:\\n                ans.append(j)\\n\\t\\t\\t\\t\\n        return sorted(ans)[k-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        ans=[]\\n\\t\\t\\n        for i in matrix:\\n            for j in i:\\n                ans.append(j)\\n\\t\\t\\t\\t\\n        return sorted(ans)[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323037,
                "title": "c-2-approaches-priority-queue-binary-search",
                "content": "More about interview Questions : https://github.com/MAZHARMIK/Interview_DS_Algo\\n\\nFull July Challenge  Solution till now: https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Arrays/2-D%20Array/Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix.cpp\\n\\n```\\n//Approach-1 (Naive Priority_queue approach O(n*nlog(k))\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int> pq;\\n        \\n        for(vector<int>& vec : matrix) {\\n            for(int &x : vec) {\\n                pq.push(x);\\n                if(pq.size() > k)\\n                    pq.pop();\\n            }\\n        }\\n        \\n        return pq.top();\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Binary Search : O(log(max-min) * n)\\nclass Solution {\\npublic:\\n    int n;\\n    int lessThanEqualToCount(vector<vector<int>>& matrix, int target) {\\n        int i = 0, j = n-1;\\n        int count = 0;\\n\\t\\t//O(n) -> Someone please correct me here\\n        while(i < n) {\\n          while(j >= 0 && matrix[i][j] > target)\\n            j--;\\n          count += j+1;\\n          i++;\\n        }\\n        return count;\\n    }\\n\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n          n = matrix.size();\\n          int l = matrix[0][0];\\n          int h = matrix[n-1][n-1];\\n\\t\\t\\t\\n\\t\\t  //O(log(max-min))\\n          while(l <= h) {\\n            int mid = l + (h-l)/2;\\n            int dist = lessThanEqualToCount(matrix, mid);\\n            if(dist < k)\\n              l = mid+1;\\n            else\\n              h = mid-1;\\n          }\\n          return l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Naive Priority_queue approach O(n*nlog(k))\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int> pq;\\n        \\n        for(vector<int>& vec : matrix) {\\n            for(int &x : vec) {\\n                pq.push(x);\\n                if(pq.size() > k)\\n                    pq.pop();\\n            }\\n        }\\n        \\n        return pq.top();\\n    }\\n};\\n```\n```\\n//Approach-2 (Binary Search : O(log(max-min) * n)\\nclass Solution {\\npublic:\\n    int n;\\n    int lessThanEqualToCount(vector<vector<int>>& matrix, int target) {\\n        int i = 0, j = n-1;\\n        int count = 0;\\n\\t\\t//O(n) -> Someone please correct me here\\n        while(i < n) {\\n          while(j >= 0 && matrix[i][j] > target)\\n            j--;\\n          count += j+1;\\n          i++;\\n        }\\n        return count;\\n    }\\n\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n          n = matrix.size();\\n          int l = matrix[0][0];\\n          int h = matrix[n-1][n-1];\\n\\t\\t\\t\\n\\t\\t  //O(log(max-min))\\n          while(l <= h) {\\n            int mid = l + (h-l)/2;\\n            int dist = lessThanEqualToCount(matrix, mid);\\n            if(dist < k)\\n              l = mid+1;\\n            else\\n              h = mid-1;\\n          }\\n          return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322605,
                "title": "c-using-binary-search-with-explanation",
                "content": "```\\nint check(vector<vector<int>>& a, int mid)\\n    {\\n        int n=a.size();\\n        int i=n-1; //bottom row\\n        int j=0; //first column\\n        int ans=0;\\n        //we will start from bottom rows left most element \\n        while(i>=0 && j<n)\\n        {\\n            if(a[i][j]>mid) i--; //if element i greater than mid , go upwards \\n                             //because there are smaller elements upward not rightwards\\n            else\\n            {\\n                ans+=i+1; /**element less than mid counts which colmumn number\\n                         because elements before it will already be less than mid and present element\\n                        (sorted matrix) **/\\n                j++; //check rightwards \\n            }\\n        }\\n        return ans; //count of elements less than and equal to mid\\n    }\\n    int kthSmallest(vector<vector<int>>& a, int k) {\\n        int n=a.size();\\n        int i=a[0][0]; //lowest\\n        int j=a[n-1][n-1]; //highest\\n        while(i<j)\\n        {\\n            int mid=(j+i)/2; //mid \\n            int count=check(a,mid); //check elements le than and equal to mid \\n            if(count<k) i=mid+1; /**if elements les than it are les than k\\n                                which means we have to check for element greater than mid\\n                                & who has count=k **/ \\n            else j=mid; //else check for smaller number who has check less than present count \\n        }\\n        return i;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nint check(vector<vector<int>>& a, int mid)\\n    {\\n        int n=a.size();\\n        int i=n-1; //bottom row\\n        int j=0; //first column\\n        int ans=0;\\n        //we will start from bottom rows left most element \\n        while(i>=0 && j<n)\\n        {\\n            if(a[i][j]>mid) i--; //if element i greater than mid , go upwards \\n                             //because there are smaller elements upward not rightwards\\n            else\\n            {\\n                ans+=i+1; /**element less than mid counts which colmumn number\\n                         because elements before it will already be less than mid and present element\\n                        (sorted matrix) **/\\n                j++; //check rightwards \\n            }\\n        }\\n        return ans; //count of elements less than and equal to mid\\n    }\\n    int kthSmallest(vector<vector<int>>& a, int k) {\\n        int n=a.size();\\n        int i=a[0][0]; //lowest\\n        int j=a[n-1][n-1]; //highest\\n        while(i<j)\\n        {\\n            int mid=(j+i)/2; //mid \\n            int count=check(a,mid); //check elements le than and equal to mid \\n            if(count<k) i=mid+1; /**if elements les than it are les than k\\n                                which means we have to check for element greater than mid\\n                                & who has count=k **/ \\n            else j=mid; //else check for smaller number who has check less than present count \\n        }\\n        return i;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1322399,
                "title": "c-easy-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                pq.push(matrix[i][j]);\\n                if(pq.size()>k)pq.pop();\\n            }\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                pq.push(matrix[i][j]);\\n                if(pq.size()>k)pq.pop();\\n            }\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322098,
                "title": "kth-smallest-element-c-using-priority-queue-minheap",
                "content": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int M = matrix.size(), N = matrix[0].size();\\n        int cnt = 0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                pq.push(matrix[i][j]);\\n            }\\n        }\\n\\t\\t// kth element from the top in priority_queue is the kth smallest element\\n        while (k > 1) {\\n            pq.pop();\\n            k--;\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int M = matrix.size(), N = matrix[0].size();\\n        int cnt = 0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                pq.push(matrix[i][j]);\\n            }\\n        }\\n\\t\\t// kth element from the top in priority_queue is the kth smallest element\\n        while (k > 1) {\\n            pq.pop();\\n            k--;\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321974,
                "title": "go-binary-search-solution-16ms-100",
                "content": "\\n![image](https://assets.leetcode.com/users/images/befe3752-48ce-4726-b08d-8295db0a986d_1625647533.533686.png)\\n\\n\\nBinary search solution:\\n\\n```\\nfunc kthSmallest(matrix [][]int, k int) int {\\n    n := len(matrix)\\n    start, end, mid := matrix[0][0], matrix[n-1][n-1], 0\\n    count := 0\\n    for start < end {\\n        mid = start + (end-start)/2\\n        count = countLessEqual(matrix, mid)\\n        if count < k {\\n            start = mid + 1\\n            continue\\n        }\\n        \\n        end = mid\\n    }\\n    return start\\n}\\n\\nfunc countLessEqual(matrix [][]int, mid int) int {\\n    count := 0\\n    n := len(matrix)\\n    for r, c := n-1, 0; r >= 0 && c < n; {\\n        if matrix[r][c] > mid {\\n            r--\\n            continue\\n        }\\n        \\n        count += r+1\\n        c++\\n    }\\n    \\n    return count\\n}\\n\\n",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "\\n![image](https://assets.leetcode.com/users/images/befe3752-48ce-4726-b08d-8295db0a986d_1625647533.533686.png)\\n\\n\\nBinary search solution:\\n\\n```\\nfunc kthSmallest(matrix [][]int, k int) int {\\n    n := len(matrix)\\n    start, end, mid := matrix[0][0], matrix[n-1][n-1], 0\\n    count := 0\\n    for start < end {\\n        mid = start + (end-start)/2\\n        count = countLessEqual(matrix, mid)\\n        if count < k {\\n            start = mid + 1\\n            continue\\n        }\\n        \\n        end = mid\\n    }\\n    return start\\n}\\n\\nfunc countLessEqual(matrix [][]int, mid int) int {\\n    count := 0\\n    n := len(matrix)\\n    for r, c := n-1, 0; r >= 0 && c < n; {\\n        if matrix[r][c] > mid {\\n            r--\\n            continue\\n        }\\n        \\n        count += r+1\\n        c++\\n    }\\n    \\n    return count\\n}\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1190024,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int> pq;\\n        for(int i = 0;i<matrix.size();i++)\\n        {\\n            for(int j= 0;j<matrix[0].size();j++)\\n            {\\n                pq.push(matrix[i][j]);\\n                if(pq.size()>k)\\n                {\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        priority_queue<int> pq;\\n        for(int i = 0;i<matrix.size();i++)\\n        {\\n            for(int j= 0;j<matrix[0].size();j++)\\n            {\\n                pq.push(matrix[i][j]);\\n                if(pq.size()>k)\\n                {\\n                    pq.pop();\\n                }\\n            }\\n        }\\n        return pq.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098919,
                "title": "simple-java-binary-search-with-0-nlog-max-min-beats-100",
                "content": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int length = matrix.length;\\n        int low = matrix[0][0];\\n        int high = matrix[length-1][length-1];\\n        \\n        while(low<high) {\\n            int mid = (low+high)/2;\\n            if(myCount(matrix, mid, length) < k) {\\n                low = mid + 1;\\n            } else {\\n                high = mid; // note here even if its equal to k we need one more iteration so that we can get the correct value\\n            }\\n        }\\n        return high; // here we can return high or low either\\n    }\\n    \\n    private int myCount(int[][] matrix, int valueToCompare, int length) {\\n        int row = 0;\\n        int col = length - 1;\\n        int count = 0;\\n        \\n        while(row<length && col>=0) {\\n            if(matrix[row][col] <= valueToCompare) {\\n                count += col + 1;\\n                row ++;\\n            } else {\\n                col --;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int length = matrix.length;\\n        int low = matrix[0][0];\\n        int high = matrix[length-1][length-1];\\n        \\n        while(low<high) {\\n            int mid = (low+high)/2;\\n            if(myCount(matrix, mid, length) < k) {\\n                low = mid + 1;\\n            } else {\\n                high = mid; // note here even if its equal to k we need one more iteration so that we can get the correct value\\n            }\\n        }\\n        return high; // here we can return high or low either\\n    }\\n    \\n    private int myCount(int[][] matrix, int valueToCompare, int length) {\\n        int row = 0;\\n        int col = length - 1;\\n        int count = 0;\\n        \\n        while(row<length && col>=0) {\\n            if(matrix[row][col] <= valueToCompare) {\\n                count += col + 1;\\n                row ++;\\n            } else {\\n                col --;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999681,
                "title": "java-two-approaches-priority-queue-binary-search-solution",
                "content": "**Priority Queue**\\n```\\nclass Solution {\\n    \\n    public class Element implements Comparable<Element>{\\n        int row,col,val;\\n        \\n        public Element(int row, int col, int val){\\n            this.row = row;\\n            this.col = col;\\n            this.val = val;\\n        }\\n        \\n        @Override\\n        public int compareTo(Element e){\\n            return this.val - e.val;\\n        }\\n    }\\n    \\n    public int kthSmallest(int[][] matrix, int k) {\\n        \\n        PriorityQueue<Element> q = new PriorityQueue<Element>();\\n        \\n        //add first row into the priority queue\\n        for(int i=0;i<matrix[0].length;i++)\\n            q.add(new Element(0,i, matrix[0][i]));\\n        \\n        for(int i=0;i<k-1;i++){\\n            Element e = q.poll();\\n            if (e.row+1 < matrix.length)\\n                q.add(new Element(e.row+1, e.col, matrix[e.row+1][e.col]));    \\n        }\\n        \\n        return q.peek().val;\\n    }\\n}\\n```\\n**Binary Search**\\n```\\n      class Solution {\\n\\t  public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        int left = matrix[0][0];\\n        int right = matrix[n-1][n-1];\\n        \\n        int result = 0;\\n        while (left <= right){\\n            int mid = left + (right - left) / 2;\\n            int count = countSmallerThanMid(mid, matrix);\\n            if (count < k)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return left;\\n    }\\n    \\n    // count how many elements are there lesser than the mid\\n    private int countSmallerThanMid(int mid, int[][] matrix){\\n        int n  = matrix.length;\\n        int j = n-1;\\n        int count = 0;\\n        \\n        for (int i=0;i<n;i++){\\n            while (j >= 0 && matrix[i][j] > mid)\\n                j--;\\n            count += j+1;\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public class Element implements Comparable<Element>{\\n        int row,col,val;\\n        \\n        public Element(int row, int col, int val){\\n            this.row = row;\\n            this.col = col;\\n            this.val = val;\\n        }\\n        \\n        @Override\\n        public int compareTo(Element e){\\n            return this.val - e.val;\\n        }\\n    }\\n    \\n    public int kthSmallest(int[][] matrix, int k) {\\n        \\n        PriorityQueue<Element> q = new PriorityQueue<Element>();\\n        \\n        //add first row into the priority queue\\n        for(int i=0;i<matrix[0].length;i++)\\n            q.add(new Element(0,i, matrix[0][i]));\\n        \\n        for(int i=0;i<k-1;i++){\\n            Element e = q.poll();\\n            if (e.row+1 < matrix.length)\\n                q.add(new Element(e.row+1, e.col, matrix[e.row+1][e.col]));    \\n        }\\n        \\n        return q.peek().val;\\n    }\\n}\\n```\n```\\n      class Solution {\\n\\t  public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        int left = matrix[0][0];\\n        int right = matrix[n-1][n-1];\\n        \\n        int result = 0;\\n        while (left <= right){\\n            int mid = left + (right - left) / 2;\\n            int count = countSmallerThanMid(mid, matrix);\\n            if (count < k)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return left;\\n    }\\n    \\n    // count how many elements are there lesser than the mid\\n    private int countSmallerThanMid(int mid, int[][] matrix){\\n        int n  = matrix.length;\\n        int j = n-1;\\n        int count = 0;\\n        \\n        for (int i=0;i<n;i++){\\n            while (j >= 0 && matrix[i][j] > mid)\\n                j--;\\n            count += j+1;\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 924778,
                "title": "c-solution-using-priority-queue-easy-implementation-o-klong",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint kthSmallest(vector<vector<int>>& matrix, int k) {\\n\\n\\n\\t\\t\\tint m = matrix.size();\\n\\n\\t\\t\\tif (m == 0) return 0;\\n\\n\\t\\t\\tint n = matrix[0].size();\\n\\n\\t\\t\\tif (n == 0) return 0;\\n\\n\\t\\t\\tpriority_queue<int> pq;\\n\\n\\n\\t\\t\\tfor (int i=0; i<m; i++)\\n\\t\\t\\t\\tfor (int j=0; j<n; j++){\\n\\t\\t\\t\\t\\tpq.push(matrix[i][j]);\\n\\t\\t\\t\\t\\tif (pq.size() > k)\\n\\t\\t\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\treturn pq.top();\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint kthSmallest(vector<vector<int>>& matrix, int k) {\\n\\n\\n\\t\\t\\tint m = matrix.size();\\n\\n\\t\\t\\tif (m == 0) return 0;\\n\\n\\t\\t\\tint n = matrix[0].size();\\n\\n\\t\\t\\tif (n == 0) return 0;\\n\\n\\t\\t\\tpriority_queue<int> pq;\\n\\n\\n\\t\\t\\tfor (int i=0; i<m; i++)\\n\\t\\t\\t\\tfor (int j=0; j<n; j++){\\n\\t\\t\\t\\t\\tpq.push(matrix[i][j]);\\n\\t\\t\\t\\t\\tif (pq.size() > k)\\n\\t\\t\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 715335,
                "title": "javascript-one-liner",
                "content": "```\\nvar kthSmallest = function(matrix, k) {\\n    return matrix.flat().sort((a,b)=>a-b)[k-1];\\n};",
                "solutionTags": [],
                "code": "```\\nvar kthSmallest = function(matrix, k) {\\n    return matrix.flat().sort((a,b)=>a-b)[k-1];\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 657336,
                "title": "two-solutions-heap-and-binary-search-faster-than-100",
                "content": "First straightforward answer is to use BFS. The time complexity will be around O(k) but we\\'ll have to use some space(O(N^2)) to track visited cells. \\n```\\n    private class Point {\\n        int x;\\n        int y;\\n        int val;\\n        public Point(int x, int y, int val) {\\n            this.x = x;\\n            this.y = y;\\n            this.val = val;\\n        }\\n    }\\n    \\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        PriorityQueue<Point> minHeap = new PriorityQueue<Point>((\\n            (p1, p2) -> p1.val - p2.val\\n        ));\\n        boolean[][] visited = new boolean[n][n];\\n        minHeap.add(new Point(0, 0, matrix[0][0]));\\n        visited[0][0] = true;\\n        while (!minHeap.isEmpty() && k > 1) {\\n            Point curr = minHeap.poll();\\n            int x = curr.x, y = curr.y;\\n            if (y + 1 < n && !visited[x][y + 1]) {\\n                minHeap.add(new Point(x, y + 1, matrix[x][y + 1]));\\n                visited[x][y + 1] = true;\\n            }\\n            if (x + 1 < n && !visited[x + 1][y]) {\\n                minHeap.add(new Point(x + 1, y, matrix[x + 1][y]));\\n                visited[x + 1][y] = true;\\n            }\\n            k--;\\n        }\\n        return minHeap.poll().val;\\n    }\\n```\\n\\n\\n\\nSecond solution is to binary search the answer. So the question breaks down to two parts, binary cut the answer range and try to determine the count. Because of it\\'s sorted by rows and cols, we can easily make the count function O(N). So the time for this solution is O(NlogN).\\n```\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        int l = matrix[0][0];\\n        int r = matrix[n - 1][n - 1];\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (count(matrix, mid) < k) {\\n                l = mid + 1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    // return the smaller or equal value count of target\\n    private int count(int[][] A, int target) {\\n        int n = A.length;\\n        int ans = 0;\\n        int j = n - 1;\\n        for (int i = 0; i < n; i++) {\\n            while (j >= 0 && A[i][j] > target) j--;\\n            if (j == -1) break;\\n            ans += (j + 1);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    private class Point {\\n        int x;\\n        int y;\\n        int val;\\n        public Point(int x, int y, int val) {\\n            this.x = x;\\n            this.y = y;\\n            this.val = val;\\n        }\\n    }\\n    \\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        PriorityQueue<Point> minHeap = new PriorityQueue<Point>((\\n            (p1, p2) -> p1.val - p2.val\\n        ));\\n        boolean[][] visited = new boolean[n][n];\\n        minHeap.add(new Point(0, 0, matrix[0][0]));\\n        visited[0][0] = true;\\n        while (!minHeap.isEmpty() && k > 1) {\\n            Point curr = minHeap.poll();\\n            int x = curr.x, y = curr.y;\\n            if (y + 1 < n && !visited[x][y + 1]) {\\n                minHeap.add(new Point(x, y + 1, matrix[x][y + 1]));\\n                visited[x][y + 1] = true;\\n            }\\n            if (x + 1 < n && !visited[x + 1][y]) {\\n                minHeap.add(new Point(x + 1, y, matrix[x + 1][y]));\\n                visited[x + 1][y] = true;\\n            }\\n            k--;\\n        }\\n        return minHeap.poll().val;\\n    }\\n```\n```\\n    public int kthSmallest(int[][] matrix, int k) {\\n        int n = matrix.length;\\n        int l = matrix[0][0];\\n        int r = matrix[n - 1][n - 1];\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (count(matrix, mid) < k) {\\n                l = mid + 1;\\n            } else {\\n                r = mid;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    // return the smaller or equal value count of target\\n    private int count(int[][] A, int target) {\\n        int n = A.length;\\n        int ans = 0;\\n        int j = n - 1;\\n        for (int i = 0; i < n; i++) {\\n            while (j >= 0 && A[i][j] > target) j--;\\n            if (j == -1) break;\\n            ans += (j + 1);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 644781,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n\\n  public int kthSmallest(int[][] matrix, int k) {\\n      int m = matrix.length, n = matrix[0].length;\\n      int low = matrix[0][0], high = matrix[m - 1][n - 1];\\n        while (low <= high) {\\n            int mid = low+(high - low) / 2 ;\\n            int count = countNums(matrix,mid);\\n            if (count < k)\\n                low = mid + 1;\\n            else\\n                high = mid-1;\\n        }\\n        return low;\\n  }\\n  //Counts the numbers less than mid, using the sorted matrix search pattern.\\n    private int countNums(int[][] matrix,int mid){\\n        int count = 0;\\n        int i = 0;\\n        int j = matrix[0].length-1;   // initialize start to top right corner\\n\\t\\t\\n        while(i<matrix.length&&j>=0){\\n            if(matrix[i][j]<=mid){\\n                count = count + j +1;    // adds j+1 elements, as column indexes are before current element\\n                i++;                                  // move to next row for bigger match\\n            } else{\\n                j--;                                  // move to previous column for smaller match\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n  public int kthSmallest(int[][] matrix, int k) {\\n      int m = matrix.length, n = matrix[0].length;\\n      int low = matrix[0][0], high = matrix[m - 1][n - 1];\\n        while (low <= high) {\\n            int mid = low+(high - low) / 2 ;\\n            int count = countNums(matrix,mid);\\n            if (count < k)\\n                low = mid + 1;\\n            else\\n                high = mid-1;\\n        }\\n        return low;\\n  }\\n  //Counts the numbers less than mid, using the sorted matrix search pattern.\\n    private int countNums(int[][] matrix,int mid){\\n        int count = 0;\\n        int i = 0;\\n        int j = matrix[0].length-1;   // initialize start to top right corner\\n\\t\\t\\n        while(i<matrix.length&&j>=0){\\n            if(matrix[i][j]<=mid){\\n                count = count + j +1;    // adds j+1 elements, as column indexes are before current element\\n                i++;                                  // move to next row for bigger match\\n            } else{\\n                j--;                                  // move to previous column for smaller match\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 624955,
                "title": "python-binary-search-o-nlogx",
                "content": "Time complexity is O(NlogX), while X = max(matrix) - min(matrix)\\nDefine a new function to find how many numbers are less than the mid. Then use the binary search in the main function.\\n\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        n = len(matrix)\\n        L = matrix[0][0]\\n        R = matrix[-1][-1]\\n        while L < R:\\n            mid = L + (R-L)//2\\n            temp = self.search_less_than_mid(matrix, mid, n)\\n            if temp < k:\\n                L = mid + 1\\n            else:\\n                R = mid \\n        return L\\n        \\n    def search_less_than_mid(self, matrix, target, n):\\n        cnt = 0\\n        i = n - 1\\n        j = 0\\n        while i >= 0 and j < n:\\n            if matrix[i][j] <= target:\\n                j += 1\\n                cnt += i+1\\n            else:\\n                i -= 1\\n        return cnt",
                "solutionTags": [],
                "code": "Time complexity is O(NlogX), while X = max(matrix) - min(matrix)\\nDefine a new function to find how many numbers are less than the mid. Then use the binary search in the main function.\\n\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        n = len(matrix)\\n        L = matrix[0][0]\\n        R = matrix[-1][-1]\\n        while L < R:\\n            mid = L + (R-L)//2\\n            temp = self.search_less_than_mid(matrix, mid, n)\\n            if temp < k:\\n                L = mid + 1\\n            else:\\n                R = mid \\n        return L\\n        \\n    def search_less_than_mid(self, matrix, target, n):\\n        cnt = 0\\n        i = n - 1\\n        j = 0\\n        while i >= 0 and j < n:\\n            if matrix[i][j] <= target:\\n                j += 1\\n                cnt += i+1\\n            else:\\n                i -= 1\\n        return cnt",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565034,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1565402,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1567584,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1566346,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1913602,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1573409,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1569104,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 2006413,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1575265,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1573586,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1565034,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1565402,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1567584,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1566346,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1913602,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1573409,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1569104,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 2006413,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1575265,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1573586,
                "content": [
                    {
                        "username": "amrinders433",
                        "content": "# Kth Smallest Element in a Sorted Matrix\\n![image](https://assets.leetcode.com/users/images/dc1a846a-126c-49cb-b9fa-e7a529d86182_1614142241.31893.png)\\n"
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "thank you for the best explaination"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process in this [article](https://medium.com/brain-framework/kth-smallest-element-in-sorted-matrix-b20400cf878e). Hope it helps !"
                    },
                    {
                        "username": "devilsplay",
                        "content": "Thank you very  much"
                    },
                    {
                        "username": "Ben_Van",
                        "content": "Right now since the arrays are in \\'non-degreasing order\\' according to the problem description, we had better move this question  from\\'Algorithm\\' to the category of \\'Harware/Mechanical/Lubrication\\' .\\nOh wait, there is no such a category on Leetcode? Then it is a good time to add one!"
                    },
                    {
                        "username": "vv_1801",
                        "content": "Hey Guys, \\nHere is the link to the video solution for this question by **alGOds**.\\n**https://youtu.be/G5wLN4UweAM**\\nIt has the **perfect explanation** to solve this using **binary search** along with some other optimisations."
                    },
                    {
                        "username": "argonaut16",
                        "content": "The example test cases are not illustrative; it would be better if they included something like `matrix=[[1,2],[1,3]]` and `k=2` here."
                    },
                    {
                        "username": "apsharam",
                        "content": "Following test case failed for me:\\n![image](https://assets.leetcode.com/users/ashram/image_1580946697.png)\\n\\nHow I understand the question, kth smallest element in Matrix mean\\n\\n1 is the first smallest element\\n2 is the second smallest element\\n3 is the third smallest element\\n\\nSo for k=2, the answer should be 2 right?"
                    },
                    {
                        "username": "kiShubham",
                        "content": "[1 ,1, 2, 3 ] ;now look at 2nd smallest its 1 ., im not saying to convert the 2d array in single array this will increase tc drastically ,but u can use to visualize the question  "
                    },
                    {
                        "username": "LivingHell",
                        "content": "There\\'s another 1 in the matrix and question specifically said to return kth smallest not the kth distinct one. "
                    },
                    {
                        "username": "OT_Chen",
                        "content": "I've seen multiple solutions using binary search to narrow down the `[lo, hi]` to get `mid = (hi - lo) / 2` until the count of elements smaller mid is exactly `k`. \\n\\nThey all directly return the `mid` as result to represent mid is the kth-smallest element in array. But how can we be sure that `mid` really exist in array?\\n\\nI can understand the priority-queue solution and merge sort solution. But for binary search, the `mid existence problem` still bothers me."
                    },
                    {
                        "username": "nikalinov",
                        "content": "It can be proved with contradiction. Suppose the final `mid` does not exist in the table and for it to be the answer, there should be at least k numbers less than or equal to `mid` (`count(mid) >= k` in the code).\n\nHowever, if it does not exist in the matrix, there is no number equal to `mid`, so all previous numbers are less than `mid`. Therefore, there must exist some number `mid'` which does exist in the matrix and is less than the found `mid` and for which `count(mid') >= k` as well: let the existing number before `mid` be `num`, `mid` > `num`, so if we take `num` as `mid'`, then obviously `mid' >= num` and `count(mid) == count(mid') >= k`.\n\nThat is a contradiction since we have checked the search space `[1, mid - 1]` and `mid` is the smallest element for which `count(mid) >= k` is true, so the only possible scenario is `mid == mid'`.\n\nFor example, take a matrix `[[4, 5, 8], [7, 9, 12], [10, 13, 15]]`, `k = 6`, the order is `4, 5, 7, 8, 9, 10, 12, 13, 15`. Suppose the final `mid` is `11`, so `count(11) >= 6`. Obviously, as there is no `11` in the table, all numbers before are strictly less than 11, which implies that there must be some number which is the biggest number before `11`: `10`, and for that number `count(10) == count(11) >= 6`. Considering that, the situation when the final `mid` is `11` is impossible since we check `[1, 10]` and we will find `10` as the answer. \n\nHope that is more or less clear."
                    },
                    {
                        "username": "coder42032",
                        "content": "yeah i also have same problem."
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH  | |  BEATS 95%\\nThis problem is similar to finding median in row and column wise sorted matrix, and in this question we are already provided with midean i.e \\'k\\'.\\n\\nLOGIC: suppose you convert the given matrix into a sorted linear array (1D array) , in this array the 1st smallest no. will be at 1st postion , 5th smallest no. will be at 5th position and so on for others also, so if we are given find k=8 smallest no. then it will be at 8th position or we can say there will be 8 numbers before it (if we exclude the no. then 7 numbers will be before it). SO we need to calculate how many numbers are before it for k=8 , 8 numbers should be before the number.\\n\\n1. Use binary search to find a middle number and check if \\'k\\' numbers are less then it or not.\\n2. if \\'k\\' numbers are less than the number(i.e middle element form binary search) then update start to start=mid+1 to check a potential number ahead.\\n3. else update end \\n4. Once we are out of loop return start which actually holds the number for which \\'k\\' elements are less then it."
                    },
                    {
                        "username": "phoenix2talent",
                        "content": "My range shrinks in every iteration of binary search. If the mid (= low + (high-low)/2) is not present in matrix, it will result in some condition < or >=. This will shift the bounds of the range. It is necessary that these bounds will converge around an element in the matrix, because of the way we count the number of smaller elements. If my mid keeps on lying between elements present in matrix, the condition will force the mid to move in either direction closer to an element present in the matrix."
                    },
                    {
                        "username": "punter",
                        "content": "when & is used with top(), the code does not work as expected.\\nCould someone please explain why?"
                    }
                ]
            },
            {
                "id": 1572678,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "https://github.com/hqztrue/LeetCodeSolutions/blob/master/378.%20Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix.pdf\\nFor small values of k, this algorithm is better than O(n).\\n\\nAnd this paper gives the optimal solution O(sqrt(k)) when k is small: Generalized Selection and Ranking: Sorted Matrices."
                    },
                    {
                        "username": "alex108",
                        "content": "When I supply the following input (for Java), I get a seemingly incorrect answer of \"200\":\\n\\n[[1,200,300],[10,11,18],[12,19,22]]\\n4\\n\\nWhen sorted, the input looks like:\\n1,10,11,12,18,19,22,200,300\\n\\nThis means that the correct answer should be 12, right?  Am I mis-understanding the problem somehow?"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "it is mention that matrix is sorted in both row and column wise,\\nyour test case is wrong\\n"
                    },
                    {
                        "username": "tungpham",
                        "content": "I still don\\'t fully understand the problem. From the example, since everything is sorted, isn\\'t it the equivalent of going from top to bottom, left to right, k steps to get to the k smallest element? "
                    },
                    {
                        "username": "IlyaChernikov",
                        "content": "[@ajaynairarun](/ajaynairarun) I don\\'t get it too. What does the `k-th` element mean? Which ways can we go to find it? The description is not clear for me at all. I tried to map 1D-index to 2D-index and return matrix value of it and it passed around ~30% of all test cases"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "if there is duplicates the method you mentioned wont work right?\nand in the question it is mentioned (EACH row in ascending order)"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(378)Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix"
                    },
                    {
                        "username": "fkie4",
                        "content": "too hard"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Information to solvers:\nGuys there is a test case that says input :\n[[1,2],[1,3]]\nMeaning that rows are only sorted left to right and top to bottom it is not necessary that end of a row element at i will be less that first element at i+1th row.\nor else the solution would have been \n```\nclass Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\n       int n = matrix.size();\n       int targetRow = (k%n)?((k/n)):(k/n)-1;\n       int targetColumn = (k%n == 0)? n-1 : (k%n)-1;\n       cout<<targetRow<<\" \"<<targetColumn<<endl;\n       return  matrix[targetRow][targetColumn];\n    }\n};\n```"
                    },
                    {
                        "username": "kiodrvme",
                        "content": "The binary search solution could be written in one line\\n```\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        return matrix[0][0] + bisect_left(range(matrix[0][0], matrix[-1][-1]), k, key=lambda mid: sum(bisect.bisect(row, mid) for row in matrix))\\n```"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "I tried to attempt this question as\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int t = sqrt(k);\\n        k = k - t;\\n        int i = 0, j = 0;\\n        bool p;\\n        while(i < t && j < t){\\n            if(k==0){\\n                return p ? matrix[i][t]  : matrix[t][j];\\n            }\\n            if(k and matrix[i][t] <= matrix[t][j]){\\n                i++; k--; p=1;\\n            }\\n            else if(k and matrix[i][t] > matrix[t][j]){\\n                j++; k--; p=0;\\n            }\\n        }\\n        return 0; \\n    }\\n};\\n```\\nbut it is showing RUNTIME error"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Following solutions can be used:\\n1. We can use an auxiliary array, where each index of array will store the current column index for each row. Initially, all the elements will point to 0th row of the array. Now, we can traverse this array k times to find the minimum element and then increase the column number by 1 for that row. This approach will have time complexity as O(n*k).\\n\\n2. An optimisation on above approach will be to use a min heap. Store all the elements of the first column in following format : (value, row, column) in a min heap. Now, repeat the steps k times, where we get the minimum element from the min heap i.e. very first element of the heap, store the element of next column into the top of the heap and min heapify from the top of the heap. Time complexity of this will be: O(N + K* Log(N)). "
                    },
                    {
                        "username": "Unnatimishra_123",
                        "content": "        n=len(matrix)\\n        l=float(\\'inf\\')\\n        r=float(\\'-inf\\')\\n\\n        for i in range(n):\\n            l=min(l,matrix[i][0])\\n            r=max(r,matrix[i][n-1])\\n\\n\\n        while l < r:\\n            mid = (l + (r - l) //2)\\n            x=0\\n            for i in range(n):\\n                up=bisect.bisect_right(matrix[i],mid)\\n                x+=up\\n\\n            if x < k:  \\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n\\n"
                    }
                ]
            },
            {
                "id": 1571839,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "https://github.com/hqztrue/LeetCodeSolutions/blob/master/378.%20Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix.pdf\\nFor small values of k, this algorithm is better than O(n).\\n\\nAnd this paper gives the optimal solution O(sqrt(k)) when k is small: Generalized Selection and Ranking: Sorted Matrices."
                    },
                    {
                        "username": "alex108",
                        "content": "When I supply the following input (for Java), I get a seemingly incorrect answer of \"200\":\\n\\n[[1,200,300],[10,11,18],[12,19,22]]\\n4\\n\\nWhen sorted, the input looks like:\\n1,10,11,12,18,19,22,200,300\\n\\nThis means that the correct answer should be 12, right?  Am I mis-understanding the problem somehow?"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "it is mention that matrix is sorted in both row and column wise,\\nyour test case is wrong\\n"
                    },
                    {
                        "username": "tungpham",
                        "content": "I still don\\'t fully understand the problem. From the example, since everything is sorted, isn\\'t it the equivalent of going from top to bottom, left to right, k steps to get to the k smallest element? "
                    },
                    {
                        "username": "IlyaChernikov",
                        "content": "[@ajaynairarun](/ajaynairarun) I don\\'t get it too. What does the `k-th` element mean? Which ways can we go to find it? The description is not clear for me at all. I tried to map 1D-index to 2D-index and return matrix value of it and it passed around ~30% of all test cases"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "if there is duplicates the method you mentioned wont work right?\nand in the question it is mentioned (EACH row in ascending order)"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(378)Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix"
                    },
                    {
                        "username": "fkie4",
                        "content": "too hard"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Information to solvers:\nGuys there is a test case that says input :\n[[1,2],[1,3]]\nMeaning that rows are only sorted left to right and top to bottom it is not necessary that end of a row element at i will be less that first element at i+1th row.\nor else the solution would have been \n```\nclass Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\n       int n = matrix.size();\n       int targetRow = (k%n)?((k/n)):(k/n)-1;\n       int targetColumn = (k%n == 0)? n-1 : (k%n)-1;\n       cout<<targetRow<<\" \"<<targetColumn<<endl;\n       return  matrix[targetRow][targetColumn];\n    }\n};\n```"
                    },
                    {
                        "username": "kiodrvme",
                        "content": "The binary search solution could be written in one line\\n```\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        return matrix[0][0] + bisect_left(range(matrix[0][0], matrix[-1][-1]), k, key=lambda mid: sum(bisect.bisect(row, mid) for row in matrix))\\n```"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "I tried to attempt this question as\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int t = sqrt(k);\\n        k = k - t;\\n        int i = 0, j = 0;\\n        bool p;\\n        while(i < t && j < t){\\n            if(k==0){\\n                return p ? matrix[i][t]  : matrix[t][j];\\n            }\\n            if(k and matrix[i][t] <= matrix[t][j]){\\n                i++; k--; p=1;\\n            }\\n            else if(k and matrix[i][t] > matrix[t][j]){\\n                j++; k--; p=0;\\n            }\\n        }\\n        return 0; \\n    }\\n};\\n```\\nbut it is showing RUNTIME error"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Following solutions can be used:\\n1. We can use an auxiliary array, where each index of array will store the current column index for each row. Initially, all the elements will point to 0th row of the array. Now, we can traverse this array k times to find the minimum element and then increase the column number by 1 for that row. This approach will have time complexity as O(n*k).\\n\\n2. An optimisation on above approach will be to use a min heap. Store all the elements of the first column in following format : (value, row, column) in a min heap. Now, repeat the steps k times, where we get the minimum element from the min heap i.e. very first element of the heap, store the element of next column into the top of the heap and min heapify from the top of the heap. Time complexity of this will be: O(N + K* Log(N)). "
                    },
                    {
                        "username": "Unnatimishra_123",
                        "content": "        n=len(matrix)\\n        l=float(\\'inf\\')\\n        r=float(\\'-inf\\')\\n\\n        for i in range(n):\\n            l=min(l,matrix[i][0])\\n            r=max(r,matrix[i][n-1])\\n\\n\\n        while l < r:\\n            mid = (l + (r - l) //2)\\n            x=0\\n            for i in range(n):\\n                up=bisect.bisect_right(matrix[i],mid)\\n                x+=up\\n\\n            if x < k:  \\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n\\n"
                    }
                ]
            },
            {
                "id": 1571944,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "https://github.com/hqztrue/LeetCodeSolutions/blob/master/378.%20Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix.pdf\\nFor small values of k, this algorithm is better than O(n).\\n\\nAnd this paper gives the optimal solution O(sqrt(k)) when k is small: Generalized Selection and Ranking: Sorted Matrices."
                    },
                    {
                        "username": "alex108",
                        "content": "When I supply the following input (for Java), I get a seemingly incorrect answer of \"200\":\\n\\n[[1,200,300],[10,11,18],[12,19,22]]\\n4\\n\\nWhen sorted, the input looks like:\\n1,10,11,12,18,19,22,200,300\\n\\nThis means that the correct answer should be 12, right?  Am I mis-understanding the problem somehow?"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "it is mention that matrix is sorted in both row and column wise,\\nyour test case is wrong\\n"
                    },
                    {
                        "username": "tungpham",
                        "content": "I still don\\'t fully understand the problem. From the example, since everything is sorted, isn\\'t it the equivalent of going from top to bottom, left to right, k steps to get to the k smallest element? "
                    },
                    {
                        "username": "IlyaChernikov",
                        "content": "[@ajaynairarun](/ajaynairarun) I don\\'t get it too. What does the `k-th` element mean? Which ways can we go to find it? The description is not clear for me at all. I tried to map 1D-index to 2D-index and return matrix value of it and it passed around ~30% of all test cases"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "if there is duplicates the method you mentioned wont work right?\nand in the question it is mentioned (EACH row in ascending order)"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(378)Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix"
                    },
                    {
                        "username": "fkie4",
                        "content": "too hard"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Information to solvers:\nGuys there is a test case that says input :\n[[1,2],[1,3]]\nMeaning that rows are only sorted left to right and top to bottom it is not necessary that end of a row element at i will be less that first element at i+1th row.\nor else the solution would have been \n```\nclass Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\n       int n = matrix.size();\n       int targetRow = (k%n)?((k/n)):(k/n)-1;\n       int targetColumn = (k%n == 0)? n-1 : (k%n)-1;\n       cout<<targetRow<<\" \"<<targetColumn<<endl;\n       return  matrix[targetRow][targetColumn];\n    }\n};\n```"
                    },
                    {
                        "username": "kiodrvme",
                        "content": "The binary search solution could be written in one line\\n```\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        return matrix[0][0] + bisect_left(range(matrix[0][0], matrix[-1][-1]), k, key=lambda mid: sum(bisect.bisect(row, mid) for row in matrix))\\n```"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "I tried to attempt this question as\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int t = sqrt(k);\\n        k = k - t;\\n        int i = 0, j = 0;\\n        bool p;\\n        while(i < t && j < t){\\n            if(k==0){\\n                return p ? matrix[i][t]  : matrix[t][j];\\n            }\\n            if(k and matrix[i][t] <= matrix[t][j]){\\n                i++; k--; p=1;\\n            }\\n            else if(k and matrix[i][t] > matrix[t][j]){\\n                j++; k--; p=0;\\n            }\\n        }\\n        return 0; \\n    }\\n};\\n```\\nbut it is showing RUNTIME error"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Following solutions can be used:\\n1. We can use an auxiliary array, where each index of array will store the current column index for each row. Initially, all the elements will point to 0th row of the array. Now, we can traverse this array k times to find the minimum element and then increase the column number by 1 for that row. This approach will have time complexity as O(n*k).\\n\\n2. An optimisation on above approach will be to use a min heap. Store all the elements of the first column in following format : (value, row, column) in a min heap. Now, repeat the steps k times, where we get the minimum element from the min heap i.e. very first element of the heap, store the element of next column into the top of the heap and min heapify from the top of the heap. Time complexity of this will be: O(N + K* Log(N)). "
                    },
                    {
                        "username": "Unnatimishra_123",
                        "content": "        n=len(matrix)\\n        l=float(\\'inf\\')\\n        r=float(\\'-inf\\')\\n\\n        for i in range(n):\\n            l=min(l,matrix[i][0])\\n            r=max(r,matrix[i][n-1])\\n\\n\\n        while l < r:\\n            mid = (l + (r - l) //2)\\n            x=0\\n            for i in range(n):\\n                up=bisect.bisect_right(matrix[i],mid)\\n                x+=up\\n\\n            if x < k:  \\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n\\n"
                    }
                ]
            },
            {
                "id": 1575222,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "https://github.com/hqztrue/LeetCodeSolutions/blob/master/378.%20Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix.pdf\\nFor small values of k, this algorithm is better than O(n).\\n\\nAnd this paper gives the optimal solution O(sqrt(k)) when k is small: Generalized Selection and Ranking: Sorted Matrices."
                    },
                    {
                        "username": "alex108",
                        "content": "When I supply the following input (for Java), I get a seemingly incorrect answer of \"200\":\\n\\n[[1,200,300],[10,11,18],[12,19,22]]\\n4\\n\\nWhen sorted, the input looks like:\\n1,10,11,12,18,19,22,200,300\\n\\nThis means that the correct answer should be 12, right?  Am I mis-understanding the problem somehow?"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "it is mention that matrix is sorted in both row and column wise,\\nyour test case is wrong\\n"
                    },
                    {
                        "username": "tungpham",
                        "content": "I still don\\'t fully understand the problem. From the example, since everything is sorted, isn\\'t it the equivalent of going from top to bottom, left to right, k steps to get to the k smallest element? "
                    },
                    {
                        "username": "IlyaChernikov",
                        "content": "[@ajaynairarun](/ajaynairarun) I don\\'t get it too. What does the `k-th` element mean? Which ways can we go to find it? The description is not clear for me at all. I tried to map 1D-index to 2D-index and return matrix value of it and it passed around ~30% of all test cases"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "if there is duplicates the method you mentioned wont work right?\nand in the question it is mentioned (EACH row in ascending order)"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(378)Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix"
                    },
                    {
                        "username": "fkie4",
                        "content": "too hard"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Information to solvers:\nGuys there is a test case that says input :\n[[1,2],[1,3]]\nMeaning that rows are only sorted left to right and top to bottom it is not necessary that end of a row element at i will be less that first element at i+1th row.\nor else the solution would have been \n```\nclass Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\n       int n = matrix.size();\n       int targetRow = (k%n)?((k/n)):(k/n)-1;\n       int targetColumn = (k%n == 0)? n-1 : (k%n)-1;\n       cout<<targetRow<<\" \"<<targetColumn<<endl;\n       return  matrix[targetRow][targetColumn];\n    }\n};\n```"
                    },
                    {
                        "username": "kiodrvme",
                        "content": "The binary search solution could be written in one line\\n```\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        return matrix[0][0] + bisect_left(range(matrix[0][0], matrix[-1][-1]), k, key=lambda mid: sum(bisect.bisect(row, mid) for row in matrix))\\n```"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "I tried to attempt this question as\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int t = sqrt(k);\\n        k = k - t;\\n        int i = 0, j = 0;\\n        bool p;\\n        while(i < t && j < t){\\n            if(k==0){\\n                return p ? matrix[i][t]  : matrix[t][j];\\n            }\\n            if(k and matrix[i][t] <= matrix[t][j]){\\n                i++; k--; p=1;\\n            }\\n            else if(k and matrix[i][t] > matrix[t][j]){\\n                j++; k--; p=0;\\n            }\\n        }\\n        return 0; \\n    }\\n};\\n```\\nbut it is showing RUNTIME error"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Following solutions can be used:\\n1. We can use an auxiliary array, where each index of array will store the current column index for each row. Initially, all the elements will point to 0th row of the array. Now, we can traverse this array k times to find the minimum element and then increase the column number by 1 for that row. This approach will have time complexity as O(n*k).\\n\\n2. An optimisation on above approach will be to use a min heap. Store all the elements of the first column in following format : (value, row, column) in a min heap. Now, repeat the steps k times, where we get the minimum element from the min heap i.e. very first element of the heap, store the element of next column into the top of the heap and min heapify from the top of the heap. Time complexity of this will be: O(N + K* Log(N)). "
                    },
                    {
                        "username": "Unnatimishra_123",
                        "content": "        n=len(matrix)\\n        l=float(\\'inf\\')\\n        r=float(\\'-inf\\')\\n\\n        for i in range(n):\\n            l=min(l,matrix[i][0])\\n            r=max(r,matrix[i][n-1])\\n\\n\\n        while l < r:\\n            mid = (l + (r - l) //2)\\n            x=0\\n            for i in range(n):\\n                up=bisect.bisect_right(matrix[i],mid)\\n                x+=up\\n\\n            if x < k:  \\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n\\n"
                    }
                ]
            },
            {
                "id": 2043569,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "https://github.com/hqztrue/LeetCodeSolutions/blob/master/378.%20Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix.pdf\\nFor small values of k, this algorithm is better than O(n).\\n\\nAnd this paper gives the optimal solution O(sqrt(k)) when k is small: Generalized Selection and Ranking: Sorted Matrices."
                    },
                    {
                        "username": "alex108",
                        "content": "When I supply the following input (for Java), I get a seemingly incorrect answer of \"200\":\\n\\n[[1,200,300],[10,11,18],[12,19,22]]\\n4\\n\\nWhen sorted, the input looks like:\\n1,10,11,12,18,19,22,200,300\\n\\nThis means that the correct answer should be 12, right?  Am I mis-understanding the problem somehow?"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "it is mention that matrix is sorted in both row and column wise,\\nyour test case is wrong\\n"
                    },
                    {
                        "username": "tungpham",
                        "content": "I still don\\'t fully understand the problem. From the example, since everything is sorted, isn\\'t it the equivalent of going from top to bottom, left to right, k steps to get to the k smallest element? "
                    },
                    {
                        "username": "IlyaChernikov",
                        "content": "[@ajaynairarun](/ajaynairarun) I don\\'t get it too. What does the `k-th` element mean? Which ways can we go to find it? The description is not clear for me at all. I tried to map 1D-index to 2D-index and return matrix value of it and it passed around ~30% of all test cases"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "if there is duplicates the method you mentioned wont work right?\nand in the question it is mentioned (EACH row in ascending order)"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(378)Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix"
                    },
                    {
                        "username": "fkie4",
                        "content": "too hard"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Information to solvers:\nGuys there is a test case that says input :\n[[1,2],[1,3]]\nMeaning that rows are only sorted left to right and top to bottom it is not necessary that end of a row element at i will be less that first element at i+1th row.\nor else the solution would have been \n```\nclass Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\n       int n = matrix.size();\n       int targetRow = (k%n)?((k/n)):(k/n)-1;\n       int targetColumn = (k%n == 0)? n-1 : (k%n)-1;\n       cout<<targetRow<<\" \"<<targetColumn<<endl;\n       return  matrix[targetRow][targetColumn];\n    }\n};\n```"
                    },
                    {
                        "username": "kiodrvme",
                        "content": "The binary search solution could be written in one line\\n```\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        return matrix[0][0] + bisect_left(range(matrix[0][0], matrix[-1][-1]), k, key=lambda mid: sum(bisect.bisect(row, mid) for row in matrix))\\n```"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "I tried to attempt this question as\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int t = sqrt(k);\\n        k = k - t;\\n        int i = 0, j = 0;\\n        bool p;\\n        while(i < t && j < t){\\n            if(k==0){\\n                return p ? matrix[i][t]  : matrix[t][j];\\n            }\\n            if(k and matrix[i][t] <= matrix[t][j]){\\n                i++; k--; p=1;\\n            }\\n            else if(k and matrix[i][t] > matrix[t][j]){\\n                j++; k--; p=0;\\n            }\\n        }\\n        return 0; \\n    }\\n};\\n```\\nbut it is showing RUNTIME error"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Following solutions can be used:\\n1. We can use an auxiliary array, where each index of array will store the current column index for each row. Initially, all the elements will point to 0th row of the array. Now, we can traverse this array k times to find the minimum element and then increase the column number by 1 for that row. This approach will have time complexity as O(n*k).\\n\\n2. An optimisation on above approach will be to use a min heap. Store all the elements of the first column in following format : (value, row, column) in a min heap. Now, repeat the steps k times, where we get the minimum element from the min heap i.e. very first element of the heap, store the element of next column into the top of the heap and min heapify from the top of the heap. Time complexity of this will be: O(N + K* Log(N)). "
                    },
                    {
                        "username": "Unnatimishra_123",
                        "content": "        n=len(matrix)\\n        l=float(\\'inf\\')\\n        r=float(\\'-inf\\')\\n\\n        for i in range(n):\\n            l=min(l,matrix[i][0])\\n            r=max(r,matrix[i][n-1])\\n\\n\\n        while l < r:\\n            mid = (l + (r - l) //2)\\n            x=0\\n            for i in range(n):\\n                up=bisect.bisect_right(matrix[i],mid)\\n                x+=up\\n\\n            if x < k:  \\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n\\n"
                    }
                ]
            },
            {
                "id": 1927452,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "https://github.com/hqztrue/LeetCodeSolutions/blob/master/378.%20Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix.pdf\\nFor small values of k, this algorithm is better than O(n).\\n\\nAnd this paper gives the optimal solution O(sqrt(k)) when k is small: Generalized Selection and Ranking: Sorted Matrices."
                    },
                    {
                        "username": "alex108",
                        "content": "When I supply the following input (for Java), I get a seemingly incorrect answer of \"200\":\\n\\n[[1,200,300],[10,11,18],[12,19,22]]\\n4\\n\\nWhen sorted, the input looks like:\\n1,10,11,12,18,19,22,200,300\\n\\nThis means that the correct answer should be 12, right?  Am I mis-understanding the problem somehow?"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "it is mention that matrix is sorted in both row and column wise,\\nyour test case is wrong\\n"
                    },
                    {
                        "username": "tungpham",
                        "content": "I still don\\'t fully understand the problem. From the example, since everything is sorted, isn\\'t it the equivalent of going from top to bottom, left to right, k steps to get to the k smallest element? "
                    },
                    {
                        "username": "IlyaChernikov",
                        "content": "[@ajaynairarun](/ajaynairarun) I don\\'t get it too. What does the `k-th` element mean? Which ways can we go to find it? The description is not clear for me at all. I tried to map 1D-index to 2D-index and return matrix value of it and it passed around ~30% of all test cases"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "if there is duplicates the method you mentioned wont work right?\nand in the question it is mentioned (EACH row in ascending order)"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(378)Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix"
                    },
                    {
                        "username": "fkie4",
                        "content": "too hard"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Information to solvers:\nGuys there is a test case that says input :\n[[1,2],[1,3]]\nMeaning that rows are only sorted left to right and top to bottom it is not necessary that end of a row element at i will be less that first element at i+1th row.\nor else the solution would have been \n```\nclass Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\n       int n = matrix.size();\n       int targetRow = (k%n)?((k/n)):(k/n)-1;\n       int targetColumn = (k%n == 0)? n-1 : (k%n)-1;\n       cout<<targetRow<<\" \"<<targetColumn<<endl;\n       return  matrix[targetRow][targetColumn];\n    }\n};\n```"
                    },
                    {
                        "username": "kiodrvme",
                        "content": "The binary search solution could be written in one line\\n```\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        return matrix[0][0] + bisect_left(range(matrix[0][0], matrix[-1][-1]), k, key=lambda mid: sum(bisect.bisect(row, mid) for row in matrix))\\n```"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "I tried to attempt this question as\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int t = sqrt(k);\\n        k = k - t;\\n        int i = 0, j = 0;\\n        bool p;\\n        while(i < t && j < t){\\n            if(k==0){\\n                return p ? matrix[i][t]  : matrix[t][j];\\n            }\\n            if(k and matrix[i][t] <= matrix[t][j]){\\n                i++; k--; p=1;\\n            }\\n            else if(k and matrix[i][t] > matrix[t][j]){\\n                j++; k--; p=0;\\n            }\\n        }\\n        return 0; \\n    }\\n};\\n```\\nbut it is showing RUNTIME error"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Following solutions can be used:\\n1. We can use an auxiliary array, where each index of array will store the current column index for each row. Initially, all the elements will point to 0th row of the array. Now, we can traverse this array k times to find the minimum element and then increase the column number by 1 for that row. This approach will have time complexity as O(n*k).\\n\\n2. An optimisation on above approach will be to use a min heap. Store all the elements of the first column in following format : (value, row, column) in a min heap. Now, repeat the steps k times, where we get the minimum element from the min heap i.e. very first element of the heap, store the element of next column into the top of the heap and min heapify from the top of the heap. Time complexity of this will be: O(N + K* Log(N)). "
                    },
                    {
                        "username": "Unnatimishra_123",
                        "content": "        n=len(matrix)\\n        l=float(\\'inf\\')\\n        r=float(\\'-inf\\')\\n\\n        for i in range(n):\\n            l=min(l,matrix[i][0])\\n            r=max(r,matrix[i][n-1])\\n\\n\\n        while l < r:\\n            mid = (l + (r - l) //2)\\n            x=0\\n            for i in range(n):\\n                up=bisect.bisect_right(matrix[i],mid)\\n                x+=up\\n\\n            if x < k:  \\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n\\n"
                    }
                ]
            },
            {
                "id": 1915864,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "https://github.com/hqztrue/LeetCodeSolutions/blob/master/378.%20Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix.pdf\\nFor small values of k, this algorithm is better than O(n).\\n\\nAnd this paper gives the optimal solution O(sqrt(k)) when k is small: Generalized Selection and Ranking: Sorted Matrices."
                    },
                    {
                        "username": "alex108",
                        "content": "When I supply the following input (for Java), I get a seemingly incorrect answer of \"200\":\\n\\n[[1,200,300],[10,11,18],[12,19,22]]\\n4\\n\\nWhen sorted, the input looks like:\\n1,10,11,12,18,19,22,200,300\\n\\nThis means that the correct answer should be 12, right?  Am I mis-understanding the problem somehow?"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "it is mention that matrix is sorted in both row and column wise,\\nyour test case is wrong\\n"
                    },
                    {
                        "username": "tungpham",
                        "content": "I still don\\'t fully understand the problem. From the example, since everything is sorted, isn\\'t it the equivalent of going from top to bottom, left to right, k steps to get to the k smallest element? "
                    },
                    {
                        "username": "IlyaChernikov",
                        "content": "[@ajaynairarun](/ajaynairarun) I don\\'t get it too. What does the `k-th` element mean? Which ways can we go to find it? The description is not clear for me at all. I tried to map 1D-index to 2D-index and return matrix value of it and it passed around ~30% of all test cases"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "if there is duplicates the method you mentioned wont work right?\nand in the question it is mentioned (EACH row in ascending order)"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(378)Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix"
                    },
                    {
                        "username": "fkie4",
                        "content": "too hard"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Information to solvers:\nGuys there is a test case that says input :\n[[1,2],[1,3]]\nMeaning that rows are only sorted left to right and top to bottom it is not necessary that end of a row element at i will be less that first element at i+1th row.\nor else the solution would have been \n```\nclass Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\n       int n = matrix.size();\n       int targetRow = (k%n)?((k/n)):(k/n)-1;\n       int targetColumn = (k%n == 0)? n-1 : (k%n)-1;\n       cout<<targetRow<<\" \"<<targetColumn<<endl;\n       return  matrix[targetRow][targetColumn];\n    }\n};\n```"
                    },
                    {
                        "username": "kiodrvme",
                        "content": "The binary search solution could be written in one line\\n```\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        return matrix[0][0] + bisect_left(range(matrix[0][0], matrix[-1][-1]), k, key=lambda mid: sum(bisect.bisect(row, mid) for row in matrix))\\n```"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "I tried to attempt this question as\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int t = sqrt(k);\\n        k = k - t;\\n        int i = 0, j = 0;\\n        bool p;\\n        while(i < t && j < t){\\n            if(k==0){\\n                return p ? matrix[i][t]  : matrix[t][j];\\n            }\\n            if(k and matrix[i][t] <= matrix[t][j]){\\n                i++; k--; p=1;\\n            }\\n            else if(k and matrix[i][t] > matrix[t][j]){\\n                j++; k--; p=0;\\n            }\\n        }\\n        return 0; \\n    }\\n};\\n```\\nbut it is showing RUNTIME error"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Following solutions can be used:\\n1. We can use an auxiliary array, where each index of array will store the current column index for each row. Initially, all the elements will point to 0th row of the array. Now, we can traverse this array k times to find the minimum element and then increase the column number by 1 for that row. This approach will have time complexity as O(n*k).\\n\\n2. An optimisation on above approach will be to use a min heap. Store all the elements of the first column in following format : (value, row, column) in a min heap. Now, repeat the steps k times, where we get the minimum element from the min heap i.e. very first element of the heap, store the element of next column into the top of the heap and min heapify from the top of the heap. Time complexity of this will be: O(N + K* Log(N)). "
                    },
                    {
                        "username": "Unnatimishra_123",
                        "content": "        n=len(matrix)\\n        l=float(\\'inf\\')\\n        r=float(\\'-inf\\')\\n\\n        for i in range(n):\\n            l=min(l,matrix[i][0])\\n            r=max(r,matrix[i][n-1])\\n\\n\\n        while l < r:\\n            mid = (l + (r - l) //2)\\n            x=0\\n            for i in range(n):\\n                up=bisect.bisect_right(matrix[i],mid)\\n                x+=up\\n\\n            if x < k:  \\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n\\n"
                    }
                ]
            },
            {
                "id": 1866739,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "https://github.com/hqztrue/LeetCodeSolutions/blob/master/378.%20Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix.pdf\\nFor small values of k, this algorithm is better than O(n).\\n\\nAnd this paper gives the optimal solution O(sqrt(k)) when k is small: Generalized Selection and Ranking: Sorted Matrices."
                    },
                    {
                        "username": "alex108",
                        "content": "When I supply the following input (for Java), I get a seemingly incorrect answer of \"200\":\\n\\n[[1,200,300],[10,11,18],[12,19,22]]\\n4\\n\\nWhen sorted, the input looks like:\\n1,10,11,12,18,19,22,200,300\\n\\nThis means that the correct answer should be 12, right?  Am I mis-understanding the problem somehow?"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "it is mention that matrix is sorted in both row and column wise,\\nyour test case is wrong\\n"
                    },
                    {
                        "username": "tungpham",
                        "content": "I still don\\'t fully understand the problem. From the example, since everything is sorted, isn\\'t it the equivalent of going from top to bottom, left to right, k steps to get to the k smallest element? "
                    },
                    {
                        "username": "IlyaChernikov",
                        "content": "[@ajaynairarun](/ajaynairarun) I don\\'t get it too. What does the `k-th` element mean? Which ways can we go to find it? The description is not clear for me at all. I tried to map 1D-index to 2D-index and return matrix value of it and it passed around ~30% of all test cases"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "if there is duplicates the method you mentioned wont work right?\nand in the question it is mentioned (EACH row in ascending order)"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(378)Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix"
                    },
                    {
                        "username": "fkie4",
                        "content": "too hard"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Information to solvers:\nGuys there is a test case that says input :\n[[1,2],[1,3]]\nMeaning that rows are only sorted left to right and top to bottom it is not necessary that end of a row element at i will be less that first element at i+1th row.\nor else the solution would have been \n```\nclass Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\n       int n = matrix.size();\n       int targetRow = (k%n)?((k/n)):(k/n)-1;\n       int targetColumn = (k%n == 0)? n-1 : (k%n)-1;\n       cout<<targetRow<<\" \"<<targetColumn<<endl;\n       return  matrix[targetRow][targetColumn];\n    }\n};\n```"
                    },
                    {
                        "username": "kiodrvme",
                        "content": "The binary search solution could be written in one line\\n```\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        return matrix[0][0] + bisect_left(range(matrix[0][0], matrix[-1][-1]), k, key=lambda mid: sum(bisect.bisect(row, mid) for row in matrix))\\n```"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "I tried to attempt this question as\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int t = sqrt(k);\\n        k = k - t;\\n        int i = 0, j = 0;\\n        bool p;\\n        while(i < t && j < t){\\n            if(k==0){\\n                return p ? matrix[i][t]  : matrix[t][j];\\n            }\\n            if(k and matrix[i][t] <= matrix[t][j]){\\n                i++; k--; p=1;\\n            }\\n            else if(k and matrix[i][t] > matrix[t][j]){\\n                j++; k--; p=0;\\n            }\\n        }\\n        return 0; \\n    }\\n};\\n```\\nbut it is showing RUNTIME error"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Following solutions can be used:\\n1. We can use an auxiliary array, where each index of array will store the current column index for each row. Initially, all the elements will point to 0th row of the array. Now, we can traverse this array k times to find the minimum element and then increase the column number by 1 for that row. This approach will have time complexity as O(n*k).\\n\\n2. An optimisation on above approach will be to use a min heap. Store all the elements of the first column in following format : (value, row, column) in a min heap. Now, repeat the steps k times, where we get the minimum element from the min heap i.e. very first element of the heap, store the element of next column into the top of the heap and min heapify from the top of the heap. Time complexity of this will be: O(N + K* Log(N)). "
                    },
                    {
                        "username": "Unnatimishra_123",
                        "content": "        n=len(matrix)\\n        l=float(\\'inf\\')\\n        r=float(\\'-inf\\')\\n\\n        for i in range(n):\\n            l=min(l,matrix[i][0])\\n            r=max(r,matrix[i][n-1])\\n\\n\\n        while l < r:\\n            mid = (l + (r - l) //2)\\n            x=0\\n            for i in range(n):\\n                up=bisect.bisect_right(matrix[i],mid)\\n                x+=up\\n\\n            if x < k:  \\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n\\n"
                    }
                ]
            },
            {
                "id": 1807251,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "https://github.com/hqztrue/LeetCodeSolutions/blob/master/378.%20Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix.pdf\\nFor small values of k, this algorithm is better than O(n).\\n\\nAnd this paper gives the optimal solution O(sqrt(k)) when k is small: Generalized Selection and Ranking: Sorted Matrices."
                    },
                    {
                        "username": "alex108",
                        "content": "When I supply the following input (for Java), I get a seemingly incorrect answer of \"200\":\\n\\n[[1,200,300],[10,11,18],[12,19,22]]\\n4\\n\\nWhen sorted, the input looks like:\\n1,10,11,12,18,19,22,200,300\\n\\nThis means that the correct answer should be 12, right?  Am I mis-understanding the problem somehow?"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "it is mention that matrix is sorted in both row and column wise,\\nyour test case is wrong\\n"
                    },
                    {
                        "username": "tungpham",
                        "content": "I still don\\'t fully understand the problem. From the example, since everything is sorted, isn\\'t it the equivalent of going from top to bottom, left to right, k steps to get to the k smallest element? "
                    },
                    {
                        "username": "IlyaChernikov",
                        "content": "[@ajaynairarun](/ajaynairarun) I don\\'t get it too. What does the `k-th` element mean? Which ways can we go to find it? The description is not clear for me at all. I tried to map 1D-index to 2D-index and return matrix value of it and it passed around ~30% of all test cases"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "if there is duplicates the method you mentioned wont work right?\nand in the question it is mentioned (EACH row in ascending order)"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(378)Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix"
                    },
                    {
                        "username": "fkie4",
                        "content": "too hard"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Information to solvers:\nGuys there is a test case that says input :\n[[1,2],[1,3]]\nMeaning that rows are only sorted left to right and top to bottom it is not necessary that end of a row element at i will be less that first element at i+1th row.\nor else the solution would have been \n```\nclass Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\n       int n = matrix.size();\n       int targetRow = (k%n)?((k/n)):(k/n)-1;\n       int targetColumn = (k%n == 0)? n-1 : (k%n)-1;\n       cout<<targetRow<<\" \"<<targetColumn<<endl;\n       return  matrix[targetRow][targetColumn];\n    }\n};\n```"
                    },
                    {
                        "username": "kiodrvme",
                        "content": "The binary search solution could be written in one line\\n```\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        return matrix[0][0] + bisect_left(range(matrix[0][0], matrix[-1][-1]), k, key=lambda mid: sum(bisect.bisect(row, mid) for row in matrix))\\n```"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "I tried to attempt this question as\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int t = sqrt(k);\\n        k = k - t;\\n        int i = 0, j = 0;\\n        bool p;\\n        while(i < t && j < t){\\n            if(k==0){\\n                return p ? matrix[i][t]  : matrix[t][j];\\n            }\\n            if(k and matrix[i][t] <= matrix[t][j]){\\n                i++; k--; p=1;\\n            }\\n            else if(k and matrix[i][t] > matrix[t][j]){\\n                j++; k--; p=0;\\n            }\\n        }\\n        return 0; \\n    }\\n};\\n```\\nbut it is showing RUNTIME error"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Following solutions can be used:\\n1. We can use an auxiliary array, where each index of array will store the current column index for each row. Initially, all the elements will point to 0th row of the array. Now, we can traverse this array k times to find the minimum element and then increase the column number by 1 for that row. This approach will have time complexity as O(n*k).\\n\\n2. An optimisation on above approach will be to use a min heap. Store all the elements of the first column in following format : (value, row, column) in a min heap. Now, repeat the steps k times, where we get the minimum element from the min heap i.e. very first element of the heap, store the element of next column into the top of the heap and min heapify from the top of the heap. Time complexity of this will be: O(N + K* Log(N)). "
                    },
                    {
                        "username": "Unnatimishra_123",
                        "content": "        n=len(matrix)\\n        l=float(\\'inf\\')\\n        r=float(\\'-inf\\')\\n\\n        for i in range(n):\\n            l=min(l,matrix[i][0])\\n            r=max(r,matrix[i][n-1])\\n\\n\\n        while l < r:\\n            mid = (l + (r - l) //2)\\n            x=0\\n            for i in range(n):\\n                up=bisect.bisect_right(matrix[i],mid)\\n                x+=up\\n\\n            if x < k:  \\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n\\n"
                    }
                ]
            },
            {
                "id": 1806931,
                "content": [
                    {
                        "username": "hqztrue",
                        "content": "https://github.com/hqztrue/LeetCodeSolutions/blob/master/378.%20Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix.pdf\\nFor small values of k, this algorithm is better than O(n).\\n\\nAnd this paper gives the optimal solution O(sqrt(k)) when k is small: Generalized Selection and Ranking: Sorted Matrices."
                    },
                    {
                        "username": "alex108",
                        "content": "When I supply the following input (for Java), I get a seemingly incorrect answer of \"200\":\\n\\n[[1,200,300],[10,11,18],[12,19,22]]\\n4\\n\\nWhen sorted, the input looks like:\\n1,10,11,12,18,19,22,200,300\\n\\nThis means that the correct answer should be 12, right?  Am I mis-understanding the problem somehow?"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "it is mention that matrix is sorted in both row and column wise,\\nyour test case is wrong\\n"
                    },
                    {
                        "username": "tungpham",
                        "content": "I still don\\'t fully understand the problem. From the example, since everything is sorted, isn\\'t it the equivalent of going from top to bottom, left to right, k steps to get to the k smallest element? "
                    },
                    {
                        "username": "IlyaChernikov",
                        "content": "[@ajaynairarun](/ajaynairarun) I don\\'t get it too. What does the `k-th` element mean? Which ways can we go to find it? The description is not clear for me at all. I tried to map 1D-index to 2D-index and return matrix value of it and it passed around ~30% of all test cases"
                    },
                    {
                        "username": "ajaynairarun",
                        "content": "if there is duplicates the method you mentioned wont work right?\nand in the question it is mentioned (EACH row in ascending order)"
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(378)Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix"
                    },
                    {
                        "username": "fkie4",
                        "content": "too hard"
                    },
                    {
                        "username": "vikasboss6855",
                        "content": "Information to solvers:\nGuys there is a test case that says input :\n[[1,2],[1,3]]\nMeaning that rows are only sorted left to right and top to bottom it is not necessary that end of a row element at i will be less that first element at i+1th row.\nor else the solution would have been \n```\nclass Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\n       int n = matrix.size();\n       int targetRow = (k%n)?((k/n)):(k/n)-1;\n       int targetColumn = (k%n == 0)? n-1 : (k%n)-1;\n       cout<<targetRow<<\" \"<<targetColumn<<endl;\n       return  matrix[targetRow][targetColumn];\n    }\n};\n```"
                    },
                    {
                        "username": "kiodrvme",
                        "content": "The binary search solution could be written in one line\\n```\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        return matrix[0][0] + bisect_left(range(matrix[0][0], matrix[-1][-1]), k, key=lambda mid: sum(bisect.bisect(row, mid) for row in matrix))\\n```"
                    },
                    {
                        "username": "huiii_huiii",
                        "content": "I tried to attempt this question as\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(vector<vector<int>>& matrix, int k) {\\n        int n=matrix.size();\\n        int t = sqrt(k);\\n        k = k - t;\\n        int i = 0, j = 0;\\n        bool p;\\n        while(i < t && j < t){\\n            if(k==0){\\n                return p ? matrix[i][t]  : matrix[t][j];\\n            }\\n            if(k and matrix[i][t] <= matrix[t][j]){\\n                i++; k--; p=1;\\n            }\\n            else if(k and matrix[i][t] > matrix[t][j]){\\n                j++; k--; p=0;\\n            }\\n        }\\n        return 0; \\n    }\\n};\\n```\\nbut it is showing RUNTIME error"
                    },
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Following solutions can be used:\\n1. We can use an auxiliary array, where each index of array will store the current column index for each row. Initially, all the elements will point to 0th row of the array. Now, we can traverse this array k times to find the minimum element and then increase the column number by 1 for that row. This approach will have time complexity as O(n*k).\\n\\n2. An optimisation on above approach will be to use a min heap. Store all the elements of the first column in following format : (value, row, column) in a min heap. Now, repeat the steps k times, where we get the minimum element from the min heap i.e. very first element of the heap, store the element of next column into the top of the heap and min heapify from the top of the heap. Time complexity of this will be: O(N + K* Log(N)). "
                    },
                    {
                        "username": "Unnatimishra_123",
                        "content": "        n=len(matrix)\\n        l=float(\\'inf\\')\\n        r=float(\\'-inf\\')\\n\\n        for i in range(n):\\n            l=min(l,matrix[i][0])\\n            r=max(r,matrix[i][n-1])\\n\\n\\n        while l < r:\\n            mid = (l + (r - l) //2)\\n            x=0\\n            for i in range(n):\\n                up=bisect.bisect_right(matrix[i],mid)\\n                x+=up\\n\\n            if x < k:  \\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Generate Random Point in a Circle",
        "question_content": "<p>Given the radius and the position of the center of a circle, implement the function <code>randPoint</code> which generates a uniform random point inside the circle.</p>\n\n<p>Implement the <code>Solution</code> class:</p>\n\n<ul>\n\t<li><code>Solution(double radius, double x_center, double y_center)</code> initializes the object with the radius of the circle <code>radius</code> and the position of the center <code>(x_center, y_center)</code>.</li>\n\t<li><code>randPoint()</code> returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array <code>[x, y]</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;Solution&quot;, &quot;randPoint&quot;, &quot;randPoint&quot;, &quot;randPoint&quot;]\n[[1.0, 0.0, 0.0], [], [], []]\n<strong>Output</strong>\n[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]\n\n<strong>Explanation</strong>\nSolution solution = new Solution(1.0, 0.0, 0.0);\nsolution.randPoint(); // return [-0.02493, -0.38077]\nsolution.randPoint(); // return [0.82314, 0.38945]\nsolution.randPoint(); // return [0.36572, 0.17248]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;&nbsp;radius &lt;= 10<sup>8</sup></code></li>\n\t<li><code>-10<sup>7</sup> &lt;= x_center, y_center &lt;= 10<sup>7</sup></code></li>\n\t<li>At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>randPoint</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 154037,
                "title": "polar-coordinates-10-lines",
                "content": "The point is that we should not use ```x=rand(len)*cos(rand(degree))```, we should use ```x=sqrt(rand(len))*cos(rand(degree))```.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/caraxin/image_1532665245.png)\\n\\nReference: http://www.anderswallin.net/2009/05/uniform-random-points-in-a-circle-using-polar-coordinates/\\n```\\nclass Solution {\\n    double radius, x_center, y_center;\\n    public Solution(double radius, double x_center, double y_center) {\\n        this.radius=radius;\\n        this.x_center=x_center;\\n        this.y_center=y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double len= Math.sqrt(Math.random())*radius;\\n        double deg= Math.random()*2*Math.PI;\\n        double x= x_center+len*Math.cos(deg);\\n        double y= y_center+len*Math.sin(deg);\\n        return new double[]{x,y};\\n    }\\n}\\n```\\n**update**: thanks @jianhu for pointing this out, we should use```double deg = Math.random() * Math.PI * 2``` here.\\nHappy Coding!",
                "solutionTags": [],
                "code": "```x=rand(len)*cos(rand(degree))```\n```x=sqrt(rand(len))*cos(rand(degree))```\n```\\nclass Solution {\\n    double radius, x_center, y_center;\\n    public Solution(double radius, double x_center, double y_center) {\\n        this.radius=radius;\\n        this.x_center=x_center;\\n        this.y_center=y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double len= Math.sqrt(Math.random())*radius;\\n        double deg= Math.random()*2*Math.PI;\\n        double x= x_center+len*Math.cos(deg);\\n        double y= y_center+len*Math.sin(deg);\\n        return new double[]{x,y};\\n    }\\n}\\n```\n```double deg = Math.random() * Math.PI * 2```",
                "codeTag": "Java"
            },
            {
                "id": 1113679,
                "title": "python-polar-coordinates-explained-with-diagrams-and-math",
                "content": "Imagine first special case for this problem: we have circle with radius equal to `1` and coordinates of center is `(0, 0)`. Let us use polar coordinates:\\n`x = R * cos(theta)`\\n`y = R * sin(theta)`.\\n\\n<img src=\"https://assets.leetcode.com/users/images/0a8d83b0-69fb-4ee7-866b-91fce8ddfb2f_1615969976.4114075.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"250\" height=\"250\"/>\\n\\n\\n\\nHere `R` is distance between our point (call it `A`) and the origin (call it `O`). `theta` is angle between `OA` and axis `OX`.\\nWhy it is good idea to go to polar coordinates here? Because in polar coordiantes unity circle can be written as:\\n`R <= 1`\\n`0 <= theta <= 2*pi`.\\n\\nNow we need to answer two qustions: how to generate `R` and how to generate `theta`.\\n\\n1. About `theta` it is quite obvious: we do it uniformly.\\n2. About `R` it is not obvious: if we do it uniformly, there will be more points closer if we generate it in uniform way. Look at this intuition: let us fix `R = 1` and generate `10`  points, then fix `R = 0.5` and generate `10` more points. What you can see? Distance between points on the big circle is in average `2` times bigger, than between `2` points on smaller circle. It actually means, that for small circle you need to generate only `5` points, not `10`, and by this logic if you have `x` points for circle with `R = 1`, you need `x*R` points for smaller radius. \\n\\n<img src=\"https://assets.leetcode.com/users/images/d8f828cb-bf5a-40dc-9da9-cddf6656b2ac_1615970011.1811876.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"200\" height=\"200\"/>\\n\\n\\nThis was intuition, now let go into mathematics: what does uniform distribution means, that if we choose small element inside our circle, than probability to get inside this element should be proportional to area of this element. Let us define `F(R)` cumulative distribution function (cdf) for radius. Then by definition probability to get between `R` and `R + dR` is equal to `F(R + dR) - F(R) = f(R)*dR`, where `f(R)` is probability density function (pdf), so probability to get into this small region is `f(R)* dR * dTheta`. From other point of view, area of this region can be calclated as `[(R+dR)^2 - R^2]*dTheta = 2*R*dR*dTheta`. From here we get, that `f(R) = c*R` for some constant `c` (because we say it is proportional, not equal). Now, `F\\'(R) = f(R)`, so `F(R) = c*R^2` (here `c` is another conatant). Now the question is how you generate data such that cumulative function is proportional to `R^2`. The answer is **Inverse transform sampling** (check wikipedia), where idea is given uniform distribution generate data from any distribution `F(R)`: we need to generate `R` from uniform distrubution and than apply inverse function, that is we have `sqrt(uniform(0,1))` in the end.\\n\\n<img src=\"https://assets.leetcode.com/users/images/ed0b4ca6-695b-4006-9985-968a1fc76279_1615969804.150301.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"250\" height=\"250\"/>\\n\\n**Complexity**: time and space complexity is just `O(1)`.\\n\\n```\\nclass Solution:\\n    def __init__(self, radius, x_center, y_center):\\n        self.r, self.x, self.y = radius, x_center, y_center\\n\\n    def randPoint(self):\\n        theta = uniform(0,2*pi)\\n        R = self.r*sqrt(uniform(0,1))\\n        return [self.x + R*cos(theta), self.y + R*sin(theta)]\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self, radius, x_center, y_center):\\n        self.r, self.x, self.y = radius, x_center, y_center\\n\\n    def randPoint(self):\\n        theta = uniform(0,2*pi)\\n        R = self.r*sqrt(uniform(0,1))\\n        return [self.x + R*cos(theta), self.y + R*sin(theta)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113792,
                "title": "generate-random-point-in-a-circle-short-easy-w-explanation-and-diagrams",
                "content": "We know that any point in a circle is of the form - `(Rcos\\u03B8, Rsin\\u03B8)`. For circles having center other than origin, this becomes - `(Xc + Rcos\\u03B8, Yc + Rsin\\u03B8)`. We might choose the approach to select random integer `[0, 1]` and multiply by `R` to generate a point uniformly between [0, R], then generate a random `\\u03B8` and finally generate points using the above-mentioned formula.\\n\\nHowever, the set of points generated by above approach won\\'t be uniformly distributed and more biased towards the center. This is because, the area towards the outer of circle is greater than towards the inner end of circle.\\n![image](https://assets.leetcode.com/users/images/ccdec8da-a911-497f-8df9-9cb03ab82393_1615977015.2818558.png)\\n\\nSo, for a section of circle `(\\u03B8, \\u03B8+\\u0394)`, for the points to be uniform, we need to generate more points towards the outer circle than we need towards inner of circle. \\n\\n---------\\n\\nFor this purpose, we use the square root function on the randomly generated point between [0, 1] (watch `sqrt()` is applied to `random()` in below code) to bias the outer end circle points. **Note that after applying sqrt on `random()` (a point between [0, 1]), the result would be a value greater than the original `random()` thus making it biased more towards the outer end**. This makes the point uniformly generated over all of the circle.\\n\\n\\n\\n\\n```\\nclass Solution {\\n    double R, X, Y;\\npublic:\\n    Solution(double radius, double x_center, double y_center) : R(radius), X(x_center), Y(y_center) {\\n        srand(time(0));\\n    }\\n    double random(){\\n        return (double)rand() / RAND_MAX; // for generating random points between 0 to 1\\n    }\\n    vector<double> randPoint() {\\n        vector<double> randomPoint(2);\\n        double len = sqrt(random()) * R, deg = 2 * M_PI * random();\\n        randomPoint[0] = X + len * cos(deg);\\n        randomPoint[1] = Y + len * sin(deg);\\n        return randomPoint;\\n    }\\n};\\n```\\n\\n-----------\\n----------------------\\n\\n**Reason for choosing Square root function**\\n\\nThe reason for choosing `sqrt()` rather than any other functions like `cbrt()` to bias it towards outer end is that in the first approach mentioned above, the points generated were proportional to `R^2` because our random was proportional to `R`, thus making points over all area of circle proportional to `R^2` which made them concentrated more towards the center. Making our random proportional to `sqrt(R)` would make the points generated over all the area of circle proportional to `R` which would make all the points generate uniformly throughout the circle.\\n\\n\\n![image](https://assets.leetcode.com/users/images/ce0b6f64-0a90-4e58-b8b8-673d039e3bae_1615977676.6706777.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    double R, X, Y;\\npublic:\\n    Solution(double radius, double x_center, double y_center) : R(radius), X(x_center), Y(y_center) {\\n        srand(time(0));\\n    }\\n    double random(){\\n        return (double)rand() / RAND_MAX; // for generating random points between 0 to 1\\n    }\\n    vector<double> randPoint() {\\n        vector<double> randomPoint(2);\\n        double len = sqrt(random()) * R, deg = 2 * M_PI * random();\\n        randomPoint[0] = X + len * cos(deg);\\n        randomPoint[1] = Y + len * sin(deg);\\n        return randomPoint;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155650,
                "title": "explanation-with-graphs-why-using-math-sqrt",
                "content": "    public double[] randPoint() {\\n        double len= Math.sqrt(Math.random())*radius;\\n        double deg= Math.random()*2*Math.PI;\\n        double x= x_center+len*Math.cos(deg);\\n        double y= y_center+len*Math.sin(deg);\\n        return new double[]{x,y};\\n    }\\nAbove is the solution that some currently most voted post used to solve this question.\\nPosters are using **Math.sqrt()** to get the graph with correct random points.\\nHowever, what\\'s happening here? Why the points will go near to center if we don\\'t use Math.sqrt()?\\nHere is some expanation with graph to show what\\'s behind this.\\n\\nFirst, in above solution, we need to know that we are using one random **Length** to multiply on a random **normalized vector**(x^2 + y^2 = 1) to get the random point.\\nSounds good right?\\nHowever, if we directly multiply them, we will get a graph that points placed averagely according to **Length/Radius**. \\n![image](https://s3-lc-upload.s3.amazonaws.com/users/fd8783/image_1533180618.png)  -->   ![image](https://s3-lc-upload.s3.amazonaws.com/users/fd8783/image_1533114715.png)\\n<h3>In the smallest circle (i.e. radius = 0.1), it can get a same amount of points with the larger circle (i.e. radius = 0.9)!</h3>\\n\\nTherefore, we need to decrease the chance that the point can placed there according to how close it is to the center (how short is the that position\\'s radius).\\n\\nThen, finally, Here is Math.sqrt()\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/fd8783/image_1533115147.png)\\n***Red** line is normal random, **Green** line is Math.sqrt(random)\\nThis is exactly what we want!\\n\\nAfter using this, we can get a correct graph!\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/fd8783/image_1533180675.png) -->   ![image](https://s3-lc-upload.s3.amazonaws.com/users/fd8783/image_1533116036.png)\\n\\n\\n\\nUndeniably, using Math.sqrt() is a clever method.\\nHowever, I think it is quite difficult to understand without explanation.\\nI hope this can help if you don\\'t understand why Math.sqrt().\\n\\n\\n",
                "solutionTags": [],
                "code": "    public double[] randPoint() {\\n        double len= Math.sqrt(Math.random())*radius;\\n        double deg= Math.random()*2*Math.PI;\\n        double x= x_center+len*Math.cos(deg);\\n        double y= y_center+len*Math.sin(deg);\\n        return new double[]{x,y};\\n    }\\nAbove is the solution that some currently most voted post used to solve this question.\\nPosters are using **Math.sqrt()** to get the graph with correct random points.\\nHowever, what\\'s happening here? Why the points will go near to center if we don\\'t use Math.sqrt()?\\nHere is some expanation with graph to show what\\'s behind this.\\n\\nFirst, in above solution, we need to know that we are using one random **Length** to multiply on a random **normalized vector**(x^2 + y^2 = 1) to get the random point.\\nSounds good right?\\nHowever, if we directly multiply them, we will get a graph that points placed averagely according to **Length/Radius**. \\n![image](https://s3-lc-upload.s3.amazonaws.com/users/fd8783/image_1533180618.png)  -->   ![image](https://s3-lc-upload.s3.amazonaws.com/users/fd8783/image_1533114715.png)\\n<h3>In the smallest circle (i.e. radius = 0.1), it can get a same amount of points with the larger circle (i.e. radius = 0.9)!</h3>\\n\\nTherefore, we need to decrease the chance that the point can placed there according to how close it is to the center (how short is the that position\\'s radius).\\n\\nThen, finally, Here is Math.sqrt()\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/fd8783/image_1533115147.png)\\n***Red** line is normal random, **Green** line is Math.sqrt(random)\\nThis is exactly what we want!\\n\\nAfter using this, we can get a correct graph!\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/fd8783/image_1533180675.png) -->   ![image](https://s3-lc-upload.s3.amazonaws.com/users/fd8783/image_1533116036.png)\\n\\n\\n\\nUndeniably, using Math.sqrt() is a clever method.\\nHowever, I think it is quite difficult to understand without explanation.\\nI hope this can help if you don\\'t understand why Math.sqrt().\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1113623,
                "title": "js-python-java-c-polar-notation-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe easiest way to get a random point in a circle is to use **polar notation**. With polar notation, you can define any point in the circle with the polar angle (**ang**) and the length of the hypotenuse (**hyp**).\\n\\nFor both, we can apply a random number generator to give us a value in a usable range. The polar angle will be in the range **[0, 2 * pi]** and the hypotenuse will be in the range **[0, radius]**.\\n\\nThings can get tricky when we\\'re finding a random value for the hypotenuse, however, because if we evenly favor the entire allowable range, the points will tend to be more densely packed towards the center of the circle.\\n\\nTake, for example, a circle with a radius of **1**. If we divide the radius in half, the area in which the points with a hypotenuse in the smaller half (**[0, 0.5]**) will be scattered is a circle of radius 0.5 whose area is defined as **pi * (0.5)^2**, or **0.25 * pi**. The area in which the points with a hypotenuse in the larger half (**[0.5, 1]**) will be scattered is the remaining difference of the larger circle, defined as **pi * 1^2 - 0.25 * pi**, or **0.75 * pi**.\\n\\n![visual 1](https://i.imgur.com/1dWiDnQ.png)\\n\\nSo even though the two halves are even, the area described by rotating the two halves around the center are drastically different. In order to allow for an even distribution, then, we need to take the square root of the random number *before* multiplying it by the radius to get our hypotenuse, so that we can exponentially favor values farther from the center.\\n\\nOnce we have our values for **ang** and **hyp**, we can simply use sine and cosine to obtain values for the opposite (**opp**) and adjacent (**adj**) legs of our right triangle, which will equal the amount we need to add to/subtract from the x and y coordinates of our center point (**XC**, **YC**).\\n\\n![visual 2](https://i.imgur.com/dLc2H2S.png)\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThe code for all four languages is almost identical.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **160ms / 55.2MB** (beats 100% / 100%).\\n```javascript\\nclass Solution {\\n    constructor(radius, x_center, y_center) {\\n        this.RAD = radius\\n        this.XC = x_center\\n        this.YC = y_center\\n    }\\n    randPoint() {\\n        let ang = Math.random() * 2 * Math.PI,\\n            hyp = Math.sqrt(Math.random()) * this.RAD,\\n            adj = Math.cos(ang) * hyp,\\n            opp = Math.sin(ang) * hyp\\n        return [this.XC + adj, this.YC + opp]\\n    }\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **132ms / 24.3MB** (beats 95% / 89%).\\n```python\\nclass Solution:\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.RAD = radius\\n        self.XC = x_center\\n        self.YC = y_center\\n    def randPoint(self) -> List[float]:\\n        ang = random.uniform(0, 1) * 2 * math.pi\\n        hyp = sqrt(random.uniform(0, 1)) * self.RAD\\n        adj = cos(ang) * hyp\\n        opp = sin(ang) * hyp\\n        return [self.XC + adj, self.YC + opp]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **193ms / 48.0MB** (beats 100% / 99%).\\n```java\\nclass Solution {\\n    double RAD, XC, YC;\\n    public Solution(double radius, double x_center, double y_center) {\\n        RAD = radius;\\n        XC = x_center;\\n        YC = y_center;\\n    }\\n    public double[] randPoint() {\\n        double ang = Math.random() * 2 * Math.PI,\\n            hyp = Math.sqrt(Math.random()) * RAD,\\n            adj = Math.cos(ang) * hyp,\\n            opp = Math.sin(ang) * hyp;\\n        return new double[]{XC + adj, YC + opp};\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **84ms / 27.1MB** (beats 97% / 82%).\\n```c++\\nclass Solution {\\npublic:\\n    double RAD, XC, YC;\\n    Solution(double radius, double x_center, double y_center) {\\n        RAD = radius;\\n        XC = x_center;\\n        YC = y_center;\\n    }   \\n    vector<double> randPoint() {\\n        double ang = (double)rand() / RAND_MAX * 2 * M_PI,\\n            hyp = sqrt((double)rand() / RAND_MAX) * RAD,\\n            adj = cos(ang) * hyp,\\n            opp = sin(ang) * hyp;\\n        return vector<double>{XC + adj, YC + opp};\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nclass Solution {\\n    constructor(radius, x_center, y_center) {\\n        this.RAD = radius\\n        this.XC = x_center\\n        this.YC = y_center\\n    }\\n    randPoint() {\\n        let ang = Math.random() * 2 * Math.PI,\\n            hyp = Math.sqrt(Math.random()) * this.RAD,\\n            adj = Math.cos(ang) * hyp,\\n            opp = Math.sin(ang) * hyp\\n        return [this.XC + adj, this.YC + opp]\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.RAD = radius\\n        self.XC = x_center\\n        self.YC = y_center\\n    def randPoint(self) -> List[float]:\\n        ang = random.uniform(0, 1) * 2 * math.pi\\n        hyp = sqrt(random.uniform(0, 1)) * self.RAD\\n        adj = cos(ang) * hyp\\n        opp = sin(ang) * hyp\\n        return [self.XC + adj, self.YC + opp]\\n```\n```java\\nclass Solution {\\n    double RAD, XC, YC;\\n    public Solution(double radius, double x_center, double y_center) {\\n        RAD = radius;\\n        XC = x_center;\\n        YC = y_center;\\n    }\\n    public double[] randPoint() {\\n        double ang = Math.random() * 2 * Math.PI,\\n            hyp = Math.sqrt(Math.random()) * RAD,\\n            adj = Math.cos(ang) * hyp,\\n            opp = Math.sin(ang) * hyp;\\n        return new double[]{XC + adj, YC + opp};\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    double RAD, XC, YC;\\n    Solution(double radius, double x_center, double y_center) {\\n        RAD = radius;\\n        XC = x_center;\\n        YC = y_center;\\n    }   \\n    vector<double> randPoint() {\\n        double ang = (double)rand() / RAND_MAX * 2 * M_PI,\\n            hyp = sqrt((double)rand() / RAND_MAX) * RAD,\\n            adj = cos(ang) * hyp,\\n            opp = sin(ang) * hyp;\\n        return vector<double>{XC + adj, YC + opp};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154092,
                "title": "very-simple-python-solution",
                "content": "Since we are given the `(x, y)` and `r`, so we can formulate this rectangle of `[x-r, y-r, x+r, y+r]`. It is very easy for us to make samples from squares uniformly, and we just reject the samples outside the circle.\\n\\n```\\nimport random\\nclass Solution(object):\\n\\n    def __init__(self, radius, x_center, y_center):\\n        \"\"\"\\n        :type radius: float\\n        :type x_center: float\\n        :type y_center: float\\n        \"\"\"\\n        self.x_min, self.x_max = x_center - radius, x_center + radius\\n        self.y_min, self.y_max = y_center - radius, y_center + radius\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n\\n    def randPoint(self):\\n        \"\"\"\\n        :rtype: List[float]\\n        \"\"\"\\n        while True:\\n            x, y = random.uniform(self.x_min, self.x_max), random.uniform(self.y_min, self.y_max)\\n            if (x - self.x_center)**2 + (y - self.y_center)**2 <= self.radius**2:\\n                return [x, y]\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\nclass Solution(object):\\n\\n    def __init__(self, radius, x_center, y_center):\\n        \"\"\"\\n        :type radius: float\\n        :type x_center: float\\n        :type y_center: float\\n        \"\"\"\\n        self.x_min, self.x_max = x_center - radius, x_center + radius\\n        self.y_min, self.y_max = y_center - radius, y_center + radius\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n\\n    def randPoint(self):\\n        \"\"\"\\n        :rtype: List[float]\\n        \"\"\"\\n        while True:\\n            x, y = random.uniform(self.x_min, self.x_max), random.uniform(self.y_min, self.y_max)\\n            if (x - self.x_center)**2 + (y - self.y_center)**2 <= self.radius**2:\\n                return [x, y]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129589,
                "title": "palindromic-substrings-short-easy-w-explanation-beats-100",
                "content": "In the brute-force approach, we would be checking each substring for a palindrome. This approach needs a time complexity of **`O(N^2)*O(N)`** , `O(N)` for checking if each `N^2` number of subtrings are palindrome. This would be a very inefficient solution as we are repeating many comparisions over and over.  There exists a better approach which reduces the time to check if a substring is palindrome to **`O(1)`**.\\n\\n----\\n\\n\\u2714\\uFE0F ***Solution (Check palindrome from center & Extend)***\\n\\nWe can do better than naive approach if we check for each palindromic substring from its center. We would have 2 cases -\\n* ***Odd length palindrome*** - We can consider each center. For each center, the center itself is a palindrome. We can then try to **extend the string by 1 character to the left and right & check if its a palindrome**. If the character on the left and right are equal, the palindrome can be extended. Add 1 to count each time the palindrome is extended.\\n* ***Even length palindrome*** - We can consider each two letter substring from the given string. If they are equal, they form a palindrome and count can be increased by 1. Again, try extending the palindrome and increase the count if palindrome is formed.\\n\\nSo, we just need to keep two variables `l` and `r` and keep extending them in the left and right direction till a palindrome keeps forming.\\n\\n```\\nint countSubstrings(string s) {\\n\\tint n = size(s), cnt = n; // cnt = n, since each single letter is palindrome in itself.\\n\\t// For odd length palindromes\\n\\tfor(int i = 1, l = 0, r = 2; i < n; i++, l = i - 1, r = i + 1)\\n\\t\\twhile(l >= 0 && r < n && s[l] == s[r]) l--, r++, cnt++;                    \\n\\t// For even length palindromes\\n\\tfor(int i = 1, l = 0, r = 1; i < n; i++, l = i - 1, r = i)\\n\\t\\twhile(l >= 0 && r < n && s[l] == s[r]) l--, r++, cnt++;            \\n\\treturn cnt;\\n}\\n```\\n\\n***Time Complexity*** : **`O(N^2)`**, where `N` is the length of string `s`. The worst case can occur when all the characters are equal and for each center, we would need to iterate till either extreme is reached.*\\n\\n***Space Complexity*** : **`O(1)`**, since only constant space is being used.\\n\\n----\\n\\n<table style=\"margin: auto;\"><tr><td><img src=\"https://assets.leetcode.com/users/images/00b776a9-ad52-46ef-89c7-c19260eec699_1616847568.8961484.png\" height=\"200\" align=\"center\"></td></tr></table>\\n\\n\\n-----\\n-----",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countSubstrings(string s) {\\n\\tint n = size(s), cnt = n; // cnt = n, since each single letter is palindrome in itself.\\n\\t// For odd length palindromes\\n\\tfor(int i = 1, l = 0, r = 2; i < n; i++, l = i - 1, r = i + 1)\\n\\t\\twhile(l >= 0 && r < n && s[l] == s[r]) l--, r++, cnt++;                    \\n\\t// For even length palindromes\\n\\tfor(int i = 1, l = 0, r = 1; i < n; i++, l = i - 1, r = i)\\n\\t\\twhile(l >= 0 && r < n && s[l] == s[r]) l--, r++, cnt++;            \\n\\treturn cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1126937,
                "title": "pacific-atlantic-water-flow-short-easy-w-explanation-diagrams",
                "content": "In a naive approach, we would have to consider each cell and find if it is reachable to both the oceans by checking if it is able to reach - **1.** top or left edge(atlantic) and,  **2.** bottom or right edge (pacific). This would take about **`O((mn)^2)`**, which is not efficient.\\n\\n***Solution - I (DFS Traversal)***\\n\\nI will try to explain the process using images provided in LC solution.\\n\\nWe can observe that there are these cells which can reach -\\n\\n* None \\n* Pacific\\n* Atlantic\\n* Both Pacific and Atlantic\\n\\n\\nWe need only the cells satisfying the last condition above.\\n\\n\\nNow, if we start from the cells connected to altantic ocean and visit all cells having height greater than current cell (**water can only flow from a cell to another one with height equal or lower**), we are able to reach some subset of cells (let\\'s call them **`A`**).\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/7fe6657a-4bc1-4d68-8a26-befe6e106371_1616674367.2859244.png\" align=\"center\" width=\"500\"/></p>\\n\\n\\n\\nNext, we start from the cells connected to pacific ocean and repeat the same process, we find another subset (let\\'s call this one **`B`**).\\n\\n<p align=\"center\"><img src=\"https://assets.leetcode.com/users/images/ef3a788b-7b66-4c70-a47c-58490b998177_1616674843.2320118.png\" align=\"center\" width=\"500\"/></p>\\n\\n\\nThe final answer we get will be the intersection of sets `A` and `B` (**`A \\u2229 B`**).\\n\\n<p align=\"center\"><img src=\"https://assets.leetcode.com/users/images/6a9f7a1f-105e-4d6c-8e7c-ede3a2f9b6de_1616674967.7329113.png\" align=\"center\" width=\"500\"/></p>\\n\\nSo, we just need to iterate from edge cells, find cells reachable from atlantic (set `A`), cells reachable from pacific (set `B`) and return their intersection. This can be done using DFS or BFS graph traversals.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n\\t// denotes cells reachable starting from atlantic and pacific edged cells respectively\\n    vector<vector<bool> > atlantic, pacific;\\n\\tvector<vector<int> > ans;    \\n    vector<vector<int> > pacificAtlantic(vector<vector<int>>& mat) {\\n        if(!size(mat)) return ans;\\n        m = size(mat), n = size(mat[0]);\\n        atlantic = pacific = vector<vector<bool> >(m, vector<bool>(n, false));\\n\\t\\t// perform dfs from all edge cells (ocean-connected cells)\\n        for(int i = 0; i < m; i++) dfs(mat, pacific, i, 0), dfs(mat, atlantic, i, n - 1);\\n        for(int i = 0; i < n; i++) dfs(mat, pacific, 0, i), dfs(mat, atlantic, m - 1, i);             \\n        return ans;\\n    }\\n    void dfs(vector<vector<int> >& mat, vector<vector<bool> >& visited, int i, int j){        \\n        if(visited[i][j]) return;\\n        visited[i][j] = true;\\n\\t\\t// if cell reachable from both the oceans, insert into final answer vector\\n        if(atlantic[i][j] && pacific[i][j]) ans.push_back(vector<int>{i, j});    \\n\\t\\t// dfs from current cell only if height of next cell is greater\\n/*\\u2B07\\uFE0F*/  if(i + 1 <  m && mat[i + 1][j] >= mat[i][j]) dfs(mat, visited, i + 1, j); \\n/*\\u2B06\\uFE0F*/  if(i - 1 >= 0 && mat[i - 1][j] >= mat[i][j]) dfs(mat, visited, i - 1, j);\\n/*\\u27A1\\uFE0F*/  if(j + 1 <  n && mat[i][j + 1] >= mat[i][j]) dfs(mat, visited, i, j + 1); \\n/*\\u2B05\\uFE0F*/  if(j - 1 >= 0 && mat[i][j - 1] >= mat[i][j]) dfs(mat, visited, i, j - 1);\\n    }\\n};\\n```\\n\\n**Time Complexity :** **`O(M*N)`**, in worst case, all cells are reachable to both oceans and would be visited twice. This case can occur when all elements are equal.\\n**Space Complexity :** **`O(M*N)`**, to mark the atlantic and pacific visited cells.\\n\\n\\n---------\\n---------\\n\\n***Solution - II (BFS Traversal)***\\n\\nBelow is similar solution as above converted to **BFS traversal** -\\n\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int> > ans;\\n    vector<vector<bool> > atlantic, pacific;\\n    queue<pair<int, int> > q;\\n    vector<vector<int> > pacificAtlantic(vector<vector<int>>& mat) {\\n        if(!size(mat)) return ans;\\n        m = size(mat), n = size(mat[0]);\\n        atlantic = pacific = vector<vector<bool> >(m, vector<bool>(n, false));\\n        for(int i = 0; i < m; i++) bfs(mat, pacific, i, 0), bfs(mat, atlantic, i, n - 1);\\n        for(int i = 0; i < n; i++) bfs(mat, pacific, 0, i), bfs(mat, atlantic, m - 1, i);             \\n        return ans;\\n    }\\n    void bfs(vector<vector<int> >& mat, vector<vector<bool> >& visited, int i, int j){        \\n        q.push({i, j});\\n        while(!q.empty()){\\n            tie(i, j) = q.front(); q.pop();\\n            if(visited[i][j]) continue;\\n            visited[i][j] = true;\\n            if(atlantic[i][j] && pacific[i][j]) ans.push_back(vector<int>{i, j});\\n            if(i + 1 <  m && mat[i + 1][j] >= mat[i][j]) q.push({i + 1, j});\\n            if(i - 1 >= 0 && mat[i - 1][j] >= mat[i][j]) q.push({i - 1, j});\\n            if(j + 1 <  n && mat[i][j + 1] >= mat[i][j]) q.push({i, j + 1});\\n            if(j - 1 >= 0 && mat[i][j - 1] >= mat[i][j]) q.push({i, j - 1});\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n\\t// denotes cells reachable starting from atlantic and pacific edged cells respectively\\n    vector<vector<bool> > atlantic, pacific;\\n\\tvector<vector<int> > ans;    \\n    vector<vector<int> > pacificAtlantic(vector<vector<int>>& mat) {\\n        if(!size(mat)) return ans;\\n        m = size(mat), n = size(mat[0]);\\n        atlantic = pacific = vector<vector<bool> >(m, vector<bool>(n, false));\\n\\t\\t// perform dfs from all edge cells (ocean-connected cells)\\n        for(int i = 0; i < m; i++) dfs(mat, pacific, i, 0), dfs(mat, atlantic, i, n - 1);\\n        for(int i = 0; i < n; i++) dfs(mat, pacific, 0, i), dfs(mat, atlantic, m - 1, i);             \\n        return ans;\\n    }\\n    void dfs(vector<vector<int> >& mat, vector<vector<bool> >& visited, int i, int j){        \\n        if(visited[i][j]) return;\\n        visited[i][j] = true;\\n\\t\\t// if cell reachable from both the oceans, insert into final answer vector\\n        if(atlantic[i][j] && pacific[i][j]) ans.push_back(vector<int>{i, j});    \\n\\t\\t// dfs from current cell only if height of next cell is greater\\n/*\\u2B07\\uFE0F*/  if(i + 1 <  m && mat[i + 1][j] >= mat[i][j]) dfs(mat, visited, i + 1, j); \\n/*\\u2B06\\uFE0F*/  if(i - 1 >= 0 && mat[i - 1][j] >= mat[i][j]) dfs(mat, visited, i - 1, j);\\n/*\\u27A1\\uFE0F*/  if(j + 1 <  n && mat[i][j + 1] >= mat[i][j]) dfs(mat, visited, i, j + 1); \\n/*\\u2B05\\uFE0F*/  if(j - 1 >= 0 && mat[i][j - 1] >= mat[i][j]) dfs(mat, visited, i, j - 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int> > ans;\\n    vector<vector<bool> > atlantic, pacific;\\n    queue<pair<int, int> > q;\\n    vector<vector<int> > pacificAtlantic(vector<vector<int>>& mat) {\\n        if(!size(mat)) return ans;\\n        m = size(mat), n = size(mat[0]);\\n        atlantic = pacific = vector<vector<bool> >(m, vector<bool>(n, false));\\n        for(int i = 0; i < m; i++) bfs(mat, pacific, i, 0), bfs(mat, atlantic, i, n - 1);\\n        for(int i = 0; i < n; i++) bfs(mat, pacific, 0, i), bfs(mat, atlantic, m - 1, i);             \\n        return ans;\\n    }\\n    void bfs(vector<vector<int> >& mat, vector<vector<bool> >& visited, int i, int j){        \\n        q.push({i, j});\\n        while(!q.empty()){\\n            tie(i, j) = q.front(); q.pop();\\n            if(visited[i][j]) continue;\\n            visited[i][j] = true;\\n            if(atlantic[i][j] && pacific[i][j]) ans.push_back(vector<int>{i, j});\\n            if(i + 1 <  m && mat[i + 1][j] >= mat[i][j]) q.push({i + 1, j});\\n            if(i - 1 >= 0 && mat[i - 1][j] >= mat[i][j]) q.push({i - 1, j});\\n            if(j + 1 <  n && mat[i][j + 1] >= mat[i][j]) q.push({i, j + 1});\\n            if(j - 1 >= 0 && mat[i][j - 1] >= mat[i][j]) q.push({i, j - 1});\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120216,
                "title": "reordered-power-of-2-short-easy-w-explanation-beats-100",
                "content": "***Solution - I (Counting Digits Frequency)***\\n\\nA simple solution is to check if frequency of digits in N and all powers of 2 less than `10^9` are equal. In our case, we need to check for all powers of 2 from `2^0` to `2^29` and if any of them matches with digits in `N`, return true.\\n\\n```\\n// counts frequency of each digit in given number N and returns it as vector\\nvector<int> countDigits(int N){\\n\\tvector<int>digitsInN(10);\\n\\twhile(N)\\n\\t\\tdigitsInN[N % 10]++, N /= 10;\\n\\treturn digitsInN;\\n}\\nbool reorderedPowerOf2(int N) {\\n\\tvector<int> digitsInN = countDigits(N); // freq of digits in N\\n\\t// powOf2 goes from 2^0 to 2^29 and each time freq of digits in powOf2 is compared with digitsInN\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n\\t\\tif(digitsInN == countDigits(powOf2)) return true;  // return true if both have same frequency of each digits\\n\\treturn false;\\n}\\n```\\n\\n**Time Complexity :** **`O(logn)`**, where `n` is maximum power of 2 for which digits are counted (2^30). More specifically the time complexity can be written as `O(logN + log2 + log4 + ... + log(2^30))` which after ignoring the constant factors and lower order terms comes out to `O(logn)`.\\n**Time Complexity :** **`O(1)`**. We are using vector to store digits of `N` and powers of 2 but they are taking constant space and don\\'t depend on the input `N`.\\n\\n---------\\n---------\\n\\n***Solution - II (Convert to string & sort)***\\n\\nWe can convert `N` to string, sort it and compare it with every power of 2 by converting and sorting that as well.\\n\\n```\\nbool reorderedPowerOf2(int N) {\\n\\tstring n = to_string(N);\\n\\tsort(begin(n), end(n));\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1){\\n\\t\\tstring pow2_str = to_string(powOf2);\\n\\t\\tsort(begin(pow2_str), end(pow2_str));\\n\\t\\tif(n == pow2_str) return true;  \\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n-------\\n\\nBoth solutions have the same run-time -\\n\\n![image](https://assets.leetcode.com/users/images/ec72eb4f-071d-4c4f-91b1-c6c098015f29_1616318669.6588662.png)\\n\\n-------\\n-------",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// counts frequency of each digit in given number N and returns it as vector\\nvector<int> countDigits(int N){\\n\\tvector<int>digitsInN(10);\\n\\twhile(N)\\n\\t\\tdigitsInN[N % 10]++, N /= 10;\\n\\treturn digitsInN;\\n}\\nbool reorderedPowerOf2(int N) {\\n\\tvector<int> digitsInN = countDigits(N); // freq of digits in N\\n\\t// powOf2 goes from 2^0 to 2^29 and each time freq of digits in powOf2 is compared with digitsInN\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1)\\n\\t\\tif(digitsInN == countDigits(powOf2)) return true;  // return true if both have same frequency of each digits\\n\\treturn false;\\n}\\n```\n```\\nbool reorderedPowerOf2(int N) {\\n\\tstring n = to_string(N);\\n\\tsort(begin(n), end(n));\\n\\tfor(int i = 0, powOf2 = 1; i < 30; i++, powOf2 <<= 1){\\n\\t\\tstring pow2_str = to_string(powOf2);\\n\\t\\tsort(begin(pow2_str), end(pow2_str));\\n\\t\\tif(n == pow2_str) return true;  \\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1110674,
                "title": "encode-and-decode-tinyurl-short-easy-w-explanation",
                "content": "***Solution - I (Just to pass)***\\n\\nIf you just want to solve the question, here you go -\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```\\n\\n----------\\n----------\\n\\n***Solution - II***\\n\\nHere\\'s a better, more practical and robust solution which could be applied in real-world - \\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, string>UrlToCode, codeToUrl;\\n    string alphanumeric, base;    \\n\\t//                   \\uD83D\\uDD3Bs = secure = important! :)\\n    Solution(): base(\"https://tinyurl.com/\"),\\n    alphanumeric(\"abcdefghijklmnopqrstuvwxyzAbCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\") {\\n        srand(time(0)); // seed for random generator used by rand()\\n    }\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        // if encoded url already exists for a given longUrl (dont want duplicates for same url)\\n        if(UrlToCode.count(longUrl)) return base + UrlToCode[longUrl];\\n        string code = \"\";\\n        // generate a random code from alphanumeric string\\n        while(1){\\n            for(int i = 0; i < 6; i++)\\n                code += alphanumeric[rand() % 62];\\n            // if new code is formed, break out of loop\\n            if(!codeToUrl.count(code)) break; \\n            code = \"\";   // loop back to generate a new unique code\\n        }\\n        string encoded = base + code;\\n        UrlToCode[longUrl] = code;    // store longUrl to code mapping to avoid duplicates        \\n        codeToUrl[encoded] = longUrl; // to decode shortened url back to original\\n        return encoded;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return codeToUrl[shortUrl];\\n    }\\n};\\n```\\n\\nThe above code would need to try and generate a new code every time the randomly generated string is found to be already allocated. In theory, it could be possible that the algorithm takes infinite time to generate a shortened Url but I would put the probability of that to be about the same as all the vibrating atoms in your chairs aligning sideways to make you fall \\uD83E\\uDD37\\u200D\\uD83D\\uDE47.\\n\\n\\nSince our code space is huge (`62^6`), it is very unlikely that it would many iterations. We could always increase the `code` length to 7 or 8 to reduce collisions even further but it\\'s not really unnecessary.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        return longUrl;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, string>UrlToCode, codeToUrl;\\n    string alphanumeric, base;    \\n\\t//                   \\uD83D\\uDD3Bs = secure = important! :)\\n    Solution(): base(\"https://tinyurl.com/\"),\\n    alphanumeric(\"abcdefghijklmnopqrstuvwxyzAbCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\") {\\n        srand(time(0)); // seed for random generator used by rand()\\n    }\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        // if encoded url already exists for a given longUrl (dont want duplicates for same url)\\n        if(UrlToCode.count(longUrl)) return base + UrlToCode[longUrl];\\n        string code = \"\";\\n        // generate a random code from alphanumeric string\\n        while(1){\\n            for(int i = 0; i < 6; i++)\\n                code += alphanumeric[rand() % 62];\\n            // if new code is formed, break out of loop\\n            if(!codeToUrl.count(code)) break; \\n            code = \"\";   // loop back to generate a new unique code\\n        }\\n        string encoded = base + code;\\n        UrlToCode[longUrl] = code;    // store longUrl to code mapping to avoid duplicates        \\n        codeToUrl[encoded] = longUrl; // to decode shortened url back to original\\n        return encoded;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return codeToUrl[shortUrl];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135741,
                "title": "stamping-the-sequence-js-python-java-c-easy-reverse-matching-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nFor this problem, it\\'s easier to think of the target array (**T**) as being composed of layers of stamps (**S**). Since **T** represents the finished product of all the stamps, we\\'ll need to reverse the process and peel off one layer at a time.\\n```js\\n target:  a b a b a b c b c b a b a b c b c\\n\\n\\nlayer 1:          a b c           a b c    \\nlayer 2:      a b c   a b c   a b c   a b c\\nlayer 3:  a b c           a b c\\n```\\nSo we\\'ll need to iterate through **T** a number of times, finding and removing any full instances of **S**. Once we\\'re past the initial pass, we can use **character masks** to find partial matches for **S** on each remaining pass.\\n```\\n pass 1:  a b a b a b c b c b a b a b c b c\\n                  ^ ^ ^           ^ ^ ^\\n\\n pass 2:  a b a b * * * b c b a b * * * b c\\n              ^ ^ ^   ^ ^ ^   ^ ^ ^   ^ ^ ^\\n\\n pass 3:  a b * * * * * * * b * * * * * * *\\n          ^ ^ ^           ^ ^ ^\\n\\n pass 4:  * * * * * * * * * * * * * * * * *\\n```\\nTo speed things up, we should avoid a replacement if the partial match is actually the complete mask (ie, **\" * * * \"**), as nothing actually changed (**sdiff = false**). Then we should continue until we finish a pass without making any changes (**tdiff = false**).\\n\\nAt that point, if the remaining **T** is all masked, we can return our answer array (**ans**), otherwise we should return an empty array. Since we\\'re locating the stamp indexes in reverse order, we should either insert each newly-found index at the beginning of **ans**, or we should push them to the end and then reverse **ans** before we **return** it.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nSince we need to modify **T**, we should convert it to an array for all except C++, which has mutable strings.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **92ms / 40.5MB** (beats 100% / 100%).\\n```javascript\\nvar movesToStamp = function(S, T) {\\n    if (S === T) return [0]\\n    let slen = S.length, tlen = T.length - slen + 1,\\n        ans = [], tdiff = true, sdiff, i, j\\n    S = S.split(\"\"), T = T.split(\"\")\\n    while (tdiff)\\n        for (i = 0, tdiff = false; i < tlen; i++) {\\n            for (j = 0, sdiff = false; j < slen; j++)\\n                if (T[i+j] === \"*\") continue\\n                else if (T[i+j] !== S[j]) break\\n                else sdiff = true\\n            if (j === slen && sdiff) {\\n                for (j = i, tdiff = true; j < slen + i; j++)\\n                    T[j] = \"*\"\\n                ans.unshift(i)\\n            }\\n        }\\n    for (i = 0; i < T.length; i++) if (T[i] !== \"*\") return []\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **168ms / 14.3MB** (beats 86% / 99%).\\n```python\\nclass Solution:\\n    def movesToStamp(self, S: str, T: str) -> List[int]:\\n        if S == T: return [0]\\n        S, T = list(S), list(T)\\n        slen, tlen = len(S), len(T) - len(S) + 1\\n        ans, tdiff, sdiff = [], True, True\\n        while tdiff:\\n            tdiff = False\\n            for i in range(tlen):\\n                sdiff = False\\n                for j in range(slen):\\n                    if T[i+j] == \"*\": continue\\n                    if T[i+j] != S[j]: break\\n                    sdiff = True\\n                else: \\n                    if sdiff:\\n                        tdiff = True\\n                        for j in range(i, i + slen): T[j] = \"*\"\\n                        ans.append(i)\\n        for i in range(len(T)):\\n            if T[i] != \"*\": return []\\n        return reversed(ans)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **4ms / 38.6MB** (beats 67% / 100%).\\n```java\\nclass Solution {\\n    public int[] movesToStamp(String S, String T) {\\n        if (S == T) return new int[]{0};\\n        char[] SC = S.toCharArray(), TC = T.toCharArray();\\n        int slen = SC.length, tlen = TC.length - slen + 1, i, j;\\n        List<Integer> lans = new ArrayList<>();\\n        Boolean tdiff = true, sdiff;\\n        while (tdiff)\\n            for (i = 0, tdiff = false; i < tlen; i++) {\\n                for (j = 0, sdiff = false; j < slen; j++)\\n                    if (TC[i+j] == \\'*\\') continue;\\n                    else if (TC[i+j] != SC[j]) break;\\n                    else sdiff = true;\\n                if (j == slen && sdiff) {\\n                    for (j = i, tdiff = true; j < slen + i; j++)\\n                        TC[j] = \\'*\\';\\n                    lans.add(0, i);\\n                }\\n            }\\n        for (i = 0; i < TC.length; i++) if (TC[i] != \\'*\\') return new int[]{};\\n        int[] ans = new int[lans.size()];\\n        for (i = 0; i < lans.size(); i++) ans[i] = lans.get(i);\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **4ms / 7.2MB** (beats 99% / 95%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> movesToStamp(string S, string T) {\\n        if (S == T) return {0};\\n        int slen = S.size(), tlen = T.size() - slen + 1, i, j;\\n        vector<int> ans;\\n        bool tdiff = true, sdiff;\\n        while (tdiff)\\n            for (i = 0, tdiff = false; i < tlen; i++) {\\n                for (j = 0, sdiff = false; j < slen; j++)\\n                    if (T[i+j] == \\'*\\') continue;\\n                    else if (T[i+j] != S[j]) break;\\n                    else sdiff = true;\\n                if (j == slen && sdiff) {\\n                    for (j = i, tdiff = true; j < slen + i; j++)\\n                        T[j] = \\'*\\';\\n                    ans.push_back(i);\\n                }\\n            }\\n        for (i = 0; i < T.size(); i++) if (T[i] != \\'*\\') return {};\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n target:  a b a b a b c b c b a b a b c b c\\n\\n\\nlayer 1:          a b c           a b c    \\nlayer 2:      a b c   a b c   a b c   a b c\\nlayer 3:  a b c           a b c\\n```\n```\\n pass 1:  a b a b a b c b c b a b a b c b c\\n                  ^ ^ ^           ^ ^ ^\\n\\n pass 2:  a b a b * * * b c b a b * * * b c\\n              ^ ^ ^   ^ ^ ^   ^ ^ ^   ^ ^ ^\\n\\n pass 3:  a b * * * * * * * b * * * * * * *\\n          ^ ^ ^           ^ ^ ^\\n\\n pass 4:  * * * * * * * * * * * * * * * * *\\n```\n```javascript\\nvar movesToStamp = function(S, T) {\\n    if (S === T) return [0]\\n    let slen = S.length, tlen = T.length - slen + 1,\\n        ans = [], tdiff = true, sdiff, i, j\\n    S = S.split(\"\"), T = T.split(\"\")\\n    while (tdiff)\\n        for (i = 0, tdiff = false; i < tlen; i++) {\\n            for (j = 0, sdiff = false; j < slen; j++)\\n                if (T[i+j] === \"*\") continue\\n                else if (T[i+j] !== S[j]) break\\n                else sdiff = true\\n            if (j === slen && sdiff) {\\n                for (j = i, tdiff = true; j < slen + i; j++)\\n                    T[j] = \"*\"\\n                ans.unshift(i)\\n            }\\n        }\\n    for (i = 0; i < T.length; i++) if (T[i] !== \"*\") return []\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def movesToStamp(self, S: str, T: str) -> List[int]:\\n        if S == T: return [0]\\n        S, T = list(S), list(T)\\n        slen, tlen = len(S), len(T) - len(S) + 1\\n        ans, tdiff, sdiff = [], True, True\\n        while tdiff:\\n            tdiff = False\\n            for i in range(tlen):\\n                sdiff = False\\n                for j in range(slen):\\n                    if T[i+j] == \"*\": continue\\n                    if T[i+j] != S[j]: break\\n                    sdiff = True\\n                else: \\n                    if sdiff:\\n                        tdiff = True\\n                        for j in range(i, i + slen): T[j] = \"*\"\\n                        ans.append(i)\\n        for i in range(len(T)):\\n            if T[i] != \"*\": return []\\n        return reversed(ans)\\n```\n```java\\nclass Solution {\\n    public int[] movesToStamp(String S, String T) {\\n        if (S == T) return new int[]{0};\\n        char[] SC = S.toCharArray(), TC = T.toCharArray();\\n        int slen = SC.length, tlen = TC.length - slen + 1, i, j;\\n        List<Integer> lans = new ArrayList<>();\\n        Boolean tdiff = true, sdiff;\\n        while (tdiff)\\n            for (i = 0, tdiff = false; i < tlen; i++) {\\n                for (j = 0, sdiff = false; j < slen; j++)\\n                    if (TC[i+j] == \\'*\\') continue;\\n                    else if (TC[i+j] != SC[j]) break;\\n                    else sdiff = true;\\n                if (j == slen && sdiff) {\\n                    for (j = i, tdiff = true; j < slen + i; j++)\\n                        TC[j] = \\'*\\';\\n                    lans.add(0, i);\\n                }\\n            }\\n        for (i = 0; i < TC.length; i++) if (TC[i] != \\'*\\') return new int[]{};\\n        int[] ans = new int[lans.size()];\\n        for (i = 0; i < lans.size(); i++) ans[i] = lans.get(i);\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> movesToStamp(string S, string T) {\\n        if (S == T) return {0};\\n        int slen = S.size(), tlen = T.size() - slen + 1, i, j;\\n        vector<int> ans;\\n        bool tdiff = true, sdiff;\\n        while (tdiff)\\n            for (i = 0, tdiff = false; i < tlen; i++) {\\n                for (j = 0, sdiff = false; j < slen; j++)\\n                    if (T[i+j] == \\'*\\') continue;\\n                    else if (T[i+j] != S[j]) break;\\n                    else sdiff = true;\\n                if (j == slen && sdiff) {\\n                    for (j = i, tdiff = true; j < slen + i; j++)\\n                        T[j] = \\'*\\';\\n                    ans.push_back(i);\\n                }\\n            }\\n        for (i = 0; i < T.size(); i++) if (T[i] != \\'*\\') return {};\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123894,
                "title": "3sum-with-multiplicity-short-easy-w-explanation-beats-100",
                "content": "***Solution - I***\\n\\nWe can **sort the array and use a two pointer technique** on the sorted array. For each `i` in the sorted array, find two indices `j` and `k` (i < j < k) using 2-pointer such that `arr[j] + arr[k] = target - arr[i]`. Now, in a sorted array, duplicated `arr[j]` and `arr[k]` would appear consecutively. \\n\\nFor eg. Suppose we have target=4 and we are searching for `j` and `k` in subarray `[1,1,2,2,2,3,3,3]`. We find j can be 1st index and k can be last index. We pick up all elements equal to `arr[j]` (l=2) and `arr[k]` (r=3). A total of `l*r` will be added to the final count.\\n\\nWe also need to take care when `arr[j]` and `arr[k]` are the same element. In this case, a total of `(k-i) * (k-i+1)/2` has to be added. For eg. if we had a subarray `[2,2,2]` and needed to find such that `arr[j] + arr[k] = 4`, we would have 3 total pairs (`{0,1},{0,2},{1,2}`).\\n\\n**Note :** Sorting won\\'t affect our final answer. We just need to make sure that we choose 3 distinct elements from the array and the pair (i,j,k) is counted just once. Check for some array without and with sort and you would get the idea.\\n\\n```\\nint threeSumMulti(vector<int>& arr, int target) {\\n\\tint n = size(arr), ans = 0, mod = 1000000007;\\n\\tsort(begin(arr), end(arr));\\n\\tfor(int i = 0; i < n - 2; i++){\\n\\t\\tint T = target - arr[i],  j = i + 1, k = n - 1;\\n\\t\\twhile(j < k){\\n\\t\\t\\tif(arr[j] + arr[k] == T){\\n\\t\\t\\t\\tif(arr[j] == arr[k]){\\n\\t\\t\\t\\t\\tans = (ans + (((k - j) * (k - j + 1)) >> 1) % mod) % mod;  break;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint l = 1, r = 1;\\n\\t\\t\\t\\t\\twhile(j + 1 < k && arr[j] == arr[j + 1]) j++, l++;\\n\\t\\t\\t\\t\\twhile(k - 1 >= j && arr[k] == arr[k - 1]) k--, r++;\\n\\t\\t\\t\\t\\tans += (l * r) % mod;\\n\\t\\t\\t\\t\\tj++, k--;\\n\\t\\t\\t\\t}                    \\n\\t\\t\\t}\\n\\t\\t\\telse if(arr[j] + arr[k] < T) j++;\\n\\t\\t\\telse k--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n**Time Complexity :** **`O(N^2)`**, \\n**Space Complexity :** **`O(sort)`**, only extra space needed is the implict space used in sort.\\n\\n![image](https://assets.leetcode.com/users/images/0a7c2041-597f-4e63-ae63-dd71293423ce_1616512183.3679485.png)\\n\\n\\n---------\\n---------\\n\\n***Solution - II***\\n\\nWe can notice that elements of the array can be at max `100`. We can use this to optimise the solution further.\\n\\nInstead of choosing one index and finding the other two indices using two-pointer as done in previous approach, we can choose each number from `0 to 100` and if it exists in array, find other two numbers.\\n\\nWe need to maintain a frequency array to do this efficiently. We will have following cases (here i,j,k denote value of array we are checking, not indices) - \\n\\n* `i = j = k` : Add `freq[i] * (freq[i] - 1) * (freq[i] - 2) / 6` which is nothing but formula of number of ways to choose three distinct elements from n. \\n* `i = j != k` : Add `freq[k] + (freq[i] * (freq[i] - 1))/2` which denotes that number of `k`s and ways to choose 2 distinct elements from freq[i]\\n* `i != j = k` : Similar to above\\n* `i != j != k` : Just multiply all frequency to get the number of triplet possible.\\n\\n```\\nint threeSumMulti(vector<int>& arr, int t) {        \\n\\tint freq[101] = {0}, MAX = 0, ans = 0, mod = 1000000007;\\n\\tfor(auto& num : arr) freq[num]++, MAX = max(MAX, num);\\n\\tfor(int i = 0; i <= MAX; i++){\\n\\t\\tif(i + i + i == t) ans += (((long)freq[i] * (freq[i] - 1) * (freq[i] - 2)) / 6) % mod;\\n\\t\\tfor(int j = i + 1; j <= MAX; j++)               \\n\\t\\t\\tif(i + i + j == t) ans += (freq[i] * (freq[i] - 1) >> 1) * freq[j];\\n\\t\\t\\telse if(i + j + j == t) ans += (freq[j] * (freq[j] - 1) >> 1) * freq[i];\\n\\t\\t\\telse ans += (t - i - j > j  && t - i - j <= MAX ? freq[i] * freq[j] * freq[t - i - j] : 0) % mod;            \\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n**Time complexity :** `O(N + MAX^2)`, where `N` is the number of elemetns in `arr` and `MAX` is the maximum element of array.\\n**Space complexity :** `O(1)`\\n\\n![image](https://assets.leetcode.com/users/images/78e7c8d4-3227-43a4-a4be-4407041b7a42_1616509984.6405087.png)\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint threeSumMulti(vector<int>& arr, int target) {\\n\\tint n = size(arr), ans = 0, mod = 1000000007;\\n\\tsort(begin(arr), end(arr));\\n\\tfor(int i = 0; i < n - 2; i++){\\n\\t\\tint T = target - arr[i],  j = i + 1, k = n - 1;\\n\\t\\twhile(j < k){\\n\\t\\t\\tif(arr[j] + arr[k] == T){\\n\\t\\t\\t\\tif(arr[j] == arr[k]){\\n\\t\\t\\t\\t\\tans = (ans + (((k - j) * (k - j + 1)) >> 1) % mod) % mod;  break;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint l = 1, r = 1;\\n\\t\\t\\t\\t\\twhile(j + 1 < k && arr[j] == arr[j + 1]) j++, l++;\\n\\t\\t\\t\\t\\twhile(k - 1 >= j && arr[k] == arr[k - 1]) k--, r++;\\n\\t\\t\\t\\t\\tans += (l * r) % mod;\\n\\t\\t\\t\\t\\tj++, k--;\\n\\t\\t\\t\\t}                    \\n\\t\\t\\t}\\n\\t\\t\\telse if(arr[j] + arr[k] < T) j++;\\n\\t\\t\\telse k--;\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nint threeSumMulti(vector<int>& arr, int t) {        \\n\\tint freq[101] = {0}, MAX = 0, ans = 0, mod = 1000000007;\\n\\tfor(auto& num : arr) freq[num]++, MAX = max(MAX, num);\\n\\tfor(int i = 0; i <= MAX; i++){\\n\\t\\tif(i + i + i == t) ans += (((long)freq[i] * (freq[i] - 1) * (freq[i] - 2)) / 6) % mod;\\n\\t\\tfor(int j = i + 1; j <= MAX; j++)               \\n\\t\\t\\tif(i + i + j == t) ans += (freq[i] * (freq[i] - 1) >> 1) * freq[j];\\n\\t\\t\\telse if(i + j + j == t) ans += (freq[j] * (freq[j] - 1) >> 1) * freq[i];\\n\\t\\t\\telse ans += (t - i - j > j  && t - i - j <= MAX ? freq[i] * freq[j] * freq[t - i - j] : 0) % mod;            \\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1134012,
                "title": "russian-doll-envelopes-js-python-java-c-easy-lis-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to try every single permutation of our envelope array (**E**), but that would be a **time complexity** of **O(N!)** which is frankly an incomprehensible number when **N** goes up to **5000**.\\n\\nAs the naive approach would involve repeating many of the same individual comparisons over and over again, we can quickly see that a **dynamic programming** (**DP**) solution would be beneficial.\\n\\nIn order for a DP solution to be effective, however, we\\'d need to find a way to progress from the easiest subsolution and build from there for each successively more complex subsolution. The best way to do this would be to sort **E** first by **width** (**E[i][0]**), and then by **height** (**E[i][1]**).\\n\\nThen we could start with the smallest envelope and work our way up, storing in our DP array (**dp**) the result of how many smaller envelopes it is possible to fit in the corresponding envelope. That way we could simplify each iteration to checking to see which of the entries in **dp** corresponding to smaller envelopes is the largest. This would drop the time complexity to **O(N^2)**, which is a definite improvement.\\n\\nBut it should also be apparent that if we were to define a **subsequence** of **E** that was the ideal nesting order of envelopes for the solution, then that array would be strictly increasing in *both* width and height.\\n\\nIf we\\'ve already sorted **E** primarily by width, we should then be able to consider a corresponding array of just the heights and realize that the solution would be defined as the [**longest increasing subsequence**](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) of that.\\n\\nThe only difficulty would be for consecutive envelopes with the *same* sorted width. To avoid that, we can simply make sure that our sort function sorts height in descending order so that the first envelope encountered for any given width would be the largest one.\\n\\nAt the end of the longest increasing subsequence algorithm, the length of **dp** is equal to the length of the subsequence. Due to the sort function and the binary searches required for the algorithm, the time complexity now shrinks to **O(N log N)**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython has a built-in binary search function, **bisect()**.\\n\\nJava has a built-in binary search function as well (**Arrays.binarySearch()**), but in order to use the more performant **int[]** rather than a **List< Integer >**, we\\'ll need to specify a max length for **dp** and then keep track of the current index of the longest subsequence separately in **ans**.\\n\\nC++ has a built-in binary search function, **lower_bound()**.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 40.8MB** (beats 100% / 90%).\\n```javascript\\nvar maxEnvelopes = function(E) {\\n    E.sort((a,b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0])\\n    let len = E.length, dp = []\\n    for (let i = 0; i < len; i++) {\\n        let height = E[i][1], left = 0, right = dp.length   \\n        while (left < right) {\\n            let mid = (left + right) >> 1\\n            if (dp[mid] < height) left = mid + 1\\n            else right = mid\\n        }\\n        dp[left] = height\\n    }\\n    return dp.length\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **140ms / 16.4MB** (beats 97% / 85%).\\n```python\\nclass Solution:\\n    def maxEnvelopes(self, E: List[List[int]]) -> int:\\n        E.sort(key=lambda x: (x[0], -x[1]))\\n        dp = []\\n        for _,height in E:\\n            left = bisect_left(dp, height)\\n            if left == len(dp): dp.append(height)\\n            else: dp[left] = height\\n        return len(dp)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **7ms / 39.5MB** (beats 100% / 95%).\\n```java\\nclass Solution {\\n    public int maxEnvelopes(int[][] E) {\\n        Arrays.sort(E, (a,b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        int[] dp = new int[E.length];\\n        int ans = 0;\\n        for (int[] env : E) {\\n            int height = env[1];\\n            int left = Arrays.binarySearch(dp, 0, ans, height);\\n            if (left < 0) left = -left - 1;\\n            if (left == ans) ans++;\\n            dp[left] = height;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **32ms / 15.9MB** (beats 99% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& E) {\\n        sort(E.begin(), E.end(), [](vector<int>& a, vector<int>& b) \\n             -> bool {return a[0] == b[0] ? b[1] < a[1] : a[0] < b[0];});\\n        vector<int> dp;\\n        for (auto& env : E) {\\n            int height = env[1];\\n            int left = lower_bound(dp.begin(), dp.end(), height) - dp.begin();\\n            if (left == dp.size()) dp.push_back(height);\\n            dp[left] = height;\\n        }\\n        return dp.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar maxEnvelopes = function(E) {\\n    E.sort((a,b) => a[0] === b[0] ? b[1] - a[1] : a[0] - b[0])\\n    let len = E.length, dp = []\\n    for (let i = 0; i < len; i++) {\\n        let height = E[i][1], left = 0, right = dp.length   \\n        while (left < right) {\\n            let mid = (left + right) >> 1\\n            if (dp[mid] < height) left = mid + 1\\n            else right = mid\\n        }\\n        dp[left] = height\\n    }\\n    return dp.length\\n};\\n```\n```python\\nclass Solution:\\n    def maxEnvelopes(self, E: List[List[int]]) -> int:\\n        E.sort(key=lambda x: (x[0], -x[1]))\\n        dp = []\\n        for _,height in E:\\n            left = bisect_left(dp, height)\\n            if left == len(dp): dp.append(height)\\n            else: dp[left] = height\\n        return len(dp)\\n```\n```java\\nclass Solution {\\n    public int maxEnvelopes(int[][] E) {\\n        Arrays.sort(E, (a,b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        int[] dp = new int[E.length];\\n        int ans = 0;\\n        for (int[] env : E) {\\n            int height = env[1];\\n            int left = Arrays.binarySearch(dp, 0, ans, height);\\n            if (left < 0) left = -left - 1;\\n            if (left == ans) ans++;\\n            dp[left] = height;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxEnvelopes(vector<vector<int>>& E) {\\n        sort(E.begin(), E.end(), [](vector<int>& a, vector<int>& b) \\n             -> bool {return a[0] == b[0] ? b[1] < a[1] : a[0] < b[0];});\\n        vector<int> dp;\\n        for (auto& env : E) {\\n            int height = env[1];\\n            int left = lower_bound(dp.begin(), dp.end(), height) - dp.begin();\\n            if (left == dp.size()) dp.push_back(height);\\n            dp[left] = height;\\n        }\\n        return dp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113799,
                "title": "short-easy-w-explanation-diagrams-polar-notation-solution",
                "content": "We know that any point in a circle is of the form - `(Rcos\\u03B8, Rsin\\u03B8)`. For circles having center other than origin, this becomes - `(Xc + Rcos\\u03B8, Yc + Rsin\\u03B8)`. We might choose the approach to select random integer `[0, 1]` and multiply by `R` to generate a point uniformly between [0, R], then generate a random `\\u03B8` and finally generate points using the above-mentioned formula.\\n\\nHowever, the set of points generated by above approach won\\'t be uniformly distributed and more biased towards the center. This is because, the area towards the outer of circle is greater than towards the inner end of circle.\\n![image](https://assets.leetcode.com/users/images/ccdec8da-a911-497f-8df9-9cb03ab82393_1615977015.2818558.png)\\n\\nSo, for a section of circle `(\\u03B8, \\u03B8+\\u0394)`, for the points to be uniform, we need to generate more points towards the outer circle than we need towards inner of circle. \\n\\n---------\\n\\nFor this purpose, we use the square root function on the randomly generated point between [0, 1] (watch `sqrt()` is applied to `random()` in below code) to bias the outer end circle points. **Note that after applying sqrt on `random()` (a point between [0, 1]), the result would be a value greater than the original `random()` thus making it biased more towards the outer end**. This makes the point uniformly generated over all of the circle.\\n\\n\\n\\n\\n```\\nclass Solution {\\n    double R, X, Y;\\npublic:\\n    Solution(double radius, double x_center, double y_center) : R(radius), X(x_center), Y(y_center) {\\n        srand(time(0));\\n    }\\n    double random(){\\n        return (double)rand() / RAND_MAX;\\n    }\\n    vector<double> randPoint() {\\n        vector<double> randomPoint(2);\\n        double len = sqrt(random()) * R, deg = 2 * M_PI * random();\\n        randomPoint[0] = X + len * cos(deg);\\n        randomPoint[1] = Y + len * sin(deg);\\n        return randomPoint;\\n    }\\n};\\n```\\n\\n-----------\\n----------------------\\n\\n**Reason for choosing Square root function**\\n\\nThe reason for choosing `sqrt()` rather than any other functions like `cbrt()` to bias it towards outer end is that in the first approach mentioned above, the points generated were proportional to `R^2` because our random was proportional to `R`, thus making points over all area of circle proportional to `R^2` which made them concentrated more towards the center. Making our random proportional to `sqrt(R)` would make the points generated over all the area of circle proportional to `R` which would make all the points generate uniformly throughout the circle.\\n\\n\\n![image](https://assets.leetcode.com/users/images/ce0b6f64-0a90-4e58-b8b8-673d039e3bae_1615977676.6706777.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    double R, X, Y;\\npublic:\\n    Solution(double radius, double x_center, double y_center) : R(radius), X(x_center), Y(y_center) {\\n        srand(time(0));\\n    }\\n    double random(){\\n        return (double)rand() / RAND_MAX;\\n    }\\n    vector<double> randPoint() {\\n        vector<double> randomPoint(2);\\n        double len = sqrt(random()) * R, deg = 2 * M_PI * random();\\n        randomPoint[0] = X + len * cos(deg);\\n        randomPoint[1] = Y + len * sin(deg);\\n        return randomPoint;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125220,
                "title": "advantage-shuffle-js-python-java-c-short-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe general principle here is easy to understand: for each value in **B**, we ideally want to pick a number from **A** that is *just* higher to match up against it. The naive way to do this would require sorting **A**, then iterating through it until we find the ideal number, then removing that number from **A** and moving it to the answer array (**ans**) at a **time complexity** of **O(n^2)**.\\n\\nWe could employ a **binary search** instead of a straight iteration, which would drop the overall time complexity to **O(n * log n)**, matching the sort time complexity. The issue that remains, however, is that getting rid of elements of **A** can be time-consuming. (*Note: This method actually works well in Python; see the code below.*)\\n\\nInstead, if we had a sorted **B** as well, we could just match up the values very easily in descending order. If the largest remaining value of **A** is larger than the largest remaining value of **B**, then use it, otherwise, use the smallest remaining value of **A**, which is the least useful.\\n\\nSince we need to return our answer matched up agains the original order of **B**, however, we can\\'t just sort **B**. We can, however, create an **index order lookup array** and sort it in reference to the values in **B**, then use it as a bridge between the sorted **A** and unsorted **B**.\\n\\nOnce we\\'ve finished iterating, we can **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript as usual should take advantage of the faster typed arrays here.\\n\\nPython can convert **A** to a **deque** when it sorts to speed up the removal of elements from both ends. (Thanks [**@gizmo707**](https://leetcode.com/gizmo707)!)\\n\\nAs noted above, Python also has a very short, competitively performant version using **bisect** and without needing to sort **B**.\\n\\nJava will have to use a basic sort on **A**, as it\\'s a primitive array, but we can make **ord** an Integer array so that we can use a **lambda** sort. That means we\\'ll have to swap **i** and **j**.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **160ms / 47.8MB** (beats 100% / 70%).\\n```javascript\\nvar advantageCount = function(A, B) {\\n    let ord = Uint16Array.from({length:B.length}, (_,i) => i), \\n        ans = new Uint32Array(B.length),\\n        i = 0, j = B.length - 1\\n    ord.sort((a,b) => B[b] - B[a])\\n    A.sort((a,b) => b - a)\\n    for (let ix of ord)\\n        ans[ix] = A[i] > B[ix] ? A[i++] : A[j--]\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **308ms / 16.7MB** (beats 100% / 99%).\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        order = sorted(range(n), key=lambda x: B[x], reverse=True)\\n        ans = [0] * n\\n        A = deque(sorted(A))\\n        for ix in order:\\n            ans[ix] = A.pop() if A[-1] > B[ix] else A.popleft()\\n        return ans\\n```\\n\\n---\\n\\n#### ***Python Code w/ Binary Search:***\\n\\nThe best result for the code below is **344ms / 16.6MB** (beats 88% / 100%).\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        ans, A = [], sorted(A)\\n        for num in B:\\n            val = bisect_right(A, num)\\n            ans.append(A.pop(0) if val == len(A) else A.pop(val))\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **25ms / 41.3MB** (beats 100% / 85%).\\n```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Integer[] ord = new Integer[B.length];\\n        int[] ans = new int[A.length];\\n        for (int i = 0; i < B.length; i++) ord[i] = i;\\n        Arrays.sort(ord, (a,b) -> Integer.compare(B[b], B[a]));\\n        Arrays.sort(A);\\n        int i = 0, j = B.length - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[j] > B[ix] ? A[j--] : A[i++];\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **60ms / 33.4MB** (beats 99% / 97%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> ord = vector<int>(B.size()), ans = vector<int>(A.size());\\n        for (int i = 0; i < B.size(); i++) ord[i] = i;\\n        sort(ord.begin(), ord.end(), [&](int a, int b) {return B[a] > B[b];});\\n        sort(A.begin(), A.end(), greater<>());\\n        int i = 0, j = B.size() - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[i] > B[ix] ? A[i++] : A[j--];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar advantageCount = function(A, B) {\\n    let ord = Uint16Array.from({length:B.length}, (_,i) => i), \\n        ans = new Uint32Array(B.length),\\n        i = 0, j = B.length - 1\\n    ord.sort((a,b) => B[b] - B[a])\\n    A.sort((a,b) => b - a)\\n    for (let ix of ord)\\n        ans[ix] = A[i] > B[ix] ? A[i++] : A[j--]\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        order = sorted(range(n), key=lambda x: B[x], reverse=True)\\n        ans = [0] * n\\n        A = deque(sorted(A))\\n        for ix in order:\\n            ans[ix] = A.pop() if A[-1] > B[ix] else A.popleft()\\n        return ans\\n```\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        ans, A = [], sorted(A)\\n        for num in B:\\n            val = bisect_right(A, num)\\n            ans.append(A.pop(0) if val == len(A) else A.pop(val))\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int[] advantageCount(int[] A, int[] B) {\\n        Integer[] ord = new Integer[B.length];\\n        int[] ans = new int[A.length];\\n        for (int i = 0; i < B.length; i++) ord[i] = i;\\n        Arrays.sort(ord, (a,b) -> Integer.compare(B[b], B[a]));\\n        Arrays.sort(A);\\n        int i = 0, j = B.length - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[j] > B[ix] ? A[j--] : A[i++];\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n        vector<int> ord = vector<int>(B.size()), ans = vector<int>(A.size());\\n        for (int i = 0; i < B.size(); i++) ord[i] = i;\\n        sort(ord.begin(), ord.end(), [&](int a, int b) {return B[a] > B[b];});\\n        sort(A.begin(), A.end(), greater<>());\\n        int i = 0, j = B.size() - 1;\\n        for (int ix : ord)\\n            ans[ix] = A[i] > B[ix] ? A[i++] : A[j--];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113661,
                "title": "c-super-simple-easy-solution-faster-then-99",
                "content": "We generate random numbers until we find one that is in the circle.\\n```\\nclass Solution {\\npublic:\\n    Solution(double radius, double x_center, double y_center) : \\n    m_x_center(x_center), m_y_center(y_center), m_radius(radius) {}\\n    \\n    vector<double> randPoint() {\\n        double x, y;\\n        while (!isInCircle(x, y)) {\\n            x = (double)rand()/RAND_MAX * (m_radius + m_radius) + m_x_center - m_radius;\\n            y = (double)rand()/RAND_MAX * (m_radius + m_radius) + m_y_center - m_radius;\\n        }\\n        return {x, y};\\n    }\\n    \\n    bool isInCircle(double x, double y) { \\n        return ((x - m_x_center) * (x - m_x_center) + \\n            (y - m_y_center) * (y - m_y_center) <= m_radius * m_radius);\\n    } \\n    \\nprivate:\\n    double m_x_center;\\n    double m_y_center;\\n    double m_radius;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(double radius, double x_center, double y_center) : \\n    m_x_center(x_center), m_y_center(y_center), m_radius(radius) {}\\n    \\n    vector<double> randPoint() {\\n        double x, y;\\n        while (!isInCircle(x, y)) {\\n            x = (double)rand()/RAND_MAX * (m_radius + m_radius) + m_x_center - m_radius;\\n            y = (double)rand()/RAND_MAX * (m_radius + m_radius) + m_y_center - m_radius;\\n        }\\n        return {x, y};\\n    }\\n    \\n    bool isInCircle(double x, double y) { \\n        return ((x - m_x_center) * (x - m_x_center) + \\n            (y - m_y_center) * (y - m_y_center) <= m_radius * m_radius);\\n    } \\n    \\nprivate:\\n    double m_x_center;\\n    double m_y_center;\\n    double m_radius;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121849,
                "title": "vowel-spellchecker-js-python-java-c-easy-mask-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem can be broken up into a couple steps of increasing difficulty. The first step is to check whether or not the words in the query list (**Q**) exists in the word list (**W**). For that, we can use the simplest form of value-lookup data structure, which is a **Set**.\\n\\nNext, we need to check if each query has a case-insensitive match in **W**. For case-insensitive matching, the easiest thing to do is to **lowercase** (or **uppercase**) both terms before comparing. In this case, since we want to match one term, but return another, we should use a **Map** data structure, where the **key** is the lowercased term and the **value** is the matching **word**.\\n\\nBut here we encounter an issue, as it is possible for two words to have the same lowercase form. Per the rules we want to favor the one that appears first in **W**, so we can either iterate through **W** forwards and repeatedly check to make sure we\\'re not overwriting an existing entry, or we can simply iterate through **W** backwards and just automatically overwrite entries. This will force the first occurance to be the one that \"sticks\".\\n\\nFor the third check, we need to match the **word** except for the vowels. Whenever you need to selectively match strings by only a portion, the easiest way to do it is with a **mask**. In this case, we can use **regex** to replace all vowel occurrances with a **character mask**, such as **\"#\"**. For example, we can check if **\"tail\"** and **\"tool\"** would match by applying the character masks to both terms and seeing that **\"t##l\" == \"t##l\"**.\\n\\nThis calls for another map structure. We could technically reuse the earlier one, as there will be no overlaps, but navigating two separate, smaller maps is generally more efficient than one large one. Since we\\'ll also want to iterate backwards through **W** for this map, we migtht as well do it at the same time as the other one.\\n\\nThen we can just iterate through **Q** and check for matches in the correct order. As is generally the case with query lists, we can replace the queries in **Q** with their result in order to save on **space complexity**.\\n\\nThen, when we\\'re done, we just **return Q**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript can use **logical OR** chaining to shorten the assignment of the proper result in **Q**.\\n\\nRegex is much slower in Java and C++, so we can use a helper function to do the same thing for us.\\n\\nC++ will also need a helper to lowercase the words.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **108ms / 49.7MB** (beats 100% / 97%).\\n```javascript\\nconst regex = /[aeiou]/g\\nvar spellchecker = function(W, Q) {\\n    let orig = new Set(W), lower = new Map(), mask = new Map()\\n    for (let i = W.length - 1; ~i; i--) {\\n        let word = W[i], wlow = word.toLowerCase()\\n        lower.set(wlow, word)\\n        mask.set(wlow.replace(regex, \"*\"), word)\\n    }\\n    for (let i in Q) {\\n        let query = Q[i], qlow = query.toLowerCase(),\\n            qmask = qlow.replace(regex, \"*\")\\n        if (orig.has(query)) continue\\n        else Q[i] = lower.get(qlow) || mask.get(qmask) || \"\"\\n    }\\n    return Q\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **160ms / 16.6MB** (beats 98% / 85%).\\n```python\\nclass Solution:\\n    def spellchecker(self, W: List[str], Q: List[str]) -> List[str]:\\n        orig, lcase, mask = set(W), defaultdict(), defaultdict()\\n        regex = r\\'[aeiou]\\'\\n        for i in range(len(W)-1,-1,-1):\\n            word = W[i]\\n            wlow = word.lower()\\n            lcase[wlow] = word\\n            mask[re.sub(regex, \\'*\\', wlow)] = word\\n        for i in range(len(Q)):\\n            query = Q[i]\\n            qlow = query.lower()\\n            qmask = re.sub(regex, \\'*\\', qlow)\\n            if query in orig: continue\\n            elif qlow in lcase: Q[i] = lcase[qlow]\\n            elif qmask in mask: Q[i] = mask[qmask]\\n            else: Q[i] = \"\"\\n        return Q\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **16ms / 41.6MB** (beats 97% / 99%).\\n```java\\nclass Solution {\\n    public String[] spellchecker(String[] W, String[] Q) {\\n        Set<String> orig = new HashSet<>(Arrays.asList(W));\\n        Map<String, String> lower = new HashMap<>(), mask = new HashMap<>();\\n        for (int i = W.length - 1; i >= 0; i--) {\\n            String word = W[i], wlow = word.toLowerCase();\\n            lower.put(wlow, word);\\n            mask.put(vmask(wlow), word);\\n        }\\n        for (int i = 0; i < Q.length; i++) {\\n            String query = Q[i], qlow = query.toLowerCase(),\\n                qmask = vmask(qlow);\\n            if (orig.contains(query)) continue;\\n            else if (lower.containsKey(qlow)) Q[i] = lower.get(qlow);\\n            else if (mask.containsKey(qmask)) Q[i] = mask.get(qmask);\\n            else Q[i] = \"\";\\n        }\\n        return Q;\\n    }\\n    public String vmask(String str) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < str.length(); i++) {\\n            char c = str.charAt(i);\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') c = \\'*\\';\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **64ms / 32.7MB** (beats 85% / 87%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& W, vector<string>& Q) {\\n        set<string> orig (W.begin(), W.end());\\n        unordered_map<string, string> lower, mask;\\n        for (int i = W.size() - 1; ~i; i--) {\\n            string word = W[i], wlow = lcase(word);\\n            lower[wlow] = word, mask[vmask(wlow)] = word;\\n        }\\n        for (string &query : Q) {\\n            string qlow = lcase(query), qmask = vmask(qlow);\\n            if (orig.count(query)) continue;\\n            else if (lower.count(qlow)) query = lower[qlow];\\n            else if (mask.count(qmask)) query = mask[qmask];\\n            else query = \"\";\\n        }\\n        return Q;\\n    }\\n    static string vmask(string str) {\\n        for (char &c : str)\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n                c = \\'*\\';\\n        return str;\\n    }\\n    static string lcase(string str) {\\n        for (char &c : str) c = tolower(c);\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst regex = /[aeiou]/g\\nvar spellchecker = function(W, Q) {\\n    let orig = new Set(W), lower = new Map(), mask = new Map()\\n    for (let i = W.length - 1; ~i; i--) {\\n        let word = W[i], wlow = word.toLowerCase()\\n        lower.set(wlow, word)\\n        mask.set(wlow.replace(regex, \"*\"), word)\\n    }\\n    for (let i in Q) {\\n        let query = Q[i], qlow = query.toLowerCase(),\\n            qmask = qlow.replace(regex, \"*\")\\n        if (orig.has(query)) continue\\n        else Q[i] = lower.get(qlow) || mask.get(qmask) || \"\"\\n    }\\n    return Q\\n};\\n```\n```python\\nclass Solution:\\n    def spellchecker(self, W: List[str], Q: List[str]) -> List[str]:\\n        orig, lcase, mask = set(W), defaultdict(), defaultdict()\\n        regex = r\\'[aeiou]\\'\\n        for i in range(len(W)-1,-1,-1):\\n            word = W[i]\\n            wlow = word.lower()\\n            lcase[wlow] = word\\n            mask[re.sub(regex, \\'*\\', wlow)] = word\\n        for i in range(len(Q)):\\n            query = Q[i]\\n            qlow = query.lower()\\n            qmask = re.sub(regex, \\'*\\', qlow)\\n            if query in orig: continue\\n            elif qlow in lcase: Q[i] = lcase[qlow]\\n            elif qmask in mask: Q[i] = mask[qmask]\\n            else: Q[i] = \"\"\\n        return Q\\n```\n```java\\nclass Solution {\\n    public String[] spellchecker(String[] W, String[] Q) {\\n        Set<String> orig = new HashSet<>(Arrays.asList(W));\\n        Map<String, String> lower = new HashMap<>(), mask = new HashMap<>();\\n        for (int i = W.length - 1; i >= 0; i--) {\\n            String word = W[i], wlow = word.toLowerCase();\\n            lower.put(wlow, word);\\n            mask.put(vmask(wlow), word);\\n        }\\n        for (int i = 0; i < Q.length; i++) {\\n            String query = Q[i], qlow = query.toLowerCase(),\\n                qmask = vmask(qlow);\\n            if (orig.contains(query)) continue;\\n            else if (lower.containsKey(qlow)) Q[i] = lower.get(qlow);\\n            else if (mask.containsKey(qmask)) Q[i] = mask.get(qmask);\\n            else Q[i] = \"\";\\n        }\\n        return Q;\\n    }\\n    public String vmask(String str) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < str.length(); i++) {\\n            char c = str.charAt(i);\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\') c = \\'*\\';\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& W, vector<string>& Q) {\\n        set<string> orig (W.begin(), W.end());\\n        unordered_map<string, string> lower, mask;\\n        for (int i = W.size() - 1; ~i; i--) {\\n            string word = W[i], wlow = lcase(word);\\n            lower[wlow] = word, mask[vmask(wlow)] = word;\\n        }\\n        for (string &query : Q) {\\n            string qlow = lcase(query), qmask = vmask(qlow);\\n            if (orig.count(query)) continue;\\n            else if (lower.count(qlow)) query = lower[qlow];\\n            else if (mask.count(qmask)) query = mask[qmask];\\n            else query = \"\";\\n        }\\n        return Q;\\n    }\\n    static string vmask(string str) {\\n        for (char &c : str)\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n                c = \\'*\\';\\n        return str;\\n    }\\n    static string lcase(string str) {\\n        for (char &c : str) c = tolower(c);\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131066,
                "title": "reconstruct-original-digits-from-english-js-python-java-c-simple-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe most important thing we have to realize here is that some of the characters that make up the input string (**S**) can only belong to one possible word. This will immediately tell us how many of that digit should belong in our answer (**ans**).\\n\\nThe first thing we should do, then, is to create a **frequency map** (**fmap**) of all the characters in **S**. Since we\\'re dealing with characters here, we have the option to use an **arraymap** with **26** elements corresponding to the **0-index** code of each character rather than using a normal map object, which should speed up the processing.\\n\\nSome of the words, however, use only characters that can be found in more than one word, so we\\'ll have to carefully pick the order in which we figure out the frequency of each word, so that we can simplify later checks.\\n\\nFor example, the digits in the word forms of the digits **0**, **2**, **4**, **6**, and **8** all contain a character unique to that word, so we could iterate through those words and update the **fmap** entries for each of their characters to represent the removal of those words.\\n\\nBut we don\\'t really need to update the frequency of every character, only the ones that will be useful for isolating the remaining five words.\\n\\nTo keep track of the proper word order, the special character for each word, and the required characters to remove, we can declare a constant lookup array (**DIGITS**).\\n\\nIn order to keep **ans** in the proper order, we should initially put the individual digit strings in a temporary array and then **join ans** before we **return** it.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor Python, using **count()** is actually faster than using a **frequency map**, so we can reverse a bit of the process and remove the common letter results at the later word, rather than the earlier one.\\n\\nJava should split **S** into a **charArray** before iteration, and should use a **StringBuilder()** to concatenate **ans** before **return**ing it.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **84ms / 41.4MB** (beats 100% / 100%).\\n```javascript\\nconst DIGITS = [\\n    [\"0\",25,[14]],\\n    [\"2\",22,[14]],\\n    [\"4\",20,[5,14]],\\n    [\"6\",23,[18,8]],\\n    [\"8\",6,[8,7]],\\n    [\"5\",5,[8]],\\n    [\"7\",18,[]],\\n    [\"3\",7,[]],\\n    [\"9\",8,[]],\\n    [\"1\",14,[]]\\n]\\nvar originalDigits = function(S) {\\n    let fmap = new Uint16Array(26),\\n        ans = new Array(10), len = S.length\\n    for (let i = 0; i < len; i++)\\n        fmap[S.charCodeAt(i) - 97]++\\n    for (let i = 0; i < 10; i++) {\\n        let [dig, char, rems] = DIGITS[i],\\n            count = fmap[char]\\n        for (let j = 0; j < rems.length; j++)\\n            fmap[rems[j]] -= count\\n        ans[dig] = dig.repeat(count)\\n    }\\n    return ans.join(\"\")\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.8MB** (beats 100% / 27%).\\n```python\\nDIGITS = [\\n    [0,\\'z\\',[]],\\n    [2,\\'w\\',[]],\\n    [4,\\'u\\',[]],\\n    [6,\\'x\\',[]],\\n    [8,\\'g\\',[]],\\n    [5,\\'f\\',[4]],\\n    [7,\\'s\\',[6]],\\n    [3,\\'h\\',[8]],\\n    [9,\\'i\\',[6,8,5]],\\n    [1,\\'o\\',[0,2,4]]\\n]\\nclass Solution:\\n    def originalDigits(self, S: str) -> str:\\n        fmap, ans, n = [0] * 26, [0] * 10, len(S)\\n        for i in range(10):\\n            dig, char, rems = DIGITS[i]\\n            count = S.count(char)\\n            for rem in rems: count -= ans[rem]\\n            ans[dig] += count\\n        return \"\".join([str(i) * ans[i] for i in range(10)])\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **3ms / 39.3MB** (beats 100% / 90%).\\n```java\\nclass Solution {\\n    static final int[] DIGS = {0,2,4,6,8,5,7,3,9,1}, CHARS = {25,22,20,23,6,5,18,7,8,14};\\n    static final int[][] REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\n    public String originalDigits(String S) {\\n        int[] fmap = new int[26], ans = new int[10];\\n        char[] SCA = S.toCharArray();\\n        for (char c : SCA) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            char c = (char)(i + 48);\\n            for (int j = 0; j < ans[i]; j++)\\n                sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **8ms / 8.8MB** (beats 100% / 70%).\\n```c++\\nclass Solution {\\nconst int DIGS[10] = {0,2,4,6,8,5,7,3,9,1}, CHARS[10] = {25,22,20,23,6,5,18,7,8,14};\\nconst vector<vector<int>> REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\npublic:\\n    string originalDigits(string S) {\\n        int fmap[26] = {0}, ans[10] = {0};\\n        for (char c : S) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        string ansstr;\\n        for (int i = 0; i < 10; i++) {\\n            char c = (char)(i + 48);\\n            for (int j = ans[i]; j; j--)\\n                ansstr += c;\\n        }\\n        return ansstr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst DIGITS = [\\n    [\"0\",25,[14]],\\n    [\"2\",22,[14]],\\n    [\"4\",20,[5,14]],\\n    [\"6\",23,[18,8]],\\n    [\"8\",6,[8,7]],\\n    [\"5\",5,[8]],\\n    [\"7\",18,[]],\\n    [\"3\",7,[]],\\n    [\"9\",8,[]],\\n    [\"1\",14,[]]\\n]\\nvar originalDigits = function(S) {\\n    let fmap = new Uint16Array(26),\\n        ans = new Array(10), len = S.length\\n    for (let i = 0; i < len; i++)\\n        fmap[S.charCodeAt(i) - 97]++\\n    for (let i = 0; i < 10; i++) {\\n        let [dig, char, rems] = DIGITS[i],\\n            count = fmap[char]\\n        for (let j = 0; j < rems.length; j++)\\n            fmap[rems[j]] -= count\\n        ans[dig] = dig.repeat(count)\\n    }\\n    return ans.join(\"\")\\n};\\n```\n```python\\nDIGITS = [\\n    [0,\\'z\\',[]],\\n    [2,\\'w\\',[]],\\n    [4,\\'u\\',[]],\\n    [6,\\'x\\',[]],\\n    [8,\\'g\\',[]],\\n    [5,\\'f\\',[4]],\\n    [7,\\'s\\',[6]],\\n    [3,\\'h\\',[8]],\\n    [9,\\'i\\',[6,8,5]],\\n    [1,\\'o\\',[0,2,4]]\\n]\\nclass Solution:\\n    def originalDigits(self, S: str) -> str:\\n        fmap, ans, n = [0] * 26, [0] * 10, len(S)\\n        for i in range(10):\\n            dig, char, rems = DIGITS[i]\\n            count = S.count(char)\\n            for rem in rems: count -= ans[rem]\\n            ans[dig] += count\\n        return \"\".join([str(i) * ans[i] for i in range(10)])\\n```\n```java\\nclass Solution {\\n    static final int[] DIGS = {0,2,4,6,8,5,7,3,9,1}, CHARS = {25,22,20,23,6,5,18,7,8,14};\\n    static final int[][] REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\n    public String originalDigits(String S) {\\n        int[] fmap = new int[26], ans = new int[10];\\n        char[] SCA = S.toCharArray();\\n        for (char c : SCA) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < 10; i++) {\\n            char c = (char)(i + 48);\\n            for (int j = 0; j < ans[i]; j++)\\n                sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```c++\\nclass Solution {\\nconst int DIGS[10] = {0,2,4,6,8,5,7,3,9,1}, CHARS[10] = {25,22,20,23,6,5,18,7,8,14};\\nconst vector<vector<int>> REMS = {{14},{14},{5,14},{18,8},{8,7},{8},{},{},{},{}};\\npublic:\\n    string originalDigits(string S) {\\n        int fmap[26] = {0}, ans[10] = {0};\\n        for (char c : S) fmap[c - 97]++;\\n        for (int i = 0; i < 10; i++) {\\n            int count = fmap[CHARS[i]];\\n            for (int rem : REMS[i]) fmap[rem] -= count;\\n            ans[DIGS[i]] = count;\\n        }\\n        string ansstr;\\n        for (int i = 0; i < 10; i++) {\\n            char c = (char)(i + 48);\\n            for (int j = ans[i]; j; j--)\\n                ansstr += c;\\n        }\\n        return ansstr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128050,
                "title": "word-subsets-js-python-java-c-easy-merge-frequency-map-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe first major shortcut we can recognize is that if a word in **A** has to match *all* entries in **B**, then we shouldn\\'t have to think of all the entries of **B** as separate. Our first step should then be to merge all words in **B** into one master word for which all words in **B** are subsets of it. In **Example 5**, for instance, when **B = [\"ec\",\"oc\",\"ceo\"]**, the master word would be **\"ceo\"**.\\n\\nTo accomplish this, we\\'ll need to use some kind of **frequency map**. Since we\\'re dealing with characters, we can use an **arraymap** of length **26** which should be faster than using a regular map structure. We\\'ll need to have two such arraymaps: one will hold the accumulated data (**Bfreq**) and the other (**check**) will be used to temporarily store each word in **B** before checking it against **Bfreq**.\\n\\nRather than creating a new array for each word, we just need to make sure to reset **check** to all **0**\\'s before the next word.\\n\\nWhile we check through the words in **B**, we should also keep track of how many characters are currently stored in **Bfreq** (**cmax**). If **cmax** goes above **10**, then it won\\'t be possible for any word in **A** to match it due to the constraints upon **A.length**, so we should **return** an empty array.\\n\\nOnce we have our master word information stored in **Bfreq**, we can iterate through the words in **A** and compare them to **Bfreq** in a similar manner. First, however, we can easily skip any word that isn\\'t as long as **cmax**. If we get through the entire word without triggering an early **break**, we can add the word to our answer array (**ans**).\\n\\nOnce we\\'re all done iterating through **A**, we can **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython here is generally much slower with an **arraymap**, but can use a normal **dict** and **count()** to speed things up a bit.\\n\\nThere\\'s also an example of Python using Counter() and its easy comparisons for some short code.\\n\\nJava should convert the **Strings** to **char[]** before iterating through.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **132ms / 54.4MB** (beats 100% / 100%).\\n```javascript\\nvar wordSubsets = function(A, B) {\\n    let Bfreq = new Int8Array(26), cmax = 0,\\n        check = new Int8Array(26), ans = []\\n    for (let i = 0; i < B.length; i++, check.fill()) {\\n        let word = B[i]\\n        for (let j = 0; j < word.length; j++)\\n            check[word.charCodeAt(j) - 97]++\\n        for (let j = 0; j < 26; j++) {\\n            let diff = check[j] - Bfreq[j]\\n            if (diff > 0) cmax += diff, Bfreq[j] += diff\\n            if (cmax > 10) return []\\n        }\\n    }\\n    for (let i = 0; i < A.length; i++, check.fill()) {\\n        let word = A[i], j\\n        if (word.length < cmax) continue\\n        for (j = 0; j < word.length; j++)\\n            check[word.charCodeAt(j) - 97]++\\n        for (j = 0; j < 26; j++)\\n            if (check[j] < Bfreq[j]) break\\n        if (j === 26) ans.push(word)\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **464ms / 17.7MB** (beats 99% / 99%).\\n```python\\nclass Solution:\\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\\n        Bfreq, ans, cmax = {}, [], 0\\n        for word in B:\\n            for char in word:\\n                count = word.count(char)\\n                if char in Bfreq:\\n                    diff = count - Bfreq[char]\\n                    if diff > 0: \\n                        Bfreq[char] = count\\n                        cmax += diff\\n                else: \\n                    Bfreq[char] = count\\n                    cmax += count\\n            if cmax > 10: return ans\\n        print(Bfreq)\\n        for word in A:\\n            if len(word) < cmax: continue\\n            for char in Bfreq:\\n                if word.count(char) < Bfreq[char]: break\\n            else: ans.append(word)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Python Code w/ Counter:***\\n\\nThe best result for the code below is **1160ms / 17.8MB** (beats 34% / 92%).\\n```python\\nclass Solution:\\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\\n        Bfreq = Counter()\\n        for word in B: Bfreq |= Counter(word)\\n        if sum(Bfreq.values()) > 10: return []\\n        return [word for word in A if not Bfreq - Counter(word)]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **15ms / 46.8MB** (beats 95% / 90%).\\n```java\\nclass Solution {\\n    public List<String> wordSubsets(String[] A, String[] B) {\\n        int[] Bfreq = new int[26], check = new int[26];\\n        int cmax = 0;\\n        List<String> ans = new ArrayList<>();\\n        for (int i = 0; i < B.length; i++, Arrays.fill(check, 0)) {\\n            char[] word = B[i].toCharArray();\\n            for (int j = 0; j < word.length; j++)\\n                check[word[j] - \\'a\\']++;\\n            for (int j = 0; j < 26; j++) {\\n                int diff = check[j] - Bfreq[j];\\n                if (diff > 0) {\\n                    cmax += diff;\\n                    Bfreq[j] += diff;\\n                }\\n                if (cmax > 10) return ans;\\n            }\\n        }\\n        for (int i = 0; i < A.length; i++, Arrays.fill(check, 0)) {\\n            char[] word = A[i].toCharArray();\\n            int j;\\n            if (word.length < cmax) continue;\\n            for (j = 0; j < word.length; j++)\\n                check[word[j] - \\'a\\']++;\\n            for (j = 0; j < 26; j++)\\n                if (check[j] < Bfreq[j]) break;\\n            if (j == 26) ans.add(A[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **96ms / 57.1MB** (beats 98% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> wordSubsets(vector<string>& A, vector<string>& B) {\\n        int Bfreq[26] = {0}, check[26] = {0};\\n        int cmax = 0;\\n        vector<string> ans;\\n        for (string word : B) {\\n            for (char c : word) check[c - \\'a\\']++;\\n            for (int j = 0; j < 26; j++) {\\n                int diff = check[j] - Bfreq[j];\\n                if (diff > 0) cmax += diff, Bfreq[j] += diff;\\n            }\\n            if (cmax > 10) return ans;\\n            fill(check, check+26, 0);\\n        }\\n        for (string word : A) {\\n            int j;\\n            for (char c : word) check[c - \\'a\\']++;\\n            for (j = 0; j < 26; j++)\\n                if (check[j] < Bfreq[j]) break;\\n            if (j == 26) ans.push_back(word);\\n            fill(check, check+26, 0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar wordSubsets = function(A, B) {\\n    let Bfreq = new Int8Array(26), cmax = 0,\\n        check = new Int8Array(26), ans = []\\n    for (let i = 0; i < B.length; i++, check.fill()) {\\n        let word = B[i]\\n        for (let j = 0; j < word.length; j++)\\n            check[word.charCodeAt(j) - 97]++\\n        for (let j = 0; j < 26; j++) {\\n            let diff = check[j] - Bfreq[j]\\n            if (diff > 0) cmax += diff, Bfreq[j] += diff\\n            if (cmax > 10) return []\\n        }\\n    }\\n    for (let i = 0; i < A.length; i++, check.fill()) {\\n        let word = A[i], j\\n        if (word.length < cmax) continue\\n        for (j = 0; j < word.length; j++)\\n            check[word.charCodeAt(j) - 97]++\\n        for (j = 0; j < 26; j++)\\n            if (check[j] < Bfreq[j]) break\\n        if (j === 26) ans.push(word)\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\\n        Bfreq, ans, cmax = {}, [], 0\\n        for word in B:\\n            for char in word:\\n                count = word.count(char)\\n                if char in Bfreq:\\n                    diff = count - Bfreq[char]\\n                    if diff > 0: \\n                        Bfreq[char] = count\\n                        cmax += diff\\n                else: \\n                    Bfreq[char] = count\\n                    cmax += count\\n            if cmax > 10: return ans\\n        print(Bfreq)\\n        for word in A:\\n            if len(word) < cmax: continue\\n            for char in Bfreq:\\n                if word.count(char) < Bfreq[char]: break\\n            else: ans.append(word)\\n        return ans\\n```\n```python\\nclass Solution:\\n    def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:\\n        Bfreq = Counter()\\n        for word in B: Bfreq |= Counter(word)\\n        if sum(Bfreq.values()) > 10: return []\\n        return [word for word in A if not Bfreq - Counter(word)]\\n```\n```java\\nclass Solution {\\n    public List<String> wordSubsets(String[] A, String[] B) {\\n        int[] Bfreq = new int[26], check = new int[26];\\n        int cmax = 0;\\n        List<String> ans = new ArrayList<>();\\n        for (int i = 0; i < B.length; i++, Arrays.fill(check, 0)) {\\n            char[] word = B[i].toCharArray();\\n            for (int j = 0; j < word.length; j++)\\n                check[word[j] - \\'a\\']++;\\n            for (int j = 0; j < 26; j++) {\\n                int diff = check[j] - Bfreq[j];\\n                if (diff > 0) {\\n                    cmax += diff;\\n                    Bfreq[j] += diff;\\n                }\\n                if (cmax > 10) return ans;\\n            }\\n        }\\n        for (int i = 0; i < A.length; i++, Arrays.fill(check, 0)) {\\n            char[] word = A[i].toCharArray();\\n            int j;\\n            if (word.length < cmax) continue;\\n            for (j = 0; j < word.length; j++)\\n                check[word[j] - \\'a\\']++;\\n            for (j = 0; j < 26; j++)\\n                if (check[j] < Bfreq[j]) break;\\n            if (j == 26) ans.add(A[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<string> wordSubsets(vector<string>& A, vector<string>& B) {\\n        int Bfreq[26] = {0}, check[26] = {0};\\n        int cmax = 0;\\n        vector<string> ans;\\n        for (string word : B) {\\n            for (char c : word) check[c - \\'a\\']++;\\n            for (int j = 0; j < 26; j++) {\\n                int diff = check[j] - Bfreq[j];\\n                if (diff > 0) cmax += diff, Bfreq[j] += diff;\\n            }\\n            if (cmax > 10) return ans;\\n            fill(check, check+26, 0);\\n        }\\n        for (string word : A) {\\n            int j;\\n            for (char c : word) check[c - \\'a\\']++;\\n            for (j = 0; j < 26; j++)\\n                if (check[j] < Bfreq[j]) break;\\n            if (j == 26) ans.push_back(word);\\n            fill(check, check+26, 0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122188,
                "title": "vowel-spellchecker-short-easy-w-explanation-beats-100",
                "content": "***Solution - I (Naive Approach - Rejected)***\\n\\nWe can try to directly implement the solution using brute force as follows - \\n\\n```\\n// Checks for case-insensitive match between two strings\\nbool caseInsensitiveEqual(string &a, string &b){\\n\\treturn equal(begin(a), end(a), begin(b), end(b), [](char &a, char &b){\\n\\t   return tolower(a) == tolower(b); \\n\\t});\\n}\\n// Checks if given character is vowel\\nbool isVowel(char &c){\\n\\tc = tolower(c);\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n// Checks if both string can be made same after vowels replacement\\nbool vowelFreqCheck(string a, string b){\\n\\tif(size(a) != size(b)) return false;\\n\\tint n = size(a);\\n\\tfor(int i = 0; i < n; i++)            \\n\\t\\tif((!isVowel(a[i]) || !isVowel(b[i])) && tolower(a[i]) != tolower(b[i])) return false;\\n\\treturn true;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tint n = size(queries);\\n\\tvector<string> answer(n, \"\");\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tbool matched = false;\\n\\t\\t// Check if exact match is found\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(word == queries[i]){ queries[i] = word; matched = true; break; }\\n\\t\\tif(matched) continue; // move on to next query if match found\\n\\t\\t// Check if case-insensitive match is found\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(caseInsensitiveEqual(word, queries[i])){ queries[i] = word; matched = true; break; }\\n\\t\\tif(matched) continue; // move on to next query if match found\\n\\t\\t// Check if after vowel-replacement, the strings match\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(vowelFreqCheck(word, queries[i])){ queries[i] = word; matched = true; break; }\\n\\t\\tif(!matched) queries[i] = \"\"; // if no match found in any case return empty string\\n\\t}\\n\\treturn queries;\\n}\\n```\\n\\n**Time Complexity :** **`O(N*Q)`**, where `N` is the sum of lengths of words in `wordlist` and `Q` is the sum of lengths of queries.\\n**Space Complexity :** **`O(1)`**, since we are using the queries array itself. If queries array must not be modified, we would need a space complexity of `O(N)`\\n\\nThis approach is very direct implementation without any optimization and as a results times out on larger test cases.\\n\\n------------\\n------------\\n\\n***Solution - II (Time-Optimised using Hashmaps)***\\n\\nWe can optimise the solution by trading space for time. We don\\'t need to loop through the whole wordlist for every query if we use a hashmaps. The hashmaps used are - \\n1. **`lowered`** : It maps word from wordlist converted to lowercase to the original word.\\n2. **`vowelMasked`** : It maps lowered and masked vowel word from wordlist to the original word. Masking will help finding words that can be formed from one another by replacing a vowel with another vowel.\\n3. **`original_words`**: Its a hashset which stores all the original words of wordlist. Since the word is mapped to itself, we can use hashset instead and save space.\\n\\nUsing these maps, we have eliminated the need the need to loop **`wordlist`** over and over. We can now just check which of the condition the query satisfies in the precedence given in the problem.\\n\\n\\n```\\nstring toLowercase(string &s){\\n\\tfor(char& c : s) c = tolower(c);\\n\\treturn s;\\n}\\nbool isVowel(char &c){\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n// masking will help check if a word satisfies vowel-error condition\\nstring maskVowel(string &s){\\n\\tfor(char& c : s) if(isVowel(c)) c = \\'#\\';\\n\\treturn s;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tunordered_set original_words(begin(wordlist), end(wordlist));\\n\\tunordered_map<string, string> lowered, vowelMasked;\\n\\tstring tmp;\\n\\t// we are reverse-iterating since we need to find the first matching word\\n\\t// so, we need to update maps to hold the first-most word satisfying a condition\\n\\tfor(auto word = rbegin(wordlist); word != rend(wordlist); word++) \\n\\t\\ttmp = *word, lowered[toLowercase(tmp)] = *word, vowelMasked[maskVowel(tmp)] = *word;\\n\\tfor(string& q : queries){\\n\\t\\t// if exact word is found, continue since we already have it stored in queries[i] (Note : we are returing queries itself)\\n\\t\\tif(original_words.count(q)) continue;\\n\\t\\t// if query converted to lowercase matches with lower-cased word, return the corresponding mapped word from lowered hashmap\\n\\t\\telse if(lowered.count(toLowercase(q))) q = lowered[q];\\n\\t\\t// if query converted to lowercase & vowels masked matches with lower-cased vowel-masked word, return the mapped word from vowelMasked hashmap\\n\\t\\telse if(vowelMasked.count(maskVowel(q))) q = vowelMasked[q];\\n\\t\\telse q = \"\"; // if no match found, return empty string\\n\\t}\\n\\treturn queries;\\n}\\n```\\n\\n**Time Complexity :** **`O(N + Q)`**, where `N` is the sum of lengths of words in `wordlist` and `Q` is the sum of lengths of queries.\\n**Space Complexity :** **`O(N)`**, for storing in the hashmaps.\\n\\n![image](https://assets.leetcode.com/users/images/708c9d3e-6c0d-4a25-93a7-82bf463b9bd6_1616422339.8202226.png)\\n\\n\\n------------\\n------------\\n\\n***Solution - III (Further Space-Optimisation using custom hash)***\\n\\nWe don\\'t need to store the entire strings in the hashmaps as we did above. We can convert the string to a hash value and store it as a integer. \\n\\nIn this problem, since the max length of word/query is `7`, we won\\'t see much benefits (in the best case, we are improving space for keys from **`7 bytes`** to **`4 bytes`** for int). But if the words are of larger size, it would be an much optimised approach.\\n\\n```\\nstring toLowercase(string &s){\\n\\tfor(char& c : s) c = tolower(c);\\n\\treturn s;\\n}\\nbool isVowel(char c){\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\nstring maskVowel(string &s){\\n\\tfor(char& c : s) if(isVowel(c)) c = \\'#\\';\\n\\treturn s;\\n}\\nint hash(string s){\\n\\tlong h = 0, mod = 1e9 + 7;\\n\\tfor(char& c : s) h = (h * 101 + c) % mod;\\n\\treturn h;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tunordered_set<int> orig;\\n\\tunordered_map<int, string> lowered, vowelMasked;\\n\\tstring tmp;\\n\\tfor(vector<string>::reverse_iterator word = rbegin(wordlist); word != rend(wordlist); word++) \\n\\t\\ttmp = *word,orig.insert(hash(tmp)), lowered[hash(toLowercase(tmp))] = *word, vowelMasked[hash(maskVowel(tmp))] = *word;\\n\\tint h;\\n\\tfor(string& q : queries)\\n\\t\\tif(orig.count(hash(q))) continue;\\n\\t\\telse if(lowered.count(h = hash(toLowercase(q)))) q = lowered[h];\\n\\t\\telse if(vowelMasked.count(h = hash(maskVowel(q)))) q = vowelMasked[h];\\n\\t\\telse q = \"\";\\n\\treturn queries;\\n}\\n```\\n\\n**Time Complexity :** **`O(N + Q)`**, where `N` is the sum of lengths of words in `wordlist` and `Q` is the sum of lengths of queries.\\n**Space Complexity :** **`O(N)`**, for storing in the hashmaps. Although, the space complexity is still the same, we have eliminated a good chunk of constant factor without any addition to time complexity.\\n\\nNote that we would need to choose a good hash function. Luckily, the one I chose didn\\'t give any collisions. For more robust solution, you would need to handle collision cases also.\\n\\n![image](https://assets.leetcode.com/users/images/50e5afb2-f245-477c-8ede-18904754e93b_1616422748.4772894.png)\\n\\n\\n-----------\\n-----------",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Checks for case-insensitive match between two strings\\nbool caseInsensitiveEqual(string &a, string &b){\\n\\treturn equal(begin(a), end(a), begin(b), end(b), [](char &a, char &b){\\n\\t   return tolower(a) == tolower(b); \\n\\t});\\n}\\n// Checks if given character is vowel\\nbool isVowel(char &c){\\n\\tc = tolower(c);\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n// Checks if both string can be made same after vowels replacement\\nbool vowelFreqCheck(string a, string b){\\n\\tif(size(a) != size(b)) return false;\\n\\tint n = size(a);\\n\\tfor(int i = 0; i < n; i++)            \\n\\t\\tif((!isVowel(a[i]) || !isVowel(b[i])) && tolower(a[i]) != tolower(b[i])) return false;\\n\\treturn true;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tint n = size(queries);\\n\\tvector<string> answer(n, \"\");\\n\\tfor(int i = 0; i < n; i++){\\n\\t\\tbool matched = false;\\n\\t\\t// Check if exact match is found\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(word == queries[i]){ queries[i] = word; matched = true; break; }\\n\\t\\tif(matched) continue; // move on to next query if match found\\n\\t\\t// Check if case-insensitive match is found\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(caseInsensitiveEqual(word, queries[i])){ queries[i] = word; matched = true; break; }\\n\\t\\tif(matched) continue; // move on to next query if match found\\n\\t\\t// Check if after vowel-replacement, the strings match\\n\\t\\tfor(string& word : wordlist)\\n\\t\\t\\tif(vowelFreqCheck(word, queries[i])){ queries[i] = word; matched = true; break; }\\n\\t\\tif(!matched) queries[i] = \"\"; // if no match found in any case return empty string\\n\\t}\\n\\treturn queries;\\n}\\n```\n```\\nstring toLowercase(string &s){\\n\\tfor(char& c : s) c = tolower(c);\\n\\treturn s;\\n}\\nbool isVowel(char &c){\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n// masking will help check if a word satisfies vowel-error condition\\nstring maskVowel(string &s){\\n\\tfor(char& c : s) if(isVowel(c)) c = \\'#\\';\\n\\treturn s;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tunordered_set original_words(begin(wordlist), end(wordlist));\\n\\tunordered_map<string, string> lowered, vowelMasked;\\n\\tstring tmp;\\n\\t// we are reverse-iterating since we need to find the first matching word\\n\\t// so, we need to update maps to hold the first-most word satisfying a condition\\n\\tfor(auto word = rbegin(wordlist); word != rend(wordlist); word++) \\n\\t\\ttmp = *word, lowered[toLowercase(tmp)] = *word, vowelMasked[maskVowel(tmp)] = *word;\\n\\tfor(string& q : queries){\\n\\t\\t// if exact word is found, continue since we already have it stored in queries[i] (Note : we are returing queries itself)\\n\\t\\tif(original_words.count(q)) continue;\\n\\t\\t// if query converted to lowercase matches with lower-cased word, return the corresponding mapped word from lowered hashmap\\n\\t\\telse if(lowered.count(toLowercase(q))) q = lowered[q];\\n\\t\\t// if query converted to lowercase & vowels masked matches with lower-cased vowel-masked word, return the mapped word from vowelMasked hashmap\\n\\t\\telse if(vowelMasked.count(maskVowel(q))) q = vowelMasked[q];\\n\\t\\telse q = \"\"; // if no match found, return empty string\\n\\t}\\n\\treturn queries;\\n}\\n```\n```\\nstring toLowercase(string &s){\\n\\tfor(char& c : s) c = tolower(c);\\n\\treturn s;\\n}\\nbool isVowel(char c){\\n\\treturn c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\nstring maskVowel(string &s){\\n\\tfor(char& c : s) if(isVowel(c)) c = \\'#\\';\\n\\treturn s;\\n}\\nint hash(string s){\\n\\tlong h = 0, mod = 1e9 + 7;\\n\\tfor(char& c : s) h = (h * 101 + c) % mod;\\n\\treturn h;\\n}\\nvector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n\\tunordered_set<int> orig;\\n\\tunordered_map<int, string> lowered, vowelMasked;\\n\\tstring tmp;\\n\\tfor(vector<string>::reverse_iterator word = rbegin(wordlist); word != rend(wordlist); word++) \\n\\t\\ttmp = *word,orig.insert(hash(tmp)), lowered[hash(toLowercase(tmp))] = *word, vowelMasked[hash(maskVowel(tmp))] = *word;\\n\\tint h;\\n\\tfor(string& q : queries)\\n\\t\\tif(orig.count(hash(q))) continue;\\n\\t\\telse if(lowered.count(h = hash(toLowercase(q)))) q = lowered[h];\\n\\t\\telse if(vowelMasked.count(h = hash(maskVowel(q)))) q = vowelMasked[h];\\n\\t\\telse q = \"\";\\n\\treturn queries;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1136052,
                "title": "stamping-the-sequence-short-easy-w-explanation-greedy-approach",
                "content": "This was probably the toughest question in March Challenge. I will try to explain the logic in simplest way possible.\\n\\nFirstly, the question in simple terms - We have a string `????...` which we have to stamp upon repeatedly using **`stamp`** to achieve the **`target`** string (in atmost **`10*T`**, `T = len(target)`).\\n\\n------\\n\\n***Solution (Greedy Approach - Start From Backwards) :***\\n\\nWe can see that in a **valid stamp sequence** -\\n\\n * the last stamping will happen on a substring of **`target`** which is equal to **`stamp`**\\n *  Rest of stamping will occur on substring of **`target`** which may match whole `stamp` itself or a partial match of  **`stamp`** with already stamped characters at beginning/end or both. The example below will make it clear. \\n\\n(*Why allow substring match with already stamped characters at begin/end*? Because, in real stamping sequence, the future stamping can be used restamp on start/end characters which didn\\'t match completely at partial substring match mentioned above.)\\n\\nFrom the above observation, we can see that it would be **easier if we start from backwards** by finding the index of last stamping which will be start of substring of *`target`* completely matching *`stamp`*.  The next stamping would either be another complete match or a partial substring match of *`stamp`* with begin/end having already stamped characters meaning overlapping with previous stamping (previous in our backward approach not in real stamping sequence. We are going to **reverse this sequence at last to find the real stamping sequence**). \\n\\nTo make it easier to detect previous stamping, lets replace the stamped substrings of *`targets`* with **`*`** (stars). An example would give a better understanding - \\n\\n```\\ntarget = \"aabccbabc\", stamp = \"abc\"\\n-------------------------------------------\\n        i=1\\n\\t1. aabccbabc                             \\n\\t\\t^^^   ->  First match found at index 1. After stamping it becomes - a***cbabc\\n=> stamping seq = [1]\\n\\t\\t i=2\\t\\n\\t2. a***cbabc\\n\\t     ^^^  -> Found a partial match of stamp with *s(already stamped) at begin. After stamping, it becomes - a****babc\\n=> stamping seq = [1, 2]\\n\\n\"NOTE : In the above case, we could have selected index 6 as well which would have produced a valid answer.\\nBut, we are using a greedy approach in our iteration, matching the first partial/complete match of stamp in target.\"\\n             i=6\\n\\t3. a****babc\\n\\t\\t\\t ^^^ -> Found a complete match. After stamping, it becomes a****b***\\n=> stamping seq = [1, 2, 6]\\n       i=0     (restarted iteration - loop till all become stars)\\n\\t4. a****b***\\n\\t   ^^^ -> Found a partial match with *s at end. After stamping -> *****b***\\n=> stamping seq = [1, 2, 6, 0]\\n           i=4\\n\\t5. *****b***\\n\\t\\t   ^^^ -> Found a partial match *s at being & end. ********* after stamping.\\n=> stamping seq = [1, 2, 6, 0, 4]\\n\\nNow, all the characters are stamped. We break the iteration.\\n\\nThe final correct sequence will be reverse of the sequence we found above (since we are starting from reverse).\\nThus, Correct Stamping Sequence => [4, 0, 6, 2, 1].\\n```\\n\\nAlso, we must not get stuck into infinite loop replacing stars (*) with stars for which we maintain a visisted array to avoid revisiting the index at which replacement already occured. Also, if at any point we iterate whole array but are unable to replace any, then the sequence isn\\'t valid, so return [].\\n\\n----\\n\\n***Implementation Code***\\n\\n```\\nint stars, n, m;\\nvector<int> ans;     \\nvector<int> movesToStamp(string stamp, string target) {\\n\\tstars = 0, n = size(target), m = size(stamp);        \\n\\tvector<bool> vis(n, false);  // to avoid revisiting index at which replacement already occurred\\n\\twhile(stars < n){            // till all characters have not been stamped\\n\\t\\tbool replaced = false;\\n\\t\\tfor(int i = 0; i <= n - m && stars < n; i++)\\n\\t\\t\\t// for each non-visited index, check if there\\'s a match with \\'stamp\\' for target substring starting at i\\n\\t\\t\\t// replace and increment the stars count if there\\'s a match (partial or complete)\\n\\t\\t\\tif(!vis[i]) replaced = checkAndReplace(target, i, stamp), vis[i] = replaced;\\n\\t\\tif(!replaced) return {}; // if no replacement occurs throughout one iteration over target, return []\\n\\t}            \\n\\t// we began with reverse appraoch, real sequence will be reverse of what we got\\n\\treverse(begin(ans), end(ans));\\n\\treturn ans;\\n}\\nbool checkAndReplace(string& target, int& start, string& stamp){\\n\\t// check for match\\n\\tfor(int i = 0; i < m; i++)\\n\\t\\tif(target[i + start] != \\'*\\' && target[i + start] != stamp[i]) return false;\\n\\t// match occurs - push index into ans and replace start to start+m\\twith *\\n\\tans.push_back(start);\\n\\tfor(int i = start; i - start < m; i++) \\t\\n\\t\\tstars += (target[i] != \\'*\\'), target[i] = \\'*\\';        \\n\\t\\t// dont count \\u2B06\\uFE0F if it was already star character\\n\\treturn true; // denotes replacement happened at index start to start + m\\n}\\n```\\n\\n***Time Complexity :*** **`O(N*(N-M))`**. In worst case, we might only add 1 extra star in each iteration of target, and we would have to iterate `N-M` length for `N` times to make all characters starred. Consider example - `target = \"aaaaaaaaabc\",  stamp = \"abc\"`.\\n\\n***Space Complexity :*** **`O(N)`**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntarget = \"aabccbabc\", stamp = \"abc\"\\n-------------------------------------------\\n        i=1\\n\\t1. aabccbabc                             \\n\\t\\t^^^   ->  First match found at index 1. After stamping it becomes - a***cbabc\\n=> stamping seq = [1]\\n\\t\\t i=2\\t\\n\\t2. a***cbabc\\n\\t     ^^^  -> Found a partial match of stamp with *s(already stamped) at begin. After stamping, it becomes - a****babc\\n=> stamping seq = [1, 2]\\n\\n\"NOTE : In the above case, we could have selected index 6 as well which would have produced a valid answer.\\nBut, we are using a greedy approach in our iteration, matching the first partial/complete match of stamp in target.\"\\n             i=6\\n\\t3. a****babc\\n\\t\\t\\t ^^^ -> Found a complete match. After stamping, it becomes a****b***\\n=> stamping seq = [1, 2, 6]\\n       i=0     (restarted iteration - loop till all become stars)\\n\\t4. a****b***\\n\\t   ^^^ -> Found a partial match with *s at end. After stamping -> *****b***\\n=> stamping seq = [1, 2, 6, 0]\\n           i=4\\n\\t5. *****b***\\n\\t\\t   ^^^ -> Found a partial match *s at being & end. ********* after stamping.\\n=> stamping seq = [1, 2, 6, 0, 4]\\n\\nNow, all the characters are stamped. We break the iteration.\\n\\nThe final correct sequence will be reverse of the sequence we found above (since we are starting from reverse).\\nThus, Correct Stamping Sequence => [4, 0, 6, 2, 1].\\n```\n```\\nint stars, n, m;\\nvector<int> ans;     \\nvector<int> movesToStamp(string stamp, string target) {\\n\\tstars = 0, n = size(target), m = size(stamp);        \\n\\tvector<bool> vis(n, false);  // to avoid revisiting index at which replacement already occurred\\n\\twhile(stars < n){            // till all characters have not been stamped\\n\\t\\tbool replaced = false;\\n\\t\\tfor(int i = 0; i <= n - m && stars < n; i++)\\n\\t\\t\\t// for each non-visited index, check if there\\'s a match with \\'stamp\\' for target substring starting at i\\n\\t\\t\\t// replace and increment the stars count if there\\'s a match (partial or complete)\\n\\t\\t\\tif(!vis[i]) replaced = checkAndReplace(target, i, stamp), vis[i] = replaced;\\n\\t\\tif(!replaced) return {}; // if no replacement occurs throughout one iteration over target, return []\\n\\t}            \\n\\t// we began with reverse appraoch, real sequence will be reverse of what we got\\n\\treverse(begin(ans), end(ans));\\n\\treturn ans;\\n}\\nbool checkAndReplace(string& target, int& start, string& stamp){\\n\\t// check for match\\n\\tfor(int i = 0; i < m; i++)\\n\\t\\tif(target[i + start] != \\'*\\' && target[i + start] != stamp[i]) return false;\\n\\t// match occurs - push index into ans and replace start to start+m\\twith *\\n\\tans.push_back(start);\\n\\tfor(int i = start; i - start < m; i++) \\t\\n\\t\\tstars += (target[i] != \\'*\\'), target[i] = \\'*\\';        \\n\\t\\t// dont count \\u2B06\\uFE0F if it was already star character\\n\\treturn true; // denotes replacement happened at index start to start + m\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113780,
                "title": "java-generate-r-and-explained",
                "content": "Any point within the circle of radius R can be defined by its polar coordinates (r, \\u03B8) where r \\u03F5 [0, R] and \\u03B8 \\u03F5 [0, 2\\u03C0]. We just need to generate these 2 values making sure that each point has equal probability.\\n\\nGenerating \\u03B8 is easy. Just generate a random value from [0, 2\\u03C0]. It is intuitive to see that there are equal points on any radius so our generation strategy is fair.\\n\\nIf we generate r in a similar manner i.e. generate a random value from [0, R], it would be WRONG because there aren\\'t equal points on circles of different radii. If we visualize the big circle of radius R as composed of infinite concentric circles of different radii, it\\'ll start to make sense -- even though bigger concentric circles have more points on their circumference, we can\\'t just give them same weightage as smaller concentric circles.\\n\\nTo fix this, our generation strategy should give weightage to a radius proportional to how much it contributes to the main circle. This is where area comes into play. Correct strategy is to generate a random value for \\u03C0r<sup>2</sup> from [0, \\u03C0R<sup>2</sup>] or in other words, generate a random value from [0, R<sup>2</sup>] and take its square root to figure out r.\\n\\n```\\nclass Solution {\\n    private static final Random random = new Random();\\n    private double radius, x_center, y_center;\\n\\n    public Solution(double radius, double x_center, double y_center) {\\n        this.radius = radius;\\n        this.x_center = x_center;\\n        this.y_center = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double r = Math.sqrt(random.nextDouble()) * radius, theta = random.nextDouble() * 2 * Math.PI;\\n        return new double[] { x_center + r * Math.cos(theta), y_center + r * Math.sin(theta) };\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    private static final Random random = new Random();\\n    private double radius, x_center, y_center;\\n\\n    public Solution(double radius, double x_center, double y_center) {\\n        this.radius = radius;\\n        this.x_center = x_center;\\n        this.y_center = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double r = Math.sqrt(random.nextDouble()) * radius, theta = random.nextDouble() * 2 * Math.PI;\\n        return new double[] { x_center + r * Math.cos(theta), y_center + r * Math.sin(theta) };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132679,
                "title": "flip-binary-tree-to-match-preorder-js-python-java-c-recursive-dfs-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIn order to find out which nodes have to be flipped, we\\'ll have navigate the binary tree from the root in a **pre-order traversal**, which is a form of **depth first search** (**DFS**), and compare the node values with the values in the voyage array (**V**).\\n\\nAs with most binary tree DFS solutions, the common solution will use a **recursive** approach. We can use top-level scoped answer array (**ans**) to store the flipped nodes as well as an index counter (**vix**) for the current index of **V** as we traverse through the binary tree.\\n\\nFor our recursive function (**dfs**), we\\'ll need to first take care of the exit conditions when the recursive function reaches a null node or when we\\'ve already found a failure. Then, if the node value is not the one expected, we should set our answer to **[-1]**.\\n\\nSince we\\'ll need to have parent-level access when we decide on a necessary flip, we should take care of that now before calling the next round of recursion. We can simply check the left node value against the next index of **V**, and if they\\'re not a match, we should account for the flip by updating **ans**.\\n\\nRather than actually flipping around nodes in the binary tree, however, we can simply simulate the flip by recursing the two branches in reverse order. Otherwise, we can proceed with normal pre-order traversal.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython doesn\\'t deal as easily with top-level scoped variables, so we can just use the first element of our **ans** array as the **V** index (**vix**), and then pass a reference to **ans** in our recursive function.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 39.9MB** (beats 100% / 97%).\\n```javascript\\nconst flipMatchVoyage = function (root, V) {\\n    let ans = [], vix = 0\\n    const dfs = node => {\\n        if (!node || ans[0] === -1) return\\n        if (node.val !== V[vix++]) ans = [-1]\\n        else if (node.left && node.left.val !== V[vix]) {\\n            ans.push(node.val)\\n            dfs(node.right)\\n            dfs(node.left)\\n        } else {\\n            dfs(node.left)\\n            dfs(node.right)\\n        }\\n    }\\n    dfs(root)\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.2MB** (beats 100% / 89%).\\n```python\\nclass Solution:\\n    def flipMatchVoyage(self, root: TreeNode, V: List[int]) -> List[int]:\\n        ans = [0]\\n        def dfs(node, V, ans):\\n            if not node or ans[0] == -1: return\\n            if node.val != V[ans[0]]: ans[0] = -1\\n            else:\\n                ans[0] += 1\\n                if node.left and node.left.val != V[ans[0]]:\\n                    ans.append(node.val)\\n                    dfs(node.right, V, ans)\\n                    dfs(node.left, V, ans)\\n                else:\\n                    dfs(node.left, V, ans)\\n                    dfs(node.right, V, ans)\\n        dfs(root, V, ans)\\n        return ans[:1] if ans[0] == -1 else ans[1:]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.8MB** (beats 100% / 73%).\\n```java\\nclass Solution {\\n    int vix = 0;\\n    List<Integer> ans = new ArrayList<>();\\n    private void dfs(TreeNode node, int[] V) {\\n        if (node == null || (ans.size() != 0 && ans.get(0) == -1)) return;\\n        if (node.val != V[vix++])\\n            ans = new ArrayList<Integer>(Arrays.asList(-1));\\n        else if (node.left != null && node.left.val != V[vix]) {\\n            ans.add(node.val);\\n            dfs(node.right, V);\\n            dfs(node.left, V);\\n        } else {\\n            dfs(node.left, V);\\n            dfs(node.right, V);\\n        }\\n    }\\n    public List<Integer> flipMatchVoyage(TreeNode root, int[] V) {\\n        dfs(root, V);\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 13.9MB** (beats 100% / 37%).\\n```c++\\nclass Solution {\\n    int vix = 0;\\n    vector<int> ans;\\n    void dfs(TreeNode* node, vector<int>& V) {\\n        if (!node || (ans.size() && ans[0] == -1)) return;\\n        if (node->val != V[vix++]) ans = {-1};\\n        else if (node->left && node->left->val != V[vix]) {\\n            ans.push_back(node->val);\\n            dfs(node->right, V);\\n            dfs(node->left, V);\\n        } else {\\n            dfs(node->left, V);\\n            dfs(node->right, V);\\n        }\\n    }\\npublic:\\n    vector<int> flipMatchVoyage(TreeNode* root, vector<int>& V) {\\n        dfs(root, V);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst flipMatchVoyage = function (root, V) {\\n    let ans = [], vix = 0\\n    const dfs = node => {\\n        if (!node || ans[0] === -1) return\\n        if (node.val !== V[vix++]) ans = [-1]\\n        else if (node.left && node.left.val !== V[vix]) {\\n            ans.push(node.val)\\n            dfs(node.right)\\n            dfs(node.left)\\n        } else {\\n            dfs(node.left)\\n            dfs(node.right)\\n        }\\n    }\\n    dfs(root)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def flipMatchVoyage(self, root: TreeNode, V: List[int]) -> List[int]:\\n        ans = [0]\\n        def dfs(node, V, ans):\\n            if not node or ans[0] == -1: return\\n            if node.val != V[ans[0]]: ans[0] = -1\\n            else:\\n                ans[0] += 1\\n                if node.left and node.left.val != V[ans[0]]:\\n                    ans.append(node.val)\\n                    dfs(node.right, V, ans)\\n                    dfs(node.left, V, ans)\\n                else:\\n                    dfs(node.left, V, ans)\\n                    dfs(node.right, V, ans)\\n        dfs(root, V, ans)\\n        return ans[:1] if ans[0] == -1 else ans[1:]\\n```\n```java\\nclass Solution {\\n    int vix = 0;\\n    List<Integer> ans = new ArrayList<>();\\n    private void dfs(TreeNode node, int[] V) {\\n        if (node == null || (ans.size() != 0 && ans.get(0) == -1)) return;\\n        if (node.val != V[vix++])\\n            ans = new ArrayList<Integer>(Arrays.asList(-1));\\n        else if (node.left != null && node.left.val != V[vix]) {\\n            ans.add(node.val);\\n            dfs(node.right, V);\\n            dfs(node.left, V);\\n        } else {\\n            dfs(node.left, V);\\n            dfs(node.right, V);\\n        }\\n    }\\n    public List<Integer> flipMatchVoyage(TreeNode root, int[] V) {\\n        dfs(root, V);\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\n    int vix = 0;\\n    vector<int> ans;\\n    void dfs(TreeNode* node, vector<int>& V) {\\n        if (!node || (ans.size() && ans[0] == -1)) return;\\n        if (node->val != V[vix++]) ans = {-1};\\n        else if (node->left && node->left->val != V[vix]) {\\n            ans.push_back(node->val);\\n            dfs(node->right, V);\\n            dfs(node->left, V);\\n        } else {\\n            dfs(node->left, V);\\n            dfs(node->right, V);\\n        }\\n    }\\npublic:\\n    vector<int> flipMatchVoyage(TreeNode* root, vector<int>& V) {\\n        dfs(root, V);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129429,
                "title": "palindromic-substrings-js-python-java-c-optimized-mathematical-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThis problem, like many, is all about optimization. The naive solution would be to check if each and every substring is a palindrome, but that would easily achieve a **TLE** result.\\n\\nInstead, the first realization that we can make is that each larger palindrome is built upon many layers of smaller palindromes, going back to its center. So we could optimize our solution by iterating through **S** and considering the index **i** to be the center of a series of potential palindromes.\\n\\nThen, for each **i** we could use two more pointers (**j & k**) which would spread out in both directions from **i**. As long as **S[j] == S[k]**, we\\'d know we had found a new palindrome and could continue spreading outward.\\n\\nWe would have to duplicate this process for even-length palindromes, as their center would be two characters intead of one.\\n\\nBut we can optimize more than that.\\n\\nIf we instead think of the center of the palindrome not as just one or two characters, but as *any* length of repeated characters, then we can break each iteration down into two steps.\\n\\nFirst, we identify how long the \"center\" is by moving our right-size pointer (**k**) forwards while checking for duplicate characters. Now, instead of our center just being a single palindrome, it will be the **Nth triangular number** (defined as **N * (N + 1) / 2**) to account for all the smaller palindromes of which it\\'s made.\\n\\nAfter that, we can spread out with **j** and **k** just as before. Since we\\'ve dealt with the entire center\\'s worth of palindromes, we can move **i** forward to start up again after the end of the center, regardless of its length.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThe code for all four languages is very similar.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 39.2MB** (beats 100% / 91%).\\n```javascript\\nvar countSubstrings = function(S) {\\n    let len = S.length, ans = 0\\n    for (let i = 0; i < len; i++) {\\n        let j = i - 1, k = i\\n        while (k < len - 1 && S[k] === S[k+1]) k++\\n        ans += (k - j) * (k - j + 1) / 2, i = k++\\n        while (~j && k < len && S[k] === S[j]) j--, k++, ans++\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **16ms / 14.2MB** (beats 100% / 88%).\\n```python\\nclass Solution:\\n    def countSubstrings(self, S: str) -> int:\\n        ans, n, i = 0, len(S), 0\\n        while (i < n):\\n            j, k = i - 1, i\\n            while k < n - 1 and S[k] == S[k+1]: k += 1                \\n            ans += (k - j) * (k - j + 1) // 2\\n            i, k = k + 1, k + 1\\n            while ~j and k < n and S[k] == S[j]:\\n                j, k, ans = j - 1, k + 1, ans + 1\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 36.6MB** (beats 100% / 99%).\\n```java\\nclass Solution {\\n    public int countSubstrings(String S) {\\n        int len = S.length(), ans = 0;\\n        for (int i = 0; i < len; i++) {\\n            int j = i - 1, k = i;\\n            while (k < len - 1 && S.charAt(k) == S.charAt(k+1)) k++;\\n            ans += (k - j) * (k - j + 1) / 2;\\n            i = k++;\\n            while (j >= 0 && k < len && S.charAt(k++) == S.charAt(j--)) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 6.0MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int countSubstrings(string S) {\\n        int len = S.length(), ans = 0;\\n        for (int i = 0; i < len; i++) {\\n            int j = i - 1, k = i;\\n            while (k < len - 1 && S[k] == S[k+1]) k++;\\n            ans += (k - j) * (k - j + 1) / 2, i = k++;\\n            while (~j && k < len && S[k++] == S[j--]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar countSubstrings = function(S) {\\n    let len = S.length, ans = 0\\n    for (let i = 0; i < len; i++) {\\n        let j = i - 1, k = i\\n        while (k < len - 1 && S[k] === S[k+1]) k++\\n        ans += (k - j) * (k - j + 1) / 2, i = k++\\n        while (~j && k < len && S[k] === S[j]) j--, k++, ans++\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def countSubstrings(self, S: str) -> int:\\n        ans, n, i = 0, len(S), 0\\n        while (i < n):\\n            j, k = i - 1, i\\n            while k < n - 1 and S[k] == S[k+1]: k += 1                \\n            ans += (k - j) * (k - j + 1) // 2\\n            i, k = k + 1, k + 1\\n            while ~j and k < n and S[k] == S[j]:\\n                j, k, ans = j - 1, k + 1, ans + 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int countSubstrings(String S) {\\n        int len = S.length(), ans = 0;\\n        for (int i = 0; i < len; i++) {\\n            int j = i - 1, k = i;\\n            while (k < len - 1 && S.charAt(k) == S.charAt(k+1)) k++;\\n            ans += (k - j) * (k - j + 1) / 2;\\n            i = k++;\\n            while (j >= 0 && k < len && S.charAt(k++) == S.charAt(j--)) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int countSubstrings(string S) {\\n        int len = S.length(), ans = 0;\\n        for (int i = 0; i < len; i++) {\\n            int j = i - 1, k = i;\\n            while (k < len - 1 && S[k] == S[k+1]) k++;\\n            ans += (k - j) * (k - j + 1) / 2, i = k++;\\n            while (~j && k < len && S[k++] == S[j--]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120107,
                "title": "reordered-power-of-2-js-python-java-c-easy-short-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe easiest way to check if two things are shuffled versions of each other, which is what this problem is asking us to do, is to sort them both and the compare the result.\\n\\nIn that sense, the easiest solution here is to do exactly that: we can convert **N** to an array of its digits, sort it, then compare that result to the result of the same process on each power of **2**.\\n\\nSince the constraint upon **N** is **10e9**, we only need to check powers in the range **[0,29]**.\\n\\nTo make things easier to compare, we can always **join()** the resulting digit arrays into strings before comparison.\\n\\nThere are ways to very slightly improve the run time and memory here, but with an operation this small, it\\'s honestly not very necessary.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython can directly compare the lists and Java can directly compare the char arrays without needing to join them into strings. C++ can sort the strings in-place without needing to convert to an array.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 38.8MB** (beats 100% / 44).\\n```javascript\\nvar reorderedPowerOf2 = function(N) {\\n    let res = N.toString().split(\"\").sort().join(\"\")\\n    for (let i = 0; i < 30; i++)\\n        if ((1 << i).toString().split(\"\").sort().join(\"\") === res) return true\\n    return false\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.1MB** (beats 98% / 76%).\\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        res = sorted([int(x) for x in str(N)])\\n        for i in range(30):\\n            if sorted([int(x) for x in str(1 << i)]) == res: return True\\n        return False\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 35.8MB** (beats 97% / 88%).\\n```java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] res1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(res1);\\n        for (int i = 0; i < 30; i++) {\\n            char[] res2 = String.valueOf(1 << i).toCharArray();\\n            Arrays.sort(res2);\\n            if (Arrays.equals(res1, res2)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.8MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string res1 = to_string(N);\\n        sort(res1.begin(), res1.end());\\n        for (int i = 0; i < 30; i++) {\\n            string res2 = to_string(1 << i);\\n            sort(res2.begin(), res2.end());\\n            if (res1 == res2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar reorderedPowerOf2 = function(N) {\\n    let res = N.toString().split(\"\").sort().join(\"\")\\n    for (let i = 0; i < 30; i++)\\n        if ((1 << i).toString().split(\"\").sort().join(\"\") === res) return true\\n    return false\\n};\\n```\n```python\\nclass Solution:\\n    def reorderedPowerOf2(self, N: int) -> bool:\\n        res = sorted([int(x) for x in str(N)])\\n        for i in range(30):\\n            if sorted([int(x) for x in str(1 << i)]) == res: return True\\n        return False\\n```\n```java\\nclass Solution {\\n    public boolean reorderedPowerOf2(int N) {\\n        char[] res1 = String.valueOf(N).toCharArray();\\n        Arrays.sort(res1);\\n        for (int i = 0; i < 30; i++) {\\n            char[] res2 = String.valueOf(1 << i).toCharArray();\\n            Arrays.sort(res2);\\n            if (Arrays.equals(res1, res2)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n        string res1 = to_string(N);\\n        sort(res1.begin(), res1.end());\\n        for (int i = 0; i < 30; i++) {\\n            string res2 = to_string(1 << i);\\n            sort(res2.begin(), res2.end());\\n            if (res1 == res2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132885,
                "title": "flip-binary-tree-to-match-preorder-short-easy-w-explanation",
                "content": "***Solution (Preoder Traversal with Checks)***\\n\\nThe first thing that must be realised is that there is **nothing as minimum number of flips** (just don\\'t flip a node back and forth multiple time\\uD83D\\uDE05). You can **either flip some nodes** so that re-arranged tree\\'s preorder traversal matches voyage **or the tree couldn\\'t be made  to match the voyage**.\\n\\nWith that out of the way, a recursive solution  can be formed easily. We just traverse the tree and check at each node -\\n1. If the **root\\'s value** is matching voyage value **`v[i]`**.\\n2. If the root\\'s left child is matching voyage\\'s next value **`v[i + 1]`**. This needs to be performed since we would require the parent node if a flip needs to be performed.\\n\\nIf at any point **root\\'s value itself is not matching**, then we are unable to perform flip to match the voyage. **Return [-1]**.\\n\\nIf the **left child value is not matching, we can either flip or not**. If right child exists and matches, flip it else we are unable to match the tree with voyage - return [-1].\\n\\n\\n```\\nvector<int> flip;\\nint i;\\nvector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {\\n\\ti = 0;\\n\\t// if voyage is matching after some flips, return the flipped nodes, else return [-1]\\n\\treturn isMatchingVoyage(root, voyage) ? flip : vector<int>{-1};\\n}\\nbool isMatchingVoyage(TreeNode* root, vector<int>& v){\\n\\t/*\\n** Base conditions - \\n\\t1. We reached null node meaning we have traversed till end without mismatch so return true.\\n\\t2. The root itself is not matching the corresponding voyage (v[i]). This denotes we can\\'t flip any node to match the voyage and hence return false\\n** Main process - \\n\\t1. If the root -> left value is not equal to corresponding voyage value (v[i]), we have the choice to flip. We will only flip if root -> right matches v[i].\\n\\t2. If above flip isn\\'t performed, we can\\'t match the voyage so return false.\\n** Recurse -\\n\\t1. If we haven\\'t yet returned false, the voyage till now has been matched. Just recurse for the remaining tree.\\n\\t2. Since the problem asks us that preOrder should match voyage, so recurse left and then right.\\n\\t*/\\n\\tif(!root) return true;\\n\\tif(root -> val != v[i++]) return false;\\n\\t// if left node exists and doesn\\'t match voyage\\n\\tif(root -> left && root -> left -> val != v[i]) \\n\\t\\t// if right node exists and matches voyage v[i], flip the node, push into vector and continue\\n\\t\\tif(root -> right && root -> right -> val == v[i]) flip.push_back(root -> val), swap(root -> left, root -> right);            \\n\\t\\telse return false;        \\n\\t// recurse till whole tree is traversed - first left and then right.\\t\\n\\treturn isMatchingVoyage(root -> left, v) && isMatchingVoyage(root -> right, v);\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**, where `N` is the number of nodes in the tree.\\n***Space Complexity :*** **`O(N)`**\\n\\n-----\\n-----\\n\\nThe above swap and modification to the tree doesn\\'t really needs to be done. We can just modify the recursive call order. Rest solution is the same.\\n\\n```\\n    vector<int> flip;\\n    int i;\\n    vector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {\\n        i = 0;\\n        return isMatchingVoyage(root, voyage) ? flip : vector<int>{-1};\\n    }\\n    bool isMatchingVoyage(TreeNode* root, vector<int>& v){\\n        if(!root) return true;\\n        if(root -> val != v[i++]) return false;\\n        if(root -> left && root -> left -> val != v[i]){\\n            flip.push_back(root -> val);\\n            return isMatchingVoyage(root -> right, v) && isMatchingVoyage(root -> left, v);\\n        }\\n        return isMatchingVoyage(root -> left, v) && isMatchingVoyage(root -> right, v);\\n    }\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> flip;\\nint i;\\nvector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {\\n\\ti = 0;\\n\\t// if voyage is matching after some flips, return the flipped nodes, else return [-1]\\n\\treturn isMatchingVoyage(root, voyage) ? flip : vector<int>{-1};\\n}\\nbool isMatchingVoyage(TreeNode* root, vector<int>& v){\\n\\t/*\\n** Base conditions - \\n\\t1. We reached null node meaning we have traversed till end without mismatch so return true.\\n\\t2. The root itself is not matching the corresponding voyage (v[i]). This denotes we can\\'t flip any node to match the voyage and hence return false\\n** Main process - \\n\\t1. If the root -> left value is not equal to corresponding voyage value (v[i]), we have the choice to flip. We will only flip if root -> right matches v[i].\\n\\t2. If above flip isn\\'t performed, we can\\'t match the voyage so return false.\\n** Recurse -\\n\\t1. If we haven\\'t yet returned false, the voyage till now has been matched. Just recurse for the remaining tree.\\n\\t2. Since the problem asks us that preOrder should match voyage, so recurse left and then right.\\n\\t*/\\n\\tif(!root) return true;\\n\\tif(root -> val != v[i++]) return false;\\n\\t// if left node exists and doesn\\'t match voyage\\n\\tif(root -> left && root -> left -> val != v[i]) \\n\\t\\t// if right node exists and matches voyage v[i], flip the node, push into vector and continue\\n\\t\\tif(root -> right && root -> right -> val == v[i]) flip.push_back(root -> val), swap(root -> left, root -> right);            \\n\\t\\telse return false;        \\n\\t// recurse till whole tree is traversed - first left and then right.\\t\\n\\treturn isMatchingVoyage(root -> left, v) && isMatchingVoyage(root -> right, v);\\n}\\n```\n```\\n    vector<int> flip;\\n    int i;\\n    vector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {\\n        i = 0;\\n        return isMatchingVoyage(root, voyage) ? flip : vector<int>{-1};\\n    }\\n    bool isMatchingVoyage(TreeNode* root, vector<int>& v){\\n        if(!root) return true;\\n        if(root -> val != v[i++]) return false;\\n        if(root -> left && root -> left -> val != v[i]){\\n            flip.push_back(root -> val);\\n            return isMatchingVoyage(root -> right, v) && isMatchingVoyage(root -> left, v);\\n        }\\n        return isMatchingVoyage(root -> left, v) && isMatchingVoyage(root -> right, v);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113635,
                "title": "python-rejection-sampling-w-proof",
                "content": "Sample from the square where the desired circle is inscribed. Repeat until point falls into circle. This produces uniform samples of points from the circle.\\n\\n**Proof**\\nIt is straightforward to show that accepted points have uniform distribution. Let `xs` be the returned sample. Let `x` be an arbitrary point in the circle. The status variable `S=1` indicates that the sampled point is accepted by the algorithm. Applying Bayes\\' rule\\n![image](https://assets.leetcode.com/users/images/0056625d-69e0-44f6-bed4-f87665e01d80_1615968465.378517.png)\\nshows that any point inside the circle is equiprobable.\\n\\n**Complexity**\\nAs this is a randomized algorithm we can talk about its expected runtime. The probability of getting accepted in a single run is the area of circle to the square, this is `pi/4`. We keep sampling as long as we are rejected. Then it is a geometric distribuion. The mean is `4/pi`. So generating one random variable takes `4/pi` on the average. This is worse than the alternative inverse CDF method, a popular alternative in the solutions, as that takes `1` iteration. But asymptotically they are both `O(1)`. \\nWhich one would you use in practice? **None**, just use a built-in library :P\\n\\n```python\\nclass Solution:\\n    def __init__(self, radius, x_center, y_center):\\n        self.r  = radius\\n        self.xc = x_center\\n        self.yc = y_center\\n        \\n\\n    def randPoint(self):\\n        xs = 2.*self.r*random.random() - self.r\\n        ys = 2.*self.r*random.random() - self.r\\n        while xs**2 + ys**2 > self.r**2:\\n            xs = 2.*self.r*random.random() - self.r\\n            ys = 2.*self.r*random.random() - self.r\\n        return [self.xc + xs, self.yc + ys]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def __init__(self, radius, x_center, y_center):\\n        self.r  = radius\\n        self.xc = x_center\\n        self.yc = y_center\\n        \\n\\n    def randPoint(self):\\n        xs = 2.*self.r*random.random() - self.r\\n        ys = 2.*self.r*random.random() - self.r\\n        while xs**2 + ys**2 > self.r**2:\\n            xs = 2.*self.r*random.random() - self.r\\n            ys = 2.*self.r*random.random() - self.r\\n        return [self.xc + xs, self.yc + ys]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439770,
                "title": "python-random-theta-radius-explained-with-picture-clean-concise",
                "content": "**Idea**\\n- If we generate random by:\\n\\t- `x_out = uniform(x - radius, x + radius)`\\n\\t- `y_out = uniform(y + radius, y + raidus)`\\n- It will be WRONG, can check this picture\\n\\n![image](https://assets.leetcode.com/users/images/9be3d528-c951-45b6-9c23-9fe8d88f0bb9_1630554107.3880062.png)\\n(Reference: http://www.anderswallin.net/2009/05/uniform-random-points-in-a-circle-using-polar-coordinates/)\\n\\n\\n- So we need to randomize the angle uniformly, `theta = union(0, 2*pi)`.\\n- We also need to randomize the radius uniformly:\\n\\t- By randomize area first, `Area = uniform(0, pi * r * r)`\\n\\t- Get the random radius by `R = sqrt(Area / pi)`.\\n- Then we can compute the position of random `x_out` and `y_out` by:\\n\\t- `x_out = x + cos(theta) * R`\\n\\t- `y_out = y + sin(theta) * R`. \\n\\n![image](https://assets.leetcode.com/users/images/42ea42a0-755c-43f8-9b47-928f06b17ae6_1630553585.235774.png)\\n\\n\\n\\n\\n\\n```python\\nclass Solution(object):\\n\\n    def __init__(self, radius, x_center, y_center):\\n        self.r = radius\\n        self.x = x_center\\n        self.y = y_center\\n\\n    def randPoint(self):\\n        Area = uniform(0, pi * self.r * self.r)\\n        R = sqrt(Area/pi)\\n        theta = uniform(0, 2*pi)\\n        return [self.x + cos(theta) * R, self.y + sin(theta) * R]\\n```\\n**Complexity**\\n- Time: `O(1)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n\\n    def __init__(self, radius, x_center, y_center):\\n        self.r = radius\\n        self.x = x_center\\n        self.y = y_center\\n\\n    def randPoint(self):\\n        Area = uniform(0, pi * self.r * self.r)\\n        R = sqrt(Area/pi)\\n        theta = uniform(0, 2*pi)\\n        return [self.x + cos(theta) * R, self.y + sin(theta) * R]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128122,
                "title": "word-subsets-short-easy-w-explanation-beats-100",
                "content": "<h2><b>Solution</b></h2>\\n\\nWe can count frequency or character in each word from **`B`**. We will maintain a vector **`Maxfreq`**, which will store the **minimum frequency of each character required** for a word from **`A`** to be **universal word**.\\n\\nWe can finally iterate over each word from **`A`**, and check if each characters frequency is greater than or equal to the minimum required frequency (checked from `Maxfreq`).\\n\\n```\\n// count frequency of each character in a word\\nvector<int> countFreq(string& word){\\n\\tvector<int> freq(26);\\n\\tfor(auto& c : word) freq[c - \\'a\\']++;\\n\\treturn freq;\\n}\\nvector<string> wordSubsets(vector<string>& A, vector<string>& B) {\\n\\tvector<int> Maxfreq(26); // maintains minimum freq of each char required for a word to be universal word\\n\\tvector<string> ans;\\n\\tfor(auto& word : B){\\n\\t\\tvector<int> freq = countFreq(word);            \\n\\t\\tfor(int i = 0; i < 26; i++) Maxfreq[i] = max(Maxfreq[i], freq[i]);\\n\\t}        \\n\\tfor(auto& word : A){\\n\\t\\tvector<int> freq = countFreq(word);            \\n\\t\\tint i = 0;\\n\\t\\tfor(;i < 26; i++) if(freq[i] < Maxfreq[i]) break;\\n\\t\\tif(i == 26) ans.push_back(word);\\n\\t}\\n\\treturn ans;\\n}    \\n```\\n\\n**Time Complexity :** **`O(N1 + N2)`**, where `N1` is the sum of length of all words from `A` and `b` is the sum of length of all words from `N2`\\n**Space Complexity :** : **`O(U)`**, where `U`, is the sum of length of all **universal words**.\\n\\n\\n<table><tr><td>\\n<p align=\"center\"><img src=\"https://assets.leetcode.com/users/images/38fd9ad2-856c-4f1a-973a-2a3c2058c550_1616752153.8356872.png\" ></img></p>\\n</td></tr></table>\\n\\n\\n\\n\\n--------\\n---------",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// count frequency of each character in a word\\nvector<int> countFreq(string& word){\\n\\tvector<int> freq(26);\\n\\tfor(auto& c : word) freq[c - \\'a\\']++;\\n\\treturn freq;\\n}\\nvector<string> wordSubsets(vector<string>& A, vector<string>& B) {\\n\\tvector<int> Maxfreq(26); // maintains minimum freq of each char required for a word to be universal word\\n\\tvector<string> ans;\\n\\tfor(auto& word : B){\\n\\t\\tvector<int> freq = countFreq(word);            \\n\\t\\tfor(int i = 0; i < 26; i++) Maxfreq[i] = max(Maxfreq[i], freq[i]);\\n\\t}        \\n\\tfor(auto& word : A){\\n\\t\\tvector<int> freq = countFreq(word);            \\n\\t\\tint i = 0;\\n\\t\\tfor(;i < 26; i++) if(freq[i] < Maxfreq[i]) break;\\n\\t\\tif(i == 26) ans.push_back(word);\\n\\t}\\n\\treturn ans;\\n}    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1115232,
                "title": "wiggle-subsequence-js-python-java-c-easy-o-n-o-1-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe key realization here is that any number that lies in the middle of a stretch of the same direction is extraneous, because the more extreme numbers are the better choices to keep, as they allow for a larger likelihood that a subsequent number will be a directional change.\\n\\nSo the simple answer here is to count the inflection points in our input array (**N**) where the direction changes. There are several ways to do this, but in this solution, we can keep a directional flag (**up**) to keep track of the current direction and then increment our answer (**ans**) and invert **up** when a change is found.\\n\\nOne tricky thing lies in setting the initial direction. Per the instructions, the first number can represent any direction, so we\\'ll have to wait until the first time we see a different number to set our direction. We can check this with a simple **while** loop before the main loop.\\n\\nOnce we finish, we can **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nAll but Javascript will require an additional check before the main loop to account for an input array with all the same number.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **64ms / 38.2MB** (beats 99% / 97%).\\n```javascript\\nvar wiggleMaxLength = function(N) {\\n    let len = N.length, i = 1\\n    while (N[i] === N[i-1]) i++\\n    let up = N[i-1] > N[i], ans = 1\\n    for (; i < len; i++)\\n        if ((up && N[i] < N[i-1]) || (!up && N[i] > N[i-1]))\\n            up = !up, ans++\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **28ms / 13.9MB** (beats 95% / 100%).\\n```python\\nclass Solution:\\n    def wiggleMaxLength(self, N: List[int]) -> int:\\n        lenN, i = len(N), 1\\n        while i < lenN and N[i] == N[i-1]: i += 1\\n        if i == lenN: return 1\\n        up, ans = N[i-1] > N[i], 1\\n        while i < lenN:\\n            if (up and N[i] < N[i-1]) or (not up and N[i] > N[i-1]):\\n                up = not up\\n                ans += 1\\n            i += 1\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 36.2MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public int wiggleMaxLength(int[] N) {\\n        int len = N.length, i = 1, ans = 1;\\n        while (i < len && N[i] == N[i-1]) i++;\\n        if (i == len) return 1;\\n        boolean up = N[i-1] > N[i];\\n        for (; i < len; i++)\\n            if ((up && N[i] < N[i-1]) || (!up && N[i] > N[i-1])) {\\n                up = !up;\\n                ans++;\\n            }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 6.9MB** (beats 100% / 97%).\\n```c++\\nclass Solution {\\npublic:\\n    int wiggleMaxLength(vector<int>& N) {\\n        int len = N.size(), i = 1, ans = 1;\\n        while (i < len && N[i] == N[i-1]) i++;\\n        if (i == len) return 1;\\n        bool up = N[i-1] > N[i];\\n        for (; i < len; i++)\\n            if ((up && N[i] < N[i-1]) || (!up && N[i] > N[i-1]))\\n                up = !up, ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar wiggleMaxLength = function(N) {\\n    let len = N.length, i = 1\\n    while (N[i] === N[i-1]) i++\\n    let up = N[i-1] > N[i], ans = 1\\n    for (; i < len; i++)\\n        if ((up && N[i] < N[i-1]) || (!up && N[i] > N[i-1]))\\n            up = !up, ans++\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def wiggleMaxLength(self, N: List[int]) -> int:\\n        lenN, i = len(N), 1\\n        while i < lenN and N[i] == N[i-1]: i += 1\\n        if i == lenN: return 1\\n        up, ans = N[i-1] > N[i], 1\\n        while i < lenN:\\n            if (up and N[i] < N[i-1]) or (not up and N[i] > N[i-1]):\\n                up = not up\\n                ans += 1\\n            i += 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int wiggleMaxLength(int[] N) {\\n        int len = N.length, i = 1, ans = 1;\\n        while (i < len && N[i] == N[i-1]) i++;\\n        if (i == len) return 1;\\n        boolean up = N[i-1] > N[i];\\n        for (; i < len; i++)\\n            if ((up && N[i] < N[i-1]) || (!up && N[i] > N[i-1])) {\\n                up = !up;\\n                ans++;\\n            }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int wiggleMaxLength(vector<int>& N) {\\n        int len = N.size(), i = 1, ans = 1;\\n        while (i < len && N[i] == N[i-1]) i++;\\n        if (i == len) return 1;\\n        bool up = N[i-1] > N[i];\\n        for (; i < len; i++)\\n            if ((up && N[i] < N[i-1]) || (!up && N[i] > N[i-1]))\\n                up = !up, ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126814,
                "title": "pacific-atlantic-water-flow-js-python-java-c-easy-dfs-recursion-dp-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nIt should be obvious from the start that we\\'ll need to solve this problem in reverse. We know that the edges of the input matrix (**M**) will flow water out to the ocean on their respective sides, and we can tell whether an adjacent cell will funnel water to the current cell, so we\\'ll have to start from the edges and work our way inward.\\n\\nUnfortunately, since the path the water will take can possibly wind around, we can\\'t do a straight one-time iteration. Instead, we\\'ll have to use a **depth first search** (**DFS**) approach with either a **stack**/**queue** structure or **recursion**.\\n\\nFor each cell that touches an ocean, we\\'ll have to follow the reverse path of the water up the continent as far as it will go. Since we only want cells that are reached by both oceans, we\\'ll need a data structure to store the preliminary data for the cells while we wait for the opposite ocean to potentially find the same cell.\\n\\nThere are a few ways we can do this, but I\\'ll choose a **dynamic programming** (**DP**) array (**dp**). Since there\\'s no real reason to mimic the **2-D matrix** structure of **M**, we can just use a flattened **1-D array** instead, which should save some processing overhead. In order to store both oceans\\' data discretely in **dp**, we can use **+1** for one and **+2** for the other. That means that when a cell goes to **3**, it should be added to our answer array (**ans**).\\n\\nOur DFS recursion function (**dfs**) should also check to make sure that we haven\\'t already marked this cell with the current ocean (**w**) by using a **bitwise AND** (**&**) operator. Then, at the end of **dfs** we should fire off new recursions in all four directions, if possible.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript can use the lighter, typed **Uint8Array** for **dp**.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **100ms / 44.1MB** (beats 100% / 100%).\\n```javascript\\nvar pacificAtlantic = function(M) {\\n    if (!M.length) return M\\n    let y = M.length, x = M[0].length, ans = [],\\n        dp = new Uint8Array(x * y)\\n    const dfs = (i, j, w, h) => {\\n        let ij = i * x + j\\n        if ((dp[ij] & w) || M[i][j] < h) return\\n        dp[ij] += w, h = M[i][j]\\n        if (dp[ij] === 3) ans.push([i,j])\\n        if (i + 1 < y) dfs(i+1, j, w, h)\\n        if (i > 0) dfs(i-1, j, w, h)\\n        if (j + 1 < x) dfs(i, j+1, w, h)\\n        if (j > 0) dfs(i, j-1, w, h)\\n    }   \\n    for (let i = 0; i < y; i++) {\\n        dfs(i, 0, 1, M[i][0])\\n        dfs(i, x-1, 2, M[i][x-1])\\n    }\\n    for (let j = 0; j < x; j++) {\\n        dfs(0, j, 1, M[0][j])\\n        dfs(y-1, j, 2, M[y-1][j])\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **264ms / 15.6MB** (beats 97% / 53%).\\n```python\\nclass Solution:\\n    def pacificAtlantic(self, M: List[List[int]]) -> List[List[int]]:\\n        if not M: return M\\n        x, y = len(M[0]), len(M)\\n        ans, dp = [], [0] * (x * y)\\n        def dfs(i: int, j: int, w: int, h: int):\\n            ij = i * x + j\\n            if dp[ij] & w or M[i][j] < h: return\\n            dp[ij] += w\\n            h = M[i][j]\\n            if dp[ij] == 3: ans.append([i,j])\\n            if i + 1 < y: dfs(i+1, j, w, h)\\n            if i > 0: dfs(i-1, j, w, h)\\n            if j + 1 < x: dfs(i, j+1, w, h)\\n            if j > 0: dfs(i, j-1, w, h)\\n        for i in range(y):\\n            dfs(i, 0, 1, M[i][0])\\n            dfs(i, x-1, 2, M[i][x-1])\\n        for j in range(x):\\n            dfs(0, j, 1, M[0][j])\\n            dfs(y-1, j, 2, M[y-1][j])\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **2ms / 40.4MB** (beats 100% / 43%).\\n```java\\nclass Solution {\\n    static void dfs(int i, int j, int w, int h, int[][] M, byte[] dp, List<List<Integer>> ans) {\\n        int ij = i * M[0].length + j;\\n        if ((dp[ij] & w) > 0 || M[i][j] < h) return;\\n        dp[ij] += w;\\n        h = M[i][j];\\n        if (dp[ij] == 3) ans.add(Arrays.asList(i,j));\\n        if (i + 1 < M.length) dfs(i+1, j, w, h, M, dp, ans);\\n        if (i > 0) dfs(i-1, j, w, h, M, dp, ans);\\n        if (j + 1 < M[0].length) dfs(i, j+1, w, h, M, dp, ans);\\n        if (j > 0) dfs(i, j-1, w, h, M, dp, ans);\\n    }\\n    public List<List<Integer>> pacificAtlantic(int[][] M) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if (M.length == 0) return ans;\\n        int y = M.length, x = M[0].length;\\n        byte[] dp = new byte[x * y];\\n        for (int i = 0; i < x; i++) {\\n            dfs(0, i, 1, M[0][i], M, dp, ans);\\n            dfs(y-1, i, 2, M[y-1][i], M, dp, ans);\\n        }   \\n        for (int i = 0; i < y; i++) {\\n            dfs(i, 0, 1, M[i][0], M, dp, ans);\\n            dfs(i, x-1, 2, M[i][x-1], M, dp, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **24ms / 16.7MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& M) {\\n        vector<vector<int>> ans;\\n        if (M.empty()) return ans;\\n        int y = M.size(), x = M[0].size();\\n        vector<char> dp(y * x);\\n        for (int i = 0; i < y; i++) {\\n            dfs(M, dp, i, 0, 1, 0);\\n            dfs(M, dp, i, x - 1, 2, 0);\\n        }\\n        for (int i = 0; i < x; i++) {\\n            dfs(M, dp, 0, i, 1, 0);\\n            dfs(M, dp, y - 1, i, 2, 0);\\n        }\\n        for (int i = 0; i < y; i++) \\n            for (int j = 0; j < x; j++) \\n                if (dp[i * x + j] == 3) \\n                    ans.push_back({i, j});\\n        return ans;\\n    }\\nprivate:\\n    void dfs(const vector<vector<int>>& M, vector<char>& dp, int i, int j, int w, int h) {\\n        int y = M.size(), x = M[0].size(), ij = i * x + j, newh = M[i][j];;\\n        if ((dp[ij] & w) || M[i][j] < h) return;\\n        dp[ij] += w;\\n        if (i + 1 < y) dfs(M, dp, i + 1, j, w, newh);\\n        if (i > 0) dfs(M, dp, i - 1, j, w, newh);\\n        if (j + 1 < x) dfs(M, dp, i, j + 1, w, newh);\\n        if (j > 0) dfs(M, dp, i, j - 1, w, newh);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar pacificAtlantic = function(M) {\\n    if (!M.length) return M\\n    let y = M.length, x = M[0].length, ans = [],\\n        dp = new Uint8Array(x * y)\\n    const dfs = (i, j, w, h) => {\\n        let ij = i * x + j\\n        if ((dp[ij] & w) || M[i][j] < h) return\\n        dp[ij] += w, h = M[i][j]\\n        if (dp[ij] === 3) ans.push([i,j])\\n        if (i + 1 < y) dfs(i+1, j, w, h)\\n        if (i > 0) dfs(i-1, j, w, h)\\n        if (j + 1 < x) dfs(i, j+1, w, h)\\n        if (j > 0) dfs(i, j-1, w, h)\\n    }   \\n    for (let i = 0; i < y; i++) {\\n        dfs(i, 0, 1, M[i][0])\\n        dfs(i, x-1, 2, M[i][x-1])\\n    }\\n    for (let j = 0; j < x; j++) {\\n        dfs(0, j, 1, M[0][j])\\n        dfs(y-1, j, 2, M[y-1][j])\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def pacificAtlantic(self, M: List[List[int]]) -> List[List[int]]:\\n        if not M: return M\\n        x, y = len(M[0]), len(M)\\n        ans, dp = [], [0] * (x * y)\\n        def dfs(i: int, j: int, w: int, h: int):\\n            ij = i * x + j\\n            if dp[ij] & w or M[i][j] < h: return\\n            dp[ij] += w\\n            h = M[i][j]\\n            if dp[ij] == 3: ans.append([i,j])\\n            if i + 1 < y: dfs(i+1, j, w, h)\\n            if i > 0: dfs(i-1, j, w, h)\\n            if j + 1 < x: dfs(i, j+1, w, h)\\n            if j > 0: dfs(i, j-1, w, h)\\n        for i in range(y):\\n            dfs(i, 0, 1, M[i][0])\\n            dfs(i, x-1, 2, M[i][x-1])\\n        for j in range(x):\\n            dfs(0, j, 1, M[0][j])\\n            dfs(y-1, j, 2, M[y-1][j])\\n        return ans\\n```\n```java\\nclass Solution {\\n    static void dfs(int i, int j, int w, int h, int[][] M, byte[] dp, List<List<Integer>> ans) {\\n        int ij = i * M[0].length + j;\\n        if ((dp[ij] & w) > 0 || M[i][j] < h) return;\\n        dp[ij] += w;\\n        h = M[i][j];\\n        if (dp[ij] == 3) ans.add(Arrays.asList(i,j));\\n        if (i + 1 < M.length) dfs(i+1, j, w, h, M, dp, ans);\\n        if (i > 0) dfs(i-1, j, w, h, M, dp, ans);\\n        if (j + 1 < M[0].length) dfs(i, j+1, w, h, M, dp, ans);\\n        if (j > 0) dfs(i, j-1, w, h, M, dp, ans);\\n    }\\n    public List<List<Integer>> pacificAtlantic(int[][] M) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if (M.length == 0) return ans;\\n        int y = M.length, x = M[0].length;\\n        byte[] dp = new byte[x * y];\\n        for (int i = 0; i < x; i++) {\\n            dfs(0, i, 1, M[0][i], M, dp, ans);\\n            dfs(y-1, i, 2, M[y-1][i], M, dp, ans);\\n        }   \\n        for (int i = 0; i < y; i++) {\\n            dfs(i, 0, 1, M[i][0], M, dp, ans);\\n            dfs(i, x-1, 2, M[i][x-1], M, dp, ans);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& M) {\\n        vector<vector<int>> ans;\\n        if (M.empty()) return ans;\\n        int y = M.size(), x = M[0].size();\\n        vector<char> dp(y * x);\\n        for (int i = 0; i < y; i++) {\\n            dfs(M, dp, i, 0, 1, 0);\\n            dfs(M, dp, i, x - 1, 2, 0);\\n        }\\n        for (int i = 0; i < x; i++) {\\n            dfs(M, dp, 0, i, 1, 0);\\n            dfs(M, dp, y - 1, i, 2, 0);\\n        }\\n        for (int i = 0; i < y; i++) \\n            for (int j = 0; j < x; j++) \\n                if (dp[i * x + j] == 3) \\n                    ans.push_back({i, j});\\n        return ans;\\n    }\\nprivate:\\n    void dfs(const vector<vector<int>>& M, vector<char>& dp, int i, int j, int w, int h) {\\n        int y = M.size(), x = M[0].size(), ij = i * x + j, newh = M[i][j];;\\n        if ((dp[ij] & w) || M[i][j] < h) return;\\n        dp[ij] += w;\\n        if (i + 1 < y) dfs(M, dp, i + 1, j, w, newh);\\n        if (i > 0) dfs(M, dp, i - 1, j, w, newh);\\n        if (j + 1 < x) dfs(M, dp, i, j + 1, w, newh);\\n        if (j > 0) dfs(M, dp, i, j - 1, w, newh);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123835,
                "title": "3sum-with-multiplicity-js-python-java-c-efficient-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to attempt all permutations, but that would run up to **2.7e10** attempts. The first important thing to notice is that the range of numbers is very small at **[0,100]**. With that few number options, any large input array (**A**) will have many duplicates, which means we\\'re looking at a **combinatorics** solution.\\n\\nIn order to use the combinatorics shortcut, however, we\\'ll first have to make a **frequency map** of the numbers in **A**. We could always use a standard map for this, but since the range of numbers is so small and **0-indexed**, it makes more sense to use an **array** instead.\\n\\nAfter we\\'ve iterated through **A** and filled our number map (**nmap**) with the number frequencies, we can get down to the real work. The normal approach here would be to figure out the distinct numbers available and use nested loops to attempt every possible permutation. But rather than doing this, which would require many array calls, we can again take advantage of the fact that the number range is so small.\\n\\nWe can iterate through every possible permutation from **[0,100]**, regardless of wheter the numbers are in **A**. Since we\\'ve made a frequency map, those numbers will be represented as **0**\\'s, which will handily prevent anything from being added to our answer (**ans**) for permutations that we can\\'t make, and by using simple math instead of many array calls, we can actually be more performant.\\n\\nStill, there are ways to streamline this process. The basic approach will be to use a **2-pointer system** to find two of our values and then mathematically figure the third, before applying the proper permutation formula to the values.\\n\\nIt should be apparent that our largest value (**k**) can never go above the target (**T**), nor can it obviously go above the max value of **100**, so we can start it out at **min(T, 100)** and decrement from there. Also, since it will always represents the largest of the three values, it can never go below **T / 3**, because then the two smaller numbers would never be able to bring it up to **T**.\\n\\nMoving down to the next value (**j**), we can see that it can never be larger than **k** by definition, nor can it be larger than the remaining amount of space (**rem**) left to **T**, so we should start it at **min(rem, k)**. Similar to **k**, **j** can also never go below **rem / 2**.\\n\\nOnce we have two of the three values, we can check for their frequencies. If any of them are **0**\\'s, then it will automatically make the result of its permutation check a **0** as well. We can also potentially save some processing by checking for **0**\\'s and **continuing** before applying the combinatorics formulas.\\n\\nIf **i == k**, then we know that **i == j == k** because **j** has to be between **i** and **k**, so we\\'ll have to use the **n choose 3** formula. We should also check if any two other values are the same, then we should use **(n choose 2) * (n choose 1)**. Otherwise, we can just use the simple combinations formula.\\n\\nThen it\\'s important to remember to apply the **modulo** before **returning**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript was actually faster with an approach that featured isolating the actual distinct elements, sorting them, and then running efficiently through the combinations, but the code was much longer and more complex. This method is much easier and nearly as fast. In either case, we should use a typed array here for the arraymap.\\n\\nJava was oddly slower at the iteration shortcuts and actually ran faster without the added processes.\\n\\nJava and C++ should use **long** for their **ans** (prior to returning it, at least), and even for **nmap**, otherwise we\\'ll have to cast those values to **long** each time anyway.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 40.5MB** (beats 100% / 80%).\\n```javascript\\nvar threeSumMulti = function(A, T) {\\n    let nmap = new Uint16Array(101), third = T / 3, ans = 0\\n    for (let i in A) nmap[A[i]]++\\n    for (let k = Math.min(T, 100); k >= third; k--) {\\n        let rem = T - k, half = rem / 2\\n        for (let j = Math.min(rem, k); j >= half; j--) {\\n            let i = rem - j, x = nmap[i], y = nmap[j], z = nmap[k], res\\n            if (i === k) res = x * (x-1) * (x-2) / 6\\n            else if (i === j) res = x * (x-1) / 2 * z\\n            else if (j === k) res = x * y * (y-1) / 2\\n            else res = x * y * z\\n            ans = (ans + res) % 1000000007\\n        }\\n    }\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **60ms / 14.2MB** (beats 100% / 92%).\\n```python\\nclass Solution:\\n    def threeSumMulti(self, A, T):\\n        nmap, third, ans = [0 for _ in range(101)], ceil(T / 3) - 1, 0\\n        for num in A: nmap[num] += 1\\n        for k in range(min(T,100), third, -1):\\n            rem = T - k\\n            half = ceil(rem / 2) - 1\\n            for j in range(min(rem, k), half, -1):\\n                i = rem - j\\n                x, y, z = nmap[i], nmap[j], nmap[k]\\n                if i == k: ans += x * (x-1) * (x-2) // 6\\n                elif i == j: ans += x * (x-1) // 2 * z\\n                elif j == k: ans += x * y * (y-1) // 2\\n                else: ans += x * y * z\\n        return ans % 1000000007\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 38.3MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public int threeSumMulti(int[] A, int T) {\\n        long[] nmap = new long[101];\\n        long ans = 0;\\n        for (int num : A) nmap[num]++;\\n        for (int k = 100; k >= 0; k--)\\n            for (int j = k; j >= 0; j--) {\\n                int i = T - k - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **4ms / 10.2MB** (beats 99% / 100%).\\n```c++\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int T) {\\n        long nmap[101] = {0}, ans = 0;\\n        double third = T / 3;\\n        for (int num : A) nmap[num]++;\\n        for (int k = min(T, 100); k >= third; k--) {\\n            int rem = T - k;\\n            double half = rem / 2;\\n            for (int j = min(rem, k); j >= half; j--) {\\n                int i = rem - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar threeSumMulti = function(A, T) {\\n    let nmap = new Uint16Array(101), third = T / 3, ans = 0\\n    for (let i in A) nmap[A[i]]++\\n    for (let k = Math.min(T, 100); k >= third; k--) {\\n        let rem = T - k, half = rem / 2\\n        for (let j = Math.min(rem, k); j >= half; j--) {\\n            let i = rem - j, x = nmap[i], y = nmap[j], z = nmap[k], res\\n            if (i === k) res = x * (x-1) * (x-2) / 6\\n            else if (i === j) res = x * (x-1) / 2 * z\\n            else if (j === k) res = x * y * (y-1) / 2\\n            else res = x * y * z\\n            ans = (ans + res) % 1000000007\\n        }\\n    }\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def threeSumMulti(self, A, T):\\n        nmap, third, ans = [0 for _ in range(101)], ceil(T / 3) - 1, 0\\n        for num in A: nmap[num] += 1\\n        for k in range(min(T,100), third, -1):\\n            rem = T - k\\n            half = ceil(rem / 2) - 1\\n            for j in range(min(rem, k), half, -1):\\n                i = rem - j\\n                x, y, z = nmap[i], nmap[j], nmap[k]\\n                if i == k: ans += x * (x-1) * (x-2) // 6\\n                elif i == j: ans += x * (x-1) // 2 * z\\n                elif j == k: ans += x * y * (y-1) // 2\\n                else: ans += x * y * z\\n        return ans % 1000000007\\n```\n```java\\nclass Solution {\\n    public int threeSumMulti(int[] A, int T) {\\n        long[] nmap = new long[101];\\n        long ans = 0;\\n        for (int num : A) nmap[num]++;\\n        for (int k = 100; k >= 0; k--)\\n            for (int j = k; j >= 0; j--) {\\n                int i = T - k - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        return (int)(ans % 1000000007);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int threeSumMulti(vector<int>& A, int T) {\\n        long nmap[101] = {0}, ans = 0;\\n        double third = T / 3;\\n        for (int num : A) nmap[num]++;\\n        for (int k = min(T, 100); k >= third; k--) {\\n            int rem = T - k;\\n            double half = rem / 2;\\n            for (int j = min(rem, k); j >= half; j--) {\\n                int i = rem - j;\\n                if (i > j || i < 0) continue;\\n                long x = nmap[i], y = nmap[j], z = nmap[k], res = x * y * z;\\n                if (res == 0) continue;\\n                if (i == k) res = x * (x-1) * (x-2) / 6;\\n                else if (i == j) res = x * (x-1) / 2 * z;\\n                else if (j == k) res = x * y * (y-1) / 2;\\n                ans += res;\\n            }\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154405,
                "title": "c-solution-polar-coordinates",
                "content": "```\\nclass Solution {\\npublic:\\n    const double PI = 3.14159265358979732384626433832795;\\n    double m_radius, m_x_center, m_y_center;\\n\\t\\t\\n    double uniform() {\\n        return (double)rand() / RAND_MAX;\\n    }\\n    \\n    Solution(double radius, double x_center, double y_center) {\\n        m_radius = radius; m_x_center = x_center; m_y_center = y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        double theta = 2 * 3.14159265358979323846264 * uniform();\\n        double r = sqrt(uniform());\\n        return vector<double>{\\n            m_x_center + r * m_radius * cos(theta),\\n            m_y_center + r * m_radius * sin(theta)\\n        };\\n    }\\n};\\n ```\\n \\n`r` is the distance of the random point to the origin (in the unit circle). since `Probability(r < A) = A^2` (The inner circle with radius `A`), so we can simly take `sqrt(A)` to get `r`.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const double PI = 3.14159265358979732384626433832795;\\n    double m_radius, m_x_center, m_y_center;\\n\\t\\t\\n    double uniform() {\\n        return (double)rand() / RAND_MAX;\\n    }\\n    \\n    Solution(double radius, double x_center, double y_center) {\\n        m_radius = radius; m_x_center = x_center; m_y_center = y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        double theta = 2 * 3.14159265358979323846264 * uniform();\\n        double r = sqrt(uniform());\\n        return vector<double>{\\n            m_x_center + r * m_radius * cos(theta),\\n            m_y_center + r * m_radius * sin(theta)\\n        };\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1114009,
                "title": "python-3-detailed-explanation-with-graphs",
                "content": "I have tried to plot the results of all possible solutions.\\n\\nThroughout the plot, I have used the following code to plot it (adjust it for Solution 2 and 3 as well), in case you want to play with it as well:\\n```python\\n%matplotlib inline\\nimport matplotlib.pyplot as plt\\nimport random\\nfrom math import *\\nimport numpy\\n\\ns1 = Solution1(10, 0, 0)\\nlog = numpy.transpose([s1.randPoint() for _ in range(1000)])\\nplt.scatter(*log)\\nplt.title(\\'Solution 1\\')\\nplt.show()\\n```\\n\\n#### Solution 1 - fix x and calculate y\\nThis is the naive solution one can simply come up. However, from the result you can see the dots are congested at the endpoints of x.\\n```python\\nclass Solution1:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.r = radius\\n        self.xc = x_center\\n        self.yc = y_center\\n\\n    def randPoint(self):\\n        \"\"\"Not working - not uniform\"\"\"\\n        dx = random.uniform(-self.r, self.r) \\n        bound = sqrt(self.r**2 - dx**2)\\n        dy = random.uniform(-bound, bound)\\n        return [self.xc + dx, self.yc + dy]\\n```\\n![image](https://assets.leetcode.com/users/images/0ec92c63-626b-448a-9179-2a42192fe03c_1615991418.3588595.png)\\n\\n\\n#### Solution 2. Polar without sqrt()\\n```python\\nclass Solution2:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.r = radius\\n        self.xc = x_center\\n        self.yc = y_center\\n\\n    def randPoint(self):\\n        \"\"\"Not working - not uniform\"\"\"\\n        theta = random.uniform(0, 2*pi)\\n        r = self.r * random.uniform(0, 1)\\n        return [self.xc + r*cos(theta), self.yc + r*sin(theta)]\\n```\\n![image](https://assets.leetcode.com/users/images/375c28c3-3ef6-4c3c-82a4-0a352ad37880_1615991326.6347566.png)\\n#### Solution 3. Polar with sqrt()\\n```python\\nclass Solution3:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.r = radius\\n        self.xc = x_center\\n        self.yc = y_center\\n\\n    def randPoint(self):\\n        \"\"\"Working - uniform\"\"\"\\n        theta = random.uniform(0, 2*pi)\\n        r = self.r * sqrt(random.uniform(0, 1))\\n        return [self.xc + r*cos(theta), self.yc + r*sin(theta)]\\n```\\n![image](https://assets.leetcode.com/users/images/819fc82f-8925-4fea-bf96-c82dafdb4bbc_1615991440.1545947.png)\\n\\n#### Explanation\\nFor solution 1, we know if y and x has a linear relationship, then randomizing x uniformly will be randomizing y uniformly. However, we almost have a relationship (consider unit circle) y = sqrt(1-x^2). This means for uniformly distributed x, we are \"squezzing\" y into a smaller range. If the range of y gets smaller and smaller, you originally uniformly distributed y will be \"pressed\" toward the x-axis. So you can see points get congested at end points of x, where the range of y is very small.\\n\\nFor solution 2, if you do not take sqrt(r), the points will just be uniformly distributed along each diameter. Since the diameter all collapse at the center point, you have a lot of points congested around the center as well. \\n\\nP.S., there is another solution of rejection sampling as many posted. That method can be used to calculate the value of PI. Just count the number of points falling into the circle, and divide it by the total number of points - the ratio should be pi/4.",
                "solutionTags": [],
                "code": "```python\\n%matplotlib inline\\nimport matplotlib.pyplot as plt\\nimport random\\nfrom math import *\\nimport numpy\\n\\ns1 = Solution1(10, 0, 0)\\nlog = numpy.transpose([s1.randPoint() for _ in range(1000)])\\nplt.scatter(*log)\\nplt.title(\\'Solution 1\\')\\nplt.show()\\n```\n```python\\nclass Solution1:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.r = radius\\n        self.xc = x_center\\n        self.yc = y_center\\n\\n    def randPoint(self):\\n        \"\"\"Not working - not uniform\"\"\"\\n        dx = random.uniform(-self.r, self.r) \\n        bound = sqrt(self.r**2 - dx**2)\\n        dy = random.uniform(-bound, bound)\\n        return [self.xc + dx, self.yc + dy]\\n```\n```python\\nclass Solution2:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.r = radius\\n        self.xc = x_center\\n        self.yc = y_center\\n\\n    def randPoint(self):\\n        \"\"\"Not working - not uniform\"\"\"\\n        theta = random.uniform(0, 2*pi)\\n        r = self.r * random.uniform(0, 1)\\n        return [self.xc + r*cos(theta), self.yc + r*sin(theta)]\\n```\n```python\\nclass Solution3:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.r = radius\\n        self.xc = x_center\\n        self.yc = y_center\\n\\n    def randPoint(self):\\n        \"\"\"Working - uniform\"\"\"\\n        theta = random.uniform(0, 2*pi)\\n        r = self.r * sqrt(random.uniform(0, 1))\\n        return [self.xc + r*cos(theta), self.yc + r*sin(theta)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154850,
                "title": "python-solution-without-using-rejection-sampling",
                "content": "```\\nimport math\\nimport random\\n\\nclass Solution:\\n\\n    def __init__(self, radius, x_center, y_center):\\n        \"\"\"\\n        :type radius: float\\n        :type x_center: float\\n        :type y_center: float\\n        \"\"\"\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n        random.seed()\\n\\n    def randPoint(self):\\n        \"\"\"\\n        :rtype: List[float]\\n        \"\"\"\\n        degree = random.uniform(0, 2 * math.pi)\\n        dist = (2 * random.uniform(0, self.radius ** 2 / 2.0)) ** (1/2.0)\\n        x = dist * math.cos(degree)\\n        y = dist * math.sin(degree)\\n        return [self.x_center + x, self.y_center + y]\\n```\\n\\nThe secret of uniformality is done through this function:\\n```\\n(2 * random.uniform(0, self.radius ** 2 / 2.0)) ** (1/2.0)\\n```\\nFor each concentric circule, the probability that this concentric circule should be choosen is propotionaly to its length which in tern is proportial to its radius. So we need to make sure that if we construct a pdf for the radius, this pdf should be a linear function.\\nThis means we need a transformation function to map the output from random uniform to our desired distribution. Consider the inverse of such, ```t(y)```, we have:\\n```\\nd cdf(t(y)) / d y = c1 * y\\nd cdf(x) / d x = c2\\n```\\nThis implies that ```t\\'(y) = y * c1 / c2```, so ```t(y)``` is a quadratic function and the inverse of such is a square root function.\\n",
                "solutionTags": [],
                "code": "```\\nimport math\\nimport random\\n\\nclass Solution:\\n\\n    def __init__(self, radius, x_center, y_center):\\n        \"\"\"\\n        :type radius: float\\n        :type x_center: float\\n        :type y_center: float\\n        \"\"\"\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n        random.seed()\\n\\n    def randPoint(self):\\n        \"\"\"\\n        :rtype: List[float]\\n        \"\"\"\\n        degree = random.uniform(0, 2 * math.pi)\\n        dist = (2 * random.uniform(0, self.radius ** 2 / 2.0)) ** (1/2.0)\\n        x = dist * math.cos(degree)\\n        y = dist * math.sin(degree)\\n        return [self.x_center + x, self.y_center + y]\\n```\n```\\n(2 * random.uniform(0, self.radius ** 2 / 2.0)) ** (1/2.0)\\n```\n```t(y)```\n```\\nd cdf(t(y)) / d y = c1 * y\\nd cdf(x) / d x = c2\\n```\n```t\\'(y) = y * c1 / c2```\n```t(y)```",
                "codeTag": "Java"
            },
            {
                "id": 1125210,
                "title": "advantage-shuffle-short-easy-w-explanation",
                "content": "***Solution - I***\\n\\nThe problem asks us to maximize `A[i] > B[i]`. We can do this by choosing an element from `A` for every element of `B` such that element chosen from A is the smallest element greater than corresponding element from B.\\n\\nTo do this efficiently, we must sort the arrays `A` and `B`. After that, we must choose the elements for each index of B as stated above. The index of B for which `A[i] > B[i]` isn\\'t possible in solution are assigned at last (order doesn\\'t matter).\\n\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tsort(begin(A), end(A));\\n\\tvector<int> tmp = B;\\n\\tsort(begin(tmp), end(tmp));\\n\\tint idx1 = 0, idx2 = 0, n = size(A);\\n\\tunordered_map<int, vector<int> > mp;\\n\\twhile(idx1 < n)\\n\\t\\tif(A[idx1] > tmp[idx2]) mp[tmp[idx2++]].push_back(A[idx1]), A[idx1++] = -1;\\n\\t\\telse idx1++;\\n\\tfor(auto& num : A) if(num != -1) mp[tmp[idx2++]].push_back(num);\\n\\tidx2 = 0;\\n\\tfor(auto& num : B) tmp[idx2++] = mp[num].back(), mp[num].pop_back();\\n\\treturn tmp;\\n}\\n```\\n\\n**Time Complexity :** **`O(NlogN)`**, where `N` is the length of vectors `A/B`\\n**Space Complexity :** **`O(N)`**\\n\\n----------\\n----------\\n\\n***Solution - II***\\n\\nA better, more concise solution is to use multiset to solve the problem. We can keep track of the sorted elements of `A` and if any element of B is such that `A[i] > B[i]` is not possible, just assign it the smallest element available in the multiset. Every time an element is assigned and deleted.\\n\\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {        \\n\\tmultiset<int> s(begin(A), end(A));        \\n\\tfor(int i = 0; i < size(B); i++){\\n\\t\\tauto it = s.upper_bound(B[i]);\\n\\t\\tif(it == end(s)) it = begin(s);\\n\\t\\tB[i] = *it;\\n\\t\\ts.erase(it);\\n\\t}\\n\\treturn B;\\n}\\n```\\n\\n**Time Complexity :** **`O(NlogN)`**, where `N` is the length of vectors `A/B`.\\n**Space Complexity :** **`O(N)`**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {\\n\\tsort(begin(A), end(A));\\n\\tvector<int> tmp = B;\\n\\tsort(begin(tmp), end(tmp));\\n\\tint idx1 = 0, idx2 = 0, n = size(A);\\n\\tunordered_map<int, vector<int> > mp;\\n\\twhile(idx1 < n)\\n\\t\\tif(A[idx1] > tmp[idx2]) mp[tmp[idx2++]].push_back(A[idx1]), A[idx1++] = -1;\\n\\t\\telse idx1++;\\n\\tfor(auto& num : A) if(num != -1) mp[tmp[idx2++]].push_back(num);\\n\\tidx2 = 0;\\n\\tfor(auto& num : B) tmp[idx2++] = mp[num].back(), mp[num].pop_back();\\n\\treturn tmp;\\n}\\n```\n```\\nvector<int> advantageCount(vector<int>& A, vector<int>& B) {        \\n\\tmultiset<int> s(begin(A), end(A));        \\n\\tfor(int i = 0; i < size(B); i++){\\n\\t\\tauto it = s.upper_bound(B[i]);\\n\\t\\tif(it == end(s)) it = begin(s);\\n\\t\\tB[i] = *it;\\n\\t\\ts.erase(it);\\n\\t}\\n\\treturn B;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113625,
                "title": "generate-random-point-in-a-circle-js-python-java-c-polar-notation-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe easiest way to get a random point in a circle is to use **polar notation**. With polar notation, you can define any point in the circle with the polar angle (**ang**) and the length of the hypotenuse (**hyp**).\\n\\nFor both, we can apply a random number generator to give us a value in a usable range. The polar angle will be in the range **[0, 2 * pi]** and the hypotenuse will be in the range **[0, radius]**.\\n\\nThings can get tricky when we\\'re finding a random value for the hypotenuse, however, because if we evenly favor the entire allowable range, the points will tend to be more densely packed towards the center of the circle.\\n\\nTake, for example, a circle with a radius of **1**. If we divide the radius in half, the area in which the points with a hypotenuse in the smaller half (**[0, 0.5]**) will be scattered is a circle of radius 0.5 whose area is defined as **pi * (0.5)^2**, or **0.25 * pi**. The area in which the points with a hypotenuse in the larger half (**[0.5, 1]**) will be scattered is the remaining difference of the larger circle, defined as **pi * 1^2 - 0.25 * pi**, or **0.75 * pi**.\\n\\n![visual 1](https://i.imgur.com/1dWiDnQ.png)\\n\\nSo even though the two halves are even, the area described by rotating the two halves around the center are drastically different. In order to allow for an even distribution, then, we need to take the square root of the random number *before* multiplying it by the radius to get our hypotenuse, so that we can exponentially favor values farther from the center.\\n\\nOnce we have our values for **ang** and **hyp**, we can simply use sine and cosine to obtain values for the opposite (**opp**) and adjacent (**adj**) legs of our right triangle, which will equal the amount we need to add to/subtract from the x and y coordinates of our center point (**XC**, **YC**).\\n\\n![visual 2](https://i.imgur.com/dLc2H2S.png)\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThe code for all four languages is almost identical.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **160ms / 55.2MB** (beats 100% / 100%).\\n```javascript\\nclass Solution {\\n    constructor(radius, x_center, y_center) {\\n        this.RAD = radius\\n        this.XC = x_center\\n        this.YC = y_center\\n    }\\n    randPoint() {\\n        let ang = Math.random() * 2 * Math.PI,\\n            hyp = Math.sqrt(Math.random()) * this.RAD,\\n            adj = Math.cos(ang) * hyp,\\n            opp = Math.sin(ang) * hyp\\n        return [this.XC + adj, this.YC + opp]\\n    }\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **132ms / 24.3MB** (beats 95% / 89%).\\n```python\\nclass Solution:\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.RAD = radius\\n        self.XC = x_center\\n        self.YC = y_center\\n    def randPoint(self) -> List[float]:\\n        ang = random.uniform(0, 1) * 2 * math.pi\\n        hyp = sqrt(random.uniform(0, 1)) * self.RAD\\n        adj = cos(ang) * hyp\\n        opp = sin(ang) * hyp\\n        return [self.XC + adj, self.YC + opp]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **193ms / 48.0MB** (beats 100% / 99%).\\n```java\\nclass Solution {\\n    double RAD, XC, YC;\\n    public Solution(double radius, double x_center, double y_center) {\\n        RAD = radius;\\n        XC = x_center;\\n        YC = y_center;\\n    }\\n    public double[] randPoint() {\\n        double ang = Math.random() * 2 * Math.PI,\\n            hyp = Math.sqrt(Math.random()) * RAD,\\n            adj = Math.cos(ang) * hyp,\\n            opp = Math.sin(ang) * hyp;\\n        return new double[]{XC + adj, YC + opp};\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **84ms / 27.1MB** (beats 97% / 82%).\\n```c++\\nclass Solution {\\npublic:\\n    double RAD, XC, YC;\\n    Solution(double radius, double x_center, double y_center) {\\n        RAD = radius;\\n        XC = x_center;\\n        YC = y_center;\\n    }   \\n    vector<double> randPoint() {\\n        double ang = (double)rand() / RAND_MAX * 2 * M_PI,\\n            hyp = sqrt((double)rand() / RAND_MAX) * RAD,\\n            adj = cos(ang) * hyp,\\n            opp = sin(ang) * hyp;\\n        return vector<double>{XC + adj, YC + opp};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nclass Solution {\\n    constructor(radius, x_center, y_center) {\\n        this.RAD = radius\\n        this.XC = x_center\\n        this.YC = y_center\\n    }\\n    randPoint() {\\n        let ang = Math.random() * 2 * Math.PI,\\n            hyp = Math.sqrt(Math.random()) * this.RAD,\\n            adj = Math.cos(ang) * hyp,\\n            opp = Math.sin(ang) * hyp\\n        return [this.XC + adj, this.YC + opp]\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.RAD = radius\\n        self.XC = x_center\\n        self.YC = y_center\\n    def randPoint(self) -> List[float]:\\n        ang = random.uniform(0, 1) * 2 * math.pi\\n        hyp = sqrt(random.uniform(0, 1)) * self.RAD\\n        adj = cos(ang) * hyp\\n        opp = sin(ang) * hyp\\n        return [self.XC + adj, self.YC + opp]\\n```\n```java\\nclass Solution {\\n    double RAD, XC, YC;\\n    public Solution(double radius, double x_center, double y_center) {\\n        RAD = radius;\\n        XC = x_center;\\n        YC = y_center;\\n    }\\n    public double[] randPoint() {\\n        double ang = Math.random() * 2 * Math.PI,\\n            hyp = Math.sqrt(Math.random()) * RAD,\\n            adj = Math.cos(ang) * hyp,\\n            opp = Math.sin(ang) * hyp;\\n        return new double[]{XC + adj, YC + opp};\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    double RAD, XC, YC;\\n    Solution(double radius, double x_center, double y_center) {\\n        RAD = radius;\\n        XC = x_center;\\n        YC = y_center;\\n    }   \\n    vector<double> randPoint() {\\n        double ang = (double)rand() / RAND_MAX * 2 * M_PI,\\n            hyp = sqrt((double)rand() / RAND_MAX) * RAD,\\n            adj = cos(ang) * hyp,\\n            opp = sin(ang) * hyp;\\n        return vector<double>{XC + adj, YC + opp};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169518,
                "title": "c-ac-solution-using-rejection-sampling",
                "content": "Thank you guys for sharing your solutions using the Polar Coordinate, but it seems hard to find other solutions that are using rejection sampling in C++.\\n\\nThough it is quite slower than polar coordinates, using rejection sampling is easy to understand as it does not require some statistics background.\\n\\n```\\nclass Solution {\\npublic:\\n    double radius;\\n    double x_center;\\n    double y_center;\\n    \\n    Solution(double radius, double x_center, double y_center) {\\n        this->radius = radius;\\n        this->x_center = x_center;\\n        this->y_center = y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        double x;\\n        double y;\\n        \\n        do {\\n            x = (2 * ((double)rand() / RAND_MAX) - 1.0) * radius;\\n            y = (2 * ((double)rand() / RAND_MAX) - 1.0) * radius;\\n        } while (x * x + y * y > radius * radius);\\n        \\n        return { x_center + x, y_center + y };\\n    }\\n};\\n```\\n\\nThe condition of while loop checks that (x, y) coordinate is in the range of the circle.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double radius;\\n    double x_center;\\n    double y_center;\\n    \\n    Solution(double radius, double x_center, double y_center) {\\n        this->radius = radius;\\n        this->x_center = x_center;\\n        this->y_center = y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        double x;\\n        double y;\\n        \\n        do {\\n            x = (2 * ((double)rand() / RAND_MAX) - 1.0) * radius;\\n            y = (2 * ((double)rand() / RAND_MAX) - 1.0) * radius;\\n        } while (x * x + y * y > radius * radius);\\n        \\n        return { x_center + x, y_center + y };\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114249,
                "title": "can-anyone-help-me-find-out-why-this-is-wrong-thank-you",
                "content": "x1 is a random number within ```(x-r,x+r)```\\nsince \\n(x-x1)^2+(y-y1)^2 <= r^2\\n(y-y1)^2<=r^2-(x-x1)^2\\n\\n``` double range =Math.sqrt( r^2 - (x-x1)^2)```\\n\\ny1 is in range ``` y-range, y+range```\\n\\nBut this solution cannot pass all the test set. \\n\\n```\\nclass Solution {\\n    \\n    Random rm;\\n    double x;\\n    double y;\\n    double r;\\n    public Solution(double radius, double x_center, double y_center) {\\n        rm=new Random();\\n        x=x_center;\\n        y=y_center;\\n        r=radius;\\n    }\\n    \\n    public double[] randPoint() {\\n              double x1=x-r+Math.random()*2*r;\\n        double range=Math.sqrt(Math.pow(r,2)-Math.pow((x-x1),2));\\n        double y1=y-range+Math.random()*2*range;\\n        return new double[]{x1,y1};\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(radius, x_center, y_center);\\n * double[] param_1 = obj.randPoint();\\n */\\n ```",
                "solutionTags": [],
                "code": "```(x-r,x+r)```\n``` double range =Math.sqrt( r^2 - (x-x1)^2)```\n``` y-range, y+range```\n```\\nclass Solution {\\n    \\n    Random rm;\\n    double x;\\n    double y;\\n    double r;\\n    public Solution(double radius, double x_center, double y_center) {\\n        rm=new Random();\\n        x=x_center;\\n        y=y_center;\\n        r=radius;\\n    }\\n    \\n    public double[] randPoint() {\\n              double x1=x-r+Math.random()*2*r;\\n        double range=Math.sqrt(Math.pow(r,2)-Math.pow((x-x1),2));\\n        double y1=y-range+Math.random()*2*range;\\n        return new double[]{x1,y1};\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(radius, x_center, y_center);\\n * double[] param_1 = obj.randPoint();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1113767,
                "title": "c-polar-coordinates-generation",
                "content": "```\\nclass Solution {\\n    double r, x, y;\\npublic:\\n    Solution(double radius, double x_center, double y_center) : r(radius), x(x_center), y(y_center) {\\n    }\\n    \\n    vector<double> randPoint() {\\n\\t\\t // sqrt makes uniform distribution, because the area of circle depends on radius^2\\n\\t\\t // dist is in range [0..r]\\n        double dist = sqrt((double)rand() / RAND_MAX) * r;\\n\\t\\t// Angle is in range [0..2*Pi]\\n        double angle = (double)rand() / RAND_MAX * 2 * M_PI;\\n        \\n\\t\\t// Transform polar coordinates to Cartesian coordinates\\n        return {x + dist * cos(angle), y + dist * sin(angle)};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    double r, x, y;\\npublic:\\n    Solution(double radius, double x_center, double y_center) : r(radius), x(x_center), y(y_center) {\\n    }\\n    \\n    vector<double> randPoint() {\\n\\t\\t // sqrt makes uniform distribution, because the area of circle depends on radius^2\\n\\t\\t // dist is in range [0..r]\\n        double dist = sqrt((double)rand() / RAND_MAX) * r;\\n\\t\\t// Angle is in range [0..2*Pi]\\n        double angle = (double)rand() / RAND_MAX * 2 * M_PI;\\n        \\n\\t\\t// Transform polar coordinates to Cartesian coordinates\\n        return {x + dist * cos(angle), y + dist * sin(angle)};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110552,
                "title": "encode-and-decode-tinyurl-js-python-java-c-easy-map-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSince the characters we can use in the short url are limited just as much as the characters that can be used to make up the long url, there\\'s not much legitimate compression that can realistically be done.\\n\\nThe only generally feasible option is to use a **map** to act as a lookup table for codes and either use a hashing function or a random code generator to generate the **code**. Since we\\'re storing the information anyway (hashes only work one-way), we might as well just use a random code generator (**getCode()**).\\n\\nBased on the example, we can create a function that creates a random **6**-character code, using the **62 alphanumeric characters**. We should make sure to come up with a new code in the rare case that we randomly create a duplicate.\\n\\nTo avoid having to **encode** the same url twice with different random codes, we can create a reverse lookup table (**urlDB**) to store already encoded urls.\\n\\nThe **decode** function will just **return** the entry from the code map (**codeDB**).\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython has predefined alphanumeric strings, so we can take advantage of that.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 40.3MB** (beats 99% / 61%).\\n```javascript\\nlet codeDB = new Map(), urlDB = new Map()\\nconst chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\\n\\nconst getCode = () => {\\n    let code = new Array(6).fill()\\n        .map(_ => chars.charAt(~~(Math.random() * 62)))\\n    return \"http://tinyurl.com/\" + code.join(\"\")\\n}\\n\\nconst encode = longUrl => {\\n    if (urlDB.has(longUrl)) return urlDB.get(longUrl)\\n    let code = getCode()\\n    while (codeDB.has(code)) code = getCode()\\n    codeDB.set(code, longUrl)\\n    urlDB.set(longUrl, code)\\n    return code\\n}\\n\\nconst decode = shortUrl => codeDB.get(shortUrl)\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.1MB** (beats 98% / 82%).\\n```python\\nclass Codec:\\n    codeDB, urlDB = defaultdict(), defaultdict()\\n    chars = string.ascii_letters + string.digits\\n\\n    def getCode(self) -> str:\\n        code = \\'\\'.join(random.choice(self.chars) for i in range(6))\\n        return \"http://tinyurl.com/\" + code\\n \\n    def encode(self, longUrl: str) -> str:\\n        if longUrl in self.urlDB: return self.urlDB[longUrl]\\n        code = self.getCode()\\n        while code in self.codeDB: code = getCode()\\n        self.codeDB[code] = longUrl\\n        self.urlDB[longUrl] = code\\n        return code\\n\\n    def decode(self, shortUrl: str) -> str:\\n        return self.codeDB[shortUrl]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **3ms / 38.7MB** (beats 83% / 99%).\\n```java\\npublic class Codec {\\n    Map<String, String> codeDB = new HashMap<>(), urlDB = new HashMap<>();\\n    static final String chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n\\n    private String getCode() {\\n        char[] code = new char[6];\\n        for (int i = 0; i < 6; i++) \\n            code[i] = chars.charAt((int)Math.random() * 62);\\n        return \"http://tinyurl.com/\" + String.valueOf(code);\\n    }\\n    \\n    public String encode(String longUrl) {\\n        if (urlDB.containsKey(longUrl)) return urlDB.get(longUrl);\\n        String code = getCode();\\n        while (codeDB.containsKey(code)) code = getCode();\\n        codeDB.put(code, longUrl);\\n        urlDB.put(longUrl, code);\\n        return code;\\n    }\\n\\n    public String decode(String shortUrl) {\\n        return codeDB.get(shortUrl);\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.3MB** (beats 100% / 42%).\\n```c++\\nclass Solution {\\npublic:\\n    unordered_map<string, string> codeDB, urlDB;\\n    const string chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n    \\n    string getCode() {\\n        string code = \"\";\\n        for (int i = 0; i < 6; i++) code += chars[rand() % 62];\\n        return \"http://tinyurl.com/\" + code;\\n    }\\n    \\n    string encode(string longUrl) {\\n        if (urlDB.find(longUrl) != urlDB.end()) return urlDB[longUrl];\\n        string code = getCode();\\n        while (codeDB.find(code) != codeDB.end()) code = getCode();\\n        codeDB[code] = longUrl;\\n        urlDB[longUrl] = code;\\n        return code;\\n    }\\n\\n    string decode(string shortUrl) {\\n        return codeDB[shortUrl];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nlet codeDB = new Map(), urlDB = new Map()\\nconst chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\\n\\nconst getCode = () => {\\n    let code = new Array(6).fill()\\n        .map(_ => chars.charAt(~~(Math.random() * 62)))\\n    return \"http://tinyurl.com/\" + code.join(\"\")\\n}\\n\\nconst encode = longUrl => {\\n    if (urlDB.has(longUrl)) return urlDB.get(longUrl)\\n    let code = getCode()\\n    while (codeDB.has(code)) code = getCode()\\n    codeDB.set(code, longUrl)\\n    urlDB.set(longUrl, code)\\n    return code\\n}\\n\\nconst decode = shortUrl => codeDB.get(shortUrl)\\n```\n```python\\nclass Codec:\\n    codeDB, urlDB = defaultdict(), defaultdict()\\n    chars = string.ascii_letters + string.digits\\n\\n    def getCode(self) -> str:\\n        code = \\'\\'.join(random.choice(self.chars) for i in range(6))\\n        return \"http://tinyurl.com/\" + code\\n \\n    def encode(self, longUrl: str) -> str:\\n        if longUrl in self.urlDB: return self.urlDB[longUrl]\\n        code = self.getCode()\\n        while code in self.codeDB: code = getCode()\\n        self.codeDB[code] = longUrl\\n        self.urlDB[longUrl] = code\\n        return code\\n\\n    def decode(self, shortUrl: str) -> str:\\n        return self.codeDB[shortUrl]\\n```\n```java\\npublic class Codec {\\n    Map<String, String> codeDB = new HashMap<>(), urlDB = new HashMap<>();\\n    static final String chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n\\n    private String getCode() {\\n        char[] code = new char[6];\\n        for (int i = 0; i < 6; i++) \\n            code[i] = chars.charAt((int)Math.random() * 62);\\n        return \"http://tinyurl.com/\" + String.valueOf(code);\\n    }\\n    \\n    public String encode(String longUrl) {\\n        if (urlDB.containsKey(longUrl)) return urlDB.get(longUrl);\\n        String code = getCode();\\n        while (codeDB.containsKey(code)) code = getCode();\\n        codeDB.put(code, longUrl);\\n        urlDB.put(longUrl, code);\\n        return code;\\n    }\\n\\n    public String decode(String shortUrl) {\\n        return codeDB.get(shortUrl);\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    unordered_map<string, string> codeDB, urlDB;\\n    const string chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n    \\n    string getCode() {\\n        string code = \"\";\\n        for (int i = 0; i < 6; i++) code += chars[rand() % 62];\\n        return \"http://tinyurl.com/\" + code;\\n    }\\n    \\n    string encode(string longUrl) {\\n        if (urlDB.find(longUrl) != urlDB.end()) return urlDB[longUrl];\\n        string code = getCode();\\n        while (codeDB.find(code) != codeDB.end()) code = getCode();\\n        codeDB[code] = longUrl;\\n        urlDB[longUrl] = code;\\n        return code;\\n    }\\n\\n    string decode(string shortUrl) {\\n        return codeDB[shortUrl];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2866878,
                "title": "c-solutions",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    double r,x,y;\\n    Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        double x_r = ((double)rand()/RAND_MAX * (2*r)) + (x-r);\\n        double y_r = ((double)rand()/RAND_MAX * (2*r)) + (y-r);\\n        \\n        while(solve(x_r,y_r,x,y)>=r*r)\\n        {\\n            x_r = ((double)rand()/RAND_MAX * (2*r)) + (x-r);\\n            y_r = ((double)rand()/RAND_MAX * (2*r)) + (y-r);\\n        }\\n        \\n        return {x_r,y_r};\\n    }\\n    \\n    double solve(double x_r,double y_r,double x,double y)\\n    {\\n        return (x-x_r)*(x-x_r) + (y-y_r)*(y-y_r);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    double r,x,y;\\n    Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        double x_r = ((double)rand()/RAND_MAX * (2*r)) + (x-r);\\n        double y_r = ((double)rand()/RAND_MAX * (2*r)) + (y-r);\\n        \\n        while(solve(x_r,y_r,x,y)>=r*r)\\n        {\\n            x_r = ((double)rand()/RAND_MAX * (2*r)) + (x-r);\\n            y_r = ((double)rand()/RAND_MAX * (2*r)) + (y-r);\\n        }\\n        \\n        return {x_r,y_r};\\n    }\\n    \\n    double solve(double x_r,double y_r,double x,double y)\\n    {\\n        return (x-x_r)*(x-x_r) + (y-y_r)*(y-y_r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116708,
                "title": "keys-and-rooms-js-python-java-c-easy-dfs-stack-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nSince we can only enter rooms to which we have found a key, we can\\'t just iterate through the entire input array (**R**) normally. If we think of this like a graph problem, we can see that the rooms are like nodes and the keys are like edges.\\n\\nIn that case, we can use a **breadth-first search** (**BFS**) **queue** or a **depth-first search** (**DFS**) **stack** approach, or even a **DFS recursion** approach here to good effect. Here, we\\'ll push newly found keys onto **stack** as we go through.\\n\\nTo eliminate duplicate stack entries, we can use a lightweight **boolean array** (**vis**) to keep track of which rooms have already been pushed onto the stack. Rather than having to count the number of visited rooms again at the end, we can just use another variable (**count**) to keep track of that separately.\\n\\nOnce our stack runs empty, we can just check to see if the **count** is the same as the length of **R** and **return** the answer.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript can use a Uint8Array instead of a boolean array.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 40.5MB** (beats 100% / 60%).\\n```javascript\\nvar canVisitAllRooms = function(R) {\\n    let vis = new Uint8Array(R.length), stack = [0], count = 1\\n    vis[0] = 1\\n    while (stack.length) {\\n        let keys = R[stack.pop()]\\n        for (let k of keys)\\n            if (!vis[k]) stack.push(k), vis[k] = 1, count++\\n    }\\n    return R.length === count\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **52ms / 14.6MB** (beats 100% / 95%).\\n```python\\nclass Solution:\\n    def canVisitAllRooms(self, R: List[List[int]]) -> bool:\\n        vis, stack, count = [False for _ in range(len(R))], [0], 1\\n        vis[0] = 1\\n        while stack:\\n            keys = R[stack.pop()]\\n            for k in keys:\\n                if not vis[k]:\\n                    stack.append(k)\\n                    vis[k] = True\\n                    count += 1\\n        return len(R) == count\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 38.4MB** (beats 86% / 100%).\\n```java\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> R) {\\n        boolean[] vis = new boolean[R.size()];\\n        vis[0] = true;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(0);\\n        int count = 1;\\n        while (stack.size() > 0)\\n            for (int k : R.get(stack.pop()))\\n                if (!vis[k]) {\\n                    stack.push(k);\\n                    vis[k] = true;\\n                    count++;\\n                }\\n        return R.size() == count;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **4ms / 10.4MB** (beats 99% / 67%).\\n```c++\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& R) {\\n        vector<bool> vis(R.size(), false);\\n        vis[0] = true;\\n        stack<int> stk = stack<int>({0});\\n        int count = 1;\\n        while (stk.size()) {\\n            vector<int> keys = R[stk.top()]; stk.pop();\\n            for (int k : keys)\\n                if (!vis[k]) stk.push(k), vis[k] = true, count++;\\n        }\\n        return R.size() == count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar canVisitAllRooms = function(R) {\\n    let vis = new Uint8Array(R.length), stack = [0], count = 1\\n    vis[0] = 1\\n    while (stack.length) {\\n        let keys = R[stack.pop()]\\n        for (let k of keys)\\n            if (!vis[k]) stack.push(k), vis[k] = 1, count++\\n    }\\n    return R.length === count\\n};\\n```\n```python\\nclass Solution:\\n    def canVisitAllRooms(self, R: List[List[int]]) -> bool:\\n        vis, stack, count = [False for _ in range(len(R))], [0], 1\\n        vis[0] = 1\\n        while stack:\\n            keys = R[stack.pop()]\\n            for k in keys:\\n                if not vis[k]:\\n                    stack.append(k)\\n                    vis[k] = True\\n                    count += 1\\n        return len(R) == count\\n```\n```java\\nclass Solution {\\n    public boolean canVisitAllRooms(List<List<Integer>> R) {\\n        boolean[] vis = new boolean[R.size()];\\n        vis[0] = true;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(0);\\n        int count = 1;\\n        while (stack.size() > 0)\\n            for (int k : R.get(stack.pop()))\\n                if (!vis[k]) {\\n                    stack.push(k);\\n                    vis[k] = true;\\n                    count++;\\n                }\\n        return R.size() == count;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool canVisitAllRooms(vector<vector<int>>& R) {\\n        vector<bool> vis(R.size(), false);\\n        vis[0] = true;\\n        stack<int> stk = stack<int>({0});\\n        int count = 1;\\n        while (stk.size()) {\\n            vector<int> keys = R[stk.top()]; stk.pop();\\n            for (int k : keys)\\n                if (!vis[k]) stk.push(k), vis[k] = true, count++;\\n        }\\n        return R.size() == count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154027,
                "title": "straight-forward-java-ac-solution",
                "content": "Fit the circle in a square.\\nSample a point in the square and check if it\\'s also in the circle. If not, sample again.\\n\\n```\\nclass Solution {\\n    double r, x, y;\\n        \\n    public Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        Random rand = new Random();\\n        Double nx = x - r + rand.nextDouble() * 2 * r;\\n        double ny = y - r + rand.nextDouble() * 2 * r;\\n        double r2 = r * r;\\n        while(dis(nx, ny) >= r2){\\n            nx = x - r + rand.nextDouble() * 2 * r;\\n            ny = y - r + rand.nextDouble() * 2 * r;\\n        }\\n        return new double[]{nx, ny};\\n    }\\n    \\n    // it returns the square of the distance between the point and the center;\\n    double dis(double nx, double ny){\\n        return (nx - x) * (nx - x) + (ny - y) * (ny - y);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double r, x, y;\\n        \\n    public Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        Random rand = new Random();\\n        Double nx = x - r + rand.nextDouble() * 2 * r;\\n        double ny = y - r + rand.nextDouble() * 2 * r;\\n        double r2 = r * r;\\n        while(dis(nx, ny) >= r2){\\n            nx = x - r + rand.nextDouble() * 2 * r;\\n            ny = y - r + rand.nextDouble() * 2 * r;\\n        }\\n        return new double[]{nx, ny};\\n    }\\n    \\n    // it returns the square of the distance between the point and the center;\\n    double dis(double nx, double ny){\\n        return (nx - x) * (nx - x) + (ny - y) * (ny - y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133916,
                "title": "russian-doll-envelopes-easy-dp-solution-simple-trick-explained",
                "content": "The trick is, we first sort the envolopes based on their width, Then the problem now turned into finding **longest Increasing subsequence(LIS**), so we just need to find **LIS on heights of envolopes** but including some edges cases. \\nLets see the edge cases to understand it more..\\nconsider, `envolope = [[2,3],[5,8],[3,6],[5,7]]`, if we sort based on `compare function`, we get `[[2,3],[3,6],[5,7],[5,8]]`\\nNow, if perform LIS on heights, **LIS=4, but answer should be 3**, to tackle this we take `en[i][0] > en[j][0] && en[i][1]>en[j][1]` as our condition instead of `en[i][1]>en[j][1]` inorder to make sure both width and height increasing.\\n\\n**Do Upvote** if you like the code and comment down if you are facing some difficulty or having some queries.\\nGo through the code below for better understanding !!!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>a,vector<int>b){\\n        if(a[0] == b[0]) return a[1]<b[1];\\n        return a[0]<b[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>& en) {\\n        sort(en.begin(),en.end(),compare);\\n        int n = en.size(),res=1;\\n        vector<int>dp(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(en[i][0] > en[j][0] && en[i][1]>en[j][1]){\\n                    dp[i] = max(dp[i],dp[j]+1);\\n                    res = max(res,dp[i]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(vector<int>a,vector<int>b){\\n        if(a[0] == b[0]) return a[1]<b[1];\\n        return a[0]<b[0];\\n    }\\n    int maxEnvelopes(vector<vector<int>>& en) {\\n        sort(en.begin(),en.end(),compare);\\n        int n = en.size(),res=1;\\n        vector<int>dp(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                if(en[i][0] > en[j][0] && en[i][1]>en[j][1]){\\n                    dp[i] = max(dp[i],dp[j]+1);\\n                    res = max(res,dp[i]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132484,
                "title": "flip-binary-tree-to-match-preorder-traversal-easy-solution-explained",
                "content": "The idea is we traverse the voyage(v) declaring global variable `i=0`, \\nhere we need to consider, \\nif `root->val != v[i]` In this case we` return false`, because it not possible to get desired pre-order traversal.\\nAnd we check, if` root->left != NULL and if its root->left->val != v[i]`, then we flip the nodes of left and right child and push the` root->val` to our res.\\nfinally if it is possible to get desired pre-order traversal, we return our res containing the flipped node values, or else we `return {-1}`.\\n\\n**Do upvote** if you like the code, and comment down if you are facing any difficulty.\\n```\\nclass Solution {\\npublic:\\n    int i=0;\\n    vector<int> flipMatchVoyage(TreeNode* root, vector<int>& v) {\\n        vector<int>res;\\n        if(flipTree(root,v,res))\\n            return res;\\n        return {-1};\\n    }\\n    bool flipTree(TreeNode* root,vector<int>&v,vector<int>&res){\\n        if(root == NULL) return true;\\n        if(root->val != v[i++]) return false;\\n        if(root->left != NULL && root->left->val != v[i]){    \\n            res.push_back(root->val);\\n            swap(root->left,root->right);\\n        }\\n        return flipTree(root->left,v,res) && flipTree(root->right,v,res);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int i=0;\\n    vector<int> flipMatchVoyage(TreeNode* root, vector<int>& v) {\\n        vector<int>res;\\n        if(flipTree(root,v,res))\\n            return res;\\n        return {-1};\\n    }\\n    bool flipTree(TreeNode* root,vector<int>&v,vector<int>&res){\\n        if(root == NULL) return true;\\n        if(root->val != v[i++]) return false;\\n        if(root->left != NULL && root->left->val != v[i]){    \\n            res.push_back(root->val);\\n            swap(root->left,root->right);\\n        }\\n        return flipTree(root->left,v,res) && flipTree(root->right,v,res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116804,
                "title": "keys-and-rooms-short-easy-w-explanation-bfs-dfs",
                "content": "The problem asks us to check if we can visit every room starting from the room 0. This can be viewed as a **graph problem** where we want to check if we can visited every node if we start from `node 0`. The rooms are the nodes and keys are the edges of the graph.\\n\\n----------\\n\\n***Solution - I (Depth-First Search)***\\n\\n\\nThis can be done easily using a DFS. We only initiate the DFS from the `node 0` and once the DFS is complete, we check if every room is visited or not.\\n\\n\\n```\\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\\n\\tint n = size(rooms);\\n\\tvector<bool>visited(n, false);\\n\\tdfs(rooms, visited, 0);    // start from room 0\\n\\tfor(auto v : visited) if(!v) return false; // if all rooms were not reached from room 0, return false\\n\\treturn true; \\n}\\n\\nvoid dfs(vector<vector<int> >& rooms , vector<bool>& visited, int i){\\n\\tvisited[i] = true;\\n\\tfor(auto& room : rooms[i])\\n\\t\\tif(!visited[room]) dfs(rooms, visited, room);\\n}\\n```\\n\\n**Time Complexity :**  **`O(N + K)`**, where `N` is total number of rooms and `K` is the number of keys.\\n**Space Complexity :** **`O(N)`**\\n\\n![image](https://assets.leetcode.com/users/images/9f12d683-452d-4911-b045-ad4a3a072a8e_1616144286.1954126.png)\\n\\n\\n------------\\n-----------\\n\\n***Solution - II (Breadth-First Search)***\\n\\nWe can also solve the problem using a BFS appraoch -\\n\\n```\\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\\n\\tint n = size(rooms);\\n\\tvector<bool>visited(n, false);\\n\\tqueue<int> q;\\n\\tq.push(0);\\n\\twhile(!q.empty()){\\n\\t\\tint roomIdx = q.front(); q.pop();\\n\\t\\tvisited[roomIdx] = true;\\n\\t\\t// push every room visitable from current room into queue\\n\\t\\tfor(auto adjRoom : rooms[roomIdx])\\n\\t\\t\\tif(!visited[adjRoom]) q.push(adjRoom);\\n\\t}\\n\\t// return false if any room has not yet been visited\\n\\tfor(auto v : visited) if(!v) return false; \\n\\treturn true;\\n}\\n```\\n\\n**Time Complexity :**  **`O(N + K)`**, where `N` is total number of rooms and `K` is the number of keys.\\n**Space Complexity :** **`O(N)`**\\n\\n![image](https://assets.leetcode.com/users/images/40ccb23c-f0e8-4e7d-ba4d-1c95bdd2c070_1616144264.2904758.png)\\n\\n\\n-----------\\n-----------",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\\n\\tint n = size(rooms);\\n\\tvector<bool>visited(n, false);\\n\\tdfs(rooms, visited, 0);    // start from room 0\\n\\tfor(auto v : visited) if(!v) return false; // if all rooms were not reached from room 0, return false\\n\\treturn true; \\n}\\n\\nvoid dfs(vector<vector<int> >& rooms , vector<bool>& visited, int i){\\n\\tvisited[i] = true;\\n\\tfor(auto& room : rooms[i])\\n\\t\\tif(!visited[room]) dfs(rooms, visited, room);\\n}\\n```\n```\\nbool canVisitAllRooms(vector<vector<int>>& rooms) {\\n\\tint n = size(rooms);\\n\\tvector<bool>visited(n, false);\\n\\tqueue<int> q;\\n\\tq.push(0);\\n\\twhile(!q.empty()){\\n\\t\\tint roomIdx = q.front(); q.pop();\\n\\t\\tvisited[roomIdx] = true;\\n\\t\\t// push every room visitable from current room into queue\\n\\t\\tfor(auto adjRoom : rooms[roomIdx])\\n\\t\\t\\tif(!visited[adjRoom]) q.push(adjRoom);\\n\\t}\\n\\t// return false if any room has not yet been visited\\n\\tfor(auto v : visited) if(!v) return false; \\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1115277,
                "title": "wiggle-subsequence-short-easy-w-explanation",
                "content": "**Solution - I (Dynamic Programming)**\\n\\nThe problem asks us to find a sequence where differences of adjacent elements alternate between **+ve** & **-ve**. The problem can be restated as **Find the number of max and min peaks in the given array**.\\n\\nWe can iterate over the array and find these possibilities :\\n1. **`nums[i] > nums[i - 1]`**\\n2. **`nums[i] < nums[i - 1]`**\\n3. **`nums[i] == nums[i - 1]`**\\n\\nWe maintain two variables **`up`** and **`down`** both initialised to `1` (1st element will always be chosen). They denote maximum number of peaks till now with last peak being a max peak and min peak respectively. \\n\\nIf we come across condition 1, we have encountered a **possible max peak**. We update **`up`** as `1 + down` (1 + maximum number of peak till last min peak). However, if the next element is again coming under condition 1, we know that last peak shouldn\\'t have been considered. So, we again update **`up`** as `1 + down` denoting that the current peak has been considered as max peak.\\n\\nThis process is repeated for **`down`**  as well when we come across condition 2. We update **`down`** as `1 + up` (1 + maximum number of peak till last max peak).\\n\\nWhen condition 3 is encountered, we are sure that it is neither a max nor a min peak, so we just skip that iteration.\\n\\n```\\nint wiggleMaxLength(vector<int>& nums) {\\n\\tint n = size(nums), len = 1, up = 1, down = 1;\\n\\tfor(int i = 1; i < n; i++)\\n\\t\\tif(nums[i] < nums[i - 1]) up = 1 + down;\\n\\t\\telse if(nums[i] > nums[i - 1]) down = 1 + up;\\n\\t// array could start with min-peak or max-peak depending on which any of up & down could be our answer\\n\\treturn max(up, down); \\n}\\n```\\n\\n**Time Complexity :** **`O(N)`**, for traversing the array.\\n**Space Complexity :** **`O(1)`**, since only constant space is used.\\n\\n\\n-----------\\n-----------\\n\\n**Solution - II (Greedy Approach)**\\n\\nThis can be done using a greedy approach.\\n\\n* Start by initialising `prevDiff` to 0. Start a loop from 2nd number of the array.\\n* Whenever we encounter a case where `currDiff` (which is `nums[i] - nums[i - 1]`) is opposite in sign to `prevDiff` or `prevDiff == 0`(to consider the initial condition where prevDiff is 0), we know that we have come across a peak. So, we increase the length of subsequence.\\n* The final length we get is the maximum number of max and min peaks in the array.\\n\\n\\n```\\nint wiggleMaxLength(vector<int>& nums) {\\n\\tint n = size(nums), len = 1, prevDiff = 0, currDiff;\\n\\tfor(int i = 1; i < n; i++){\\n\\t\\tcurrDiff = nums[i] - nums[i - 1];\\n\\t\\tif((currDiff > 0 && prevDiff <= 0) || (currDiff < 0 && prevDiff >= 0))\\n\\t\\t\\tlen++, prevDiff = currDiff;\\n\\t}\\n\\treturn len;\\n}\\n```\\n**Time Complexity :** **`O(N)`**, for traversing the array.\\n**Space Complexity :** **`O(1)`**, since only constant space is used.\\n\\nBoth solution run with about the same speed -\\n\\n![image](https://assets.leetcode.com/users/images/d2b89faf-4e27-491c-933d-3ea1fc3d8cb6_1616065379.3338714.png)\\n\\n\\n\\n-----------\\n----------",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint wiggleMaxLength(vector<int>& nums) {\\n\\tint n = size(nums), len = 1, up = 1, down = 1;\\n\\tfor(int i = 1; i < n; i++)\\n\\t\\tif(nums[i] < nums[i - 1]) up = 1 + down;\\n\\t\\telse if(nums[i] > nums[i - 1]) down = 1 + up;\\n\\t// array could start with min-peak or max-peak depending on which any of up & down could be our answer\\n\\treturn max(up, down); \\n}\\n```\n```\\nint wiggleMaxLength(vector<int>& nums) {\\n\\tint n = size(nums), len = 1, prevDiff = 0, currDiff;\\n\\tfor(int i = 1; i < n; i++){\\n\\t\\tcurrDiff = nums[i] - nums[i - 1];\\n\\t\\tif((currDiff > 0 && prevDiff <= 0) || (currDiff < 0 && prevDiff >= 0))\\n\\t\\t\\tlen++, prevDiff = currDiff;\\n\\t}\\n\\treturn len;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1130468,
                "title": "c-polar-coords-solution",
                "content": "```\\npublic class Solution\\n{\\n    Random rand = new Random();\\n    double _r, _x, _y;\\n\\n    public Solution(double radius, double x_center, double y_center)\\n    {\\n        _r = radius;\\n        _x = x_center;\\n        _y = y_center;\\n    }\\n\\n    public double[] RandPoint()\\n    {\\n        var theta = 2.0 * Math.PI * rand.NextDouble();\\n        var r = _r * Math.Sqrt(rand.NextDouble()); // Math.Sqrt is important here for uniform density\\n\\n        var x = Math.Cos(theta) * r + _x;\\n        var y = Math.Sin(theta) * r + _y;\\n\\n        return new[] { x, y };\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    Random rand = new Random();\\n    double _r, _x, _y;\\n\\n    public Solution(double radius, double x_center, double y_center)\\n    {\\n        _r = radius;\\n        _x = x_center;\\n        _y = y_center;\\n    }\\n\\n    public double[] RandPoint()\\n    {\\n        var theta = 2.0 * Math.PI * rand.NextDouble();\\n        var r = _r * Math.Sqrt(rand.NextDouble()); // Math.Sqrt is important here for uniform density\\n\\n        var x = Math.Cos(theta) * r + _x;\\n        var y = Math.Sin(theta) * r + _y;\\n\\n        return new[] { x, y };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126739,
                "title": "pacific-atlantic-water-flow-easy-solution-simple-code-using-dfs",
                "content": "The idea is we are visiting every index that is reachable from pacific and atlantic and marking it as `visited=true` , and Finally we are checking if any index is reachable from both pacific and atlantic,then it is pushed into `res`.\\n\\n**DO UPVOTE** if you find it helpful!!\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& mat) {\\n        vector<vector<int>>res;\\n        int n = mat.size();\\n        if(n==0) return res;\\n        int m = mat[0].size();\\n        if(m==0) return res;\\n        vector<vector<bool>>pc(n,vector<bool>(m,false));\\n        vector<vector<bool>>at(n,vector<bool>(m,false));\\n        \\n        for(int i=0;i<n;i++){\\n            dfs(mat,pc,i,0,INT_MIN);\\n            dfs(mat,at,i,m-1,INT_MIN);\\n        }\\n        for(int j=0;j<m;j++){\\n            dfs(mat,pc,0,j,INT_MIN);\\n            dfs(mat,at,n-1,j,INT_MIN);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(pc[i][j] && at[i][j])\\n                    res.push_back({i,j});\\n            }\\n        }\\n        return res;\\n    }    \\n    void dfs(vector<vector<int>>&mat,vector<vector<bool>> &visited,int i,int j,int prev){\\n        if(i<0 || j<0 || i>=mat.size() || j>= mat[0].size() || visited[i][j] || mat[i][j]<prev) return;\\n        visited[i][j] = true;\\n            dfs(mat,visited,i+1,j,mat[i][j]);\\n            dfs(mat,visited,i-1,j,mat[i][j]);\\n            dfs(mat,visited,i,j+1,mat[i][j]);\\n            dfs(mat,visited,i,j-1,mat[i][j]);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& mat) {\\n        vector<vector<int>>res;\\n        int n = mat.size();\\n        if(n==0) return res;\\n        int m = mat[0].size();\\n        if(m==0) return res;\\n        vector<vector<bool>>pc(n,vector<bool>(m,false));\\n        vector<vector<bool>>at(n,vector<bool>(m,false));\\n        \\n        for(int i=0;i<n;i++){\\n            dfs(mat,pc,i,0,INT_MIN);\\n            dfs(mat,at,i,m-1,INT_MIN);\\n        }\\n        for(int j=0;j<m;j++){\\n            dfs(mat,pc,0,j,INT_MIN);\\n            dfs(mat,at,n-1,j,INT_MIN);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(pc[i][j] && at[i][j])\\n                    res.push_back({i,j});\\n            }\\n        }\\n        return res;\\n    }    \\n    void dfs(vector<vector<int>>&mat,vector<vector<bool>> &visited,int i,int j,int prev){\\n        if(i<0 || j<0 || i>=mat.size() || j>= mat[0].size() || visited[i][j] || mat[i][j]<prev) return;\\n        visited[i][j] = true;\\n            dfs(mat,visited,i+1,j,mat[i][j]);\\n            dfs(mat,visited,i-1,j,mat[i][j]);\\n            dfs(mat,visited,i,j+1,mat[i][j]);\\n            dfs(mat,visited,i,j-1,mat[i][j]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121785,
                "title": "vowel-spellchecker-c-easy-solution-clean-code-using-unordered-maps",
                "content": "**Please Upvote** if you find it helpful\\n```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_map<string, string> c;\\n        unordered_map<string, string> v;\\n        unordered_set<string> s1;\\n        for(string word: wordlist) {\\n            s1.insert(word);\\n            string temp = tolowerAlpha(word);\\n            if(c.find(temp) == c.end()) c[temp] = word;\\n            if(v.find(removeVowels(temp)) == v.end()) v[removeVowels(temp)] = word;\\n        }\\n        vector<string> res;\\n        for(string s: queries) {\\n            string temp = tolowerAlpha(s);\\n            if(s1.find(s) != s1.end()) res.push_back(s);\\n            else if(c.find(temp) != c.end()) res.push_back(c[temp]);\\n            else if(v.find(removeVowels(temp)) != v.end()) res.push_back(v[removeVowels(temp)]);\\n            else res.push_back(\"\");\\n        }\\n        return res;\\n    }\\n    string removeVowels(string s) {\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'i\\') s[i] = \\'*\\';\\n        }\\n        return s;\\n    }\\n    string tolowerAlpha(string s) {\\n        string str;\\n        for(char c: s) str += tolower(c);\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_map<string, string> c;\\n        unordered_map<string, string> v;\\n        unordered_set<string> s1;\\n        for(string word: wordlist) {\\n            s1.insert(word);\\n            string temp = tolowerAlpha(word);\\n            if(c.find(temp) == c.end()) c[temp] = word;\\n            if(v.find(removeVowels(temp)) == v.end()) v[removeVowels(temp)] = word;\\n        }\\n        vector<string> res;\\n        for(string s: queries) {\\n            string temp = tolowerAlpha(s);\\n            if(s1.find(s) != s1.end()) res.push_back(s);\\n            else if(c.find(temp) != c.end()) res.push_back(c[temp]);\\n            else if(v.find(removeVowels(temp)) != v.end()) res.push_back(v[removeVowels(temp)]);\\n            else res.push_back(\"\");\\n        }\\n        return res;\\n    }\\n    string removeVowels(string s) {\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'o\\' || s[i] == \\'u\\' || s[i] == \\'i\\') s[i] = \\'*\\';\\n        }\\n        return s;\\n    }\\n    string tolowerAlpha(string s) {\\n        string str;\\n        for(char c: s) str += tolower(c);\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114015,
                "title": "java-solution-for-those-not-clever-enough-to-come-up-with-math-sqrt",
                "content": "I fell into the same trap as a lot of people, using polar coordinates without normalizing with square root. I figured it out when I plotted my results in excel, and saw that areas farther from the center were a lot more sparse.\\n\\nHowever, I didn\\'t come up with the clever (and probably more \"correct\") solution of normalizing with square root. Instead, I used the coveted \"spray and pray\" approach.\\n\\nThe gist of my approach is as follows:\\n\\nImagine the smallest square that completely encloses the circle (call it the \"fool\\'s square\"). Its lower left corner will be at coordinates `(x - radius, y - radius)`. If we find this lower left corner, and generate a random (x,y) coordinate pair within this square, it will have an even distribution within the circle. We can implement this approach directly **except** for the case when the random coordinate point happens to fall \"out of bounds\" (i.e. in one of the four areas between the square and circle at each of the square\\'s corners. In these cases, we just discard the value and retry until we get a valid in-bounds value.\\n\\n![image](https://assets.leetcode.com/users/images/0722ebca-47ca-439f-bf73-95c460a72276_1615991913.8184464.jpeg)\\n\\nThis is not the prettiest solution, and I am sure an interviewer would prefer to see the square root method. But for us mere mortals, this is a decent hack. Code below.\\n\\n```\\nclass Solution {\\n    double r, x, y;\\n    Random rand;\\n    public Solution(double radius, double x_center, double y_center) {\\n        this.rand = new Random();\\n        this.r = radius;\\n        this.x = x_center;\\n        this.y = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        // x0, y0 is the \"origin\"; imagine a square tangent to the circle\\n        // on the top/bottom/left/right; (x0, y0) is the coordinate of its lower left corner\\n        double x0 = x-r, y0 = y-r;\\n\\t\\t\\n        // generate a random value somewhere in the fool\\'s square\\n        double dx = 2*r*rand.nextDouble();\\n        double dy = 2*r*rand.nextDouble();\\n\\t\\t\\n        // user pythagorean theorem (a^2 + b^2 = c^2) to figure out if the point\\n        // is actually within the circle, or \"out of bounds\"\\n        double a2 = Math.pow(Math.abs(x0+dx-x), 2);\\n        double b2 = Math.pow(Math.abs(y0+dy-y), 2);\\n        double c2 = Math.pow(r, 2);\\n        if(a2+b2 <= c2) {\\n\\t    // point is in bounds; return it\\n            return new double[]{x0+dx, y0+dy};\\n        } else {\\n\\t    // point is out of bounds; retry\\n            return randPoint();   \\n        } \\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double r, x, y;\\n    Random rand;\\n    public Solution(double radius, double x_center, double y_center) {\\n        this.rand = new Random();\\n        this.r = radius;\\n        this.x = x_center;\\n        this.y = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        // x0, y0 is the \"origin\"; imagine a square tangent to the circle\\n        // on the top/bottom/left/right; (x0, y0) is the coordinate of its lower left corner\\n        double x0 = x-r, y0 = y-r;\\n\\t\\t\\n        // generate a random value somewhere in the fool\\'s square\\n        double dx = 2*r*rand.nextDouble();\\n        double dy = 2*r*rand.nextDouble();\\n\\t\\t\\n        // user pythagorean theorem (a^2 + b^2 = c^2) to figure out if the point\\n        // is actually within the circle, or \"out of bounds\"\\n        double a2 = Math.pow(Math.abs(x0+dx-x), 2);\\n        double b2 = Math.pow(Math.abs(y0+dy-y), 2);\\n        double c2 = Math.pow(r, 2);\\n        if(a2+b2 <= c2) {\\n\\t    // point is in bounds; return it\\n            return new double[]{x0+dx, y0+dy};\\n        } else {\\n\\t    // point is out of bounds; retry\\n            return randPoint();   \\n        } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113715,
                "title": "python-wrong-test-cases",
                "content": "Quick answer: No, they are fine. Check out the answer by @mallikab. I\\'ll let this post stand because of the discussion it has generated, but otherwise, both the solution presented below and the assumption of test cases being wrong is false.\\n\\n# UPD: Wrong claim, because 0.01 > 0.002:\\nThe case below is wrong, the expected output is off the circle `-73839.10208 < -73839.101` and `-3289891.30206 < -3289891.301`. This is perhaps due to precision issues with floating point numbers. If I\\'m missing something, please let me know.\\n```\\nInput: [0.01, -73839.1, -3289891.3],\\nExpected output: [-73839.10208,-3289891.30206]\\n```\\n\\n# UPD: The solution below is incorrect, see the comments to know why\\n```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.x = x_center\\n        self.y = y_center\\n        self.radius = radius\\n\\n    def randPoint(self) -> List[float]:\\n        first = random.uniform(-self.radius, self.radius)\\n        secondmax = (self.radius ** 2 - first ** 2) ** 0.5\\n        second = random.uniform(-secondmax, secondmax)\\n        return [self.x + first, self.y + second]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nInput: [0.01, -73839.1, -3289891.3],\\nExpected output: [-73839.10208,-3289891.30206]\\n```\n```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.x = x_center\\n        self.y = y_center\\n        self.radius = radius\\n\\n    def randPoint(self) -> List[float]:\\n        first = random.uniform(-self.radius, self.radius)\\n        secondmax = (self.radius ** 2 - first ** 2) ** 0.5\\n        second = random.uniform(-secondmax, secondmax)\\n        return [self.x + first, self.y + second]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682896,
                "title": "inverse-transform-sampling",
                "content": "![image](https://assets.leetcode.com/users/images/c4f05007-0296-49ea-9a51-cf536e10f565_1687774720.5733783.png)\\n\\nHere\\'s how the exponent of the random number in the `r` expression influences the point density:\\n\\n![image](https://assets.leetcode.com/users/images/63e6d98a-ca12-4125-b69c-9f38f983671b_1687777924.5217948.png)\\n\\n```\\nclass Solution \\n{\\n    double x{}, y{}, RR{};\\npublic:\\n    Solution(double r, double x, double y) : RR{r*r}, x{x}, y{y}\\n    {   \\n    }\\n    \\n    vector<double> randPoint() \\n    {\\n\\t    double phi = 2.*M_PI*((double) rand() / RAND_MAX),\\n\\t\\t\\t   r   = sqrt(RR*((double) rand() / RAND_MAX));\\n\\t    return {x+r*cos(phi), y+r*sin(phi)};\\n    }\\n};\\n```\\n||\\n```\\nclass Solution \\n{\\n    double x{}, y{}, RR{};\\npublic:\\n    Solution(double r, double x, double y) : RR{r*r}, x{x}, y{y}\\n    {   \\n    }\\n    \\n    vector<double> randPoint() \\n    {\\n        auto p = complex(x,y)+polar(sqrt(RR*((double) rand() / RAND_MAX)), 2.*M_PI*((double) rand() / RAND_MAX));\\n        return {p.real(), p.imag()};\\n    }\\n};\\n```\\nWhat if instead of two independent random numbers we would have used only one for the angle **and** the raduis?\\nThat should give us a 1-d curve instead of 2-d region, right? Here\\'s the figure (red) of what we would have obtained.\\n\\n![image](https://assets.leetcode.com/users/images/a1b77a9d-46c5-432b-ae38-ba2fe1e9797d_1687795003.0861378.png)\\n\\nIt\\'s also easy to modify the algo to get the random point inside the *disk sector*:\\n\\n![image](https://assets.leetcode.com/users/images/e7a89bf0-2d72-426b-8c0b-6a52a242a739_1687852356.3437154.png)\\n\\nor a *ring sector*:\\n\\n![image](https://assets.leetcode.com/users/images/798133ea-144f-4d43-8733-48de8afba048_1687856217.3603787.png)\\nThis is the most general form of the `phi,r` expression we used.\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    double x{}, y{}, RR{};\\npublic:\\n    Solution(double r, double x, double y) : RR{r*r}, x{x}, y{y}\\n    {   \\n    }\\n    \\n    vector<double> randPoint() \\n    {\\n\\t    double phi = 2.*M_PI*((double) rand() / RAND_MAX),\\n\\t\\t\\t   r   = sqrt(RR*((double) rand() / RAND_MAX));\\n\\t    return {x+r*cos(phi), y+r*sin(phi)};\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\n    double x{}, y{}, RR{};\\npublic:\\n    Solution(double r, double x, double y) : RR{r*r}, x{x}, y{y}\\n    {   \\n    }\\n    \\n    vector<double> randPoint() \\n    {\\n        auto p = complex(x,y)+polar(sqrt(RR*((double) rand() / RAND_MAX)), 2.*M_PI*((double) rand() / RAND_MAX));\\n        return {p.real(), p.imag()};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281220,
                "title": "478-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize the class with radius, x_center, and y_center as instance variables.\\n2. When randPoint() is called, generate a random length between 0 and radius using random.uniform(0, self.radius**2).\\n3. Generate a random angle in radians between 0 and 2*pi using random.uniform(0, 1) * 2 * math.pi.\\n4. Compute the x and y coordinates of the random point using the formulas:\\nx = x_center + length * cos(angle)\\ny = y_center + length * sin(angle)\\n5. Return the coordinates as a list [x, y].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def __init__(self, radius: float, x_center: float, y_center: float):\\n    self.radius = radius\\n    self.x_center = x_center\\n    self.y_center = y_center\\n\\n  def randPoint(self) -> List[float]:\\n    length = math.sqrt(random.uniform(0, self.radius**2))\\n    degree = random.uniform(0, 1) * 2 * math.pi\\n    x = self.x_center + length * math.cos(degree)\\n    y = self.y_center + length * math.sin(degree)\\n    return [x, y]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Geometry",
                    "Rejection Sampling"
                ],
                "code": "```\\nclass Solution:\\n  def __init__(self, radius: float, x_center: float, y_center: float):\\n    self.radius = radius\\n    self.x_center = x_center\\n    self.y_center = y_center\\n\\n  def randPoint(self) -> List[float]:\\n    length = math.sqrt(random.uniform(0, self.radius**2))\\n    degree = random.uniform(0, 1) * 2 * math.pi\\n    x = self.x_center + length * math.cos(degree)\\n    y = self.y_center + length * math.sin(degree)\\n    return [x, y]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645750,
                "title": "python3-solution",
                "content": "\\tclass Solution:\\n\\n\\t\\tdef __init__(self, radius: float, x_center: float, y_center: float):\\n\\t\\t\\tself.r = radius\\n\\t\\t\\tself.x, self.y = x_center, y_center\\n        \\n\\n\\t\\tdef randPoint(self) -> List[float]:\\n\\t\\t\\ttheta = uniform(0,2*pi)\\n\\t\\t\\tR = sqrt(uniform(0,self.r**2))\\n\\t\\t\\treturn [self.x+R*cos(theta), self.y+R*sin(theta)]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\n\\t\\tdef __init__(self, radius: float, x_center: float, y_center: float):\\n\\t\\t\\tself.r = radius\\n\\t\\t\\tself.x, self.y = x_center, y_center\\n        \\n\\n\\t\\tdef randPoint(self) -> List[float]:\\n\\t\\t\\ttheta = uniform(0,2*pi)\\n\\t\\t\\tR = sqrt(uniform(0,self.r**2))\\n\\t\\t\\treturn [self.x+R*cos(theta), self.y+R*sin(theta)]",
                "codeTag": "Java"
            },
            {
                "id": 1921960,
                "title": "python-easy-understanding-solution-with-detailed-explanation",
                "content": "The idea is  finding random angle and random radius, combining them together to get a random point on 2D circle.\\nAt first, I really stuck for a long time with this code:\\n```\\nr = random.random() * self.r  # Get wrong answer with test 7. Because it won\\'t distribute evenly on circle.\\n```\\nAnd yeh, finally I found it easier to  understand by taking probability into consideration.\\nConsidering two circle:\\nA: with radius 1\\nB: with radius 0.5\\n\\nThe chance for randomly flying darts to hit target for A : B is 4 : 1 right?\\nSo with the random.random() function, we know that the chance for getting number in range(0, 1) is 4 times the chance getting number in range(0, 0.25). \\n\\nHere\\'s the table: Radius vs. the range of random.random() and the chance to hit :\\n```\\nRadius        range         chance\\n1            [0, 1]          100%\\n0.75         [0, 0.5625]      56%\\n0.5          [0, 0.25]        25%\\n0.25         [0, 0.0625]       6%\\n```\\nBy induction, we see that if we get random number by taking advantage of random.random(), the random number shoud be modified by sqrt() to conform to radius.\\n\\n\\n```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.x = x_center\\n        self.y = y_center\\n        self.r = radius\\n\\n    def randPoint(self) -> List[float]:\\n        r = sqrt(random.random()) * self.r\\n        angle = random.uniform(0, 2*pi)\\n        return [self.x + r * math.cos(angle), self.y + r *math.sin(angle)]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Probability and Statistics"
                ],
                "code": "```\\nr = random.random() * self.r  # Get wrong answer with test 7. Because it won\\'t distribute evenly on circle.\\n```\n```\\nRadius        range         chance\\n1            [0, 1]          100%\\n0.75         [0, 0.5625]      56%\\n0.5          [0, 0.25]        25%\\n0.25         [0, 0.0625]       6%\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1662634,
                "title": "c-simple-solution-with-rand",
                "content": "````\\nclass Solution {\\npublic:\\n    double x;\\n    double y;\\n    double r;\\n    Solution(double radius, double x_center, double y_center) {\\n        x = x_center;\\n        y = y_center;\\n        r = radius;\\n    }\\n    vector<double> randPoint() {\\n        double rad = (double)rand() / RAND_MAX;\\n        rad = sqrt(rad) * r; //KEY POINT: IF WE DO NOT TAKE THE SQUARE ROOT, WE WILL HAVE MANY POINTS CLOSE TO THE CENTRE THAN FAR AWAY.\\n        double teta = (double)rand() / RAND_MAX;\\n        teta *= 360.0;\\n        return {x+rad*cos(teta),y+rad*sin(teta)}; //x = rcos\\u03B8, y = rsin\\u03B8\\n    }\\n};\\n",
                "solutionTags": [
                    "Probability and Statistics"
                ],
                "code": "class Solution {\\npublic:\\n    double x;\\n    double y;\\n    double r;\\n    Solution(double radius, double x_center, double y_center) {\\n        x = x_center;\\n        y = y_center;\\n        r = radius;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1623746,
                "title": "java-bounding-box-solution",
                "content": "if you like my solution please upvote, thanks! \\nThe idea is to generate a random point within the circle\\'s bounding box/square. If the generated point falls out of the circle retry.\\n```\\nclass Solution {\\n    private double x, y, r;\\n    private ThreadLocalRandom rand;\\n    \\n    public Solution(double radius, double x_center, double y_center) {\\n        x = x_center;\\n        y = y_center;\\n        r = radius;\\n        rand = ThreadLocalRandom.current();\\n    }\\n    \\n    public double[] randPoint() {\\n        double minx = x - r;\\n        double maxx = x + r;\\n        double miny = y - r;\\n        double maxy = y + r;\\n        do {\\n            double xx = rand.nextDouble(minx, maxx);\\n            double yy = rand.nextDouble(miny, maxy);\\n            if (inCircle(xx, yy)) {\\n                return new double[]{xx, yy};\\n            }\\n        } while(true);\\n    }\\n    \\n    boolean inCircle(double xx, double yy) {\\n        xx -= x;\\n        yy -= y;\\n        xx = xx * xx;\\n        yy = yy * yy;\\n        return xx + yy <= r * r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private double x, y, r;\\n    private ThreadLocalRandom rand;\\n    \\n    public Solution(double radius, double x_center, double y_center) {\\n        x = x_center;\\n        y = y_center;\\n        r = radius;\\n        rand = ThreadLocalRandom.current();\\n    }\\n    \\n    public double[] randPoint() {\\n        double minx = x - r;\\n        double maxx = x + r;\\n        double miny = y - r;\\n        double maxy = y + r;\\n        do {\\n            double xx = rand.nextDouble(minx, maxx);\\n            double yy = rand.nextDouble(miny, maxy);\\n            if (inCircle(xx, yy)) {\\n                return new double[]{xx, yy};\\n            }\\n        } while(true);\\n    }\\n    \\n    boolean inCircle(double xx, double yy) {\\n        xx -= x;\\n        yy -= y;\\n        xx = xx * xx;\\n        yy = yy * yy;\\n        return xx + yy <= r * r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148167,
                "title": "beats-100-simple-polar-coords-python",
                "content": "```\\nclass Solution:\\n    r=0\\n    x=0\\n    y=0\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.r=radius\\n        self.x=x_center\\n        self.y=y_center\\n\\n    def randPoint(self) -> List[float]:\\n        theta = random.uniform(0,2*pi)\\n        R = self.r*sqrt(random.uniform(0,1))\\n        return [self.x + R*cos(theta), self.y + R*sin(theta)]\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    r=0\\n    x=0\\n    y=0\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.r=radius\\n        self.x=x_center\\n        self.y=y_center\\n\\n    def randPoint(self) -> List[float]:\\n        theta = random.uniform(0,2*pi)\\n        R = self.r*sqrt(random.uniform(0,1))\\n        return [self.x + R*cos(theta), self.y + R*sin(theta)]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120255,
                "title": "reordered-power-of-2-beats-100-c",
                "content": "The steps for solution to this problem are :\\n* Store all the powers of 2 in a vector\\n* Compare each numbner in vector with the given number to check if both have same digits .\\n* If both have same digits , return true\\n* else return false .\\nPls upvote if u feel it is correct and suggest if it can be improved .\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int comp(int a,int b)\\n    {\\n        bool A[10]={0},B[10]={0};\\n        int lena=0,lenb=0;\\n        while(a>0 || b>0)\\n        {\\n            if(a>0)\\n            {\\n                A[a%10]=1;\\n                a/=10;\\n                lena++;\\n            }\\n            if(b>0)\\n            {\\n                B[b%10]=1;\\n                b/=10;\\n                lenb++;\\n            }\\n        }\\n        \\n        if(lena!=lenb)\\n            return false;\\n        \\n        for(int i=0 ;i<10 ;i++)\\n            if(A[i]!=B[i])\\n                return false;\\n        return true;\\n    }\\n    \\n    bool reorderedPowerOf2(int N) {\\n        int k=1;\\n        vector<int> v;\\n        for(int i=0 ;i<30 ;i++)\\n        {\\n            v.push_back(k);\\n            k*=2;\\n        }\\n        \\n        for(int i=0 ;i<=30 ;i++)\\n        {\\n            if(comp(N,v[i]))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int comp(int a,int b)\\n    {\\n        bool A[10]={0},B[10]={0};\\n        int lena=0,lenb=0;\\n        while(a>0 || b>0)\\n        {\\n            if(a>0)\\n            {\\n                A[a%10]=1;\\n                a/=10;\\n                lena++;\\n            }\\n            if(b>0)\\n            {\\n                B[b%10]=1;\\n                b/=10;\\n                lenb++;\\n            }\\n        }\\n        \\n        if(lena!=lenb)\\n            return false;\\n        \\n        for(int i=0 ;i<10 ;i++)\\n            if(A[i]!=B[i])\\n                return false;\\n        return true;\\n    }\\n    \\n    bool reorderedPowerOf2(int N) {\\n        int k=1;\\n        vector<int> v;\\n        for(int i=0 ;i<30 ;i++)\\n        {\\n            v.push_back(k);\\n            k*=2;\\n        }\\n        \\n        for(int i=0 ;i<=30 ;i++)\\n        {\\n            if(comp(N,v[i]))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114296,
                "title": "simple-python3-using-math-and-random-90-faster",
                "content": "```\\nimport math\\nimport random\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n      self.rad = radius\\n      self.x = x_center\\n      self.y = y_center\\n        \\n\\n    def randPoint(self) -> List[float]:\\n        r = self.rad * math.sqrt(random.random())\\n        theta = random.random() * 2 * math.pi\\n        x_point = self.x + r * cos(theta)\\n        y_point = self.y + r * sin(theta)\\n        return [x_point, y_point]\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nimport random\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n      self.rad = radius\\n      self.x = x_center\\n      self.y = y_center\\n        \\n\\n    def randPoint(self) -> List[float]:\\n        r = self.rad * math.sqrt(random.random())\\n        theta = random.random() * 2 * math.pi\\n        x_point = self.x + r * cos(theta)\\n        y_point = self.y + r * sin(theta)\\n        return [x_point, y_point]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113681,
                "title": "generate-random-point-in-a-circle-c-solution-simple-code-with-explanation",
                "content": "Basically to find a random point  on a circle we need two components, an angle(theta) and distance(D) from the center. After that Now, the point (xi, yi) can be expressed as:\\n```\\nx = X + D * cos(theta)\\ny = Y + D * sin(theta)\\n```\\nwhen we try to generate the random distance from origin distribution will have more density around the origin and less as the distance from the origin increases, so for uniform distribution, we need to  use `sqrt(random())`. Go through the code for better understanding.\\n\\n```\\n#define PI 3.141592653589\\nclass Solution {\\npublic:\\n    double random(){\\n        return (double)rand() / RAND_MAX;\\n    }\\n    double x,y,r;\\n    Solution(double radius, double x_center, double y_center) {\\n        x = x_center; y = y_center; r = radius;\\n    }\\n    vector<double> randPoint() {\\n       double theta = 2 * PI * random();\\n       double d = sqrt(random())*r;\\n       return { x + d * cos(theta),y + d * sin(theta) };\\n    }\\n};\\n```\\nRefer this article https://meyavuz.wordpress.com/2018/11/15/generate-uniform-random-points-within-a-circle/\\n**Please Upvote** if you like the code.",
                "solutionTags": [],
                "code": "```\\nx = X + D * cos(theta)\\ny = Y + D * sin(theta)\\n```\n```\\n#define PI 3.141592653589\\nclass Solution {\\npublic:\\n    double random(){\\n        return (double)rand() / RAND_MAX;\\n    }\\n    double x,y,r;\\n    Solution(double radius, double x_center, double y_center) {\\n        x = x_center; y = y_center; r = radius;\\n    }\\n    vector<double> randPoint() {\\n       double theta = 2 * PI * random();\\n       double d = sqrt(random())*r;\\n       return { x + d * cos(theta),y + d * sin(theta) };\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110515,
                "title": "encode-and-decode-tinyurl-c-easy-solution-simple-code-with-explanation",
                "content": "The idea is for every` LongUrl` we generate a six random alphanumeric charecters and add to our `shortUrl`, we store it in a `unordered_map` and while decoding we can direcly return the `longUrl` \\n\\n```\\nclass Solution {\\npublic:\\n    vector<char> alphanum= {\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\',\\n                            \\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\n                            \\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\n                            \\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\',\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\n                            \\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\n                            \\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\'};\\n    \\n    unordered_map<string, string> code_Url;\\n    string encode(string longUrl) {\\n        string shortUrl=\"http://tinyurl.com/\";\\n        int t=alphanum.size();\\n        for(int i = 0; i <6; i++) {\\n            int idx=rand()%t;\\n            shortUrl+= alphanum[idx];\\n        }\\n        code_Url[shortUrl] = longUrl;\\n        return shortUrl;\\n    }\\n    string decode(string shortUrl) {\\n        return code_Url[shortUrl];\\n    }\\n};\\n\\n```\\n\\nThis question seems to be not correctly framed by the problem setter, some stupid solutions are also got accepted!!!\\n\\n```\\nclass Solution {\\npublic:\\n    string encode(string longUrl) {\\n       return longUrl;\\n    }\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```\\n\\n**Please Upvote** if you like the code.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<char> alphanum= {\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\',\\n                            \\'A\\',\\'B\\',\\'C\\',\\'D\\',\\'E\\',\\'F\\',\\'G\\',\\'H\\',\\'I\\',\\'J\\',\\n                            \\'K\\',\\'L\\',\\'M\\',\\'N\\',\\'O\\',\\'P\\',\\'Q\\',\\'R\\',\\'S\\',\\'T\\',\\n                            \\'U\\',\\'V\\',\\'W\\',\\'X\\',\\'Y\\',\\'Z\\',\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\n                            \\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\n                            \\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\'};\\n    \\n    unordered_map<string, string> code_Url;\\n    string encode(string longUrl) {\\n        string shortUrl=\"http://tinyurl.com/\";\\n        int t=alphanum.size();\\n        for(int i = 0; i <6; i++) {\\n            int idx=rand()%t;\\n            shortUrl+= alphanum[idx];\\n        }\\n        code_Url[shortUrl] = longUrl;\\n        return shortUrl;\\n    }\\n    string decode(string shortUrl) {\\n        return code_Url[shortUrl];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string encode(string longUrl) {\\n       return longUrl;\\n    }\\n    string decode(string shortUrl) {\\n        return shortUrl;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493834,
                "title": "correct-solution-rejected-why",
                "content": "I have this solution that fails on the large test case which calls randPoint() thousands of times. I plotted my output for that testcase in matplotlib and the resulting shape is identical to the plot of the expected output. Can somebody tell me why the solution gets rejected?\\n```\\n     def randPoint(self):\\n        \"\"\"\\n        :rtype: List[float]\\n        \"\"\"\\n        import random, math\\n        theta = random.uniform(0, 2*math.pi)\\n        r = random.uniform(0, self.radius)\\n        x1 = r * math.cos(theta) + self.x\\n        y1 = r * math.sin(theta) + self.y\\n        assert (self.x - x1) ** 2 + (self.y - y1) ** 2 < self.radius ** 2\\n        return [x1, y1]```",
                "solutionTags": [],
                "code": "```\\n     def randPoint(self):\\n        \"\"\"\\n        :rtype: List[float]\\n        \"\"\"\\n        import random, math\\n        theta = random.uniform(0, 2*math.pi)\\n        r = random.uniform(0, self.radius)\\n        x1 = r * math.cos(theta) + self.x\\n        y1 = r * math.sin(theta) + self.y\\n        assert (self.x - x1) ** 2 + (self.y - y1) ** 2 < self.radius ** 2\\n        return [x1, y1]```",
                "codeTag": "Python3"
            },
            {
                "id": 154734,
                "title": "short-java-solution",
                "content": "```\\n    double r , x , y;\\n    public Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double len = Math.sqrt(Math.random()) * r;\\n        double deg = Math.random() * 2 * Math.PI;\\n        return new double[]{len * Math.cos(deg) + x, len * Math.sin(deg) + y};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    double r , x , y;\\n    public Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double len = Math.sqrt(Math.random()) * r;\\n        double deg = Math.random() * 2 * Math.PI;\\n        return new double[]{len * Math.cos(deg) + x, len * Math.sin(deg) + y};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3046024,
                "title": "python-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to randomly generate points within a circle of radius radius and center point (x_center, y_center).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to use the built-in random.uniform(a, b) function which generates a random float number between a and b. We use this function to generate x and y coordinates for the point. We then check if the point is within the circle by checking if the point\\'s distance from the center of the circle is less than or equal to the radius. If it is, we return the point. If not, we continue generating new points until we find one that is within the circle.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n        self.x = x_center\\n        self.y = y_center\\n        self.r = radius\\n\\n    def randPoint(self) -> List[float]:\\n        while True:\\n            x = random.uniform(self.x - self.r, self.x + self.r)\\n            y = random.uniform(self.y - self.r, self.y + self.r)\\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\\n                return [x, y]\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(radius, x_center, y_center)\\n# param_1 = obj.randPoint()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n        self.x = x_center\\n        self.y = y_center\\n        self.r = radius\\n\\n    def randPoint(self) -> List[float]:\\n        while True:\\n            x = random.uniform(self.x - self.r, self.x + self.r)\\n            y = random.uniform(self.y - self.r, self.y + self.r)\\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\\n                return [x, y]\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(radius, x_center, y_center)\\n# param_1 = obj.randPoint()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826143,
                "title": "python3-random-uniform-simple",
                "content": "```\\nimport random\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.r=radius\\n        self.center=(x_center,y_center)\\n\\n    def randPoint(self) -> List[float]:\\n        x,y=self.center\\n        while True:\\n            x1=random.uniform(x-self.r,x+self.r)\\n            y1=random.uniform(y-self.r,y+self.r)\\n            dist=(x-x1)**2+(y-y1)**2\\n            if dist<=self.r**2: return [x1,y1]\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.r=radius\\n        self.center=(x_center,y_center)\\n\\n    def randPoint(self) -> List[float]:\\n        x,y=self.center\\n        while True:\\n            x1=random.uniform(x-self.r,x+self.r)\\n            y1=random.uniform(y-self.r,y+self.r)\\n            dist=(x-x1)**2+(y-y1)**2\\n            if dist<=self.r**2: return [x1,y1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128430,
                "title": "c-solution-for-word-subsets-map-with-explanation",
                "content": "Dear All,\\n\\nI\\'m happy to share with you my solution for Word Subset topic.\\nCode contains comments for your better understanding of algorithm.\\n```\\nclass Solution {\\npublic:\\n    vector<string> wordSubsets(vector<string>& A, vector<string>& B) \\n    {\\n        vector<string> result;\\n        // Hash Table that stores characters and how many times it should exist in the words from A\\n        map<char, int> charToCheckB;\\n        map<char, int> temp;\\n        // Hash Table that stores characters and how many times it exists in the word from A\\n        map<char, int> charToCheckA;\\n        \\n        // Loop by each element from B\\n        for(int i = 0; i < B.size(); ++i)\\n        {\\n            // Loop by each character and count number of characters to temp\\n            for(int j = 0; j < B[i].length(); ++j)\\n            {\\n                // Count current characters\\n                temp[B[i][j]]++;\\n                \\n                // Put to Hash Table bigger number between previous and current counted\\n                if (temp[B[i][j]] > charToCheckB[B[i][j]]) charToCheckB[B[i][j]] = temp[B[i][j]];\\n            }\\n            // Clear temp HashTable for next step\\n            temp.clear();\\n        }\\n        \\n        // Loop by each element from A\\n        for(int i = 0; i < A.size(); ++i)\\n        {\\n            // Loop by each character and count number of characters\\n            for(int j = 0; j < A[i].length(); ++j)\\n            {\\n                charToCheckA[A[i][j]]++;\\n            }\\n            \\n            // Loop by charToCheckB and check numbers. If numbers more than in the word - switch flag\\n            bool isExist = true;\\n            for(auto it = charToCheckB.begin(); it != charToCheckB.end(); ++it )\\n            {\\n                // If number of characters from HT B > num. of char. of word - char. doesn\\'t exist in the word\\n                if ( it->second > charToCheckA[it->first] )\\n                {\\n                    isExist = false;\\n                    break;\\n                }\\n            }\\n            \\n            // Only when all character from B was found in A - add word to result\\n            if(isExist == true)\\n            {\\n                result.push_back(A[i]);\\n            }\\n            // Clear HashTable for words for next step\\n            charToCheckA.clear();\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\nIf you know how to improve the code - please let me know I will be very grateful.\\nIf you like solution please upvote - I will be pleased.\\n\\nThanks and have a good day.\\n\\nBest Regards, Yevhen.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordSubsets(vector<string>& A, vector<string>& B) \\n    {\\n        vector<string> result;\\n        // Hash Table that stores characters and how many times it should exist in the words from A\\n        map<char, int> charToCheckB;\\n        map<char, int> temp;\\n        // Hash Table that stores characters and how many times it exists in the word from A\\n        map<char, int> charToCheckA;\\n        \\n        // Loop by each element from B\\n        for(int i = 0; i < B.size(); ++i)\\n        {\\n            // Loop by each character and count number of characters to temp\\n            for(int j = 0; j < B[i].length(); ++j)\\n            {\\n                // Count current characters\\n                temp[B[i][j]]++;\\n                \\n                // Put to Hash Table bigger number between previous and current counted\\n                if (temp[B[i][j]] > charToCheckB[B[i][j]]) charToCheckB[B[i][j]] = temp[B[i][j]];\\n            }\\n            // Clear temp HashTable for next step\\n            temp.clear();\\n        }\\n        \\n        // Loop by each element from A\\n        for(int i = 0; i < A.size(); ++i)\\n        {\\n            // Loop by each character and count number of characters\\n            for(int j = 0; j < A[i].length(); ++j)\\n            {\\n                charToCheckA[A[i][j]]++;\\n            }\\n            \\n            // Loop by charToCheckB and check numbers. If numbers more than in the word - switch flag\\n            bool isExist = true;\\n            for(auto it = charToCheckB.begin(); it != charToCheckB.end(); ++it )\\n            {\\n                // If number of characters from HT B > num. of char. of word - char. doesn\\'t exist in the word\\n                if ( it->second > charToCheckA[it->first] )\\n                {\\n                    isExist = false;\\n                    break;\\n                }\\n            }\\n            \\n            // Only when all character from B was found in A - add word to result\\n            if(isExist == true)\\n            {\\n                result.push_back(A[i]);\\n            }\\n            // Clear HashTable for words for next step\\n            charToCheckA.clear();\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114839,
                "title": "c-simple-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double r, x, y;\\n    Solution(double radius, double x_center, double y_center) {\\n        this->r = radius;\\n        this->x = x_center;\\n        this->y = y_center;\\n        srand(time(NULL));\\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomX = getRandomNumber(this->x, this->r);\\n        double randomY = getRandomNumber(this->y, this->r);\\n        while(isPointOutSide(randomX, randomY)) {\\n            randomX = getRandomNumber(this->x, this->r);\\n            randomY = getRandomNumber(this->y, this->r);\\n        }\\n        return {randomX, randomY};\\n    }\\n    \\n    bool isPointOutSide(double randomX, double randomY) {\\n        return pow((this->x - randomX), 2) + pow((this->y - randomY), 2) >= r*r;\\n    }\\n    \\n    double getRandomNumber(double a, double r) {\\n        double random = -1 + ((double) rand() / (RAND_MAX))*2;\\n        return a + random*r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double r, x, y;\\n    Solution(double radius, double x_center, double y_center) {\\n        this->r = radius;\\n        this->x = x_center;\\n        this->y = y_center;\\n        srand(time(NULL));\\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomX = getRandomNumber(this->x, this->r);\\n        double randomY = getRandomNumber(this->y, this->r);\\n        while(isPointOutSide(randomX, randomY)) {\\n            randomX = getRandomNumber(this->x, this->r);\\n            randomY = getRandomNumber(this->y, this->r);\\n        }\\n        return {randomX, randomY};\\n    }\\n    \\n    bool isPointOutSide(double randomX, double randomY) {\\n        return pow((this->x - randomX), 2) + pow((this->y - randomY), 2) >= r*r;\\n    }\\n    \\n    double getRandomNumber(double a, double r) {\\n        double random = -1 + ((double) rand() / (RAND_MAX))*2;\\n        return a + random*r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114671,
                "title": "java-simple-and-easy-solution-clean-code-with-comments",
                "content": "```\\nclass Solution {\\n    double xMin;\\n    double xMax;\\n    double yMin;\\n    double yMax;\\n    \\n    double radius;\\n    double x_center;\\n    double y_center;\\n    \\n    public Solution(double radius, double x_center, double y_center) {\\n        xMin = x_center - radius;\\n        xMax = x_center + radius;\\n        \\n        yMin = y_center - radius;\\n        yMax = y_center + radius;\\n        \\n        \\n        this.radius = radius;\\n        this.x_center = x_center;\\n        this.y_center = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        \\n        while(true){\\n            double x = randomNumber(xMin, xMax);\\n            double y = randomNumber(yMin, yMax);\\n            //just to make, coordinate is inside or on circumference of circle \\n            if(Math.sqrt(Math.pow(x - x_center, 2) + Math.pow(y - y_center, 2))  <= radius){\\n                return new double[]{x, y};\\n            }   \\n            \\n        }\\n        \\n\\n    }\\n    \\n    private double randomNumber(double min, double max){\\n        double random = min + Math.random() * (max - min);\\n        return random;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double xMin;\\n    double xMax;\\n    double yMin;\\n    double yMax;\\n    \\n    double radius;\\n    double x_center;\\n    double y_center;\\n    \\n    public Solution(double radius, double x_center, double y_center) {\\n        xMin = x_center - radius;\\n        xMax = x_center + radius;\\n        \\n        yMin = y_center - radius;\\n        yMax = y_center + radius;\\n        \\n        \\n        this.radius = radius;\\n        this.x_center = x_center;\\n        this.y_center = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        \\n        while(true){\\n            double x = randomNumber(xMin, xMax);\\n            double y = randomNumber(yMin, yMax);\\n            //just to make, coordinate is inside or on circumference of circle \\n            if(Math.sqrt(Math.pow(x - x_center, 2) + Math.pow(y - y_center, 2))  <= radius){\\n                return new double[]{x, y};\\n            }   \\n            \\n        }\\n        \\n\\n    }\\n    \\n    private double randomNumber(double min, double max){\\n        double random = min + Math.random() * (max - min);\\n        return random;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114480,
                "title": "100-faster-100-efficient-explained-soln",
                "content": "![image](https://assets.leetcode.com/users/images/66459342-3acd-45cd-b3ea-aff15cde8cb3_1616016147.0713804.png)\\n```\\npublic class Solution {\\n    private readonly double r, x, y;\\n    private readonly Random rand;\\n    public Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n        rand = new Random();\\n    }\\n    \\n    public double[] RandPoint() {\\n        double a=0,b=0;\\n        do\\n        {\\n            a = GetRandom(x,r);\\n            b = GetRandom(y,r);\\n        }while(!IsValidCorrdinate(a,b));\\n        \\n        return new double[] {a,b};\\n    }\\n    // lowest valid X-cordinate would be (x - radius) & max valid X-cordinate would be (x + radius)\\n    // lowest valid Y-cordinate would be (Y - radius) & max valid Y-cordinate would be (Y + radius)\\n    // Hence we can conclude that => Random Point can be calculated as lowest possible corrdinate + (random length b/w 0 to twice of radius)\\n    double GetRandom(double a, double b) => a-b + rand.NextDouble() * 2*b;\\n    \\n    // Pythagoras theorem a^2 + b^2 < c^2\\n    bool IsValidCorrdinate(double a,double b) => ((a-x)*(a-x) + (b-y)*(b-y)) <= r*r;\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(radius, x_center, y_center);\\n * double[] param_1 = obj.RandPoint();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private readonly double r, x, y;\\n    private readonly Random rand;\\n    public Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n        rand = new Random();\\n    }\\n    \\n    public double[] RandPoint() {\\n        double a=0,b=0;\\n        do\\n        {\\n            a = GetRandom(x,r);\\n            b = GetRandom(y,r);\\n        }while(!IsValidCorrdinate(a,b));\\n        \\n        return new double[] {a,b};\\n    }\\n    // lowest valid X-cordinate would be (x - radius) & max valid X-cordinate would be (x + radius)\\n    // lowest valid Y-cordinate would be (Y - radius) & max valid Y-cordinate would be (Y + radius)\\n    // Hence we can conclude that => Random Point can be calculated as lowest possible corrdinate + (random length b/w 0 to twice of radius)\\n    double GetRandom(double a, double b) => a-b + rand.NextDouble() * 2*b;\\n    \\n    // Pythagoras theorem a^2 + b^2 < c^2\\n    bool IsValidCorrdinate(double a,double b) => ((a-x)*(a-x) + (b-y)*(b-y)) <= r*r;\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(radius, x_center, y_center);\\n * double[] param_1 = obj.RandPoint();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113878,
                "title": "rand-point-in-circle-python-no-trigonometry-fast",
                "content": "We pick a point in a square bounding the circle, if it\\'s not in the circle, redraw a point.\\n```\\nfrom random import random\\n\\nclass Solution:\\n    def __init__(self, radius, x_center, y_center):\\n        self.r = radius\\n        self.x = x_center\\n        self.y = y_center\\n\\n    def randPoint(self):\\n        x = 2 * self.r * random() - self.r\\n        y = 2 * self.r * random() - self.r\\n        if x**2 + y**2 <= self.r**2:\\n            return [self.x + x, self.y + y]\\n        return self.randPoint()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom random import random\\n\\nclass Solution:\\n    def __init__(self, radius, x_center, y_center):\\n        self.r = radius\\n        self.x = x_center\\n        self.y = y_center\\n\\n    def randPoint(self):\\n        x = 2 * self.r * random() - self.r\\n        y = 2 * self.r * random() - self.r\\n        if x**2 + y**2 <= self.r**2:\\n            return [self.x + x, self.y + y]\\n        return self.randPoint()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113731,
                "title": "simple-swift-solution",
                "content": "```\\nclass Solution {\\n\\n    var radius: Double\\n    var x: Double\\n    var y: Double\\n    init(_ radius: Double, _ x_center: Double, _ y_center: Double) {\\n        self.radius = radius\\n        self.x = x_center\\n        self.y = y_center\\n    }\\n    \\n    func randPoint() -> [Double] {\\n        let r = radius * sqrt(Double.random(in: 0...1))\\n        let c = Double.random(in: 0..<2*Double.pi)\\n        return [x + r * cos(c), y + r * sin(c)]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n\\n    var radius: Double\\n    var x: Double\\n    var y: Double\\n    init(_ radius: Double, _ x_center: Double, _ y_center: Double) {\\n        self.radius = radius\\n        self.x = x_center\\n        self.y = y_center\\n    }\\n    \\n    func randPoint() -> [Double] {\\n        let r = radius * sqrt(Double.random(in: 0...1))\\n        let c = Double.random(in: 0..<2*Double.pi)\\n        return [x + r * cos(c), y + r * sin(c)]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113730,
                "title": "simple-solution-in-java-by-using-a-random-number-generator-formula-explained",
                "content": "Points -\\n* To generate a point within a circle, we will have to be in bounds of the circle in both the X and Y axes.\\nThe diameter ends for X axis will be -> `(x_center - r, x_center + r)` and for Y axis will be -> `(y_center - r, y_center + r)`.\\n* To generate a point in this range, we can utilise the `Math.random()` function which generates within (0, 1). If we multiply this with the diameter width, we will stay in range but on a scale of (0, 1). To come to a scale of `(x_min = x_center - r, x_max = x_center + r)`, we can add `x_min` to the product. Same for the Y axis. \\n* Now we have a number in that range but what if it is lying outside the circle in the grey area where we can draw a square using the dimensions? We need to check that, to do so just use euclidian distance between generated point and the center of circle and verify that it is within the distance of the radius. \\n\\nJava code - \\n\\n\\n```\\nclass Solution {\\n    double r;\\n    double x;\\n    double y;\\n    public Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double[] ans = new double[2];\\n        double x_min = x - r;\\n        double x_max = x + r;\\n        double y_min = y - r;\\n        double y_max = y + r;\\n        \\n        ans[0] = x_min + Math.random() * (x_max - x_min);\\n        ans[1] = y_min + Math.random() * (y_max - y_min);\\n        \\n        \\n        while((ans[0] - x) * (ans[0] - x) + (ans[1] - y) * (ans[1] - y) > r * r){\\n            ans[0] = x_min + Math.random() * (x_max - x_min);\\n            ans[1] = y_min + Math.random() * (y_max - y_min);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    double r;\\n    double x;\\n    double y;\\n    public Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double[] ans = new double[2];\\n        double x_min = x - r;\\n        double x_max = x + r;\\n        double y_min = y - r;\\n        double y_max = y + r;\\n        \\n        ans[0] = x_min + Math.random() * (x_max - x_min);\\n        ans[1] = y_min + Math.random() * (y_max - y_min);\\n        \\n        \\n        while((ans[0] - x) * (ans[0] - x) + (ans[1] - y) * (ans[1] - y) > r * r){\\n            ans[0] = x_min + Math.random() * (x_max - x_min);\\n            ans[1] = y_min + Math.random() * (y_max - y_min);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113709,
                "title": "rust-solution",
                "content": "```rust\\nuse rand::{rngs::ThreadRng, Rng};\\n\\n#[derive(Default)]\\nstruct Solution {\\n    radius: f64,\\n    x_center: f64,\\n    y_center: f64,\\n    rng: ThreadRng,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Solution {\\n\\n    fn new(radius: f64, x_center: f64, y_center: f64) -> Self {\\n        Self {\\n            radius,\\n            x_center,\\n            y_center,\\n            ..Self::default()\\n        }\\n    }\\n    \\n    fn rand_point(&mut self) -> Vec<f64> {\\n        let r = self.rng.gen::<f64>().sqrt() * self.radius;\\n        let theta = self.rng.gen::<f64>() * 2.0 * std::f64::consts::PI;\\n        [\\n            self.x_center + r * theta.cos(),\\n            self.y_center + r * theta.sin(),\\n        ]\\n        .to_vec()\\n    }\\n}\\n ```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse rand::{rngs::ThreadRng, Rng};\\n\\n#[derive(Default)]\\nstruct Solution {\\n    radius: f64,\\n    x_center: f64,\\n    y_center: f64,\\n    rng: ThreadRng,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Solution {\\n\\n    fn new(radius: f64, x_center: f64, y_center: f64) -> Self {\\n        Self {\\n            radius,\\n            x_center,\\n            y_center,\\n            ..Self::default()\\n        }\\n    }\\n    \\n    fn rand_point(&mut self) -> Vec<f64> {\\n        let r = self.rng.gen::<f64>().sqrt() * self.radius;\\n        let theta = self.rng.gen::<f64>() * 2.0 * std::f64::consts::PI;\\n        [\\n            self.x_center + r * theta.cos(),\\n            self.y_center + r * theta.sin(),\\n        ]\\n        .to_vec()\\n    }\\n}\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113640,
                "title": "python-go-sol-by-math-w-comment",
                "content": "Python sol by math\\n\\n---\\n\\nReview of circle and polar coordination system\\n\\n![image](https://assets.leetcode.com/users/images/2e5e720f-9cd6-4528-a3c2-061361a3ae04_1615973169.1428962.png)\\n\\n[Source: Math24](https://www.math24.net/definition-graphs-trigonometric-functions)\\n\\n\\n---\\n\\nPython:\\n\\n```\\nfrom random import random, seed\\nfrom math import pi, cos, sin, sqrt\\n\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        \\n        self._x_center = x_center\\n        self._y_center = y_center\\n        self._r = radius\\n        \\n        # Initialize random seed with system time\\n        seed()\\n\\n    def randPoint(self) -> List[float]:\\n        \\n        # random theta from 0 to 2*pi\\n        rand_theta = random() * 2 * pi\\n        \\n        # random radius from 0 to R\\n        rand_radius = sqrt( random() ) * self._r\\n        \\n        # compute random point based on polar coordination\\n        rand_x_coord = rand_radius * cos(rand_theta) + self._x_center\\n        rand_y_coord = rand_radius * sin(rand_theta) + self._y_center\\n        \\n        return [rand_x_coord, rand_y_coord]\\n    \\n    \\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(radius, x_center, y_center)\\n# param_1 = obj.randPoint()\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nimport (\\n    \"math/rand\"\\n    \"math\"\\n\\t\"time\"\\n)\\n\\ntype Solution struct {\\n    X_Center float64\\n    Y_Center float64\\n    Radius float64\\n}\\n\\n\\nfunc Constructor(radius float64, x_center float64, y_center float64) Solution {\\n    \\n    // Initialize random seed with system time\\n    rand.Seed( time.Now().UnixNano() )\\n    \\n    return Solution{ Radius: radius, X_Center: x_center, Y_Center: y_center }\\n}\\n\\n\\nfunc (this *Solution) RandPoint() []float64 {\\n    \\n    // random theta from 0 to 2 * pi\\n    randTheta := rand.Float64() * 2 * math.Pi\\n    \\n    // random radius from 0 to R\\n    randRadius := math.Sqrt( rand.Float64() ) * (this.Radius)\\n    \\n    // compute random point based on polar coordination\\n    randX_Coord := randRadius * math.Cos( randTheta ) + this.X_Center\\n    randY_Coord := randRadius * math.Sin( randTheta ) + this.Y_Center\\n    \\n    return []float64{ randX_Coord, randY_Coord }\\n}\\n\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * obj := Constructor(radius, x_center, y_center);\\n * param_1 := obj.RandPoint();\\n */\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: Polar coordination](https://en.wikipedia.org/wiki/Polar_coordinate_system)\\n\\n[2] [Python official docs about random](https://docs.python.org/3/library/random.html)\\n\\n[3] [Python official docs about math](https://docs.python.org/3/library/math.html?highlight=math#trigonometric-functions)\\n\\n[4] [Golang officials docs about random](https://golang.org/pkg/math/rand/)\\n\\n[5] [Golang officials docs about math](https://golang.org/pkg/math/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Math"
                ],
                "code": "```\\nfrom random import random, seed\\nfrom math import pi, cos, sin, sqrt\\n\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        \\n        self._x_center = x_center\\n        self._y_center = y_center\\n        self._r = radius\\n        \\n        # Initialize random seed with system time\\n        seed()\\n\\n    def randPoint(self) -> List[float]:\\n        \\n        # random theta from 0 to 2*pi\\n        rand_theta = random() * 2 * pi\\n        \\n        # random radius from 0 to R\\n        rand_radius = sqrt( random() ) * self._r\\n        \\n        # compute random point based on polar coordination\\n        rand_x_coord = rand_radius * cos(rand_theta) + self._x_center\\n        rand_y_coord = rand_radius * sin(rand_theta) + self._y_center\\n        \\n        return [rand_x_coord, rand_y_coord]\\n    \\n    \\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(radius, x_center, y_center)\\n# param_1 = obj.randPoint()\\n```\n```\\nimport (\\n    \"math/rand\"\\n    \"math\"\\n\\t\"time\"\\n)\\n\\ntype Solution struct {\\n    X_Center float64\\n    Y_Center float64\\n    Radius float64\\n}\\n\\n\\nfunc Constructor(radius float64, x_center float64, y_center float64) Solution {\\n    \\n    // Initialize random seed with system time\\n    rand.Seed( time.Now().UnixNano() )\\n    \\n    return Solution{ Radius: radius, X_Center: x_center, Y_Center: y_center }\\n}\\n\\n\\nfunc (this *Solution) RandPoint() []float64 {\\n    \\n    // random theta from 0 to 2 * pi\\n    randTheta := rand.Float64() * 2 * math.Pi\\n    \\n    // random radius from 0 to R\\n    randRadius := math.Sqrt( rand.Float64() ) * (this.Radius)\\n    \\n    // compute random point based on polar coordination\\n    randX_Coord := randRadius * math.Cos( randTheta ) + this.X_Center\\n    randY_Coord := randRadius * math.Sin( randTheta ) + this.Y_Center\\n    \\n    return []float64{ randX_Coord, randY_Coord }\\n}\\n\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * obj := Constructor(radius, x_center, y_center);\\n * param_1 := obj.RandPoint();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113617,
                "title": "c-short-solution",
                "content": "Run-time is `O(1)`, space is `O(1)`. \\n\\n```\\nclass Solution {\\npublic:\\n    Solution(double radius, double x_center, double y_center): r{radius}, x{x_center}, y{y_center} {}\\n    \\n    vector<double> randPoint() {\\n        double a{x+r}, b{y+r};\\n        \\n        while((a-x)*(a-x)+(b-y)*(b-y) > r*r) {\\n            a = (double)rand()/RAND_MAX*(r*2)+x-r, b = (double)rand()/RAND_MAX*(r*2)+y-r;\\n        }\\n        return {a,b};\\n        \\n    }\\n    \\n    double r;\\n    double x;\\n    double y;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(double radius, double x_center, double y_center): r{radius}, x{x_center}, y{y_center} {}\\n    \\n    vector<double> randPoint() {\\n        double a{x+r}, b{y+r};\\n        \\n        while((a-x)*(a-x)+(b-y)*(b-y) > r*r) {\\n            a = (double)rand()/RAND_MAX*(r*2)+x-r, b = (double)rand()/RAND_MAX*(r*2)+y-r;\\n        }\\n        return {a,b};\\n        \\n    }\\n    \\n    double r;\\n    double x;\\n    double y;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 779030,
                "title": "python-alternative-mathematical-solution",
                "content": "We switch to polar coordinates. instead of generating x and y, we generate r (inner radius) and phi (angle w.r.t. x-axis). We know that angle of the points should be uniformly distributed in (-pi, pi). And probability of a point having inner radius r should be proportional to r (since circumference length is proportional to radius).\\n\\nSo, we generate phi uniformly.\\n\\nAnd, we generate radius with probability proportional to length. We can do that by a trick: first generate number uniformly in range [0, r^2]. Then taking square root. Then c.d.f: P(x <= k) = P(x^2 <= k^2) = k^2/r^2 which is proportional to k^2. Taking derivative, p.d.f f(k) is proportional to k, as desired.\\n```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.cenx = x_center\\n        self.ceny = y_center\\n        self.r = radius\\n    def randPoint(self) -> List[float]:\\n        #switch to polar coordinates\\n        phi = (2*random.random() - 1) *pi\\n        r = (random.random() * (self.r)**2)**0.5\\n        res = [self.cenx + r*cos(phi), self.ceny + r*sin(phi)]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.cenx = x_center\\n        self.ceny = y_center\\n        self.r = radius\\n    def randPoint(self) -> List[float]:\\n        #switch to polar coordinates\\n        phi = (2*random.random() - 1) *pi\\n        r = (random.random() * (self.r)**2)**0.5\\n        res = [self.cenx + r*cos(phi), self.ceny + r*sin(phi)]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756093,
                "title": "java-use-deg-and-len-for-random",
                "content": "```\\nclass Solution {\\n    double r, x, y;\\n    public Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double len = Math.sqrt(Math.random()) * r;\\n        double deg = Math.random() * 2 * Math.PI;\\n        return new double[]{x + len * Math.cos(deg), y + len * Math.sin(deg)};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double r, x, y;\\n    public Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double len = Math.sqrt(Math.random()) * r;\\n        double deg = Math.random() * 2 * Math.PI;\\n        return new double[]{x + len * Math.cos(deg), y + len * Math.sin(deg)};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657590,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    private double x;\\n    private double y;\\n    private double radius;\\n    private Random random;\\n    \\n    public Solution(double radius, double x, double y) {\\n        this.x = x;\\n        this.y = y;\\n        this.radius = radius;\\n        this.random = new Random();\\n    }\\n    \\n    public double[] randPoint() {\\n        double radians = random.nextDouble() * 2 * Math.PI;\\n        double radius = this.radius * Math.sqrt(random.nextDouble());\\n        \\n        double x = this.x + radius * Math.cos(radians);\\n        double y = this.y + radius * Math.sin(radians);\\n        return new double[] { x, y };\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private double x;\\n    private double y;\\n    private double radius;\\n    private Random random;\\n    \\n    public Solution(double radius, double x, double y) {\\n        this.x = x;\\n        this.y = y;\\n        this.radius = radius;\\n        this.random = new Random();\\n    }\\n    \\n    public double[] randPoint() {\\n        double radians = random.nextDouble() * 2 * Math.PI;\\n        double radius = this.radius * Math.sqrt(random.nextDouble());\\n        \\n        double x = this.x + radius * Math.cos(radians);\\n        double y = this.y + radius * Math.sin(radians);\\n        return new double[] { x, y };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294298,
                "title": "explanation-with-math-formula-ez-to-understand",
                "content": "At first , we know the probability is in direct proportion to the area of the circle.\\nsince the ratio of a randomArea to the totalArea is in the range of [0,1], \\nso we can get the proportion by calling random() function,\\nthen we can calculate the corresponding random radius by the math formula. \\nSo everything is Ez, just use polar coordinates.\\n![](http://pictures.alphago.pro/20190518114730.png)\\n```python\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n\\n    def randPoint(self) -> List[float]:\\n        if not self.radius: return []\\n        area_proportion = random.random()\\n        r = math.sqrt(area_proportion)*self.radius\\n        theta = random.random()*2*math.pi\\n        return [r*math.cos(theta)+self.x_center,r*math.sin(theta)+self.y_center]\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n\\n    def randPoint(self) -> List[float]:\\n        if not self.radius: return []\\n        area_proportion = random.random()\\n        r = math.sqrt(area_proportion)*self.radius\\n        theta = random.random()*2*math.pi\\n        return [r*math.cos(theta)+self.x_center,r*math.sin(theta)+self.y_center]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161072,
                "title": "python-solution",
                "content": "This is mostly a geometry problem.\\n```\\nimport random\\nclass Solution(object):\\n\\n    def __init__(self, radius, x_center, y_center):\\n        \"\"\"\\n        :type radius: float\\n        :type x_center: float\\n        :type y_center: float\\n        \"\"\"\\n        self.radius = radius\\n        self.x = x_center\\n        self.y = y_center\\n\\n    def randPoint(self):\\n        \"\"\"\\n        :rtype: List[float]\\n        \"\"\"\\n        while True:\\n            x = random.uniform(-1, 1)\\n            y = random.uniform(-1, 1)\\n            if x*x + y*y <= 1:\\n                return self.x+x*self.radius, self.y+y*self.radius\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\nclass Solution(object):\\n\\n    def __init__(self, radius, x_center, y_center):\\n        \"\"\"\\n        :type radius: float\\n        :type x_center: float\\n        :type y_center: float\\n        \"\"\"\\n        self.radius = radius\\n        self.x = x_center\\n        self.y = y_center\\n\\n    def randPoint(self):\\n        \"\"\"\\n        :rtype: List[float]\\n        \"\"\"\\n        while True:\\n            x = random.uniform(-1, 1)\\n            y = random.uniform(-1, 1)\\n            if x*x + y*y <= 1:\\n                return self.x+x*self.radius, self.y+y*self.radius\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157036,
                "title": "why-my-answer-is-wrong-i-use-a-random-angle-and-random-radius-to-find-the-point",
                "content": "\\tclass Solution {\\n\\t\\tdouble r, x, y;\\n\\t\\tRandom random;\\n\\t\\tpublic Solution(double radius, double x_center, double y_center) {\\n\\t\\t\\tr = radius;\\n\\t\\t\\tx = x_center;\\n\\t\\t\\ty = y_center;\\n\\t\\t\\trandom = new Random();\\n\\t\\t}\\n\\t\\tpublic double[] randPoint() {\\n\\t\\t\\tdouble radius = r * random.nextDouble();\\n\\t\\t\\tdouble angle = random.nextDouble() * 2 * Math.PI;\\n\\t\\t\\treturn new double[]{x + radius * Math.sin(angle), y + radius * Math.cos(angle)};\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tdouble r, x, y;\\n\\t\\tRandom random;\\n\\t\\tpublic Solution(double radius, double x_center, double y_center) {\\n\\t\\t\\tr = radius;\\n\\t\\t\\tx = x_center;\\n\\t\\t\\ty = y_center;\\n\\t\\t\\trandom = new Random();\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3671363,
                "title": "java-small-radius-means-points-are-closely-packed-at-center",
                "content": "Tried(didn\\'t work):\\n- Random Angle(0 to 360)\\n- Random Radius (0 to radius)\\n\\nTried(didn\\'t work):\\n- Random Angle(0 to 360): (1-random^2)\\n- Random Radius (0 to radius): (1-random^2)\\n\\nTried:\\n- Random Angle(0 to 360) sqrt(random)\\n- Random Radius (0 to radius): sqrt(random)\\n\\n```\\nclass Solution {\\n    private double rad, x, y;\\n\\n    public Solution(double radius, double x_center, double y_center) {\\n        rad = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double[] ans = new double[2];\\n        double angle = Math.sqrt(new Random().nextDouble()) * 360;\\n        double len = Math.sqrt(new Random().nextDouble()) * rad;\\n        ans[0] = x + len * Math.cos(angle);\\n        ans[1] = y + len * Math.sin(angle);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private double rad, x, y;\\n\\n    public Solution(double radius, double x_center, double y_center) {\\n        rad = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double[] ans = new double[2];\\n        double angle = Math.sqrt(new Random().nextDouble()) * 360;\\n        double len = Math.sqrt(new Random().nextDouble()) * rad;\\n        ans[0] = x + len * Math.cos(angle);\\n        ans[1] = y + len * Math.sin(angle);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507853,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\nprivate:\\n    double r, x, y;\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    double random(){\\n        return (double) rand() / RAND_MAX;\\n    }\\n    vector<double> randPoint() {\\n        double a = random() * 2 * M_PI;\\n        double smallR = sqrt(random()) * r;\\n        return {x + smallR * cos(a), y + smallR * sin(a)};\\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom random import random\\nfrom math import sin,cos\\n\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.x=x_center\\n        self.y=y_center\\n        self.r=radius\\n        \\n    def randPoint(self) -> List[float]:\\n        a = random()*6.28318530718\\n        r = sqrt(random())*self.r\\n        return [self.x+r*cos(a),self.y+r*sin(a)]\\n```\\n\\n```Java []\\nclass Solution {\\n    double radius;\\n    double x_center;\\n    double y_center;\\n\\n    public Solution(double radius, double x_center, double y_center) {\\n       this.radius = radius;\\n       this.x_center = x_center;\\n       this.y_center = y_center; \\n    }\\n    public double[] randPoint() {\\n        \\n        double ang = Math.random() * 2 * Math.PI,\\n            r = Math.sqrt(Math.random()) * radius;\\n            \\n        return new double[]{r*Math.cos(ang)+x_center,r*Math.sin(ang)+y_center};\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\nprivate:\\n    double r, x, y;\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    double random(){\\n        return (double) rand() / RAND_MAX;\\n    }\\n    vector<double> randPoint() {\\n        double a = random() * 2 * M_PI;\\n        double smallR = sqrt(random()) * r;\\n        return {x + smallR * cos(a), y + smallR * sin(a)};\\n    }\\n};\\n```\n```Python3 []\\nfrom random import random\\nfrom math import sin,cos\\n\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.x=x_center\\n        self.y=y_center\\n        self.r=radius\\n        \\n    def randPoint(self) -> List[float]:\\n        a = random()*6.28318530718\\n        r = sqrt(random())*self.r\\n        return [self.x+r*cos(a),self.y+r*sin(a)]\\n```\n```Java []\\nclass Solution {\\n    double radius;\\n    double x_center;\\n    double y_center;\\n\\n    public Solution(double radius, double x_center, double y_center) {\\n       this.radius = radius;\\n       this.x_center = x_center;\\n       this.y_center = y_center; \\n    }\\n    public double[] randPoint() {\\n        \\n        double ang = Math.random() * 2 * Math.PI,\\n            r = Math.sqrt(Math.random()) * radius;\\n            \\n        return new double[]{r*Math.cos(ang)+x_center,r*Math.sin(ang)+y_center};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145103,
                "title": "java-rejection-sampling-polar-coordinate-explained",
                "content": "## 1. Rejection Sampling Method\\n```double x = -r + 2*r*Math.random();```\\n```double y = -r + 2*r*Math.random();```\\n\\nWth these two lines are doing? why -r ? why multiplying by 2r ? Let me Explain...\\n\\nThese lines of code generate random x and y coordinates within a circle of radius \\'r\\'. The formula for each coordinate subtracts \\'r\\' from twice \\'r\\' multiplied by a random value generated by Math.random() method.\\n\\n- Math.random() generates a random number between 0 and 1.\\n- Multiplying the random number with 2r gives a value between 0 and 2r.\\n- Subtracting r from this value gives a value between -r and r.\\n- So the final x and y coordinates will be randomly generated values within the range of (-r, r).\\n\\n```\\n while (x * x + y * y > r * r) {\\n    x = -r + 2*r*Math.random();\\n    y = -r + 2*r*Math.random();\\n } \\n```\\n\\nThe above code generates random `x and y` coordinates between `-r and r`, and keeps generating new `{x, y}`coordinates until the point falls within the circle with radius r. The equation `x * x + y * y > r * r` checks if the point lies outside the circle, and if so, new `{x, y}` coordinates are generated.\\n\\n# Code\\n```\\nclass Solution {\\n    double x0, y0, r;\\n    \\n    public Solution(double radius, double x_center, double y_center) {\\n        x0 = x_center; y0 = y_center; r = radius;\\n    }\\n    \\n    public double[] randPoint() {\\n        double x = -r + 2*r*Math.random();\\n        double y = -r + 2*r*Math.random();\\n\\n        while (x * x + y * y > r * r) {\\n          x = -r + 2*r*Math.random();\\n          y = -r + 2*r*Math.random();\\n        }\\n        return new double[]{x0 + x , y0 + y};\\n    }\\n}\\n```\\n## 2. Polar coordinate Method\\n\\n```\\ndouble deg = Math.random() * Math.PI * 2;\\ndouble len = Math.sqrt(Math.random()) * r;\\nreturn new double[]{x0 + len*Math.cos(deg), y0 + len*Math.sin(deg)};\\n```\\nThese lines of code generate random points within a circle of radius \\'r\\' centered at the point (x0, y0).\\n\\n- Math.random() generates a random number between 0 and 1.\\nMultiplying this value with 2 * Math.PI gives a random angle between 0 and 2 * Math.PI in radians.\\n- The square root of the random number generated above is taken to get a random length between 0 and 1.\\n- Multiplying this value with \\'r\\' gives a random length between 0 and \\'r\\'.\\n- Finally, the x and y coordinates of the random point within the circle are calculated using the length and angle, using the cosine and sine functions respectively.\\n- The final result is an array containing the x and y coordinates of the randomly generated point within the circle.\\n\\n### Why we are using Math.sqrt() function?? \\n![fig2.jpg](https://assets.leetcode.com/users/images/db66b070-2aae-4928-83bf-b7fd7d124080_1675595370.3486109.jpeg)\\n\\n\\nThe square root function, Math.sqrt, is used to transform a uniform distribution of random numbers into a distribution that is proportional to the radius of the circle.\\n\\nWhen generating random numbers with Math.random(), the numbers are uniformly distributed between 0 and 1. However, to generate points randomly distributed within a circle, we want the points to be more likely to be closer to the center and less likely to be near the edge. The square root function transforms the uniform distribution of Math.random() into a distribution that is proportional to the radius of the circle.\\n\\nThe result of the Math.sqrt function, multiplied by the radius \\'r\\', gives a random length between 0 and \\'r\\' that is proportional to the circle\\'s radius. This length, combined with a random angle, is then used to calculate the x and y coordinates of a random point within the circle.\\n\\n# Code\\n```\\nclass Solution {\\n    double x0, y0, r;\\n\\n    public Solution(double radius, double x_center, double y_center) {\\n        x = x_center; y = y_center; r = radius;\\n    }\\n    \\n    public double[] randPoint() {\\n        double deg = Math.random() * Math.PI * 2;\\n        double len = Math.sqrt(Math.random()) * r;\\n        return new double[]{x0 + len*Math.cos(deg), y0 + len*Math.sin(deg)};\\n    }\\n}\\n```\\n## Which one is Faster ??\\nIt\\'s hard to say which solution is faster without considering the specific requirements of your project and the computational environment. Both solutions generate random points within a circle but use different methods to do so.\\n\\nThe first solution uses a rejection sampling method where it generates random points within a square centered at the origin and with side length 2 * r. It then checks if the point lies within the circle, and if not, generates a new random point until it finds a point inside the circle. This method is relatively simple and has a constant expected time complexity.\\n\\nThe second solution uses a polar coordinate based method where it generates the random points within a circle using an angle and a length. The random angle is generated in radians between 0 and 2 * \\u03C0, and the random length is generated between 0 and \\'r\\'. This method has a slightly more complex implementation, but it could be faster than the first solution in some cases, as it generates points directly in the polar coordinate system.\\n\\n***In general, the performance of these solutions will depend on factors such as the size of the circle, the computational environment, and the specific requirements of your project.***\\n\\n### please upVote if you found this helpful !!",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Rejection Sampling",
                    "Randomized"
                ],
                "code": "```double x = -r + 2*r*Math.random();```\n```double y = -r + 2*r*Math.random();```\n```\\n while (x * x + y * y > r * r) {\\n    x = -r + 2*r*Math.random();\\n    y = -r + 2*r*Math.random();\\n } \\n```\n```\\nclass Solution {\\n    double x0, y0, r;\\n    \\n    public Solution(double radius, double x_center, double y_center) {\\n        x0 = x_center; y0 = y_center; r = radius;\\n    }\\n    \\n    public double[] randPoint() {\\n        double x = -r + 2*r*Math.random();\\n        double y = -r + 2*r*Math.random();\\n\\n        while (x * x + y * y > r * r) {\\n          x = -r + 2*r*Math.random();\\n          y = -r + 2*r*Math.random();\\n        }\\n        return new double[]{x0 + x , y0 + y};\\n    }\\n}\\n```\n```\\ndouble deg = Math.random() * Math.PI * 2;\\ndouble len = Math.sqrt(Math.random()) * r;\\nreturn new double[]{x0 + len*Math.cos(deg), y0 + len*Math.sin(deg)};\\n```\n```\\nclass Solution {\\n    double x0, y0, r;\\n\\n    public Solution(double radius, double x_center, double y_center) {\\n        x = x_center; y = y_center; r = radius;\\n    }\\n    \\n    public double[] randPoint() {\\n        double deg = Math.random() * Math.PI * 2;\\n        double len = Math.sqrt(Math.random()) * r;\\n        return new double[]{x0 + len*Math.cos(deg), y0 + len*Math.sin(deg)};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796648,
                "title": "generate-random-point-in-a-circle-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    double RAD, XC, YC;\\n    public Solution(double radius, double x_center, double y_center) {\\n        RAD = radius;\\n        XC = x_center;\\n        YC = y_center;\\n    }\\n    public double[] randPoint() {\\n        double ang = Math.random() * 2 * Math.PI,\\n            hyp = Math.sqrt(Math.random()) * RAD,\\n            adj = Math.cos(ang) * hyp,\\n            opp = Math.sin(ang) * hyp;\\n        return new double[]{XC + adj, YC + opp};\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(radius, x_center, y_center);\\n * double[] param_1 = obj.randPoint();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Geometry",
                    "Rejection Sampling",
                    "Randomized"
                ],
                "code": "```\\nclass Solution {\\n    double RAD, XC, YC;\\n    public Solution(double radius, double x_center, double y_center) {\\n        RAD = radius;\\n        XC = x_center;\\n        YC = y_center;\\n    }\\n    public double[] randPoint() {\\n        double ang = Math.random() * 2 * Math.PI,\\n            hyp = Math.sqrt(Math.random()) * RAD,\\n            adj = Math.cos(ang) * hyp,\\n            opp = Math.sin(ang) * hyp;\\n        return new double[]{XC + adj, YC + opp};\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(radius, x_center, y_center);\\n * double[] param_1 = obj.randPoint();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670068,
                "title": "100-python-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/f418f3da-887c-4e0d-a597-c481caff372e_1665085106.777385.png)\\n```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.x = x_center\\n        self.y = y_center\\n        self.r = radius\\n\\n    def randPoint(self) -> List[float]:\\n        r = sqrt(random.random()) * self.r\\n        x = random.uniform(0, 2*pi)\\n        \\n        return [self.x + r*math.cos(x), self.y + r*math.sin(x)]\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.x = x_center\\n        self.y = y_center\\n        self.r = radius\\n\\n    def randPoint(self) -> List[float]:\\n        r = sqrt(random.random()) * self.r\\n        x = random.uniform(0, 2*pi)\\n        \\n        return [self.x + r*math.cos(x), self.y + r*math.sin(x)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120391,
                "title": "python3-beats-95-solutions-two-uniform-random-number-generators-in-polar-coordinates",
                "content": "```\\n\"\"\"https://leetcode.com/problems/generate-random-point-in-a-circle/\"\"\"\\nfrom math import pi, sqrt, cos, sin\\nfrom random import random\\n\\n\\nclass Solution:\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n\\n    def randPoint(self) -> List[float]:\\n        r = sqrt((self.radius**2) * random())\\n        theta = 2 * pi * random()        \\n        return [self.x_center + r * cos(theta), self.y_center + r * sin(theta)]",
                "solutionTags": [],
                "code": "```\\n\"\"\"https://leetcode.com/problems/generate-random-point-in-a-circle/\"\"\"\\nfrom math import pi, sqrt, cos, sin\\nfrom random import random\\n\\n\\nclass Solution:\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n\\n    def randPoint(self) -> List[float]:\\n        r = sqrt((self.radius**2) * random())\\n        theta = 2 * pi * random()        \\n        return [self.x_center + r * cos(theta), self.y_center + r * sin(theta)]",
                "codeTag": "Java"
            },
            {
                "id": 1730705,
                "title": "simple-theoretical-explanation-of-why-sqrt-length-c",
                "content": "Imagine circle of rad = 1(c1) & rad = 2(c2): \\n\\t\\tIf length is randomly choosen, it has equal probability of being anywhere [0,radius].\\n        We want probability of point being in circle: p(c2) = 4 * p(c1) - why?(compare area).\\n        We take length^2 -> if length^2 = [0,1] the point belongs to c1 and if length^2 = [0,4] the point belongs to c2\\n\\t\\t=> length = sqrt(random() * length^2) = sqrt(random()) * length\\n        => prob(c2) = 4 * p(c1)\\n\\n```\\n\\nclass Solution {\\npublic:\\n    double xCenter;\\n    double yCenter;\\n    double radius;\\n    Solution(double rad, double x_center, double y_center) {\\n        radius = rad;\\n        xCenter = x_center;\\n        yCenter = y_center;\\n    }\\n    \\n    double random(){\\n        return 1.0 * rand() / RAND_MAX;\\n    }\\n   \\n    vector<double> randPoint() {        \\n        double length = sqrt(random()) * radius;\\n        double angle = random() * 2 * M_PI;\\n        double xRand = xCenter + length * cos(angle), yRand = yCenter + length * sin(angle);\\n        return {xRand, yRand};\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    double xCenter;\\n    double yCenter;\\n    double radius;\\n    Solution(double rad, double x_center, double y_center) {\\n        radius = rad;\\n        xCenter = x_center;\\n        yCenter = y_center;\\n    }\\n    \\n    double random(){\\n        return 1.0 * rand() / RAND_MAX;\\n    }\\n   \\n    vector<double> randPoint() {        \\n        double length = sqrt(random()) * radius;\\n        double angle = random() * 2 * M_PI;\\n        double xRand = xCenter + length * cos(angle), yRand = yCenter + length * sin(angle);\\n        return {xRand, yRand};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561834,
                "title": "c-final-solution",
                "content": "class Solution {\\n    double m_radius;\\n    double m_x_center;\\n    double m_y_center;\\n    \\npublic:\\n    Solution(double radius, double x_center, double y_center) \\n        : m_radius(radius), m_x_center(x_center), m_y_center(y_center) {\\n        srand(time(NULL));\\n    }\\n    \\n    vector<double> randPoint() {\\n        double ran1 = (double)rand() / RAND_MAX;\\n        double ran2 = (double)rand() / RAND_MAX;\\n        \\n        double angle = ran1 * 2 * M_PI;\\n\\t\\t//spread points outwards, not single dimension, but two dimension  \\n        double radius = sqrt(ran2) * m_radius;\\n        \\n        vector<double> rtn;\\n        rtn.push_back(m_x_center + radius * sin(angle));\\n        rtn.push_back(m_y_center + radius * cos(angle));\\n        return rtn;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    double m_radius;\\n    double m_x_center;\\n    double m_y_center;\\n    \\npublic:\\n    Solution(double radius, double x_center, double y_center) \\n        : m_radius(radius), m_x_center(x_center), m_y_center(y_center) {\\n        srand(time(NULL));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1400021,
                "title": "python-numpy-recursion",
                "content": "```\\nimport numpy as np\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.x = x_center\\n        self.y = y_center\\n        self.rad = radius\\n        self.x_min = x_center - radius\\n        self.x_max = x_center + radius\\n        self.y_min = y_center - radius\\n        self.y_max = y_center + radius\\n        \\n\\n    def randPoint(self) -> List[float]:\\n        # Use uniform number generator in numpy\\n        coords = [np.random.uniform(self.x_min, self.x_max), np.random.uniform(self.y_min, self.y_max)]\\n        \\n        # check that point is in circle, try again if it isn\\'t\\n        if np.sqrt((coords[0] - self.x) ** 2 + (coords[1] - self.y) **2) > self.rad:\\n            return self.randPoint()\\n        else:\\n            return coords\\n```",
                "solutionTags": [],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.x = x_center\\n        self.y = y_center\\n        self.rad = radius\\n        self.x_min = x_center - radius\\n        self.x_max = x_center + radius\\n        self.y_min = y_center - radius\\n        self.y_max = y_center + radius\\n        \\n\\n    def randPoint(self) -> List[float]:\\n        # Use uniform number generator in numpy\\n        coords = [np.random.uniform(self.x_min, self.x_max), np.random.uniform(self.y_min, self.y_max)]\\n        \\n        # check that point is in circle, try again if it isn\\'t\\n        if np.sqrt((coords[0] - self.x) ** 2 + (coords[1] - self.y) **2) > self.rad:\\n            return self.randPoint()\\n        else:\\n            return coords\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133693,
                "title": "flip-binary-tree-c-preorder-recursive-explained",
                "content": "```\\nclass Solution {\\n    void flip(TreeNode* root) {\\n        TreeNode* temp;\\n\\n        temp = root->left;\\n        root->left = root->right;\\n        root->right = temp;\\n    }\\n\\n    int preorder(TreeNode* root, vector<int>& voyage, int i, vector<int>& flipped_nodes) {\\n        int lcount, rcount;\\n\\n        if (root == nullptr) {\\n            return 0;\\n        }\\n\\n        if (root->val != voyage[i]) {\\n            // Give the caller a signal that it\\'s impossible.\\n            return -1;\\n        }\\n\\n        if (root->left && root->right\\n        && root->left->val != voyage[i + 1]\\n        && root->right->val == voyage[i + 1]) {\\n            flipped_nodes.push_back(root->val);\\n            flip(root);\\n        }\\n\\n        lcount = preorder(root->left, voyage, i + 1, flipped_nodes);\\n        if (lcount == -1) {\\n            return -1;\\n        }\\n\\n        rcount = preorder(root->right, voyage, i + 1 + lcount, flipped_nodes);\\n        if (rcount == -1) {\\n            return -1;\\n        }\\n\\n        // Return the count of this subtree (+ 1: me).\\n        return lcount + rcount + 1;\\n    }\\n\\npublic:\\n    vector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {\\n        vector<int> flipped_nodes;\\n        \\n        if (preorder(root, voyage, 0, flipped_nodes) == -1) {\\n            // -1 is a signal indicating that it\\'s impossible.\\n            return { -1 };\\n        }\\n\\n        return flipped_nodes;\\n    }\\n};\\n```\\n\\n**Description**\\n\\n* Three important strategies to note:\\n\\t1. `preorder` returns count of the subtree including the `root` passed to it.\\n\\t2. This is an optimistic approach. That is, even though in the future it might turn out that it\\'s impossible, we flip if it seems to work for now. If at some point in the future it turns out impossible, `preorder` immediately returns and sends a signal `-1` to the callers recursively.\\n\\t3. `flipped_nodes`, the list of the values we are supposed to return, is passed as reference to the recursive calls to `preorder` so that it can be easily updated across the recursive calls.\\n* Inserting the value of the node into `flipped_nodes` only takes place if both of the `left` and `right` children exist and it seems to work for now (more specifically, with the right next value `voyage[i + 1]` for now) to flip.\\n\\t* If no children exist or only one exists, flip is not needed because it\\'s a *preorder* traversal.\\n* Every call to `preorder` returns the count of the nodes of the subtree so that the next index in `voyage` can be easily calculated.\\n* **So when is the moment it turns out impossible?** That\\'s when the condition `root->val != voyage[i]` is met. If the root node has a different value, there is nothing we can do.\\n\\n</br>\\n\\nThank you for reviewing my code. Any suggestions or advice will be welcome!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void flip(TreeNode* root) {\\n        TreeNode* temp;\\n\\n        temp = root->left;\\n        root->left = root->right;\\n        root->right = temp;\\n    }\\n\\n    int preorder(TreeNode* root, vector<int>& voyage, int i, vector<int>& flipped_nodes) {\\n        int lcount, rcount;\\n\\n        if (root == nullptr) {\\n            return 0;\\n        }\\n\\n        if (root->val != voyage[i]) {\\n            // Give the caller a signal that it\\'s impossible.\\n            return -1;\\n        }\\n\\n        if (root->left && root->right\\n        && root->left->val != voyage[i + 1]\\n        && root->right->val == voyage[i + 1]) {\\n            flipped_nodes.push_back(root->val);\\n            flip(root);\\n        }\\n\\n        lcount = preorder(root->left, voyage, i + 1, flipped_nodes);\\n        if (lcount == -1) {\\n            return -1;\\n        }\\n\\n        rcount = preorder(root->right, voyage, i + 1 + lcount, flipped_nodes);\\n        if (rcount == -1) {\\n            return -1;\\n        }\\n\\n        // Return the count of this subtree (+ 1: me).\\n        return lcount + rcount + 1;\\n    }\\n\\npublic:\\n    vector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {\\n        vector<int> flipped_nodes;\\n        \\n        if (preorder(root, voyage, 0, flipped_nodes) == -1) {\\n            // -1 is a signal indicating that it\\'s impossible.\\n            return { -1 };\\n        }\\n\\n        return flipped_nodes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129293,
                "title": "palindromic-substrings-solution",
                "content": "```\\nclass Solution {\\n  \\tstatic int countSubstrings(String s)\\n\\t{\\n      char str[]=s.toCharArray();\\n      int n=s.length();\\n\\n\\t\\tint dp[][] = new int[n][n];\\n\\t\\tboolean P[][] = new boolean[n][n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tP[i][i] = true;\\n\\t\\tfor (int i = 0; i < n - 1; i++) {\\n\\t\\t\\tif (str[i] == str[i + 1]) {\\n\\t\\t\\t\\tP[i][i + 1] = true;\\n\\t\\t\\t\\tdp[i][i + 1] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int gap = 2; gap < n; gap++) {\\n\\t\\t\\tfor (int i = 0; i < n - gap; i++) {\\n\\t\\t\\t\\tint j = gap + i;\\n\\t\\t\\t\\tif (str[i] == str[j] && P[i + 1][j - 1])\\n\\t\\t\\t\\t\\tP[i][j] = true;\\n\\t\\t\\t\\tif (P[i][j] == true)\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i][j - 1] + dp[i + 1][j]\\n\\t\\t\\t\\t\\t\\t\\t+ 1 - dp[i + 1][j - 1];\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i][j - 1] + dp[i + 1][j]\\n\\t\\t\\t\\t\\t\\t\\t- dp[i + 1][j - 1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[0][n - 1]+n;\\n\\t}\\n    \\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n  \\tstatic int countSubstrings(String s)\\n\\t{\\n      char str[]=s.toCharArray();\\n      int n=s.length();\\n\\n\\t\\tint dp[][] = new int[n][n];\\n\\t\\tboolean P[][] = new boolean[n][n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tP[i][i] = true;\\n\\t\\tfor (int i = 0; i < n - 1; i++) {\\n\\t\\t\\tif (str[i] == str[i + 1]) {\\n\\t\\t\\t\\tP[i][i + 1] = true;\\n\\t\\t\\t\\tdp[i][i + 1] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int gap = 2; gap < n; gap++) {\\n\\t\\t\\tfor (int i = 0; i < n - gap; i++) {\\n\\t\\t\\t\\tint j = gap + i;\\n\\t\\t\\t\\tif (str[i] == str[j] && P[i + 1][j - 1])\\n\\t\\t\\t\\t\\tP[i][j] = true;\\n\\t\\t\\t\\tif (P[i][j] == true)\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i][j - 1] + dp[i + 1][j]\\n\\t\\t\\t\\t\\t\\t\\t+ 1 - dp[i + 1][j - 1];\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i][j - 1] + dp[i + 1][j]\\n\\t\\t\\t\\t\\t\\t\\t- dp[i + 1][j - 1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[0][n - 1]+n;\\n\\t}\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128167,
                "title": "word-subsets-c-using-simple-character-count",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> wordSubsets(vector<string>& A, vector<string>& B) {\\n        vector<string> res;\\n        int totalB[26] = {0,};\\n        // find all unique characters in all words in B and also find max frequence of each char among all words\\n        // ex: B = [\"abc\", \"abca\", \"accd\"], unique chars and max freq will be \"a:2, b:1, c:2, d:1\"\\n        for (string b: B) {\\n            int alpha_b[26] = {0,};\\n            for (char c: b)\\n                alpha_b[c - \\'a\\']++;\\n            for (int i = 0; i < 26; i++)\\n                totalB[i] = max(totalB[i], alpha_b[i]);\\n        }\\n        // Find if a word from A covers all unique characters and their frequencies of TotalB\\n        for (string a: A) {\\n            int totalA[26] = {0,};\\n            for (char c: a)\\n                totalA[c - \\'a\\']++;\\n            bool flag = true;\\n            for (int i = 0; i < 26; i++) {\\n                if (totalB[i] > totalA[i]) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag)\\n                res.push_back(a);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordSubsets(vector<string>& A, vector<string>& B) {\\n        vector<string> res;\\n        int totalB[26] = {0,};\\n        // find all unique characters in all words in B and also find max frequence of each char among all words\\n        // ex: B = [\"abc\", \"abca\", \"accd\"], unique chars and max freq will be \"a:2, b:1, c:2, d:1\"\\n        for (string b: B) {\\n            int alpha_b[26] = {0,};\\n            for (char c: b)\\n                alpha_b[c - \\'a\\']++;\\n            for (int i = 0; i < 26; i++)\\n                totalB[i] = max(totalB[i], alpha_b[i]);\\n        }\\n        // Find if a word from A covers all unique characters and their frequencies of TotalB\\n        for (string a: A) {\\n            int totalA[26] = {0,};\\n            for (char c: a)\\n                totalA[c - \\'a\\']++;\\n            bool flag = true;\\n            for (int i = 0; i < 26; i++) {\\n                if (totalB[i] > totalA[i]) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if (flag)\\n                res.push_back(a);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126435,
                "title": "what-is-wrong-with-this-solution",
                "content": "In below solution, I first try to find a random x coordinate and then find lower and upper limit of Y to find random y.\\nBut it fails on 7 / 8 test cases passed. \\nNot sure what is wrong, and how to validate.\\n\\n![image](https://assets.leetcode.com/users/images/7aefa05b-c0a9-4354-816c-7d69112daf4c_1616646907.1421509.png)\\n\\n\\n```\\nclass Solution {\\n    \\n    double lowX, highX;\\n    double radius, centerY, centerX;\\n    Random random = new Random();\\n\\n    public Solution(double radius, double x_center, double y_center) {\\n        this.lowX = x_center - radius;\\n        this.highX = x_center + radius;\\n        this.radius = radius;\\n        this.centerY = y_center;\\n        this.centerX = x_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double randX = random(lowX, highX); // first get random X\\n        \\n        // We will apply pythagorus to find limits of random Y\\n        double baseX = centerX - randX; // base\\n        double hypotenuse = this.radius; // hypotenuse\\n        double yRad = Math.sqrt((hypotenuse * hypotenuse) - (baseX * baseX)); // height\\n        double randY = random(centerY - yRad, centerY + yRad); \\n        return new double[]{randX, randY};\\n    }\\n    \\n    private double random(double low, double high) {\\n        return (low + (high - low) * random.nextDouble());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    double lowX, highX;\\n    double radius, centerY, centerX;\\n    Random random = new Random();\\n\\n    public Solution(double radius, double x_center, double y_center) {\\n        this.lowX = x_center - radius;\\n        this.highX = x_center + radius;\\n        this.radius = radius;\\n        this.centerY = y_center;\\n        this.centerX = x_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double randX = random(lowX, highX); // first get random X\\n        \\n        // We will apply pythagorus to find limits of random Y\\n        double baseX = centerX - randX; // base\\n        double hypotenuse = this.radius; // hypotenuse\\n        double yRad = Math.sqrt((hypotenuse * hypotenuse) - (baseX * baseX)); // height\\n        double randY = random(centerY - yRad, centerY + yRad); \\n        return new double[]{randX, randY};\\n    }\\n    \\n    private double random(double low, double high) {\\n        return (low + (high - low) * random.nextDouble());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125197,
                "title": "advantage-shuffle-fast-python-multiple-solutions-with-explanation",
                "content": "### Ideas\\nThere are multiple ways to approach this problem. I list them as my thought progresses.\\n\\n#### 1. Sorted container\\nSort `B` from big to small. The optimal pick for `b` is the smallest not-chosen value in `A` that `> b`. \\n\\nThis approach requires a data structure that supports efficient `bisect` query and deletion. `sortedcontainers.SortedList` can come in handy.\\n\\n#### 2. Running stack\\nCan we do it without non-standard libraries? The answer is yes. We can sort `A` as well and maintain a stack of eligible values.  For each `b`, we will add values `> b` from sorted `A` to the stack in descending order and pick the top element for `b`. \\n\\nSee \"Code 2\" below. After the main loop, we fill the unassigned slots in `ans` with unused values from `A`.\\n\\n#### 3. Just pick\\nOnce we have the stack view, one may start to wonder do we really need to pick the smallest value in the stack for each `b`. After all, no matter we pick the smallest or largest, it won\\'t affect the candidate pool\\'s size and consequently the number of winning locations.\\n\\nSo let\\'s try to pick the largest eligible value instead.  One realization is that we don\\'t need a stack at all! The largest eligible value, if there is any, will just be the next biggest value in sorted `A`!\\n\\nWhat if the next biggest value in `A` is `<= b`? Then there is no way to win at `b` and we fill the location with the smallest value that is not yet picked from `A`. \\n\\nSee \"Code 3\" below. Note this also eliminated the extra finishing-up logic at the end of \"Code 2\".\\n\\n### Code 2\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        sorted_A = list(sorted(A))\\n        sorted_B = list(sorted(zip(B, count())))\\n        i = j = n - 1\\n        ans = [-1] * n\\n        st = []\\n        for b, j in reversed(sorted_B):\\n            if st:\\n                ans[j] = st.pop()\\n                continue\\n            if sorted_A[i] <= b:\\n                continue\\n            while i >= 0 and sorted_A[i] > b:\\n                st.append(sorted_A[i])\\n                i -= 1\\n            ans[j] = st.pop()\\n        while i >= 0:\\n            st.append(sorted_A[i])\\n            i -= 1\\n        for i in range(n):\\n            if ans[i] == -1:\\n                ans[i] = st.pop()\\n        return ans\\n```\\n\\n### Code 3\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        sorted_A = list(sorted(A))\\n        sorted_B = list(sorted(zip(B, count())))\\n        i, k = n - 1, 0\\n        ans = [-1] * n\\n        for b, j in reversed(sorted_B):\\n            if sorted_A[i] > b:\\n                ans[j] = sorted_A[i]\\n                i -= 1\\n            else:\\n                ans[j] = sorted_A[k]\\n                k += 1\\n        return ans\\n```\\n\\n\\n### Code 3.1\\nWe could further optimize the foot print of Code 3 by sorting `A` in place and only sorting the index of `B`:\\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        A.sort()\\n        sorted_B_idxs = sorted(range(n), key=lambda j: B[j], reverse=True)\\n        i, k = n - 1, 0\\n        ans = [-1] * n\\n        for j in sorted_B_idxs:\\n            if A[i] > B[j]:\\n                ans[j] = A[i]\\n                i -= 1\\n            else:\\n                ans[j] = A[k]\\n                k += 1\\n        return ans\\n```\\n\\n### Complexity\\nFor Code 2:\\n- O(n log n) time. \\nSorting takes O(n log n). The main loop takes O(n), as it walks through both `sorted_A` and `sorted_B` once.\\n- O(n) extra space. \\nThe storage of  `sorted_A`, `sorted_B` and the stack `st`.\\n\\nFor Code 3:\\n- O(n log n) time. \\nThe same argument applies. However, the actual running time is faster as the logic is simpler with no stack operations. \\n- O(n) extra space.\\nWe still need to store `sorted_A`, `sorted_B`, but the space for `st` is saved.\\n\\n### Submission Stats\\nFor Code 2:\\nRuntime: 356 ms (beats 66.12 %)\\nMemory Usage: 18 MB\\n\\nFor Code 3:\\nRuntime: 336 ms (beats 94.14 %)\\nMemory Usage: 17.6 MB\\n\\nFor Code 3.1:\\nRuntime: 332 ms (beats 96.52 %)\\nMemory Usage: 16.9 MB (beats 93.04 %)\\n\\n---\\nIf you find this helpful, please kindly **upvote**! It will greatly encourage me to write more in the future.\\nThanks for reading and happy LeetCoding~!",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        sorted_A = list(sorted(A))\\n        sorted_B = list(sorted(zip(B, count())))\\n        i = j = n - 1\\n        ans = [-1] * n\\n        st = []\\n        for b, j in reversed(sorted_B):\\n            if st:\\n                ans[j] = st.pop()\\n                continue\\n            if sorted_A[i] <= b:\\n                continue\\n            while i >= 0 and sorted_A[i] > b:\\n                st.append(sorted_A[i])\\n                i -= 1\\n            ans[j] = st.pop()\\n        while i >= 0:\\n            st.append(sorted_A[i])\\n            i -= 1\\n        for i in range(n):\\n            if ans[i] == -1:\\n                ans[i] = st.pop()\\n        return ans\\n```\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        sorted_A = list(sorted(A))\\n        sorted_B = list(sorted(zip(B, count())))\\n        i, k = n - 1, 0\\n        ans = [-1] * n\\n        for b, j in reversed(sorted_B):\\n            if sorted_A[i] > b:\\n                ans[j] = sorted_A[i]\\n                i -= 1\\n            else:\\n                ans[j] = sorted_A[k]\\n                k += 1\\n        return ans\\n```\n```python\\nclass Solution:\\n    def advantageCount(self, A: List[int], B: List[int]) -> List[int]:\\n        n = len(A)\\n        A.sort()\\n        sorted_B_idxs = sorted(range(n), key=lambda j: B[j], reverse=True)\\n        i, k = n - 1, 0\\n        ans = [-1] * n\\n        for j in sorted_B_idxs:\\n            if A[i] > B[j]:\\n                ans[j] = A[i]\\n                i -= 1\\n            else:\\n                ans[j] = A[k]\\n                k += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122137,
                "title": "vowel-spellchecker-c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_set<string> s(wordlist.begin(), wordlist.end());\\n        unordered_map<string, string> m, mm;    \\n        vector<string> w(wordlist);\\n        for(int i=wordlist.size()-1;i>=0;i--){\\n            for(auto& j:w[i]) j=tolower(j);\\n            m[w[i]]=wordlist[i];\\n            for(auto& j:w[i]) if(j==\\'a\\' || j==\\'e\\' || j==\\'i\\' || j==\\'o\\' || j==\\'u\\') j=\\'.\\';\\n            mm[w[i]]=wordlist[i];\\n        }\\n        for(auto& i:queries){\\n            if(s.count(i)) continue;\\n            for(auto& j:i) j=tolower(j);\\n            if(m.count(i)){\\n                i=m[i];\\n                continue;\\n            }\\n            for(auto& j:i) if(j==\\'a\\' || j==\\'e\\' || j==\\'i\\' || j==\\'o\\' || j==\\'u\\') j=\\'.\\';\\n            if(mm.count(i)){\\n                i=mm[i];\\n                continue;\\n            }\\n            i=\"\";\\n        }\\n        return queries;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\\n        unordered_set<string> s(wordlist.begin(), wordlist.end());\\n        unordered_map<string, string> m, mm;    \\n        vector<string> w(wordlist);\\n        for(int i=wordlist.size()-1;i>=0;i--){\\n            for(auto& j:w[i]) j=tolower(j);\\n            m[w[i]]=wordlist[i];\\n            for(auto& j:w[i]) if(j==\\'a\\' || j==\\'e\\' || j==\\'i\\' || j==\\'o\\' || j==\\'u\\') j=\\'.\\';\\n            mm[w[i]]=wordlist[i];\\n        }\\n        for(auto& i:queries){\\n            if(s.count(i)) continue;\\n            for(auto& j:i) j=tolower(j);\\n            if(m.count(i)){\\n                i=m[i];\\n                continue;\\n            }\\n            for(auto& j:i) if(j==\\'a\\' || j==\\'e\\' || j==\\'i\\' || j==\\'o\\' || j==\\'u\\') j=\\'.\\';\\n            if(mm.count(i)){\\n                i=mm[i];\\n                continue;\\n            }\\n            i=\"\";\\n        }\\n        return queries;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121878,
                "title": "java-vowel-spellchecker-2-hashmap-1-hashset-explained",
                "content": "Three types of query words:\\n1. The query is same as the word in the wordlist.\\n2. The query has the same letters and the same order, but has subtle different with the capitalization.\\n3. The query has similar letters. Only the vowels part are different with the word in the wordlist.\\n\\nIterate wordlist:\\n1. Add the word into `HashSet`.\\n2. Capitalize the word and add to the first `HashMap`.\\n3. Replace the vowels to `*` then add to the second `HashMap`. \\n\\nSince the question also noted that only return the first match, so only put the word into map when first meet.\\n\\nQueries:\\n\\n- For type 1 : Return the same word in the wordlist.\\n- For type 2 : Capitalize the query and return the word (all capitalize) from the first map.\\n- For type 3 : Replace the vowel part of the query (after capitalize), and return the word from the second map.\\n- For others: Return the empty string.\\n\\n```\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        HashSet<String> same = new HashSet<String>();\\n        HashMap<String, String> caseInsensitive = new HashMap<String, String>();\\n        HashMap<String, String> vowelMap = new HashMap<String, String>();\\n        \\n        for (String word: wordlist) {\\n\\t\\t\\tsame.add(word);\\n            String capital = word.toUpperCase();\\n            caseInsensitive.putIfAbsent(capital, word);\\n            vowelMap.putIfAbsent(replaceVowel(capital), word);\\n        }\\n        \\n        String[] res = new String[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            if (same.contains(queries[i])) {\\n                res[i] = queries[i];\\n                continue;\\n            }\\n            \\n            String cap = queries[i].toUpperCase(), vow = replaceVowel(cap);\\n            if (caseInsensitive.containsKey(cap)) {\\n                res[i] = caseInsensitive.get(cap);\\n            } else if (vowelMap.containsKey(vow)) {\\n                res[i] = vowelMap.get(vow);\\n            } else {\\n                res[i] = \"\";\\n            }\\n        }\\n        return res;\\n\\n    }\\n    \\n    private String replaceVowel(String s) {\\n        char[] ch = s.toCharArray();\\n        for (int i = 0; i < ch.length; i++) {\\n            if (ch[i] == \\'A\\' || ch[i] == \\'E\\' || ch[i] == \\'I\\' || ch[i] == \\'O\\' || ch[i] == \\'U\\')\\n                ch[i] = \\'*\\';\\n        }\\n        return new String(ch);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String[] spellchecker(String[] wordlist, String[] queries) {\\n        HashSet<String> same = new HashSet<String>();\\n        HashMap<String, String> caseInsensitive = new HashMap<String, String>();\\n        HashMap<String, String> vowelMap = new HashMap<String, String>();\\n        \\n        for (String word: wordlist) {\\n\\t\\t\\tsame.add(word);\\n            String capital = word.toUpperCase();\\n            caseInsensitive.putIfAbsent(capital, word);\\n            vowelMap.putIfAbsent(replaceVowel(capital), word);\\n        }\\n        \\n        String[] res = new String[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            if (same.contains(queries[i])) {\\n                res[i] = queries[i];\\n                continue;\\n            }\\n            \\n            String cap = queries[i].toUpperCase(), vow = replaceVowel(cap);\\n            if (caseInsensitive.containsKey(cap)) {\\n                res[i] = caseInsensitive.get(cap);\\n            } else if (vowelMap.containsKey(vow)) {\\n                res[i] = vowelMap.get(vow);\\n            } else {\\n                res[i] = \"\";\\n            }\\n        }\\n        return res;\\n\\n    }\\n    \\n    private String replaceVowel(String s) {\\n        char[] ch = s.toCharArray();\\n        for (int i = 0; i < ch.length; i++) {\\n            if (ch[i] == \\'A\\' || ch[i] == \\'E\\' || ch[i] == \\'I\\' || ch[i] == \\'O\\' || ch[i] == \\'U\\')\\n                ch[i] = \\'*\\';\\n        }\\n        return new String(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121851,
                "title": "vowel-spellchecker-python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        table1=set()\\n        table2={}\\n        table3={}\\n        for i in wordlist:\\n            table1.add(i)\\n            key1=i.lower()\\n            if key1 not in table2:\\n                table2[key1]=i\\n            key2=\"\".join(j if j not in \"aeiou\" else \"*\" for j in key1)\\n            if key2 not in table3:\\n                table3[key2]=i\\n        res=[]\\n        for i in queries:\\n            if i in table1:\\n                res.append(i)\\n                continue\\n            word1=i.lower()\\n            if word1 in table2:\\n                res.append(table2[word1])\\n                continue\\n            word2=\"\".join(j if j not in \"aeiou\" else \"*\" for j in word1)\\n            if word2 in table3:\\n                res.append(table3[word2])\\n            else:\\n                res.append(\"\")\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spellchecker(self, wordlist: List[str], queries: List[str]) -> List[str]:\\n        table1=set()\\n        table2={}\\n        table3={}\\n        for i in wordlist:\\n            table1.add(i)\\n            key1=i.lower()\\n            if key1 not in table2:\\n                table2[key1]=i\\n            key2=\"\".join(j if j not in \"aeiou\" else \"*\" for j in key1)\\n            if key2 not in table3:\\n                table3[key2]=i\\n        res=[]\\n        for i in queries:\\n            if i in table1:\\n                res.append(i)\\n                continue\\n            word1=i.lower()\\n            if word1 in table2:\\n                res.append(table2[word1])\\n                continue\\n            word2=\"\".join(j if j not in \"aeiou\" else \"*\" for j in word1)\\n            if word2 in table3:\\n                res.append(table3[word2])\\n            else:\\n                res.append(\"\")\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120294,
                "title": "reordered-power-of-2-c-0ms",
                "content": "Easy problem just to think basic approach \\npower of 2\\'s is in bit \\n1<<i where i ranges from [0,31];\\nfor int ..N is 1e9;\\n\\n```\\n\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n         string res1 = to_string(N);\\n        sort(res1.begin(), res1.end());\\n        for (int i = 0; i < 31; i++) {\\n            string res2 = to_string(1 << i);\\n            sort(res2.begin(), res2.end());\\n            if (res1 == res2) return true;\\n        }\\n        return false;\\n    }   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool reorderedPowerOf2(int N) {\\n         string res1 = to_string(N);\\n        sort(res1.begin(), res1.end());\\n        for (int i = 0; i < 31; i++) {\\n            string res2 = to_string(1 << i);\\n            sort(res2.begin(), res2.end());\\n            if (res1 == res2) return true;\\n        }\\n        return false;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117399,
                "title": "keys-and-rooms-c-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<vector<int>>& rooms, vector<bool>& visited) {\\n        if (visited[node])\\n            return;\\n        visited[node] = true;\\n        for (int r: rooms[node]) {\\n            if (visited[r] == false) {\\n                dfs(r, rooms, visited);\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int N = rooms.size();\\n        vector<bool> visited(N, false);\\n        dfs(0, rooms, visited);\\n        return all_of(visited.begin(), visited.end(), [](bool val) {\\n            return val == true;\\n        }) ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<vector<int>>& rooms, vector<bool>& visited) {\\n        if (visited[node])\\n            return;\\n        visited[node] = true;\\n        for (int r: rooms[node]) {\\n            if (visited[r] == false) {\\n                dfs(r, rooms, visited);\\n            }\\n        }\\n    }\\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\\n        int N = rooms.size();\\n        vector<bool> visited(N, false);\\n        dfs(0, rooms, visited);\\n        return all_of(visited.begin(), visited.end(), [](bool val) {\\n            return val == true;\\n        }) ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116519,
                "title": "wiggle-subsequence-greedy-approach-c-simple-code",
                "content": "```\\npublic class Solution {\\n    public int WiggleMaxLength(int[] nums) {\\n        if (nums.Length < 2) \\n            return nums.Length;\\n        \\n        int maxLen = 1;\\n        const int up = 1, down = -1;\\n        int directionY = 0;        \\n        for (int i = 1; i < nums.Length; i++) {\\n            var diff = nums[i] - nums[i-1];\\n            \\n            if (diff < 0 && directionY != down) \\n            {         \\n                //peak\\n                directionY = -1;\\n                maxLen++;\\n            } \\n            else if (diff > 0 && directionY != up) \\n            {   \\n                //valley\\n                directionY = 1;\\n                maxLen++;\\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int WiggleMaxLength(int[] nums) {\\n        if (nums.Length < 2) \\n            return nums.Length;\\n        \\n        int maxLen = 1;\\n        const int up = 1, down = -1;\\n        int directionY = 0;        \\n        for (int i = 1; i < nums.Length; i++) {\\n            var diff = nums[i] - nums[i-1];\\n            \\n            if (diff < 0 && directionY != down) \\n            {         \\n                //peak\\n                directionY = -1;\\n                maxLen++;\\n            } \\n            else if (diff > 0 && directionY != up) \\n            {   \\n                //valley\\n                directionY = 1;\\n                maxLen++;\\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115272,
                "title": "c-square-polar-coord-explained",
                "content": "**Code and descriptions**\\n```\\nclass Solution {\\n    double radius;\\n    double x_center;\\n    double y_center;\\n\\n    vector<double> randPointInSquare() const {\\n        vector<double> point;\\n\\n        point.push_back((x_center - radius) + ((double)rand() / RAND_MAX) * (radius * 2));\\n        point.push_back((y_center - radius) + ((double)rand() / RAND_MAX) * (radius * 2));\\n\\n        return point;\\n    }\\n\\n    double distanceFromCenter(vector<double> point) const {\\n        return sqrt(pow(point[0] - x_center, 2) + pow(point[1] - y_center, 2));\\n    }\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) : radius(radius), x_center(x_center), y_center(y_center) {\\n\\n    }\\n\\n    vector<double> randPoint() {\\n        vector<double> point;\\n\\n        do {\\n            point = randPointInSquare();\\n        } while (distanceFromCenter(point) > radius);\\n\\n        return point;\\n    }\\n};\\n```\\n\\n**Both versions**\\n\\n* Use `(double)rand() / RAND_MAX` to generate a random number in a range of [0, *some_number*].\\n\\n</br>\\n\\n**Square ver.**\\n\\n* Think of a square that inscribes the given circle.\\n* Now, generate random values for *x* and *y*, ranging from `(x_center - radius)` and `(y_center - radius)` to `(x_center - radius) + (radius * 2)` and `(y_center - radius) + (radius * 2)`, respectively.\\n\\t* If the generated random point `point` is outside the area of the circle (`distanceFromCenter(point) > radius`), repeat until the point is located inside the circle.\\n* Return this point.\\n* Please refer to the figure below for easy understanding.\\n\\n![image](https://assets.leetcode.com/users/images/6205bb78-4bbe-4960-b432-64097fa16591_1616057474.5017252.jpeg \"Square\")\\n\\n```\\nclass Solution {\\n    double radius;\\n    double x_center;\\n    double y_center;\\n    \\npublic:\\n    Solution(double radius, double x_center, double y_center): radius(radius), x_center(x_center), y_center(y_center) {\\n\\n    }\\n    \\n    vector<double> randPoint() {\\n        double distance, theta;\\n        vector<double> point;\\n        \\n        distance = sqrt((double)rand() / RAND_MAX) * radius;\\n        theta = ((double)rand() / RAND_MAX) * 2 * M_PI;\\n        \\n        point.push_back(x_center + (distance * cos(theta)));\\n        point.push_back(y_center + (distance * sin(theta)));\\n        \\n        return point;\\n    }\\n};\\n```\\n\\n**Polar coordinate ver.**\\n\\n* Start from the polar coordinate system instead of the familiar Cartesian coordinate system.\\n\\t* [Polar coordinate system](https://en.wikipedia.org/wiki/Polar_coordinate_system \"Wikipedia\")\\n* Generate random `distance` and `theta` in a range of [0,`radius`] and [0,`2 * M_PI`] respectively, and then convert them into the corresponding Cartesian coordinates.\\n* The important thing here is that we need to use `sqrt` when generating a random value for `distance`.\\n\\t* Because the area of a circle is proportional to the square of its radius, the value for `distance` should be generated such that it can compensate for the relative scarcity of the outer area of the circle.\\n\\t* So `sqrt` intentionally makes the distribution of `distance` not linear but quadratic. Please see the figure below.\\n\\n![image](https://assets.leetcode.com/users/images/6a8787b3-e907-419c-bbf9-ae003b97d27e_1616058047.5737827.jpeg)\\n\\n* Return the converted point.\\n\\n</br>\\n\\nThank you for reviewing my code. Any suggestions or advice will be welcome.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double radius;\\n    double x_center;\\n    double y_center;\\n\\n    vector<double> randPointInSquare() const {\\n        vector<double> point;\\n\\n        point.push_back((x_center - radius) + ((double)rand() / RAND_MAX) * (radius * 2));\\n        point.push_back((y_center - radius) + ((double)rand() / RAND_MAX) * (radius * 2));\\n\\n        return point;\\n    }\\n\\n    double distanceFromCenter(vector<double> point) const {\\n        return sqrt(pow(point[0] - x_center, 2) + pow(point[1] - y_center, 2));\\n    }\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) : radius(radius), x_center(x_center), y_center(y_center) {\\n\\n    }\\n\\n    vector<double> randPoint() {\\n        vector<double> point;\\n\\n        do {\\n            point = randPointInSquare();\\n        } while (distanceFromCenter(point) > radius);\\n\\n        return point;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    double radius;\\n    double x_center;\\n    double y_center;\\n    \\npublic:\\n    Solution(double radius, double x_center, double y_center): radius(radius), x_center(x_center), y_center(y_center) {\\n\\n    }\\n    \\n    vector<double> randPoint() {\\n        double distance, theta;\\n        vector<double> point;\\n        \\n        distance = sqrt((double)rand() / RAND_MAX) * radius;\\n        theta = ((double)rand() / RAND_MAX) * 2 * M_PI;\\n        \\n        point.push_back(x_center + (distance * cos(theta)));\\n        point.push_back(y_center + (distance * sin(theta)));\\n        \\n        return point;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115056,
                "title": "python-solution-lowest-memory-use-no-polar-coordinates-with-comments",
                "content": "```\\nclass Solution:\\n    import math\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.r=radius\\n        self.xc=x_center\\n        self.yc=y_center\\n        \\n    \\n    def randPoint(self) -> List[float]:\\n        while True:                                               #coordinates=[r:1,xc:0,yc:0]\\n            X=random.uniform(self.xc - self.r, self.xc + self.r) # choosing a random point between(-1,1) \\n            Y=random.uniform(self.yc - self.r, self.yc + self.r) #choosing a random point between(-1,1) \\n            c=X-self.xc                                           #checking condition for point inside circle\\n            d=Y-self.yc                                          #formula=(x-xc)^2 + (y-yc)^2 < r^2\\n            if (c**2+d**2) < self.r**2:     \\n                return [X,Y]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    import math\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.r=radius\\n        self.xc=x_center\\n        self.yc=y_center\\n        \\n    \\n    def randPoint(self) -> List[float]:\\n        while True:                                               #coordinates=[r:1,xc:0,yc:0]\\n            X=random.uniform(self.xc - self.r, self.xc + self.r) # choosing a random point between(-1,1) \\n            Y=random.uniform(self.yc - self.r, self.yc + self.r) #choosing a random point between(-1,1) \\n            c=X-self.xc                                           #checking condition for point inside circle\\n            d=Y-self.yc                                          #formula=(x-xc)^2 + (y-yc)^2 < r^2\\n            if (c**2+d**2) < self.r**2:     \\n                return [X,Y]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114638,
                "title": "c-polar-coordinates",
                "content": "```\\n    double r;\\n    double x;\\n    double y;\\n    Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        /*\\n         * Logic followed is in polar coordinates, where distance, theta\\n         * are  calculated and are converted to cartesian coordinates as\\n         *  point x = x_center + distance * cos(theta)\\n         *  point y = y_center + distance * sin(theta)\\n         *\\n         * In order to find the theta which ranges in 0 ... 2pi, generate\\n         * a random number in the range of 0..1 and multiple by 2* pi\\n         *\\n         * In order to generate the distance, sqrt(rand() in rang of 0...1)\\n         * multiplied with radius\\n        */\\n        \\n        // sqrt makes uniform distribution\\n        double distance = sqrt((double)rand() / RAND_MAX) * r;\\n        // Generate the theta\\n        double theta = ((double)rand() / RAND_MAX) * 2 * M_PI;\\n        \\n        // Convert the polar coordinates to cartesian coordinates.\\n        return {x + distance * cos(theta), y + distance * sin(theta)};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    double r;\\n    double x;\\n    double y;\\n    Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        /*\\n         * Logic followed is in polar coordinates, where distance, theta\\n         * are  calculated and are converted to cartesian coordinates as\\n         *  point x = x_center + distance * cos(theta)\\n         *  point y = y_center + distance * sin(theta)\\n         *\\n         * In order to find the theta which ranges in 0 ... 2pi, generate\\n         * a random number in the range of 0..1 and multiple by 2* pi\\n         *\\n         * In order to generate the distance, sqrt(rand() in rang of 0...1)\\n         * multiplied with radius\\n        */\\n        \\n        // sqrt makes uniform distribution\\n        double distance = sqrt((double)rand() / RAND_MAX) * r;\\n        // Generate the theta\\n        double theta = ((double)rand() / RAND_MAX) * 2 * M_PI;\\n        \\n        // Convert the polar coordinates to cartesian coordinates.\\n        return {x + distance * cos(theta), y + distance * sin(theta)};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114614,
                "title": "c-any-idea-why-this-fails",
                "content": "Tried in different ways, but I get failing tests when the big ones (=many repetitions) are run, it always passes on the smaller ones, but it just tells me WA, without much further info.\\n\\nThe code - ignore the random number generation, it is the same with `rand()`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    double r, x, y;\\n    random_device rd;\\n    uniform_real_distribution<> rnd = uniform_real_distribution<>(-1.0, 1.0);\\n    Solution(double r, double x, double y) : r(r), x(x), y(y) {\\n        srand(time(NULL));\\n    }\\n    \\n    double rndRng(double a) {\\n        mt19937 gen(rd());\\n        return rnd(gen) * a;\\n    }\\n    \\n    vector<double> randPoint() {\\n        vector<double> res(2);\\n        res[0] = rndRng(r) + x;\\n        res[1] = rndRng(sqrt(pow(r, 2) - pow(abs(res[0] - x), 2))) + y;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    double r, x, y;\\n    random_device rd;\\n    uniform_real_distribution<> rnd = uniform_real_distribution<>(-1.0, 1.0);\\n    Solution(double r, double x, double y) : r(r), x(x), y(y) {\\n        srand(time(NULL));\\n    }\\n    \\n    double rndRng(double a) {\\n        mt19937 gen(rd());\\n        return rnd(gen) * a;\\n    }\\n    \\n    vector<double> randPoint() {\\n        vector<double> res(2);\\n        res[0] = rndRng(r) + x;\\n        res[1] = rndRng(sqrt(pow(r, 2) - pow(abs(res[0] - x), 2))) + y;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114579,
                "title": "javascript-rejection-sampling-faster-than-100",
                "content": "```\\n/**\\n * @param {number} radius\\n * @param {number} x_center\\n * @param {number} y_center\\n */\\nvar Solution = function(radius, x_center, y_center) {\\n  this.radius = radius;\\n  this.x_center = x_center;\\n  this.y_center = y_center;\\n};\\n\\n/**\\n * @return {number[]}\\n */\\nSolution.prototype.randPoint = function() {\\n  const randomX = randRange(this.x_center + this.radius, this.x_center - this.radius);\\n  const randomY = randRange(this.y_center + this.radius, this.y_center - this.radius);\\n  \\n  const distanceInSquares = Math.pow(randomX - this.x_center, 2) + Math.pow(randomY - this.y_center, 2);\\n  const isOutOfTheCircle = distanceInSquares > Math.pow(this.radius, 2);\\n  \\n  if (isOutOfTheCircle)) {\\n    return this.randPoint();\\n  }\\n\\n  return [randomX, randomY];\\n};\\n\\n/** \\n * Your Solution object will be instantiated and called as such:\\n * var obj = new Solution(radius, x_center, y_center)\\n * var param_1 = obj.randPoint()\\n */\\n\\nfunction randRange(maximum, minimum) {\\n  return Math.random() * (maximum - minimum) + minimum;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number} radius\\n * @param {number} x_center\\n * @param {number} y_center\\n */\\nvar Solution = function(radius, x_center, y_center) {\\n  this.radius = radius;\\n  this.x_center = x_center;\\n  this.y_center = y_center;\\n};\\n\\n/**\\n * @return {number[]}\\n */\\nSolution.prototype.randPoint = function() {\\n  const randomX = randRange(this.x_center + this.radius, this.x_center - this.radius);\\n  const randomY = randRange(this.y_center + this.radius, this.y_center - this.radius);\\n  \\n  const distanceInSquares = Math.pow(randomX - this.x_center, 2) + Math.pow(randomY - this.y_center, 2);\\n  const isOutOfTheCircle = distanceInSquares > Math.pow(this.radius, 2);\\n  \\n  if (isOutOfTheCircle)) {\\n    return this.randPoint();\\n  }\\n\\n  return [randomX, randomY];\\n};\\n\\n/** \\n * Your Solution object will be instantiated and called as such:\\n * var obj = new Solution(radius, x_center, y_center)\\n * var param_1 = obj.randPoint()\\n */\\n\\nfunction randRange(maximum, minimum) {\\n  return Math.random() * (maximum - minimum) + minimum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114106,
                "title": "c-solution-generate-random-point-in-a-circle",
                "content": "This is C# implementation as per the explanation given by @fd8783( https://leetcode.com/problems/generate-random-point-in-a-circle/discuss/155650/Explanation-with-Graphs-why-using-Math.sqrt() )\\n```\\npublic class Solution {\\n    double radius = 0;\\n    double x_center = 0;\\n    double y_center =0;\\n    Random random;\\n    public Solution(double radius, double x_center, double y_center) {\\n        this.radius = radius;\\n        this.x_center = x_center;\\n        this.y_center = y_center;        \\n        random = new Random();\\n    }\\n    \\n    public double[] RandPoint() {\\n        double len= Math.Sqrt(random.NextDouble())*radius;\\n        double deg= random.NextDouble()*2*Math.PI;\\n        double x= x_center+len*Math.Cos(deg);\\n        double y= y_center+len*Math.Sin(deg);\\n        return new double[]{x,y};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    double radius = 0;\\n    double x_center = 0;\\n    double y_center =0;\\n    Random random;\\n    public Solution(double radius, double x_center, double y_center) {\\n        this.radius = radius;\\n        this.x_center = x_center;\\n        this.y_center = y_center;        \\n        random = new Random();\\n    }\\n    \\n    public double[] RandPoint() {\\n        double len= Math.Sqrt(random.NextDouble())*radius;\\n        double deg= random.NextDouble()*2*Math.PI;\\n        double x= x_center+len*Math.Cos(deg);\\n        double y= y_center+len*Math.Sin(deg);\\n        return new double[]{x,y};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114061,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        \\n        self.radiusSquared = radius ** 2\\n        self.x_center = x_center\\n        self.y_center = y_center\\n        self.xLeftBoundary = x_center - radius\\n        self.xRightBoundary = x_center + radius\\n        self.yLowerBoundary = y_center - radius\\n        self.yUpperBoundary = y_center + radius\\n        \\n    def randPoint(self) -> List[float]:\\n\\n        x = uniform(self.xLeftBoundary, self.xRightBoundary)\\n        y = uniform(self.yLowerBoundary, self.yUpperBoundary)\\n                \\n        while (x-self.x_center) ** 2 + (y-self.y_center) ** 2 > self.radiusSquared:\\n            x = uniform(self.xLeftBoundary, self.xRightBoundary)\\n            y = uniform(self.yLowerBoundary, self.yUpperBoundary)\\n            \\n        return [x, y]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        \\n        self.radiusSquared = radius ** 2\\n        self.x_center = x_center\\n        self.y_center = y_center\\n        self.xLeftBoundary = x_center - radius\\n        self.xRightBoundary = x_center + radius\\n        self.yLowerBoundary = y_center - radius\\n        self.yUpperBoundary = y_center + radius\\n        \\n    def randPoint(self) -> List[float]:\\n\\n        x = uniform(self.xLeftBoundary, self.xRightBoundary)\\n        y = uniform(self.yLowerBoundary, self.yUpperBoundary)\\n                \\n        while (x-self.x_center) ** 2 + (y-self.y_center) ** 2 > self.radiusSquared:\\n            x = uniform(self.xLeftBoundary, self.xRightBoundary)\\n            y = uniform(self.yLowerBoundary, self.yUpperBoundary)\\n            \\n        return [x, y]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114047,
                "title": "javascript-simple-solution",
                "content": "```\\nvar Solution = function(radius, x_center, y_center) {\\n        this.radius = radius;\\n        this.x_center = x_center;\\n        this.y_center = y_center;\\n};\\n\\nSolution.prototype.randPoint = function() {\\n    let x = 1;\\n    let y = 1;\\n    while(x*x + y*y > 1){\\n        x = 2*Math.random() - 1;\\n        y = 2*Math.random() - 1;\\n    }\\n    return [this.x_center + this.radius*x, this.y_center + this.radius*y]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar Solution = function(radius, x_center, y_center) {\\n        this.radius = radius;\\n        this.x_center = x_center;\\n        this.y_center = y_center;\\n};\\n\\nSolution.prototype.randPoint = function() {\\n    let x = 1;\\n    let y = 1;\\n    while(x*x + y*y > 1){\\n        x = 2*Math.random() - 1;\\n        y = 2*Math.random() - 1;\\n    }\\n    return [this.x_center + this.radius*x, this.y_center + this.radius*y]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114024,
                "title": "c-rejection-sampling",
                "content": "Approach 1: rejection sampling [1]\\n```\\nclass Solution {\\npublic:\\n    Solution(double radius, double x_center, double y_center):_radius(radius), _x_center(x_center), _y_center(y_center)   {}\\n    \\n    vector<double> randPoint() {        \\n        while(true){\\n            double x = (2 * (double) rand()/ RAND_MAX - 1 ) * _radius;\\n            double y = (2 * (double) rand()/ RAND_MAX - 1 ) * _radius;\\n            if(x*x + y*y <= _radius * _radius) return {x + _x_center, y + _y_center};\\n        }\\n        return {};\\n    }\\n    \\nprivate:\\n    double _radius;\\n    double _x_center;\\n    double _y_center;\\n};\\n```\\nReference:\\n[1] https://www.cnblogs.com/grandyang/p/9741220.html",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(double radius, double x_center, double y_center):_radius(radius), _x_center(x_center), _y_center(y_center)   {}\\n    \\n    vector<double> randPoint() {        \\n        while(true){\\n            double x = (2 * (double) rand()/ RAND_MAX - 1 ) * _radius;\\n            double y = (2 * (double) rand()/ RAND_MAX - 1 ) * _radius;\\n            if(x*x + y*y <= _radius * _radius) return {x + _x_center, y + _y_center};\\n        }\\n        return {};\\n    }\\n    \\nprivate:\\n    double _radius;\\n    double _x_center;\\n    double _y_center;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113961,
                "title": "simple-no-math-c-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    double r;\\n    double x;\\n    double y;\\n    Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        double x_, y_;\\n        \\n        do{\\n            double rand_double_x = (double)rand() / RAND_MAX; // Gets random double between [0,1]\\n            double rand_double_y = (double)rand() / RAND_MAX;\\n            x_ = (2*(rand_double_x) - 1.0) * r;   //To get [-1, 1]\\n            y_ = (2*(rand_double_y) - 1.0) * r;   //To get [-1, 1]\\n        } while(x_*x_ + y_*y_ > r*r);\\n        \\n        return {x+x_, y+y_};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double r;\\n    double x;\\n    double y;\\n    Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        double x_, y_;\\n        \\n        do{\\n            double rand_double_x = (double)rand() / RAND_MAX; // Gets random double between [0,1]\\n            double rand_double_y = (double)rand() / RAND_MAX;\\n            x_ = (2*(rand_double_x) - 1.0) * r;   //To get [-1, 1]\\n            y_ = (2*(rand_double_y) - 1.0) * r;   //To get [-1, 1]\\n        } while(x_*x_ + y_*y_ > r*r);\\n        \\n        return {x+x_, y+y_};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113859,
                "title": "10-line-solution-beats-90",
                "content": "```\\nclass Solution {\\nprivate:\\n    double x, y, radius;\\n    std::default_random_engine rng;\\n    uniform_real_distribution<double> uni{0, 2}; // You can have upto twice the radius, so go from 0-2\\npublic:\\n    Solution(double radius, double x_center, double y_center) :  radius(radius), x(x_center), y(y_center) { }\\n    \\n    vector<double> randPoint() {\\n        double xVal = x+radius+1, yVal = y+radius+1; // Some dummy value to make sure whiel loop is taken.\\n        while ((xVal-x)*(xVal-x) + (yVal-y)*(yVal-y) > radius*radius) {\\n            xVal = (x-radius) + uni(rng) * radius;\\n            yVal = (y-radius) + uni(rng) * radius;\\n        }\\n        return {xVal, yVal};\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    double x, y, radius;\\n    std::default_random_engine rng;\\n    uniform_real_distribution<double> uni{0, 2}; // You can have upto twice the radius, so go from 0-2\\npublic:\\n    Solution(double radius, double x_center, double y_center) :  radius(radius), x(x_center), y(y_center) { }\\n    \\n    vector<double> randPoint() {\\n        double xVal = x+radius+1, yVal = y+radius+1; // Some dummy value to make sure whiel loop is taken.\\n        while ((xVal-x)*(xVal-x) + (yVal-y)*(yVal-y) > radius*radius) {\\n            xVal = (x-radius) + uni(rng) * radius;\\n            yVal = (y-radius) + uni(rng) * radius;\\n        }\\n        return {xVal, yVal};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113797,
                "title": "please-no-problems-with-random-generation-issue-with-generate-random-point-in-a-circle",
                "content": "Hello,\\n\\n Using either C# or Java, I\\'m not able to pass test 7 on 8 (input parameters : [0.01, -73839.1, -3289891.3])\\n Expected data being randomly generated, it\\'s impossible to understand the reason why the test failed : have I a duplicate in my answers, a point outside the circle ? \\n \\n I\\'ve used the \"famous\" formula but without results : \\n```\\n return new double[] {\\n            _x + _radius * Math.Cos(angle) ,\\n            _y + _radius * Math.Sin(angle)  \\n        };\\n```\\nI\\'ve even tried to divide the radius by 2 (and by 100) to be sure, the generated point is inside the circle ...\\n\\nDo you encounter the same issue ?\\n\\nThanks\\n \\n",
                "solutionTags": [],
                "code": "```\\n return new double[] {\\n            _x + _radius * Math.Cos(angle) ,\\n            _y + _radius * Math.Sin(angle)  \\n        };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113624,
                "title": "javascript-mathematical-solution",
                "content": "```\\n/**\\n * @param {number} radius\\n * @param {number} x_center\\n * @param {number} y_center\\n */\\nvar Solution = function(radius, x_center, y_center) {\\n    this.x_center = x_center;\\n    this.y_center = y_center;\\n    this.radius = radius;\\n};\\n\\n/**\\n * @return {number[]}\\n */\\nSolution.prototype.randPoint = function() {\\n    let r = this.radius * Math.sqrt(Math.random())\\n    let theta = Math.random() * 2 * Math.PI\\n    let x = this.x_center + r * Math.cos(theta)\\n    let y = this.y_center + r * Math.sin(theta)\\n    return [x, y]\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {number} radius\\n * @param {number} x_center\\n * @param {number} y_center\\n */\\nvar Solution = function(radius, x_center, y_center) {\\n    this.x_center = x_center;\\n    this.y_center = y_center;\\n    this.radius = radius;\\n};\\n\\n/**\\n * @return {number[]}\\n */\\nSolution.prototype.randPoint = function() {\\n    let r = this.radius * Math.sqrt(Math.random())\\n    let theta = Math.random() * 2 * Math.PI\\n    let x = this.x_center + r * Math.cos(theta)\\n    let y = this.y_center + r * Math.sin(theta)\\n    return [x, y]\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1111567,
                "title": "encode-and-decode-tinyurl-c-base-62-two-maps",
                "content": "**Base-62 & two-map method**\\n\\n* Maintain two `unordered_map`s, one to map indices of the original URLs to base-62 encodings and the other to map vice versa.\\n\\t* The base-62 encoding represents each of the values using one of the symbols from a set [0-9A-Za-z].\\n\\n</br>\\n\\n**Function-by-function descriptions**\\n\\n```\\n#define NUM_SYMBOLS 6\\n\\nclass Solution {\\n    const string domain = \"http://tinyurl.com/\";\\n    unordered_map<string, string> orig_to_base62, base62_to_orig;\\n```\\n\\n* `decimalToBase62`:\\n\\t* Convert the decimal number `decimal` to the base-62 representation symbol by symbol, just as we convert the numbers from decimal to binary. Use the ASCII table.\\n\\t* Push to a stack each symbol from the last one, push `\\'0\\'` until the stack has `NUM_SYMBOLS` items, and then return the entire base-62 encoding in correct order.\\n\\n```\\n    string decimalToBase62(int decimal) {\\n        stack<char> stack;\\n        int i, base10;\\n        char base62;\\n        string base62_full;\\n\\n        for (i = decimal; i > 0; i /= 62) {\\n            base10 = i % 62;\\n            if (base10 >= 0 && base10 < 10) {\\n                // 0-9\\n                base62 = base10 + 48;\\n            }\\n            else if (base10 >= 10 && base10 < 36) {\\n                // A-Z\\n                base62 = base10 - 10 + 65;\\n            }\\n            else {\\n                // a-z\\n                base62 = base10 - 36 + 97;\\n            }\\n\\n            stack.push(base62);\\n        }\\n\\n        while (stack.size() < NUM_SYMBOLS) {\\n            stack.push(\\'0\\');\\n        }\\n\\n        while (!stack.empty()) {\\n            base62_full.push_back(stack.top());\\n            stack.pop();\\n        }\\n\\n        return base62_full;\\n    }\\n```\\n\\n* `encode`:\\n\\t* If the key `longUrl` is found in `orig_to_base62`, assign the value of it to `base62`.\\n\\t* Otherwise, convert the index of `longUrl` (i.e., `orig_to_base62.size()`) to a base-62 format using `decimalToBase62`, assign it to `base62`, and populate the pair of `unordered_map`s.\\n\\t* Return `base62` with `domain`.\\n\\n```\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        stringstream ss;\\n        string base62;\\n\\n        if (orig_to_base62.find(longUrl) != orig_to_base62.end()) {\\n            base62 = orig_to_base62[longUrl];\\n        }\\n        else {\\n            base62 = decimalToBase62(orig_to_base62.size());\\n\\n            orig_to_base62[longUrl] = base62;\\n            base62_to_orig[base62] = longUrl;\\n        }\\n\\n        ss << domain << base62;\\n\\n        return ss.str();\\n    }\\n```\\n\\n* `decode`:\\n\\t* If the key `base62`, which is `shortUrl` with its `domain` part stripped away, is found in `base62_to_orig`, assign the value of it to `orig`.\\n\\t* Return `orig`. (If the key `base62` has not been found, it remains as an empty string in this code.)\\n\\n```\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string base62, orig;\\n\\n        base62 = shortUrl.substr(domain.length());\\n        if (base62_to_orig.find(base62) != base62_to_orig.end()) {\\n            orig = base62_to_orig[base62];\\n        }\\n\\n        return orig;\\n    }\\n};\\n```\\n\\n</br>\\n\\n**Full code**\\n```\\n#define NUM_SYMBOLS 6\\n\\nclass Solution {\\n    const string domain = \"http://tinyurl.com/\";\\n    unordered_map<string, string> orig_to_base62, base62_to_orig;\\n\\n    string decimalToBase62(int decimal) {\\n        stack<char> stack;\\n        int i, base10;\\n        char base62;\\n        string base62_full;\\n\\n        for (i = decimal; i > 0; i /= 62) {\\n            base10 = i % 62;\\n            if (base10 >= 0 && base10 < 10) {\\n                // 0-9\\n                base62 = base10 + 48;\\n            }\\n            else if (base10 >= 10 && base10 < 36) {\\n                // A-Z\\n                base62 = base10 - 10 + 65;\\n            }\\n            else {\\n                // a-z\\n                base62 = base10 - 36 + 97;\\n            }\\n\\n            stack.push(base62);\\n        }\\n\\n        while (stack.size() < NUM_SYMBOLS) {\\n            stack.push(\\'0\\');\\n        }\\n\\n        while (!stack.empty()) {\\n            base62_full.push_back(stack.top());\\n            stack.pop();\\n        }\\n\\n        return base62_full;\\n    }\\n    \\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        stringstream ss;\\n        string base62;\\n\\n        if (orig_to_base62.find(longUrl) != orig_to_base62.end()) {\\n            base62 = orig_to_base62[longUrl];\\n        }\\n        else {\\n            base62 = decimalToBase62(orig_to_base62.size());\\n\\n            orig_to_base62[longUrl] = base62;\\n            base62_to_orig[base62] = longUrl;\\n        }\\n\\n        ss << domain << base62;\\n\\n        return ss.str();\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string base62, orig;\\n\\n        base62 = shortUrl.substr(domain.length());\\n        if (base62_to_orig.find(base62) != base62_to_orig.end()) {\\n            orig = base62_to_orig[base62];\\n        }\\n\\n        return orig;\\n    }\\n};\\n```\\n\\n</br>\\n\\n**Space complexity is poor,** but a bit different approach to use the index of each queried URL. Thank you for reviewing my code. Any suggestions or advice will be appreciated. :)",
                "solutionTags": [],
                "code": "```\\n#define NUM_SYMBOLS 6\\n\\nclass Solution {\\n    const string domain = \"http://tinyurl.com/\";\\n    unordered_map<string, string> orig_to_base62, base62_to_orig;\\n```\n```\\n    string decimalToBase62(int decimal) {\\n        stack<char> stack;\\n        int i, base10;\\n        char base62;\\n        string base62_full;\\n\\n        for (i = decimal; i > 0; i /= 62) {\\n            base10 = i % 62;\\n            if (base10 >= 0 && base10 < 10) {\\n                // 0-9\\n                base62 = base10 + 48;\\n            }\\n            else if (base10 >= 10 && base10 < 36) {\\n                // A-Z\\n                base62 = base10 - 10 + 65;\\n            }\\n            else {\\n                // a-z\\n                base62 = base10 - 36 + 97;\\n            }\\n\\n            stack.push(base62);\\n        }\\n\\n        while (stack.size() < NUM_SYMBOLS) {\\n            stack.push(\\'0\\');\\n        }\\n\\n        while (!stack.empty()) {\\n            base62_full.push_back(stack.top());\\n            stack.pop();\\n        }\\n\\n        return base62_full;\\n    }\\n```\n```\\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        stringstream ss;\\n        string base62;\\n\\n        if (orig_to_base62.find(longUrl) != orig_to_base62.end()) {\\n            base62 = orig_to_base62[longUrl];\\n        }\\n        else {\\n            base62 = decimalToBase62(orig_to_base62.size());\\n\\n            orig_to_base62[longUrl] = base62;\\n            base62_to_orig[base62] = longUrl;\\n        }\\n\\n        ss << domain << base62;\\n\\n        return ss.str();\\n    }\\n```\n```\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string base62, orig;\\n\\n        base62 = shortUrl.substr(domain.length());\\n        if (base62_to_orig.find(base62) != base62_to_orig.end()) {\\n            orig = base62_to_orig[base62];\\n        }\\n\\n        return orig;\\n    }\\n};\\n```\n```\\n#define NUM_SYMBOLS 6\\n\\nclass Solution {\\n    const string domain = \"http://tinyurl.com/\";\\n    unordered_map<string, string> orig_to_base62, base62_to_orig;\\n\\n    string decimalToBase62(int decimal) {\\n        stack<char> stack;\\n        int i, base10;\\n        char base62;\\n        string base62_full;\\n\\n        for (i = decimal; i > 0; i /= 62) {\\n            base10 = i % 62;\\n            if (base10 >= 0 && base10 < 10) {\\n                // 0-9\\n                base62 = base10 + 48;\\n            }\\n            else if (base10 >= 10 && base10 < 36) {\\n                // A-Z\\n                base62 = base10 - 10 + 65;\\n            }\\n            else {\\n                // a-z\\n                base62 = base10 - 36 + 97;\\n            }\\n\\n            stack.push(base62);\\n        }\\n\\n        while (stack.size() < NUM_SYMBOLS) {\\n            stack.push(\\'0\\');\\n        }\\n\\n        while (!stack.empty()) {\\n            base62_full.push_back(stack.top());\\n            stack.pop();\\n        }\\n\\n        return base62_full;\\n    }\\n    \\npublic:\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        stringstream ss;\\n        string base62;\\n\\n        if (orig_to_base62.find(longUrl) != orig_to_base62.end()) {\\n            base62 = orig_to_base62[longUrl];\\n        }\\n        else {\\n            base62 = decimalToBase62(orig_to_base62.size());\\n\\n            orig_to_base62[longUrl] = base62;\\n            base62_to_orig[base62] = longUrl;\\n        }\\n\\n        ss << domain << base62;\\n\\n        return ss.str();\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        string base62, orig;\\n\\n        base62 = shortUrl.substr(domain.length());\\n        if (base62_to_orig.find(base62) != base62_to_orig.end()) {\\n            orig = base62_to_orig[base62];\\n        }\\n\\n        return orig;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111020,
                "title": "encodes-a-url-to-a-shortened-url",
                "content": "```\\nclass Solution {\\npublic:\\n      unordered_map<string, string> codeDB, urlDB;\\n    const string chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n\\n    string getCode() {\\n        string code = \"\";\\n        for (int i = 0; i < 6; i++) code += chars[rand() % 62];\\n        return \"http://tinyurl.com/\" + code;\\n    }\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        if (urlDB.find(longUrl) != urlDB.end()) return urlDB[longUrl];\\n        string code = getCode();\\n        while (codeDB.find(code) != codeDB.end()) code = getCode();\\n        codeDB[code] = longUrl;\\n        urlDB[longUrl] = code;\\n        return code;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return codeDB[shortUrl];\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n      unordered_map<string, string> codeDB, urlDB;\\n    const string chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\\n\\n    string getCode() {\\n        string code = \"\";\\n        for (int i = 0; i < 6; i++) code += chars[rand() % 62];\\n        return \"http://tinyurl.com/\" + code;\\n    }\\n\\n    // Encodes a URL to a shortened URL.\\n    string encode(string longUrl) {\\n        if (urlDB.find(longUrl) != urlDB.end()) return urlDB[longUrl];\\n        string code = getCode();\\n        while (codeDB.find(code) != codeDB.end()) code = getCode();\\n        codeDB[code] = longUrl;\\n        urlDB[longUrl] = code;\\n        return code;\\n    }\\n\\n    // Decodes a shortened URL to its original URL.\\n    string decode(string shortUrl) {\\n        return codeDB[shortUrl];\\n    }\\n};\\n\\n// Your Solution object will be instantiated and called as such:\\n// Solution solution;\\n// solution.decode(solution.encode(url));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1058716,
                "title": "go-golang-easy-solution",
                "content": "```\\ntype Solution struct {\\n    radius float64\\n    xMin float64\\n    xMax float64\\n    yMin float64\\n    yMax float64\\n    \\n}\\n\\n\\nfunc Constructor(radius float64, x_center float64, y_center float64) Solution {\\n    rand.Seed(time.Now().UnixNano())\\n    \\n    return Solution {\\n        radius : radius,\\n        xMin : x_center - radius,\\n        xMax : x_center + radius,\\n        yMin : y_center - radius,\\n        yMax : y_center + radius,\\n    }\\n}\\n\\nfunc getRand(min float64, max float64) float64 {\\n    \\n    randomizedRange := min + ((max - min) * rand.Float64())\\n    return randomizedRange\\n}\\n\\nfunc (this *Solution) RandPoint() []float64 {\\n        \\n    x1 := this.xMax - this.radius\\n    y1 := this.yMax - this.radius\\n    \\n    result := []float64{}\\n\\n    for {\\n        x2 := getRand(this.xMin, this.xMax)\\n        y2 := getRand(this.yMin, this.yMax)\\n        \\n        if (x2-x1) * (x2-x1) + (y2-y1) * (y2-y1) <= this.radius * this.radius {\\n            result = append(result, x2, y2)\\n            break\\n        }        \\n    }\\n    \\n    return result\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\ntype Solution struct {\\n    radius float64\\n    xMin float64\\n    xMax float64\\n    yMin float64\\n    yMax float64\\n    \\n}\\n\\n\\nfunc Constructor(radius float64, x_center float64, y_center float64) Solution {\\n    rand.Seed(time.Now().UnixNano())\\n    \\n    return Solution {\\n        radius : radius,\\n        xMin : x_center - radius,\\n        xMax : x_center + radius,\\n        yMin : y_center - radius,\\n        yMax : y_center + radius,\\n    }\\n}\\n\\nfunc getRand(min float64, max float64) float64 {\\n    \\n    randomizedRange := min + ((max - min) * rand.Float64())\\n    return randomizedRange\\n}\\n\\nfunc (this *Solution) RandPoint() []float64 {\\n        \\n    x1 := this.xMax - this.radius\\n    y1 := this.yMax - this.radius\\n    \\n    result := []float64{}\\n\\n    for {\\n        x2 := getRand(this.xMin, this.xMax)\\n        y2 := getRand(this.yMin, this.yMax)\\n        \\n        if (x2-x1) * (x2-x1) + (y2-y1) * (y2-y1) <= this.radius * this.radius {\\n            result = append(result, x2, y2)\\n            break\\n        }        \\n    }\\n    \\n    return result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 974351,
                "title": "don-t-forget-the-perimeter-explanations-with-two-approaches",
                "content": "Let\\'s start from a formalization of the problem description.\\n\\n## Definition\\n\\nHow do we define *a uniform distribution of points in the circle*? \\n\\nConsider points in an area as an infinite (and uncountable) set - and the area represents the *measure* of the set. This is so-called [Lebesgue measure](https://en.wikipedia.org/wiki/Lebesgue_measure) of a 2-dimensional Euclidean space.\\n\\nThe probability of selecting a measurable subset should be given by a probability measure with the whole circle assigned total measure 1. Thus the probability measure of *uniform distribution* can be defined as proportion of the area (Lebesgue measure) of measurable subset to the whole circle.\\n\\n## Proof\\n\\nSince we have established the relationship between probability and area, we only need to find construct a probability distribution whose CDF is equal to the proportion of area.\\n\\nFor convenience, we transform the Cartesian coordinates to polar coordinates. Recall how we do [surface integral for polar coordinates](https://www.math.ucla.edu/~archristian/teaching/32b-sum18/session-2.pdf). The integrand is the reciprocal of the area of circle.\\n\\nCompare it with the [joint PDF](https://en.wikipedia.org/wiki/Probability_density_function#Independence) of two indenpendent random variables. The only difference is `r`, so we only need to construct a distribution with linear PDF from a uniform distribution. This is why we apply square root to a uniformly distributed random variable.\\n\\n## Solution\\n\\n### Closed Range\\n\\nNotice that most random libraries provide a half-closed range. This problem states explicitly that \\n> 3. a point on the circumference of the circle is considered to be in the circle.\\n\\nMost posts made a mistake - they didn\\'t take the upper bound (points on the circumference) into account, because it\\'s exclusive for most standard libraries in programming languages.\\n\\nLet\\'s take a look at Java\\'s [official doc](https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/Math.html#random()) on `Math.random()`:\\n> As the largest double value less than 1.0 is Math.nextDown(1.0), a value x in the closed range [x1,x2] where x1<=x2 may be defined by the statements\\n> ```\\n>  double f = Math.random()/Math.nextDown(1.0);\\n>  double x = x1*(1.0 - f) + x2*f;\\n> ```\\n\\n### Independent Random Variable\\n\\nAnother mistake made by most posts is that pseudorandom numbers are generated from the same sequence when using the same seed.\\n\\nIf both of the Cartesian or polar coordinates are generated using the same seed, they\\'re **NOT** independent random variables any more, which breaks the premise to derive joint PDF.\\n\\nTherefore we should maintain two *independent* random variables with different seeds instead sharing one (like `Math.random()`).\\n\\n### Another Approach: Rejection Sampling\\n\\nRelated problem:\\n- [470. Implement Rand10() Using Rand7()](https://leetcode.com/problems/implement-rand10-using-rand7/)\\n\\nThis problem showed us how to construct a uniformly distributed discrete random variable using another with a larger event space. For continuous case, that applies too. Imagine we\\'re randomly pitching a coin into a square which exactly encompasses the circle, and repeat until the coin falls into the circle.\\n\\nThis is the initial solution I thought of and it\\'s more generalizable. With an average time complexity of O(4/\\u03C0), however, the worst case suffers an infinite time cost.\\n\\n### Implementation\\n\\n#### Polar Coordinates\\n\\n```java\\nclass Solution {\\n    private double xCenter;\\n    private double yCenter;\\n    private double radius;\\n    \\n    private Random rhRandom;\\n    private Random thRandom;\\n\\n    public Solution(double radius, double xCenter, double yCenter) {\\n        this.radius = radius;\\n        this.xCenter = xCenter;\\n        this.yCenter = yCenter;\\n        \\n        rhRandom = new Random();\\n        thRandom = new Random();\\n    }\\n    \\n    public double[] randPoint() {\\n        if (radius <= 0) return new double[0];\\n        \\n        double rho = radius * Math.sqrt(rhRandom.nextDouble() / Math.nextDown(1.0));\\n        double theta = 2 * Math.PI * thRandom.nextDouble();\\n        \\n        double x = xCenter + rho * Math.cos(theta);\\n        double y = yCenter + rho * Math.sin(theta);\\n        \\n        return new double[]{x, y};\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(radius, x_center, y_center);\\n * double[] param_1 = obj.randPoint();\\n */\\n ```\\n\\n\\n#### Rejection Sampling\\n\\n```java\\nclass Solution {\\n    private double xCenter;\\n    private double yCenter;\\n    private double radius;\\n    \\n    private Random xRandom;\\n    private Random yRandom;\\n\\n    public Solution(double radius, double xCenter, double yCenter) {\\n        this.radius = radius;\\n        this.xCenter = xCenter;\\n        this.yCenter = yCenter;\\n        \\n        xRandom = new Random();\\n        yRandom = new Random();\\n    }\\n    \\n    public double[] randPoint() {\\n        if (radius <= 0) return new double[0];\\n        \\n        double xLower = xCenter - radius;\\n        double xUpper = xCenter + radius;\\n        double yLower = yCenter - radius;\\n        double yUpper = yCenter + radius;\\n        \\n        double[] res = new double[2];\\n        \\n        do {\\n            res[0] = generateRandom(xLower, xUpper, xRandom);\\n            res[1] = generateRandom(yLower, yUpper, yRandom);\\n        } while (!inCircle(res[0], res[1]));\\n        \\n        return res;\\n    }\\n    \\n    private boolean inCircle(double x, double y) {\\n        double dist = Math.sqrt(Math.pow(x - xCenter, 2) + Math.pow(y - yCenter, 2));\\n        return dist <= radius;\\n    }\\n    \\n    // lower - inclusive, upper - inclusive\\n    private double generateRandom(double lower, double upper, Random random) {\\n        // Generate [0.0, 1.0] uniformly distributed\\n        double rand = random.nextDouble() / Math.nextDown(1.0);\\n        return lower * (1 - rand) + upper * rand;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(radius, x_center, y_center);\\n * double[] param_1 = obj.randPoint();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n>  double f = Math.random()/Math.nextDown(1.0);\\n>  double x = x1*(1.0 - f) + x2*f;\\n> ```\n```java\\nclass Solution {\\n    private double xCenter;\\n    private double yCenter;\\n    private double radius;\\n    \\n    private Random rhRandom;\\n    private Random thRandom;\\n\\n    public Solution(double radius, double xCenter, double yCenter) {\\n        this.radius = radius;\\n        this.xCenter = xCenter;\\n        this.yCenter = yCenter;\\n        \\n        rhRandom = new Random();\\n        thRandom = new Random();\\n    }\\n    \\n    public double[] randPoint() {\\n        if (radius <= 0) return new double[0];\\n        \\n        double rho = radius * Math.sqrt(rhRandom.nextDouble() / Math.nextDown(1.0));\\n        double theta = 2 * Math.PI * thRandom.nextDouble();\\n        \\n        double x = xCenter + rho * Math.cos(theta);\\n        double y = yCenter + rho * Math.sin(theta);\\n        \\n        return new double[]{x, y};\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(radius, x_center, y_center);\\n * double[] param_1 = obj.randPoint();\\n */\\n ```\n```java\\nclass Solution {\\n    private double xCenter;\\n    private double yCenter;\\n    private double radius;\\n    \\n    private Random xRandom;\\n    private Random yRandom;\\n\\n    public Solution(double radius, double xCenter, double yCenter) {\\n        this.radius = radius;\\n        this.xCenter = xCenter;\\n        this.yCenter = yCenter;\\n        \\n        xRandom = new Random();\\n        yRandom = new Random();\\n    }\\n    \\n    public double[] randPoint() {\\n        if (radius <= 0) return new double[0];\\n        \\n        double xLower = xCenter - radius;\\n        double xUpper = xCenter + radius;\\n        double yLower = yCenter - radius;\\n        double yUpper = yCenter + radius;\\n        \\n        double[] res = new double[2];\\n        \\n        do {\\n            res[0] = generateRandom(xLower, xUpper, xRandom);\\n            res[1] = generateRandom(yLower, yUpper, yRandom);\\n        } while (!inCircle(res[0], res[1]));\\n        \\n        return res;\\n    }\\n    \\n    private boolean inCircle(double x, double y) {\\n        double dist = Math.sqrt(Math.pow(x - xCenter, 2) + Math.pow(y - yCenter, 2));\\n        return dist <= radius;\\n    }\\n    \\n    // lower - inclusive, upper - inclusive\\n    private double generateRandom(double lower, double upper, Random random) {\\n        // Generate [0.0, 1.0] uniformly distributed\\n        double rand = random.nextDouble() / Math.nextDown(1.0);\\n        return lower * (1 - rand) + upper * rand;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(radius, x_center, y_center);\\n * double[] param_1 = obj.randPoint();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928315,
                "title": "python-acceptance-rejection-methods-with-explanation",
                "content": "Basic idea is to sample from the squre that contains the circle; if the points falls out of the circle, reject it and re-generate.\\nThe techinque is commonly used (actually a basic algorithm ) in simuation, statistics, etc.. to generate samples from some distributions where analytical solution is hard to obtain..\\n\\n```\\nfrom random import random\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.x = x_center\\n        self.y = y_center\\n        self.r = radius\\n        self.min_x = self.x - self.r\\n        self.min_y = self.y - self.r        \\n\\n    def randPoint(self) -> List[float]:\\n        rand_x = random()\\n        rand_y = random()\\n        x = 2*self.r * rand_x + self.min_x\\n        y = 2*self.r * rand_y + self.min_y\\n        \\n        while (x-self.x)**2 + (y-self.y) ** 2 > self.r ** 2:\\n            rand_x = random()\\n            rand_y = random()\\n            x = 2*self.r * rand_x + self.min_x\\n            y = 2*self.r * rand_y + self.min_y\\n        return [x, y]",
                "solutionTags": [],
                "code": "Basic idea is to sample from the squre that contains the circle; if the points falls out of the circle, reject it and re-generate.\\nThe techinque is commonly used (actually a basic algorithm ) in simuation, statistics, etc.. to generate samples from some distributions where analytical solution is hard to obtain..\\n\\n```\\nfrom random import random\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.x = x_center\\n        self.y = y_center\\n        self.r = radius\\n        self.min_x = self.x - self.r\\n        self.min_y = self.y - self.r        \\n\\n    def randPoint(self) -> List[float]:\\n        rand_x = random()\\n        rand_y = random()\\n        x = 2*self.r * rand_x + self.min_x\\n        y = 2*self.r * rand_y + self.min_y\\n        \\n        while (x-self.x)**2 + (y-self.y) ** 2 > self.r ** 2:\\n            rand_x = random()\\n            rand_y = random()\\n            x = 2*self.r * rand_x + self.min_x\\n            y = 2*self.r * rand_y + self.min_y\\n        return [x, y]",
                "codeTag": "Java"
            },
            {
                "id": 758308,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    double r;\\n    double cx;\\n    double cy;\\n    const double PI=3.14159265358979732384626433832795;\\n    \\n    Solution(double radius, double x_center, double y_center) {\\n        r=radius;\\n        cx=x_center;\\n        cy=y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        double ok=(double)(rand())/RAND_MAX;\\n        double theta=2*PI*ok;\\n        \\n        double rsz=sqrt((double)(rand())/RAND_MAX);  \\n        \\n        double x=cx+rsz*r*cos(theta);\\n        double y=cy+rsz*r*sin(theta);\\n        \\n        vector<double> ans={x,y};\\n        return ans;\\n        \\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(radius, x_center, y_center);\\n * vector<double> param_1 = obj->randPoint();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double r;\\n    double cx;\\n    double cy;\\n    const double PI=3.14159265358979732384626433832795;\\n    \\n    Solution(double radius, double x_center, double y_center) {\\n        r=radius;\\n        cx=x_center;\\n        cy=y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        double ok=(double)(rand())/RAND_MAX;\\n        double theta=2*PI*ok;\\n        \\n        double rsz=sqrt((double)(rand())/RAND_MAX);  \\n        \\n        double x=cx+rsz*r*cos(theta);\\n        double y=cy+rsz*r*sin(theta);\\n        \\n        vector<double> ans={x,y};\\n        return ans;\\n        \\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(radius, x_center, y_center);\\n * vector<double> param_1 = obj->randPoint();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695240,
                "title": "solved-why-is-the-solution-using-rejection-sampling-wrong",
                "content": "I came up with solution that generate the points randomly in the rectangle inclosing the circle and then use rejection sampling to reject the points who lie farther than distance r from centre of circle. It passed **7/8** test cases and fails for the input : **[0.01, -73839.1, -3289891.3]**\\n```\\nclass Solution {\\nprivate : \\n    double radius, x_c , y_c;\\npublic:\\n    double randR(double a, double b) { // return a double uniformly in [a,b]\\n        return a + (1.0*rand()/RAND_MAX)*(b-a);\\n    }\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        x_c = x_center;\\n        y_c = y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        \\n        double rx = randR(x_c - radius, x_c + radius);\\n        double ry = randR(y_c - radius, y_c + radius);\\n        \\n        while((rx - x_c)*(rx - x_c) + (ry - y_c)*(ry - y_c) > radius*radius) {\\n            rx = randR(x_c - radius, x_c + radius);\\n            ry = randR(y_c - radius, y_c + radius);\\n        }\\n        return vector<double>{rx,ry};\\n    }\\n};\\n```\\n\\nCan you let me know what might be the issue ?\\n\\n**Edit :  The issue is because of Scope of the variable radius. the variable radius inside Solution() takes local scope of variable (function variable) into account and the member variable radius takes some garbage value upon declaration, which causes the issue ( although 7 testcases pass ). If i just change any radius variable to other name it works fine.**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate : \\n    double radius, x_c , y_c;\\npublic:\\n    double randR(double a, double b) { // return a double uniformly in [a,b]\\n        return a + (1.0*rand()/RAND_MAX)*(b-a);\\n    }\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        x_c = x_center;\\n        y_c = y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        \\n        double rx = randR(x_c - radius, x_c + radius);\\n        double ry = randR(y_c - radius, y_c + radius);\\n        \\n        while((rx - x_c)*(rx - x_c) + (ry - y_c)*(ry - y_c) > radius*radius) {\\n            rx = randR(x_c - radius, x_c + radius);\\n            ry = randR(y_c - radius, y_c + radius);\\n        }\\n        return vector<double>{rx,ry};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652270,
                "title": "python-sqrt-uniform-solution",
                "content": "```\\nimport numpy as np\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.radius = radius\\n        self.center = [x_center,y_center]\\n        \\n\\n    def randPoint(self) -> List[float]:\\n        R = self.radius\\n        u = self.center[0]\\n        v = self.center[1]\\n        r = R*math.sqrt(random.uniform(0,1))\\n        theta = random.randint(0,360)\\n        return [r*np.cos(np.deg2rad(theta)) + u,r*np.sin(np.deg2rad(theta))+v]\\n\\t\\t\\n\\t\\t```\\n\\t\\t\\n\\t\\t```\\n\\t\\thttps://stackoverflow.com/questions/5837572/generate-a-random-point-within-a-circle-uniformly\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.radius = radius\\n        self.center = [x_center,y_center]\\n        \\n\\n    def randPoint(self) -> List[float]:\\n        R = self.radius\\n        u = self.center[0]\\n        v = self.center[1]\\n        r = R*math.sqrt(random.uniform(0,1))\\n        theta = random.randint(0,360)\\n        return [r*np.cos(np.deg2rad(theta)) + u,r*np.sin(np.deg2rad(theta))+v]\\n\\t\\t\\n\\t\\t```\n```\\n\\t\\thttps://stackoverflow.com/questions/5837572/generate-a-random-point-within-a-circle-uniformly\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 523550,
                "title": "simple-java",
                "content": "```\\nclass Solution {\\n    \\n    double x;\\n    double y;\\n    double r;\\n    Random rand;\\n\\n    public Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n        \\n        rand = new Random(System.currentTimeMillis());\\n    }\\n    \\n    public double[] randPoint() {\\n        double[] ret = new double[2];\\n        do {\\n            ret[0] = rand.nextDouble() * 2 * r - r;\\n            ret[1] = rand.nextDouble() * 2 * r - r;\\n        } while (Math.sqrt(ret[0]*ret[0] + ret[1]*ret[1]) > r);\\n        \\n        ret[0] += x;\\n        ret[1] += y;\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    double x;\\n    double y;\\n    double r;\\n    Random rand;\\n\\n    public Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n        \\n        rand = new Random(System.currentTimeMillis());\\n    }\\n    \\n    public double[] randPoint() {\\n        double[] ret = new double[2];\\n        do {\\n            ret[0] = rand.nextDouble() * 2 * r - r;\\n            ret[1] = rand.nextDouble() * 2 * r - r;\\n        } while (Math.sqrt(ret[0]*ret[0] + ret[1]*ret[1]) > r);\\n        \\n        ret[0] += x;\\n        ret[1] += y;\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507870,
                "title": "pure-mathematical-solution-without-rejection-memory-100",
                "content": "The code is only for fun purpose...\\nOnly to show how to solve the problem by mathematics and computational science.\\n\\nFirstly we must understand that for a circle, uniform distributed X or Y are not leading to a uniform distribution on the circle support. That is to say if we really want to start with two generated random variables from uniform distribution, we must tranform either (or both).\\n\\nIt is obvious that the probabiliy density function in the circle support f(x,y)=1/(2 * pi * radius * radius), but there should be infinite combinations of random variable X and Y that satisfy the condition.\\n\\nMy solution is that, I assume the conditional distribution of Y|X as uniform on the support, then try to solve for the unconditional distribution of X.\\n\\nTo make notation easier, I normalize x_center=y_center=0 and radius=1 without loss of generality.\\n\\nGiven the assumption of uniform Y|X, and f(x,y) is known constant, f(x) is derived to be (x * sqrt(1-x * x)) * 2/pi . And further the cumulative distribution function F(x) is calculated by integration as (x * sqrt(1-x * x) + arcsin(x)) / pi + 0.5, where the support of x is [-1, 1]. \\n\\nThe inverse mapping of F(x) of a uniform distributed variable is equivalent to an X generated by the previous distribution. (Proof omitted, search for it if you\\'re interested in the transform)\\n\\nAlthough there is not analytical solution for the inverse mapping, given the monotonicity of CDF, bounded binary search is fast enough to find the solution satisfying tolerance.\\n\\nThere are several small changes to the algorithm I described above, but one should be able to follow with those basic ideas.\\n\\nP.S. good kids please don\\'t follow this...\\n\\n\\n```\\nclass Solution {\\n\\n  double r, xC, yC;\\n  public Solution(double radius, double x_center, double y_center) {\\n    r=radius;\\n    xC=x_center;\\n    yC=y_center;\\n  }\\n  \\n  public double[] randPoint() {\\n    double tempX=Math.random()-0.5, tempY=(Math.random()-0.5)*2;\\n    double x=binarySearch(tempX);\\n    double y=Math.sqrt(1-x*x)*tempY;\\n    double[] res=new double[]{xC+r*x, yC+r*y};\\n    return res;\\n  }\\n\\n  private double binarySearch(double target) {\\n    double left=-1, right=1, err=1, x=0;\\n    while (Math.abs(err)>1e-8) {\\n      x=(left+right)/2;\\n      err=cdf(x)-target;\\n      if (err>0)\\n        right=x;\\n      else\\n        left=x;\\n    }\\n    return x;\\n  }\\n\\n  private double cdf(double x) {\\n    return  (x*Math.sqrt(1-x*x)+Math.asin(x))/Math.PI;\\n  }\\n}\\n```\\n\\n\\nA simpler version by polar coordinates with no iteration. 98% runtime.\\n\\nx=cos(theta) * dist; y=sin(theta) * dist;\\n\\n\\n```\\nclass Solution {\\n  double r, xC, yC;\\n  public Solution(double radius, double x_center, double y_center) {\\n    r=radius;\\n    xC=x_center;\\n    yC=y_center;\\n  }\\n  \\n  public double[] randPoint() {\\n    double theta=2*Math.PI*(Math.random()-0.5), dist=Math.sqrt(Math.random());\\n    double x=Math.cos(theta)*dist, y=Math.sin(theta)*dist;\\n    return new double[]{xC+r*x, yC+r*y};\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n  double r, xC, yC;\\n  public Solution(double radius, double x_center, double y_center) {\\n    r=radius;\\n    xC=x_center;\\n    yC=y_center;\\n  }\\n  \\n  public double[] randPoint() {\\n    double tempX=Math.random()-0.5, tempY=(Math.random()-0.5)*2;\\n    double x=binarySearch(tempX);\\n    double y=Math.sqrt(1-x*x)*tempY;\\n    double[] res=new double[]{xC+r*x, yC+r*y};\\n    return res;\\n  }\\n\\n  private double binarySearch(double target) {\\n    double left=-1, right=1, err=1, x=0;\\n    while (Math.abs(err)>1e-8) {\\n      x=(left+right)/2;\\n      err=cdf(x)-target;\\n      if (err>0)\\n        right=x;\\n      else\\n        left=x;\\n    }\\n    return x;\\n  }\\n\\n  private double cdf(double x) {\\n    return  (x*Math.sqrt(1-x*x)+Math.asin(x))/Math.PI;\\n  }\\n}\\n```\n```\\nclass Solution {\\n  double r, xC, yC;\\n  public Solution(double radius, double x_center, double y_center) {\\n    r=radius;\\n    xC=x_center;\\n    yC=y_center;\\n  }\\n  \\n  public double[] randPoint() {\\n    double theta=2*Math.PI*(Math.random()-0.5), dist=Math.sqrt(Math.random());\\n    double x=Math.cos(theta)*dist, y=Math.sin(theta)*dist;\\n    return new double[]{xC+r*x, yC+r*y};\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497974,
                "title": "simple-python-solution-with-minimum-library-use-92-faster",
                "content": "\\n```\\nimport random\\n\\nclass Solution:\\n\\n\\tdef __init__(self, radius: float, x_center: float, y_center: float):\\n\\t\\tself.radius = radius\\n\\t\\tself.xc = x_center\\n\\t\\tself.yc = y_center\\n\\n\\tdef randPoint(self) -> list:\\n\\t\\twhile True:\\n\\t\\t\\trx = (random.random() - 0.5) * 2\\n\\t\\t\\try = (random.random() - 0.5) * 2\\n\\t\\t\\t\\n\\t\\t\\tif ((rx**2) + (ry**2)) <= 1:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\treturn [rx*self.radius+self.xc, ry*self.radius+self.yc]\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport random\\n\\nclass Solution:\\n\\n\\tdef __init__(self, radius: float, x_center: float, y_center: float):\\n\\t\\tself.radius = radius\\n\\t\\tself.xc = x_center\\n\\t\\tself.yc = y_center\\n\\n\\tdef randPoint(self) -> list:\\n\\t\\twhile True:\\n\\t\\t\\trx = (random.random() - 0.5) * 2\\n\\t\\t\\try = (random.random() - 0.5) * 2\\n\\t\\t\\t\\n\\t\\t\\tif ((rx**2) + (ry**2)) <= 1:\\n\\t\\t\\t\\tbreak\\n\\n\\t\\treturn [rx*self.radius+self.xc, ry*self.radius+self.yc]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483152,
                "title": "c-82",
                "content": "class Solution \\n{\\n    public:\\n    \\n    Solution(double radius, double x_center, double y_center) \\n    {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n        dist = std::uniform_real_distribution<double>(-r, r);\\n    }\\n    \\n    std::vector<double> randPoint() \\n    {\\n        while(true)\\n        {   \\n            const double x1 = dist(gen);\\n            const double y1 = dist(gen);\\n            const double rp2 = std::pow(r, 2.0);\\n\\n            if(std::pow(x1, 2.0) + std::pow(y1, 2.0) <= rp2)\\n            {      \\n                return {x + x1, y + y1};\\n            }\\n        }\\n        \\n        return std::vector<double>();\\n    }\\n    \\n    private:\\n    \\n    double r;\\n    double x;\\n    double y;\\n    std::default_random_engine gen;\\n    std::uniform_real_distribution<double> dist;\\n    \\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(radius, x_center, y_center);\\n * vector<double> param_1 = obj->randPoint();\\n */",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution \\n{\\n    public:\\n    \\n    Solution(double radius, double x_center, double y_center) \\n    {\\n        r = radius;\\n        x = x_center;\\n        y = y_center;\\n        dist = std::uniform_real_distribution<double>(-r, r);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 400358,
                "title": "python-how-many-points",
                "content": "**approach 1** \\n\\n\\n**what goes on?**\\nthere are more points on a larger circle \\nany larger circle should \"occur\" more\\n\\n**how many points (total) are choosable?**\\nthe area of the disk thats centered at (x,y)\\n```pi r ^ 2``` \\n\\n\\n**choose a random disk area between 0 and max**\\nchoose a random value v between 0 and ```pi r ^ 2```\\n\\n```0 <= v <= pi R ^ 2```\\n\\n**whats the radius of that disk?**\\nlet the radius be r\\n```\\nv = pi * r ** 2\\nr = (v/pi) ** 0.5\\n```\\n\\n**then**\\nx = xc + rcos(theta)\\nx = yx + ysin(theta)\\nwhere theta is a random angle in radius (at most 2 pi = 360 deg) \\n\\n\\n\\n```\\nclass Solution(object):\\n\\n    def __init__(self, radius, x_center, y_center):\\n        self.r = radius\\n        self.x = x_center\\n        self.y = y_center\\n\\n    def randPoint(self):\\n        r = (self.randomize(0, math.pi * self.r ** 2) / math.pi) ** 0.5\\n        theta = self.randomize(0, 2 * math.pi)\\n        return [self.x + r * math.cos(theta), self.y + r * math.sin(theta)]\\n        \\n\\n    def randomize(self,a,b):\\n        return random.uniform(a, b)\\n```\\n\\n\\n**approach 2**\\n\\ngenerate a random point within a square centered around xc,yc\\nas long as it does not sit within disk : keep generating",
                "solutionTags": [],
                "code": "```pi r ^ 2```\n```pi r ^ 2```\n```0 <= v <= pi R ^ 2```\n```\\nv = pi * r ** 2\\nr = (v/pi) ** 0.5\\n```\n```\\nclass Solution(object):\\n\\n    def __init__(self, radius, x_center, y_center):\\n        self.r = radius\\n        self.x = x_center\\n        self.y = y_center\\n\\n    def randPoint(self):\\n        r = (self.randomize(0, math.pi * self.r ** 2) / math.pi) ** 0.5\\n        theta = self.randomize(0, 2 * math.pi)\\n        return [self.x + r * math.cos(theta), self.y + r * math.sin(theta)]\\n        \\n\\n    def randomize(self,a,b):\\n        return random.uniform(a, b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319915,
                "title": "can-you-tell-me-why-my-answer-is-wrong",
                "content": "class Solution {\\n    double radius;\\n    double x_center;\\n    double y_center;\\n\\n    public Solution(double radius, double x_center, double y_center) {\\n        this.radius = radius;\\n        this.x_center = x_center;\\n        this.y_center = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double delta_x = (Math.random() * 2 - 1) * radius;\\n        double delta_y = Math.sqrt(radius * radius - delta_x * delta_x);\\n        int side = (int)(Math.random() * 2);\\n        if(side == 0) {\\n            return new double[]{x_center + delta_x, y_center + delta_y};\\n        } else {\\n            return new double[]{x_center + delta_x, y_center - delta_y};\\n        }\\n        \\n    }\\n}\\n\\nI first randomly generate x offset in the range -radius to radius. Then caluculate y offset based on x offset and radius.\\nSince y offset can be either positive or negative too, I use this line:  \"int side = (int)(Math.random() * 2);\" to get a number of either 0 or 1 with equal probability to determin wheter is positive y offset or negative y offset. But I failed to pass the last test case.",
                "solutionTags": [],
                "code": "class Solution {\\n    double radius;\\n    double x_center;\\n    double y_center;\\n\\n    public Solution(double radius, double x_center, double y_center) {\\n        this.radius = radius;\\n        this.x_center = x_center;\\n        this.y_center = y_center;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 316048,
                "title": "simple-python-for-middle-school-math-problem",
                "content": "```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        \\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n        \\n    def randPoint(self) -> List[float]:\\n        while True:\\n            x, y = random.uniform(-self.radius, self.radius), random.uniform(-self.radius, self.radius)\\n            if x*x + y*y <= self.radius*self.radius:\\n                return [x+self.x_center, y+self.y_center]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        \\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n        \\n    def randPoint(self) -> List[float]:\\n        while True:\\n            x, y = random.uniform(-self.radius, self.radius), random.uniform(-self.radius, self.radius)\\n            if x*x + y*y <= self.radius*self.radius:\\n                return [x+self.x_center, y+self.y_center]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251986,
                "title": "fast-and-simple-non-deterministic-solution",
                "content": "I sample randomly within the the square with side length `2 * radius` and center `(x_center, y_center)`. If the chosen `(x, y)` pair is not inside the circle I try again until I get a pair inside the circle and then I return that. The probability of not getting a pair inside the circle is `(4 - pi)/4` which is less than `1/4`. Then, on average, it takes `4/pi = 1.27` attempts (if I did my calculations correctly using the definition of expected value) to get a point inside the circle, i.e. you get it almost immediately.\\nMy code is:\\n```java\\nclass Solution {\\n    private double radius;\\n    private double x_center;\\n    private double y_center;\\n    private Random r;\\n    \\n    public Solution(double radius, double x_center, double y_center) {\\n        this.radius = radius;\\n        this.x_center = x_center;\\n        this.y_center = y_center;\\n        this.r = new Random();\\n    }\\n    \\n    private boolean isInCircle(double x, double y) {\\n        double xDist = x - x_center;\\n        double yDist = y - y_center;\\n        return xDist * xDist + yDist * yDist <= radius * radius;\\n    }\\n    \\n    private double getRandom(double center) {\\n        double randDistFromR = r.nextDouble() * radius * 2;\\n        \\n        return center - radius + randDistFromR;\\n    }\\n    \\n\\t// Loop executes 4/pi times on average\\n    public double[] randPoint() {\\n        double x;\\n        double y;\\n        \\n        do {\\n            x = getRandom(x_center);\\n            y = getRandom(y_center);\\n        } while (!isInCircle(x, y));\\n        \\n        return new double[]{x, y};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    private double radius;\\n    private double x_center;\\n    private double y_center;\\n    private Random r;\\n    \\n    public Solution(double radius, double x_center, double y_center) {\\n        this.radius = radius;\\n        this.x_center = x_center;\\n        this.y_center = y_center;\\n        this.r = new Random();\\n    }\\n    \\n    private boolean isInCircle(double x, double y) {\\n        double xDist = x - x_center;\\n        double yDist = y - y_center;\\n        return xDist * xDist + yDist * yDist <= radius * radius;\\n    }\\n    \\n    private double getRandom(double center) {\\n        double randDistFromR = r.nextDouble() * radius * 2;\\n        \\n        return center - radius + randDistFromR;\\n    }\\n    \\n\\t// Loop executes 4/pi times on average\\n    public double[] randPoint() {\\n        double x;\\n        double y;\\n        \\n        do {\\n            x = getRandom(x_center);\\n            y = getRandom(y_center);\\n        } while (!isInCircle(x, y));\\n        \\n        return new double[]{x, y};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222373,
                "title": "java-short-solution",
                "content": "```\\nclass Solution {\\n    double r;\\n    double x;\\n    double y;\\n    public Solution(double radius, double x_center, double y_center) {\\n        this.r = radius;\\n        this.x = x_center;\\n        this.y = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double area = (double)Math.random()*Math.PI*r*r;\\n        \\n        double cur_r = Math.sqrt(area/Math.PI);\\n        \\n        double rad = Math.random()*2*Math.PI;\\n        \\n        \\n        return new double[]{Math.cos(rad)*cur_r+x, Math.sin(rad)*cur_r+y};\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(radius, x_center, y_center);\\n * double[] param_1 = obj.randPoint();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double r;\\n    double x;\\n    double y;\\n    public Solution(double radius, double x_center, double y_center) {\\n        this.r = radius;\\n        this.x = x_center;\\n        this.y = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double area = (double)Math.random()*Math.PI*r*r;\\n        \\n        double cur_r = Math.sqrt(area/Math.PI);\\n        \\n        double rad = Math.random()*2*Math.PI;\\n        \\n        \\n        return new double[]{Math.cos(rad)*cur_r+x, Math.sin(rad)*cur_r+y};\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(radius, x_center, y_center);\\n * double[] param_1 = obj.randPoint();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 207859,
                "title": "python-careful-about-random",
                "content": "```\\nfrom random import uniform, random\\nimport math\\nclass Solution:\\n\\n    def __init__(self, radius, x_center, y_center):\\n        \"\"\"\\n        :type radius: float\\n        :type x_center: float\\n        :type y_center: float\\n        \"\"\"\\n        self.r = radius\\n        self.x = x_center\\n        self.y = y_center\\n        \\n\\n    def randPoint(self):\\n        \"\"\"\\n        :rtype: List[float]\\n        \"\"\"\\n        a = uniform(0, 2*math.pi)\\n        rr = (uniform(0, self.r**2))**(1/2)\\n        return [self.x + rr  * math.cos(a), self.y + rr * math.sin(a)]\\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(radius, x_center, y_center)\\n# param_1 = obj.randPoint()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom random import uniform, random\\nimport math\\nclass Solution:\\n\\n    def __init__(self, radius, x_center, y_center):\\n        \"\"\"\\n        :type radius: float\\n        :type x_center: float\\n        :type y_center: float\\n        \"\"\"\\n        self.r = radius\\n        self.x = x_center\\n        self.y = y_center\\n        \\n\\n    def randPoint(self):\\n        \"\"\"\\n        :rtype: List[float]\\n        \"\"\"\\n        a = uniform(0, 2*math.pi)\\n        rr = (uniform(0, self.r**2))**(1/2)\\n        return [self.x + rr  * math.cos(a), self.y + rr * math.sin(a)]\\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(radius, x_center, y_center)\\n# param_1 = obj.randPoint()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 174867,
                "title": "python-pure-math-without-sqrt",
                "content": "I used the triangular random generator instead of the sqrt approach.\\n\\n\\n```\\nclass Solution(object):\\n\\n    def __init__(self, radius, x_center, y_center):\\n        \"\"\"\\n        :type radius: float\\n        :type x_center: float\\n        :type y_center: float\\n        \"\"\"\\n        self.r = radius\\n        self.x = x_center\\n        self.y = y_center\\n        \\n\\n    def randPoint(self):\\n        \"\"\"\\n        :rtype: List[float]\\n        \"\"\"\\n        # R is triangular distribution \\n        # Think about thing ring area, which is linear to distance from center\\n        # thena is uniform\\n        \\n        # Third param is peak point\\n        r = random.triangular(0, self.r, self.r) \\n        theta = random.uniform(-math.pi, math.pi)\\n        return [self.x + r * math.cos(theta), self.y + r * math.sin(theta)]\\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(radius, x_center, y_center)\\n# param_1 = obj.randPoint()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def __init__(self, radius, x_center, y_center):\\n        \"\"\"\\n        :type radius: float\\n        :type x_center: float\\n        :type y_center: float\\n        \"\"\"\\n        self.r = radius\\n        self.x = x_center\\n        self.y = y_center\\n        \\n\\n    def randPoint(self):\\n        \"\"\"\\n        :rtype: List[float]\\n        \"\"\"\\n        # R is triangular distribution \\n        # Think about thing ring area, which is linear to distance from center\\n        # thena is uniform\\n        \\n        # Third param is peak point\\n        r = random.triangular(0, self.r, self.r) \\n        theta = random.uniform(-math.pi, math.pi)\\n        return [self.x + r * math.cos(theta), self.y + r * math.sin(theta)]\\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(radius, x_center, y_center)\\n# param_1 = obj.randPoint()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 174566,
                "title": "java-solution-based-on-rejection-sampling",
                "content": "```\\nclass Solution {\\n    double r;\\n    double x0;\\n    double y0;\\n    public Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x0 = x_center;\\n        y0 = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double x = 0,y=0;\\n        do{\\n            x = -r + 2*r*Math.random();\\n            y = -r + 2*r*Math.random();\\n        }while(x*x + y*y > r*r);\\n        return new double[]{x0+x,y0+y};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    double r;\\n    double x0;\\n    double y0;\\n    public Solution(double radius, double x_center, double y_center) {\\n        r = radius;\\n        x0 = x_center;\\n        y0 = y_center;\\n    }\\n    \\n    public double[] randPoint() {\\n        double x = 0,y=0;\\n        do{\\n            x = -r + 2*r*Math.random();\\n            y = -r + 2*r*Math.random();\\n        }while(x*x + y*y > r*r);\\n        return new double[]{x0+x,y0+y};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154790,
                "title": "reject-sampling-solution",
                "content": "\\\\_(:\\u0437\\u300D\\u2220)\\\\_\\n\\nIt is hard to come up with a **correct** solution using polar coordinates. https://leetcode.com/problems/generate-random-point-in-a-circle/discuss/154037/Polar-Coordinates-10-lines\\n\\nA simple and correct solution is, using **reject sampling**.\\nRepeat sampling a random point in a square, until the point locates in the circle:\\n\\n```\\nvar Solution = function(radius, x_center, y_center) {\\n    this.radius = radius;\\n    this.x_center = x_center;\\n    this.y_center = y_center;\\n};\\n\\nSolution.prototype.randPoint = function() {\\n    let x = (2 * Math.random() - 1) * this.radius;\\n    let y = (2 * Math.random() - 1) * this.radius;\\n    if (x * x + y * y > Math.pow(this.radius, 2)) return this.randPoint();\\n    return [x + this.x_center, y + this.y_center];\\n};\\n\\n// I use Javascript because generating random numbers in C++ is too complex...\\n```\\n\\nFollow up:\\nHow can you generate a random 3D point:\\n1. in a ball?\\n2. on a sphere?",
                "solutionTags": [],
                "code": "```\\nvar Solution = function(radius, x_center, y_center) {\\n    this.radius = radius;\\n    this.x_center = x_center;\\n    this.y_center = y_center;\\n};\\n\\nSolution.prototype.randPoint = function() {\\n    let x = (2 * Math.random() - 1) * this.radius;\\n    let y = (2 * Math.random() - 1) * this.radius;\\n    if (x * x + y * y > Math.pow(this.radius, 2)) return this.randPoint();\\n    return [x + this.x_center, y + this.y_center];\\n};\\n\\n// I use Javascript because generating random numbers in C++ is too complex...\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 154473,
                "title": "simple-java-solution-with-explanation",
                "content": "The solution is simple as follows:\\n1- Define the max and min range of Xs and Ys. \\n2- Use Random double to get a random value. The popular formula to get a random double value between a range is : double randomValue = rangeMin + (rangeMax - rangeMin) * r.nextDouble();\\nHowever, since the rangeMin can be negative, I have changed it to\\n rangeMax + (rangeMin-rangeMax) * r.nextDouble(); and simplified it as :\\n x_min=-2*radius; x_max=radius+x_center;\\n y_min=-2*radius; y_max=radius+y_center; \\n 3- Now everytime you get a random X & Y, make sure the distance of the random point to the center is in the max range. The formula is:\\n  Distance =\\u221A(x2\\u2212centerX)^2+(y2\\u2212centerY)^2  which is equals to Radius^2=(x2\\u2212centerX)^2+(y2\\u2212centerY)^2\\n```\\n            Random random; double x_min=0,x_max=0,y_min=0,y_max=0,r2=0,x_center,y_center;\\n\\t    public Solution(double radius, double x_center, double y_center) {\\n\\t        random=new Random();\\n\\t        this.x_center=x_center; this.y_center=y_center;\\n                x_min=-2*radius; x_max=radius+x_center;\\n\\t        y_min=-2*radius; y_max=radius+y_center; \\n                r2=radius*radius; // max distance of two points possible            \\n\\t    }\\t    \\n\\t    public double[] randPoint() {\\n\\t    \\tdouble x = (random.nextDouble())*x_min+x_max;\\n\\t    \\tdouble y = (random.nextDouble())*y_min+y_max;\\t\\n            while((x-x_center)*(x-x_center)+(y-y_center)*(y-y_center)>=r2){ //Make sure the distance between the random point and the center is in the range\\n                x = (random.nextDouble())*x_min+x_max;\\n\\t    \\ty = (random.nextDouble())*y_min+y_max;\\t\\n            }\\n\\t        return new double[]{x,y};\\n\\t    } \\n```",
                "solutionTags": [],
                "code": "```\\n            Random random; double x_min=0,x_max=0,y_min=0,y_max=0,r2=0,x_center,y_center;\\n\\t    public Solution(double radius, double x_center, double y_center) {\\n\\t        random=new Random();\\n\\t        this.x_center=x_center; this.y_center=y_center;\\n                x_min=-2*radius; x_max=radius+x_center;\\n\\t        y_min=-2*radius; y_max=radius+y_center; \\n                r2=radius*radius; // max distance of two points possible            \\n\\t    }\\t    \\n\\t    public double[] randPoint() {\\n\\t    \\tdouble x = (random.nextDouble())*x_min+x_max;\\n\\t    \\tdouble y = (random.nextDouble())*y_min+y_max;\\t\\n            while((x-x_center)*(x-x_center)+(y-y_center)*(y-y_center)>=r2){ //Make sure the distance between the random point and the center is in the range\\n                x = (random.nextDouble())*x_min+x_max;\\n\\t    \\ty = (random.nextDouble())*y_min+y_max;\\t\\n            }\\n\\t        return new double[]{x,y};\\n\\t    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4071138,
                "title": "c-discard-random-coordinate-not-in-circle-189ms-100",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    Random rnd = new ();\\n    double radius;\\n    double radiusPow2;\\n    double x_center; \\n    double y_center;\\n\\n    public Solution(double radius, double x_center, double y_center) {\\n        this.radius = radius;\\n        this.radiusPow2 = radius * radius;\\n        this.x_center = x_center;\\n        this.y_center = y_center;\\n    }\\n    \\n    public double[] RandPoint() \\n    {\\n        var (a1, a2) = (rnd.NextDouble() * radius, rnd.NextDouble() * radius);\\n\\n        if(a1*a1 + a2*a2 > radiusPow2)\\n            return this.RandPoint();\\n\\n        return rnd.Next(4) switch\\n        {\\n            0 => new double[] { x_center + a1, y_center + a2 },\\n            1 => new double[] { x_center + a1, y_center - a2 },\\n            2 => new double[] { x_center - a1, y_center - a2 },\\n            _ => new double[] { x_center - a1, y_center + a2 },\\n        };\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    Random rnd = new ();\\n    double radius;\\n    double radiusPow2;\\n    double x_center; \\n    double y_center;\\n\\n    public Solution(double radius, double x_center, double y_center) {\\n        this.radius = radius;\\n        this.radiusPow2 = radius * radius;\\n        this.x_center = x_center;\\n        this.y_center = y_center;\\n    }\\n    \\n    public double[] RandPoint() \\n    {\\n        var (a1, a2) = (rnd.NextDouble() * radius, rnd.NextDouble() * radius);\\n\\n        if(a1*a1 + a2*a2 > radiusPow2)\\n            return this.RandPoint();\\n\\n        return rnd.Next(4) switch\\n        {\\n            0 => new double[] { x_center + a1, y_center + a2 },\\n            1 => new double[] { x_center + a1, y_center - a2 },\\n            2 => new double[] { x_center - a1, y_center - a2 },\\n            _ => new double[] { x_center - a1, y_center + a2 },\\n        };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054160,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} radius\\n * @param {number} x_center\\n * @param {number} y_center\\n */\\nvar Solution = function(radius, x_center, y_center) {\\n    this.radius = radius;\\n    this.x_center = x_center;\\n    this.y_center = y_center;\\n};\\n\\n/**\\n * @return {number[]}\\n */\\nSolution.prototype.randPoint = function() {\\n    let x = 1;\\n    let y = 1;\\n    while(x*x + y*y > 1){\\n        x = 2*Math.random() - 1;\\n        y = 2*Math.random() - 1;\\n    }\\n    return [this.x_center + this.radius*x, this.y_center + this.radius*y]\\n};\\n\\n/** \\n * Your Solution object will be instantiated and called as such:\\n * var obj = new Solution(radius, x_center, y_center)\\n * var param_1 = obj.randPoint()\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} radius\\n * @param {number} x_center\\n * @param {number} y_center\\n */\\nvar Solution = function(radius, x_center, y_center) {\\n    this.radius = radius;\\n    this.x_center = x_center;\\n    this.y_center = y_center;\\n};\\n\\n/**\\n * @return {number[]}\\n */\\nSolution.prototype.randPoint = function() {\\n    let x = 1;\\n    let y = 1;\\n    while(x*x + y*y > 1){\\n        x = 2*Math.random() - 1;\\n        y = 2*Math.random() - 1;\\n    }\\n    return [this.x_center + this.radius*x, this.y_center + this.radius*y]\\n};\\n\\n/** \\n * Your Solution object will be instantiated and called as such:\\n * var obj = new Solution(radius, x_center, y_center)\\n * var param_1 = obj.randPoint()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976947,
                "title": "best-java-solution-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double RAD, XC, YC;\\n    public Solution(double radius, double x_center, double y_center) {\\n        RAD = radius;\\n        XC = x_center;\\n        YC = y_center;\\n    }\\n    public double[] randPoint() {\\n        double ang = Math.random() * 2 * Math.PI,\\n            hyp = Math.sqrt(Math.random()) * RAD,\\n            adj = Math.cos(ang) * hyp,\\n            opp = Math.sin(ang) * hyp;\\n        return new double[]{XC + adj, YC + opp};\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(radius, x_center, y_center);\\n * double[] param_1 = obj.randPoint();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    double RAD, XC, YC;\\n    public Solution(double radius, double x_center, double y_center) {\\n        RAD = radius;\\n        XC = x_center;\\n        YC = y_center;\\n    }\\n    public double[] randPoint() {\\n        double ang = Math.random() * 2 * Math.PI,\\n            hyp = Math.sqrt(Math.random()) * RAD,\\n            adj = Math.cos(ang) * hyp,\\n            opp = Math.sin(ang) * hyp;\\n        return new double[]{XC + adj, YC + opp};\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(radius, x_center, y_center);\\n * double[] param_1 = obj.randPoint();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968351,
                "title": "c-o-1-time-and-space-complexity",
                "content": "# Intuition\\nPolar coordinates of a circle is:\\n\\nx = x_origin + r * cos(theta)\\ny = y_origin + r * sin(theta)\\n\\nwhere r is the radius and theta is the angle made when joining the point (x,y) to the center of the cirecle, i.e., (x_origin, y_origin). \\n\\nSo, if we randomize the r and theta to take random values within the circle area, we will get the correct solution for this problem.\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n#include <math.h>\\nclass Solution {\\nprivate: \\n    double rad, x_cen, y_cen;\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        rad = radius;\\n        x_cen = x_center;\\n        y_cen = y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        double r = sqrt((double)rand()/RAND_MAX)*rad;\\n        double deg = ((double)rand()/RAND_MAX)*2*M_PI;\\n        vector<double> cord(2,0);\\n        cord[0] = x_cen+(r*cos(deg));\\n        cord[1] = y_cen+(r*sin(deg));\\n        return cord;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(radius, x_center, y_center);\\n * vector<double> param_1 = obj->randPoint();\\n */\\n\\n \\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Geometry",
                    "Rejection Sampling",
                    "Randomized"
                ],
                "code": "```\\n#include <math.h>\\nclass Solution {\\nprivate: \\n    double rad, x_cen, y_cen;\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        rad = radius;\\n        x_cen = x_center;\\n        y_cen = y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        double r = sqrt((double)rand()/RAND_MAX)*rad;\\n        double deg = ((double)rand()/RAND_MAX)*2*M_PI;\\n        vector<double> cord(2,0);\\n        cord[0] = x_cen+(r*cos(deg));\\n        cord[1] = y_cen+(r*sin(deg));\\n        return cord;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(radius, x_center, y_center);\\n * vector<double> param_1 = obj->randPoint();\\n */\\n\\n \\n```",
                "codeTag": "C++"
            },
            {
                "id": 3939815,
                "title": "elixir-solution-with-math",
                "content": "# Approach\\nIf we direcly use uniform distribution of both degree and distance from center, the probability of a point to be chosen will be ***inversely proportional to the square of distance from center***. \\n\\nThis can be observed by considering the *area* of a circle:\\nEg. When the radius is doubled, the area will be quadrupled, and the probability of a point to be chosen will decrease to 25%.\\n\\nTo make every point in the circle get the same probability, we can obtain the random distance by taking a floating number from 0.0 to 1.0 with uniform distribution, take square root of it, and then multiply by radius.\\n\\nA simple proof why this works: Consider the case when x with $$0.0 <= x < 0.4$$ is picked in range of 0.0 to 1.0. Then taking square root and multiplying radius gives $$0 <= r*\\\\sqrt{x} < r*\\\\sqrt{0.4}$$. When we calculate the area of circle with radius = $$r*\\\\sqrt{0.4}$$, the result is $$(r*\\\\sqrt{0.4})^2 * \\\\pi = 0.4 * r^2 * \\\\pi$$. This means the range of x will exactly occupy **40%** of the area of original circle.\\n\\n# Code\\n```\\ndefmodule Solution do\\n  use GenServer\\n  \\n  @spec init_(radius :: float, x_center :: float, y_center :: float) :: any\\n  def init_(radius, x_center, y_center) do\\n    GenServer.start_link(__MODULE__, nil, [name: __MODULE__])\\n    GenServer.call(__MODULE__, {:init, radius, x_center, y_center})\\n  end\\n\\n  @spec rand_point() :: [float]\\n  def rand_point() do\\n    GenServer.call(__MODULE__, :rand)\\n  end\\n\\n  @impl true\\n  def init(_) do\\n    {:ok, nil}\\n  end\\n\\n  @impl true\\n  def handle_call({:init, radius, x_center, y_center}, _, _) do\\n    {:reply, :ok, {radius, x_center, y_center}}\\n  end\\n\\n  def handle_call(:rand, _, {radius, x_center, y_center}) do\\n    dist = :rand.uniform() |> :math.sqrt() |> Kernel.*(radius)\\n    radian = :rand.uniform() |> Kernel.*(2 * :math.pi())\\n    x = x_center + dist * :math.cos(radian)\\n    y = y_center + dist * :math.sin(radian)\\n    {:reply, [x, y], {radius, x_center, y_center}}\\n  end\\nend\\n\\n# Your functions will be called as such:\\n# Solution.init_(radius, x_center, y_center)\\n# param_1 = Solution.rand_point()\\n\\n# Solution.init_ will be called before every test case, in which you can do some necessary initializations.\\n```",
                "solutionTags": [
                    "Elixir",
                    "Math"
                ],
                "code": "```\\ndefmodule Solution do\\n  use GenServer\\n  \\n  @spec init_(radius :: float, x_center :: float, y_center :: float) :: any\\n  def init_(radius, x_center, y_center) do\\n    GenServer.start_link(__MODULE__, nil, [name: __MODULE__])\\n    GenServer.call(__MODULE__, {:init, radius, x_center, y_center})\\n  end\\n\\n  @spec rand_point() :: [float]\\n  def rand_point() do\\n    GenServer.call(__MODULE__, :rand)\\n  end\\n\\n  @impl true\\n  def init(_) do\\n    {:ok, nil}\\n  end\\n\\n  @impl true\\n  def handle_call({:init, radius, x_center, y_center}, _, _) do\\n    {:reply, :ok, {radius, x_center, y_center}}\\n  end\\n\\n  def handle_call(:rand, _, {radius, x_center, y_center}) do\\n    dist = :rand.uniform() |> :math.sqrt() |> Kernel.*(radius)\\n    radian = :rand.uniform() |> Kernel.*(2 * :math.pi())\\n    x = x_center + dist * :math.cos(radian)\\n    y = y_center + dist * :math.sin(radian)\\n    {:reply, [x, y], {radius, x_center, y_center}}\\n  end\\nend\\n\\n# Your functions will be called as such:\\n# Solution.init_(radius, x_center, y_center)\\n# param_1 = Solution.rand_point()\\n\\n# Solution.init_ will be called before every test case, in which you can do some necessary initializations.\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3900095,
                "title": "randomized-cpp-easy-implementation",
                "content": "\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double rr;\\n    double x;\\n    double y;\\n    Solution(double radius, double x_center, double y_center) {\\n        rr=radius;\\n        x=x_center;\\n        y=y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        double rand1=(double)rand()/RAND_MAX;           //generate random value between 0 ans 1.\\n        double rand2=(double)rand()/RAND_MAX;           //generate random value between 0 ans 1.\\n        double angle= 2.0*M_PI*rand1;                   //generate random value between 0 ans 2*pie(exclusive).\\n        double r=sqrt(rand2)*rr;                       // uniformly choose radius randomly.\\n        double p1=r*cos(angle)+x;\\n        double p2=r*sin(angle)+y;\\n        return {p1,p2};\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(radius, x_center, y_center);\\n * vector<double> param_1 = obj->randPoint();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Geometry",
                    "Randomized"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double rr;\\n    double x;\\n    double y;\\n    Solution(double radius, double x_center, double y_center) {\\n        rr=radius;\\n        x=x_center;\\n        y=y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        double rand1=(double)rand()/RAND_MAX;           //generate random value between 0 ans 1.\\n        double rand2=(double)rand()/RAND_MAX;           //generate random value between 0 ans 1.\\n        double angle= 2.0*M_PI*rand1;                   //generate random value between 0 ans 2*pie(exclusive).\\n        double r=sqrt(rand2)*rr;                       // uniformly choose radius randomly.\\n        double p1=r*cos(angle)+x;\\n        double p2=r*sin(angle)+y;\\n        return {p1,p2};\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(radius, x_center, y_center);\\n * vector<double> param_1 = obj->randPoint();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706265,
                "title": "c-simple-solution-with-comments-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public:\\n    Solution(double radius, double x_center, double y_center) {\\n      r = radius;\\n      x = x_center;\\n      y = y_center;\\n      srand((unsigned)time(NULL));\\n    }\\n\\n    vector<double> randPoint() {\\n      // Q: Why need sqrt here?\\n      // A: Density of cicle is different along the radius, for example [0,0.5)\\n      //   and [0.5,1), area of [0,0.5) is less than [0.5,1), and area is\\n      //   proportional to radius^2, thus take a root after random sample.\\n      double length = r * sqrt(rand01());\\n      double radius = 2*acos(-1) * rand01(); // acos(-1) == pi\\n      double dx = length * sin(radius);\\n      double dy = length * cos(radius);\\n      return {x+dx, y+dy};\\n    }\\n\\n    inline double rand01() {\\n      return double(rand()) / double(RAND_MAX);\\n    }\\n\\n  private:\\n    double r, x, y;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    Solution(double radius, double x_center, double y_center) {\\n      r = radius;\\n      x = x_center;\\n      y = y_center;\\n      srand((unsigned)time(NULL));\\n    }\\n\\n    vector<double> randPoint() {\\n      // Q: Why need sqrt here?\\n      // A: Density of cicle is different along the radius, for example [0,0.5)\\n      //   and [0.5,1), area of [0,0.5) is less than [0.5,1), and area is\\n      //   proportional to radius^2, thus take a root after random sample.\\n      double length = r * sqrt(rand01());\\n      double radius = 2*acos(-1) * rand01(); // acos(-1) == pi\\n      double dx = length * sin(radius);\\n      double dy = length * cos(radius);\\n      return {x+dx, y+dy};\\n    }\\n\\n    inline double rand01() {\\n      return double(rand()) / double(RAND_MAX);\\n    }\\n\\n  private:\\n    double r, x, y;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689860,
                "title": "ruby-solution-without-polar-coordinates",
                "content": "# Intuition\\nTo create a truly random sample, select a random point from the square that fits this circle, then verify it\\'s inside the circle.\\n\\n# Approach\\nSave the radius and center as class variables when you initialize.\\n\\nMain function:\\n1. Select a random x difference from center by multiplying the radius by a random float from 0 to 1, and sample [-1,1] to make it equally likely to be positive/negative.\\n2. Do the same for y.\\n3. Confirm that x and y lie inside the circle using the distance formula; if not, select a new x and y.\\n4. Return the center point + the x diff and y diff.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$ average case.  Theoretically $$O(infinity)$$ worst case, but $$O(1)$$ in any real scenario.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution\\n    def initialize(radius, x_center, y_center)\\n        @r,@x,@y = radius, x_center, y_center\\n    end\\n\\n    def rand_point()\\n        x = @r * rand * [-1,1].sample\\n        y = @r * rand * [-1,1].sample\\n\\n        until x**2 + y**2 <= @r**2\\n            x = @r * rand * [-1,1].sample\\n            y = @r * rand * [-1,1].sample\\n        end\\n\\n        [@x + x, @y + y]\\n    end\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass Solution\\n    def initialize(radius, x_center, y_center)\\n        @r,@x,@y = radius, x_center, y_center\\n    end\\n\\n    def rand_point()\\n        x = @r * rand * [-1,1].sample\\n        y = @r * rand * [-1,1].sample\\n\\n        until x**2 + y**2 <= @r**2\\n            x = @r * rand * [-1,1].sample\\n            y = @r * rand * [-1,1].sample\\n        end\\n\\n        [@x + x, @y + y]\\n    end\\n\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629193,
                "title": "random-coordinate-generation-using-polar-coordinates",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this problem is to generate random points within a given circle. Since the circle is defined by its radius and center coordinates, we can use polar coordinates to generate random points within the circle.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe key approach is to generate random angles and lengths within the appropriate ranges. By converting the random angle and scaled length to Cartesian coordinates using trigonometry, we can obtain random points within the circle.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <vector>\\n#include <cmath>\\n#include <cstdlib>  // for rand() and RAND_MAX\\n\\nclass Solution {\\nprivate:\\n    double radius;   // radius of the circle\\n    double x_center; // x-coordinate of the circle\\'s center\\n    double y_center; // y-coordinate of the circle\\'s center\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        this->radius = radius;\\n        this->x_center = x_center;\\n        this->y_center = y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        double angle;    // angle in radians\\n        double length;   // distance from the center to the random point\\n\\n        double random = (double)rand() / RAND_MAX;  // random number between 0 and 1\\n        angle = random * 2 * M_PI;  // convert the random number to an angle in the range [0, 2\\u03C0)\\n\\n        double random2 = (double)rand() / RAND_MAX;\\n        length = sqrt(random2) * radius;  // randomly scaled length within the circle\\'s radius\\n\\n        // Calculate the coordinates of the random point using polar coordinates\\n        double x_random = x_center + length * cos(angle);\\n        double y_random = y_center + length * sin(angle);\\n        \\n        return vector<double>{x_random, y_random};  // return the random point as a vector\\n    }\\n};\\n\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(radius, x_center, y_center);\\n * vector<double> param_1 = obj->randPoint();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Randomized"
                ],
                "code": "```\\n#include <vector>\\n#include <cmath>\\n#include <cstdlib>  // for rand() and RAND_MAX\\n\\nclass Solution {\\nprivate:\\n    double radius;   // radius of the circle\\n    double x_center; // x-coordinate of the circle\\'s center\\n    double y_center; // y-coordinate of the circle\\'s center\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        this->radius = radius;\\n        this->x_center = x_center;\\n        this->y_center = y_center;\\n    }\\n    \\n    vector<double> randPoint() {\\n        double angle;    // angle in radians\\n        double length;   // distance from the center to the random point\\n\\n        double random = (double)rand() / RAND_MAX;  // random number between 0 and 1\\n        angle = random * 2 * M_PI;  // convert the random number to an angle in the range [0, 2\\u03C0)\\n\\n        double random2 = (double)rand() / RAND_MAX;\\n        length = sqrt(random2) * radius;  // randomly scaled length within the circle\\'s radius\\n\\n        // Calculate the coordinates of the random point using polar coordinates\\n        double x_random = x_center + length * cos(angle);\\n        double y_random = y_center + length * sin(angle);\\n        \\n        return vector<double>{x_random, y_random};  // return the random point as a vector\\n    }\\n};\\n\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(radius, x_center, y_center);\\n * vector<double> param_1 = obj->randPoint();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3626562,
                "title": "polar-coordinates-not-needed",
                "content": "Most solutions here appear to require the use of polar coordinates. That being said, the following solution appears to generate points with a uniform distribution across the entire circle, as evidenced below:\\n![image](https://assets.leetcode.com/users/images/209a2070-9e0c-496f-bb39-ce5b4a53ad1a_1686506394.7751818.png)\\n![image](https://assets.leetcode.com/users/images/c7f298e5-92f5-499a-8775-0f10a4629624_1686506477.9565992.png)\\n\\n**Intuition**\\nThrowing darts at a wall. Suppose you have a 1x1 square, wherein a quarter circle is inscribed as follows:\\n![image](https://assets.leetcode.com/users/images/79bf9fb9-f88b-4e11-92a1-5fe2b5644420_1686506677.3133662.jpeg)\\n\\nAll you have to do is generate points until you get one that \\'lands\\' inside that quarter circle. Once that happens, you just need to do 2 things:\\n1. Because this will only generate values within a quarter circle, we need a 50% chance that the signs on each of the components flip. This ensures that we represent the entire circle.\\n2. Because we don\\'t want a unit circle solution, we need to remap the coordinates generated to the desired circle.\\n\\n**Solution**\\n```\\ndef randPoint(self) -> List[float]:\\n        #Throw random darts until we get one that landed within the circle\\n        current_x, current_y = self.generate_random_point()\\n        #Flip signs of the values if necessary\\n        current_x, current_y = self.generate_random_sign_flip(current_x, current_y)\\n        #We will return the remapped_values\\n        scale, x_offset, y_offset = self.__radius, self.__x_center, self.__y_center\\n        return [self.remapped_value(current_x, scale, x_offset), self.remapped_value(current_y, scale, y_offset)]\\n```\\nHelper methods:\\n```\\ndef generate_random_point(self):\\n        current_x = 1\\n        current_y = 1\\n        while sqrt(current_x ** 2 + current_y ** 2) >= 1:\\n            current_x = random.random()\\n            current_y = random.random()\\n        return current_x, current_y\\n\\ndef generate_random_sign_flip(self, num1, num2):\\n        if random.random() > 0.5:\\n            num1 = -1 * num1\\n        if random.random() > 0.5:\\n            num2 = -1 * num2\\n        return num1, num2\\n\\ndef remapped_value(self, initial_value, scale, offset):\\n        remapped_number = initial_value * scale + offset\\n        return remapped_number\\n```\\nNot the most efficient solution, and it\\'s a lot of extra steps to reduce run-time a bit, but thought I\\'d share :)",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\ndef randPoint(self) -> List[float]:\\n        #Throw random darts until we get one that landed within the circle\\n        current_x, current_y = self.generate_random_point()\\n        #Flip signs of the values if necessary\\n        current_x, current_y = self.generate_random_sign_flip(current_x, current_y)\\n        #We will return the remapped_values\\n        scale, x_offset, y_offset = self.__radius, self.__x_center, self.__y_center\\n        return [self.remapped_value(current_x, scale, x_offset), self.remapped_value(current_y, scale, y_offset)]\\n```\n```\\ndef generate_random_point(self):\\n        current_x = 1\\n        current_y = 1\\n        while sqrt(current_x ** 2 + current_y ** 2) >= 1:\\n            current_x = random.random()\\n            current_y = random.random()\\n        return current_x, current_y\\n\\ndef generate_random_sign_flip(self, num1, num2):\\n        if random.random() > 0.5:\\n            num1 = -1 * num1\\n        if random.random() > 0.5:\\n            num2 = -1 * num2\\n        return num1, num2\\n\\ndef remapped_value(self, initial_value, scale, offset):\\n        remapped_number = initial_value * scale + offset\\n        return remapped_number\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1565292,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 1564955,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 1566293,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 1566880,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 1569263,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 1777083,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 2076146,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 1902941,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 1876514,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 1818206,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 1565292,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 1564955,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 1566293,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 1566880,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 1569263,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 1777083,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 2076146,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 1902941,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 1876514,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            },
            {
                "id": 1818206,
                "content": [
                    {
                        "username": "CodeLenin",
                        "content": "As the circle is becoming smaller towards the center, taking linear random on radius will not provide uniform points for circles. \\nSo for even distribution we have to take `sqrt(radius)`. See the below images \\n\\n***Image 1 : Without sqrt on random  - You can see lot of points near the center***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707260.png)\\n\\n***Image 1 : With sqrt on random  - You can see uniformly distributed***\\n![image](https://assets.leetcode.com/users/codelenin/image_1565707366.png)\\n\\n"
                    },
                    {
                        "username": "Ricola",
                        "content": "Out ouf curiosity, I was wondering how the solution is verified. Since we are creating random numbers, how can the judge know that the solution is uniform? It seems that it works since if you don\\'t use the sqrt it fails, but how?\\n\\nSince I doubt it has access to the internal mechanics of random generation in every language, I guess that it calls a lot of random and checks if it follows the accurate distribution, but as this comic tells us, you can never be sure with randomness. What if the randomess just by chance created points that look like another distribution?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ricola/image_1534934091.png)\\n"
                    },
                    {
                        "username": "lostfish",
                        "content": "I guess the validation method is like the answer of 2nd floor by [@lenin](/CodeLenin). Samping and check whether the point proportion within any radius r is close to r\\*r/(R\\*R)."
                    },
                    {
                        "username": "datou12138",
                        "content": "Given random variable X, with origin distribution as  ![image](https://assets.leetcode.com/users/datou12138/image_1556034167.png).\\nAnd random variable Y, with target distribution as ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png).\\nWe want to find a transformation function y=g(x) that transform origin distribution to our target distribution.\\n\\nWe have theorem that if g(x) is strictly monotonic, and its derived function is g\\'(x), the pdf of Y is ![image](https://assets.leetcode.com/users/datou12138/image_1556034275.png) (1)\\n, where h(y) is inverse function of y=g(x).\\n\\nSince ![image](https://assets.leetcode.com/users/datou12138/image_1556034236.png)\\nhas no variable x in it, we can simply get from Eq 1 that ![image](https://assets.leetcode.com/users/datou12138/image_1556034385.png).\\nSo![image](https://assets.leetcode.com/users/datou12138/image_1556034428.png).\\nThat is ![image](https://assets.leetcode.com/users/datou12138/image_1556034459.png).\\n\\n// Save up for leetcode future support of Latex fomulation syntax.\\nX\\n\\n p_X(x)=1\\n\\np_Y(y)=\\\\frac{2}{R^2}y\\n\\ng(x) \\n\\ny=g(x)\\n\\ng\\'(x)\\n\\nY\\n\\np_Y(y)=p_X(h(y))|h\\'(y)| \\n\\n |h\\'(y)|=\\\\frac{p_Y(y)}{p_X(x)}= \\\\frac{2y}{R^2}\\n\\nx=h(y)=\\\\frac{y^2}{R^2}\\n\\ny=g(x)=R\\\\sqrt{x}\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "krantarat",
                        "content": "Here we are going to randomize the radius. \\n\\nWe can think of it as randomizing the area, call it `A`, and this `A` would be proportional to the total area of the circle `PI*R*R`.  And after getting `A`, we try to revert back what the radius `r` we need to compose the circle with area `A`, and thus getting our randomized value.\\n\\n`PI*r*r = A` \\n`r=sqrt(A/PI)`, but `A` is in range `[0, PI*R*R) = PI*R*R*rand(0,1)`\\n`r=sqrt(PI*R*R*rand(0,1)/PI)`\\n`r=sqrt(R*R*rand(0,1))`\\n`r=R*sqrt(rand(0,1))`\\n\\nNote:\\nIf we get the small area -> the radius should be small.\\nIf we get the large area -> the radius should be large.\\n\\nAlso, when the area is very small, a constant change `d` in A would cause our radius to change much higher than when the area is larger.\\n\\n\\n\\n"
                    },
                    {
                        "username": "jihwan11",
                        "content": "Issue:\\nMathmatical logic is very simple, but it doesn\\'t requires randomness and precision of double values.\\nCode can generate random points in a certain area within the circle.  Also, mathematical operation on a duble number, such as \\'x*x\\' with a small radius may invalidate a solution.\\n\\nInteresting result:\\nOne of Test cases on this site is Random(0.01, -73839.1, -3289891.29811).\\nWith my generated values, I checked my results with (myX-(-73839.1))^2 + (myY-(-3289891.29811))^2 <= (0.01)^2\\nI called the randPoint method 300000000 times without an error, but this website fails my code.\\n"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@cartesPerforees](/cartesPerforees) I had a similar issue and used matplotlib to generate 100 points at a time, thousands of times with a .01 second delay so it animates. Its hardly mathematically rigorous, but it *looks* completely random. Radnom enough that I have my doubts about the validity of their checker anyhow, given they are only making 3*10**4 calls. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "how did you \"check\" your results? Did you only check that the points are within the circle? That is not what the problem asks.\nProperly checking for uniformity of your distribution with appropriate p-values is a non-trivial task that is significantly more mathematically advanced than the problem at hand.\n\nAre you sure your solution really generates a *uniform* distribution of points within the circle? (i.e. you asymptotically get the same concentration of points around every point in the circle?)"
                    },
                    {
                        "username": "MatsRivel",
                        "content": "I\\'m having the same issues"
                    },
                    {
                        "username": "godshiva",
                        "content": "Lots of thumbs down... is that just people mad that their solution didn\\'t work or are they objecting to requiring math knowledge being a requisite for completing the problem?  I don\\'t mind either way, if I learn something new (mathematically) I kinda like that"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Some of the thumbs down are for people using more advanced techniques that it seems to be randomly failing. I\\'ve spent the last two hours analyzing the data my algo produces. I\\'ve produced *billions* of points, all double checked that they all work. It *seems* as random as the naive solution, its using the same PRNG calls... yet fails without saying why. Not that I\\'m salty. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "every single leetode problem that involves any form of maths beyond division gets downvoted to death.\nDevs hate to be reminded that they suck at maths and that it might get in the way of some coding assignments"
                    },
                    {
                        "username": "Anshul29",
                        "content": "I think they should mention that the points generated should all be different.\\nMy code returns the center as all the random points and it passes for all the testcases except for [0.01,-73839.1,-3289891.3] so either review your solution checker or write in the description that all points should be unique. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Love this problem!\\nI have a physics background and consider myself good at maths, but I still learned something new about inverse transform sampling! \\n(it is not required knowledge for this problem tho, I solved it in a much more hands-on way, using integral calculations that are commonplace in physics. It\\'s less elegant tho)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "as of now there are 314 solutions haha :)"
                    },
                    {
                        "username": "madpoly",
                        "content": "getting small rounding errors, anyone know how to fix?\\n `class Solution {\\nprivate:\\ndouble radius=0.00000;\\ndouble xcenter=0.00000;\\ndouble ycenter=0.00000;\\n\\npublic:\\n    Solution(double radius, double x_center, double y_center) {\\n        radius = radius;\\n        xcenter = x_center;\\n        ycenter = y_center;\\n        std::cout << \"radius: \" << radius << \", xcenter: \" << x_center << \", ycenter: \" << y_center << std::endl; \\n        \\n    }\\n    \\n    vector<double> randPoint() {\\n        double randomradius= (static_cast<double>(sqrt(rand()) ) / RAND_MAX) * radius;\\n        double randomangle= (static_cast<double> (sqrt(rand()) ) / RAND_MAX) * 360.000000;\\n        std::cout << \"randomradius: \" << randomradius << std::endl;\\n        std::cout << \"random angle: \" << randomangle << std::endl; \\n        double yp= sin(randomangle)*randomradius;\\n        double xp= cos(randomangle)*randomradius;\\n        std::cout << \"yp: \" << yp<<std::endl;\\n        std::cout << \"xp: \" << xp<<std::endl;\\n        std::vector<double> point= {xp+xcenter, yp+ycenter};\\n        return point; \\n    }\\n};\\n`"
                    }
                ]
            }
        ]
    },
    {
        "title": "Get Highest Answer Rate Question",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565620,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1566181,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1566266,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1567687,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1576368,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1573226,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1572863,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1572586,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1572482,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1570454,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1565620,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1566181,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1566266,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1567687,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1576368,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1573226,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1572863,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1572586,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1572482,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            },
            {
                "id": 1570454,
                "content": [
                    {
                        "username": "zhizirachel",
                        "content": "I\\'ve found many of the approach use limit 1\\nwhat if there are more than 1 questions with highest answer rate?"
                    },
                    {
                        "username": "lancexie",
                        "content": "![image](https://assets.leetcode.com/users/images/b1d42796-1a74-4af0-a2c9-1e61bdf2c415_1622130937.6985977.png)\\n**Note:** The highest answer rate meaning is: answer number\\'s ratio in show number in the same question.\\n\\n\\nBy the definition of this question, we consider the ratio of number of times of \\'answer\\' and number of times of \\'show\\'. 285 has an answer rate of 1 and 369 also has answer rate of 1?\\n\\nI am curious why do people use order by desc and limit 1? Why do we assume there is only 1 answer with highest rate but not multiple? \\n"
                    },
                    {
                        "username": "apurva_shekhar",
                        "content": "I think it\\'s because we have to provide the id with the smallest question_id"
                    },
                    {
                        "username": "xukerui",
                        "content": "When i use either of the given two solution approaches to submit, the result is quite weird: it get random acceptance.  if you try to submit same solution for multiple times, you will find it is either accepted  or reject b/c of wrong answer, in a random fashion. I looked into the wrong answer test case it is always the one below: \\n\\n'''{\"headers\": {\"survey_log\": [\"uid\", \"action\", \"question_id\", \"answer_id\", \"q_num\", \"timestamp\"]},\"rows\": {\"survey_log\": [[5, \"answer\", 285, 123, 1, 1], [5, \"answer\", 285, 123, 1, 2], [5, \"answer\", 369, 123, 2, 3], [5, \"skip\", 369, null, 2, 4]]}}'''\\n\\nThis test cases is problematic b/c neither question_id 285 nor 369 has action 'show', so that the ratio defined by (num_answer/num_show) will both give null values for 285 and 369, which means if you order them by this ratio, it will give random order.  \\n\\nYou can check this out using the \"custom testcase\" option and \"run code\" of solution on this test case. you will find both \"your answer\" and \"expected answer\" varies from run to run, which leads to random acceptance of your submission. (here i removed 'limit 1' in the test code to show the full order)\\n![3_1508202669378_output1.png](/assets/uploads/files/1508202670316-output1-resized.png) ![2_1508202669378_output2.png](/assets/uploads/files/1508202670355-output2-resized.png) ![1_1508202669378_output3.png](/assets/uploads/files/1508202670432-output3-resized.png) ![0_1508202669378_output4.png](/assets/uploads/files/1508202670389-output4-resized.png) \\n\\nThis problem needs to remove this testcase or add new rules for case where no 'show' action in any question_id \\n\\nbtw, the provided \"COUNT(IF...)\" approach needs to be corrected: COUNT(IF(action = 'show', 1, 0) ) --->COUNT(IF(action = 'show', 1, null)"
                    },
                    {
                        "username": "jeremycui0123",
                        "content": "I\\'m experiencing Invalid Testcase \\'Candidates\\' error and doesn\\'t allow me to run any query. I didn\\'t change the default test case and it doesn\\'t even allow me to run select * from SurveyLog.\\n\\nDoes anyone have met this before? If so, how did you solve this? Or do you have any suggestion?\\n\\nThank you all so much!!"
                    },
                    {
                        "username": "uncomfortablepanda",
                        "content": "readibility is the key to this types of queries in my opinion :)\\n\\n\\nwith calcs1 as (\\n\\nSELECT question_id, \\ncount((CASE WHEN action =\\'show\\' THEN 1 END )) as shown,\\ncount((case when action=\\'answer\\' THEN 1 END)) as answered \\nFROM surveylog\\nGROUP BY 1\\n\\n), calcs2 as (\\n\\nSELECT question_id, (answered/shown) as response FROM calcs1 ORDER BY response DESC \\n\\n)\\n\\nSELECT question_id as survey_log  FROM calcs2 LIMIT 1"
                    },
                    {
                        "username": "Emailsiraj",
                        "content": "Oracle compiler issue, please correct"
                    },
                    {
                        "username": "omg_zozobra",
                        "content": "though my code passed all test, faster than 94%\\ni still confused about the def of answer rate\\nin my code, i used #of answer/#of show question appears time\\nI dont know if that is right\\n\\n\\u2018\\u2019\\u2018\\nselect b.question_id as survey_log\\nfrom\\n(select question_id,count(answer_id)as ans_times\\nfrom survey_log\\ngroup by question_id)b\\ninner join\\n(select question_id,count(question_id)as show_times\\nfrom survey_log\\n\\ngroup by question_id)c\\non b.question_id=c.question_id\\norder by ans_times/show_times desc\\nlimit 1\\n\\u2019\\u2018\\u2019"
                    },
                    {
                        "username": "hellomyworld",
                        "content": "When use SQL Server to solve this problem, how to this problem. If the show number is zero?"
                    },
                    {
                        "username": "wantrytao",
                        "content": "# Write your MySQL query statement below\\n\\nselect question_id as survey_log\\nfrom survey_log\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1"
                    },
                    {
                        "username": "dqf566",
                        "content": "# Write your MySQL query statement below\\n\\nThe question is to get the survey_log with the highest answer rate. You just need to get the survey_id with highest counts for the answer.\\n\\nI didn\\'t calculate the answer_rate, because I am very lazy...\\n\\nselect question_id as survey_log\\nfrom survey_log\\nwhere answer_id IS NOT NULL\\ngroup by question_id\\norder by count(answer_id) desc\\nlimit 1\\n"
                    },
                    {
                        "username": "Mitomolfz",
                        "content": "but there might be such case that some questions have same answer times but different show times"
                    }
                ]
            }
        ]
    }
]