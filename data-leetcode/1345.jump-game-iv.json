[
    {
        "title": "Angle Between Hands of a Clock",
        "question_content": "Given two numbers, hour and minutes, return the smaller angle (in degrees) formed between the hour and the minute hand.\nAnswers within 10-5 of the actual value will be accepted as correct.\n&nbsp;\nExample 1:\n\nInput: hour = 12, minutes = 30\nOutput: 165\n\nExample 2:\n\nInput: hour = 3, minutes = 30\nOutput: 75\n\nExample 3:\n\nInput: hour = 3, minutes = 15\nOutput: 7.5\n\n&nbsp;\nConstraints:\n\n\t1 <= hour <= 12\n\t0 <= minutes <= 59",
        "solutions": [
            {
                "id": 502738,
                "title": "java-python-c-simple-math-on-clock-angles",
                "content": "**Basic Unitary Method**\\n(Credits - @rajcm)\\n\\n**Hour Hand**\\nIn 12 hours Hour hand complete whole circle and cover 360\\xB0\\nSo, 1 hour = 360\\xB0 / 12 = 30\\xB0\\n\\nSince 1 hours = 30\\xB0\\nIn 1 minute, hours hand rotate -> 30\\xB0 / 60 = 0.5\\xB0\\nSo total angle because of minutes by hour hand is `minutes/60 * 30` or `minutes * 0.5`\\n\\n**Minute Hand**\\nIn 60 minutes Minute Hand completes whole circle and cover 360\\xB0.\\nSo, 1 minute -> 360\\xB0 / 60 = 6\\xB0\\n\\n<br><br>\\n\\n**Java**\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n         // Degree covered by hour hand (hour area + minutes area)\\n        double h = (hour%12 * 30) + ((double)minutes/60 * 30);\\n        \\n         // Degree covered by minute hand (Each minute = 6 degree)\\n        double m = minutes * 6;\\n        \\n         // Absolute angle between them\\n        double angle = Math.abs(m - h);\\n        \\n         // If the angle is obtuse (>180), convert it to acute (0<=x<=180)\\n        if (angle > 180) angle = 360.0 - angle;\\n        \\n        return angle;\\n    }\\n}\\n```\\n<br><br>\\n\\n**Python**\\n\\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        # Degree covered by hour hand (hour area + minutes area)\\n        h = (hour%12 * 30) + (minutes/60 * 30)\\n        \\n        # Degree covered by minute hand (Each minute = 6 degree)\\n        m = minutes * 6\\n        \\n        # Absolute angle between them\\n        angle = abs(m - h)\\n        \\n        # If the angle is obtuse (>180), convert it to acute (0<=x<=180)\\n        if angle > 180:\\n            angle = 360.0 - angle\\n        \\n        return (angle)\\n```\\n\\n**C++**\\nCredits : [MichaelZ](https://leetcode.com/michaelz/)\\nThanks for the C++ code.\\n```\\ndouble angleClock(int hour, int minutes) {\\n        double minute=minutes*6, hr=hour*30+(double)minutes/2, diff=abs(hr-minute);\\n        return min(diff, 360-diff);\\n    }\\n```\\t\\n\\nPlease upvote if you found this useful.\\nIf you have any queries, please post in comment section.\\nThank you",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n         // Degree covered by hour hand (hour area + minutes area)\\n        double h = (hour%12 * 30) + ((double)minutes/60 * 30);\\n        \\n         // Degree covered by minute hand (Each minute = 6 degree)\\n        double m = minutes * 6;\\n        \\n         // Absolute angle between them\\n        double angle = Math.abs(m - h);\\n        \\n         // If the angle is obtuse (>180), convert it to acute (0<=x<=180)\\n        if (angle > 180) angle = 360.0 - angle;\\n        \\n        return angle;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        # Degree covered by hour hand (hour area + minutes area)\\n        h = (hour%12 * 30) + (minutes/60 * 30)\\n        \\n        # Degree covered by minute hand (Each minute = 6 degree)\\n        m = minutes * 6\\n        \\n        # Absolute angle between them\\n        angle = abs(m - h)\\n        \\n        # If the angle is obtuse (>180), convert it to acute (0<=x<=180)\\n        if angle > 180:\\n            angle = 360.0 - angle\\n        \\n        return (angle)\\n```\n```\\ndouble angleClock(int hour, int minutes) {\\n        double minute=minutes*6, hr=hour*30+(double)minutes/2, diff=abs(hr-minute);\\n        return min(diff, 360-diff);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735395,
                "title": "python-math-solution-oneliner-explained",
                "content": "To solve this problem we need to understand the speeds of Hands of a clock.\\n\\n1. Let us find the place, where **hour hand** is. First, whe have `12` hours in total, for `360` degrees, that means `30` degrees per hour. Also, for every `60` minutes, our hour hand rotated by `1` hour, that is `30` degrees, so for every minute, it is rotated by `0.5` degrees. So, final place for hour hand is `30*hour + 0.5*minutes`\\n2. Let us find the place, where **minute hand** is: every `60` minutes minute hand makes full rotation, that means we have `6` degrees for each minute.\\n3. Finally, we evaluate absolute difference between these two numbers, and if angle is more than `180` degrees, we return complementary angle.\\n\\n**Complexity**: time and space is `O(1)`, we just use some mathematical formulae.\\n\\n```\\nclass Solution:\\n    def angleClock(self, hour, minutes):\\n        H_place = 30*hour + 0.5*minutes\\n        M_place = 6*minutes\\n        diff = abs(H_place - M_place)\\n        return diff if diff <= 180 else 360 - diff\\n```\\n\\n**Oneliner**\\nWe can write this as oneliner as well:\\n```\\nreturn min(abs(30*hour-5.5*minutes),360-abs(30*hour-5.5*minutes))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour, minutes):\\n        H_place = 30*hour + 0.5*minutes\\n        M_place = 6*minutes\\n        diff = abs(H_place - M_place)\\n        return diff if diff <= 180 else 360 - diff\\n```\n```\\nreturn min(abs(30*hour-5.5*minutes),360-abs(30*hour-5.5*minutes))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735414,
                "title": "c-easy-with-explanation",
                "content": "### Approach\\n1. Hour hand\\nThe clock is 360deg. Make 4 parts each part is 90deg. 15 min = 90deg. So 5 min = 30 deg.\\nSo every hour our hour hand goes forward 30 deg.\\n2. Minute hand.\\nAs 5 min = 30 deg. So 1 min = 30/5 = 6 deg.\\nif it is 30 min ->  deg is 6 * 30 = 180 deg\\n3. Relation between hour and minute hand (Hint 1)\\nNow if minute hand is at 6 i.e. 30 min hour hand goes to 2.5 min.\\ni.e. out of 60 min hand covers 30 min and out of 5 min hour hand covers 2.5.\\nWe can see the ratio here.\\nso for every minute hour hand goes by 0.5 minutes.\\n\\nSo we can find both hour angle and minute angle and see their difference. Also as the question wants us to return the shorter angle we can to perforn 360 - diff and see if it smaller than diff.\\n#### Steps:\\n1. For hour hand we perform hour % 12 and then mutilply it to magnitude of 30deg.\\n``hour_angle = (hour % 12 ) * 30 + ratio`` - ``ratio = minutes * 0.5``\\n2. For minute hand - ``minutes*6 degrees``\\n3. calculate difference between the two angles - ``abs(h_angle - min_angle)``\\n4. Check the shorter angle ``min(diff,360-diff)``\\n5. Complete\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hour_angle = (hour % 12 ) * 30 + minutes * 0.5;\\n        double minute_angle = minutes * 6;\\n        double diff = abs(hour_angle - minute_angle);\\n        return min(diff, 360 - diff);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hour_angle = (hour % 12 ) * 30 + minutes * 0.5;\\n        double minute_angle = minutes * 6;\\n        double diff = abs(hour_angle - minute_angle);\\n        return min(diff, 360 - diff);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502816,
                "title": "python-mathematical-solution-with-explanation",
                "content": "The minute hand moves by ```minute_deg_per_min = 360\\xB0 / 60 = 6\\xB0``` per minute.\\nThe hour hand moves by ```hour_deg_per_hour = 360\\xB0 / 12 = 30\\xB0``` per hour.\\nThe hour hand has an additional movement of ```hour_deg_per_min = hour_deg_per_hour / 60 = 30\\xB0 / 60 = 0.5\\xB0``` per minute.\\n\\nTherefore we get the following movements:\\n```\\nhour_hand_deg = hour * hour_deg_per_hour + minutes * hour_deg_per_min = hour * 30 + minutes * 0.5\\nminute_hand_deg = minutes * minute_deg_per_min = minutes * 6\\n```\\n\\nWe need the absolute difference between those two:\\n```\\ndiff_deg = |hour_hand_deg - minute_hand_deg| = |hour * 30 + minutes * 0.5 - minutes * 6| = |hour * 30 - minutes * 5.5|\\n```\\n\\nAs we can easily see when looking at a clock there are two different angles between the hands:\\nThe minimum angle on one side is between 0\\xB0 and 180\\xB0.\\nThe maximum angle on the other side is between 180\\xB0 and 360\\xB0.\\nWe need the minimum angle. If our formular returned a number above 180\\xB0 we got the maximum angle.\\nWe can calculate the minimum angle by subtracting the maximum angle from 360\\xB0.\\n\\nTime and space complexity: ```O(1)```\\n```python\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        diff = abs(30 * hour - 5.5 * minutes)\\n        return diff if diff <= 180 else 360 - diff\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```minute_deg_per_min = 360\\xB0 / 60 = 6\\xB0```\n```hour_deg_per_hour = 360\\xB0 / 12 = 30\\xB0```\n```hour_deg_per_min = hour_deg_per_hour / 60 = 30\\xB0 / 60 = 0.5\\xB0```\n```\\nhour_hand_deg = hour * hour_deg_per_hour + minutes * hour_deg_per_min = hour * 30 + minutes * 0.5\\nminute_hand_deg = minutes * minute_deg_per_min = minutes * 6\\n```\n```\\ndiff_deg = |hour_hand_deg - minute_hand_deg| = |hour * 30 + minutes * 0.5 - minutes * 6| = |hour * 30 - minutes * 5.5|\\n```\n```O(1)```\n```python\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        diff = abs(30 * hour - 5.5 * minutes)\\n        return diff if diff <= 180 else 360 - diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512733,
                "title": "use-720-for-a-circle-then-divide-by-2-0",
                "content": "\\n```\\n    public double angleClock(int h, int m) {\\n        int hr = 60 * h + m;\\n        int min = 12 * m;\\n        \\n        int angle = Math.abs(hr - min);\\n        return Math.min(angle, 720 - angle)/2.0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public double angleClock(int h, int m) {\\n        int hr = 60 * h + m;\\n        int min = 12 * m;\\n        \\n        int angle = Math.abs(hr - min);\\n        return Math.min(angle, 720 - angle)/2.0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 503002,
                "title": "c-simple-easy-solution",
                "content": "Get minutes equivalent for hour hand on a scale of 0-60, in the code below hrm is used to denote that.\\nWe know that at max, the difference can be 180 degrees, or 30 units in minute equivalent scale, we use this condition and calculate appropriately.\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hrm,mn;\\n        mn=minutes;\\n        hrm = hour%12*5;\\n        hrm+=mn/12.0;\\n        if(abs(mn-hrm)>30)\\n            return mn>hrm?(60-mn+hrm)*6:(60-hrm+mn)*6;\\n        else\\n            return abs(mn-hrm)*6;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hrm,mn;\\n        mn=minutes;\\n        hrm = hour%12*5;\\n        hrm+=mn/12.0;\\n        if(abs(mn-hrm)>30)\\n            return mn>hrm?(60-mn+hrm)*6:(60-hrm+mn)*6;\\n        else\\n            return abs(mn-hrm)*6;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520957,
                "title": "c-1-line-solution-beats-100-submissions",
                "content": "Hey guys,\\nHope you all are doing well!\\nTo be honest, I could have written this code in a single line, but I decided to keep it as simple as possible so that everyone\\xA0can\\xA0easily grasp the logic behind it.\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes){\\n        double hh_angle=(60*hour+minutes)*0.5;  \\n        double mh_angle=minutes*6;\\n        double ans=abs(hh_angle-mh_angle);     //diff liya hai\\n        return ans<=180.0 ? ans : 360.0-ans;   //chhote angle ko return kiya hai\\n    }\\n};\\n```\\nExplaination: \\ni) The minute hand moves 360 degrees in 60 minute => 6 degrees in 1 minute.\\nii) Hour hand moves 360 degrees in 12 hours => 0.5 degrees in 1 minute. \\niii) In h hours and m minutes, the minute hand would move (h*60 + m)*6 and hour hand would move (h*60 + m)*0.5. \\n\\nPlease let me know if you have any questions in the comments. I\\'d be delighted to respond.\\xA0\\nIf you found the solution helpful, please vote it up.\\nHave fun coding.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes){\\n        double hh_angle=(60*hour+minutes)*0.5;  \\n        double mh_angle=minutes*6;\\n        double ans=abs(hh_angle-mh_angle);     //diff liya hai\\n        return ans<=180.0 ? ans : 360.0-ans;   //chhote angle ko return kiya hai\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174887,
                "title": "3-lines-of-code-easiest-cpp-solution-with-explanation-runtime-0ms",
                "content": "**Code:**\\n```\\ndouble angleClock(int hour, int minutes)\\n    {\\n        //1 minutes = 6`    (360/60)\\n        //so firtly calulate minutes travelled by hour hand.\\n        //Every 1 hour in clock consists of 5 minute part, so (hour*5)\\n        //In very minute the movement of hour hand will be (5/60) = (1/12)\\n        //So to calculate movement in the hour hand bcz of minute hand will be (minutes/12)\\n        //So, (hour*5.0) + (minutes/12.0) will give the position of hour hand in respect of minute hand\\n\\t\\t\\n        double hr = (hour*5.0) + (minutes/12.0);  \\n\\t\\t\\n        //to calculate the angle between them\\n        //difference betweem hour hand position and minutes hand position multipled with 6\\n        //So angle 1 = (abs(hr - minutes))*6\\n        //The other angle will be (360 - angle 1)\\n        //return the smaller one\\n\\t\\t\\n        double a = min((abs(hr - minutes))*6, abs(360 - (abs(hr - minutes))*6));\\n\\t\\t\\n        return a;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\ndouble angleClock(int hour, int minutes)\\n    {\\n        //1 minutes = 6`    (360/60)\\n        //so firtly calulate minutes travelled by hour hand.\\n        //Every 1 hour in clock consists of 5 minute part, so (hour*5)\\n        //In very minute the movement of hour hand will be (5/60) = (1/12)\\n        //So to calculate movement in the hour hand bcz of minute hand will be (minutes/12)\\n        //So, (hour*5.0) + (minutes/12.0) will give the position of hour hand in respect of minute hand\\n\\t\\t\\n        double hr = (hour*5.0) + (minutes/12.0);  \\n\\t\\t\\n        //to calculate the angle between them\\n        //difference betweem hour hand position and minutes hand position multipled with 6\\n        //So angle 1 = (abs(hr - minutes))*6\\n        //The other angle will be (360 - angle 1)\\n        //return the smaller one\\n\\t\\t\\n        double a = min((abs(hr - minutes))*6, abs(360 - (abs(hr - minutes))*6));\\n\\t\\t\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1436506,
                "title": "100-fastest-simple-math",
                "content": "```\\n double angleClock(int hour, int minutes) {\\n        double num_hours = (30*((double)hour + ((double)(minutes)/60)));  // total time in hours eg 12:30 == 12.5 hours\\n\\t\\t//and multiplying with 30 as 1 hour = 30 degrees \\n        if(num_hours > 360) {\\n            num_hours -= 360; \\n        }// If the result goes above 360 \\n        double ans_min = 6 * minutes;  // every min is 6 degrees \\n        double result = abs(num_hours - ans_min);  // This is first answer but the minimal \\n\\t\\t//could be 360 - answer. Thats why the below line  :) \\n        return min(result, 360 - result);\\n    }\\n\\t// If you understood it then please Upvote , it motivates me !!\\n\\n```",
                "solutionTags": [],
                "code": "```\\n double angleClock(int hour, int minutes) {\\n        double num_hours = (30*((double)hour + ((double)(minutes)/60)));  // total time in hours eg 12:30 == 12.5 hours\\n\\t\\t//and multiplying with 30 as 1 hour = 30 degrees \\n        if(num_hours > 360) {\\n            num_hours -= 360; \\n        }// If the result goes above 360 \\n        double ans_min = 6 * minutes;  // every min is 6 degrees \\n        double result = abs(num_hours - ans_min);  // This is first answer but the minimal \\n\\t\\t//could be 360 - answer. Thats why the below line  :) \\n        return min(result, 360 - result);\\n    }\\n\\t// If you understood it then please Upvote , it motivates me !!\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 503033,
                "title": "4-lines-javascript-solution-with-explanation-link-60-ms",
                "content": "Solution:\\n```\\nvar angleClock = function(hour, minutes) {\\n    var minutesAngle = minutes * 6;\\n    var hoursAngle = (hour + minutes / 60) * 30;\\n    var diff = Math.abs(minutesAngle - hoursAngle);\\n    return Math.min(diff, 360 - diff);\\n};\\n```\\n\\nHere is explanation: https://www.varsitytutors.com/sat_math-help/how-to-find-the-angle-of-clock-hands\\n\\n![image](https://assets.leetcode.com/users/eforce/image_1581191938.png)\\n",
                "solutionTags": [],
                "code": "```\\nvar angleClock = function(hour, minutes) {\\n    var minutesAngle = minutes * 6;\\n    var hoursAngle = (hour + minutes / 60) * 30;\\n    var diff = Math.abs(minutesAngle - hoursAngle);\\n    return Math.min(diff, 360 - diff);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502808,
                "title": "simple-java-solution-w-explanation",
                "content": "We can compute the angle between each hand and the vertical line, then take the absolute sum of them.\\nFirst angle (the one between the minute hand and the vertical line): `minutes*360 / 60`\\nSecond angle (the one between the hour hand and the vertical line): `hour offset from 12 o\\'clock` + `minute offset from its hour time`\\n```\\npublic double angleClock(int hour, int minutes) {\\n        double minAngle = minutes*360 / 60;\\n        double hourAnglePart1 = hour != 12 ? (hour * 360) / 12 : 0;\\n        double hourAnglePart2 = (double) (30 * minutes)/ (double) 60;\\n        double hourAngle = hourAnglePart1 + hourAnglePart2;\\n        double preResult = Math.abs(minAngle - (hourAngle));\\n        return preResult > 180 ? 360 - preResult : preResult;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic double angleClock(int hour, int minutes) {\\n        double minAngle = minutes*360 / 60;\\n        double hourAnglePart1 = hour != 12 ? (hour * 360) / 12 : 0;\\n        double hourAnglePart2 = (double) (30 * minutes)/ (double) 60;\\n        double hourAngle = hourAnglePart1 + hourAnglePart2;\\n        double preResult = Math.abs(minAngle - (hourAngle));\\n        return preResult > 180 ? 360 - preResult : preResult;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 744048,
                "title": "java-simple-small-and-efficient-code",
                "content": "Simple efficient java code.\\n\\n\\tclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n\\n\\t\\tdouble angle = 0;\\n\\t\\tdouble minAngle = minutes * 6;\\n\\t\\tdouble hrAngle = hour * 30 + (minAngle / 360 * 30);\\n\\t\\thrAngle = hrAngle % 360;\\n\\n\\t\\tangle = Math.abs(hrAngle - minAngle);\\n\\n\\t\\tangle = Math.min(angle, 360 - angle);\\n\\n\\t\\treturn angle;\\n\\t}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double angleClock(int hour, int minutes) {\\n\\n\\t\\tdouble angle = 0;\\n\\t\\tdouble minAngle = minutes * 6;\\n\\t\\tdouble hrAngle = hour * 30 + (minAngle / 360 * 30);\\n\\t\\thrAngle = hrAngle % 360;\\n\\n\\t\\tangle = Math.abs(hrAngle - minAngle);\\n\\n\\t\\tangle = Math.min(angle, 360 - angle);\\n\\n\\t\\treturn angle;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 735419,
                "title": "simple-c-solution-0ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double(abs(5.5*minutes - 30*hour));\\n        if(double(abs(5.5*minutes - 30*hour))>180)\\n            return 360-double(abs(5.5*minutes - 30*hour));\\n        else\\n            return double(abs(5.5*minutes - 30*hour));\\n    }\\n};\\n```\\n\\n# Simple Formula to Calculate the Angle between the hands of a clock\\n**x = 11m/2-30h***",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double(abs(5.5*minutes - 30*hour));\\n        if(double(abs(5.5*minutes - 30*hour))>180)\\n            return 360-double(abs(5.5*minutes - 30*hour));\\n        else\\n            return double(abs(5.5*minutes - 30*hour));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734934,
                "title": "simple-math-python-solution-with-detailed-explanation",
                "content": "Clock is a circle, so the overall angle is 360. \\nThere are 60 minutes, which completes one whole circle, so angle of each minute is 360 / 60 = 6.\\nSimilarly, 12 hours, so angle of each hour is 360 // 12 = 30.\\n\\nWhile calculating hour angle, add minutes into hour because hour hand moves with each second and minute with a minute angle.\\n\\nSo, the actual hours will be hours + minutes / 60 and then multiply by 30 to get the angle.\\n\\n**Note:** In Python, Don\\'t divide by // as it will give you floor number i.e. for 3//2 will give 1 instead of 1.5 and we are interested in that fraction value, So use single forward slash \\'/\\' instead of double \\'//\\'.\\n\\n**Don\\'t forget to upvote if you find it useful!!**\\n\\n**Happy LeetCoding!! :)**\\n\\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        one_min_angle = 6\\n        one_hour_angle = 30\\n        \\n        minute_angle = minutes * one_min_angle\\n        hour_angle = (hour + (minutes / 60)) * one_hour_angle      # calculate hour angle by adding minutes into hour\\n        \\n        \\n        diff = abs(hour_angle - minute_angle)            # get absolute difference between angles\\n        \\n        return diff if diff <= 180 else 360 - diff          # return min angle, if diff > 180 then subtract from 360\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        one_min_angle = 6\\n        one_hour_angle = 30\\n        \\n        minute_angle = minutes * one_min_angle\\n        hour_angle = (hour + (minutes / 60)) * one_hour_angle      # calculate hour angle by adding minutes into hour\\n        \\n        \\n        diff = abs(hour_angle - minute_angle)            # get absolute difference between angles\\n        \\n        return diff if diff <= 180 else 360 - diff          # return min angle, if diff > 180 then subtract from 360\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503681,
                "title": "python-faster-than-100",
                "content": "```\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        hour %= 12 \\n        h = hour*30 + minutes/2\\n        m = 6 * minutes\\n        return min(abs(h-m), 360-abs(m-h))",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        hour %= 12 \\n        h = hour*30 + minutes/2\\n        m = 6 * minutes\\n        return min(abs(h-m), 360-abs(m-h))",
                "codeTag": "Python3"
            },
            {
                "id": 2621242,
                "title": "c-beats-100-best-approach-no-explanation-needed",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double minDegree=6*minutes;\\n        if(hour==12)\\n            hour=0;\\n        double hourDegree=double(hour+minutes/60.0)*30;\\n        double angle1=abs(minDegree-hourDegree);\\n        double angle2=360-angle1;\\n        return min(angle1,angle2);\\n    }\\n};\\n\\nif(itHelps)\\n\\t upvote++;\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double minDegree=6*minutes;\\n        if(hour==12)\\n            hour=0;\\n        double hourDegree=double(hour+minutes/60.0)*30;\\n        double angle1=abs(minDegree-hourDegree);\\n        double angle2=360-angle1;\\n        return min(angle1,angle2);\\n    }\\n};\\n\\nif(itHelps)\\n\\t upvote++;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735353,
                "title": "java-c-4-line-mathematical-solution-with-explanation",
                "content": "The code uses following facts.\\n1. Every hour, hour hand crosses 30 degree angle. ( 360 degreee / 12 hours = 30 degrees)\\n2. Every minute, minute hand covers 6 degree angle. (360 degree / 60 minutes = 6 degree )\\n3. Every minute, hour hand covers 0.5 degree angle. (30 degree / 60 minutes = 0.5 degree)\\n\\nNow we use above 3 facts to compute hourDegree for hour hand and minuteDegree for \\nminute hands. \\nWe take absolute difference between them and return minimum of (diff, 360 - diff).\\n\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double hourDegree = hour * 30 % 360 + minutes * 0.5;\\n        double minuteDegree = minutes * 6;\\n        \\n        double answer = Math.abs(minuteDegree - hourDegree);\\n        \\n        return Math.min(answer, 360 -answer);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double hourDegree = hour * 30 % 360 + minutes * 0.5;\\n        double minuteDegree = minutes * 6;\\n        \\n        double answer = Math.abs(minuteDegree - hourDegree);\\n        \\n        return Math.min(answer, 360 -answer);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651720,
                "title": "c-easy-solution-beats-100",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double min = minutes*6;\\n        double hr = 30*(hour%12) + 0.5*minutes;\\n\\n        double temp1 = abs(min-hr);\\n        double temp2 = 360-temp1;\\n\\n        if(temp1>temp2){\\n            return temp2;\\n        }\\n        \\n        return temp1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double min = minutes*6;\\n        double hr = 30*(hour%12) + 0.5*minutes;\\n\\n        double temp1 = abs(min-hr);\\n        double temp2 = 360-temp1;\\n\\n        if(temp1>temp2){\\n            return temp2;\\n        }\\n        \\n        return temp1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168210,
                "title": "c-solution-using-fractions",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hr, int min) {\\n        double hr1= 360/12, min1= hr1/5 , frac= (double)min/60;\\n        double hrAngle= (hr+frac)*hr1 , minAngle= min*min1;\\n        // cout<<hrAngle<<\" \"<<minAngle;\\n        double ans= abs(hrAngle- minAngle);\\n        return ans<180 ?ans: 360-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hr, int min) {\\n        double hr1= 360/12, min1= hr1/5 , frac= (double)min/60;\\n        double hrAngle= (hr+frac)*hr1 , minAngle= min*min1;\\n        // cout<<hrAngle<<\" \"<<minAngle;\\n        double ans= abs(hrAngle- minAngle);\\n        return ans<180 ?ans: 360-ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2955410,
                "title": "c-100-faster-o-1-time-and-space-very-simple-concise-solution-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***Note:** For complete code, please scroll to the end. Detailed explanation continues below.*\\n\\n*This is a very easy and intuitive problem. Not sure why this is marked as a medium problem in Leetcode.*\\n\\nIf we set a standard unit of position measurement we can use the minute value to count the exact position(including extra displacement) of the hour hand. For example, if the time is 12:30, then hour hand is exactly at middle position of 12 and 1. To find the standard position we can use below formula:\\n\\nhourPosition = hour*(unit/12) + (unit/12)*(minute/60)\\n\\nHere,\\nhourPosition=exact position of hour hand\\nunit=total size of the clock in our new unit of mesaurement\\n\\nFor convenience, we can select unit as 60 minutes(unit=60) which is equivalent to 1 hour. This will mean that we won\\'t have to change our minute value to our new unit of measurement. We can later after finding our answer using this unit, calculate it with respect to 360 degree.\\n\\nNew formula becomes:\\n\\nhourPosition = hour*(5) + (5)*(minute/60)\\n\\nWe only have to keep 1 edge case in mind here that our hour input can have a value of 12. For such cases, we have to convert it to 0.\\n\\nAlso this might give us the bigger angle instead of the smaller angle. For this issue we can subtract the angle found from 360 and take the smaller value of the two.\\n\\n# Detailed Explanation/Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we take care of the edge case inline in our input.\\n\\n```\\nif(hour==12)\\n    hour=0;\\n```\\nNext we find the exact hour positions and minute positions. Since our output needs to be in double we will make the calculation accordingly and store it in a double variable. For hour position we will store it in hourDegree and for minute position we will store it in minDegree.\\n\\nFirst we find the hour position. Since our hour and minute values are integer always but we need double value, we calculate minutes/60.00 instead of minutes/60. This will make the rest of the calculation also happen using doubles due to implicit typecasting.\\n\\n```\\ndouble hourDegree=hour*5+(5*(minutes/60.00));\\n```\\nFor minute position, since our unit is also equivalent to minutes, we simply store the minute value to minPosition. Here also implicit typecasting takes care of integer to double conversion.\\n\\n```\\ndouble minDegree=minutes;\\n```\\nNext we find the difference between the positions and calculate the angle. For that we have to first calcualte the absolute difference of positions i.e. `abs(hourDegree-minDegree)`. Now, since our unit was equivalent to minutes, that means a whole rotation of the clock will give us 60 positions. That means 360 degree is reduced to 60 positions. So to convert it to degree, we have to multiply by 360/60 i.e. 6.\\n\\n```\\ndouble res=abs(hourDegree-minDegree)*6.00;\\n```\\nNow we have our angle in res variable. However, this might be the bigger angle. Since the smaller and bigger angles are complement of each other, we can simply take the difference of 360.00(we need to do calculation in doubles) and res and return the value which is less among res and 360.00-res.\\n\\n```\\nreturn min(res,360.00-res);\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince we don\\'t have any loops and our calculations are also basic, the TC is $$O(1)$$.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nOur SC is also $$O(1)$$ as we don\\'t have any variable sized containers.\\n\\n# Complete Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        if(hour==12)\\n         hour=0;\\n        double hourDegree=hour*5+(5*(minutes/60.00));\\n        double minDegree=minutes;\\n        double res=abs(hourDegree-minDegree)*6.00;\\n        return min(res,360.00-res);\\n    }\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/fe61a7ef-7c8d-4bcd-92b4-712cb72cbfee_1672094790.9694436.png)\\n\\nIf this helped you, please leave an upvote. Thanks. \\uD83D\\uDE0A\\uD83C\\uDF08",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif(hour==12)\\n    hour=0;\\n```\n```\\ndouble hourDegree=hour*5+(5*(minutes/60.00));\\n```\n```\\ndouble minDegree=minutes;\\n```\n```\\ndouble res=abs(hourDegree-minDegree)*6.00;\\n```\n```\\nreturn min(res,360.00-res);\\n```\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        if(hour==12)\\n         hour=0;\\n        double hourDegree=hour*5+(5*(minutes/60.00));\\n        double minDegree=minutes;\\n        double res=abs(hourDegree-minDegree)*6.00;\\n        return min(res,360.00-res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658342,
                "title": "easy-java-implementation-with-explaination",
                "content": "Approach:\\n* In 12 hours , hour hand can do 360 degrees , so per hour hour hand will do 30 degrees.\\n* Similarly in 60 minutes, minute hand can do 360 degrees, so in 1 minute, the minute hand will do 6 degree rotation.\\n* Also keep in mind while the minute hand is moving the hour hand will move along with it. Like in 60 minutes , the hour hand rotates 30 degrees\\n* So per minute the hour hand rotates 0.5 degrees.\\n\\n* Now simply find the difference between the hour and minute hand store it in result.\\n* Now check whether result or 360 - result, which is smaller and return it as the result.\\n\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n         double angleHour = hour*30, angleMinutes = minutes*6;\\n        \\n        angleHour =angleHour + 0.5*(minutes);\\n        \\n        double res = Math.abs(angleHour - angleMinutes);\\n        \\n        return Math.min(res, 360-res);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n         double angleHour = hour*30, angleMinutes = minutes*6;\\n        \\n        angleHour =angleHour + 0.5*(minutes);\\n        \\n        double res = Math.abs(angleHour - angleMinutes);\\n        \\n        return Math.min(res, 360-res);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450691,
                "title": "python-easy-code-with-comments",
                "content": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        #Angle traversal by hourhand\\n        hAngle = 30*(hour%12)\\n        \\n        #Angle traversal by minuteshand\\n        mAngle = 6*(minutes%60)\\n        \\n        #Extra traversal by hourhand based on minutes hand\\n        extraAngle = (minutes/60)*30\\n        \\n        hAngle+=extraAngle\\n        \\n        #Angle difference\\n        diff = abs(hAngle-mAngle)\\n        \\n        #Always prefer acute angle\\n        return min(diff,360-diff)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        #Angle traversal by hourhand\\n        hAngle = 30*(hour%12)\\n        \\n        #Angle traversal by minuteshand\\n        mAngle = 6*(minutes%60)\\n        \\n        #Extra traversal by hourhand based on minutes hand\\n        extraAngle = (minutes/60)*30\\n        \\n        hAngle+=extraAngle\\n        \\n        #Angle difference\\n        diff = abs(hAngle-mAngle)\\n        \\n        #Always prefer acute angle\\n        return min(diff,360-diff)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424720,
                "title": "100",
                "content": "double angleClock(int ho, int min) {\\n        double x=0,y=0;\\n        if (ho==12)\\n        {\\n            ho=0;\\n        }\\n        x=ho*(30);\\n        x+=(min*0.5);\\n        y=(min*6);\\n        double ans;\\n        if (x>y)\\n        {\\n            ans= x-y;\\n        }\\n       else{\\n            ans= y-x;\\n       }\\n        \\n       \\n        if (ans>180)\\n        {\\n           return 360- ans;\\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "double angleClock(int ho, int min) {\\n        double x=0,y=0;\\n        if (ho==12)\\n        {\\n            ho=0;\\n        }\\n        x=ho*(30);\\n        x+=(min*0.5);\\n        y=(min*6);\\n        double ans;\\n        if (x>y)\\n        {\\n            ans= x-y;\\n        }\\n       else{\\n            ans= y-x;\\n       }\\n        \\n       \\n        if (ans>180)\\n        {\\n           return 360- ans;\\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2169417,
                "title": "python-1-liner-o-1",
                "content": "1. The minute hand will move `m_angle = 6*m` degrees.\\n2. The hour hand will move `h_angle = 30*h + 0.5*m` degrees.\\n3. `angle = abs(h_angle - m_angle)`\\n4. Answer is `min(angle,360-angle)`\\n```\\nclass Solution:\\n    def angleClock(self, h: int, m: int) -> float:\\n        return min(abs(6*m - (30*h + 0.5*m )), 360-abs(6*m - (30*h + 0.5*m )))\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, h: int, m: int) -> float:\\n        return min(abs(6*m - (30*h + 0.5*m )), 360-abs(6*m - (30*h + 0.5*m )))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007927,
                "title": "python-easy-solution-full-explanation",
                "content": "12 hours = 360 degree\\n1 hour = 30 degree \\n60 mins = 360 degree\\n1 min = 6 degree\\nso first we will calculate the degree for the minutes hand i.e., \\na=6 * minutes\\nnow we will calculate the dgree for the hour hand,\\nb=(hour+minutes/60) * 30 (minutes/60 is done so that we can get the exact position of the hour hand like what if it is between any hours (ex: 2 and 3 )\\nNow c=abs(a-b)\\nd=(360-c)\\nreturn min(c,d) (what if the degree between hands is coming low from the other side so taking the minimum of the both.\\nHere is the code,\\n \\n \\n\\t\\ta=minutes*6\\n        b=(hour+(minutes/60))*30\\n        c=abs(a-b)\\n        d=abs(360-c)\\n        return min(c,d)\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\nUpvote it, if you like...",
                "solutionTags": [],
                "code": "12 hours = 360 degree\\n1 hour = 30 degree \\n60 mins = 360 degree\\n1 min = 6 degree\\nso first we will calculate the degree for the minutes hand i.e., \\na=6 * minutes\\nnow we will calculate the dgree for the hour hand,\\nb=(hour+minutes/60) * 30 (minutes/60 is done so that we can get the exact position of the hour hand like what if it is between any hours (ex: 2 and 3 )\\nNow c=abs(a-b)\\nd=(360-c)\\nreturn min(c,d) (what if the degree between hands is coming low from the other side so taking the minimum of the both.\\nHere is the code,\\n \\n \\n\\t\\ta=minutes*6\\n        b=(hour+(minutes/60))*30\\n        c=abs(a-b)\\n        d=abs(360-c)\\n        return min(c,d)\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\nUpvote it, if you like...",
                "codeTag": "Unknown"
            },
            {
                "id": 1911342,
                "title": "python-one-line-solution-based-on-aptitude-formula",
                "content": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        return min(abs(30*hour-5.5*minutes),360-abs(30*hour-5.5*minutes))\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        return min(abs(30*hour-5.5*minutes),360-abs(30*hour-5.5*minutes))\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889556,
                "title": "python-easiest-to-understand-comments-clear-and-concise",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def angleClock(self, h, m):\\n        # Convert the hour hand to another minute hand\\n        m2 = (h%12 + m/60)*5\\n        \\n        # Calculate the difference between the two minute hands\\n        diff = abs(m-m2)\\n        \\n        # Convert the difference to an angle\\n        ang = diff*(360/60)\\n        \\n        # Return the smallest angle\\n        return min(360-ang, ang)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, h, m):\\n        # Convert the hour hand to another minute hand\\n        m2 = (h%12 + m/60)*5\\n        \\n        # Calculate the difference between the two minute hands\\n        diff = abs(m-m2)\\n        \\n        # Convert the difference to an angle\\n        ang = diff*(360/60)\\n        \\n        # Return the smallest angle\\n        return min(360-ang, ang)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839139,
                "title": "java-easy-explanation-on-clock-angles",
                "content": "**Find A ( Angle of Hour Hand from start/origin/0 degree)**\\n\\n12 hours = 360 deg\\n1 hour = 30 deg\\n\\nalso 60 minutes = 30 deg\\n**1 min = 0.5 deg**\\n\\nIt means hour hand rotate by 0.5 degrees every minute\\n\\n**A = 30*Hours +  (0.5)Minutes**\\n\\n**30*Hours**  = Rotation of hour hand from start every hour ( as 1 hour = 30 deg , so n hours = 30*n ) \\n**0.5minutes** = Rotation of hour hand from start every minute  \\n\\n![image](https://assets.leetcode.com/users/images/270a4a24-6599-42d6-a689-6ebe75310994_1646986749.7168727.png)\\n\\n<br>\\n<hr>\\n<br>\\n\\n**Find B ( Angle of Minute Hand from start/origin/0 degree)**\\n\\n60 minutes = 360 deg\\n**1 min = 6 deg**\\n\\nIt means minute hand rotate by 6 degrees every minute\\n\\n**B = 6*minutes**\\n\\n![image](https://assets.leetcode.com/users/images/812d1093-311f-4ccf-9852-46e57ec9c475_1646986847.6751308.png)\\n\\n<br>\\n\\n**Difference of A and B will give us Angle Between Hands of a Clock**\\nAngle(C) = Math.abs(A-B)\\n\\n![image](https://assets.leetcode.com/users/images/ed6ca54f-97ab-45e1-bbf8-91a6b2ef238e_1646988496.2992537.png)\\n\\n<br>\\n<hr>\\n<br>\\n\\n**Java Code**\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n\\t\\t//Angle of Hour Hand from start\\n        double hourHand = 30*hour + (0.5)*minutes;\\n        \\n\\t\\t//Angle of Minute Hand from start\\n        double minHand = 6 * minutes;\\n        \\n        //Difference of A and B will give us Angle Between Hands of a Clock\\n        double angle = Math.abs(hourHand - minHand);\\n        \\n\\t\\t// to return the smaller angle formed between the hour and the minute hand.\\n        return angle > 180 ? 360 - angle : angle;\\n    }\\n}\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n\\t\\t//Angle of Hour Hand from start\\n        double hourHand = 30*hour + (0.5)*minutes;\\n        \\n\\t\\t//Angle of Minute Hand from start\\n        double minHand = 6 * minutes;\\n        \\n        //Difference of A and B will give us Angle Between Hands of a Clock\\n        double angle = Math.abs(hourHand - minHand);\\n        \\n\\t\\t// to return the smaller angle formed between the hour and the minute hand.\\n        return angle > 180 ? 360 - angle : angle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758598,
                "title": "c-0ms-beats-100-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n          return min( abs( (hour % 12 + minutes/60.0) * 30 - (minutes*6) ), 360 -  abs( (hour % 12 + minutes/60.0) * 30 - (minutes*6) ));\\n    }\\n};\\n\\n\\n\\n(hr % 12 + min/60 ) * 360/12 - min/60 * 360\\nformula for finding angle \\n\\nupvote if it was helpfull\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n          return min( abs( (hour % 12 + minutes/60.0) * 30 - (minutes*6) ), 360 -  abs( (hour % 12 + minutes/60.0) * 30 - (minutes*6) ));\\n    }\\n};\\n\\n\\n\\n(hr % 12 + min/60 ) * 360/12 - min/60 * 360\\nformula for finding angle \\n\\nupvote if it was helpfull\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687385,
                "title": "c-simple-math-solution-2-lines-0ms",
                "content": "It is a simple conversion question.\\nThe angle between hour and minute hand = angle from 12 o\\'clock to hour hand - angle from 12 o\\'clock to minutes hand\\n\\nangle from 12 o\\'clock to hour hand = ((5*hour + (minutes/60)*5))/60)*360 [because hour hand will be slightly moved in clockwise direction because of minutes passed and also converting to degrees]\\n\\nangle from 12 o\\'clock to minutes hand = (minutes/60)*360\\n\\nOn simplification we get,\\nangle between hour hand and minutes hand = 30*hour - 5.5*minutes\\n\\nBecause we should take the smaller angle, we use the min function to find the minimum of (angle, 360 - angle)\\n\\nNOTE: The result angle could be negative so we take the absolute value\\n\\n ```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double ans = abs(30*hour - (5.5*minutes));\\n        return min(ans, 360-ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double ans = abs(30*hour - (5.5*minutes));\\n        return min(ans, 360-ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323801,
                "title": "100-c-0ms-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        \\n        if(hour == 12) hour = 0;\\n        double a = ((hour)*30.0 + (minutes)*0.5);\\n        double b = (minutes)*6.0;\\n        \\n        return abs(a-b)>180.0 ? 360.0-abs(a-b) : abs(a-b);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        \\n        if(hour == 12) hour = 0;\\n        double a = ((hour)*30.0 + (minutes)*0.5);\\n        double b = (minutes)*6.0;\\n        \\n        return abs(a-b)>180.0 ? 360.0-abs(a-b) : abs(a-b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281213,
                "title": "easy-c-100-faster-o-1-space-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        //get the degree of minutes and hours from the 12 (pointing at 12)\\n        \\n        double  minDegree=(minutes* 6);\\n        //30 degree gap in between each hour\\n        double hourDegree=(hour==12) ? 0 : hour*30;\\n        //some degree are gonna add to hour because of the minute hand\\n        //for x minutes the hour degree moves (1/2)*x \\n\\t\\t//ex x= 30 min (pointing at 6 ) and hour is at 12 , then the hour hand moves a extra of (1/2) * 30 = 15 degrees ahead\\n        hourDegree+= (double)(minutes)/2;\\n        \\n\\t\\t//get the angle in degrees between them\\n        double angle=abs(minDegree-hourDegree);\\n        \\n        //there are two possibles angles \\n        return min(angle,360-angle);\\n    }\\n};\\n```\\n**Please upvote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        //get the degree of minutes and hours from the 12 (pointing at 12)\\n        \\n        double  minDegree=(minutes* 6);\\n        //30 degree gap in between each hour\\n        double hourDegree=(hour==12) ? 0 : hour*30;\\n        //some degree are gonna add to hour because of the minute hand\\n        //for x minutes the hour degree moves (1/2)*x \\n\\t\\t//ex x= 30 min (pointing at 6 ) and hour is at 12 , then the hour hand moves a extra of (1/2) * 30 = 15 degrees ahead\\n        hourDegree+= (double)(minutes)/2;\\n        \\n\\t\\t//get the angle in degrees between them\\n        double angle=abs(minDegree-hourDegree);\\n        \\n        //there are two possibles angles \\n        return min(angle,360-angle);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896674,
                "title": "python-3-simple-faster-than-72-33-and-memort-less-than-100",
                "content": "I didn\\'t think that this is gonna work, but here it is, scoring a perfect memory score. I will first show you the code, and then explain it to you. \\n```\\ndef main(hour, minutes):\\n    minutesAngle = minutes * 6\\n    hourAngle = (((hour % 12) * 30) + ((minutes / 60) * 30))\\n    angle = abs(hourAngle - minutesAngle)\\n    return min(angle, 360 - angle)\\n```\\n\\n\\nFirst of all, we measure the angle at which, minute hand will be. Now, there are 60 minutes and 360 degress, thus, 1 minute is (360 / 60) 6 degrees. \\nhourAngle depends on hour hand, as well has the minutes hand. First of all, every hour except 12 add 30 degrees. Thus, we used modulo. Then, if it is one hour and 60 minutes, its basically two hours. Therefore, to calculate the additional angle, we divide the minutes by 60, and then multiply by 30. You can directly divide by 2, but I felt that is more intuitive. \\nThen, we calculate the difference between minute and hour angle and to return minimum, we return minimum between angle and 360 - angle.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef main(hour, minutes):\\n    minutesAngle = minutes * 6\\n    hourAngle = (((hour % 12) * 30) + ((minutes / 60) * 30))\\n    angle = abs(hourAngle - minutesAngle)\\n    return min(angle, 360 - angle)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 820584,
                "title": "javascript-with-detailed-explanation",
                "content": "Idea: Consider 12pm to be degree `0`. Then calculate the degrees of hour hand and minute hand. Return the difference.\\n\\nFor example: `03:30pm`\\n```\\nminute hand: (30 / 60) * 360 = 180\\nmeaning 30 of 60 minutes takes half of a circle (360 degrees)\\n\\nhour hand: (3 * 360 / 12) + (30 / 60 * 360 / 12) = 105\\nmeaning 3 hours take 3 hour sectors (360 / 12) and 30 of 60 minutes takes half of a hour sector (360 / 12)\\n\\n180 - 105 = 75, the answer\\n```\\n\\n##### Javascript\\n```javascript\\nvar angleClock = function(hour, minutes) {\\n    const minuteAngle = minutes / 60 * 360;\\n    const hourAngle = (hour % 12 + minutes / 60 ) * 360 / 12;\\n    let ans = Math.abs(minuteAngle - hourAngle);\\n    return ans >= 180 ? 360 - ans : ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nminute hand: (30 / 60) * 360 = 180\\nmeaning 30 of 60 minutes takes half of a circle (360 degrees)\\n\\nhour hand: (3 * 360 / 12) + (30 / 60 * 360 / 12) = 105\\nmeaning 3 hours take 3 hour sectors (360 / 12) and 30 of 60 minutes takes half of a hour sector (360 / 12)\\n\\n180 - 105 = 75, the answer\\n```\n```javascript\\nvar angleClock = function(hour, minutes) {\\n    const minuteAngle = minutes / 60 * 360;\\n    const hourAngle = (hour % 12 + minutes / 60 ) * 360 / 12;\\n    let ans = Math.abs(minuteAngle - hourAngle);\\n    return ans >= 180 ? 360 - ans : ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736348,
                "title": "java-3-line-simple-ans-o-1-time-with-explanation",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        // Find angle made by minute hand\\n        double min = 6.0*minutes;\\n\\t\\t// Find andgle made by hour hand\\n        double hr = 30.0*(hour%12) + 0.5*minutes;\\n        \\n\\t\\t// Return the difference between both hands (We need smaller angle that\\'s why did Math.min())\\n        return Math.min(360.0-Math.abs(min - hr), Math.abs(min - hr));\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double angleClock(int hour, int minutes) {\\n        // Find angle made by minute hand\\n        double min = 6.0*minutes;\\n\\t\\t// Find andgle made by hour hand\\n        double hr = 30.0*(hour%12) + 0.5*minutes;\\n        \\n\\t\\t// Return the difference between both hands (We need smaller angle that\\'s why did Math.min())\\n        return Math.min(360.0-Math.abs(min - hr), Math.abs(min - hr));\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 736322,
                "title": "python-o-1-o-1",
                "content": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        hr_pos = (hour%12)*5 + (minutes/60)*5\\n\\t\\tdiff_angle = abs(minutes - hr_pos) * 6\\n\\n        if diff_angle > 180:\\n            return 360-diff_angle\\n\\n        return diff_angle\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        hr_pos = (hour%12)*5 + (minutes/60)*5\\n\\t\\tdiff_angle = abs(minutes - hr_pos) * 6\\n\\n        if diff_angle > 180:\\n            return 360-diff_angle\\n\\n        return diff_angle\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736234,
                "title": "java-o-1-0ms-2-line-solution",
                "content": "**Implementation**\\n```\\npublic double angleClock(int h, int m) {\\n        double theta = Math.abs(30 * h - 5.5 * m);        \\n        return (theta > 180) ? 360 - theta : theta;\\n    }\\n```\\n**Logic**\\nWe need to calculate the difference of angle swept by both hands from *any arbitrary position* to the current position. This will be one of the two angles, using this we can  obtain the result.\\n\\nFor simple understanding lets consider **12:00** as *arbitrary position*. This is one of the position where both hands are overlapping (angle b/w both hands is zero) hence, difference between the two swept angles will give us one of the angles between hour hand and minute hand.\\n\\nNow we can arrive to the solution by following below steps:\\n1. Calculate the angle swept by both hands(\\u2220Hour and \\u2220Minute). Angle swept by any hand can be calculated by considering the fact that Clock can be divided into:\\n* 12 sectors of (360/12=) **30 degrees** for calculating \\u2220Hour,\\n* 60 sectors of (360/60=) **6 degrees** for calculating \\u2220Minute and \\u2220Hour\\n* Hour hand also moves every minute by **(30 / 60) = 0.5 degrees** Hence in *m* minutes it will move by  **(30 *  m / 60) degrees**\\n```\\n    angleH = 30 * (h + m / 60F);  // i.e. (30 * h) + (30 * m / 60)\\n    angleM = 6 * m; // i.e. 360 * m / 60\\n```\\n\\n2. Find the absolute difference between swept angles i.e. (say) **\\u03B8 = |\\u2220Hour - \\u2220Minute|**.\\n*\\u03B8* and *360 - \\u03B8* as the two angles between both hand.\\n```\\n    theta = Math.abs(angleH - angleM);\\n````\\n3. Find the smaller angle between *\\u03B8* and *360 - \\u03B8*. **Result = min(\\u03B8, 360-\\u03B8)**\\n```\\n    return Math.min(theta, 360-theta); \\n```\\nNote: Implementation has simplified expression for ```\\u03B8``` (or ```theta```)\\n\\n![image](https://assets.leetcode.com/users/images/b0a42dbc-f3dc-4e4f-a322-92075a59c9aa_1594890188.0851424.png)\\n\\n\\n\\n     \\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic double angleClock(int h, int m) {\\n        double theta = Math.abs(30 * h - 5.5 * m);        \\n        return (theta > 180) ? 360 - theta : theta;\\n    }\\n```\n```\\n    angleH = 30 * (h + m / 60F);  // i.e. (30 * h) + (30 * m / 60)\\n    angleM = 6 * m; // i.e. 360 * m / 60\\n```\n```\\n    theta = Math.abs(angleH - angleM);\\n```\n```\\n    return Math.min(theta, 360-theta); \\n```\n```\\u03B8```\n```theta```",
                "codeTag": "Unknown"
            },
            {
                "id": 632493,
                "title": "java-0ms-beats-100-space-and-time-with-full-explanation",
                "content": "1. The Hour hand moves 30 (360/12) degrees every hour and 1/2 (30/60) a degree every minute.\\n2. The Minute hand moves 6 (360/60) degrees every minute.\\n3. Therefore the total movement of hand hour is : hours  30 + minutes  0.5 or total number of minutes  0.5 which is  : (hour60+minutes)0.5 \\n4. The total movement of minute hour is : minutes  6.\\n5. Now get the difference between both the movements and get the absolute value of it (as angle cannot the negative here).\\n6. Now if the resulting angle comes to be more than 180 degrees then return 360-angle as the answer as the answer requires the smaller angle.\\n\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double angle=Math.abs((hour*60+minutes)*0.5-minutes*6);\\n        return angle>180.0?360.0-angle:angle;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double angle=Math.abs((hour*60+minutes)*0.5-minutes*6);\\n        return angle>180.0?360.0-angle:angle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630465,
                "title": "java-100-runtime-o-1-and-100-space-2-lines",
                "content": "\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n\\t\\n        double angel = Math.abs((hour + (minutes/60.0))-(minutes/5.0))*30;       \\n        return (angel<=180)? angel : 360-angel;\\n\\t\\t\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double angleClock(int hour, int minutes) {\\n\\t\\n        double angel = Math.abs((hour + (minutes/60.0))-(minutes/5.0))*30;       \\n        return (angel<=180)? angel : 360-angel;\\n\\t\\t\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 620444,
                "title": "c-6-lines-simple-maths-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n\\t//Distance travelled by hour hand with a speed of 0.5 degree per minute\\n        double hd=m*0.5;\\n\\t//Distance travelled by minute hand with a speed of 6 degree per minute\\n        double md=m*6;\\n\\t//Assuming the minute hand to be initially at 12, the difference will be hour*5*6\\n        double ex=h*5*6;\\n        if(h==12)ex=0;\\n\\t//The actual difference between thehour and minute hand\\n        double ans=abs(md-hd-ex);\\n        return (min(ans,360-ans));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n\\t//Distance travelled by hour hand with a speed of 0.5 degree per minute\\n        double hd=m*0.5;\\n\\t//Distance travelled by minute hand with a speed of 6 degree per minute\\n        double md=m*6;\\n\\t//Assuming the minute hand to be initially at 12, the difference will be hour*5*6\\n        double ex=h*5*6;\\n        if(h==12)ex=0;\\n\\t//The actual difference between thehour and minute hand\\n        double ans=abs(md-hd-ex);\\n        return (min(ans,360-ans));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504101,
                "title": "python-3-math-line-by-line-explanation-16ms-beats-100",
                "content": "```py\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        m = minutes * 6     # Scale up minutes [0, 360): 360/60 = 6\\n        h = (hour%12) * 30  # Hours to [0, 12), then scale up to [0, 360): 360/12 = 30\\n        h += m / 12         # Adjust hour hand: full rotation of minute hand moves hour hand 1/12th of the circle\\n        angle = abs(m - h)  # Get rid of the smallest hand by adjusting it to 0. This moves the largest to -smallest\\n        return angle if angle < 180 else 360 - angle  # Return the smaller angle\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        m = minutes * 6     # Scale up minutes [0, 360): 360/60 = 6\\n        h = (hour%12) * 30  # Hours to [0, 12), then scale up to [0, 360): 360/12 = 30\\n        h += m / 12         # Adjust hour hand: full rotation of minute hand moves hour hand 1/12th of the circle\\n        angle = abs(m - h)  # Get rid of the smallest hand by adjusting it to 0. This moves the largest to -smallest\\n        return angle if angle < 180 else 360 - angle  # Return the smaller angle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502773,
                "title": "java-4-liner",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double ans = (Math.abs(hour * 5 - minutes)) * 6.0;\\n        if(hour * 5 >= minutes) ans += (1.0 * minutes) / (2.0);\\n        else ans -= (1.0 * minutes) / (2.0);\\n        return Math.abs(Math.min(ans, 360 * 1.0 - ans));\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double ans = (Math.abs(hour * 5 - minutes)) * 6.0;\\n        if(hour * 5 >= minutes) ans += (1.0 * minutes) / (2.0);\\n        else ans -= (1.0 * minutes) / (2.0);\\n        return Math.abs(Math.min(ans, 360 * 1.0 - ans));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4008455,
                "title": "simple-arithmetics-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        int totalMinutes=hour*60+minutes;\\n     double hourAngle=totalMinutes*0.5;\\n     double minuteAngle=minutes*6;\\n     if(hourAngle>=360)\\n     hourAngle=hourAngle-360;\\ndouble ans=Math.abs(minuteAngle-hourAngle);\\nif(ans>180.00)\\nans=360.00-ans;\\nreturn ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        int totalMinutes=hour*60+minutes;\\n     double hourAngle=totalMinutes*0.5;\\n     double minuteAngle=minutes*6;\\n     if(hourAngle>=360)\\n     hourAngle=hourAngle-360;\\ndouble ans=Math.abs(minuteAngle-hourAngle);\\nif(ans>180.00)\\nans=360.00-ans;\\nreturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855754,
                "title": "simple-aptitude-o-1-in-time-and-space",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double minuteAngle = minutes*6, hourAngle = (hour*30 + minutes/2.0);\\n        if(hourAngle > 360) hourAngle -= 360;\\n\\n       double angle = abs(minuteAngle - hourAngle); //take the difference of angle swept by hour hand and minute hand\\n       return min(angle,360 - angle); //return acute angle\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double minuteAngle = minutes*6, hourAngle = (hour*30 + minutes/2.0);\\n        if(hourAngle > 360) hourAngle -= 360;\\n\\n       double angle = abs(minuteAngle - hourAngle); //take the difference of angle swept by hour hand and minute hand\\n       return min(angle,360 - angle); //return acute angle\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762671,
                "title": "solution-python",
                "content": "# Intuition\\n- This is a tricky problem, here any `division` of whole `whole` numbers will be evealuated to `floor` division. \\n*In Python 2.x, the division of two integers returns an integer result (floor division) instead of a float.*\\nMaybe the author wanted to pay respect or whatever.\\nSo:\\n    - You can try `return 1 / 2 ` and see `0` \\n    - That\\'s why you need to divide by a `float` number\\n\\n\\n\\n- Also,  the function `abs` Returns the absolute value of the argument.\\n\\n# Detailed Code\\n```\\nclass Solution(object):\\n    def angleClock(self, hour, minutes):\\n        \"\"\"\\n        1 hour = 30\\n        1 minute = 6\\n        \"\"\"\\n        if hour == 12:\\n            hour = 0\\n        hand_one_angle = hour * 30 + (minutes / 2.0)\\n\\n        hand_two_angle = minutes * 6\\n\\n        angle = hand_one_angle - hand_two_angle\\n        angle = abs(angle)  \\n\\n        return angle if angle <= 180 else 360 - angle\\n```\\n# Short code\\n```\\nclass Solution(object):\\n    def angleClock(self, hour, minutes):\\n        if hour == 12:\\n            hour = 0\\n\\n        angle = abs(hour * 30 + (minutes / 2.0) - minutes * 6)\\n        return angle if angle <= 180 else 360 - angle\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def angleClock(self, hour, minutes):\\n        \"\"\"\\n        1 hour = 30\\n        1 minute = 6\\n        \"\"\"\\n        if hour == 12:\\n            hour = 0\\n        hand_one_angle = hour * 30 + (minutes / 2.0)\\n\\n        hand_two_angle = minutes * 6\\n\\n        angle = hand_one_angle - hand_two_angle\\n        angle = abs(angle)  \\n\\n        return angle if angle <= 180 else 360 - angle\\n```\n```\\nclass Solution(object):\\n    def angleClock(self, hour, minutes):\\n        if hour == 12:\\n            hour = 0\\n\\n        angle = abs(hour * 30 + (minutes / 2.0) - minutes * 6)\\n        return angle if angle <= 180 else 360 - angle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759900,
                "title": "simple-math",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double min=minutes;\\n        double hr=hour;\\n//taking 12 as reference, hr*30 is the angle rotated by hour hand,min*6 is angle rotated by minute hand and when minute hand rotates by 6deg, hour hand rotates by 0.5deg in same sence...can be proven.\\n        double deg=abs(hr*30-min*6+min/2);\\n        if(deg>180){\\n            deg=360-deg;\\n        }\\n        return deg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double min=minutes;\\n        double hr=hour;\\n//taking 12 as reference, hr*30 is the angle rotated by hour hand,min*6 is angle rotated by minute hand and when minute hand rotates by 6deg, hour hand rotates by 0.5deg in same sence...can be proven.\\n        double deg=abs(hr*30-min*6+min/2);\\n        if(deg>180){\\n            deg=360-deg;\\n        }\\n        return deg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655543,
                "title": "simple-and-easy-c-solution-t-n-o-1",
                "content": "# Intuition\\nJust have to figure out how the angles of the hands of the clocks are changing.So,\\n\\nthe minute hand of the clock moves 360 degree in one hour(60 min) which means (360/60)= 6 degree in a minute, using this you can find out the angle of minutes hand.\\n\\nThe hour hand of the clock moves 360 degree in 12 hours(12x60 min) which means (360/(12x60)) =0.5 degree in a minute. Then you calculate angle of hour hand by adding the angle changed by the hour hand by minutes passed in that hour plus the angle it already had at the hour time like 5 O\\'clock or 3 O\\'clock (you can calulate by looking at the hour and multiply it by 30 as every 5 min where the notation for hour is given is 30 degree).\\n\\n# Approach\\nminute_hand_angle= 6* minutes\\n\\nhour_hand_angle=(0.5*minutes) + (hour%12)*30\\n\\nreturn the difference between the angles.     \\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double ma=minutes*6,ha=(0.5*minutes)+((hour%12)*30);\\n        return min(abs(ma-ha),360-abs(ma-ha));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double ma=minutes*6,ha=(0.5*minutes)+((hour%12)*30);\\n        return min(abs(ma-ha),360-abs(ma-ha));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549353,
                "title": "c-3-line-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        int dom = minutes*6;\\n        double doh = hour*30 + minutes*0.5;\\n        return min(abs(doh-dom) , 360-abs(doh-dom));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        int dom = minutes*6;\\n        double doh = hour*30 + minutes*0.5;\\n        return min(abs(doh-dom) , 360-abs(doh-dom));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511956,
                "title": "easy-mathematical-solution-in-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhour hand covers 30 degree in 60 mins and minute hand covers 360 degree in 60 minutes\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntaking 12 as 0 degree\\n\\nhour hand position in degree = initial postion + minutes * speed;\\nspeed of hour hand = 0.5 degree per minute\\nminute hand position in degree = initial position + minutes * speed;\\nspeed of minute hand = 6 degree per minute\\n# Complexity\\n- Time complexity:$$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        hour = hour % 12;\\n\\n        double h_moves = hour * 30.0 + minutes * 0.5;\\n        double m_moves = 0.0 + minutes * 6.0;\\n\\n        double a1 = abs(m_moves - h_moves);\\n\\n        return min(a1, 360.0 - a1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        hour = hour % 12;\\n\\n        double h_moves = hour * 30.0 + minutes * 0.5;\\n        double m_moves = 0.0 + minutes * 6.0;\\n\\n        double a1 = abs(m_moves - h_moves);\\n\\n        return min(a1, 360.0 - a1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995635,
                "title": "easy-c-solution-o-1-time-complexity",
                "content": "# Approach\\n1) Initialize two doubles hour1 and minutes1\\n2) hour1 is the distance of hour clock from 12 and minutes1 is the distance of the minute clock from 12\\n3) We then calculate the absolute difference between the distances and multiply it with 360/no of partitions(12) i.e. 30 and that will give us the angle between hour hand and minute hand\\n4) .\\n    ->If the result is less than 180 i.e. acute then it is the smaller angle and so we return the result\\n    ->If the result is more than 180 i.e. obtuse then it is the larger angle and so we return the smaller angle which will be 180-result\\n\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hour1 =hour%12+ minutes/60.0;\\n        double minutes1 =(minutes/60.0)*12;\\n        double result =abs(hour1-minutes1)*30.0;\\n        if(result<=180)return result;\\n        else return 360.0-result;\\n    }\\n};\\n//Upvote the answer if it was helpful ..Thank You\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hour1 =hour%12+ minutes/60.0;\\n        double minutes1 =(minutes/60.0)*12;\\n        double result =abs(hour1-minutes1)*30.0;\\n        if(result<=180)return result;\\n        else return 360.0-result;\\n    }\\n};\\n//Upvote the answer if it was helpful ..Thank You\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879501,
                "title": "basic-math-solution",
                "content": "\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n        double mAngle= m*6;\\n        double a=mAngle/12;\\n        if(h==12)\\n            h=0;\\n        double hAngle=((h*5*6)+a);\\n        double ans=max(mAngle,hAngle)-min(mAngle,hAngle);\\n        double temp=360-ans;\\n        return min(ans,temp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n        double mAngle= m*6;\\n        double a=mAngle/12;\\n        if(h==12)\\n            h=0;\\n        double hAngle=((h*5*6)+a);\\n        double ans=max(mAngle,hAngle)-min(mAngle,hAngle);\\n        double temp=360-ans;\\n        return min(ans,temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872418,
                "title": "o-1-space-and-time-solution-c-using-formula",
                "content": "# Approach\\nAngle = [(11/2)M-30H]\\nif it is greater than 180 return it after subtracting from 360.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:<b>$$O(1)$$</b>\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        if(hour==12)hour=0;\\n        double x=abs((60*hour)-(11*minutes));\\n        if(x/2<=180)\\n        return (x/2);\\n        else\\n            return 360-(x/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        if(hour==12)hour=0;\\n        double x=abs((60*hour)-(11*minutes));\\n        if(x/2<=180)\\n        return (x/2);\\n        else\\n            return 360-(x/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813551,
                "title": "c-easy-solution-0ms-100-fast-with-comments",
                "content": "```\\ndouble angleClock(int hour, int minutes){\\n    double maffhr=(double)minutes*30/60; //calculating the angle by which the hour hand is affected due to the minutes hand\\n    double hrangle=(double)hour*30+maffhr; //calculating the angle made by hour hand with 12\\n    double miangle=(double)minutes*30/5; //calculating the angle made by minutes hand with 12\\n    double ang=fabs(hrangle-miangle); //calculating the angle difference between the hour and minutes hand\\n    return fmin(ang,360-ang); //returns the minimum angle as been told in the description\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\ndouble angleClock(int hour, int minutes){\\n    double maffhr=(double)minutes*30/60; //calculating the angle by which the hour hand is affected due to the minutes hand\\n    double hrangle=(double)hour*30+maffhr; //calculating the angle made by hour hand with 12\\n    double miangle=(double)minutes*30/5; //calculating the angle made by minutes hand with 12\\n    double ang=fabs(hrangle-miangle); //calculating the angle difference between the hour and minutes hand\\n    return fmin(ang,360-ang); //returns the minimum angle as been told in the description\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2769436,
                "title": "c-one-liner-formula-based",
                "content": "Formula for angle between Minute and Hour hand of a clock = 11/2 * minutes - 30 * hour\\n```\\nclass Solution\\n{\\n    public:\\n        double angleClock(int hour, int minutes){\\n            return min(abs((11 / 2.0) *minutes - 30 *hour), 360 - abs((11 / 2.0) *minutes - 30 *hour));\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        double angleClock(int hour, int minutes){\\n            return min(abs((11 / 2.0) *minutes - 30 *hour), 360 - abs((11 / 2.0) *minutes - 30 *hour));\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666246,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double hourDegree = (hour*30) + (minutes*0.5);\\n        double minuteDegree = (minutes*6);\\n        double angleBetween = Math.abs(hourDegree - minuteDegree);\\n        return Math.min(angleBetween, 360-angleBetween);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double hourDegree = (hour*30) + (minutes*0.5);\\n        double minuteDegree = (minutes*6);\\n        double angleBetween = Math.abs(hourDegree - minuteDegree);\\n        return Math.min(angleBetween, 360-angleBetween);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2632938,
                "title": "c-100-faster-than-all-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double minDegree=6*minutes;\\n        if(hour==12)\\n            hour=0;\\n        double hourDegree=double(hour+minutes/60.0)*30;\\n        double angle1=abs(minDegree-hourDegree);\\n        double angle2=360-angle1;\\n        return min(angle1,angle2);\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double minDegree=6*minutes;\\n        if(hour==12)\\n            hour=0;\\n        double hourDegree=double(hour+minutes/60.0)*30;\\n        double angle1=abs(minDegree-hourDegree);\\n        double angle2=360-angle1;\\n        return min(angle1,angle2);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2593806,
                "title": "c-simple-100-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double t=30*hour;\\n        double t1=5.5*minutes;\\n        double ans=t-t1;\\n        if(ans<0) ans*=-1;\\n        if(ans>180) ans=360-ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double t=30*hour;\\n        double t1=5.5*minutes;\\n        double ans=t-t1;\\n        if(ans<0) ans*=-1;\\n        if(ans>180) ans=360-ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548929,
                "title": "1344-angle-between-hands-of-a-clock-in-java-time-o-1-space-o-1",
                "content": "class Solution {\\n  public double angleClock(int hour, int minutes) {\\n    final double hourHand = (hour % 12 + minutes / 60.0) * 30;\\n    final double minuteHand = minutes * 6;\\n    final double diff = Math.abs(hourHand - minuteHand);\\n    return Math.min(diff, 360 - diff);\\n  }\\n}\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n  public double angleClock(int hour, int minutes) {\\n    final double hourHand = (hour % 12 + minutes / 60.0) * 30;\\n    final double minuteHand = minutes * 6;\\n    final double diff = Math.abs(hourHand - minuteHand);\\n    return Math.min(diff, 360 - diff);\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2546912,
                "title": "java-100-fastest-method-with-simple-math",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double anglePerHour = 30;\\n        double anglePerMin = 6;\\n        \\n        double diffHour = Math.abs(minutes / 5.0 - hour) * anglePerHour;\\n        double diffMin = (minutes / 60.0) * 5 * anglePerMin;\\n        \\n        double cwdiff = 0;\\n        //if minute hand is before hour hand;\\n        if(minutes / 5 - hour < 0){\\n            cwdiff = diffHour + diffMin;\\n        }\\n        \\n        //if minute hand is after hour hand;\\n        else{\\n            cwdiff = Math.abs(diffHour - diffMin);\\n        }\\n        \\n        double ccwdiff = 360 - cwdiff;\\n        return Math.min(cwdiff, ccwdiff);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double anglePerHour = 30;\\n        double anglePerMin = 6;\\n        \\n        double diffHour = Math.abs(minutes / 5.0 - hour) * anglePerHour;\\n        double diffMin = (minutes / 60.0) * 5 * anglePerMin;\\n        \\n        double cwdiff = 0;\\n        //if minute hand is before hour hand;\\n        if(minutes / 5 - hour < 0){\\n            cwdiff = diffHour + diffMin;\\n        }\\n        \\n        //if minute hand is after hour hand;\\n        else{\\n            cwdiff = Math.abs(diffHour - diffMin);\\n        }\\n        \\n        double ccwdiff = 360 - cwdiff;\\n        return Math.min(cwdiff, ccwdiff);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387730,
                "title": "c-solution-math",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double ans = abs((30 * hour) - (5.5 * minutes));\\n        return min(ans, 360-ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double ans = abs((30 * hour) - (5.5 * minutes));\\n        return min(ans, 360-ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2383792,
                "title": "beginner-friendly-explanation-and-solution-java-0-ms",
                "content": "# Approach\\nImagine the clock as a circle, and then think through this:\\n- one complete rotation around the circle is 360 degrees\\n- the clock (circle) is divided into 12 labels (hours from 1 through 12)\\n- what is the angle between two consecutive labels? 360 / 12 = 30\\n- - another way to think this is the opposite way: if 30 is added 12 times it makes 360!\\n\\nMoving forward\\n- observe that when needle shows 5 minutes, it is physically at label 1. For 15 minutes it is at label 3, for 45 at label 9.\\n- - the above fact can be represented as `min / 5 = label`\\n\\nWhy the above stuff?\\nImage it\\'s 12:30 on the clock, so hour label is obviously 12. What about the minute label? 30 / 5 = 6. So, 12 to 6. What\\'s the difference: 12 - 6 = 6. In other words, the clock shows two needles which have covered 6 consecutive labels from hour label to minute label. What is the angle between these labels: 6 * 30 = 180. **(Not exactly, as explained below - but undertanding like this will make it easier to get to the tricky part)**\\n\\n# **Tricky part**\\nOur assumptions in the above walkthrough have kept the hour needle constant. That is, we assume that the hour needle **does not** move from its position and just jumps to next label when an hour passes. \\uD83D\\uDE27 This is not the case:\\n- observe that as the minute needle moves through, the hour needle slowly moves too.\\n- as 60 minutes pass, the hour needle slowly progresses to the next hour\\n\\nIf you observe the images in the problem description tab, there are 3 images of clocks. Take, for example, the clock with 12:30. Observe that the hour needle is not exactly at 12. Its **halfway** through 12 and 1.\\n- when the minutes needle is at 30, hour needle moves *halfway or 50% or 0.5* to the next hour\\n- when the minutes needle is at 15, hour neendle moves to 25% or 0.25 to the next hour\\n\\nThis can be represented mathematically as `minutes / 60`\\n>30 / 60 = 0.50\\\\\\n>45 / 60 = 0.75\\n>60 / 60 = 1.00\\n>15 / 60 = 0.25\\n>23 / 60 = 0.38\\n\\nSo, we have to keep in mind this displacement of hour needle as well and add it to the original hour needle position.\\n\\n## Another tricky bit\\n*(This one kept me scratching my head for 20 minutes - It shouldnt have but still...)*\\n\\nNote that two needles in a clock can be at 180 degrees at max, not beyond that. So, if the calculated angle becomes greater than 180, just subtract it from 360.\\n\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n\\n        double minToHLabel = minutes / 5.0;\\n  \\n        double disp = (double) 1/60 * minutes;\\n        \\n        double diff = (hour + disp) - minToHLabel;\\n        \\n\\t\\t// absolute difference (Math.abs can be used aswell) \\n        if (diff < 0){\\n            diff = diff * - 1;\\n        }\\n        \\n\\t\\t// if the calculated angle is greater than 180, return after subtracting from 360\\n        if (diff * 30 > 180){\\n            return 360 - diff * 30;\\n        }\\n        else {\\n            return diff * 30;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n\\n        double minToHLabel = minutes / 5.0;\\n  \\n        double disp = (double) 1/60 * minutes;\\n        \\n        double diff = (hour + disp) - minToHLabel;\\n        \\n\\t\\t// absolute difference (Math.abs can be used aswell) \\n        if (diff < 0){\\n            diff = diff * - 1;\\n        }\\n        \\n\\t\\t// if the calculated angle is greater than 180, return after subtracting from 360\\n        if (diff * 30 > 180){\\n            return 360 - diff * 30;\\n        }\\n        else {\\n            return diff * 30;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368840,
                "title": "c-o-1-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hr=30*hour+(0.5*minutes);\\n        hr=hr>=360?hr-360:hr;\\n        double m=6*minutes;\\n        if(m>hr)\\n        return m-hr<hr+(360-m)?m-hr:hr+(360-m);\\n        return hr-m<(360-hr)+m?hr-m:(360-hr)+m;\\n    }\\n};\\n```\\nAs we know \\n**One hour** = 30 degress + 0.5 * Minutes.\\n**One Minute** = 6 degress.\\nNow we apply simple mathematic formula to yield the result.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hr=30*hour+(0.5*minutes);\\n        hr=hr>=360?hr-360:hr;\\n        double m=6*minutes;\\n        if(m>hr)\\n        return m-hr<hr+(360-m)?m-hr:hr+(360-m);\\n        return hr-m<(360-hr)+m?hr-m:(360-hr)+m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306119,
                "title": "on-line-or-two-lines-python",
                "content": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        x = abs(minutes * 6 -(hour * 30 + minutes/2))\\n        return min(360-x , x)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        x = abs(minutes * 6 -(hour * 30 + minutes/2))\\n        return min(360-x , x)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2258116,
                "title": "3-o-1-time-o-1-space-illustrated-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/97c6441b-71ae-4045-b52c-69c5f97894c3_1657362262.4013243.png)\\n\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \"\"\" O(1)TS \"\"\"\\n        h = 360 / 12 * (hour + minutes / 60)\\n        m = 360 / 60 * minutes\\n        return min(a := abs(h - m), 360 - a)\\n\\t\\t\\n\\t\\t\\n![image](https://assets.leetcode.com/users/images/ab16870a-4834-444f-936c-5c071d410f3c_1657362277.5164502.png)\\n\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \"\"\" O(1)TS \"\"\"\\n        return min(a := abs(30 * hour - 5.5 * minutes), 360 - a)",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/97c6441b-71ae-4045-b52c-69c5f97894c3_1657362262.4013243.png)\\n\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \"\"\" O(1)TS \"\"\"\\n        h = 360 / 12 * (hour + minutes / 60)\\n        m = 360 / 60 * minutes\\n        return min(a := abs(h - m), 360 - a)\\n\\t\\t\\n\\t\\t\\n![image](https://assets.leetcode.com/users/images/ab16870a-4834-444f-936c-5c071d410f3c_1657362277.5164502.png)\\n\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \"\"\" O(1)TS \"\"\"\\n        return min(a := abs(30 * hour - 5.5 * minutes), 360 - a)",
                "codeTag": "Python3"
            },
            {
                "id": 2191114,
                "title": "simple-math-solution-easy-explanation",
                "content": "* First we have to calculate perMinute and perHour angles.\\n**perMinute angle = 360 (total angle) / 60 (minutes) \\nSimilarly perHour angle= 360 /12 (hours)**\\n* if(hour ==12 ) convert it to 0, So angle fits in 360 degrees  to avoid unneccesary calculations.\\n\\n* Now as the minute hand moves hour hand angle also changes. To find out that angle :\\nwe can see that between any two hours  30 degree angle exists.\\n**So perMinute Movement of hour hand between two hours = 30( angle between two hours)/60(total minutes).**\\n**So totalHourAngle= perHourAngle( 30 ) * hours + 0.5 * minutes.\\nMinuteHandAngle = perMinuteAngle( 6 )  * minutes.**\\n \\n*  **then angle1=abs(hourAngle - minuteAngle);**\\n       **angle2 =360 - angle1**\\n \\n*  **RequiredAns = min(angle1,angle2)**.\\n\\n* Please note that all angle are calculated with respect to 12:00.\\n\\n\\tPlease upvote if found Helpful!!\\n\\n```\\nclass Solution{\\npublic:\\n   double angleClock(int hour, int minutes){\\n      int perMinute = 6;  \\n      int perHour = 30;   \\n      if (hour == 12)\\n         hour = 0;\\n      double minuteAngle = 6 * minutes;\\n      double hourAngle = 30 * hour + minutes * 0.5;\\n      double angle1 = abs(hourAngle - minuteAngle);\\n      double angle2 = abs(360 - angle1);\\n      return min(angle1, angle2);\\n   }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n   double angleClock(int hour, int minutes){\\n      int perMinute = 6;  \\n      int perHour = 30;   \\n      if (hour == 12)\\n         hour = 0;\\n      double minuteAngle = 6 * minutes;\\n      double hourAngle = 30 * hour + minutes * 0.5;\\n      double angle1 = abs(hourAngle - minuteAngle);\\n      double angle2 = abs(360 - angle1);\\n      return min(angle1, angle2);\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163214,
                "title": "angle-between-hands-of-a-clock-python-solution",
                "content": "def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        \"\"\"\\n        As hour clock move by (360/12) is per hour + ((360/12)/60) per minutes\\n        \"\"\"\\n        hours_degree = (360/12)*hour+(360/720)*minutes\\n        minute_degree = (360/60)*minutes\\n        res =  abs(hours_degree-minute_degree)\\n        if res > 180:\\n            return 360-res\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        \"\"\"\\n        As hour clock move by (360/12) is per hour + ((360/12)/60) per minutes\\n        \"\"\"\\n        hours_degree = (360/12)*hour+(360/720)*minutes\\n        minute_degree = (360/60)*minutes\\n        res =  abs(hours_degree-minute_degree)\\n        if res > 180:\\n            return 360-res\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2102837,
                "title": "python-naive-approach-explained-with-comments",
                "content": "**Code**\\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        # Normalizing minute position in range (1-12)\\n        min_clock = minutes/5\\n\\n        # If time is 12.00 returning 0\\n        if minutes == 0 and hour*30 == 360:\\n            return 0\\n        \\n        # If minutes is 0 then multiply hour by 30 degree as each hour consists of 30 degree\\n        elif minutes == 0:\\n            only_hour = hour*30\\n            \\n            # Check whether it is shorter in opposite direction\\n            if only_hour > 180:\\n                return 360-(only_hour)\\n            return only_hour\\n        \\n        else:\\n            # Finding the degree between minute hand and closest hour of the hour hand\\n            time = abs(hour-min_clock)*30\\n            \\n            # Finding the difference that needs to added/subtracted\\n            diff = 30/(60/minutes)\\n            \\n            # Subtracting when minute hand is at greater value that hour hand\\n            if min_clock > hour:\\n                fin_time = time-diff\\n                \\n            # Adding when minute hand is at lesser value that hour hand\\n            else:\\n                fin_time = time+diff\\n            \\n            # Check the shorter direction\\n            if fin_time > 180:\\n                diff = fin_time-180\\n                return abs(180-diff)\\n            else:\\n                return abs(fin_time)\\n            \\n```\\n\\n\\n**Space & Time Analysis**\\n![image](https://assets.leetcode.com/users/images/3c439212-1a7d-45ff-a31d-630b871e2e81_1654181622.2073946.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        # Normalizing minute position in range (1-12)\\n        min_clock = minutes/5\\n\\n        # If time is 12.00 returning 0\\n        if minutes == 0 and hour*30 == 360:\\n            return 0\\n        \\n        # If minutes is 0 then multiply hour by 30 degree as each hour consists of 30 degree\\n        elif minutes == 0:\\n            only_hour = hour*30\\n            \\n            # Check whether it is shorter in opposite direction\\n            if only_hour > 180:\\n                return 360-(only_hour)\\n            return only_hour\\n        \\n        else:\\n            # Finding the degree between minute hand and closest hour of the hour hand\\n            time = abs(hour-min_clock)*30\\n            \\n            # Finding the difference that needs to added/subtracted\\n            diff = 30/(60/minutes)\\n            \\n            # Subtracting when minute hand is at greater value that hour hand\\n            if min_clock > hour:\\n                fin_time = time-diff\\n                \\n            # Adding when minute hand is at lesser value that hour hand\\n            else:\\n                fin_time = time+diff\\n            \\n            # Check the shorter direction\\n            if fin_time > 180:\\n                diff = fin_time-180\\n                return abs(180-diff)\\n            else:\\n                return abs(fin_time)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061780,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n        // Few helpful notes for problem solving\\n        // Considering the clock as a total of 360 degree space\\n        // we have 12 hours, each hour moves 360/12 = 30 degrees\\n        // we have 60 mins, each minute moves 360/60 = 6 degrees\\n        // 60 minutes of time moves hour needle by 30 degrees; 1 minute will move hours extra by 30/60 mins\\n        \\n        double oneHourDegrees = 30;\\n        double oneMinDegrees = 6;\\n\\n        double minuteAngle = minutes * oneMinDegrees;\\n        \\n        double hourAngle = (hour % 12) * oneHourDegrees;\\n        double hourAngleExtraMovement = minutes * (oneHourDegrees / 60);\\n        \\n        \\n        double diff = Math.abs((hourAngle + hourAngleExtraMovement) - minuteAngle);\\n        return Math.min(diff, 360-diff);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n        // Few helpful notes for problem solving\\n        // Considering the clock as a total of 360 degree space\\n        // we have 12 hours, each hour moves 360/12 = 30 degrees\\n        // we have 60 mins, each minute moves 360/60 = 6 degrees\\n        // 60 minutes of time moves hour needle by 30 degrees; 1 minute will move hours extra by 30/60 mins\\n        \\n        double oneHourDegrees = 30;\\n        double oneMinDegrees = 6;\\n\\n        double minuteAngle = minutes * oneMinDegrees;\\n        \\n        double hourAngle = (hour % 12) * oneHourDegrees;\\n        double hourAngleExtraMovement = minutes * (oneHourDegrees / 60);\\n        \\n        \\n        double diff = Math.abs((hourAngle + hourAngleExtraMovement) - minuteAngle);\\n        return Math.min(diff, 360-diff);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023508,
                "title": "beats-100-percent-cpp-solution-very-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double a1_h =hour*30 +minutes/2.0 ;\\n          double a1_m =minutes*6 ;\\n     \\n        double ang1 =abs(a1_h-a1_m);\\n        double ang2 =360 -ang1;\\n        return min(ang1,ang2);\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double a1_h =hour*30 +minutes/2.0 ;\\n          double a1_m =minutes*6 ;\\n     \\n        double ang1 =abs(a1_h-a1_m);\\n        double ang2 =360 -ang1;\\n        return min(ang1,ang2);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1925864,
                "title": "c-100-fatsest-easy",
                "content": "class Solution {\\npublic:\\n    double angleClock(int hr, int m) {\\n        \\n        double Am=(double)m*6;\\n        double th;\\n        if(hr!=12){\\n        th=hr + (double)m/60;\\n        }\\n        else\\n        th=(double)m/60;\\n        \\n        double Ah=(double)th*30;\\n        \\n        \\n        if((th<=6 && m<=30) || (th>=6 && m>=30))\\n        return abs(Ah-Am);\\n        else \\n        {\\n            return min(abs(Ah-Am),(360-abs(Ah-Am)));\\n        }\\n    }\\n};\\n\\nI hope you liked it...",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    double angleClock(int hr, int m) {\\n        \\n        double Am=(double)m*6;\\n        double th;\\n        if(hr!=12){\\n        th=hr + (double)m/60;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1885653,
                "title": "pure-maths-simple-one-line-soln-beats-100",
                "content": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n  return min (abs(-(30*hour)+(5.5*minutes)),360.0-abs((-30*hour)+(5.5*minutes)));\\n      }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n  return min (abs(-(30*hour)+(5.5*minutes)),360.0-abs((-30*hour)+(5.5*minutes)));\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1883807,
                "title": "javascript-1344-angle-between-hands-of-a-clock",
                "content": "---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar angleClock = function (hour, minutes) {\\n    const degh = hour + minutes / 60; // convert to hours\\n    const degm = minutes / 5; //         convert to hours\\n\\n    const angle = Math.abs(degm - degh) * 30; // 30 degrees per 1 hour\\n    return Math.min(angle, 360 - angle);\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/211173a3-6c7c-4be3-bb0d-b56a6298ab6c_1648257885.2183793.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar angleClock = function (hour, minutes) {\\n    const degh = hour + minutes / 60; // convert to hours\\n    const degm = minutes / 5; //         convert to hours\\n\\n    const angle = Math.abs(degm - degh) * 30; // 30 degrees per 1 hour\\n    return Math.min(angle, 360 - angle);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786555,
                "title": "easy-c-100-faster",
                "content": "```\\ndouble angleClock(int hour, int minutes)\\n{\\n    if (hour == 12)\\n        hour = 0;\\n\\n    double hour_d = minutes;\\n\\n    hour_d = (hour * 30) + (hour_d / 2);\\n    double min_d = minutes * 6;\\n\\n    cout << hour_d << \" \" << min_d << endl;\\n\\n    if (hour_d > min_d)\\n        return min(hour_d - min_d, 360.0 - hour_d + min_d);\\n\\n    else\\n        return min(min_d - hour_d, 360.0 - min_d + hour_d);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\ndouble angleClock(int hour, int minutes)\\n{\\n    if (hour == 12)\\n        hour = 0;\\n\\n    double hour_d = minutes;\\n\\n    hour_d = (hour * 30) + (hour_d / 2);\\n    double min_d = minutes * 6;\\n\\n    cout << hour_d << \" \" << min_d << endl;\\n\\n    if (hour_d > min_d)\\n        return min(hour_d - min_d, 360.0 - hour_d + min_d);\\n\\n    else\\n        return min(min_d - hour_d, 360.0 - min_d + hour_d);\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1724461,
                "title": "simple-one-line-java-solution-with-proper-explanation",
                "content": "```\\npublic double angleClock(int hour, int minutes) {\\n\\t\\t//Hour hand roatation per hour = 360/12 = 30\\n\\t\\t// Hour hand rotation per min = 30/60 = 0.5\\n\\t\\t// Min hand rotation per min = 360/60 = 6\\n        double diff = Math.abs((hour%12)*30 + minutes*0.5- minutes*6);\\n        return diff>180? (360-diff):diff;\\n}\\n```\\n\\t\\t",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic double angleClock(int hour, int minutes) {\\n\\t\\t//Hour hand roatation per hour = 360/12 = 30\\n\\t\\t// Hour hand rotation per min = 30/60 = 0.5\\n\\t\\t// Min hand rotation per min = 360/60 = 6\\n        double diff = Math.abs((hour%12)*30 + minutes*0.5- minutes*6);\\n        return diff>180? (360-diff):diff;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1722685,
                "title": "c-clock-math-explained",
                "content": "```\\n    /*\\n    Mathwise-        \\n        1 hour = 60 minutes = 360 degrees on a clock.\\n        every time minute hand travels 360 degrees, hour hand travels by 1 hour\\'s worth - 30 degrees (360/12)\\n        every time minute hand travels 6 degrees (1 minute), hour hand travels (30*6)/360: 0.5 degrees\\n        \\n        minute hand would be at the 6*minute angle\\n        hour hand would be at the 30*hour + 0.5*minute.\\n        \\n        compute the angle difference \\n        if angle is bigger than 180, return the 360 - angle result\\n        minute hand goes 6 degrees per minute\\n        \\n        angle will be minute angle - hour angle (abs);\\n    */\\nclass Solution {\\npublic:\\n\\n    double angleClock(int hour, int minutes) {\\n        double minuteAngle = 6 * minutes;\\n        double hourAngle = 30 * hour + 0.5 * minutes;\\n        \\n        double angle = abs(minuteAngle - hourAngle);\\n        return min(angle, 360-angle); //as thought earlier, we could use a conditional like if(angle > 180) {return 360-angle};\\n    }\\n    \\n    //TIME - O(1) //no matter what happens, we have a constant time\\n    //SPACE - O(1) //no matter what happens, we have a constant space\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    /*\\n    Mathwise-        \\n        1 hour = 60 minutes = 360 degrees on a clock.\\n        every time minute hand travels 360 degrees, hour hand travels by 1 hour\\'s worth - 30 degrees (360/12)\\n        every time minute hand travels 6 degrees (1 minute), hour hand travels (30*6)/360: 0.5 degrees\\n        \\n        minute hand would be at the 6*minute angle\\n        hour hand would be at the 30*hour + 0.5*minute.\\n        \\n        compute the angle difference \\n        if angle is bigger than 180, return the 360 - angle result\\n        minute hand goes 6 degrees per minute\\n        \\n        angle will be minute angle - hour angle (abs);\\n    */\\nclass Solution {\\npublic:\\n\\n    double angleClock(int hour, int minutes) {\\n        double minuteAngle = 6 * minutes;\\n        double hourAngle = 30 * hour + 0.5 * minutes;\\n        \\n        double angle = abs(minuteAngle - hourAngle);\\n        return min(angle, 360-angle); //as thought earlier, we could use a conditional like if(angle > 180) {return 360-angle};\\n    }\\n    \\n    //TIME - O(1) //no matter what happens, we have a constant time\\n    //SPACE - O(1) //no matter what happens, we have a constant space\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575773,
                "title": "java-math-on-clock-angles-faster-than-100",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {      \\n        \\n        int oneMinAngle = 6;\\n        int oneHourAngle = 30;\\n        \\n        //calculating the effect of minutes on the hour hand\\n        double minFrac = (double)minutes/60.0;\\n        double hHandMove = minFrac * oneHourAngle;\\n       \\n        //calculating the angles of hour hand the minute hand from 0degree\\n        double hAngle = (hour%12) * oneHourAngle + hHandMove;\\n        double minAngle = minutes * oneMinAngle;\\n        \\n        //calculating both the angles formed \\n        double firstDiff = Math.abs(hAngle - minAngle);\\n        double secondDiff = 360 - firstDiff;\\n        \\n        return Math.min(firstDiff, secondDiff);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {      \\n        \\n        int oneMinAngle = 6;\\n        int oneHourAngle = 30;\\n        \\n        //calculating the effect of minutes on the hour hand\\n        double minFrac = (double)minutes/60.0;\\n        double hHandMove = minFrac * oneHourAngle;\\n       \\n        //calculating the angles of hour hand the minute hand from 0degree\\n        double hAngle = (hour%12) * oneHourAngle + hHandMove;\\n        double minAngle = minutes * oneMinAngle;\\n        \\n        //calculating both the angles formed \\n        double firstDiff = Math.abs(hAngle - minAngle);\\n        double secondDiff = 360 - firstDiff;\\n        \\n        return Math.min(firstDiff, secondDiff);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538731,
                "title": "easy-to-understand-python-code",
                "content": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        # cloclwise\\n\\t\\t# 30 degrees is the angle of one hour\\n        hour_angle = hour * 30 + 30 * minutes / 60\\n        minute_angle = 360 * minutes / 60\\n        return min(360 - abs(minute_angle - hour_angle), abs(minute_angle - hour_angle))",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        # cloclwise\\n\\t\\t# 30 degrees is the angle of one hour\\n        hour_angle = hour * 30 + 30 * minutes / 60\\n        minute_angle = 360 * minutes / 60\\n        return min(360 - abs(minute_angle - hour_angle), abs(minute_angle - hour_angle))",
                "codeTag": "Java"
            },
            {
                "id": 1464436,
                "title": "java-math-with-explanation",
                "content": "1. For every 1 hour (60 minutes) that is completed on a clock, the minutes pointer rotates 360 degrees. This means that for every 1 minute, the minutes pointer moved 6 degrees.\\n2. For every 12 hours, the hours pointer completes 360 degrees, which means that the hour pointer moves 30 degrees every hour.\\n3. The main point to remember here is that the hour pointer doesn\\'t remain at a static position between every hour that passes, but it covers a certain degree as the minutes keep passing by. It is important to calculate the degree of movement and add it to the total degree that the hours pointer moves.\\n\\nAs an example, let us consider when the time is 12:30. While the minutes pointer moves by 180 degrees at this time (30 * 6), the hour pointer moves by 0.5 degrees every 1 minute,as calculated below:\\n\\n360 degrees = 12 hours\\n30 degrees = 1 hour\\n30 degrees = 60 minutes => 0.5 degrees every minute. In this example, where the minutes is at 30, we can thus infer that the hours pointer has moved 15 degrees. We thus calculate the hoursAngle and minutesAngle.\\n\\n```\\n public double angleClock(int hour, int minutes) {\\n        double hourAngle = 30*(hour%12) + 0.5*(minutes);\\n        double minuteAngle = 6*(minutes);\\n        \\n        double result = Math.abs(hourAngle-minuteAngle);\\n        //min angle to be returned.\\n        return Math.min(result, 360-result);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n public double angleClock(int hour, int minutes) {\\n        double hourAngle = 30*(hour%12) + 0.5*(minutes);\\n        double minuteAngle = 6*(minutes);\\n        \\n        double result = Math.abs(hourAngle-minuteAngle);\\n        //min angle to be returned.\\n        return Math.min(result, 360-result);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1432604,
                "title": "3-line-100-c-code",
                "content": "```\\n//please upvote  if you like the solution \\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hA = 30*hour + (double)minutes/2;\\n        double mA = 6*minutes;\\n        return min(360 - abs(hA - mA), abs(hA - mA));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//please upvote  if you like the solution \\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hA = 30*hour + (double)minutes/2;\\n        double mA = 6*minutes;\\n        return min(360 - abs(hA - mA), abs(hA - mA));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314494,
                "title": "c-easy-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tdouble angleClock(int hour, int minutes) {\\n\\n\\t\\t\\tdouble n=static_cast<double>(minutes)/60;        \\n\\t\\t\\tdouble min=n*360;        \\n\\t\\t\\tdouble hou=(n+hour)*30;\\n\\n\\t\\t\\treturn abs(hou-min)>360-abs(hou-min)?360-abs(hou-min):abs(hou-min);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tdouble angleClock(int hour, int minutes) {\\n\\n\\t\\t\\tdouble n=static_cast<double>(minutes)/60;        \\n\\t\\t\\tdouble min=n*360;        \\n\\t\\t\\tdouble hou=(n+hour)*30;\\n\\n\\t\\t\\treturn abs(hou-min)>360-abs(hou-min)?360-abs(hou-min):abs(hou-min);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1298871,
                "title": "detailed-solution-with-full-explanation",
                "content": "class Solution {\\n    \\n    public double angleClock(int hour, int minutes) {\\n        /*\\n            This method calculates the angles difference \\n            between HOUR HAND and MINUTE HAND\\n        */\\n\\n        /*\\n        ALGORITHM:\\n            #   Calculate the angles for each hands from \\n                the origin(i.e. 12 o\\'clock)\\n            #   1 hour makes 30 degrees\\n            #   1 minute makes 6 degrees\\n        */\\n\\n        double angleHourHand = (hour * 30) % 360 + minutes * 0.5;\\n        // one hour makes 30 degrees\\n        // 12 o\\'clock is 0 degrees, that is why modulues applied\\n        // 60 minutes is 1 hour and that is 30 degrees\\n        // so 1 minute is 0.5 degree\\n\\n        double angleMinuteHand = minutes * 6; \\n        // 60 minutes is 360 degrees\\n        // 1 minute is 6 degrees\\n\\n        double difference = angleHourHand - angleMinuteHand;\\n\\n        // IF NEGATIVE, MAKE POSITIVE\\n        if (difference < 0){\\n            difference *= -1;\\n        }\\n\\n        // There are two angles \\n        // One is definitely smaller than 180, find it \\n        if(difference > 180){\\n            difference = 360 - difference; // the other angles that completes to 360\\n        }\\n        \\n        \\n        return difference;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public double angleClock(int hour, int minutes) {\\n        /*\\n            This method calculates the angles difference \\n            between HOUR HAND and MINUTE HAND\\n        */\\n\\n        /*\\n        ALGORITHM:\\n            #   Calculate the angles for each hands from \\n                the origin(i.e. 12 o\\'clock)\\n            #   1 hour makes 30 degrees\\n            #   1 minute makes 6 degrees\\n        */\\n\\n        double angleHourHand = (hour * 30) % 360 + minutes * 0.5;\\n        // one hour makes 30 degrees\\n        // 12 o\\'clock is 0 degrees, that is why modulues applied\\n        // 60 minutes is 1 hour and that is 30 degrees\\n        // so 1 minute is 0.5 degree\\n\\n        double angleMinuteHand = minutes * 6; \\n        // 60 minutes is 360 degrees\\n        // 1 minute is 6 degrees\\n\\n        double difference = angleHourHand - angleMinuteHand;\\n\\n        // IF NEGATIVE, MAKE POSITIVE\\n        if (difference < 0){\\n            difference *= -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1260232,
                "title": "php-solution-100-faster-2-lines-of-code",
                "content": "```\\n\\tfunction angleClock($hour, $minutes) {\\n        $delta = abs($hour * 30 - $minutes / 2 * 11);\\n        return $delta <= 180 ? $delta : 360 - $delta;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tfunction angleClock($hour, $minutes) {\\n        $delta = abs($hour * 30 - $minutes / 2 * 11);\\n        return $delta <= 180 ? $delta : 360 - $delta;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1260171,
                "title": "php-solution-100-faster",
                "content": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $hour\\n     * @param Integer $minutes\\n     * @return Float\\n     */\\n    function angleClock($hour, $minutes) {\\n        if($hour > 12) $hour -= 12; \\n        $delta = abs(($minutes * 6) - (0.5 * ($hour * 60 + $minutes)));\\n        if($delta < 180) \\n            return $delta;\\n        return 360-$delta;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $hour\\n     * @param Integer $minutes\\n     * @return Float\\n     */\\n    function angleClock($hour, $minutes) {\\n        if($hour > 12) $hour -= 12; \\n        $delta = abs(($minutes * 6) - (0.5 * ($hour * 60 + $minutes)));\\n        if($delta < 180) \\n            return $delta;\\n        return 360-$delta;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192482,
                "title": "two-liner-c-solution-100-faster",
                "content": "Formula for finding angle between hour hand and minute hand:\\nAngle= (30 * Hour - (11/2) * Minutes))\\nIf the Angle is greater than 180 degree ( reflex angle ) then subtract it from 360 degree to get the correct angle.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double x= abs(30*hour - 11/(double)2*minutes);\\n        return min(x,360.00000-x);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double x= abs(30*hour - 11/(double)2*minutes);\\n        return min(x,360.00000-x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182338,
                "title": "100-faster-solution",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n    double  hour_hand_angle = hour*30 + minutes*0.5;\\n    double minute_hand_angle = minutes*6;\\n    double angle = abs(hour_hand_angle - minute_hand_angle);\\n        if(angle<=180)\\n            return angle;\\n        else \\n            return 360 - angle;\\n    }\\n};\\n```\\n```\\n# Quick Explanation\\n1. Hour hand makes angle of 360\\xB0 in 12 hours , so in 1 hour it will make 360/12 = 30\\xB0. In 1 hour(60 minutes) it is making 30\\xB0 so in 1 minute it will make 30/60 = 0.5\\xB0.\\n2. Minute hand makes angle of 360\\xB0 in 1 hour(60 minutes) , so in 1 minute it will make 360/60 = 6\\xB0.\\n3. Subtract both angles to give absolute value.\\n4. We have to return smallest angle ,so check if its greater than 180\\xB0 then subract it from 360\\xB0.\\nUpvote if it helped!\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n    double  hour_hand_angle = hour*30 + minutes*0.5;\\n    double minute_hand_angle = minutes*6;\\n    double angle = abs(hour_hand_angle - minute_hand_angle);\\n        if(angle<=180)\\n            return angle;\\n        else \\n            return 360 - angle;\\n    }\\n};\\n```\n```\\n# Quick Explanation\\n1. Hour hand makes angle of 360\\xB0 in 12 hours , so in 1 hour it will make 360/12 = 30\\xB0. In 1 hour(60 minutes) it is making 30\\xB0 so in 1 minute it will make 30/60 = 0.5\\xB0.\\n2. Minute hand makes angle of 360\\xB0 in 1 hour(60 minutes) , so in 1 minute it will make 360/60 = 6\\xB0.\\n3. Subtract both angles to give absolute value.\\n4. We have to return smallest angle ,so check if its greater than 180\\xB0 then subract it from 360\\xB0.\\nUpvote if it helped!\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144549,
                "title": "c-with-explanation",
                "content": "```\\n    /*\\n     * Solution is to find the angle between hours hand and\\n     * minutes hand, need to see how much hours hand will\\n     * deviate with respect to minute hand.\\n     *\\n     * The hours hand will complete angle of 360 only when it\\n     * completes 12 hours i.e..,\\n     *       360degrees -> 12 hours\\n     *        30degrees -> 1 hour\\n     *\\n     * As we can see tha there is a 30degree deviation in the\\n     * hour hand which corresponds to 0.5degree in 1 minute\\n     *        30degrees -> 1 hour\\n     *        30degress -> 60 minutes\\n     *        0.5degree -> 1 minute\\n     *\\n     * Now lets check the minutes hand, the minutes hand will\\n     * complete 360degree in 60 minutes\\n     *        360degree -> 60 minutes\\n     *         60degree -> 1 minute\\n     *\\n     * Absolute difference of both hours angle and minutes angle\\n     * will give the result.\\n     *\\n     * Base Case:\\n     * If the hour is 12, then hour hand is at 0\\n     * If the hour, minutes < 0 or hour > 12 or min > 60, invalid\\n    */\\n    double angleClock(int hour, int minutes) {\\n        if (hour < 0 || minutes < 0 || hour > 12 || minutes > 60) {\\n            // Invalid input\\n            return 0.0;\\n        }\\n        \\n        // Check if the hour is 12, then hour hand is at 0\\n        if (hour == 12) {\\n            // Replace with zero\\n            hour = 0;\\n        }\\n        \\n        // As minutes hand effects the hours hand, calculate the hour\\n        // angle by including the minutes hand. As angle between the\\n        // hours hand for a minute is known(0.5), hours hand needs\\n        // to be converted to minutes and multiply with 0.5 so that we\\n        // get the total angle\\n        //       (h*60 + m) >> 1\\n        double hoursAngle = (hour * 60 + minutes) * 0.5;\\n        \\n        // Calculate the minutes angle, as we know the angle at each\\n        // minute directly multiple with 6\\n        double minutesAngle = minutes * 6;\\n        \\n        // Get the absolute difference and return\\n        double angle = abs(hoursAngle - minutesAngle);\\n        \\n        // Return the smaller angle of two possible angles\\n        angle = min(360 - angle, angle);\\n        \\n        return angle;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * Solution is to find the angle between hours hand and\\n     * minutes hand, need to see how much hours hand will\\n     * deviate with respect to minute hand.\\n     *\\n     * The hours hand will complete angle of 360 only when it\\n     * completes 12 hours i.e..,\\n     *       360degrees -> 12 hours\\n     *        30degrees -> 1 hour\\n     *\\n     * As we can see tha there is a 30degree deviation in the\\n     * hour hand which corresponds to 0.5degree in 1 minute\\n     *        30degrees -> 1 hour\\n     *        30degress -> 60 minutes\\n     *        0.5degree -> 1 minute\\n     *\\n     * Now lets check the minutes hand, the minutes hand will\\n     * complete 360degree in 60 minutes\\n     *        360degree -> 60 minutes\\n     *         60degree -> 1 minute\\n     *\\n     * Absolute difference of both hours angle and minutes angle\\n     * will give the result.\\n     *\\n     * Base Case:\\n     * If the hour is 12, then hour hand is at 0\\n     * If the hour, minutes < 0 or hour > 12 or min > 60, invalid\\n    */\\n    double angleClock(int hour, int minutes) {\\n        if (hour < 0 || minutes < 0 || hour > 12 || minutes > 60) {\\n            // Invalid input\\n            return 0.0;\\n        }\\n        \\n        // Check if the hour is 12, then hour hand is at 0\\n        if (hour == 12) {\\n            // Replace with zero\\n            hour = 0;\\n        }\\n        \\n        // As minutes hand effects the hours hand, calculate the hour\\n        // angle by including the minutes hand. As angle between the\\n        // hours hand for a minute is known(0.5), hours hand needs\\n        // to be converted to minutes and multiply with 0.5 so that we\\n        // get the total angle\\n        //       (h*60 + m) >> 1\\n        double hoursAngle = (hour * 60 + minutes) * 0.5;\\n        \\n        // Calculate the minutes angle, as we know the angle at each\\n        // minute directly multiple with 6\\n        double minutesAngle = minutes * 6;\\n        \\n        // Get the absolute difference and return\\n        double angle = abs(hoursAngle - minutesAngle);\\n        \\n        // Return the smaller angle of two possible angles\\n        angle = min(360 - angle, angle);\\n        \\n        return angle;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1098587,
                "title": "java-easy-solution-runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "```\\n\\npublic double angleClock(int hour, int minutes) \\n    {\\n        double m=0;\\n        m=minutes*6;\\n        double h=hour%12;;\\n        h=(h*30)+(minutes*0.5);\\n        double angle = Math.abs(m - h);\\n        \\n        if((angle)>180)\\n          return (360-angle);\\n        else\\n             return (angle);\\n\\t\\t\\t }\\n",
                "solutionTags": [],
                "code": "```\\n\\npublic double angleClock(int hour, int minutes) \\n    {\\n        double m=0;\\n        m=minutes*6;\\n        double h=hour%12;;\\n        h=(h*30)+(minutes*0.5);\\n        double angle = Math.abs(m - h);\\n        \\n        if((angle)>180)\\n          return (360-angle);\\n        else\\n             return (angle);\\n\\t\\t\\t }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1013332,
                "title": "python-simulation-math",
                "content": "```py\\n\\'\\'\\'\\nsimulation + math\\nh: 1 hour: hour hand: 360/12 + 30/60*minutes\\n           minute hand 360/60\\n\\'\\'\\'\\n\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        mDegree = 360/60 * minutes\\n        hDegree = 360/12 * hour + 360/(60*12)*minutes\\n\\n        return min(abs(mDegree-hDegree), 360-abs(mDegree-hDegree))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n\\'\\'\\'\\nsimulation + math\\nh: 1 hour: hour hand: 360/12 + 30/60*minutes\\n           minute hand 360/60\\n\\'\\'\\'\\n\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        mDegree = 360/60 * minutes\\n        hDegree = 360/12 * hour + 360/(60*12)*minutes\\n\\n        return min(abs(mDegree-hDegree), 360-abs(mDegree-hDegree))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000569,
                "title": "c-0ms-math-two-solution-with-comments",
                "content": "if this isnt simply, we can separate ... and have second solution \\n\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n      double ang = abs((h%12)*30 - m*5.5);\\n      return min (ang , 360 - ang); \\n    }\\n};\\n```\\n_____________\\n\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n      double ah = (h%12)*30 + m*0.5;             //calculate angle of hours hand\\n      double am = m*6.0;                         //calculate angle of minutes hand\\n      double ang;\\n      if(ah > am) ang = ah - am;                 //calculate angle beetween minutes hand and hours hand\\n      else ang = am - ah;\\n      \\n      if(ang>180) ang = 360 - ang;               //if our angle isnt sharp\\n      return ang;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n      double ang = abs((h%12)*30 - m*5.5);\\n      return min (ang , 360 - ang); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n      double ah = (h%12)*30 + m*0.5;             //calculate angle of hours hand\\n      double am = m*6.0;                         //calculate angle of minutes hand\\n      double ang;\\n      if(ah > am) ang = ah - am;                 //calculate angle beetween minutes hand and hours hand\\n      else ang = am - ah;\\n      \\n      if(ang>180) ang = 360 - ang;               //if our angle isnt sharp\\n      return ang;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922724,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n        \\n        if(hour==12)\\n            hour=0;\\n        double min=minutes*6.0;\\n        double hrs=hour*30.0+minutes*0.5;\\n        double diff=Math.abs(min-hrs);\\n        if(diff>180)\\n        {\\n            return 360-diff;\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n        \\n        if(hour==12)\\n            hour=0;\\n        double min=minutes*6.0;\\n        double hrs=hour*30.0+minutes*0.5;\\n        double diff=Math.abs(min-hrs);\\n        if(diff>180)\\n        {\\n            return 360-diff;\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803854,
                "title": "python-3-explanation",
                "content": "* We can break this question down into two separate functions:\\n1. `getMinuteAngle`: For a given `minutes` value, what is the angle from the 0 position to where the minute hand is.\\n2. `getHourAngle`: For a given `minutes` **and** `hours` value, what is the angle from the 0 position to where the hour hand is.\\n\\t * We need to factor in both the `minutes` and `hours` values for the hours hand since it moves a little bit for each minute that goes by.\\n* For `getMinuteAngle`, we calculate the angle between the 0 position and one minute \\'notch\\' on the clock as `360 / 60 == 6`.\\n\\t* We then multiply this by however many `minutes` we have.\\n* For `getHourAngle`, we calculate the angle between the 0 position and one hour \\'noth\\' on the clock as `360 / 12 == 30`.\\n\\t* We also need to calculate the `minuteOffsetAngle`, which is the fractional amount the hour hand moves for each passing minute.\\n\\t* This value is the proportion of `oneHourAngle` multiplied by how many minutes in a total hour have passed.\\n\\t* In our return statement we need to be sure to modulo the `hour` value by `12` since a clock can represent 24 hours by looping around the clock twice.\\n* After we have both the `minuteAngle` and the `hourAngle`, we calculate the `angleDifference` as an `abs`olute value, and return the smaller angle in the circle using a ternary operator.\\n```\\nclass Solution:\\n    \\n    def getMinuteAngle(self, minutes: int) -> int:\\n        oneMinuteAngle = 6\\n        \\n        return minutes * oneMinuteAngle\\n    \\n    def getHourAngle(self, hour: int, minutes: int) -> float:\\n        oneHourAngle = 30\\n        minuteOffsetAngle = oneHourAngle * (minutes / 60)\\n        \\n        return ((hour % 12) * oneHourAngle) + minuteOffsetAngle\\n    \\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        minuteAngle = self.getMinuteAngle(minutes)\\n        hourAngle = self.getHourAngle(hour, minutes)\\n\\n        angleDifference = abs(hourAngle - minuteAngle)\\n        return angleDifference if angleDifference <= 180 else 360 - angleDifference\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def getMinuteAngle(self, minutes: int) -> int:\\n        oneMinuteAngle = 6\\n        \\n        return minutes * oneMinuteAngle\\n    \\n    def getHourAngle(self, hour: int, minutes: int) -> float:\\n        oneHourAngle = 30\\n        minuteOffsetAngle = oneHourAngle * (minutes / 60)\\n        \\n        return ((hour % 12) * oneHourAngle) + minuteOffsetAngle\\n    \\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        minuteAngle = self.getMinuteAngle(minutes)\\n        hourAngle = self.getHourAngle(hour, minutes)\\n\\n        angleDifference = abs(hourAngle - minuteAngle)\\n        return angleDifference if angleDifference <= 180 else 360 - angleDifference\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786183,
                "title": "c-0ms-solution-using-formula",
                "content": "```\\n double a1,a2;\\n        a1=(double)(11*minutes)/2;\\n        a1=a1-(30*hour);\\n        a1=abs(a1);\\n        a2=abs(360-a1);\\n        if(a1<a2)\\n            return a1;\\n        else\\n            return a2;\\n```",
                "solutionTags": [],
                "code": "```\\n double a1,a2;\\n        a1=(double)(11*minutes)/2;\\n        a1=a1-(30*hour);\\n        a1=abs(a1);\\n        a2=abs(360-a1);\\n        if(a1<a2)\\n            return a1;\\n        else\\n            return a2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 784649,
                "title": "simple-java-solution-0ms-beat-100",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        if(hour<1 || hour >12 || minutes <0 || minutes >59) return -1;\\n        double handle1 = (double) hour + (double)minutes/60;\\n        double handle2 = (double)minutes / 60 * 12;\\n\\n        double res = Math.abs(handle1 - handle2) / 12 * 360;\\n        if(res > 180) res = 360 - res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        if(hour<1 || hour >12 || minutes <0 || minutes >59) return -1;\\n        double handle1 = (double) hour + (double)minutes/60;\\n        double handle2 = (double)minutes / 60 * 12;\\n\\n        double res = Math.abs(handle1 - handle2) / 12 * 360;\\n        if(res > 180) res = 360 - res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758827,
                "title": "clear-python-solution-faster-than-98",
                "content": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        minuteAngle = 6 * minutes\\n        hourAngle = (hour % 12) * 30\\n        add = minutes * 0.5\\n        hourAngle += add\\n        angle = abs(hourAngle - minuteAngle)\\n        return min(angle, 360 - angle)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        minuteAngle = 6 * minutes\\n        hourAngle = (hour % 12) * 30\\n        add = minutes * 0.5\\n        hourAngle += add\\n        angle = abs(hourAngle - minuteAngle)\\n        return min(angle, 360 - angle)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742053,
                "title": "java-solution-0ms-runtime",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n        double h_ang, minu_ang, angle=0.0;\\n        minu_ang = (minutes % 60) * 6;\\n        h_ang = (hour % 12) * 30 + minutes * 0.5;\\n        angle = Math.abs(h_ang - minu_ang);\\n      \\n        if(angle>180)\\n         angle = 360 - angle;\\n        \\n        return angle;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n        double h_ang, minu_ang, angle=0.0;\\n        minu_ang = (minutes % 60) * 6;\\n        h_ang = (hour % 12) * 30 + minutes * 0.5;\\n        angle = Math.abs(h_ang - minu_ang);\\n      \\n        if(angle>180)\\n         angle = 360 - angle;\\n        \\n        return angle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 737105,
                "title": "simple-java-math-solution",
                "content": "*Check out this desmos playground to visualize the graph :)*\\n***https://www.desmos.com/calculator/n7xtljtues***\\n\\nA full circle has `360 degrees` - and `60 minutes`. `360/60 = 6`\\n*Every minute* is **6 degrees clockwise for the minute hand**. \\n\\nEvery `hour` moves the hour-hand over `5` ticks, or `5 * 6 = 30 degrees`. \\nSo, *every minute* is **1/60 of an hour, or 30/60 degrees = .5 degrees clockwise for the hour hand**.\\n\\nSo, as time moves forward each minute, the angle grows by `5.5 degrees`(because 6 - 0.5 = 5.5). When the value goes over `180`, you take the extra and count backward. \\nStarting from `12:00`, or `0 degrees`, you can simply count forward by `5.5`. Ex: When the value reaches `181.5`, you take the shorter angle: `180 - 1.5 = 178.5`\\n\\n```\\n//hour * 60 gives us the number of ticks forward from the hour\\n//minutes tells us how many additional ticks forward\\n//multiply by 5.5 degrees per tick\\n//mod by 360 because it doesn\\'t matter if it\\'s rotated a full circle\\n//use min to get the smaller of the 2 angles formed\\n\\ndouble b = (((hour % 12) * 60 + minutes) * 5.5) % 360;\\nreturn Math.min(b, 360 - b);\\n```\\nThe `hour % 12` is so that 12:00 is treated as the beginning, aka 0 steps forward in time, rather than the end, 720 steps forward in time.\\n\\nAnother thing to note is that there are 361 unique outputs for this function, so you could easily precompute all the values, and store them if this method was going to be called many many times. The possible output values are `[0, 180]` *in steps of* `0.5`\\n\\nAdditionally, if you\\'re allowing complex numbers, you can use the following function to directly compute the result with all arithmetic:\\n![image](https://assets.leetcode.com/users/images/cdfe5fe3-28ba-4229-a9dd-f440093a0d3d_1594795935.0496445.png)\\n\\n`Re` means only the `real` portion of the complex number, and `Im` means only the imaginary part.\\n\\nThe input `x` is the number of minutes since the angle between the hands was `0 degrees`. The graph of the function looks like this:\\n![image](https://assets.leetcode.com/users/images/4b1cb2af-ada0-41ce-bd98-d0c63711f672_1594794620.6631007.png)\\n\\nCheck out this desmos playground to visualize the graph :)\\nhttps://www.desmos.com/calculator/n7xtljtues\\n<iframe src=\"https://www.desmos.com/calculator/n7xtljtues?embed\" width=\"500px\" height=\"500px\" style=\"border: 1px solid #ccc\" frameborder=0></iframe>",
                "solutionTags": [],
                "code": "```\\n//hour * 60 gives us the number of ticks forward from the hour\\n//minutes tells us how many additional ticks forward\\n//multiply by 5.5 degrees per tick\\n//mod by 360 because it doesn\\'t matter if it\\'s rotated a full circle\\n//use min to get the smaller of the 2 angles formed\\n\\ndouble b = (((hour % 12) * 60 + minutes) * 5.5) % 360;\\nreturn Math.min(b, 360 - b);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736991,
                "title": "logical-solution-over-optimized-solution",
                "content": "The first thing we want to do is map minutes to degrees. A simple way to logically do so is to solve for the ratio D in the proportion:\\nD = 360deg/60min = 6deg/1min;\\n\\nThen, x minutes in degrees is represented by:\\nM(x) = (x)min * D \\n\\t\\t = (x)min * (6)deg/min\\n\\t\\t = (6x)deg\\n\\nGiven that 5 minute increments also correspond to one hour on the clock:\\nM(5) = (6(5))deg\\n\\t\\t= 30deg;\\n\\nThe ith hour in degrees can be found by:\\nH_base(i) = i * 30deg;\\n\\nTo find the hour hand\\'s actual offset from it\\'s base:\\nH_offset(m) = M(5) * (M(m) / 360deg)\\n\\t\\t\\t\\t\\t= 30deg * ((6m)deg / 360deg)\\n\\t\\t\\t\\t\\t= 30deg * 6m/360\\n\\t\\t\\t\\t\\t= (m/2)deg\\n\\nThe total displacement, therefore, is:\\nH(h, m) = H_base(h) + H_offset(m)\\n\\t\\t\\t = h * 30deg + (m/2)deg\\n\\t\\t\\t = (30h + m/2)deg\\n\\nNow that we have H(h,m) and M(m), we can take the absolute value of their difference:\\nLet L = ABS(m - h).\\nBasically, the distance between the minute and hour hands is the angle, and that distance has to be positive.\\n\\nThe last requirement is that we take the smaller of the two resulting angles:\\nMIN (L, 360 - L)\\n\\nSo, in code:\\n\\n```\\nclass Solution {\\n#define M(m) 6 *m\\n#define H_base(h) h * 30\\n#define H_offset(m) (double)m / 2\\n#define H(h, m) H_base(h) + H_offset(m)\\npublic:\\n    double angleClock(int hour, int minutes) {\\n\\t\\tdouble M = M(minutes);\\n\\t\\tdouble H = H(hour, minutes);\\n\\t\\tdouble L = abs(M - H);\\n\\t\\treturn min(L, 360 - L);\\n    }\\n};\\n```\\n### Below are unnecessary optimizations, especially considering that this problem is \\'locked\\' now. I also assume the reader\\'s familiarity with algebra and C/C++\\nI considered two optimizations, both based on refactoring the expression, abs(M - H), which expands to: \\n```\\n\\tabs( 6 * minutes - (30 * hour + (minutes / 2) ) );\\n```\\nWith some algebra, we can bring the arithmetic operations down to 1 SUB and 2 MULT (the compiler knows to make (double)11/2 a constant. To skip the explicit cast, you can write it as a literal, 5.5):\\n```\\n    double angleClock(int hour, int minutes) {\\n\\t\\tdouble L = abs(5.5*minutes - 30.0*hour);\\n\\t\\treturn L > 180 ? 360 - L : L;\\n\\t}\\n```\\nWhile this alone might seem like the most optimal solution, the corresponding assembler output (clang++-9, -O1) will show many conversions and move operations that exist just because the abs function takes a double instead of an integer. So, maybe we can do better by refactoring the abs(M-H) expression so that M-H remains an integer? Yes:\\n```\\n\\tdouble L = abs(11*minutes - 60*hour) * 0.5;\\n```\\nEven further, we can keep the result of abs as an int and delay the conversion to a double (that happens when multiplying by 0.5) until after the final conditional statement:\\n```\\n        int L = abs(11*minutes - 60*hour);\\n        return (L > 360 ? 720 - L : L) * 0.5;\\n```\\nIn order to allow the L * 0.5 expression to become the function\\'s last instructions, we double the constants, 180 and 360, to return the correct values. If you looked at the compiler output, you would\\'ve been able to see that the constants 180 and 360 had to be moved into XMM registers to compare against L when it was a double. Now that L is an int, the new constants (360 and 720) are immediate operands to the instructions. Here is a CE link to a comparison of this change: https://godbolt.org/z/YMWWaz\\n\\nBasically, the premise of the optimizations comes from a general rule to minimize data conversions.\\n# Optimized Solution:\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        int L = abs(11*minutes - 60*hour);\\n        return (L > 360 ? 720 - L : L) * 0.5;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n#define M(m) 6 *m\\n#define H_base(h) h * 30\\n#define H_offset(m) (double)m / 2\\n#define H(h, m) H_base(h) + H_offset(m)\\npublic:\\n    double angleClock(int hour, int minutes) {\\n\\t\\tdouble M = M(minutes);\\n\\t\\tdouble H = H(hour, minutes);\\n\\t\\tdouble L = abs(M - H);\\n\\t\\treturn min(L, 360 - L);\\n    }\\n};\\n```\n```\\n\\tabs( 6 * minutes - (30 * hour + (minutes / 2) ) );\\n```\n```\\n    double angleClock(int hour, int minutes) {\\n\\t\\tdouble L = abs(5.5*minutes - 30.0*hour);\\n\\t\\treturn L > 180 ? 360 - L : L;\\n\\t}\\n```\n```\\n\\tdouble L = abs(11*minutes - 60*hour) * 0.5;\\n```\n```\\n        int L = abs(11*minutes - 60*hour);\\n        return (L > 360 ? 720 - L : L) * 0.5;\\n```\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        int L = abs(11*minutes - 60*hour);\\n        return (L > 360 ? 720 - L : L) * 0.5;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736893,
                "title": "java-solution-angle-between-hands-of-a-clock-0-ms-beat-100-5-lines-easy-to-understand",
                "content": "* Consider the clock as a 360 degree circle\\n* Each minute as a 6 degree leap, thus 60 minutes -> 360 degrees\\n* And each hour is a 30 degree leap, thus 12 hours -> 360 degrees\\n* Given the hour and minutes, calculate the respective angles\\n* Return the minimum of the diff and 360 - diff.\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        int minuteAngle = minutes*6;\\n        double hourAngle = hour == 12 ? 0 : hour*30;\\n        hourAngle += ((minuteAngle*30)/360.0);\\n        double angle = Math.abs(hourAngle - minuteAngle);\\n        return Math.min(360 - angle, angle);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        int minuteAngle = minutes*6;\\n        double hourAngle = hour == 12 ? 0 : hour*30;\\n        hourAngle += ((minuteAngle*30)/360.0);\\n        double angle = Math.abs(hourAngle - minuteAngle);\\n        return Math.min(360 - angle, angle);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736818,
                "title": "python-easy-solution",
                "content": "Just see if hour hand is ahead of minutes hand in clockwise direction.\\n```\\ndef angleClock(self, hour: int, minutes: int) -> float:\\n        mins_diff = (hour%12)*5 - minutes\\n        if mins_diff < 0:\\n            angle = abs(abs(mins_diff)*6 - minutes*0.5)\\n            return min(angle, 360-angle)\\n        else:\\n            angle = mins_diff*6 + minutes*0.5\\n            return min(angle, 360-angle)\\n```",
                "solutionTags": [],
                "code": "```\\ndef angleClock(self, hour: int, minutes: int) -> float:\\n        mins_diff = (hour%12)*5 - minutes\\n        if mins_diff < 0:\\n            angle = abs(abs(mins_diff)*6 - minutes*0.5)\\n            return min(angle, 360-angle)\\n        else:\\n            angle = mins_diff*6 + minutes*0.5\\n            return min(angle, 360-angle)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 736731,
                "title": "python-3-lines",
                "content": "```\\nclass Solution(object):\\n    def angleClock(self, hour, minutes):\\n        \"\"\"\\n        :type hour: int\\n        :type minutes: int\\n        :rtype: float\\n        \"\"\"\\n        m = minutes*6\\n        h = hour*30 + float(minutes*30)/60\\n    \\n        return min(abs(m-h), 360-abs(m-h))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def angleClock(self, hour, minutes):\\n        \"\"\"\\n        :type hour: int\\n        :type minutes: int\\n        :rtype: float\\n        \"\"\"\\n        m = minutes*6\\n        h = hour*30 + float(minutes*30)/60\\n    \\n        return min(abs(m-h), 360-abs(m-h))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736695,
                "title": "c-avoids-double-arithmetic-almost",
                "content": "Since calculations using doubles are more inefficient than ints, we keep the angles in half-degrees(0-720 instead of 0-360) until the very end.\\n\\nRemove unnecessary addition in delta calculation which should look like this:\\n```var delta = (hour == 12 ? 0 : hour * 60) + minutes - (minutes * 12);```\\nBut can be reduced to the line below.\\n\\nAvoids using Math.Abs\\n\\n```\\n    public double AngleClock(int hour, int minutes) {\\n        var delta = (hour == 12 ? 0 : hour * 60) - (minutes * 11);\\n        if (delta < 0) delta += 720;\\n        if (delta > 360) delta = 720 - delta;\\n        return delta / 2D;\\n    }\\n```",
                "solutionTags": [],
                "code": "```var delta = (hour == 12 ? 0 : hour * 60) + minutes - (minutes * 12);```\n```\\n    public double AngleClock(int hour, int minutes) {\\n        var delta = (hour == 12 ? 0 : hour * 60) - (minutes * 11);\\n        if (delta < 0) delta += 720;\\n        if (delta > 360) delta = 720 - delta;\\n        return delta / 2D;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736596,
                "title": "c-angle-between-h-and-m-with-proof-and-explaination",
                "content": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        /*\\n        \\n        total clock is divided into 12 sectors with 30 degree angle each as (360/12)=30\\n        \\n        each sector contributes 5 minutes so ->  30/5 = 6 degrees on each minute\\n        \\n        30*(hour%12) because we will calculate the shift with respect to 12 hour hand\\n        \\n        if some x minutes  past then how much does this contribute the hour hand rotation ? \\n        \\n        well, for 60 minutes it will turn 30 deg\\n        \\n            then for x minutes it will turn 30*x/60= x/2;\\n        \\n        so that is it take the difference of hour and minute hand then check which is minimum clockwise or anti             clockwise \\n        \\n        \\n        Please upvote if i was able to explain well  :-)\\n        \\n        */\\n        \\n        \\n        \\n        double ans= abs(30*(hour%12) + minutes/2.0 - 6*(minutes));\\n        \\n        \\n        return min(360-ans,ans);        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        /*\\n        \\n        total clock is divided into 12 sectors with 30 degree angle each as (360/12)=30\\n        \\n        each sector contributes 5 minutes so ->  30/5 = 6 degrees on each minute\\n        \\n        30*(hour%12) because we will calculate the shift with respect to 12 hour hand\\n        \\n        if some x minutes  past then how much does this contribute the hour hand rotation ? \\n        \\n        well, for 60 minutes it will turn 30 deg\\n        \\n            then for x minutes it will turn 30*x/60= x/2;\\n        \\n        so that is it take the difference of hour and minute hand then check which is minimum clockwise or anti             clockwise \\n        \\n        \\n        Please upvote if i was able to explain well  :-)\\n        \\n        */\\n        \\n        \\n        \\n        double ans= abs(30*(hour%12) + minutes/2.0 - 6*(minutes));\\n        \\n        \\n        return min(360-ans,ans);        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 736594,
                "title": "faster-than-100-java",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n    \\n        double minuteAngle = (360/60)*minutes;\\n        double hourAngle = (360/12)*hour + minutes * (30.0/60.0);\\n        \\n        return Math.min(Math.abs(hourAngle-minuteAngle), 360-Math.abs(hourAngle-minuteAngle));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n    \\n        double minuteAngle = (360/60)*minutes;\\n        double hourAngle = (360/12)*hour + minutes * (30.0/60.0);\\n        \\n        return Math.min(Math.abs(hourAngle-minuteAngle), 360-Math.abs(hourAngle-minuteAngle));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736545,
                "title": "c-simple-oneliner-explained-100-time-95-space",
                "content": "In order to solve it in one line, I used the trick to declare an extra variable (`diff`) as a parameter.\\n\\nIn the body of my function, I then used the parentheses to assign it the result of my operation and then just use its result for the conditional of the ternary operator, whose clauses were now just using the updated value of `diff`.\\n\\nFor the math, I just grouped: the angle formed by the hours is computed as `h * 30 + m / 2.0`, since each full hour can only take `1 / 12` of the whole clock, so `360 / 12 == 30`, plus the portion matching how many minutes have passed since the last \"o\\'clock\" moment, ie: `m * 30 / 60.0 == m / 2.0`. For the minutes is even easier: each minute equates to `360 / 60`, that is to say, `6` degrees.\\n\\nYou end up having `h * 30 + m / 2.0 - m * 6` or, if you group another bit: `h * 30.0 - m * 11 / 2.0`.\\n\\nFinally, if the difference is bigger than half a circle (`180` degreess), then I take the smaller angle, computed as `360 - diff`; if it is smaller, I just take `diff` directly :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m, double diff = 0) {\\n        return (diff = abs(h * 30.0 - m * 11 / 2.0)) > 180 ? 360 - diff : diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m, double diff = 0) {\\n        return (diff = abs(h * 30.0 - m * 11 / 2.0)) > 180 ? 360 - diff : diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736198,
                "title": "angle-between-hands-o-a-clock-answer-using-formula",
                "content": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        double x =abs((11/2.0)*minutes-30*hour);\\n        if(x<180)\\n            return x;\\n        else\\n            return 360-x;\\n    }\\n};\\n\\nuse   angle=|(11/2.0)*minutes-30 * hour |\\nif angle>180 then 360-angle is the answer.\\nelse\\nangle is the answer.",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        double x =abs((11/2.0)*minutes-30*hour);\\n        if(x<180)\\n            return x;\\n        else\\n            return 360-x;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 736142,
                "title": "easiest-mathematical-explanation-with-4-line-readable-java-code",
                "content": "For **minutes angle** - \\n60 minutes = 360 angle\\ngiven minutes = ? angle\\n**minutesAngle = minutes\\\\*360/60 = minutes\\\\*6**\\n\\nFor **hour angle** - \\n1 hours = 30 angle\\ngiven hours = ? angle\\n**hourAngle = hour*30 + (angle due to minutes)**\\n**Exception :** for hour 12, hour angle will be 0 and total angle will be only due to minutes.\\n\\nFor **angle due to minutes** -\\n60 minutes = 30 angle\\ngiven minutes = ? angle\\n**angle due to minutes = minutes*30/60 = minutes/2**\\n```\\nclass Solution {\\n    public double angleClock(int hour, int min) {\\n        double minutes = min, minuteAngle=minutes*6;   //minutes variable is only for converting minutes to double from int\\n        double hoursAngle = (hour==12) ? minutes/2 : (hour*30)+(minutes/2);\\n        double angle = Math.abs(minuteAngle-hoursAngle);   //difference between both angles\\n        return angle>180 ? 360-angle : angle;   // for minimum angle, if angle is greater than 180, subtract it from 360\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int min) {\\n        double minutes = min, minuteAngle=minutes*6;   //minutes variable is only for converting minutes to double from int\\n        double hoursAngle = (hour==12) ? minutes/2 : (hour*30)+(minutes/2);\\n        double angle = Math.abs(minuteAngle-hoursAngle);   //difference between both angles\\n        return angle>180 ? 360-angle : angle;   // for minimum angle, if angle is greater than 180, subtract it from 360\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736042,
                "title": "angle-between-hands-of-a-clock-clean-java-code",
                "content": "```\\nclass Solution {\\n    \\n    final double MIN_P_H     = 5.0;\\n    final double CIRCLE      = 360.0;\\n    final double SEMI_CIRCLE = 180.0;\\n    final double HOURS       = 12.0;\\n    final double MINUTES     = 60.0;\\n    final double DEGREE_P_H  = 30.0;\\n    \\n    public double angleClock(int hour, int minutes) {\\n        if(minutes == hour/MIN_P_H) return 0.0;\\n        \\n        double result = 0.0;\\n        \\n        double minutes_d = degreeOfMin(minutes);\\n        double hour_d    = degreeOfHour(hour, minutes);\\n        result = Math.abs(minutes_d - hour_d);\\n        \\n        if(result > SEMI_CIRCLE) result = Math.abs(result - CIRCLE);\\n        return result;\\n    }\\n    \\n    private double degreeOfMin(int m){\\n        if(m == 0) return 0.0;\\n        \\n        double minutes_ratio = m / MINUTES;\\n        return minutes_ratio * CIRCLE;\\n    }\\n    \\n    private double degreeOfHour(int h, int m){\\n        if(h == HOURS && m == 0) return 0.0;\\n        \\n        double hours_ratio = h / HOURS;\\n        double minutes_ratio = m / MINUTES;\\n        double hours_degree = (hours_ratio * CIRCLE) + (minutes_ratio * DEGREE_P_H);\\n        \\n        if(hours_degree > CIRCLE) hours_degree -= CIRCLE;\\n        return hours_degree;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    final double MIN_P_H     = 5.0;\\n    final double CIRCLE      = 360.0;\\n    final double SEMI_CIRCLE = 180.0;\\n    final double HOURS       = 12.0;\\n    final double MINUTES     = 60.0;\\n    final double DEGREE_P_H  = 30.0;\\n    \\n    public double angleClock(int hour, int minutes) {\\n        if(minutes == hour/MIN_P_H) return 0.0;\\n        \\n        double result = 0.0;\\n        \\n        double minutes_d = degreeOfMin(minutes);\\n        double hour_d    = degreeOfHour(hour, minutes);\\n        result = Math.abs(minutes_d - hour_d);\\n        \\n        if(result > SEMI_CIRCLE) result = Math.abs(result - CIRCLE);\\n        return result;\\n    }\\n    \\n    private double degreeOfMin(int m){\\n        if(m == 0) return 0.0;\\n        \\n        double minutes_ratio = m / MINUTES;\\n        return minutes_ratio * CIRCLE;\\n    }\\n    \\n    private double degreeOfHour(int h, int m){\\n        if(h == HOURS && m == 0) return 0.0;\\n        \\n        double hours_ratio = h / HOURS;\\n        double minutes_ratio = m / MINUTES;\\n        double hours_degree = (hours_ratio * CIRCLE) + (minutes_ratio * DEGREE_P_H);\\n        \\n        if(hours_degree > CIRCLE) hours_degree -= CIRCLE;\\n        return hours_degree;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735918,
                "title": "python-readable-solution",
                "content": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        if hour == 12:\\n            hour = 0\\n        time_minutes = hour*60 + minutes\\n        hour_angle = (time_minutes * 360) / (12*60)\\n        minute_angle = (minutes * 360) / 60\\n        ans = abs(minute_angle - hour_angle)\\n        if ans > 180:\\n            ans = 360 - ans\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        if hour == 12:\\n            hour = 0\\n        time_minutes = hour*60 + minutes\\n        hour_angle = (time_minutes * 360) / (12*60)\\n        minute_angle = (minutes * 360) / 60\\n        ans = abs(minute_angle - hour_angle)\\n        if ans > 180:\\n            ans = 360 - ans\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735846,
                "title": "c-just-1-line-easy-peasy-japanesey",
                "content": "For every one hour, the bigger hand rotates by 30\\xB0. And for every minute past that hour, the bigger hand further rotates by 0.5\\xB0. The minute hand rotates at 6\\xB0 per minute. Return the difference between both the hands. \\n```\\ndouble angleClock(int hour, int minutes)\\n        return min(abs(hour*30 - minutes*5.5), 360-abs(hour*30 - minutes*5.5));\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\ndouble angleClock(int hour, int minutes)\\n        return min(abs(hour*30 - minutes*5.5), 360-abs(hour*30 - minutes*5.5));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 735783,
                "title": "java-o-1-math-formula",
                "content": "Explanation: For the hours, you have 12 different values. For the minutes you have 60 different values. You can then divide 360 degrees into 12 parts for the hours (result is 30), and divide 360 degrees into 60 parts for the minutes (result: 6).\\n\\nNow you can easily calculate how many degrees there are between the beginning of each pointer and their current position. For the hours it would be `30*hours` and for the minutes it would be `6*minutes`. But be careful! The hour pointer can be anywhere between the current and the next hour, so you can\\'t just take the hours value, you need to use the minutes to calculate where, in between the current and the next hour, the pointer is. You do that by using `30 * (hours + minutes/60)`.\\n\\nNow, in order to calculate the angle between, you take the difference between the two calculated degrees. Beware that the result can be negative, as you won\\'t know which pointer is ahead of the other, so you take the absolute value of that difference. Also, you do not know if you calculated the bigger or the smaller angle, so you do take the minimum between the calculated angle and its complement: `min(calculated,360-calculated)`.\\n\\nThe formula can then be worked.\\n1. `| 6minutes - 30 * (hours + minutes/60) |`\\n2. `| 6minutes - 30hours - 30minutes/60 |`\\n3. `| 6minutes - 30hours - minutes/2 |`\\n4. `| 12minutes/2 - 60hours/2 - minutes/2 |`\\n5. `| 11minutes/2 - 60hours/2 |`\\n6. `| (11minutes - 60hours)/2 |`\\n\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double a = Math.abs((11*minutes - 60*hour)/2.0);\\n        return Math.min(a,360-a);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double a = Math.abs((11*minutes - 60*hour)/2.0);\\n        return Math.min(a,360-a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735712,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n        double diff = (minutes/60.0)*30;\\n        \\n        double hourHand = hour * 30 + diff;\\n        double minuteHand = minutes * 6;\\n        \\n        double ans = hourHand - minuteHand;\\n        if(ans < 0){\\n            ans = -ans;\\n        }\\n        if(ans > 180){\\n            ans = 360 - ans;\\n        }\\n       \\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n        double diff = (minutes/60.0)*30;\\n        \\n        double hourHand = hour * 30 + diff;\\n        double minuteHand = minutes * 6;\\n        \\n        double ans = hourHand - minuteHand;\\n        if(ans < 0){\\n            ans = -ans;\\n        }\\n        if(ans > 180){\\n            ans = 360 - ans;\\n        }\\n       \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735664,
                "title": "go-0ms-faster-than-100",
                "content": "```go\\nfunc angleClock(hour int, minutes int) float64 {\\n    hour %= 12\\n    ma, ha := 360.0/60.0*float64(minutes), 360.0/12.0*float64(hour) + 360.0/12.0*float64(minutes)/60.0\\n    a := math.Max(ma, ha) - math.Min(ma, ha)\\n    \\n    if a > 180.0 {\\n        return 360.0 - a\\n    }\\n    \\n    return a\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc angleClock(hour int, minutes int) float64 {\\n    hour %= 12\\n    ma, ha := 360.0/60.0*float64(minutes), 360.0/12.0*float64(hour) + 360.0/12.0*float64(minutes)/60.0\\n    a := math.Max(ma, ha) - math.Min(ma, ha)\\n    \\n    if a > 180.0 {\\n        return 360.0 - a\\n    }\\n    \\n    return a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 735651,
                "title": "suddh-desi-math",
                "content": "```\\n public static double angleClock(int hour, int minutes) {\\n\\n        /**\\n         * What do i know :\\n         *\\n         * Total Degrees = 360. For 12 hours\\n         * In 1 hour = 360/12 = 30 degrees.\\n         * In 1 hour(60 minutes) = 30 degree, So 1 minute = 30/60 ==> 1/2;\\n         *\\n         * Now how much hour has moved in corresponding to minute.\\n         * HourDegree = hour * 30 + (minutes/60) * 30;\\n         *\\n         * Or we can also write as\\n         * HourDegree = hour * 30 + minute/2\\n         *\\n         * For Minutes it\\'s simple :\\n         * In 1 minute = 360/60 ==> 6 degree.\\n         *\\n         * So for given minutes\\n         * MinutesDegree = minutes * 6;\\n         *\\n         * Edge case if someone has given time 12:30....we have to consider time from 0 to 11... else 12 * 30 will overshoot\\n         */\\n        double hourDegree = hour * 30 + (minutes / 2d);\\n        double minuteDegree = minutes * 6;\\n\\n        double absoluteDifferenceInDegree = Math.abs(hourDegree - minuteDegree);\\n\\n        return absoluteDifferenceInDegree > 180 ? 360 - absoluteDifferenceInDegree : absoluteDifferenceInDegree;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n public static double angleClock(int hour, int minutes) {\\n\\n        /**\\n         * What do i know :\\n         *\\n         * Total Degrees = 360. For 12 hours\\n         * In 1 hour = 360/12 = 30 degrees.\\n         * In 1 hour(60 minutes) = 30 degree, So 1 minute = 30/60 ==> 1/2;\\n         *\\n         * Now how much hour has moved in corresponding to minute.\\n         * HourDegree = hour * 30 + (minutes/60) * 30;\\n         *\\n         * Or we can also write as\\n         * HourDegree = hour * 30 + minute/2\\n         *\\n         * For Minutes it\\'s simple :\\n         * In 1 minute = 360/60 ==> 6 degree.\\n         *\\n         * So for given minutes\\n         * MinutesDegree = minutes * 6;\\n         *\\n         * Edge case if someone has given time 12:30....we have to consider time from 0 to 11... else 12 * 30 will overshoot\\n         */\\n        double hourDegree = hour * 30 + (minutes / 2d);\\n        double minuteDegree = minutes * 6;\\n\\n        double absoluteDifferenceInDegree = Math.abs(hourDegree - minuteDegree);\\n\\n        return absoluteDifferenceInDegree > 180 ? 360 - absoluteDifferenceInDegree : absoluteDifferenceInDegree;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 735567,
                "title": "c-simple-straightforward-solution-100-00",
                "content": "```\\n// Please, UpVote, if you like it :-)\\ndouble angleClock(int hour, int minutes) {\\n\\tdouble minutesAngle = (360 / 60) * minutes;\\n\\tdouble hoursAngle = (360 / 12) * (hour % 12);\\n\\thoursAngle += (360 / 12) * (minutes / 60.0); // minutes for adding to hours\\n\\tdouble angle = abs(minutesAngle - hoursAngle);\\n\\treturn min(angle, 360 - angle);\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Please, UpVote, if you like it :-)\\ndouble angleClock(int hour, int minutes) {\\n\\tdouble minutesAngle = (360 / 60) * minutes;\\n\\tdouble hoursAngle = (360 / 12) * (hour % 12);\\n\\thoursAngle += (360 / 12) * (minutes / 60.0); // minutes for adding to hours\\n\\tdouble angle = abs(minutesAngle - hoursAngle);\\n\\treturn min(angle, 360 - angle);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 735478,
                "title": "c-one-liner",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n        return min(abs(h*30- 5.5*m), 360-abs(h*30- 5.5*m));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n        return min(abs(h*30- 5.5*m), 360-abs(h*30- 5.5*m));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735467,
                "title": "c-simple-maths-0ms-soln-100",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hrNeedle=(hour+(minutes/60.0))*30;\\n        double minNeedle=minutes*6.0;\\n        double diff=abs(hrNeedle-minNeedle);\\n        return min(diff,360.0-diff);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hrNeedle=(hour+(minutes/60.0))*30;\\n        double minNeedle=minutes*6.0;\\n        double diff=abs(hrNeedle-minNeedle);\\n        return min(diff,360.0-diff);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735435,
                "title": "java-3-lines-100-with-0ms",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n\\t\\t//The absolute degree between two needles.\\n\\t\\t//Minute: 1minute = 6 degrees\\n\\t\\t//Hour: 1hour = 30 degrees\\n\\t\\t//For Hour needle, we take modulus 12 because the degree of 12 o\\'clock is 0.\\n\\t\\t//However the degree of Hour needle needs to take into account the progress\\n\\t\\t// of the Minute needle, which is min/60, with min varies from 0 to 60. During this \\n\\t\\t// progression, the Hour needle can move a total of 30 degrees, that\\'s why we add \\n\\t\\t// 30* min/60 to the Hour needle angle.\\n        double ans=Math.abs(((hour%12)*30+(double)minutes/2)-minutes*6);\\n\\t\\t\\n        if(ans>180)ans=360-ans;\\n\\t\\t//We want the smaller angle.\\n\\t\\t//Math.min() is avoided as it slows down the code.\\n\\t\\t\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n\\t\\t//The absolute degree between two needles.\\n\\t\\t//Minute: 1minute = 6 degrees\\n\\t\\t//Hour: 1hour = 30 degrees\\n\\t\\t//For Hour needle, we take modulus 12 because the degree of 12 o\\'clock is 0.\\n\\t\\t//However the degree of Hour needle needs to take into account the progress\\n\\t\\t// of the Minute needle, which is min/60, with min varies from 0 to 60. During this \\n\\t\\t// progression, the Hour needle can move a total of 30 degrees, that\\'s why we add \\n\\t\\t// 30* min/60 to the Hour needle angle.\\n        double ans=Math.abs(((hour%12)*30+(double)minutes/2)-minutes*6);\\n\\t\\t\\n        if(ans>180)ans=360-ans;\\n\\t\\t//We want the smaller angle.\\n\\t\\t//Math.min() is avoided as it slows down the code.\\n\\t\\t\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735425,
                "title": "c-solution-in-two-line",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double g=abs(30*hour-5.5*minutes);\\n        return min(g,360-g);\\n    }\\n};\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double g=abs(30*hour-5.5*minutes);\\n        return min(g,360-g);\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 735368,
                "title": "c-4-line-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hourDegree = (hour+(minutes/60.00))*30.00; // Hour*30 for degrees hour needle has covered + extra degrees covered by hour according to minute.\\n        double minDegree = minutes*6.00; // 1 minute is 6 degrees\\n        \\n        double diff = abs(hourDegree - minDegree);\\n        \\n        return min(diff, 360.00-diff);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hourDegree = (hour+(minutes/60.00))*30.00; // Hour*30 for degrees hour needle has covered + extra degrees covered by hour according to minute.\\n        double minDegree = minutes*6.00; // 1 minute is 6 degrees\\n        \\n        double diff = abs(hourDegree - minDegree);\\n        \\n        return min(diff, 360.00-diff);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724080,
                "title": "100-faster-cpp",
                "content": "```\\n double angleClock(int h, int m) {\\n        double d,x,d1;\\n        if(h==12)\\n            h=0;\\n        d=abs(h*30-5.5*m);\\n        d1=min(d,360-d);\\n        \\n        \\n        return d1;\\n    }\\n\\t",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n double angleClock(int h, int m) {\\n        double d,x,d1;\\n        if(h==12)\\n            h=0;\\n        d=abs(h*30-5.5*m);\\n        d1=min(d,360-d);\\n        \\n        \\n        return d1;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 641291,
                "title": "java-0ms-100",
                "content": "```\\n    public double angleClock(int hour, int minutes) {\\n        hour = hour % 12;\\n        double tmp = minutes * 1.0 / 60 * 30;\\n        double hourAngle = hour * 30 + tmp;\\n        double minuteAngle = tmp * 12;\\n        double gap = Math.abs(hourAngle - minuteAngle);\\n        return Math.min(gap, 360 - gap);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public double angleClock(int hour, int minutes) {\\n        hour = hour % 12;\\n        double tmp = minutes * 1.0 / 60 * 30;\\n        double hourAngle = hour * 30 + tmp;\\n        double minuteAngle = tmp * 12;\\n        double gap = Math.abs(hourAngle - minuteAngle);\\n        return Math.min(gap, 360 - gap);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 634685,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} hour\\n * @param {number} minutes\\n * @return {number}\\n */\\nvar angleClock = function(hour, minutes) {\\n    if(hour == 12){\\n        hour = 0\\n    }\\n    let min = minutes/5\\n    \\n    let newHour = Math.abs(hour + minutes/60)\\n    let angle = Math.abs(newHour-min)*30\\n    return Math.min((360-angle),angle)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} hour\\n * @param {number} minutes\\n * @return {number}\\n */\\nvar angleClock = function(hour, minutes) {\\n    if(hour == 12){\\n        hour = 0\\n    }\\n    let min = minutes/5\\n    \\n    let newHour = Math.abs(hour + minutes/60)\\n    let angle = Math.abs(newHour-min)*30\\n    return Math.min((360-angle),angle)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615354,
                "title": "c-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) \\n    {\\n        double hourAngle = (hour % 12) * 30 + 1.0 * minutes / 2, minuteAngle = minutes * 6;\\n        return min(abs(hourAngle - minuteAngle), 360 - abs(hourAngle - minuteAngle));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) \\n    {\\n        double hourAngle = (hour % 12) * 30 + 1.0 * minutes / 2, minuteAngle = minutes * 6;\\n        return min(abs(hourAngle - minuteAngle), 360 - abs(hourAngle - minuteAngle));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568481,
                "title": "python-99-one-liner-explained",
                "content": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        h,m = (360*(hour+minutes/60)/12) % 360 , (360*minutes/60) \\n        d = abs(h-m)\\n        return d if d<180 else 360 - d\\n```\\n\\nLet\\'s start with a 3 liner. There are a couple catches here.\\n\\n1. if we start from 0, the minutes never go above 60. But the hours can be actually above 12 (like if we get 12:59 - that\\'s almost 1:00), so we need to add minutes to the hours:\\n\\n```\\n        h,m = (360*(hour+minutes/60)/12) % 360 , (360*minutes/60) \\n```\\n\\nThe hours can go from 0:00 - that\\'s 0 to 12:00 - that\\'s 360 and even higher to 12:59 - that\\'s above 360. So if our hour angle goes above 360 - we need to bring reduce it by 360, that\\'s done by `% 360`\\n\\n3. The angle between the arrows can\\'t be more than 180, so we need to find the diff. We do it in two steps:\\n\\n```\\n        d = abs(h-m)\\n\\t\\treturn d if d<180 else 360 - d\\n```\\n\\nThat looks somewhat random, but there is meaning to it. The angle between arrows is relative and can be measured in two ways - clockwise and counterclockwise. One if those angles is going to be <=180, another one is >=180 . So we need to pick the smaller angle regardless of the direction. The first `abs()` call basically means we don\\'t care if the angle is measured clockwise or counterwise. And the 2nd `if` statement says that we need to pick the smaller one.\\n\\nOk, so where is the one-liner? Here you go, the same code, just re-packaged:\\n\\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        return d if (d := abs(30*(hour+minutes/60) % 360 - 6*minutes)) <180 else 360 - d\\n ```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        h,m = (360*(hour+minutes/60)/12) % 360 , (360*minutes/60) \\n        d = abs(h-m)\\n        return d if d<180 else 360 - d\\n```\n```\\n        h,m = (360*(hour+minutes/60)/12) % 360 , (360*minutes/60) \\n```\n```\\n        d = abs(h-m)\\n\\t\\treturn d if d<180 else 360 - d\\n```\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        return d if (d := abs(30*(hour+minutes/60) % 360 - 6*minutes)) <180 else 360 - d\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 565039,
                "title": "java-simple-and-easy-to-understand",
                "content": "class Solution {\\n\\n\\tpublic double angleClock(int hour, int minutes) {\\n\\t\\t\\n\\t\\tdouble h = (hour % 12) * 30 + (minutes / 60.0) * 30;\\n\\t\\tdouble m = minutes * 6;\\n\\t\\tdouble abs = Math.abs(h - m);\\n\\n\\t\\treturn abs > 180 ? 360 - abs : abs;\\n\\t}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\tpublic double angleClock(int hour, int minutes) {\\n\\t\\t\\n\\t\\tdouble h = (hour % 12) * 30 + (minutes / 60.0) * 30;\\n\\t\\tdouble m = minutes * 6;\\n\\t\\tdouble abs = Math.abs(h - m);\\n\\n\\t\\treturn abs > 180 ? 360 - abs : abs;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 555054,
                "title": "java-beats-100-time-space",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double h_dev = (minutes != 60 && minutes != 0) ? (((double)minutes/60) / 12 ) * 360 : 0;\\n        double h = hour != 12 ? ((double)hour / 12 ) * 360 : 0;\\n        double h_angle_from_12 = h + h_dev;\\n        double m_angle_from_12 = minutes != 60 ? ((double)minutes / 60) * 360 : 0;\\n        \\n        return Math.min(Math.abs(h_angle_from_12 - m_angle_from_12),Math.abs(360 - Math.abs(h_angle_from_12 - m_angle_from_12)));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double h_dev = (minutes != 60 && minutes != 0) ? (((double)minutes/60) / 12 ) * 360 : 0;\\n        double h = hour != 12 ? ((double)hour / 12 ) * 360 : 0;\\n        double h_angle_from_12 = h + h_dev;\\n        double m_angle_from_12 = minutes != 60 ? ((double)minutes / 60) * 360 : 0;\\n        \\n        return Math.min(Math.abs(h_angle_from_12 - m_angle_from_12),Math.abs(360 - Math.abs(h_angle_from_12 - m_angle_from_12)));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550569,
                "title": "c-one-liner",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        return abs((hour % 12) * 30.0 - minutes * 5.5) > 180 ? 360.0 - abs((hour % 12) * 30.0 - minutes * 5.5) : abs((hour % 12) * 30.0 - minutes * 5.5);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        return abs((hour % 12) * 30.0 - minutes * 5.5) > 180 ? 360.0 - abs((hour % 12) * 30.0 - minutes * 5.5) : abs((hour % 12) * 30.0 - minutes * 5.5);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549352,
                "title": "java-solution-beats-100-time-space",
                "content": "360 for 12h -> 1 h has 30\\n360 for 60m -> 1 m has 6\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        if (hour == 12) hour = 0;\\n\\n        double hh = (hour + minutes * 1.0 / 60) * 30;\\n        double mm = minutes * 6;\\n\\n        double diff = Math.abs(hh - mm);\\n        return Math.min(diff, 360 - diff);\\n    }\\n}\\n```\\n\\nMore concise code\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double diff = Math.abs(hour * 30 - minutes * 5.5);\\n        return Math.min(diff, 360 - diff);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        if (hour == 12) hour = 0;\\n\\n        double hh = (hour + minutes * 1.0 / 60) * 30;\\n        double mm = minutes * 6;\\n\\n        double diff = Math.abs(hh - mm);\\n        return Math.min(diff, 360 - diff);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double diff = Math.abs(hour * 30 - minutes * 5.5);\\n        return Math.min(diff, 360 - diff);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509782,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nCalculate the degree of the hour hand and the degree of the minute hand.  Return the answer as the difference between these two degrees.\\n\\n**Note:** if this difference is greater-than `180` degrees, then subtract `180` from the answer (ie. it is a smaller degree difference between the two hands on the other side of the clock).  For example, let\\'s say the degree difference is `270`, then `270 - 180 = 90`.  This is the same value as `360 - 270 = 90`.  So we can simply return the minimum of the `answer` and `360 - answer`.\\n\\n**Formulas:**\\n```\\nh = hours\\nm = minutes\\n\\t\\t\\t \\nhour degree = h * 360 / 12 + 30 * m / 60\\n            = h * 30 + m / 2\\n\\nminute degree = m / 60 * 360\\n              = m * 6\\n\\nanswer degree = abs(hour degree - minute degree)\\n              = abs(h * 30 + m / 2 - m * 6)\\n              = abs(h * 30 - m * 5.5)\\n```\\n\\n**Runtime:** O(1)\\n\\n---\\n\\n**Concise Solutions:**\\n\\n*Javascript*\\n```\\nlet angleClock = (h, m) => {\\n    let degree = Math.abs(h * 30 - m * 5.5);\\n    return Math.min(degree, 360 - degree);\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n        auto degree = abs(h * 30 - m * 5.5);\\n        return min(degree, 360 - degree);\\n    }\\n};\\n```\\n\\n---\\n\\n**Verbose Solutions:**\\n\\n*Javascript*\\n```\\nlet angleClock = (h, m) => {\\n    if (h == 12)\\n        h = 0;\\n    h = 30 * h + 0.5 * m;\\n    m = 6 * m;\\n    let degree = Math.max(h, m) - Math.min(h, m);\\n    return Math.min(degree, 360 - degree)\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m, double offset = 1e5) {\\n        if (h == 12)\\n            h = 0;\\n        h = offset * (30 * h + 0.5 * m);\\n        m = offset * (6 * m);\\n        auto degree = max(h, m) - min(h, m);\\n        return min(degree / offset, 360 - degree / offset);\\n    }\\n};\\n```\\n\\n---\\n\\n**Supplemental Notes:**\\n\\n60 minutes for 360 degrees -> 1 minute for every 6 degrees\\n\\n12 hours for 360 degrees -> 1 hour for every 30 degrees\\n\\nwithin that 30 degrees, the minute hand alters the hour hand\\n\\n60 minutes for 30 degrees -> 1 minute for every 0.5 degrees\\n\\nformulas:\\n\\nh = 30 * h + 0.5 * m\\nm = 6 * m\\n\\nexamples:\\n\\nInput: hour = 12, minutes = 30\\nOutput: 165\\n\\nhour = 12 -> degree = 0 + 30 * 0.5 = 15\\nmin = 30 -> degree = 30 * 6 = 180\\n180 - 15 = 165\\n\\nInput: hour = 3, minutes = 30\\nOutput: 75\\n\\nhour = 3 -> degree = 3 * 30 = 90 + 30 * 0.5 = 105\\nmin = 30 -> degree = 30 * 6 = 180\\n180 - 105 = 75\\n\\nInput: hour = 3, minutes = 15\\nOutput: 7.5\\n\\nhour = 3 -> degree = 3 * 30 = 90 + 15 * 0.5 = 97.5\\nmin = 15 -> degree = 15 * 6 = 90\\n97.5 - 80 = 7.5\\n\\nInput: hour = 4, minutes = 50\\nOutput: 155\\n\\nhour = 4 -> degree = 4 * 30 = 120 + 50 * 0.5 = 145\\nmin = 50 -> degree = 50 * 6 = 300\\n300 - 145 = 155",
                "solutionTags": [],
                "code": "```\\nh = hours\\nm = minutes\\n\\t\\t\\t \\nhour degree = h * 360 / 12 + 30 * m / 60\\n            = h * 30 + m / 2\\n\\nminute degree = m / 60 * 360\\n              = m * 6\\n\\nanswer degree = abs(hour degree - minute degree)\\n              = abs(h * 30 + m / 2 - m * 6)\\n              = abs(h * 30 - m * 5.5)\\n```\n```\\nlet angleClock = (h, m) => {\\n    let degree = Math.abs(h * 30 - m * 5.5);\\n    return Math.min(degree, 360 - degree);\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n        auto degree = abs(h * 30 - m * 5.5);\\n        return min(degree, 360 - degree);\\n    }\\n};\\n```\n```\\nlet angleClock = (h, m) => {\\n    if (h == 12)\\n        h = 0;\\n    h = 30 * h + 0.5 * m;\\n    m = 6 * m;\\n    let degree = Math.max(h, m) - Math.min(h, m);\\n    return Math.min(degree, 360 - degree)\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m, double offset = 1e5) {\\n        if (h == 12)\\n            h = 0;\\n        h = offset * (30 * h + 0.5 * m);\\n        m = offset * (6 * m);\\n        auto degree = max(h, m) - min(h, m);\\n        return min(degree / offset, 360 - degree / offset);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504892,
                "title": "c-very-easy-solution-4-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double minute_angle = (360*minutes)/60;\\n        double hour_angle = (hour%12)*30 + (30*(double)minutes)/60;\\n        double ans = abs(minute_angle - hour_angle);\\n        return min(ans,360-ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double minute_angle = (360*minutes)/60;\\n        double hour_angle = (hour%12)*30 + (30*(double)minutes)/60;\\n        double ans = abs(minute_angle - hour_angle);\\n        return min(ans,360-ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503917,
                "title": "java-simple-solution-using-basic-maths",
                "content": "12 hours = 360 degree => 1 hour = 30 degree angle\\n60 minutes =  360 degree => 1 minute = 6 degree angle\\n1hour = 60 minutes => 1 minute = 1/60 hour\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double angle = Math.abs(30.0 * (hour % 12 + (double) minutes / 60) - 6 * minutes);\\n        return (angle <= 180.0) ? angle : 360 - angle;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double angle = Math.abs(30.0 * (hour % 12 + (double) minutes / 60) - 6 * minutes);\\n        return (angle <= 180.0) ? angle : 360 - angle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503266,
                "title": "java-4-line-very-simple-code-easy-to-understand",
                "content": "**step1**: compute the clockwise minutess angle difference from \"12\" \\n**step2**: compute the clockwise hours angle difference from \"12\" (which may be influnced by minutes hand)\\n**step3**: compute the absolute difference between the previous diff and return the smaller one: ```min(diff, 360 - diff)```\\n\\n\\n**Code**:\\n```java\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double minAngle = minutes * 6.0;     // Clockwise Angle difference from \"12\"\\n        double hourAngle = (hour % 12) * 30.0 + minutes * 0.5;  // min/60 * 30\\n        double diff = Math.abs(hourAngle - minAngle);\\n        return Math.min(diff, 360 - diff);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```min(diff, 360 - diff)```\n```java\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double minAngle = minutes * 6.0;     // Clockwise Angle difference from \"12\"\\n        double hourAngle = (hour % 12) * 30.0 + minutes * 0.5;  // min/60 * 30\\n        double diff = Math.abs(hourAngle - minAngle);\\n        return Math.min(diff, 360 - diff);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502810,
                "title": "c-simple-solution",
                "content": "We multiple minutes to 6 (because 360 / 60 = 6), also we transfer haur  to minutes and divide it to 2 (because 360/720 = 0.5).\\n360 total angel in clock\\n60 is minutes in 1 hour \\n720 is 12 hours in minutes\\n```\\ndouble angleClock(int hour, int minutes) {\\n\\tdouble res = 0;\\n\\tdouble minAngle = (double)minutes * 6;\\n\\tdouble hourAngle = ((double)hour * 60 + (double)minutes) / 2;\\n\\tres = abs(hourAngle - minAngle);\\n\\tres = min(res, 360 - res);\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble angleClock(int hour, int minutes) {\\n\\tdouble res = 0;\\n\\tdouble minAngle = (double)minutes * 6;\\n\\tdouble hourAngle = ((double)hour * 60 + (double)minutes) / 2;\\n\\tres = abs(hourAngle - minAngle);\\n\\tres = min(res, 360 - res);\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502709,
                "title": "python",
                "content": "```python\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        if (hour == 12): \\n            hour = 0\\n        if (minutes == 60): \\n            minutes = 0\\n        hour_angle = 0.5 * (hour * 60 + minutes) \\n        minute_angle = 6 * minutes\\n\\n        angle = abs(hour_angle - minute_angle)  \\n        angle = min(360 - angle, angle) \\n\\n        return angle",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        if (hour == 12): \\n            hour = 0\\n        if (minutes == 60): \\n            minutes = 0\\n        hour_angle = 0.5 * (hour * 60 + minutes) \\n        minute_angle = 6 * minutes\\n\\n        angle = abs(hour_angle - minute_angle)  \\n        angle = min(360 - angle, angle) \\n\\n        return angle",
                "codeTag": "Java"
            },
            {
                "id": 4072348,
                "title": "as-simple-as-you-done-in-your-schooling",
                "content": "# Intuition\\nJust as you done in aptitude\\n\\n# Approach\\nCalcuate minute spaces and thats it....\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        int hr_mul=30;\\n        double hr_min_mul=0.5;\\n        int min_mul=6;\\n        double i=hour*hr_mul;\\n        double j=minutes*hr_min_mul;\\n        double k=fmod(i+j,360.0);\\n        double l=minutes*min_mul;\\n        return min(fabs(k - l), 360.0 - fabs(k - l));;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        int hr_mul=30;\\n        double hr_min_mul=0.5;\\n        int min_mul=6;\\n        double i=hour*hr_mul;\\n        double j=minutes*hr_min_mul;\\n        double k=fmod(i+j,360.0);\\n        double l=minutes*min_mul;\\n        return min(fabs(k - l), 360.0 - fabs(k - l));;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046543,
                "title": "python-solution-with-formula",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery minute, the minute hand moves 6 degrees.(because 360/60 = 6 degrees)\\nEvery minute, the hour hand moves half a degree (there are 720 minutes in half a day).\\nSo At h:mm, the hour hand has moved (60h + m) * 0.5 degrees = 30h + m/2\\nThe minute hand is at 6m degrees\\nThe difference between is (30h + m/2) - 6m = 30h - (11/2)m.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find other angle,we just have to subtract with 360\\ni.e., 360-(30h)+5.5*m\\nFinally return the minimum angle of these angles\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n      a = abs(30*hour-5.5*minutes)\\n      b = abs(360-a)\\n      return b if a>b else a\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n      a = abs(30*hour-5.5*minutes)\\n      b = abs(360-a)\\n      return b if a>b else a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037869,
                "title": "easy-4-line-python3-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        hr_ang = (hour*30+0.5*minutes)%360\\n        min_ang = minutes*6%360\\n        diff =  abs(min_ang - hr_ang)\\n        return min(diff,360-diff)\\n        \\n\\n\\n\\n\\n\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        hr_ang = (hour*30+0.5*minutes)%360\\n        min_ang = minutes*6%360\\n        diff =  abs(min_ang - hr_ang)\\n        return min(diff,360-diff)\\n        \\n\\n\\n\\n\\n\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036069,
                "title": "c-solution-0ms-beats-100",
                "content": "**Explanation:**\\n\\nFirst find the angle that the hour hand makes:\\nThe hour hand will complete 30\\xB0 in one hour and using this we can deduce that if the hour hand moves 30\\xB0 in 1 hour (60 minutes) then it will move 30\\xB0/60 = 0.5\\xB0 in a minute. \\nTherefore, we can say the angle moved by the hour hand `= (30 * hour) + (0.5 * minutes)`.\\n\\nSimilarily, find the angle that the minute hand makes:\\nWe know that the 60 minutes equals one hour and so, minute hand completes 360\\xB0 (one revolution) in 60 minutes. Thus, the minute hand covers 360\\xB0/60 = 6\\xB0 in a minute.\\nTherefore, we can say the angle moved by the minute hand `= (6 * minutes)`.\\n\\nThe total angle between the hands equals to the absolute difference of the two angles.\\nNext, simply check if the angle calculated is greater than 180\\xB0, if so, then to return the smallest angle subtract the angle from 360\\xB0.\\n\\n**Solution:**\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hour_angle = (30*hour)+(0.5*minutes);\\n        double minute_angle = (6*minutes);\\n        double angle = abs(hour_angle - minute_angle);\\n        if(angle > 180) return (double)(360-angle);\\n        return angle;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hour_angle = (30*hour)+(0.5*minutes);\\n        double minute_angle = (6*minutes);\\n        double angle = abs(hour_angle - minute_angle);\\n        if(angle > 180) return (double)(360-angle);\\n        return angle;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035218,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        // find for minutes\\n        double a = (minutes / 60.0000) * 360.0000;\\n\\n        // find for hour\\n        double b = 0;\\n        if(hour < 12) b = (hour / 12.0000) * 360.0000;\\n\\n        b += (minutes / 60.0000) * 30.0000;\\n \\n        cout << a << \" \" << b << endl;\\n        if(abs(a - b) <= 180)  return abs(a - b);\\n\\n        if(a > 180) return 360 - a + b;\\n        return 360 - b + a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        // find for minutes\\n        double a = (minutes / 60.0000) * 360.0000;\\n\\n        // find for hour\\n        double b = 0;\\n        if(hour < 12) b = (hour / 12.0000) * 360.0000;\\n\\n        b += (minutes / 60.0000) * 30.0000;\\n \\n        cout << a << \" \" << b << endl;\\n        if(abs(a - b) <= 180)  return abs(a - b);\\n\\n        if(a > 180) return 360 - a + b;\\n        return 360 - b + a;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4023269,
                "title": "easy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        double angleClock(int hour, int minutes)\\n        {\\n            double total_hour = double(hour) + double(minutes) / 60;\\n\\n           \\t//12 hr -> 360 degrees\\n           \\t//1 hr  -> 30 degress\\n           \\t//x hr  -> x*30;\\n            double angle_hour_hand = total_hour * 30;\\n\\n           \\t//60 min -> 360 degrees\\n           \\t//1 min  -> 6 degrees\\n           \\t//y min  -> y*6\\n\\n            double angle_minute_hand = minutes * 6;\\n            if(angle_hour_hand >= 360)\\n              angle_hour_hand = angle_hour_hand-360;\\n\\n            double result = abs(angle_minute_hand - angle_hour_hand);\\n            if(result > 180)\\n              return 360-result;\\n            return result;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        double angleClock(int hour, int minutes)\\n        {\\n            double total_hour = double(hour) + double(minutes) / 60;\\n\\n           \\t//12 hr -> 360 degrees\\n           \\t//1 hr  -> 30 degress\\n           \\t//x hr  -> x*30;\\n            double angle_hour_hand = total_hour * 30;\\n\\n           \\t//60 min -> 360 degrees\\n           \\t//1 min  -> 6 degrees\\n           \\t//y min  -> y*6\\n\\n            double angle_minute_hand = minutes * 6;\\n            if(angle_hour_hand >= 360)\\n              angle_hour_hand = angle_hour_hand-360;\\n\\n            double result = abs(angle_minute_hand - angle_hour_hand);\\n            if(result > 180)\\n              return 360-result;\\n            return result;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991811,
                "title": "100-beats-cpp-easy-and-simple-solution-with-the-approach",
                "content": "double angleClock(int hour, int minutes) {\\n       if(hour==12)\\n           hour=0;\\n\\t\\t   \\n\\t\\t   /*    12 hour=360;\\n\\t\\t     1hour=30 deg rotate;\\n\\t\\t\\t 60 min=30 deg\\n\\t\\t\\t 1 min=1/2deg;\\n\\t\\t\\t so n minutes=n/2 deg\\n\\t\\t\\t hour=hour+minutes/2deg;\\n\\t\\t\\t */\\n        double h1=(minutes/5.0-0)*30;             \\n        double angle=(hour-0)*30+minutes/2.0;\\n       \\n        return min(abs(angle-h1),360-abs(angle-h1));\\n       \\n        \\n    }",
                "solutionTags": [],
                "code": "double angleClock(int hour, int minutes) {\\n       if(hour==12)\\n           hour=0;\\n\\t\\t   \\n\\t\\t   /*    12 hour=360;\\n\\t\\t     1hour=30 deg rotate;\\n\\t\\t\\t 60 min=30 deg\\n\\t\\t\\t 1 min=1/2deg;\\n\\t\\t\\t so n minutes=n/2 deg\\n\\t\\t\\t hour=hour+minutes/2deg;\\n\\t\\t\\t */\\n        double h1=(minutes/5.0-0)*30;             \\n        double angle=(hour-0)*30+minutes/2.0;\\n       \\n        return min(abs(angle-h1),360-abs(angle-h1));\\n       \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3985725,
                "title": "beats-100-best-and-o-1-time-and-space-complexity",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        if(hour==12)\\n        hour=0;\\n        double x=abs((60*hour)-(11*minutes));\\n        if(x/2<=180)\\n            return (x/2);\\n        else\\n            return 360-(x/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        if(hour==12)\\n        hour=0;\\n        double x=abs((60*hour)-(11*minutes));\\n        if(x/2<=180)\\n            return (x/2);\\n        else\\n            return 360-(x/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978899,
                "title": "clock-angle-direct-formula",
                "content": "# Approach\\nFormula for angle: \\n**angle = (11 / 2) * Minutes - 30 * Hours**\\nIf angle is greater than 180, return 360 - angle\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\n- Space complexity: O(1) \\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double ans = Math.abs(5.5 * minutes - 30 * hour);\\n        return ans < 180 ? ans : 360 - ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double ans = Math.abs(5.5 * minutes - 30 * hour);\\n        return ans < 180 ? ans : 360 - ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947037,
                "title": "c-1-line",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        return min(abs(30.0 * (hour % 12) - 5.5 * minutes), 360 - abs(30.0 * (hour % 12) - 5.5 * minutes));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        return min(abs(30.0 * (hour % 12) - 5.5 * minutes), 360 - abs(30.0 * (hour % 12) - 5.5 * minutes));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943814,
                "title": "javascript-simple-solution",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} hour\\n * @param {number} minutes\\n * @return {number}\\n */\\nvar angleClock = function(hour, minutes) {\\n    // calculate one minute angle -> 360deg / 60mins = 6deg\\n    let oneMinuteAngle = 6;\\n\\n    // calculate one hour angle -> 360deg / 12hrs = 30deg\\n    let oneHourAngle = 30;\\n\\n    // Minutes angle\\n    let minutesAngle = oneMinuteAngle * minutes;\\n\\n    // Hour Angle\\n    let hourAngle = (hour % 12 + minutes/60) * oneHourAngle;\\n\\n    let diff = Math.abs(hourAngle - minutesAngle);\\n\\n    return Math.min(diff, 360 - diff);\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} hour\\n * @param {number} minutes\\n * @return {number}\\n */\\nvar angleClock = function(hour, minutes) {\\n    // calculate one minute angle -> 360deg / 60mins = 6deg\\n    let oneMinuteAngle = 6;\\n\\n    // calculate one hour angle -> 360deg / 12hrs = 30deg\\n    let oneHourAngle = 30;\\n\\n    // Minutes angle\\n    let minutesAngle = oneMinuteAngle * minutes;\\n\\n    // Hour Angle\\n    let hourAngle = (hour % 12 + minutes/60) * oneHourAngle;\\n\\n    let diff = Math.abs(hourAngle - minutesAngle);\\n\\n    return Math.min(diff, 360 - diff);\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3929774,
                "title": "c-simple-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double ans = ((double)hour + (double)minutes/60)*30;\\n        ans -= (double)minutes*6;\\n        ans = fabs(ans);\\n        return (ans > 180) ? 360-ans : ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double ans = ((double)hour + (double)minutes/60)*30;\\n        ans -= (double)minutes*6;\\n        ans = fabs(ans);\\n        return (ans > 180) ? 360-ans : ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929196,
                "title": "easiest-two-line-c-solution",
                "content": "# Intuition\\nThere is this formula to calculate angles between hands of the clock.\\nAngles between the hands of the clock=30H-11/2*M.\\nUse this formula in the code.\\n\\n# Approach\\n1) Calculate the value of the angle using the formula. Make sure to include decimal points.\\n\\n2) Next, check if its negative (since, angle cannot be negative).\\n3) If it is negative multiply the angle by -1.\\n\\n4) Now calculate the minimum of the angle and its reflex angle (since, the minimum is considered as the angle of the clock)\\nReturn this answer;\\n\\n5) Use sample test cases to get this logic intuitively.\\n\\n# Complexity\\n- Time complexity:\\n0(1)\\n\\n- Space complexity:\\n0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double d=30*hour-(11.0/2.0)*minutes;\\n        if(d<0)\\n        d*=-1;\\n        return min(d,360-d);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double d=30*hour-(11.0/2.0)*minutes;\\n        if(d<0)\\n        d*=-1;\\n        return min(d,360-d);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908900,
                "title": "have-a-look",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        double h=hour*30 + minutes*0.5;\\n        double m=hour*0 + minutes*6;\\n        \\n        double alpha=abs(h-m);\\n        \\n        return min(alpha,360-alpha);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        double h=hour*30 + minutes*0.5;\\n        double m=hour*0 + minutes*6;\\n        \\n        double alpha=abs(h-m);\\n        \\n        return min(alpha,360-alpha);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881205,
                "title": "one-line-solution-with-explanation",
                "content": "# Approach\\n```\\nminHandDegrees = 360 * minutes/60\\nhourComponent = 360 * hour/12\\nminuteComponent = 360 * 1/12 * minutes/60\\nhourHandDegrees = hourComponent + minuteComponent\\n```\\n\\nIf ```abs(hourHandDegrees - minHandDegrees) > 180``` then min angle is ```360 - abs(hourDeg - minDeg)```.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$.\\n\\n- Space complexity: $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        return min(d := abs(30*hour - 5.5*minutes), 360 - d)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nminHandDegrees = 360 * minutes/60\\nhourComponent = 360 * hour/12\\nminuteComponent = 360 * 1/12 * minutes/60\\nhourHandDegrees = hourComponent + minuteComponent\\n```\n```abs(hourHandDegrees - minHandDegrees) > 180```\n```360 - abs(hourDeg - minDeg)```\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        return min(d := abs(30*hour - 5.5*minutes), 360 - d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867306,
                "title": "python-beginner-friendly-solution",
                "content": "# Intuition\\nUse Maths and describe angle at hour hand\\n\\n# Approach\\nFind how much hour hand will move in certain minutes, make a list of all the degree when hour hand is at hours like 1:00 , 2:00, find degree of minute hand. Find absolute value of hour angle - minute angle if it is greater than 180 return 360 - angle.\\nUpvote if you like the solution\\n\\n# Code\\n```\\nclass Solution(object):\\n    def angleClock(self, hour, minutes):\\n        \"\"\"\\n        :type hour: int\\n        :type minutes: int\\n        :rtype: float\\n        \"\"\"\\n        degree = 30*float(minutes)/60\\n        anh = [30,60,90,120,150,180,210,240,270,300,330,0]\\n        deg = 6*minutes\\n        print(anh[hour-1] , deg , degree)\\n        angle = abs(anh[hour-1] - deg + degree)\\n        if angle > 180:\\n            return 360 - angle\\n        return angle\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def angleClock(self, hour, minutes):\\n        \"\"\"\\n        :type hour: int\\n        :type minutes: int\\n        :rtype: float\\n        \"\"\"\\n        degree = 30*float(minutes)/60\\n        anh = [30,60,90,120,150,180,210,240,270,300,330,0]\\n        deg = 6*minutes\\n        print(anh[hour-1] , deg , degree)\\n        angle = abs(anh[hour-1] - deg + degree)\\n        if angle > 180:\\n            return 360 - angle\\n        return angle\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564980,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            },
            {
                "id": 1574050,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            },
            {
                "id": 1574514,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            },
            {
                "id": 2039881,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            },
            {
                "id": 1969160,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            },
            {
                "id": 1882191,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            },
            {
                "id": 1730514,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            },
            {
                "id": 1724523,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            },
            {
                "id": 1707148,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            }
        ]
    },
    {
        "title": "Jump Game IV",
        "question_content": "<p>Given an array of&nbsp;integers <code>arr</code>, you are initially positioned at the first index of the array.</p>\n\n<p>In one step you can jump from index <code>i</code> to index:</p>\n\n<ul>\n\t<li><code>i + 1</code> where:&nbsp;<code>i + 1 &lt; arr.length</code>.</li>\n\t<li><code>i - 1</code> where:&nbsp;<code>i - 1 &gt;= 0</code>.</li>\n\t<li><code>j</code> where: <code>arr[i] == arr[j]</code> and <code>i != j</code>.</li>\n</ul>\n\n<p>Return <em>the minimum number of steps</em> to reach the <strong>last index</strong> of the array.</p>\n\n<p>Notice that you can not jump outside of the array at any time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [100,-23,-23,404,100,23,23,23,3,404]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> You need three jumps from index 0 --&gt; 4 --&gt; 3 --&gt; 9. Note that index 9 is the last index of the array.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [7]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Start index is the last index. You do not need to jump.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [7,6,9,6,9,6,9,7]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> You can jump directly from index 0 to index 7 which is last index of the array.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>8</sup> &lt;= arr[i] &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1690813,
                "title": "best-explanation-ever-possible-for-this-question",
                "content": "Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F\\n\\n**So Ladies n Gentlemen without any further due let\\'s start,**\\n```\\nLet\\'s understood with an example - [100,-23,-23,404,100,23,23,23,3,404] and using this example we create a map. \\nWhere Key is the number present and the value as an the index in which it is present. \\nSo, we would get something like this:\\n```\\n![image](https://assets.leetcode.com/users/images/262653d1-38ec-4dd0-8671-d71b6bf8892b_1642214744.1664274.png)\\n\\n\\nAs we see the key is **100** and value part **0,4** which would give us the **indexes** where this **value** is found. So, that whenever we want to jump we can found at **4 index** also we have **100** we can **jump directly** on that apart from going to **i + 1, i - 1**. So, now with that will take a **queue**, where we will going to store the element that we are going to process at each step. \\nSince we are **positioned at index 0** will **add 0** in the **queue** and the steps would be **0** as we have not taken any of these steps till now. Now from here we can go to different places.\\n\\n![image](https://assets.leetcode.com/users/images/8c3fd5c3-0490-45e8-80d1-555ca905f1ef_1642215457.224442.png)\\n\\nTo state all the possible jumps at each step. I had **marked a vertical line** in the **queue**. So, **starting is 0** from here we can jump to some other steps. \\nSo, now in the first step we can jump to `idx - 1, idx + 1 or values in map`. Which gives us **-1, 1** & the value in map **0, 4**. In this one **0** is **current index** and **4th** one is this **100**.\\n\\n![image](https://assets.leetcode.com/users/images/53996ad6-d5e1-4077-a443-06e07fb508a7_1642216339.8178186.png)\\n\\nFrom these **-1 & 0** are not reachable & we can just reach to **1 & 4**. We put these in the **queue**. And that line mark the end of the position we can reach in **1st step**. Now we had already process the **100** we will **removing** from the **map**. So, that we do not process this again, there will be cases where we can get a **tle** if we keep the processes index in map for **example** if all these are **100**. We\\'ll keep on processing the **i - 1 i + 1 i - 1 i + 1** and every other index **multiple** no of times and we\\'ll get a **tle**. So, for that reason we are just **removing** from our **map**.\\n\\nNow, in this we know that in the first step we can reach to **1 & 4**. So, in the **next step** where can we reach. So we will be **popping** the element out of **queue and calculating jumps** from that particular index.\\nSo, for that since we are calculating **2nd step**. We do `step = step + 1` and we find the step from the 1st index which is **-23** : **we can go to 0 or 2 or 1 but 0 & 1 are not reachable**. So, we will add **2** in the **queue**.\\n\\n![image](https://assets.leetcode.com/users/images/aa94f3db-e4b5-4c89-97f2-b4076f4443ed_1642218629.943465.png)\\n\\n\\nNow we will again **remove -23 from our Map**.\\nNext we will go to **4th index**. So, from **4th index** we can go to **-1, +1** & we could have also gone to **index 0** but since **100** is not **present** in **map**. We couldn\\'t be going to 100 or 0 sice it is already remove from the map. So here will add **5 & 3 in our queue**. Now we have already got places where we can jump in **2**. We are finding where will be ending up in **step 3**. Will do a `step++` and start processing our indexes.\\n\\n**From 2 we can reach to 3**. So, we **add 3**. But from **5 we can reach to 6 & 7** so we add these two. And from **3 we can reach to 9**. Now here we can see **9 is indeed our last index**. So, here we will be `returning 3`.\\nWhich is minimum step we would be needed to reach the index 9 or last index. So, we return 3.\\n\\n![image](https://assets.leetcode.com/users/images/04238d68-3276-4a69-acc6-750a05c43a73_1642218510.5799263.png)\\n\\n**Now let\\'s code it up** \\n\\n*code each line explained*\\n\\n* Step 1 :\\n```\\n{\\n        // creating variable\\n        int n = arr.length;\\n        if(n == 1) return 0; // base case\\n        \\n        // craeted map holding integer & list\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int step = 0; // intial step is 0\\n        \\n        // Our 1st job is \"fill the map\"\\n        for(int i = 0; i < n; i++){\\n            // so, using this function it will check is arr[i] is present or not, if it\\'s not present it would create a new arraylist\\n            // and if it\\'s already present we will add index in it\\n            map.computeIfAbsent(arr[i], v -> new ArrayList()).add(i);\\n        }\\n```\\n\\n* Step 2 :\\n```\\n// next we need a queue.\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);// in queue we will add our 1st index which is 0;\\n        \\n        while(!q.isEmpty()){ // looping until queue is not empty\\n            step++; // incrementing our step\\n            int size = q.size(); // taking queue size\\n            for(int i = 0; i < size; i++){ // now for each element in this queue for this particulart size running a loop\\n                // so, here we will perform 3 steps\\n                int j = q.poll(); // getting element from queue\\n                \\n                // Jump to j - 1\\n                if(j - 1 >= 0 && map.containsKey(arr[j - 1])){\\n                    q.offer(j - 1);\\n                }\\n                \\n                // Jump to j + 1\\n                if(j + 1 < n && map.containsKey(arr[j + 1])){\\n                    // there could be 2 conditions\\n                    if(j + 1 == n - 1) return step; // if j+1 is equals to last element\\n                    q.offer(j + 1); // otherwise add in queue\\n                }\\n                \\n                // Jump to k --> arr[j] == arr[k]\\n                if(map.containsKey(arr[j])){ // if this particular element hasn\\'t processed\\n                    for(int k : map.get(arr[j])){ // so, we will iterate over each k\\n                        if(k != j){ // in this we first check if they are not equal, positions are not same\\n                            if(k == n - 1) return step;\\n                            q.offer(k);\\n                        }\\n                    }\\n                }\\n                map.remove(arr[j]); // removing from map\\n            }\\n        }\\n```\\n\\n* Final Step :\\n```\\nreturn step;\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        \\n        if(n == 1) return 0;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int step = 0;\\n        \\n        // fill the map\\n        for(int i = 0; i < n; i++){\\n            map.computeIfAbsent(arr[i], v -> new ArrayList()).add(i);\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        \\n        while(!q.isEmpty()){\\n            step++;\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                int j = q.poll();\\n            \\n                if(j - 1 >= 0 && map.containsKey(arr[j - 1])){\\n                    q.offer(j - 1);\\n                }\\n\\n                if(j + 1 < n && map.containsKey(arr[j + 1])){\\n                    if(j + 1 == n - 1) return step;\\n                    q.offer(j + 1);\\n                }\\n\\n                if(map.containsKey(arr[j])){\\n                    for(int k : map.get(arr[j])){\\n                        if(k != j){\\n                            if(k == n - 1) return step;\\n                            q.offer(k);\\n                        }\\n                    }\\n                }\\n                map.remove(arr[j]);\\n            }\\n        }\\n        \\n        return step;\\n    }\\n}\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)\\n\\nIf you have some \\uD83E\\uDD14 doubts feel free to bug me anytime or If you understood than don\\'t forget to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nLet\\'s understood with an example - [100,-23,-23,404,100,23,23,23,3,404] and using this example we create a map. \\nWhere Key is the number present and the value as an the index in which it is present. \\nSo, we would get something like this:\\n```\n```\\n{\\n        // creating variable\\n        int n = arr.length;\\n        if(n == 1) return 0; // base case\\n        \\n        // craeted map holding integer & list\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int step = 0; // intial step is 0\\n        \\n        // Our 1st job is \"fill the map\"\\n        for(int i = 0; i < n; i++){\\n            // so, using this function it will check is arr[i] is present or not, if it\\'s not present it would create a new arraylist\\n            // and if it\\'s already present we will add index in it\\n            map.computeIfAbsent(arr[i], v -> new ArrayList()).add(i);\\n        }\\n```\n```\\n// next we need a queue.\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);// in queue we will add our 1st index which is 0;\\n        \\n        while(!q.isEmpty()){ // looping until queue is not empty\\n            step++; // incrementing our step\\n            int size = q.size(); // taking queue size\\n            for(int i = 0; i < size; i++){ // now for each element in this queue for this particulart size running a loop\\n                // so, here we will perform 3 steps\\n                int j = q.poll(); // getting element from queue\\n                \\n                // Jump to j - 1\\n                if(j - 1 >= 0 && map.containsKey(arr[j - 1])){\\n                    q.offer(j - 1);\\n                }\\n                \\n                // Jump to j + 1\\n                if(j + 1 < n && map.containsKey(arr[j + 1])){\\n                    // there could be 2 conditions\\n                    if(j + 1 == n - 1) return step; // if j+1 is equals to last element\\n                    q.offer(j + 1); // otherwise add in queue\\n                }\\n                \\n                // Jump to k --> arr[j] == arr[k]\\n                if(map.containsKey(arr[j])){ // if this particular element hasn\\'t processed\\n                    for(int k : map.get(arr[j])){ // so, we will iterate over each k\\n                        if(k != j){ // in this we first check if they are not equal, positions are not same\\n                            if(k == n - 1) return step;\\n                            q.offer(k);\\n                        }\\n                    }\\n                }\\n                map.remove(arr[j]); // removing from map\\n            }\\n        }\\n```\n```\\nreturn step;\\n```\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        \\n        if(n == 1) return 0;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int step = 0;\\n        \\n        // fill the map\\n        for(int i = 0; i < n; i++){\\n            map.computeIfAbsent(arr[i], v -> new ArrayList()).add(i);\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        \\n        while(!q.isEmpty()){\\n            step++;\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                int j = q.poll();\\n            \\n                if(j - 1 >= 0 && map.containsKey(arr[j - 1])){\\n                    q.offer(j - 1);\\n                }\\n\\n                if(j + 1 < n && map.containsKey(arr[j + 1])){\\n                    if(j + 1 == n - 1) return step;\\n                    q.offer(j + 1);\\n                }\\n\\n                if(map.containsKey(arr[j])){\\n                    for(int k : map.get(arr[j])){\\n                        if(k != j){\\n                            if(k == n - 1) return step;\\n                            q.offer(k);\\n                        }\\n                    }\\n                }\\n                map.remove(arr[j]);\\n            }\\n        }\\n        \\n        return step;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502699,
                "title": "java-c-bfs-solution-clean-code-o-n",
                "content": "**Java**\\n```java\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        HashMap<Integer, List<Integer>> indicesOfValue = new HashMap<>();\\n        for (int i = 0; i < n; i++)\\n            indicesOfValue.computeIfAbsent(arr[i], x -> new LinkedList<>()).add(i);\\n        boolean[] visited = new boolean[n]; visited[0] = true;\\n        Queue<Integer> q = new LinkedList<>(); q.offer(0);\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            for (int size = q.size(); size > 0; --size) {\\n                int i = q.poll();\\n                if (i == n - 1) return step; // Reached to last index\\n                List<Integer> next = indicesOfValue.get(arr[i]);\\n                next.add(i - 1); next.add(i + 1);\\n                for (int j : next) {\\n                    if (j >= 0 && j < n && !visited[j]) {\\n                        visited[j] = true;\\n                        q.offer(j);\\n                    }\\n                }\\n                next.clear(); // avoid later lookup indicesOfValue arr[i]\\n            }\\n            step++;\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n**C++**\\n```C++\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> indicesOfValue;\\n        for (int i = 0; i < n; i++)\\n            indicesOfValue[arr[i]].push_back(i);\\n        vector<bool> visited(n); visited[0] = true;\\n        queue<int> q; q.push(0);\\n        int step = 0;\\n        while (!q.empty()) {\\n            for (int size = q.size(); size > 0; --size) {\\n                int i = q.front(); q.pop();\\n                if (i == n - 1) return step; // Reached to last index\\n                vector<int>& next = indicesOfValue[arr[i]];\\n                next.push_back(i - 1); next.push_back(i + 1);\\n                for (int j : next) {\\n                    if (j >= 0 && j < n && !visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                next.clear(); // avoid later lookup indicesOfValue arr[i]\\n            }\\n            step++;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n**Complexity**\\n- Time & Space: `O(N)`\\n\\n**Expain Time O(N):** In the case where each index has the same value, the algorithm goes to the neighbor (the same value) once then breaks all the edge by using: `next.clear()`\\nSo the algorithm will traverse up to `N` edges for `j` and `2N` edges for `(i+1, i-1)`.\\nThat\\'s why time complexity is `O(3N)` ~ `O(N)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        HashMap<Integer, List<Integer>> indicesOfValue = new HashMap<>();\\n        for (int i = 0; i < n; i++)\\n            indicesOfValue.computeIfAbsent(arr[i], x -> new LinkedList<>()).add(i);\\n        boolean[] visited = new boolean[n]; visited[0] = true;\\n        Queue<Integer> q = new LinkedList<>(); q.offer(0);\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            for (int size = q.size(); size > 0; --size) {\\n                int i = q.poll();\\n                if (i == n - 1) return step; // Reached to last index\\n                List<Integer> next = indicesOfValue.get(arr[i]);\\n                next.add(i - 1); next.add(i + 1);\\n                for (int j : next) {\\n                    if (j >= 0 && j < n && !visited[j]) {\\n                        visited[j] = true;\\n                        q.offer(j);\\n                    }\\n                }\\n                next.clear(); // avoid later lookup indicesOfValue arr[i]\\n            }\\n            step++;\\n        }\\n        return 0;\\n    }\\n}\\n```\n```C++\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> indicesOfValue;\\n        for (int i = 0; i < n; i++)\\n            indicesOfValue[arr[i]].push_back(i);\\n        vector<bool> visited(n); visited[0] = true;\\n        queue<int> q; q.push(0);\\n        int step = 0;\\n        while (!q.empty()) {\\n            for (int size = q.size(); size > 0; --size) {\\n                int i = q.front(); q.pop();\\n                if (i == n - 1) return step; // Reached to last index\\n                vector<int>& next = indicesOfValue[arr[i]];\\n                next.push_back(i - 1); next.push_back(i + 1);\\n                for (int j : next) {\\n                    if (j >= 0 && j < n && !visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                next.clear(); // avoid later lookup indicesOfValue arr[i]\\n            }\\n            step++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316467,
                "title": "jump-game-iv-why-dfs-will-not-work-explained",
                "content": "This problem has same issue using on using dfs as in problem [Open the Lock](https://leetcode.com/problems/open-the-lock/) \\nYou may find its editorial [here](https://leetcode.com/problems/open-the-lock/discuss/1253043/open-the-lock-why-dfs-or-recursion-traversal-will-not-work-explainition)\\n\\n### **Explanation** :\\n\\nAs asked in ques , we try to use recursion and travel all possible direction (i+1, i-1, a[i]==a[j] & i != j)\\n\\nRecursion :\\nWe start with simple recursion. And it goes like this:\\n```\\nunordered_map<int, vector<int>> mp;\\n    vector<bool> visit;\\n    int rec(vector<int>& arr, int start, vector<bool>& visit){\\n        if(start <0 || start > arr.size()-1) return 1000000; //out of range \\n        if(visit[start]==true) return 1000000; //already wisited in a node\\n        if(start == arr.size()-1) return 0; //base case when we reach the last index\\n        int step = 1000000; \\n        visit[start]=true; //marking as visited \\n        step = min(step, 1+rec(arr, start+1, visit));  //recurse on i+1\\n        step = min(step, 1+rec(arr, start-1, visit));  //recurse on i-1\\n        for(int i =0;i<mp[arr[start]].size(); i++){   //recurse on a[i]==a[j] & i!=j\\n          if(mp[arr[start]][i] != start)  step = min(step, 1+ rec(arr, mp[arr[start]][i], visit));   \\n        }\\n        visit[start] = false;  //unmarking as visited when done\\n        return step; \\n     }\\n    \\n    int minJumps(vector<int>& arr) {\\n        visit.resize(arr.size(), false);\\n        for(int i =0; i<arr.size(); i++){\\n            mp[arr[i]].push_back(i);  //use array to store a[i]==a[j]\\n        }\\n        return rec(arr, 0, visit);\\n        \\n    }\\n```\\n\\n1. Brute-force : So here we try all nodes that are possible to be jumped. Also, we are using visited array but we are unmarking the node as unvisited after it has been traverse in a path. This is done so that if we we dont unmark it, and we traverse a longer path before, then on traversing a relatively shorter path having any common node , will break the dfs traversal. This is called backtracking. Where we are undoing what was done.\\n\\nThis solves our one problem of not marking any node which as visited if it could be used in any other path too. **When a node is common in multiple paths, we mark and then unmark it visited.**\\n\\n2. Using DP : Next, this solution give us correct answer, but computes path which are common in various paths. There re-computation is involved. To solve this, we can think of memoization (dp), to store the computed paths.\\n\\nAlthough, this seems at first like it would work, but think of the where we traversed a path via  node x. Lets, dp[x] will store the min path from x to last index. Then when we are done with this path, we backtrack and release node x. Then, we might have some path via node x, which follows another path form node x to last index and is actually shorter, but because we have already stored some value in dp[x], we get wrong value.\\n\\nExplained in below fig:\\n[100,-23,-23,404,100,23,23,23,3,404]\\n\\n![image](https://assets.leetcode.com/users/images/cfdbd13a-0505-47c5-956b-22fda8677df8_1625434352.598207.png)\\n\\n\\nYellow path -> correct ans\\nRed path -> path 1 , that we traversed first\\nblack path -> path 2 , traversed next\\nHere, we traversed node node 4 (arr[4] = 100) in red path first, and we get the value of path from node 4 to last node 9 as dp[4] = 4. (From node 4 , node 3 is already marked visited, so node 4 has just this path of length 4 )\\nNext we traversed path black, and node 4 has already value stored dp[4] = 4 , so our min path is not correctly calculated.\\nTherefore, there are multiple paths to reach last index from node 4, and also to reach node 4 , therefore, the dp[4] may not be the minimum value;\\n\\n\\n### **Conclusion** :\\n\\nSo, we tried solving below problems:\\n1.) **Multiple paths with common node** : Used backtracking to mark and unmark the node.\\n\\t\\tIts a bruteforce, will give TLE.\\n2.) **Multiple paths from node x to last index** : Used dp[x] to store computed value for a node x in a path. Will not work, as stored value may not be the min value. WA\\n\\nHence, Dfs will not work. as we have end up tracking multiple paths from that stop and considering the minimum. As commented by [@iamninja in solution comments section](https://leetcode.com/problems/jump-game-iv/solution/765888) : \\n**Due to duplicates relation problem becomes a graph with cycles and you needs to find a shortest path.**\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nunordered_map<int, vector<int>> mp;\\n    vector<bool> visit;\\n    int rec(vector<int>& arr, int start, vector<bool>& visit){\\n        if(start <0 || start > arr.size()-1) return 1000000; //out of range \\n        if(visit[start]==true) return 1000000; //already wisited in a node\\n        if(start == arr.size()-1) return 0; //base case when we reach the last index\\n        int step = 1000000; \\n        visit[start]=true; //marking as visited \\n        step = min(step, 1+rec(arr, start+1, visit));  //recurse on i+1\\n        step = min(step, 1+rec(arr, start-1, visit));  //recurse on i-1\\n        for(int i =0;i<mp[arr[start]].size(); i++){   //recurse on a[i]==a[j] & i!=j\\n          if(mp[arr[start]][i] != start)  step = min(step, 1+ rec(arr, mp[arr[start]][i], visit));   \\n        }\\n        visit[start] = false;  //unmarking as visited when done\\n        return step; \\n     }\\n    \\n    int minJumps(vector<int>& arr) {\\n        visit.resize(arr.size(), false);\\n        for(int i =0; i<arr.size(); i++){\\n            mp[arr[i]].push_back(i);  //use array to store a[i]==a[j]\\n        }\\n        return rec(arr, 0, visit);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 988714,
                "title": "python-bfs-with-small-trick-explained",
                "content": "In this problem we are asked to find shortest path between two nodes in some graph, so the first idea you should think is bfs (or Dijkstra algorithm). Actually, bfs is almost sufficient here, but we need to do one optimization which increase our speed dramatically.\\n\\n1. Let us use `d`: defaultdict, where for each value we keep list of all possible indexes for this value. We need this to make fast steps of type 3.\\n2. Let `visited` be as usual set of visited nodes, we need it in usual bfs, not to visit any node two times.\\n3. Let `visited_groups` be set of visited **values**: we need it for the following reason. Imagine, we have `arr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 2]`. Then first time we see `1`, we visit all other `1`. Second time we see `1`, we do not need to check its neibors of type `3`, we already know that we visited them. Without this optimization time complexity can be potentially `O(n^2)`.\\n4. What we do next is classical **bfs**: we extract node from queue, visit two neibors of types `1` and `2` and if we did not visit value of this node yet, we visit its all neibors of type `3`.\\n\\n**Complexity**: time complexity is `O(n)`: we visit every index only once and try to visit every node no more than `3` times: for each type of neighbors. Space complexity is `O(n)` as well: to keep `visited` and `visited_groups` sets.\\n\\n```\\nclass Solution:\\n    def minJumps(self, arr):\\n        n = len(arr)\\n        d = defaultdict(list)\\n        for i, num in enumerate(arr):\\n            d[num].append(i)\\n            \\n        queue = deque([(0, 0)])\\n        visited, visited_groups = set(), set()\\n        \\n        while queue:\\n            steps, index = queue.popleft()\\n            if index == n - 1: return steps\\n            \\n            for neib in [index - 1, index + 1]:\\n                if 0 <= neib < n and neib not in visited:\\n                    visited.add(neib)\\n                    queue.append((steps + 1, neib))\\n            \\n            if arr[index] not in visited_groups:\\n                for neib in d[arr[index]]:\\n                    if neib not in visited:\\n                        visited.add(neib)\\n                        queue.append((steps + 1, neib))\\n                visited_groups.add(arr[index])\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr):\\n        n = len(arr)\\n        d = defaultdict(list)\\n        for i, num in enumerate(arr):\\n            d[num].append(i)\\n            \\n        queue = deque([(0, 0)])\\n        visited, visited_groups = set(), set()\\n        \\n        while queue:\\n            steps, index = queue.popleft()\\n            if index == n - 1: return steps\\n            \\n            for neib in [index - 1, index + 1]:\\n                if 0 <= neib < n and neib not in visited:\\n                    visited.add(neib)\\n                    queue.append((steps + 1, neib))\\n            \\n            if arr[index] not in visited_groups:\\n                for neib in d[arr[index]]:\\n                    if neib not in visited:\\n                        visited.add(neib)\\n                        queue.append((steps + 1, neib))\\n                visited_groups.add(arr[index])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257792,
                "title": "c-simple-bfs-reason-to-clear-the-map-explained-with-image",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>>mp;\\n        for (int i = 0; i < n; i++) mp[arr[i]].push_back(i);\\n        \\n        queue<int>q;\\n        vector<bool>visited(n, false);\\n        q.push(0);\\n        int steps = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                int currIdx = q.front();\\n                q.pop();\\n                if (currIdx == n - 1) return steps;\\n                //================================================================\\n                //EXPLORE ALL POSSIBLE OPTIONS\\n                if (currIdx + 1 < n && !visited[currIdx + 1])  //OPTION-1 (Move Forward)\\n                {\\n                    visited[currIdx + 1] = true;\\n                    q.push(currIdx + 1);\\n                }\\n                if (currIdx - 1 >= 0 && !visited[currIdx - 1]) //OPTION-2 (Move Backward)\\n                {\\n                    visited[currIdx - 1] = true;\\n                    q.push(currIdx - 1);\\n                }\\n                for (int newIdx : mp[arr[currIdx]])  //OPTION-3 (Move to same valued idx)\\n                {                                 //newIdx coud be before currIdx or after currIdx\\n                    if (!visited[newIdx]) \\n                    {\\n                        visited[newIdx] = true;\\n                        q.push(newIdx);\\n                    }\\n                }\\n                //===================================================================\\n                mp[arr[currIdx]].clear();    //EXPLAINED BELOW :)\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Why to clear the map when you already marked \"visited = true\"?????**\\n#**\"Visited = true\", will work completely fine** to prevent visiting any index that is \\n (already explored) or (waiting in the queue to be explored)\\n#So whenever we iterate the \"map\" of similar valued indexes we can check whether the \\n index is visited. If visited it will not consider that path.\\n\\n//========================================================================\\n#**But there is one problem of time constraint** with the traditional approach\\n#**There could be a large number of indexes with same value**\\n#So after the first index for a value is encountered we add all the occurances of that value in the queue\\n**and mark those indexes as visited**\\n#When we encounter that similar valued index (after popping from queue) then we\\n again iterate over all those redundant indexes and \\n **every time the condition \"visited = true\" becomes true** and we just iterate those \\n large number of indexes for no reason \\n#So we can prevent this redundant iteration just by \"**CLEARING THE MAP FOR ALREADY VISITED VALUES**\"\\n\\nSo \\n**OPTION-1 => Iterate all already visited indexes, visited becomes true, exit the loop, no harm done\\nOPTION-2 => Clear the map -> Don\\'t even iterate the already visited indexes, no harm done :)  <== USE THIS ONE**\\n\\n![image](https://assets.leetcode.com/users/images/c069416b-711b-4768-b897-ea8a34750642_1677988681.620403.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>>mp;\\n        for (int i = 0; i < n; i++) mp[arr[i]].push_back(i);\\n        \\n        queue<int>q;\\n        vector<bool>visited(n, false);\\n        q.push(0);\\n        int steps = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                int currIdx = q.front();\\n                q.pop();\\n                if (currIdx == n - 1) return steps;\\n                //================================================================\\n                //EXPLORE ALL POSSIBLE OPTIONS\\n                if (currIdx + 1 < n && !visited[currIdx + 1])  //OPTION-1 (Move Forward)\\n                {\\n                    visited[currIdx + 1] = true;\\n                    q.push(currIdx + 1);\\n                }\\n                if (currIdx - 1 >= 0 && !visited[currIdx - 1]) //OPTION-2 (Move Backward)\\n                {\\n                    visited[currIdx - 1] = true;\\n                    q.push(currIdx - 1);\\n                }\\n                for (int newIdx : mp[arr[currIdx]])  //OPTION-3 (Move to same valued idx)\\n                {                                 //newIdx coud be before currIdx or after currIdx\\n                    if (!visited[newIdx]) \\n                    {\\n                        visited[newIdx] = true;\\n                        q.push(newIdx);\\n                    }\\n                }\\n                //===================================================================\\n                mp[arr[currIdx]].clear();    //EXPLAINED BELOW :)\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257895,
                "title": "java-easy-bfs",
                "content": "**We can use a BFS (breadth first search) approach to find the minimum number of steps to reach the last index. Starting from the first index, we can visit all the neighbouring indices and add them to a queue. We can then repeat this process for all the indices in the queue until we reach the last index. To efficiently find the neighboring indices, we can use an HashMap to store the indices of each value in the List. This allows us to easily find the neighbouring indices of a given index using the values at that index. We can mark the visited indices to avoid visiting them again and keep track of the number of steps taken to reach each index. Once we reach the last index, we can return the number of steps taken to reach it. If we cannot reach the last index, we can return -1 to indicate that it is not possible to reach the last index.\\nExplanation credits :- https://leetcode.com/singhabhinash/\\nLink of explanation :- https://leetcode.com/problems/jump-game-iv/discuss/3257846/Day-64-oror-BFS-oror-O(n)-time-and-O(n)-space-oror-Easiest-Beginner-Friendly-Sol**\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int steps=0;\\n        int  n=arr.length;\\n        HashMap<Integer,List<Integer>> hm=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(!hm.containsKey(arr[i])){\\n                List<Integer> temp =new ArrayList<>();\\n                temp.add(i);\\n                hm.put(arr[i],temp);\\n            }\\n            else{\\n                List<Integer> temp=hm.get(arr[i]);\\n                temp.add(i);\\n                hm.put(arr[i],temp);\\n            }\\n        }\\n        boolean vis[]=new boolean[n];\\n        vis[0]=true;\\n        Queue<Integer> qu=new LinkedList<>();\\n        qu.add(0);\\n        while(!qu.isEmpty()){\\n            int size=qu.size();\\n            for(int i=0;i<size;i++){\\n                int curridx=qu.poll();\\n                if(curridx==n-1)\\n                    return steps;\\n                List<Integer> jumptoindexes=hm.get(arr[curridx]);\\n                jumptoindexes.add(curridx+1);\\n                jumptoindexes.add(curridx-1);\\n                for(int q:jumptoindexes){\\n                    if(q>=0 && q<n && !vis[q]){\\n                        vis[q]=true;\\n                        qu.add(q);\\n                    }\\n                }\\n                jumptoindexes.clear();\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/28b6d959-485e-4322-820e-f53989be39f8_1677982432.0934901.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int steps=0;\\n        int  n=arr.length;\\n        HashMap<Integer,List<Integer>> hm=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(!hm.containsKey(arr[i])){\\n                List<Integer> temp =new ArrayList<>();\\n                temp.add(i);\\n                hm.put(arr[i],temp);\\n            }\\n            else{\\n                List<Integer> temp=hm.get(arr[i]);\\n                temp.add(i);\\n                hm.put(arr[i],temp);\\n            }\\n        }\\n        boolean vis[]=new boolean[n];\\n        vis[0]=true;\\n        Queue<Integer> qu=new LinkedList<>();\\n        qu.add(0);\\n        while(!qu.isEmpty()){\\n            int size=qu.size();\\n            for(int i=0;i<size;i++){\\n                int curridx=qu.poll();\\n                if(curridx==n-1)\\n                    return steps;\\n                List<Integer> jumptoindexes=hm.get(arr[curridx]);\\n                jumptoindexes.add(curridx+1);\\n                jumptoindexes.add(curridx-1);\\n                for(int q:jumptoindexes){\\n                    if(q>=0 && q<n && !vis[q]){\\n                        vis[q]=true;\\n                        qu.add(q);\\n                    }\\n                }\\n                jumptoindexes.clear();\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502711,
                "title": "python-simple-solution-with-explanations",
                "content": "**Idea**\\nStart from position 0. Use breadth first search until the last position is found. \\n\\n**Trick**\\n1. Track all the values we have explored. For a given value, we only add it to the frontier once\\n2. Track all the positions we have explored.\\n3. Python trick: `nei[num] * (num not in num_met)`\\n\\n**Complexity**\\nTime: `O(N)`\\nSpace: `O(N)`\\n\\n**Python 3**\\n```\\ndef minJumps(self, arr):\\n    nei = collections.defaultdict(list)\\n    _ = [nei[x].append(i) for i, x in enumerate(arr)]\\n\\n    frontier = collections.deque([(0,0)])\\n    num_met, pos_met = set(), set()\\n    while frontier:\\n        pos, step = frontier.popleft() # state: position, step\\n        if pos == len(arr) - 1: return step\\n        num = arr[pos]\\n        pos_met.add(pos) # track explored positions\\n\\n        for p in [pos - 1, pos + 1] + nei[num] * (num not in num_met):\\n            if p in pos_met or not 0 <= p < len(arr): continue\\n            frontier.append((p, step + 1))\\n\\n        num_met.add(num) # track explored values\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef minJumps(self, arr):\\n    nei = collections.defaultdict(list)\\n    _ = [nei[x].append(i) for i, x in enumerate(arr)]\\n\\n    frontier = collections.deque([(0,0)])\\n    num_met, pos_met = set(), set()\\n    while frontier:\\n        pos, step = frontier.popleft() # state: position, step\\n        if pos == len(arr) - 1: return step\\n        num = arr[pos]\\n        pos_met.add(pos) # track explored positions\\n\\n        for p in [pos - 1, pos + 1] + nei[num] * (num not in num_met):\\n            if p in pos_met or not 0 <= p < len(arr): continue\\n            frontier.append((p, step + 1))\\n\\n        num_met.add(num) # track explored values\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3257817,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start at the first index and try to reach the last index by taking jumps as given in the problem. If we can reach the last index in one of these jumps, we can return the number of jumps. However, we might need to take jumps to indices we have already visited before, so we need to keep track of visited indices to avoid infinite loops.\\n\\n# Approach\\n1. Create a dictionary to store the indices of each value in the array.\\n2. Use a queue to perform a breadth-first search of the indices.\\n3. For each index in the queue, add the indices corresponding to the adjacent values in the\\ndictionary and to the left and right of the current index.\\n4. If the last index is reached, return the number of jumps taken so far.\\n5. If the queue is emptied and the last index is not reached, return -1 to indicate that it is\\nnot possible to reach the last index.\\n\\n\\n# Complexity\\n- Time complexity: The worst-case time complexity is $$O(n)$$, where n is the length of the array. In the worst case, we might need to visit all the indices in the array to reach the last index.\\n\\n- Space complexity: The space complexity is also $$O(n)$$, where n is the length of the array. We need to store the dictionary, visited indices, and the queue. The size of the queue can be up\\nto n in the worst case.\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n# Code\\n\\n``` Java []\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        Map<Integer, List<Integer>> valueToIndex = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            valueToIndex.computeIfAbsent(arr[i], k -> new ArrayList<>()).add(i);\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        int steps = 0;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = queue.poll();\\n                if (curr == n - 1) {\\n                    return steps;\\n                }\\n                \\n                if (curr - 1 >= 0 && !visited[curr - 1]) {\\n                    visited[curr - 1] = true;\\n                    queue.offer(curr - 1);\\n                }\\n                \\n                if (curr + 1 < n && !visited[curr + 1]) {\\n                    visited[curr + 1] = true;\\n                    queue.offer(curr + 1);\\n                }\\n                \\n                for (int index : valueToIndex.getOrDefault(arr[curr], Collections.emptyList())) {\\n                    if (!visited[index]) {\\n                        visited[index] = true;\\n                        queue.offer(index);\\n                    }\\n                }\\n                \\n                // remove the indices with the same value to avoid revisiting them\\n                valueToIndex.remove(arr[curr]);\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        unordered_map<int, vector<int>> valueToIndex;\\n        for (int i = 0; i < n; i++) {\\n            valueToIndex[arr[i]].push_back(i);\\n        }\\n        \\n        vector<bool> visited(n, false);\\n        visited[0] = true;\\n        queue<int> q;\\n        q.push(0);\\n        int steps = 0;\\n        \\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = q.front();\\n                q.pop();\\n                if (curr == n - 1) {\\n                    return steps;\\n                }\\n                \\n                if (curr - 1 >= 0 && !visited[curr - 1]) {\\n                    visited[curr - 1] = true;\\n                    q.push(curr - 1);\\n                }\\n                \\n                if (curr + 1 < n && !visited[curr + 1]) {\\n                    visited[curr + 1] = true;\\n                    q.push(curr + 1);\\n                }\\n                \\n                for (int index : valueToIndex[arr[curr]]) {\\n                    if (!visited[index]) {\\n                        visited[index] = true;\\n                        q.push(index);\\n                    }\\n                }\\n                \\n                // remove the indices with the same value to avoid revisiting them\\n                valueToIndex.erase(arr[curr]);\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\\n``` Python []\\nclass Solution(object):\\n    def minJumps(self, arr):\\n        n = len(arr)\\n        if n == 1:\\n            return 0\\n        \\n        # Build a dictionary to store the positions of each value in the array\\n        positions = {}\\n        for i in range(n):\\n            if arr[i] not in positions:\\n                positions[arr[i]] = []\\n            positions[arr[i]].append(i)\\n        \\n        # BFS algorithm to find the minimum number of jumps\\n        visited = set()\\n        q = [(0, 0)]  # (position, jumps)\\n        while q:\\n            pos, jumps = q.pop(0)\\n            \\n            # Check if we\\'ve reached the end of the array\\n            if pos == n - 1:\\n                return jumps\\n            \\n            # Jump to adjacent indices\\n            for next_pos in [pos-1, pos+1]:\\n                if 0 <= next_pos < n and next_pos not in visited:\\n                    visited.add(next_pos)\\n                    q.append((next_pos, jumps+1))\\n            \\n            # Jump to indices with the same value\\n            if arr[pos] in positions:\\n                for next_pos in positions[arr[pos]]:\\n                    if next_pos not in visited:\\n                        visited.add(next_pos)\\n                        q.append((next_pos, jumps+1))\\n                \\n                # We don\\'t need to keep track of the positions anymore\\n                del positions[arr[pos]]\\n        \\n        return -1  # It\\'s not possible to reach the end of the array\\n\\n```\\n```\\nTable Representation of the iteration for given example\\nI hope you will like it \\uD83D\\uDE0A\\n----------------------------------------------------------------------\\nExample 1:\\n\\narr = [100,-23,-23,404,100,23,23,23,3,404]\\n\\ni  Current Value  Next Possible Values   Jumps\\n0  100            -23, 1, 4               1\\n1  -23            100, -23, 2, 3          2\\n3  404            4                       3\\n4  100            -23, 1, 3, 5, 9         4\\n5  23             100, 23, 6, 7, 8        4\\n6  23             100, 23, 5, 7, 8        4\\n7  23             100, 23, 5, 6, 8        4\\n8  23             100, 23, 5, 6, 7        4\\n9  3              404                     3\\n----------------------------------------------------------------------\\nExample 2:\\n\\narr = [7]\\n\\ni  Current Value  Next Possible Values   Jumps\\n0  7              None                     0\\n----------------------------------------------------------------------\\nExample 3:\\n\\narr = [7,6,9,6,9,6,9,7]\\ni  Current Value  Next Possible Values   Jumps\\n0  7              7, 1, 7                  1\\n1  6              9, 3, 7                  2\\n2  9              6, 4, 6, 7               2\\n4  9              6, 2, 6, 7               2\\n6  9              7, 5                     2\\n7  7              7, 0                     1\\n\\n\\n```\\n\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        Map<Integer, List<Integer>> valueToIndex = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            valueToIndex.computeIfAbsent(arr[i], k -> new ArrayList<>()).add(i);\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        int steps = 0;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = queue.poll();\\n                if (curr == n - 1) {\\n                    return steps;\\n                }\\n                \\n                if (curr - 1 >= 0 && !visited[curr - 1]) {\\n                    visited[curr - 1] = true;\\n                    queue.offer(curr - 1);\\n                }\\n                \\n                if (curr + 1 < n && !visited[curr + 1]) {\\n                    visited[curr + 1] = true;\\n                    queue.offer(curr + 1);\\n                }\\n                \\n                for (int index : valueToIndex.getOrDefault(arr[curr], Collections.emptyList())) {\\n                    if (!visited[index]) {\\n                        visited[index] = true;\\n                        queue.offer(index);\\n                    }\\n                }\\n                \\n                // remove the indices with the same value to avoid revisiting them\\n                valueToIndex.remove(arr[curr]);\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        unordered_map<int, vector<int>> valueToIndex;\\n        for (int i = 0; i < n; i++) {\\n            valueToIndex[arr[i]].push_back(i);\\n        }\\n        \\n        vector<bool> visited(n, false);\\n        visited[0] = true;\\n        queue<int> q;\\n        q.push(0);\\n        int steps = 0;\\n        \\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = q.front();\\n                q.pop();\\n                if (curr == n - 1) {\\n                    return steps;\\n                }\\n                \\n                if (curr - 1 >= 0 && !visited[curr - 1]) {\\n                    visited[curr - 1] = true;\\n                    q.push(curr - 1);\\n                }\\n                \\n                if (curr + 1 < n && !visited[curr + 1]) {\\n                    visited[curr + 1] = true;\\n                    q.push(curr + 1);\\n                }\\n                \\n                for (int index : valueToIndex[arr[curr]]) {\\n                    if (!visited[index]) {\\n                        visited[index] = true;\\n                        q.push(index);\\n                    }\\n                }\\n                \\n                // remove the indices with the same value to avoid revisiting them\\n                valueToIndex.erase(arr[curr]);\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\n``` Python []\\nclass Solution(object):\\n    def minJumps(self, arr):\\n        n = len(arr)\\n        if n == 1:\\n            return 0\\n        \\n        # Build a dictionary to store the positions of each value in the array\\n        positions = {}\\n        for i in range(n):\\n            if arr[i] not in positions:\\n                positions[arr[i]] = []\\n            positions[arr[i]].append(i)\\n        \\n        # BFS algorithm to find the minimum number of jumps\\n        visited = set()\\n        q = [(0, 0)]  # (position, jumps)\\n        while q:\\n            pos, jumps = q.pop(0)\\n            \\n            # Check if we\\'ve reached the end of the array\\n            if pos == n - 1:\\n                return jumps\\n            \\n            # Jump to adjacent indices\\n            for next_pos in [pos-1, pos+1]:\\n                if 0 <= next_pos < n and next_pos not in visited:\\n                    visited.add(next_pos)\\n                    q.append((next_pos, jumps+1))\\n            \\n            # Jump to indices with the same value\\n            if arr[pos] in positions:\\n                for next_pos in positions[arr[pos]]:\\n                    if next_pos not in visited:\\n                        visited.add(next_pos)\\n                        q.append((next_pos, jumps+1))\\n                \\n                # We don\\'t need to keep track of the positions anymore\\n                del positions[arr[pos]]\\n        \\n        return -1  # It\\'s not possible to reach the end of the array\\n\\n```\n```\\nTable Representation of the iteration for given example\\nI hope you will like it \\uD83D\\uDE0A\\n----------------------------------------------------------------------\\nExample 1:\\n\\narr = [100,-23,-23,404,100,23,23,23,3,404]\\n\\ni  Current Value  Next Possible Values   Jumps\\n0  100            -23, 1, 4               1\\n1  -23            100, -23, 2, 3          2\\n3  404            4                       3\\n4  100            -23, 1, 3, 5, 9         4\\n5  23             100, 23, 6, 7, 8        4\\n6  23             100, 23, 5, 7, 8        4\\n7  23             100, 23, 5, 6, 8        4\\n8  23             100, 23, 5, 6, 7        4\\n9  3              404                     3\\n----------------------------------------------------------------------\\nExample 2:\\n\\narr = [7]\\n\\ni  Current Value  Next Possible Values   Jumps\\n0  7              None                     0\\n----------------------------------------------------------------------\\nExample 3:\\n\\narr = [7,6,9,6,9,6,9,7]\\ni  Current Value  Next Possible Values   Jumps\\n0  7              7, 1, 7                  1\\n1  6              9, 3, 7                  2\\n2  9              6, 4, 6, 7               2\\n4  9              6, 2, 6, 7               2\\n6  9              7, 5                     2\\n7  7              7, 0                     1\\n\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509868,
                "title": "java-bfs",
                "content": "```\\npublic int minJumps(int[] arr) {\\n        if(arr.length<=1) {\\n            return 0;\\n        }\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i=0;i<arr.length;i++) {\\n            map.putIfAbsent(arr[i],new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        }\\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        visited.add(0);\\n        int count = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i=0;i<size;i++) {\\n                int pop = queue.poll();\\n                if(pop==arr.length-1) {\\n                    return count;\\n                }\\n                if(pop>0 && visited.add(pop-1)) {\\n                    queue.add(pop-1);\\n                }\\n                if(pop<arr.length-1 && visited.add(pop+1)) {\\n                    queue.add(pop+1);\\n                }\\n                if(map.containsKey(arr[pop])) {\\n                    for (int index : map.get(arr[pop])) {\\n                        if(visited.add(index)) {\\n                            queue.add(index);\\n                        }\\n                    }\\n                    map.remove(arr[pop]); // Since we have already taken all indexes into account, we don\\'t need to traverse them again.\\n                    // Consider example: [1,1,1,1,1,1,.....(5000 terms), 11] -> Answer =2;\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minJumps(int[] arr) {\\n        if(arr.length<=1) {\\n            return 0;\\n        }\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i=0;i<arr.length;i++) {\\n            map.putIfAbsent(arr[i],new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        }\\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        visited.add(0);\\n        int count = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i=0;i<size;i++) {\\n                int pop = queue.poll();\\n                if(pop==arr.length-1) {\\n                    return count;\\n                }\\n                if(pop>0 && visited.add(pop-1)) {\\n                    queue.add(pop-1);\\n                }\\n                if(pop<arr.length-1 && visited.add(pop+1)) {\\n                    queue.add(pop+1);\\n                }\\n                if(map.containsKey(arr[pop])) {\\n                    for (int index : map.get(arr[pop])) {\\n                        if(visited.add(index)) {\\n                            queue.add(index);\\n                        }\\n                    }\\n                    map.remove(arr[pop]); // Since we have already taken all indexes into account, we don\\'t need to traverse them again.\\n                    // Consider example: [1,1,1,1,1,1,.....(5000 terms), 11] -> Answer =2;\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1690840,
                "title": "python-bfs-o-n-100-faster-image-explanation",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n\\n![image](https://assets.leetcode.com/users/images/877c253f-58c4-4553-983e-5aa79b649b66_1642222089.0379643.png)\\n\\n\\n```\\nRuntime: 512 ms, faster than 100.00% of Python online submissions for Jump Game IV.\\nMemory Usage: 27.6 MB, less than 87.72% of Python online submissions for Jump Game IV.\\n```\\n\\n```\\nclass Solution(object):\\n    def minJumps(self, arr):\\n        if len(arr) == 1: return 0  # obviously\\n\\n        adj = defaultdict(list)\\n        for i, n in enumerate(arr):\\n            adj[n].append(i)\\n\\n        ans = [0] * len(arr)  # the return value is ans[0], once we find it, we can return immediately.\\n        dq = deque([len(arr) - 1])  # obviously, ans[-1] == 0, so we fill in ans from ans[-1] to ans[0] iteratively\\n\\n        while dq:\\n            i = dq.popleft()\\n\\n            # move forward if the next one has not seen before that is ans[i + 1] == 0\\n            # note that the ans[len(arr) - 1] is always 0, we should NOT update it, so i < len(arr) - 1\\n            if i < len(arr) - 2 and ans[i + 1] == 0:\\n                ans[i + 1] = ans[i] + 1\\n                dq.append(i + 1)\\n\\n            # move backward if the previous one has not seen before that is ans[i - 1] == 0\\n            if i > 0 and ans[i - 1] == 0:\\n                ans[i - 1] = ans[i] + 1\\n                if i - 1 == 0: return ans[0]\\n                dq.append(i - 1)\\n\\n            # move to j where arr[i] == arr[j]\\n            for j in adj[arr[i]]:\\n                if ans[j] == 0 and j < len(arr) - 1:\\n                    ans[j] = ans[i] + 1\\n                    if j == 0: return ans[0]\\n                    dq.append(j)\\n            adj.pop(arr[i])  # pop arr[i] from the adj, very very important to avoid double calculating\\n```\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nRuntime: 512 ms, faster than 100.00% of Python online submissions for Jump Game IV.\\nMemory Usage: 27.6 MB, less than 87.72% of Python online submissions for Jump Game IV.\\n```\n```\\nclass Solution(object):\\n    def minJumps(self, arr):\\n        if len(arr) == 1: return 0  # obviously\\n\\n        adj = defaultdict(list)\\n        for i, n in enumerate(arr):\\n            adj[n].append(i)\\n\\n        ans = [0] * len(arr)  # the return value is ans[0], once we find it, we can return immediately.\\n        dq = deque([len(arr) - 1])  # obviously, ans[-1] == 0, so we fill in ans from ans[-1] to ans[0] iteratively\\n\\n        while dq:\\n            i = dq.popleft()\\n\\n            # move forward if the next one has not seen before that is ans[i + 1] == 0\\n            # note that the ans[len(arr) - 1] is always 0, we should NOT update it, so i < len(arr) - 1\\n            if i < len(arr) - 2 and ans[i + 1] == 0:\\n                ans[i + 1] = ans[i] + 1\\n                dq.append(i + 1)\\n\\n            # move backward if the previous one has not seen before that is ans[i - 1] == 0\\n            if i > 0 and ans[i - 1] == 0:\\n                ans[i - 1] = ans[i] + 1\\n                if i - 1 == 0: return ans[0]\\n                dq.append(i - 1)\\n\\n            # move to j where arr[i] == arr[j]\\n            for j in adj[arr[i]]:\\n                if ans[j] == 0 and j < len(arr) - 1:\\n                    ans[j] = ans[i] + 1\\n                    if j == 0: return ans[0]\\n                    dq.append(j)\\n            adj.pop(arr[i])  # pop arr[i] from the adj, very very important to avoid double calculating\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712669,
                "title": "c-o-n-bfs-w-explanation",
                "content": "The idea is to find the underlying graph, where all edges  have same weight and indices represent nodes. There is an edge between the nodes corresponding to the surrounding indices and also the other indices which have the same value. Then this problem reduces to simple shortest path finding, which can be solved by any shortest path algorithm. Since the edge weights are unity, BFS will also suffice.\\n```\\nint minJumps(vector<int>& arr) \\n{\\n\\tunordered_map<int,vector<int>> adj;\\n    int n=arr.size();\\n    for(int i=0;i<n;++i)\\n    \\tif(adj.find(arr[i])==adj.end())\\n    \\t\\tadj[arr[i]]={i};\\n    \\telse adj[arr[i]].push_back(i);\\n    vector<int> grey(n,0);\\n    grey[0]=1;\\n    queue<pair<int,int>> q;\\n    q.push({0,0});\\n    int ret=INT_MAX;\\n    while(!q.empty())\\n    {\\n    \\tpair<int,int> temp=q.front();\\n        q.pop();\\n    \\tint u=temp.first;\\n    \\tint d=temp.second;\\n    \\tif(u==n-1)\\n    \\t\\treturn d;\\n    \\telse\\n    \\t{\\n    \\t\\tif(u>0&&!grey[u-1])\\n    \\t\\t{\\n    \\t\\t\\tq.push({u-1,d+1});\\n    \\t\\t\\tgrey[u-1]=1;\\n    \\t\\t}\\n    \\t\\tif(u+1<n&&!grey[u+1])\\n    \\t\\t{\\n    \\t\\t\\tq.push({u+1,d+1});\\n    \\t\\t\\tgrey[u+1]=1;\\n    \\t\\t}\\n    \\t\\tfor(int v:adj[arr[u]])\\n    \\t\\t\\tif(!grey[v])\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tq.push({v,d+1});\\n    \\t\\t\\t\\tgrey[v]=1;\\n    \\t\\t\\t}\\n            adj[arr[u]]={};\\n    \\t}\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nint minJumps(vector<int>& arr) \\n{\\n\\tunordered_map<int,vector<int>> adj;\\n    int n=arr.size();\\n    for(int i=0;i<n;++i)\\n    \\tif(adj.find(arr[i])==adj.end())\\n    \\t\\tadj[arr[i]]={i};\\n    \\telse adj[arr[i]].push_back(i);\\n    vector<int> grey(n,0);\\n    grey[0]=1;\\n    queue<pair<int,int>> q;\\n    q.push({0,0});\\n    int ret=INT_MAX;\\n    while(!q.empty())\\n    {\\n    \\tpair<int,int> temp=q.front();\\n        q.pop();\\n    \\tint u=temp.first;\\n    \\tint d=temp.second;\\n    \\tif(u==n-1)\\n    \\t\\treturn d;\\n    \\telse\\n    \\t{\\n    \\t\\tif(u>0&&!grey[u-1])\\n    \\t\\t{\\n    \\t\\t\\tq.push({u-1,d+1});\\n    \\t\\t\\tgrey[u-1]=1;\\n    \\t\\t}\\n    \\t\\tif(u+1<n&&!grey[u+1])\\n    \\t\\t{\\n    \\t\\t\\tq.push({u+1,d+1});\\n    \\t\\t\\tgrey[u+1]=1;\\n    \\t\\t}\\n    \\t\\tfor(int v:adj[arr[u]])\\n    \\t\\t\\tif(!grey[v])\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tq.push({v,d+1});\\n    \\t\\t\\t\\tgrey[v]=1;\\n    \\t\\t\\t}\\n            adj[arr[u]]={};\\n    \\t}\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1690949,
                "title": "c-bfs-solution-o-n-time-and-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n == 1) return 0;\\n        \\n        unordered_map<int, vector<int>> mp;\\n        \\n        int step = 0;\\n        \\n        //fill map\\n        for(int i = 0; i<n; i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        \\n        //queue\\n        queue<int> q;\\n        q.push(0);\\n        \\n        while(!q.empty()){\\n            step++;\\n            int size = q.size();\\n            \\n            for(int i = 0; i<size; i++){\\n                int j = q.front();\\n                q.pop();\\n                \\n                //jump to j-1\\n                if(j-1 >= 0 && mp.find(arr[j-1]) != mp.end()){\\n                    q.push(j-1);\\n                }\\n                \\n                //jump to j+1\\n                if(j+1 < n && mp.find(arr[j+1]) != mp.end()){\\n                    if(j+1 == n-1) return step;\\n                    q.push(j+1);\\n                }\\n                \\n                // jump to equal\\n                if(mp.find(arr[j]) != mp.end()){\\n                    for(auto k: mp[arr[j]]){\\n                        if(k != j){\\n                            if(k == n-1) return step;\\n                            q.push(k);\\n                        }\\n                    }\\n                }\\n                mp.erase(arr[j]);\\n            }\\n        }\\n        return step;\\n    }\\n};\\n```\\n\\nPlease **Upvote** :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n == 1) return 0;\\n        \\n        unordered_map<int, vector<int>> mp;\\n        \\n        int step = 0;\\n        \\n        //fill map\\n        for(int i = 0; i<n; i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        \\n        //queue\\n        queue<int> q;\\n        q.push(0);\\n        \\n        while(!q.empty()){\\n            step++;\\n            int size = q.size();\\n            \\n            for(int i = 0; i<size; i++){\\n                int j = q.front();\\n                q.pop();\\n                \\n                //jump to j-1\\n                if(j-1 >= 0 && mp.find(arr[j-1]) != mp.end()){\\n                    q.push(j-1);\\n                }\\n                \\n                //jump to j+1\\n                if(j+1 < n && mp.find(arr[j+1]) != mp.end()){\\n                    if(j+1 == n-1) return step;\\n                    q.push(j+1);\\n                }\\n                \\n                // jump to equal\\n                if(mp.find(arr[j]) != mp.end()){\\n                    for(auto k: mp[arr[j]]){\\n                        if(k != j){\\n                            if(k == n-1) return step;\\n                            q.push(k);\\n                        }\\n                    }\\n                }\\n                mp.erase(arr[j]);\\n            }\\n        }\\n        return step;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503171,
                "title": "9-lines-python-bfs",
                "content": "```\\ndef minJumps(self, A):\\n    indices = collections.defaultdict(list)\\n    for i, a in enumerate(A):\\n        indices[a].append(i)\\n    done, now = {-1}, {0}\\n    for steps in itertools.count():\\n        done |= now\\n        if len(A) - 1 in done:\\n            return steps\\n        now = {j for i in now for j in [i-1, i+1] + indices.pop(A[i], [])} - done\\n```\\nAvoids stepping outside on the left by putting `-1` in `done`. No need to avoid stepping outside on the right, that\\'s only possible from the goal index, and from the goal we don\\'t move further.\\n\\nFirst time we step off some value, we `pop` all its indices so we don\\'t use them again later.",
                "solutionTags": [],
                "code": "```\\ndef minJumps(self, A):\\n    indices = collections.defaultdict(list)\\n    for i, a in enumerate(A):\\n        indices[a].append(i)\\n    done, now = {-1}, {0}\\n    for steps in itertools.count():\\n        done |= now\\n        if len(A) - 1 in done:\\n            return steps\\n        now = {j for i in now for j in [i-1, i+1] + indices.pop(A[i], [])} - done\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3257971,
                "title": "clean-codes-full-explanation-breadth-first-search-c-java-python3",
                "content": "# Intuition :\\n- We ha ve to find the minimum number of jumps needed to reach the last index of an array. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach :\\n- The idea is to use a **Breadth First Search** approach to explore all the possible paths starting from the first index.\\n\\n---\\n\\n\\n\\n# Steps needed to solve the Problem :\\n\\n ***\\u27A1\\uFE0FStep 1: Initialize data structures***\\n- The first step is to initialize few data structures that will be used later in the algorithm. \\n- Create a map to store the indices of each value in the input array, a queue to store the indices of the current nodes to be visited, and a boolean array to mark whether each index has been seen before:\\n```\\nfinal int n = arr.length;\\n\\n// Initialize a map to store the indices of each value in the array\\nMap<Integer, List<Integer>> graph = new HashMap<>();\\n\\n// Initialize a queue with the first index and mark it as seen\\nQueue<Integer> q = new ArrayDeque<>(Arrays.asList(0));\\n\\n// Initialize a boolean array to keep track of visited indices\\nboolean[] seen = new boolean[n];\\nseen[0] = true;\\n\\n```\\n***\\u27A1\\uFE0FStep 2: Build the graph***\\n- Next step is to build a graph that represents the relationships between the elements in the input array. And loop through the array and add each index to the list of indices for its corresponding value in the map:\\n```\\nfor (int i = 0; i < n; ++i) \\n{\\n  // Add the current index to the list of indices for its corresponding value\\n  graph.putIfAbsent(arr[i], new ArrayList<>());\\n  graph.get(arr[i]).add(i);\\n}\\n\\n```\\n***\\u27A1\\uFE0FStep 3: BFS Algorithm***\\n- Now, in this step enter a loop that performs a BFS algorithm to find the minimum number of jumps needed to reach the end of the array.\\n-  At each iteration of the loop, dequeue the next node from the queue, check if it\\'s the last index of the array, and mark it as visited.\\n-  Then add the adjacent nodes to the list of indices for their corresponding value in the map, and enqueue any adjacent nodes that have not been visited yet:\\n```\\nfor (int steps = 0; !q.isEmpty(); ++steps) \\n{\\n  // Iterate over all the nodes at the current level of the BFS\\n  for (int sz = q.size(); sz > 0; --sz) \\n  {\\n    // Dequeue the next node and check if it\\'s the last index of the array\\n    final int i = q.poll();\\n    if (i == n - 1)\\n      return steps;\\n    seen[i] = true;\\n    final int u = arr[i];\\n    // Add the adjacent nodes to the list of indices for their corresponding value\\n    if (i + 1 < n)\\n      graph.get(u).add(i + 1);\\n    if (i - 1 >= 0)\\n      graph.get(u).add(i - 1);\\n    // Iterate over all the adjacent nodes and enqueue them if they haven\\'t been seen yet\\n    for (final int v : graph.get(u)) \\n    {\\n      if (seen[v])\\n        continue;\\n      q.offer(v);\\n    }\\n    // Clear the list of indices for the current node value to avoid revisiting it\\n    graph.get(u).clear();\\n  }\\n}\\n\\n```\\n***\\u27A1\\uFE0FStep 4: Return the minimum number of jumps***\\n- If the end of the array is reached, return the number of steps it took to get there. Otherwise, throw an error:\\n```\\n// If the last index is not reached, throw an exception\\nthrow new IllegalArgumentException();\\n\\n```\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : O(N+K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(N+K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n***Let\\'s Code it Up .\\nThere may be minor syntax difference in C++ and Python***\\n# Codes [C++ |Java |Python3] : With Comments\\n```C++ []\\nclass Solution {\\npublic:\\n  int minJumps(vector<int>& arr) {\\n    const int n = arr.size();\\n    // {a: indices}\\n    unordered_map<int, vector<int>> graph;\\n    // Initialize queue with first index and mark as seen\\n    queue<int> q{{0}};\\n    vector<bool> seen(n);\\n    seen[0] = true;\\n\\n    // Create graph where keys are elements and values are their indices in arr\\n    for (int i = 0; i < n; ++i)\\n      graph[arr[i]].push_back(i);\\n\\n    // BFS\\n    for (int steps = 0; !q.empty(); ++steps) {\\n      // Process all nodes at current level\\n      for (int sz = q.size(); sz > 0; --sz) {\\n        const int i = q.front();\\n        q.pop();\\n        // If last index is reached, return number of steps\\n        if (i == n - 1)\\n          return steps;\\n        seen[i] = true;\\n        const int u = arr[i];\\n        // Add adjacent indices to graph\\n        if (i + 1 < n)\\n          graph[u].push_back(i + 1);\\n        if (i - 1 >= 0)\\n          graph[u].push_back(i - 1);\\n        // Process all adjacent nodes\\n        for (const int v : graph[u]) {\\n          if (seen[v])\\n            continue;\\n          q.push(v);\\n        }\\n        // Clear indices in graph to avoid revisiting\\n        graph[u].clear();\\n      }\\n    }\\n    // Should never reach here\\n    throw;\\n  }\\n};\\n```\\n```Java []\\nclass Solution \\n{\\n  public int minJumps(int[] arr) \\n  {\\n    final int n = arr.length;\\n    // {a: indices}\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    // Initialize a map to store the indices of each value in the array\\n    Queue<Integer> q = new ArrayDeque<>(Arrays.asList(0));\\n    // Initialize a queue with the first index and mark it as seen\\n    boolean[] seen = new boolean[n];\\n    seen[0] = true;\\n\\n    for (int i = 0; i < n; ++i) \\n    {\\n      // Add the current index to the list of indices for its corresponding value\\n      graph.putIfAbsent(arr[i], new ArrayList<>());\\n      graph.get(arr[i]).add(i);\\n    }\\n\\n    for (int steps = 0; !q.isEmpty(); ++steps) \\n    {\\n      // Iterate over all the nodes at the current level of the BFS\\n      for (int sz = q.size(); sz > 0; --sz) \\n      {\\n        // Dequeue the next node and check if it\\'s the last index of the array\\n        final int i = q.poll();\\n        if (i == n - 1)\\n          return steps;\\n        seen[i] = true;\\n        final int u = arr[i];\\n        // Add the adjacent nodes to the list of indices for their corresponding value\\n        if (i + 1 < n)\\n          graph.get(u).add(i + 1);\\n        if (i - 1 >= 0)\\n          graph.get(u).add(i - 1);\\n        // Iterate over all the adjacent nodes and enqueue them if they haven\\'t been seen yet\\n        for (final int v : graph.get(u)) \\n        {\\n          if (seen[v])\\n            continue;\\n          q.offer(v);\\n        }\\n        // Clear the list of indices for the current node value to avoid revisiting it\\n        graph.get(u).clear();\\n      }\\n    }\\n    // If the last index is not reached, throw an exception\\n    throw new IllegalArgumentException();\\n  }\\n}\\n```\\n```Python []\\nclass Solution:\\n  def minJumps(self, arr: List[int]) -> int:\\n    n = len(arr)\\n    # {num: indices}\\n    graph = collections.defaultdict(list)\\n    steps = 0\\n    q = collections.deque([0])\\n    seen = {0}\\n\\n    # Create graph where keys are elements and values are their indices in arr\\n    for i, a in enumerate(arr):\\n      graph[a].append(i)\\n\\n    # BFS\\n    while q:\\n      # Process all nodes at current level\\n      for _ in range(len(q)):\\n        i = q.popleft()\\n        # If last index is reached, return number of steps\\n        if i == n - 1:\\n          return steps\\n        seen.add(i)\\n        u = arr[i]\\n        # Add adjacent indices to graph\\n        if i + 1 < n:\\n          graph[u].append(i + 1)\\n        if i - 1 >= 0:\\n          graph[u].append(i - 1)\\n        # Process all adjacent nodes\\n        for v in graph[u]:\\n          if v in seen:\\n            continue\\n          q.append(v)\\n        # Clear indices in graph to avoid revisiting\\n        graph[u].clear()\\n      steps += 1\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/93d3956d-8e55-4c8b-a784-65a8618dd010_1677985041.7690272.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfinal int n = arr.length;\\n\\n// Initialize a map to store the indices of each value in the array\\nMap<Integer, List<Integer>> graph = new HashMap<>();\\n\\n// Initialize a queue with the first index and mark it as seen\\nQueue<Integer> q = new ArrayDeque<>(Arrays.asList(0));\\n\\n// Initialize a boolean array to keep track of visited indices\\nboolean[] seen = new boolean[n];\\nseen[0] = true;\\n\\n```\n```\\nfor (int i = 0; i < n; ++i) \\n{\\n  // Add the current index to the list of indices for its corresponding value\\n  graph.putIfAbsent(arr[i], new ArrayList<>());\\n  graph.get(arr[i]).add(i);\\n}\\n\\n```\n```\\nfor (int steps = 0; !q.isEmpty(); ++steps) \\n{\\n  // Iterate over all the nodes at the current level of the BFS\\n  for (int sz = q.size(); sz > 0; --sz) \\n  {\\n    // Dequeue the next node and check if it\\'s the last index of the array\\n    final int i = q.poll();\\n    if (i == n - 1)\\n      return steps;\\n    seen[i] = true;\\n    final int u = arr[i];\\n    // Add the adjacent nodes to the list of indices for their corresponding value\\n    if (i + 1 < n)\\n      graph.get(u).add(i + 1);\\n    if (i - 1 >= 0)\\n      graph.get(u).add(i - 1);\\n    // Iterate over all the adjacent nodes and enqueue them if they haven\\'t been seen yet\\n    for (final int v : graph.get(u)) \\n    {\\n      if (seen[v])\\n        continue;\\n      q.offer(v);\\n    }\\n    // Clear the list of indices for the current node value to avoid revisiting it\\n    graph.get(u).clear();\\n  }\\n}\\n\\n```\n```\\n// If the last index is not reached, throw an exception\\nthrow new IllegalArgumentException();\\n\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\nclass Solution {\\npublic:\\n  int minJumps(vector<int>& arr) {\\n    const int n = arr.size();\\n    // {a: indices}\\n    unordered_map<int, vector<int>> graph;\\n    // Initialize queue with first index and mark as seen\\n    queue<int> q{{0}};\\n    vector<bool> seen(n);\\n    seen[0] = true;\\n\\n    // Create graph where keys are elements and values are their indices in arr\\n    for (int i = 0; i < n; ++i)\\n      graph[arr[i]].push_back(i);\\n\\n    // BFS\\n    for (int steps = 0; !q.empty(); ++steps) {\\n      // Process all nodes at current level\\n      for (int sz = q.size(); sz > 0; --sz) {\\n        const int i = q.front();\\n        q.pop();\\n        // If last index is reached, return number of steps\\n        if (i == n - 1)\\n          return steps;\\n        seen[i] = true;\\n        const int u = arr[i];\\n        // Add adjacent indices to graph\\n        if (i + 1 < n)\\n          graph[u].push_back(i + 1);\\n        if (i - 1 >= 0)\\n          graph[u].push_back(i - 1);\\n        // Process all adjacent nodes\\n        for (const int v : graph[u]) {\\n          if (seen[v])\\n            continue;\\n          q.push(v);\\n        }\\n        // Clear indices in graph to avoid revisiting\\n        graph[u].clear();\\n      }\\n    }\\n    // Should never reach here\\n    throw;\\n  }\\n};\\n```\n```Java []\\nclass Solution \\n{\\n  public int minJumps(int[] arr) \\n  {\\n    final int n = arr.length;\\n    // {a: indices}\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    // Initialize a map to store the indices of each value in the array\\n    Queue<Integer> q = new ArrayDeque<>(Arrays.asList(0));\\n    // Initialize a queue with the first index and mark it as seen\\n    boolean[] seen = new boolean[n];\\n    seen[0] = true;\\n\\n    for (int i = 0; i < n; ++i) \\n    {\\n      // Add the current index to the list of indices for its corresponding value\\n      graph.putIfAbsent(arr[i], new ArrayList<>());\\n      graph.get(arr[i]).add(i);\\n    }\\n\\n    for (int steps = 0; !q.isEmpty(); ++steps) \\n    {\\n      // Iterate over all the nodes at the current level of the BFS\\n      for (int sz = q.size(); sz > 0; --sz) \\n      {\\n        // Dequeue the next node and check if it\\'s the last index of the array\\n        final int i = q.poll();\\n        if (i == n - 1)\\n          return steps;\\n        seen[i] = true;\\n        final int u = arr[i];\\n        // Add the adjacent nodes to the list of indices for their corresponding value\\n        if (i + 1 < n)\\n          graph.get(u).add(i + 1);\\n        if (i - 1 >= 0)\\n          graph.get(u).add(i - 1);\\n        // Iterate over all the adjacent nodes and enqueue them if they haven\\'t been seen yet\\n        for (final int v : graph.get(u)) \\n        {\\n          if (seen[v])\\n            continue;\\n          q.offer(v);\\n        }\\n        // Clear the list of indices for the current node value to avoid revisiting it\\n        graph.get(u).clear();\\n      }\\n    }\\n    // If the last index is not reached, throw an exception\\n    throw new IllegalArgumentException();\\n  }\\n}\\n```\n```Python []\\nclass Solution:\\n  def minJumps(self, arr: List[int]) -> int:\\n    n = len(arr)\\n    # {num: indices}\\n    graph = collections.defaultdict(list)\\n    steps = 0\\n    q = collections.deque([0])\\n    seen = {0}\\n\\n    # Create graph where keys are elements and values are their indices in arr\\n    for i, a in enumerate(arr):\\n      graph[a].append(i)\\n\\n    # BFS\\n    while q:\\n      # Process all nodes at current level\\n      for _ in range(len(q)):\\n        i = q.popleft()\\n        # If last index is reached, return number of steps\\n        if i == n - 1:\\n          return steps\\n        seen.add(i)\\n        u = arr[i]\\n        # Add adjacent indices to graph\\n        if i + 1 < n:\\n          graph[u].append(i + 1)\\n        if i - 1 >= 0:\\n          graph[u].append(i - 1)\\n        # Process all adjacent nodes\\n        for v in graph[u]:\\n          if v in seen:\\n            continue\\n          q.append(v)\\n        # Clear indices in graph to avoid revisiting\\n        graph[u].clear()\\n      steps += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288991,
                "title": "bfs-c-with-intuition-100-and-simple-explanation",
                "content": "**OBSERVATIONS** \\n1. Given that we can **jump to the previous and next neighbour if they are within the limits** from the current position.\\n2. We can also **jump to the same element which is present in the array but at different index** .\\n\\nAtlast we have to return the **minimum number of steps to reach the end (n-1 th index )**\\n\\n**LOGIC**\\n**1**. Here we are using BFS Algorithm. \\nThen the immediate question is why???? \\n\\n**Reason**\\n\\n**Whenever there is an unwieghted graph and we want to retrive the shortest path or minimum steps to reach the destination** , we use **BFS**  , **as it takes all the neighbouring guys from the current node and this process repeats for every node** .\\n\\n**Thus the total visualisation will be like we are generating hotspots/ rainbows on each node. Therefore the spread to the entire graph takes minimum effort** .\\n\\nThus , by moving forward\\n**2**. The question is very easy but few changes to be made on applying BFS.\\n**3**. According to Observations, here **for the current element its friends are the previous and next neighbours, and same guys** . \\nSo we will create **a hashmap of node and his same guys**\\n\\nThe other data structures needed are :- ***queue :- Pushing the indexes  ; \\nVisited array (bool type ) :- To mark which nodes are visited***\\nAnd a **step variable** :- Counts the steps to till we have reach the end.\\n**4**. Starting the BFS,  push 0 as its the first index and mark it as visted. Begin the loop until the queue becomes empty :\\n\\t\\t* Take the **front element** . **If its the n-1 th index , directly return the step** ;\\n\\t\\t* **Else take its previous and next guys and put in its friends list** ;\\n\\t\\t* Start **traversing the neighbours list which contains same guys, prev guy and next guy**.\\n    \\t* If they are **within the range and still not visited** :- Mark them as visited and push them\\n    \\t\\n**One important point of this whole question is, after visiting the neighbours list, plz clear the list** The reason is : \\n\\n**Removing the visited ones to reduce the repetitive work;\\nAs the children are already visted and no use for the coming iterations for \\nany further guy in coming iterations bcz we have already used that path and didnt got the answer ,so not allowing to use this path**\\n\\n\" **To tell in simple manner, everytime we are reducing the size of the friendslist, so that the search space is reducing.** \"\\n\\n*Code* \\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=size(arr);\\n        if(n==1) return 0;   //  edge case : )\\n        unordered_map<int,list<int>>mp;    // ele -> all its same guys \\n        for(int i=0;i<n;i++) mp[arr[i]].push_back(i);\\n        queue<int>q;\\n        vector<bool>vis(n,false);\\n        q.push(0); vis[0]=true;\\n        int step=0;\\n        while(!q.empty()){\\n            \\n            int sz=size(q);\\n            while(sz--){\\n                int fr=q.front(); q.pop();\\n                if(fr==n-1) return step; // if u reached the last ind then return count step;\\n                // else now vist all its neighs who are i+1,i-1 and same guys \\n                list<int>& neigh=mp[arr[fr]];\\n                neigh.push_back(fr-1); \\n                neigh.push_back(fr+1);\\n                // since the left and right guys of ith ele are not there in its list\\n\\t\\t\\t\\t\\n                // so now iterate through neigh who are within the range and not vis\\n                for(auto x: neigh){\\n                    if(x>=0 and x<n and !vis[x]){q.push(x); vis[x]=true;}\\n                }\\n                neigh.clear();  // removing the visited ones to reduce the reptiive work;\\n                // as the children are already visted and no use for the coming iterations for \\n                // any further guy in coming iterations; bcz we have already used that path and didnt got the ans ,so not allowing to use this path;\\n            }\\n            step++; // counting the steps\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n**Thanks for reading.\\nIf you like it , Do upvote\\nHappy Learning :)**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=size(arr);\\n        if(n==1) return 0;   //  edge case : )\\n        unordered_map<int,list<int>>mp;    // ele -> all its same guys \\n        for(int i=0;i<n;i++) mp[arr[i]].push_back(i);\\n        queue<int>q;\\n        vector<bool>vis(n,false);\\n        q.push(0); vis[0]=true;\\n        int step=0;\\n        while(!q.empty()){\\n            \\n            int sz=size(q);\\n            while(sz--){\\n                int fr=q.front(); q.pop();\\n                if(fr==n-1) return step; // if u reached the last ind then return count step;\\n                // else now vist all its neighs who are i+1,i-1 and same guys \\n                list<int>& neigh=mp[arr[fr]];\\n                neigh.push_back(fr-1); \\n                neigh.push_back(fr+1);\\n                // since the left and right guys of ith ele are not there in its list\\n\\t\\t\\t\\t\\n                // so now iterate through neigh who are within the range and not vis\\n                for(auto x: neigh){\\n                    if(x>=0 and x<n and !vis[x]){q.push(x); vis[x]=true;}\\n                }\\n                neigh.clear();  // removing the visited ones to reduce the reptiive work;\\n                // as the children are already visted and no use for the coming iterations for \\n                // any further guy in coming iterations; bcz we have already used that path and didnt got the ans ,so not allowing to use this path;\\n            }\\n            step++; // counting the steps\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198853,
                "title": "c-bfs-solution-99-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>>m; //to store the index of the same value\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            m[arr[i]].push_back(i);\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        vector<int>vis(n);\\n        int level=0;\\n        while(q.empty()==false){\\n            int sz=q.size();\\n            while(sz--){\\n                auto front=q.front();\\n                q.pop();\\n                if(front==n-1){         //if current node is last node return current level\\n                    return level;\\n                }\\n                vis[front]=1;                   //mark current node\\n                auto &temp=m[arr[front]];           //get list of nodes which are having same value as current node\\n                for(auto &i:temp){\\n                    if(vis[i]==0){             //if any node is not visited \\n                        if(i==n-1)            // check if it is last node return level+1 (because it will be find it in next round)\\n                            return level+1;\\n                        q.push(i);           // otherwise mark as visited and add in queue\\n                        vis[i]=1;\\n                    }\\n                }\\n                temp.clear();            //clear the array since we have visited all the nodes or will be visiting in future but added in queue\\n                if(front+1==n-1){       //if front+1 is last then we can directly jump to it and reach to destination so return level +1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  //no need to check for front-1 is the last or not because if we are at index n then only we can reach to n-1 by jumping left but we can never go to n (mention in question)\\n                    return level+1;\\n                }\\n                if(front-1>=0 and vis[front-1]==0){        //check if we can jump to the left then we will add in the queue and mark as visited\\n                    q.push(front-1);\\n                    vis[front-1]=1;\\n                }\\n                if(front+1<n and vis[front+1]==0){         //check if we can jump to the right then we will add in the queue and mark as visited\\n                    q.push(front+1);\\n                    vis[front+1]=1;\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>>m; //to store the index of the same value\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            m[arr[i]].push_back(i);\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        vector<int>vis(n);\\n        int level=0;\\n        while(q.empty()==false){\\n            int sz=q.size();\\n            while(sz--){\\n                auto front=q.front();\\n                q.pop();\\n                if(front==n-1){         //if current node is last node return current level\\n                    return level;\\n                }\\n                vis[front]=1;                   //mark current node\\n                auto &temp=m[arr[front]];           //get list of nodes which are having same value as current node\\n                for(auto &i:temp){\\n                    if(vis[i]==0){             //if any node is not visited \\n                        if(i==n-1)            // check if it is last node return level+1 (because it will be find it in next round)\\n                            return level+1;\\n                        q.push(i);           // otherwise mark as visited and add in queue\\n                        vis[i]=1;\\n                    }\\n                }\\n                temp.clear();            //clear the array since we have visited all the nodes or will be visiting in future but added in queue\\n                if(front+1==n-1){       //if front+1 is last then we can directly jump to it and reach to destination so return level +1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  //no need to check for front-1 is the last or not because if we are at index n then only we can reach to n-1 by jumping left but we can never go to n (mention in question)\\n                    return level+1;\\n                }\\n                if(front-1>=0 and vis[front-1]==0){        //check if we can jump to the left then we will add in the queue and mark as visited\\n                    q.push(front-1);\\n                    vis[front-1]=1;\\n                }\\n                if(front+1<n and vis[front+1]==0){         //check if we can jump to the right then we will add in the queue and mark as visited\\n                    q.push(front+1);\\n                    vis[front+1]=1;\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258666,
                "title": "c-bfs-readable-code",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int minJumps(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        const int inf = 1e9;\\n\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++)\\n            mp[arr[i]].push_back(i);\\n\\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        \\n        vector<int> dist(n, inf);\\n        dist[0] = 0;\\n\\n        while (!q.empty())\\n        {\\n            auto idx = q.front().first;\\n            auto moves = q.front().second;\\n            q.pop();\\n\\n            assert(idx >= 0 and idx < n);\\n\\n            if (idx == n - 1)\\n                return moves;\\n\\n            if (idx - 1 >= 0 and moves + 1 < dist[idx - 1])\\n            {\\n                dist[idx - 1] = moves + 1;\\n                q.push({idx - 1, moves + 1});\\n            }\\n\\n            if (idx + 1 < n and moves + 1 < dist[idx + 1])\\n            {\\n                dist[idx + 1] = moves + 1;\\n                q.push({idx + 1, moves + 1});\\n            }\\n\\n            for (auto i : mp[arr[idx]])\\n            {\\n                if (i != idx and moves + 1 < dist[i])\\n                {\\n                    dist[i] = moves + 1;\\n                    q.push({i, moves + 1});\\n                }\\n            }\\n            mp.erase(arr[idx]);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minJumps(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        const int inf = 1e9;\\n\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++)\\n            mp[arr[i]].push_back(i);\\n\\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        \\n        vector<int> dist(n, inf);\\n        dist[0] = 0;\\n\\n        while (!q.empty())\\n        {\\n            auto idx = q.front().first;\\n            auto moves = q.front().second;\\n            q.pop();\\n\\n            assert(idx >= 0 and idx < n);\\n\\n            if (idx == n - 1)\\n                return moves;\\n\\n            if (idx - 1 >= 0 and moves + 1 < dist[idx - 1])\\n            {\\n                dist[idx - 1] = moves + 1;\\n                q.push({idx - 1, moves + 1});\\n            }\\n\\n            if (idx + 1 < n and moves + 1 < dist[idx + 1])\\n            {\\n                dist[idx + 1] = moves + 1;\\n                q.push({idx + 1, moves + 1});\\n            }\\n\\n            for (auto i : mp[arr[idx]])\\n            {\\n                if (i != idx and moves + 1 < dist[i])\\n                {\\n                    dist[i] = moves + 1;\\n                    q.push({i, moves + 1});\\n                }\\n            }\\n            mp.erase(arr[idx]);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258651,
                "title": "c-easiest-optimised-approach-line-by-line-explanation-beats-100",
                "content": "# Intuition\\nThe given problem is to find the minimum number of steps to reach the last index of the array, where in one step, we can either move to the adjacent indices or to any index having the same value as the current index.\\n\\nThe approach used to solve this problem is Breadth-First Search (BFS), where we start traversing the array from the first index, and at each step, we explore all the possible jumps that can be made from the current index. We keep track of the visited indices to avoid revisiting the same indices again, and we also maintain a queue to keep track of the indices that need to be explored in the next step.\\n\\n\\n# Approach\\nFor each index, we explore three possible jumps:\\n\\ni + 1, where i + 1 < arr.length\\ni - 1, where i - 1 >= 0\\nj where arr[i] == arr[j] and i != j\\n\\nIf any of the next indices haven\\'t been visited before, we mark them as visited and add them to the queue. We repeat this process until we reach the last index of the array or until there are no more indices to explore in the queue.\\n\\nThe minimum number of steps to reach the last index of the array is the number of steps required to reach the last index from the first index, which is the number of levels in the BFS tree.\\n\\nTherefore, the intuition behind this approach is to explore all the possible jumps from each index of the array in a breadth-first manner until we reach the last index, and we maintain a count of the number of steps required to reach the last index.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the BFS algorithm used to solve this problem is O(n), where n is the number of elements in the array. This is because we visit each element of the array exactly once, and for each element, we explore at most three possible jumps.\\n\\n- Space complexity:\\nThe space complexity of the algorithm is also O(n), as we need to store the visited array of size n and the queue of size at most n, which can happen in the worst case when all elements have the same value.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if (n == 1) return 0;\\n        unordered_map<int, vector<int>> indices;\\n        for (int i = 0; i < n; i++) {\\n            indices[arr[i]].push_back(i);\\n        }\\n        vector<int> visited(n);\\n        visited[0] = true;\\n        queue<int> q;\\n        q.push(0);\\n        int steps = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = q.front();\\n                q.pop();\\n                if (curr == n - 1) return steps;\\n                if (curr + 1 < n && !visited[curr + 1]) {\\n                    visited[curr + 1] = true;\\n                    q.push(curr + 1);\\n                }\\n                if (curr - 1 >= 0 && !visited[curr - 1]) {\\n                    visited[curr - 1] = true;\\n                    q.push(curr - 1);\\n                }\\n                for (int nextIndex : indices[arr[curr]]) {\\n                    if (nextIndex != curr && !visited[nextIndex]) {\\n                        visited[nextIndex] = true;\\n                        q.push(nextIndex);\\n                    }\\n                }\\n                indices[arr[curr]].clear();\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n//\\uD83D\\uDC47UPVOTE IF YOU LIKED MY SOLUTION\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if (n == 1) return 0;\\n        unordered_map<int, vector<int>> indices;\\n        for (int i = 0; i < n; i++) {\\n            indices[arr[i]].push_back(i);\\n        }\\n        vector<int> visited(n);\\n        visited[0] = true;\\n        queue<int> q;\\n        q.push(0);\\n        int steps = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = q.front();\\n                q.pop();\\n                if (curr == n - 1) return steps;\\n                if (curr + 1 < n && !visited[curr + 1]) {\\n                    visited[curr + 1] = true;\\n                    q.push(curr + 1);\\n                }\\n                if (curr - 1 >= 0 && !visited[curr - 1]) {\\n                    visited[curr - 1] = true;\\n                    q.push(curr - 1);\\n                }\\n                for (int nextIndex : indices[arr[curr]]) {\\n                    if (nextIndex != curr && !visited[nextIndex]) {\\n                        visited[nextIndex] = true;\\n                        q.push(nextIndex);\\n                    }\\n                }\\n                indices[arr[curr]].clear();\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n//\\uD83D\\uDC47UPVOTE IF YOU LIKED MY SOLUTION\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258907,
                "title": "leetcode-the-hard-way-bidirectional-bfs-explained",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=S6hagPEHjAY&list=PLBu4Bche1aEWeSa2dtoFf---oF0hwokdE&index=5) if you are interested.\\n\\n---\\n\\n```py\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        loc = defaultdict(list)\\n        # v can go to index i\\n        for i, v in enumerate(arr): loc[v].append(i)\\n        # q: from left to right\\n        # q2: from right to left\\n        q, q2 = deque([0]), deque([n - 1])\\n        # vis: visited state for q\\n        # vis2: visited state for q2\\n        vis, vis2 = {0}, {n - 1}\\n        ans = 0\\n        # Bidirectional BFS\\n        while q:\\n            # process the shortest queue\\n            if len(q2) < len(q):\\n                q, q2 = q2, q\\n                vis, vis2 = vis2, vis\\n            for _ in range(len(q)):\\n                # get the current element\\n                x = q.popleft()\\n                # if `x` exists in vis2, \\n                # that means we\\'ve processed the rest already\\n                if x in vis2:\\n                    return ans\\n                # otherwise, we can either jump to \\n                # - prev index or \\n                # - next index or\\n                # - any index j where arr[i] == arr[j] and i != j\\n                for i in [x - 1, x + 1] + loc[arr[x]]:\\n                    # check if the next index is within the bound \\n                    # and visitied or not\\n                    if 0 <= i < n and i not in vis:\\n                        # mark it visited\\n                        vis.add(i)\\n                        # add to the queue\\n                        q.append(i)\\n                # remove loc[arr[x]] to speed up since we\\'ve processed it\\n                del loc[arr[x]]\\n            # add one step\\n            ans += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```py\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        loc = defaultdict(list)\\n        # v can go to index i\\n        for i, v in enumerate(arr): loc[v].append(i)\\n        # q: from left to right\\n        # q2: from right to left\\n        q, q2 = deque([0]), deque([n - 1])\\n        # vis: visited state for q\\n        # vis2: visited state for q2\\n        vis, vis2 = {0}, {n - 1}\\n        ans = 0\\n        # Bidirectional BFS\\n        while q:\\n            # process the shortest queue\\n            if len(q2) < len(q):\\n                q, q2 = q2, q\\n                vis, vis2 = vis2, vis\\n            for _ in range(len(q)):\\n                # get the current element\\n                x = q.popleft()\\n                # if `x` exists in vis2, \\n                # that means we\\'ve processed the rest already\\n                if x in vis2:\\n                    return ans\\n                # otherwise, we can either jump to \\n                # - prev index or \\n                # - next index or\\n                # - any index j where arr[i] == arr[j] and i != j\\n                for i in [x - 1, x + 1] + loc[arr[x]]:\\n                    # check if the next index is within the bound \\n                    # and visitied or not\\n                    if 0 <= i < n and i not in vis:\\n                        # mark it visited\\n                        vis.add(i)\\n                        # add to the queue\\n                        q.append(i)\\n                # remove loc[arr[x]] to speed up since we\\'ve processed it\\n                del loc[arr[x]]\\n            # add one step\\n            ans += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691093,
                "title": "python3-recursive-bfs-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThis problem can be approached as finding the shortest path in a graph. If we take an index of the `arr` as a node, we can see that from that node we can go to `i-1`, `i+1` and to `j` where `arr[i] == arr[j]`. We could build an adjacency list but it\\'s not necessary because `i-1` and `i+1` can be calculated from the index. The only thing we need is a hashmap `groups` with the list of elements where we can jump directly from the current element.\\n\\nWhen the hashmap is ready, we can traverse the graph level by level using standard BFS and find the shortest distance to the last element. There is one catch here though. It\\'s not enough to keep a set of visited nodes. For example, this array `[7,7,7,7,7,7,7 .......,11]` with max number of elements will give us a TME since we have to visit 7s on every iteration which will give us an `O(n^2)` complexity. We need to ignore such groups after we visited them once. That is why we have another set for visited groups along with the set of visited nodes.\\n\\nTime: **O(E+V)** - BFS\\nSpace: **O(n)** - hashmap\\n\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        N, groups = len(arr), defaultdict(list)\\n\\n        for i, el in enumerate(arr): \\n            groups[el].append(i)\\n\\n        vis, vis_groups = set(), set()\\n        \\n        def bfs(lvl, dist):\\n            nextLvl = set()\\n            \\n            for i in lvl:\\n                if i in vis: continue\\n                if i == N-1: return dist\\n                \\n                vis.add(i)\\n                \\n                if i: nextLvl.add(i-1)\\n                if i+1 < N: nextLvl.add(i+1)\\n                \\n                if not arr[i] in vis_groups:\\n                    vis_groups.add(arr[i])\\n                    nextLvl.update(groups[arr[i]])\\n            \\n            return bfs(nextLvl, dist + 1)\\n            \\n        return bfs(set([0]), 0)\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        N, groups = len(arr), defaultdict(list)\\n\\n        for i, el in enumerate(arr): \\n            groups[el].append(i)\\n\\n        vis, vis_groups = set(), set()\\n        \\n        def bfs(lvl, dist):\\n            nextLvl = set()\\n            \\n            for i in lvl:\\n                if i in vis: continue\\n                if i == N-1: return dist\\n                \\n                vis.add(i)\\n                \\n                if i: nextLvl.add(i-1)\\n                if i+1 < N: nextLvl.add(i+1)\\n                \\n                if not arr[i] in vis_groups:\\n                    vis_groups.add(arr[i])\\n                    nextLvl.update(groups[arr[i]])\\n            \\n            return bfs(nextLvl, dist + 1)\\n            \\n        return bfs(set([0]), 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690827,
                "title": "c-bfs-solution",
                "content": "```\\n int minJumps(vector<int>& arr) {\\n        \\n       unordered_map<int,vector<int>> mp;\\n        \\n       for(int i=0;i<arr.size();i++){\\n           mp[arr[i]].push_back(i);\\n       }\\n       \\n        queue<int> q;\\n        q.push(0);\\n        \\n        vector<int> dis(arr.size(),1e9);\\n        \\n        dis[0]=0;\\n        \\n        while(!q.empty()){\\n            \\n            int index=q.front();\\n            q.pop();\\n            \\n            if(index==arr.size() - 1) return dis[index];\\n            \\n            vector<int> &list=mp[arr[index]];\\n            list.push_back(index - 1);\\n            list.push_back(index + 1);\\n            \\n            \\n            for(auto  &x : list){\\n                \\n                if(x>=0 and x<arr.size() and dis[x]>dis[index] + 1){\\n                    dis[x] = dis[index] + 1;\\n                    q.push(x);\\n                }\\n            }\\n            list.clear();\\n        }\\n        \\n        return -1;\\n    }\\n```\\nConnect with me :[ Linkedin ](https://www.linkedin.com/in/sarvesh-khandelwal-206b171a7/)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n int minJumps(vector<int>& arr) {\\n        \\n       unordered_map<int,vector<int>> mp;\\n        \\n       for(int i=0;i<arr.size();i++){\\n           mp[arr[i]].push_back(i);\\n       }\\n       \\n        queue<int> q;\\n        q.push(0);\\n        \\n        vector<int> dis(arr.size(),1e9);\\n        \\n        dis[0]=0;\\n        \\n        while(!q.empty()){\\n            \\n            int index=q.front();\\n            q.pop();\\n            \\n            if(index==arr.size() - 1) return dis[index];\\n            \\n            vector<int> &list=mp[arr[index]];\\n            list.push_back(index - 1);\\n            list.push_back(index + 1);\\n            \\n            \\n            for(auto  &x : list){\\n                \\n                if(x>=0 and x<arr.size() and dis[x]>dis[index] + 1){\\n                    dis[x] = dis[index] + 1;\\n                    q.push(x);\\n                }\\n            }\\n            list.clear();\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1502824,
                "title": "simple-bfs-transversal-c-clean-code",
                "content": "Idea is simple, create a graph connecting all the idexes which satisfy the given conditions, \\nlike:- i + 1 where: i + 1 < arr.length.\\n        i - 1 where: i - 1 >= 0.\\n       j where: arr[i] == arr[j] and i != j.\\nfor third condition we are maintaing a graph.\\nNow we have a directed, unweighted graph and our task is to find the shorted distance between index 0 and n-1. Use BFS for it and maintain a visited which will also keep track of distance of node from 0.\\nBelow is the simple implementation of it,\\n\\n````\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>visited(n,0);     // keep track of visit\\n        \\n        map<int,vector<int>>mp;      // store the index for which values are same \\n        for(int i=0;i<n;i++)\\n        { \\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<int> adj[n];         //create adjancy list \\n        // build graph\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i-1>=0)\\n            adj[i].push_back(i-1);\\n            if(i+1<n)\\n            adj[i].push_back(i+1);\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        visited[0]=1;\\n        // BFS transversal\\n\\t\\twhile(!q.empty())\\n\\t\\t{\\n\\t\\t    int u=q.front();\\n\\t\\t    q.pop();\\n            if(u==n-1)\\n                return visited[u]-1;\\n\\t\\t    for(int v : adj[u])\\n            {\\n                if(visited[v]==0)\\n                {\\n                    q.push(v);\\n                    visited[v]=visited[u]+1;\\n                }\\n\\t\\t    }\\n            for(auto v:mp[arr[u]])\\n            {\\n                if(visited[v]==0)\\n                {\\n                    visited[v]=visited[u]+1;\\n                    q.push(v);\\n\\t\\t        }\\n            }\\n            mp[arr[u]].clear();\\n        }\\n        return visited[n-1]-1;      // return distance of n-1 index from 0\\n       }\\n};\\n````\\nPlaese upvote it if found helpful\\nHappy Coding!!",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>visited(n,0);     // keep track of visit\\n        \\n        map<int,vector<int>>mp;      // store the index for which values are same \\n        for(int i=0;i<n;i++)\\n        { \\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<int> adj[n];         //create adjancy list \\n        // build graph\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i-1>=0)\\n            adj[i].push_back(i-1);\\n            if(i+1<n)\\n            adj[i].push_back(i+1);\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        visited[0]=1;\\n        // BFS transversal\\n\\t\\twhile(!q.empty())\\n\\t\\t{\\n\\t\\t    int u=q.front();\\n\\t\\t    q.pop();\\n            if(u==n-1)\\n                return visited[u]-1;\\n\\t\\t    for(int v : adj[u])\\n            {\\n                if(visited[v]==0)\\n                {\\n                    q.push(v);\\n                    visited[v]=visited[u]+1;\\n                }\\n\\t\\t    }\\n            for(auto v:mp[arr[u]])\\n            {\\n                if(visited[v]==0)\\n                {\\n                    visited[v]=visited[u]+1;\\n                    q.push(v);\\n\\t\\t        }\\n            }\\n            mp[arr[u]].clear();\\n        }\\n        return visited[n-1]-1;      // return distance of n-1 index from 0\\n       }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256637,
                "title": "clean-and-concise-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<bool>vis(n, false);\\n        unordered_map<int, vector<int> >mp;\\n        for(int i = 0; i < n; i++)\\n            mp[arr[i]].push_back(i);\\n        queue<int>q;\\n        q.push(0);\\n        vis[0] = true;\\n        int step = 0;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            while(sz--) {\\n                int i = q.front();\\n                q.pop();\\n                if(i == n-1)return step;\\n                if(i+1 < n && !vis[i+1])vis[i+1] = true, q.push(i+1);\\n                if(i-1 >= 0 && !vis[i-1])vis[i-1] = true, q.push(i-1);\\n                for(auto &j : mp[arr[i]])\\n                    if(!vis[j])vis[j] = true, q.push(j);\\n                mp.erase(arr[i]); // Comment this line..You will get TLE\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<bool>vis(n, false);\\n        unordered_map<int, vector<int> >mp;\\n        for(int i = 0; i < n; i++)\\n            mp[arr[i]].push_back(i);\\n        queue<int>q;\\n        q.push(0);\\n        vis[0] = true;\\n        int step = 0;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            while(sz--) {\\n                int i = q.front();\\n                q.pop();\\n                if(i == n-1)return step;\\n                if(i+1 < n && !vis[i+1])vis[i+1] = true, q.push(i+1);\\n                if(i-1 >= 0 && !vis[i-1])vis[i-1] = true, q.push(i-1);\\n                for(auto &j : mp[arr[i]])\\n                    if(!vis[j])vis[j] = true, q.push(j);\\n                mp.erase(arr[i]); // Comment this line..You will get TLE\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691583,
                "title": "java-23ms-100-super-fast-bfs-optimizations-explained",
                "content": "UPDATE March 2023:  The test cases for this leetcode problem have changed, so that this code is now much slower, with a runtime of 1500ms.  In many leetcode problems, when passed an arrays, it is frequently assumed that the arrays will be processed from low-index start to high-index end.  The test cases contain a few test cases that are frequently designed to be difficult when processed from start to end, but usually no test cases that are difficult when processed backward, from end back to start.  After this code was faster than all other code on the runtime graph, someone added test case(s) that are difficult when processing the passed array from end to start.  This has happened in multiple other leetcode problems, where I had code that was very fast when processing arrays backward.  I\\'m glad people have added more robust test cases, even though some of my very fast code now runs much slower.  In one case, someone added new test cases that are difficult when processing the array from end back to start, so I changed my code to process the array from center outward very quickly.  Then someone added difficult test cases when processing the array from the center outward.  It is good to find leetcoders that can create test cases that fill these processing gaps, and be more difficult for more types of algorithms.\\n\\nORIGINAL Januaray 2022:\\nThe Java code below runs as fast as 23ms on 2022-01-15.  The next fastest entry on the graph at this date was 33ms.  Clicking the \"Submit\" button in a leetcode problem multiple times, can result in different runtimes for each submit.  The code below had runtimes from 23ms to 91ms.  Runtimes may also change when leetcode adds new test cases in the future.\\n\\nFor leetcode problem #1345 \"Jump Game IV\":  The code below uses a Breadth First Search (BFS) algorithm.  A BFS algorithm usually searches layer-by-layer from a defined starting point, until the goal of the search is found.  The code below starts at a pre-defined index in the array `arr[]`.  All possible valid moves from that pre-defined index in `arr[]`, are saved as indexes in the next \"layer\" of the search.  Then the BFS uses all the indexes from that saved layer, to try all possible valid moves from those indexes, and save those indexes in a new layer.  The BFS advances the search layer by layer, until reaching the end of the search.\\n\\nThe code below is optimized for speed.  Several optimizations are used to gain speed.  Some of these optimizations are basic to many Breadth First Search implementations.  Some optimizations are specific to this leetcode problem.  Optimizations are:\\n\\n**Search backward:**  This leetcode problem discussion says to start at index 0 and find the minimum number of valid moves to \"jump\" to index `arr.length-1`.  The rules of \"jumps\" in this problem are symmetric, so that the answer will be the same using going from start to end, or from end to start.  The code below uses the Breadth First Search going from the end-point of the game (the last index in the array; `arr[arr.length-1]`) backward to the start-point in the game (index zero; `arr[0]`). In leetcode problems, when processing can be done either from start to end, or from end to start, it is frequently faster to process backward.  Processing backward in leetcode problems is usually faster because of the test cases that were designed to be difficult for most problem code.  However some test cases are faster when processed backward.  This leetcode problem has been faster processing in the backward direction.  Therefore the code below starts the BFS at `arr[arr.length-1]` and jumps to `arr[0]`.\\n\\nIn some problems with known start-point and end-point of a Breadth First Search (BFS), it is faster to start a BFS from each end and have the two Breadth First Searches meet in the middle.  This method can be faster when the BFS tree will spread wider and wider for each layer.  By starting at each end and working toward the middle, the BFS trees don\\'t spread as wide and there may be fewer nodes to search.  However, in this leetcode problem, searching from both end toward the middle was slightly slower in my implementation.\\n\\n**Ignore interior values of repeated consecutive values:**  In the passed `arr[]` array, if the same value is repeated multiple times in a row, then only the first and last value of that repeated value are significant for the \"Jump Game IV\" rules.  For example, if\\n ` ` ` ` ` ` ` ` `arr[] = [1,8,8,8,8,8,8,1,4,8,8,7,8]`\\nthen values in `arr[]` can be handled as:\\n ` ` ` ` ` ` ` ` `arr[] = [1,8,*,*,*,*,8,1,4,8,8,7,8]`\\nwhere \"\\\\*\" represents a value that can be ignored for this game.  This is because of the definition of the jump rules.  If we jumped to the first \"8\" at index 1, then there would be no reason to set to index 1+1 when we could jump directly to any other \"8\" and have fewer jumps.\\n \\nThe code below creates a HashMap so that any value in `arr[]` can be looked-up in the HashMap to get a List of all indexes where that same value occurs in `arr[]`.  For example, the HashMap entry for \"1\" would contain the list `{0,7}`.  The HashMap entry for \"8\" would contain the list `{1,6,9,10,12}`.  The \"8\"s at index 2 through 5, the \"\\\\*\"s in the example above, are not saved in this list because they could NOT be on the minimum path in this game.  Ignoring the interior values of repeated consecutive values keep these lists shorter and runtime faster.\\n \\nA test case for this leetcode problem has over 49_000 consecutive \"7\"s.  By ignoring interior values of multiply repeated values in a row, this reduces the HashMap list for \"7\" from over 49_000 indexes to be processes, to a list length of only two \"7\"s to be processed.\\n \\n**Don\\'t reallocate Arrays:**  In the code below, the Breadth First Search (BFS) uses Arrays of `int` to contain the indexes for each layer of the BFS.  The BFS has one array for the current indexes to start a jump from, and another array being filled with the next layer of indexes jumped to.  When the array of current indexes has been fully processed, the two arrays are swapped, which saves the time of deallocating an old array and allocating a new array of the same length.\\n \\nIn Java, an array variable is only a reference, or a pointer, to the array data allocated in memory.  In the following pseudo-code fragment, the process of swapping which array data the variables `curLayer` and `nextLayer` are referencing is shown with the variable name on the left, and lines pointing to which allocated data they are referencing or pointing to.  A temporary variable is used to help swap which data goes with the array variables.  Sorry for the crude text graphics.\\n ```\\n         int[] curLayer ----------> {...array #1...}\\n         int[] nextLayer ---------> {...array #2...}\\ntmpLayer = curLayer;\\n         int[] tmpLayer ------------v\\n         int[] curLayer ----------> {...array #1...}\\n         int[] nextLayer ---------> {...array #2...}\\ncurLayer = nextLayer;\\n         int[] tmpLayer ----------> {...array #1...}\\n         int[] curLayer ------------v\\n         int[] nextLayer ---------> {...array #2...}\\nnextLayer = tmpLayer;\\n                             /----> {...array #1...}\\n         int[] curLayer ----(--\\\\\\n         int[] nextLayer --/    \\\\-> {...array #2...}\\n ```\\n**Use Arrays of primitive type instead of Lists for BFS layers:**  Arrays of primitive types such as `int`, `long`, `boolean`, `byte`, etc. are usually faster runtime than using List or other Collection data types, and are also faster than Arrays of objects such as `Integer`, `Long`, `Boolean`, `Byte`, etc.  Arrays are used in the code below to hold the layers of the Breadth First Search (BFS).  Arrays can be used because the maximum possible length needed for these arrays is known and is not extremely large.  In cases where the maximum possible length is unknown or is extremely large, a List would be better.  This is because an Array\\'s size can NOT be changed, while a List will expand in size as needed.\\n \\n The use of Arrays in the code below was a choice for optimizing for speed.  But Lists would be better for readability, maintaining code, simplifying code, and generally are considered a better programming practice.  In real-world programming, if the requirements have limits on runtime or memory size, Arrays and less readable code may be needed.  These types of speed and memory requirements often happen in real-time and embedded programming, and in some frequently called low-level run-time routines.\\n \\n\\n**If useful, please upvote.**\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int len = arr.length;\\n        if (len <= 1)  return 0;\\n        if (arr[0] == arr[len - 1])  return 1;\\n\\n        // Put all arr[] values in a HashMap so we can find matching values faster.\\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap();\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        list.add(0);\\n        map.put(arr[0], list);              // Add arr[0] to the HashMap.\\n        list = new ArrayList<Integer>();\\n        list.add(len - 1);\\n        map.put(arr[len - 1], list);        // Add arr[len - 1] to the HashMap.\\n        // Loop to add arr[1..len-2] to HashMap.\\n        for (int i = 1; i < len - 1; i++) { \\n            list = map.get(arr[i]);\\n            if (list == null) {             // If arr[i] not yet in HashMap...\\n                list = new ArrayList<Integer>();\\n                map.put(arr[i], list);\\n            }\\n            // Add arr[i] to the HashMap only if arr[i] is a different value from \\n            // arr[i-1] or arr[i+1].  Repeated consecutive values can be reduced \\n            // to only the first and last of those repeated consecutive values.  \\n            // Interior values of repeated consecutive values aren\\'t needed because \\n            // we want the minimum number of jumps and we could always jump from \\n            // the same arr[n] value to the start or the end of the same repeated \\n            // consecutive values.  Jumping to the middle of the repeated \\n            // consecutive values would increase the number of jumps beyond the \\n            // minimum number of jumps.  so we ignore interior values of repeated \\n            // consecutive values.  One leetcode test case has more than 49_000 \"7\"s \\n            // in a row.  We can ignore all but the first and last \"7\" of the \\n            // repeated consecutive \"7\"s, which makes the Breadth First Search much \\n            // faster.\\n            if (arr[i - 1] != arr[i] || arr[i + 1] != arr[i])\\n                list.add(i);\\n        }\\n        \\n        // Setup the Breadth First Search (BFS) values to start at the end-point \\n        // of the jumps (last index in arr[]) and work the jumps back to the \\n        // start-point of the jumps (index zero in arr[]).  This is faster than \\n        // going forward, because of test cases for this leetcode problem that \\n        // are designed to be more difficult when going forward.\\n        boolean[] used = new boolean[len];\\n        used[arr.length - 1] = true;\\n        int[] curLayer = new int[len];\\n        int curIdx = 0;\\n        curLayer[curIdx++] = arr.length - 1;\\n        int[] nextLayer = new int[len];\\n        int nextIdx = 0;\\n        int layerLevel = 1;\\n        int[] tmpLayer;\\n        \\n        // Loop until the Breadth First Search (BFS) finds its goal.  The goal is to \\n        // jump to index 0 in arr[] because we are doing the jumps from end-point \\n        // to start-point.\\n        while (true) {\\n            nextIdx = 0;\\n\\n            // Loop through all nodes in the current level of the BFS.\\n            for (int i1 = 0; i1 < curIdx; i1++) {\\n                int i = curLayer[i1];\\n                // Save jump to previous array index, unless we already visited the \\n                // previous array index, or we are at index 1 and therefore the previous \\n                // index is 0 which means that we end the search at index 0.\\n                if (i > 0 && !used[i - 1]) {\\n                    if (i == 1)  return layerLevel;\\n                    used[i - 1] = true;\\n                    nextLayer[nextIdx++] = i - 1;\\n                }\\n                // Save jump to next array index, unless we already visited the next \\n                // array index, or there is no next array index.\\n                if (i < arr.length - 1 && !used[i + 1]) {\\n                    used[i + 1] = true;\\n                    nextLayer[nextIdx++] = i + 1;\\n                }\\n                // Save jump to all other arr[] index that contain the same value as \\n                // arr[i] (the current array entry).  The HashMap contains a list of \\n                // arr[] indexes that contain the same value as arr[i].  If any of \\n                // these jumps are to index 0, then the Breadth First Search is done.\\n                ArrayList<Integer> sameNumIndexes = map.get(arr[i]);\\n                if (sameNumIndexes.size() > 1) {\\n                    for (int j : sameNumIndexes) {\\n                        if (!used[j]) {\\n                            if (j == 0)  return layerLevel;\\n                            used[j] = true;\\n                            nextLayer[nextIdx++] = j;\\n                        }\\n                    }\\n                }\\n                // sameNumIndexes.clear();\\n            }\\n            // Swap the lext level of the BFS to become the new current level of the \\n            // BFS for the next time through the main BFS loop.\\n            tmpLayer = curLayer;\\n            curLayer = nextLayer;\\n            nextLayer = tmpLayer;\\n            curIdx = nextIdx;\\n            layerLevel++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n         int[] curLayer ----------> {...array #1...}\\n         int[] nextLayer ---------> {...array #2...}\\ntmpLayer = curLayer;\\n         int[] tmpLayer ------------v\\n         int[] curLayer ----------> {...array #1...}\\n         int[] nextLayer ---------> {...array #2...}\\ncurLayer = nextLayer;\\n         int[] tmpLayer ----------> {...array #1...}\\n         int[] curLayer ------------v\\n         int[] nextLayer ---------> {...array #2...}\\nnextLayer = tmpLayer;\\n                             /----> {...array #1...}\\n         int[] curLayer ----(--\\\\\\n         int[] nextLayer --/    \\\\-> {...array #2...}\\n ```\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int len = arr.length;\\n        if (len <= 1)  return 0;\\n        if (arr[0] == arr[len - 1])  return 1;\\n\\n        // Put all arr[] values in a HashMap so we can find matching values faster.\\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap();\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        list.add(0);\\n        map.put(arr[0], list);              // Add arr[0] to the HashMap.\\n        list = new ArrayList<Integer>();\\n        list.add(len - 1);\\n        map.put(arr[len - 1], list);        // Add arr[len - 1] to the HashMap.\\n        // Loop to add arr[1..len-2] to HashMap.\\n        for (int i = 1; i < len - 1; i++) { \\n            list = map.get(arr[i]);\\n            if (list == null) {             // If arr[i] not yet in HashMap...\\n                list = new ArrayList<Integer>();\\n                map.put(arr[i], list);\\n            }\\n            // Add arr[i] to the HashMap only if arr[i] is a different value from \\n            // arr[i-1] or arr[i+1].  Repeated consecutive values can be reduced \\n            // to only the first and last of those repeated consecutive values.  \\n            // Interior values of repeated consecutive values aren\\'t needed because \\n            // we want the minimum number of jumps and we could always jump from \\n            // the same arr[n] value to the start or the end of the same repeated \\n            // consecutive values.  Jumping to the middle of the repeated \\n            // consecutive values would increase the number of jumps beyond the \\n            // minimum number of jumps.  so we ignore interior values of repeated \\n            // consecutive values.  One leetcode test case has more than 49_000 \"7\"s \\n            // in a row.  We can ignore all but the first and last \"7\" of the \\n            // repeated consecutive \"7\"s, which makes the Breadth First Search much \\n            // faster.\\n            if (arr[i - 1] != arr[i] || arr[i + 1] != arr[i])\\n                list.add(i);\\n        }\\n        \\n        // Setup the Breadth First Search (BFS) values to start at the end-point \\n        // of the jumps (last index in arr[]) and work the jumps back to the \\n        // start-point of the jumps (index zero in arr[]).  This is faster than \\n        // going forward, because of test cases for this leetcode problem that \\n        // are designed to be more difficult when going forward.\\n        boolean[] used = new boolean[len];\\n        used[arr.length - 1] = true;\\n        int[] curLayer = new int[len];\\n        int curIdx = 0;\\n        curLayer[curIdx++] = arr.length - 1;\\n        int[] nextLayer = new int[len];\\n        int nextIdx = 0;\\n        int layerLevel = 1;\\n        int[] tmpLayer;\\n        \\n        // Loop until the Breadth First Search (BFS) finds its goal.  The goal is to \\n        // jump to index 0 in arr[] because we are doing the jumps from end-point \\n        // to start-point.\\n        while (true) {\\n            nextIdx = 0;\\n\\n            // Loop through all nodes in the current level of the BFS.\\n            for (int i1 = 0; i1 < curIdx; i1++) {\\n                int i = curLayer[i1];\\n                // Save jump to previous array index, unless we already visited the \\n                // previous array index, or we are at index 1 and therefore the previous \\n                // index is 0 which means that we end the search at index 0.\\n                if (i > 0 && !used[i - 1]) {\\n                    if (i == 1)  return layerLevel;\\n                    used[i - 1] = true;\\n                    nextLayer[nextIdx++] = i - 1;\\n                }\\n                // Save jump to next array index, unless we already visited the next \\n                // array index, or there is no next array index.\\n                if (i < arr.length - 1 && !used[i + 1]) {\\n                    used[i + 1] = true;\\n                    nextLayer[nextIdx++] = i + 1;\\n                }\\n                // Save jump to all other arr[] index that contain the same value as \\n                // arr[i] (the current array entry).  The HashMap contains a list of \\n                // arr[] indexes that contain the same value as arr[i].  If any of \\n                // these jumps are to index 0, then the Breadth First Search is done.\\n                ArrayList<Integer> sameNumIndexes = map.get(arr[i]);\\n                if (sameNumIndexes.size() > 1) {\\n                    for (int j : sameNumIndexes) {\\n                        if (!used[j]) {\\n                            if (j == 0)  return layerLevel;\\n                            used[j] = true;\\n                            nextLayer[nextIdx++] = j;\\n                        }\\n                    }\\n                }\\n                // sameNumIndexes.clear();\\n            }\\n            // Swap the lext level of the BFS to become the new current level of the \\n            // BFS for the next time through the main BFS loop.\\n            tmpLayer = curLayer;\\n            curLayer = nextLayer;\\n            nextLayer = tmpLayer;\\n            curIdx = nextIdx;\\n            layerLevel++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258509,
                "title": "javascript-beats-100-runtime-167-ms",
                "content": "# Intuition\\nMy thought was to use a Breadth First Search (BFS) algorithm to solve this problem. This type of algorithm searches for a solution by exploring neighboring nodes before moving on to the next layer of nodes (step). The goal of this algorithm is to find the shortest path from the starting node to the destination node.\\n\\n# Approach\\nI used a Map to store the index of each element in the array, and then used a Set to keep track of the indexes that have already been checked. I performed a BFS traversal of the array, starting from the last element, and going towards the beginning. I used the Map to check if the current element had any jumps associated with it and add those indexes to the Set of next indexes to be checked. I also added the adjacent indexes to the Set of next indexes to be checked. Finally, I incremented the step count each time I traversed the array.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function (arr) {\\n    const targetIndex = arr.length - 1;\\n    if (targetIndex < 1) return 0;\\n\\n    const map = new Map();\\n    for (let i = 0; i < arr.length; i++) {\\n        if (!map.has(arr[i])) map.set(arr[i], []);\\n        map.get(arr[i]).push(i);\\n    }\\n\\n    let checkedIndexes = new Set();\\n    let stepCount = 0;\\n    let currentStepIndexes = new Set();\\n    currentStepIndexes.add(targetIndex);\\n    // from right to left. end to start. arr.length - 1 to 0\\n    while (currentStepIndexes.size > 0) {\\n        let nextStepIndexes = new Set();\\n        for (const currentStepIndex of currentStepIndexes.values()) {\\n            checkedIndexes.add(currentStepIndex);\\n\\n            if (currentStepIndex == 0) return stepCount;\\n            // -1\\n            if (currentStepIndex > 0 && !checkedIndexes.has(currentStepIndex - 1)) {\\n                if ((currentStepIndex - 1) == 0) return ++stepCount;\\n                nextStepIndexes.add(currentStepIndex - 1);\\n            }\\n            // jumps\\n            const jumps = map.get(arr[currentStepIndex]);\\n            if (jumps) {\\n                map.delete(arr[currentStepIndex]);\\n                let limit = 0;\\n                for (const jumpIndex of jumps) {\\n                    if (jumpIndex !== currentStepIndex && !checkedIndexes.has(jumpIndex)) {\\n                        limit++;\\n                        if (limit > 5) break;\\n                        if (jumpIndex == 0) return ++stepCount;\\n                        nextStepIndexes.add(jumpIndex);\\n                    }\\n                }\\n            }\\n            // +1\\n            if (currentStepIndex < targetIndex && !checkedIndexes.has(currentStepIndex + 1)) {\\n                nextStepIndexes.add(currentStepIndex + 1);\\n            }\\n        }\\n        currentStepIndexes = nextStepIndexes;\\n        stepCount++;\\n    }\\n    return stepCount;\\n}\\n```\\n\\n**If my work was useful for you, please upvote!**\\n\\n\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Shortest Path"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function (arr) {\\n    const targetIndex = arr.length - 1;\\n    if (targetIndex < 1) return 0;\\n\\n    const map = new Map();\\n    for (let i = 0; i < arr.length; i++) {\\n        if (!map.has(arr[i])) map.set(arr[i], []);\\n        map.get(arr[i]).push(i);\\n    }\\n\\n    let checkedIndexes = new Set();\\n    let stepCount = 0;\\n    let currentStepIndexes = new Set();\\n    currentStepIndexes.add(targetIndex);\\n    // from right to left. end to start. arr.length - 1 to 0\\n    while (currentStepIndexes.size > 0) {\\n        let nextStepIndexes = new Set();\\n        for (const currentStepIndex of currentStepIndexes.values()) {\\n            checkedIndexes.add(currentStepIndex);\\n\\n            if (currentStepIndex == 0) return stepCount;\\n            // -1\\n            if (currentStepIndex > 0 && !checkedIndexes.has(currentStepIndex - 1)) {\\n                if ((currentStepIndex - 1) == 0) return ++stepCount;\\n                nextStepIndexes.add(currentStepIndex - 1);\\n            }\\n            // jumps\\n            const jumps = map.get(arr[currentStepIndex]);\\n            if (jumps) {\\n                map.delete(arr[currentStepIndex]);\\n                let limit = 0;\\n                for (const jumpIndex of jumps) {\\n                    if (jumpIndex !== currentStepIndex && !checkedIndexes.has(jumpIndex)) {\\n                        limit++;\\n                        if (limit > 5) break;\\n                        if (jumpIndex == 0) return ++stepCount;\\n                        nextStepIndexes.add(jumpIndex);\\n                    }\\n                }\\n            }\\n            // +1\\n            if (currentStepIndex < targetIndex && !checkedIndexes.has(currentStepIndex + 1)) {\\n                nextStepIndexes.add(currentStepIndex + 1);\\n            }\\n        }\\n        currentStepIndexes = nextStepIndexes;\\n        stepCount++;\\n    }\\n    return stepCount;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502756,
                "title": "bfs-get-rid-of-tle",
                "content": "Naive implementation of BFS will get TLE, we can use two ways to get rid of TLE.\\n1) build the children nodes from highest index to lowest indes as highest index is close to target.\\n2) early pruning.\\n\\nI will explain those approach as follows.\\n\\n**1) build the children nodes from highest index to lowest indes**\\nTraverse nodes reversely to build the next children nodes during BFS process as our target is last element of the array and do the searching reversely will make the similar effect of A* algorithm. We search from the close to target element firstly.\\n\\nReversely works very good on the test case below\\n\\n[7,\\u2026,7,7,11] it has many 7s at the beginning of the list.\\n\\nPython code is here:\\n\\nThe critical part to get rid of TLE is using\\n\\na_i[arr[i]][::-1]\\n\\ninstead of a_i[arr[i]].\\n```python\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        a_i = collections.defaultdict(list)\\n        for i, a in enumerate(arr):\\n            a_i[a].append(i)\\n        def bfs():\\n            from collections import deque\\n            Q = deque([(0,0)])\\n            seen = {0}\\n            while Q:\\n                i, d = Q.popleft()\\n                if i==len(arr)-1:return d\\n                for j in [i-1, i+1]+a_i[arr[i]][::-1]:\\n                    if 0<=j<len(arr) and j!=i and j not in seen:\\n                        seen.add(j)\\n                        if j==len(arr)-1:return d+1\\n                        Q.append((j,d+1))\\n        return bfs()\\n```\\nC++ code is here.\\n```\\nclass Solution {\\n     vector<int> dir = {-1, 1};\\npublic:\\n     int bfs(int n,unordered_map<int, vector<int>> &a_i,vector<int>& arr){\\n            unordered_set<int> visited;\\n            deque<pair<int, int>> Q = {{0,0}};\\n            while(!Q.empty()){\\n                auto this_p = Q.front();\\n                Q.pop_front();\\n                int i=this_p.first, d= this_p.second;\\n                if (i == n-1)return d;\\n                for (auto &di:dir){\\n                    int j=i+di;\\n                    if(j>=0 && j<n){\\n                        //if(j==this_p.first)continue;\\n                        auto it=visited.find(j);\\n                        if(it==visited.end()){\\n                            if(j==n-1)return d+1;\\n                            visited.insert(j);\\n                            Q.emplace_back(j, d+1);\\n                    }\\n                }\\n                }\\n                \\n                for (auto &j:a_i[arr[i]]){\\n                    if(j==i)continue;\\n                    auto it=visited.find(j);\\n                    if(it==visited.end()){\\n                        if(j==n-1)return d+1;\\n                        visited.insert(j);\\n                        Q.emplace_back(make_pair(j, d+1));\\n                    }\\n                }\\n                \\n            }\\n         return 0;\\n        }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> a_i;\\n        int n = arr.size();\\n        /*\\n         // traverse in order get TLE at the fllowing case:\\n         [7,..7,11]\\n        for(int i=0;i<n;++i){\\n            a_i[arr[i]].push_back(i);\\n        }\\n        */\\n        \\n        // traverse reversely\\n        for(int i=n-1;i>=0;--i){\\n            a_i[arr[i]].push_back(i);\\n        }\\n        \\n       \\n        return bfs(n, a_i,arr);\\n    }\\n};\\n```\\n\\n**2) early pruning.**\\nWe can also get rid of TLE by early pruning.\\nSuch as in the following example, the bolded 23 is unnecessary to be explored, we can safely remove it from candidates during early stage.\\n[100,-23,-23,404,100,23,**23**,23,3,404]\\nPython code\\n```python\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        a_i_,a_i = collections.defaultdict(list),collections.defaultdict(list)\\n        for i, a in enumerate(arr):\\n            a_i_[a].append(i)\\n        #early pruning.\\n        for key in a_i_:\\n            for j, v in enumerate(a_i_[key]):\\n                #print(j,v)\\n                if j>=1 and j<len(a_i_[key])-1 and a_i_[key][j-1]==v-1 and a_i_[key][j+1]==v+1:continue\\n                a_i[key].append(v)\\n        def bfs():\\n            from collections import deque\\n            Q = deque([(0,0)])\\n            seen = {0}\\n            while Q:\\n                i, d = Q.popleft()\\n                if i==len(arr)-1:return d\\n                for j in [i-1, i+1]+a_i[arr[i]]:\\n                    if 0<=j<len(arr) and j!=i and j not in seen:\\n                        seen.add(j)\\n                        if j==len(arr)-1:return d+1\\n                        Q.append((j,d+1))\\n        return bfs()\\n```\\nC++ code\\n```\\nclass Solution {\\n     vector<int> dir = {-1, 1};\\npublic:\\n     int bfs(int n,unordered_map<int, vector<int>> &a_i,vector<int>& arr){\\n            unordered_set<int> visited;\\n            deque<pair<int, int>> Q = {{0,0}};\\n            while(!Q.empty()){\\n                auto this_p = Q.front();\\n                Q.pop_front();\\n                int i=this_p.first, d= this_p.second;\\n                if (i == n-1)return d;\\n                for (auto &di:dir){\\n                    int j=i+di;\\n                    if(j>=0 && j<n){\\n                        //if(j==this_p.first)continue;\\n                        auto it=visited.find(j);\\n                        if(it==visited.end()){\\n                            if(j==n-1)return d+1;\\n                            visited.insert(j);\\n                            Q.emplace_back(j, d+1);\\n                    }\\n                }\\n                }\\n                \\n                for (auto &j:a_i[arr[i]]){\\n                    if(j==i)continue;\\n                    auto it=visited.find(j);\\n                    if(it==visited.end()){\\n                        if(j==n-1)return d+1;\\n                        visited.insert(j);\\n                        Q.emplace_back(make_pair(j, d+1));\\n                    }\\n                }\\n                \\n            }\\n         return 0;\\n        }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> a_i;\\n        int n = arr.size();\\n        /*\\n         // traverse in order get TLE at the fllowing case:\\n         [7,..7,11]\\n        for(int i=0;i<n;++i){\\n            a_i[arr[i]].push_back(i);\\n        }\\n        */\\n         \\n         // traverse in order get TLE, prune unnesessary nodes can get AC\\n         //[7,..7,11]\\n        unordered_map<int, vector<int>> a_i_;\\n        for(int i=0;i<n;++i){\\n            a_i_[arr[i]].push_back(i);\\n        }\\n        \\n        for(auto it=a_i_.begin();it!=a_i_.end();++it){\\n            int k=it->first;\\n            for(int j=0;j<a_i_[k].size();++j){\\n                if(j>=1 && j<a_i_[k].size()-1 && a_i_[k][j+1]==a_i_[k][j]+1 &&a_i_[k][j-1]==a_i_[k][j]-1)continue;\\n                a_i[k].push_back(a_i_[k][j]);\\n            }\\n        }\\n        /*\\n        // traverse reversely\\n        for(int i=n-1;i>=0;--i){\\n            a_i_[arr[i]].push_back(i);\\n        }\\n        */\\n        \\n       \\n        return bfs(n, a_i,arr);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        a_i = collections.defaultdict(list)\\n        for i, a in enumerate(arr):\\n            a_i[a].append(i)\\n        def bfs():\\n            from collections import deque\\n            Q = deque([(0,0)])\\n            seen = {0}\\n            while Q:\\n                i, d = Q.popleft()\\n                if i==len(arr)-1:return d\\n                for j in [i-1, i+1]+a_i[arr[i]][::-1]:\\n                    if 0<=j<len(arr) and j!=i and j not in seen:\\n                        seen.add(j)\\n                        if j==len(arr)-1:return d+1\\n                        Q.append((j,d+1))\\n        return bfs()\\n```\n```\\nclass Solution {\\n     vector<int> dir = {-1, 1};\\npublic:\\n     int bfs(int n,unordered_map<int, vector<int>> &a_i,vector<int>& arr){\\n            unordered_set<int> visited;\\n            deque<pair<int, int>> Q = {{0,0}};\\n            while(!Q.empty()){\\n                auto this_p = Q.front();\\n                Q.pop_front();\\n                int i=this_p.first, d= this_p.second;\\n                if (i == n-1)return d;\\n                for (auto &di:dir){\\n                    int j=i+di;\\n                    if(j>=0 && j<n){\\n                        //if(j==this_p.first)continue;\\n                        auto it=visited.find(j);\\n                        if(it==visited.end()){\\n                            if(j==n-1)return d+1;\\n                            visited.insert(j);\\n                            Q.emplace_back(j, d+1);\\n                    }\\n                }\\n                }\\n                \\n                for (auto &j:a_i[arr[i]]){\\n                    if(j==i)continue;\\n                    auto it=visited.find(j);\\n                    if(it==visited.end()){\\n                        if(j==n-1)return d+1;\\n                        visited.insert(j);\\n                        Q.emplace_back(make_pair(j, d+1));\\n                    }\\n                }\\n                \\n            }\\n         return 0;\\n        }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> a_i;\\n        int n = arr.size();\\n        /*\\n         // traverse in order get TLE at the fllowing case:\\n         [7,..7,11]\\n        for(int i=0;i<n;++i){\\n            a_i[arr[i]].push_back(i);\\n        }\\n        */\\n        \\n        // traverse reversely\\n        for(int i=n-1;i>=0;--i){\\n            a_i[arr[i]].push_back(i);\\n        }\\n        \\n       \\n        return bfs(n, a_i,arr);\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        a_i_,a_i = collections.defaultdict(list),collections.defaultdict(list)\\n        for i, a in enumerate(arr):\\n            a_i_[a].append(i)\\n        #early pruning.\\n        for key in a_i_:\\n            for j, v in enumerate(a_i_[key]):\\n                #print(j,v)\\n                if j>=1 and j<len(a_i_[key])-1 and a_i_[key][j-1]==v-1 and a_i_[key][j+1]==v+1:continue\\n                a_i[key].append(v)\\n        def bfs():\\n            from collections import deque\\n            Q = deque([(0,0)])\\n            seen = {0}\\n            while Q:\\n                i, d = Q.popleft()\\n                if i==len(arr)-1:return d\\n                for j in [i-1, i+1]+a_i[arr[i]]:\\n                    if 0<=j<len(arr) and j!=i and j not in seen:\\n                        seen.add(j)\\n                        if j==len(arr)-1:return d+1\\n                        Q.append((j,d+1))\\n        return bfs()\\n```\n```\\nclass Solution {\\n     vector<int> dir = {-1, 1};\\npublic:\\n     int bfs(int n,unordered_map<int, vector<int>> &a_i,vector<int>& arr){\\n            unordered_set<int> visited;\\n            deque<pair<int, int>> Q = {{0,0}};\\n            while(!Q.empty()){\\n                auto this_p = Q.front();\\n                Q.pop_front();\\n                int i=this_p.first, d= this_p.second;\\n                if (i == n-1)return d;\\n                for (auto &di:dir){\\n                    int j=i+di;\\n                    if(j>=0 && j<n){\\n                        //if(j==this_p.first)continue;\\n                        auto it=visited.find(j);\\n                        if(it==visited.end()){\\n                            if(j==n-1)return d+1;\\n                            visited.insert(j);\\n                            Q.emplace_back(j, d+1);\\n                    }\\n                }\\n                }\\n                \\n                for (auto &j:a_i[arr[i]]){\\n                    if(j==i)continue;\\n                    auto it=visited.find(j);\\n                    if(it==visited.end()){\\n                        if(j==n-1)return d+1;\\n                        visited.insert(j);\\n                        Q.emplace_back(make_pair(j, d+1));\\n                    }\\n                }\\n                \\n            }\\n         return 0;\\n        }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> a_i;\\n        int n = arr.size();\\n        /*\\n         // traverse in order get TLE at the fllowing case:\\n         [7,..7,11]\\n        for(int i=0;i<n;++i){\\n            a_i[arr[i]].push_back(i);\\n        }\\n        */\\n         \\n         // traverse in order get TLE, prune unnesessary nodes can get AC\\n         //[7,..7,11]\\n        unordered_map<int, vector<int>> a_i_;\\n        for(int i=0;i<n;++i){\\n            a_i_[arr[i]].push_back(i);\\n        }\\n        \\n        for(auto it=a_i_.begin();it!=a_i_.end();++it){\\n            int k=it->first;\\n            for(int j=0;j<a_i_[k].size();++j){\\n                if(j>=1 && j<a_i_[k].size()-1 && a_i_[k][j+1]==a_i_[k][j]+1 &&a_i_[k][j-1]==a_i_[k][j]-1)continue;\\n                a_i[k].push_back(a_i_[k][j]);\\n            }\\n        }\\n        /*\\n        // traverse reversely\\n        for(int i=n-1;i>=0;--i){\\n            a_i_[arr[i]].push_back(i);\\n        }\\n        */\\n        \\n       \\n        return bfs(n, a_i,arr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260466,
                "title": "solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>>mp;\\n        for (int i = 0; i < n; i++) mp[arr[i]].push_back(i);\\n        \\n        queue<int>q;\\n        vector<bool>visited(n, false);\\n        q.push(0);\\n        int steps = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                int currIdx = q.front();\\n                q.pop();\\n                if (currIdx == n - 1) return steps;\\n                if (currIdx + 1 < n && !visited[currIdx + 1]) \\n                {\\n                    visited[currIdx + 1] = true;\\n                    q.push(currIdx + 1);\\n                }\\n                if (currIdx - 1 >= 0 && !visited[currIdx - 1]) \\n                {\\n                    visited[currIdx - 1] = true;\\n                    q.push(currIdx - 1);\\n                }\\n                for (int newIdx : mp[arr[currIdx]])  \\n                {                                \\n                    if (!visited[newIdx]) \\n                    {\\n                        visited[newIdx] = true;\\n                        q.push(newIdx);\\n                    }\\n                }\\n                \\n                mp[arr[currIdx]].clear();    \\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>>mp;\\n        for (int i = 0; i < n; i++) mp[arr[i]].push_back(i);\\n        \\n        queue<int>q;\\n        vector<bool>visited(n, false);\\n        q.push(0);\\n        int steps = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                int currIdx = q.front();\\n                q.pop();\\n                if (currIdx == n - 1) return steps;\\n                if (currIdx + 1 < n && !visited[currIdx + 1]) \\n                {\\n                    visited[currIdx + 1] = true;\\n                    q.push(currIdx + 1);\\n                }\\n                if (currIdx - 1 >= 0 && !visited[currIdx - 1]) \\n                {\\n                    visited[currIdx - 1] = true;\\n                    q.push(currIdx - 1);\\n                }\\n                for (int newIdx : mp[arr[currIdx]])  \\n                {                                \\n                    if (!visited[newIdx]) \\n                    {\\n                        visited[newIdx] = true;\\n                        q.push(newIdx);\\n                    }\\n                }\\n                \\n                mp[arr[currIdx]].clear();    \\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694469,
                "title": "why-dp-memoization-is-not-working",
                "content": "I was wondering why DP + Memo is not working , however recursive solution gives TLE. I don\\'t know why the simple memoization technique is not working.Here is my code. Please help - \\n```\\npublic static int minJumpsv2(int[] arr) {\\n        HashMap<Integer, List<Integer>> hm = new HashMap<>();\\n        boolean [] visited = new boolean[arr.length];\\n        int [] dp = new int[arr.length];\\n        Arrays.fill(dp,-1);\\n        Arrays.fill(visited,false);\\n        for (int i=0;i<arr.length;i++) hm.computeIfAbsent(arr[i],v -> new ArrayList<>()).add(i);\\n        return helperv2(arr,0,hm,visited,dp);\\n    }\\n\\t\\n\\tpublic static int helperv2(int [] arr, int i,HashMap<Integer,List<Integer>> hm,boolean [] visited,int[] dp){\\n        if (i<0 || i>=arr.length || visited[i]) return Integer.MAX_VALUE;\\n        if (i== arr.length-1)return 0;\\n        if (dp[i] != -1)return dp[i];\\n        visited[i] = true;\\n        int p1 = helperv2(arr,i+1,hm,visited,dp); \\n        int p2 = helperv2(arr,i-1,hm,visited,dp);\\n        int p3 = Integer.MAX_VALUE;\\n        if (hm.containsKey(arr[i])){\\n            List<Integer> list = hm.get(arr[i]);\\n            for (int index : list) p3 = Math.min(p3,helperv2(arr,index,hm,visited,dp));\\n        }\\n        visited[i] = false;\\n        int min = Math.min(p1, Math.min(p2, p3));\\n        dp[i] = min==Integer.MAX_VALUE ? 0 : min+1;\\n        return dp[i];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\npublic static int minJumpsv2(int[] arr) {\\n        HashMap<Integer, List<Integer>> hm = new HashMap<>();\\n        boolean [] visited = new boolean[arr.length];\\n        int [] dp = new int[arr.length];\\n        Arrays.fill(dp,-1);\\n        Arrays.fill(visited,false);\\n        for (int i=0;i<arr.length;i++) hm.computeIfAbsent(arr[i],v -> new ArrayList<>()).add(i);\\n        return helperv2(arr,0,hm,visited,dp);\\n    }\\n\\t\\n\\tpublic static int helperv2(int [] arr, int i,HashMap<Integer,List<Integer>> hm,boolean [] visited,int[] dp){\\n        if (i<0 || i>=arr.length || visited[i]) return Integer.MAX_VALUE;\\n        if (i== arr.length-1)return 0;\\n        if (dp[i] != -1)return dp[i];\\n        visited[i] = true;\\n        int p1 = helperv2(arr,i+1,hm,visited,dp); \\n        int p2 = helperv2(arr,i-1,hm,visited,dp);\\n        int p3 = Integer.MAX_VALUE;\\n        if (hm.containsKey(arr[i])){\\n            List<Integer> list = hm.get(arr[i]);\\n            for (int index : list) p3 = Math.min(p3,helperv2(arr,index,hm,visited,dp));\\n        }\\n        visited[i] = false;\\n        int min = Math.min(p1, Math.min(p2, p3));\\n        dp[i] = min==Integer.MAX_VALUE ? 0 : min+1;\\n        return dp[i];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 507950,
                "title": "java-bidirectional-bfs",
                "content": "Maintain two queue from head and tail of the array respectively, pick the one with smaller size each time to do the BFS until they meet at the middle.\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int res = 0, n = arr.length;\\n        if(n == 1){\\n            return 0;\\n        }\\n        boolean[] visited = new boolean[n];\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            map.putIfAbsent(arr[i], new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        }\\n        Set<Integer> head = new HashSet<>(), tail = new HashSet<>();\\n        head.add(0);\\n        tail.add(n - 1);\\n        visited[0] = true;\\n        visited[n - 1] = true;\\n        while(head.size() > 0 && tail.size() > 0){\\n            if(head.size() > tail.size()){\\n                Set<Integer> temp = tail;\\n                tail = head;\\n                head = temp;\\n            }\\n            Set<Integer> next = new HashSet<>();\\n            for(int i : head){\\n                int x = i + 1, y = i - 1;\\n                if(tail.contains(x) || tail.contains(y)){\\n                    return res + 1;\\n                }\\n                if(x < n && !visited[x]){\\n                    visited[x] = true;\\n                    next.add(x);\\n                }\\n                if(y >= 0 && !visited[y]){\\n                    visited[y] = true;\\n                    next.add(y);\\n                }\\n                for(int z : map.get(arr[i])){\\n                    if(z == i){\\n                        continue;\\n                    }\\n                    if(tail.contains(z)){\\n                        return res + 1;\\n                    }\\n                    if(!visited[z]){\\n                        visited[z] = true;\\n                        next.add(z);\\n                    }\\n                }\\n            }\\n            head = next;\\n            res++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int res = 0, n = arr.length;\\n        if(n == 1){\\n            return 0;\\n        }\\n        boolean[] visited = new boolean[n];\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            map.putIfAbsent(arr[i], new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        }\\n        Set<Integer> head = new HashSet<>(), tail = new HashSet<>();\\n        head.add(0);\\n        tail.add(n - 1);\\n        visited[0] = true;\\n        visited[n - 1] = true;\\n        while(head.size() > 0 && tail.size() > 0){\\n            if(head.size() > tail.size()){\\n                Set<Integer> temp = tail;\\n                tail = head;\\n                head = temp;\\n            }\\n            Set<Integer> next = new HashSet<>();\\n            for(int i : head){\\n                int x = i + 1, y = i - 1;\\n                if(tail.contains(x) || tail.contains(y)){\\n                    return res + 1;\\n                }\\n                if(x < n && !visited[x]){\\n                    visited[x] = true;\\n                    next.add(x);\\n                }\\n                if(y >= 0 && !visited[y]){\\n                    visited[y] = true;\\n                    next.add(y);\\n                }\\n                for(int z : map.get(arr[i])){\\n                    if(z == i){\\n                        continue;\\n                    }\\n                    if(tail.contains(z)){\\n                        return res + 1;\\n                    }\\n                    if(!visited[z]){\\n                        visited[z] = true;\\n                        next.add(z);\\n                    }\\n                }\\n            }\\n            head = next;\\n            res++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502972,
                "title": "javascript-bfs-better-than-100",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function(arr) {\\n  if (arr.length === 1) return 0;\\n  const sameValIdx = new Map();\\n  for (let i = arr.length - 1; i >= 0; i--) {\\n    const val = arr[i];\\n    if (!sameValIdx.has(val)) sameValIdx.set(val, []);\\n    sameValIdx.get(val).push(i);\\n  }\\n  \\n  const seen = new Set();\\n  seen.add(0);\\n  const queue = [[0, 0]];\\n  while (queue.length) {\\n    const [idx, step] = queue.shift();\\n    \\n    if (idx - 1 >= 0 && !seen.has(idx - 1)) {\\n      queue.push([idx - 1, step + 1]);\\n      seen.add(idx - 1);\\n    }\\n    if (idx + 1 < arr.length && !seen.has(idx + 1)) {\\n      if (idx + 1 === arr.length - 1) return step + 1; // You have to check here to handle this case [7,7,7,7,7...]\\n      queue.push([idx + 1, step + 1]);\\n      seen.add(idx + 1);\\n    }\\n    \\n    const targetArr = sameValIdx.get(arr[idx]);\\n    for (let j = 0; j < targetArr.length; j++) {\\n      const i = targetArr[j];\\n      if (!seen.has(i) && i !== idx - 1 && i !== idx + 1) {\\n        if (i === arr.length - 1) return step + 1; // You have to check here to handle this case [7,7,7,7,7...]\\n        queue.push([i, step + 1]);\\n        seen.add(i);\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function(arr) {\\n  if (arr.length === 1) return 0;\\n  const sameValIdx = new Map();\\n  for (let i = arr.length - 1; i >= 0; i--) {\\n    const val = arr[i];\\n    if (!sameValIdx.has(val)) sameValIdx.set(val, []);\\n    sameValIdx.get(val).push(i);\\n  }\\n  \\n  const seen = new Set();\\n  seen.add(0);\\n  const queue = [[0, 0]];\\n  while (queue.length) {\\n    const [idx, step] = queue.shift();\\n    \\n    if (idx - 1 >= 0 && !seen.has(idx - 1)) {\\n      queue.push([idx - 1, step + 1]);\\n      seen.add(idx - 1);\\n    }\\n    if (idx + 1 < arr.length && !seen.has(idx + 1)) {\\n      if (idx + 1 === arr.length - 1) return step + 1; // You have to check here to handle this case [7,7,7,7,7...]\\n      queue.push([idx + 1, step + 1]);\\n      seen.add(idx + 1);\\n    }\\n    \\n    const targetArr = sameValIdx.get(arr[idx]);\\n    for (let j = 0; j < targetArr.length; j++) {\\n      const i = targetArr[j];\\n      if (!seen.has(i) && i !== idx - 1 && i !== idx + 1) {\\n        if (i === arr.length - 1) return step + 1; // You have to check here to handle this case [7,7,7,7,7...]\\n        queue.push([i, step + 1]);\\n        seen.add(i);\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502765,
                "title": "c-bfs-greedy",
                "content": "* Precompute in map value to list of indices\\n* Greedily try to take the farthest node \\n\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        queue<pair<int, int>> q;\\n        unordered_map<int, vector<int>> mp;\\n        for(int i = 0; i < arr.size(); i++)\\n            mp[arr[i]].push_back(i);\\n        int n = arr.size();\\n        vector<int> vis(n, false);\\n        q.push({ n - 1, 0 });\\n        vis[n - 1] = 1;\\n        int steps = 0;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n\\t\\t\\tint f = q.front().first;\\n\\t\\t\\tint steps = q.front().second;\\n\\t\\t\\tq.pop();\\n\\t\\t\\tif(f == 0)\\n\\t\\t\\t\\treturn steps;\\n\\t\\t\\tif(f - 1 >= 0 && !vis[f - 1]) {\\n\\t\\t\\t\\tq.push({ f - 1, steps + 1 });\\n\\t\\t\\t\\tvis[f - 1] = true;\\n\\t\\t\\t}\\n\\t\\t\\tif(f + 1 < n && !vis[f + 1]) {\\n\\t\\t\\t\\tq.push({ f + 1, steps + 1 });\\n\\t\\t\\t\\tvis[f + 1] = true;\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto j : mp[arr[f]]) {\\n\\t\\t\\t\\tif(j == f)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif(!vis[j]) {\\n\\t\\t\\t\\t\\tvis[j] = true;\\n\\t\\t\\t\\t\\tq.push({ j, steps + 1 });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        }\\n        return -1; \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        queue<pair<int, int>> q;\\n        unordered_map<int, vector<int>> mp;\\n        for(int i = 0; i < arr.size(); i++)\\n            mp[arr[i]].push_back(i);\\n        int n = arr.size();\\n        vector<int> vis(n, false);\\n        q.push({ n - 1, 0 });\\n        vis[n - 1] = 1;\\n        int steps = 0;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n\\t\\t\\tint f = q.front().first;\\n\\t\\t\\tint steps = q.front().second;\\n\\t\\t\\tq.pop();\\n\\t\\t\\tif(f == 0)\\n\\t\\t\\t\\treturn steps;\\n\\t\\t\\tif(f - 1 >= 0 && !vis[f - 1]) {\\n\\t\\t\\t\\tq.push({ f - 1, steps + 1 });\\n\\t\\t\\t\\tvis[f - 1] = true;\\n\\t\\t\\t}\\n\\t\\t\\tif(f + 1 < n && !vis[f + 1]) {\\n\\t\\t\\t\\tq.push({ f + 1, steps + 1 });\\n\\t\\t\\t\\tvis[f + 1] = true;\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto j : mp[arr[f]]) {\\n\\t\\t\\t\\tif(j == f)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif(!vis[j]) {\\n\\t\\t\\t\\t\\tvis[j] = true;\\n\\t\\t\\t\\t\\tq.push({ j, steps + 1 });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        }\\n        return -1; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259383,
                "title": "very-easy-100-easiest-logic-ever-fully-explained-step-by-step-c-javascript-java-python",
                "content": "# Intuition\\nThe main idea is to build a graph where each node represents a value in the input array, and each edge represents a connection between two indexes with the same value or between two adjacent indexes. Then, we perform a Breadth-First Search (BFS) starting from index 0 to find the shortest path to the last index, where each step corresponds to a jump.\\n\\n# Approach\\nIn this implementation, we use a Map object to represent the graph, a jumps array to keep track of the minimum number of jumps to reach each index, and a queue q to store the indexes to visit. We initialize the jumps array to -1, except for the first index which has a free jump. We also delete the nodes from the graph as we visit them to avoid revisiting them.\\n\\n# Complexity\\n- Time complexity:\\nThis solution has a time complexity of O(n + k log k), where n is the length of the input array and k is the number of distinct values in the array. \\n- Space complexity:\\nThe space complexity is also O(n + k), to store the graph and the jumps array.\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\n\\nvar minJumps = function(arr) {\\n    const n = arr.length;\\n    if (n === 1) return 0; // edge case: only one element, no jumps needed\\n    const jumps = new Array(n).fill(-1); // initialize jumps array to -1\\n    const graph = new Map(); // create a map to represent the graph of connections\\n    for (let i = 0; i < n; i++) {\\n        if (!graph.has(arr[i])) graph.set(arr[i], []);\\n        graph.get(arr[i]).push(i); // add current index to the list of indexes with the same value\\n    }\\n    const q = [0]; // start BFS from index 0\\n    jumps[0] = 0; // first jump is free\\n    while (q.length > 0) {\\n        const currIndex = q.shift();\\n        const currValue = arr[currIndex];\\n        const neighbors = graph.get(currValue);\\n        if (neighbors) { // add a check for truthy value\\n            for (const neighborIndex of neighbors) {\\n                if (jumps[neighborIndex] === -1) { // if neighbor has not been visited yet\\n                    jumps[neighborIndex] = jumps[currIndex] + 1; // update number of jumps\\n                    q.push(neighborIndex); // add neighbor to the queue\\n                }\\n            }\\n            graph.delete(currValue); // remove current value from the graph to avoid revisiting it\\n        }\\n        if (currIndex - 1 >= 0 && jumps[currIndex - 1] === -1) { // check left neighbor\\n            jumps[currIndex - 1] = jumps[currIndex] + 1; // update number of jumps\\n            q.push(currIndex - 1); // add left neighbor to the queue\\n        }\\n        if (currIndex + 1 < n && jumps[currIndex + 1] === -1) { // check right neighbor\\n            jumps[currIndex + 1] = jumps[currIndex] + 1; // update number of jumps\\n            q.push(currIndex + 1); // add right neighbor to the queue\\n        }\\n    }\\n    return jumps[n - 1]; // return minimum number of jumps to reach the last index\\n};\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/67e34a02-d9d5-4376-a343-20c2fad7b455_1678004108.3564777.png)\\n\\n# Please Upvote\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\n\\nvar minJumps = function(arr) {\\n    const n = arr.length;\\n    if (n === 1) return 0; // edge case: only one element, no jumps needed\\n    const jumps = new Array(n).fill(-1); // initialize jumps array to -1\\n    const graph = new Map(); // create a map to represent the graph of connections\\n    for (let i = 0; i < n; i++) {\\n        if (!graph.has(arr[i])) graph.set(arr[i], []);\\n        graph.get(arr[i]).push(i); // add current index to the list of indexes with the same value\\n    }\\n    const q = [0]; // start BFS from index 0\\n    jumps[0] = 0; // first jump is free\\n    while (q.length > 0) {\\n        const currIndex = q.shift();\\n        const currValue = arr[currIndex];\\n        const neighbors = graph.get(currValue);\\n        if (neighbors) { // add a check for truthy value\\n            for (const neighborIndex of neighbors) {\\n                if (jumps[neighborIndex] === -1) { // if neighbor has not been visited yet\\n                    jumps[neighborIndex] = jumps[currIndex] + 1; // update number of jumps\\n                    q.push(neighborIndex); // add neighbor to the queue\\n                }\\n            }\\n            graph.delete(currValue); // remove current value from the graph to avoid revisiting it\\n        }\\n        if (currIndex - 1 >= 0 && jumps[currIndex - 1] === -1) { // check left neighbor\\n            jumps[currIndex - 1] = jumps[currIndex] + 1; // update number of jumps\\n            q.push(currIndex - 1); // add left neighbor to the queue\\n        }\\n        if (currIndex + 1 < n && jumps[currIndex + 1] === -1) { // check right neighbor\\n            jumps[currIndex + 1] = jumps[currIndex] + 1; // update number of jumps\\n            q.push(currIndex + 1); // add right neighbor to the queue\\n        }\\n    }\\n    return jumps[n - 1]; // return minimum number of jumps to reach the last index\\n};\\n\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3257984,
                "title": "jump-game-iv-solving-the-leetcode-challenge-march-5-2023-fully-explained",
                "content": "![image.png](https://assets.leetcode.com/users/images/d5bd5c46-5f44-4fa7-820f-dd165a96fb91_1677816522.0925934.png)\\n\\n# Full explaination at : [Solution](https://yoichiisagi.hashnode.dev/jump-game-iv-solving-the-leetcode-challenge-march-5-2023)\\n\\n![image.png](https://assets.leetcode.com/users/images/6907ce4f-a766-4668-bd51-1cedade65e46_1677816533.0083919.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic int minJumps(int[] arr) {\\n    int n = arr.length;\\n    if(n == 1) return 0;\\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n    for(int i = 0; i < n; i++) {\\n        List<Integer> list = map.get(arr[i]);\\n        if(list == null) map.put(arr[i], list = new ArrayList<>());\\n        list.add(i);\\n    }\\n    int[] visited = new int[n];\\n    Deque<Integer> forward = new LinkedList<>(), backward = new LinkedList<>();\\n    visited[0] = 1;\\n    forward.add(0);\\n    visited[n - 1] = 2;\\n    backward.add(n - 1);\\n    for(int res = 1, dir = 1; ; res++) {\\n        if(forward.size() > backward.size()) {\\n            Deque<Integer> temp = forward; forward = backward; backward = temp;\\n            dir = 3 - dir;\\n        }\\n        for(int size = forward.size(); size-- > 0; ) {\\n            int i = forward.poll();\\n            List<Integer> list = map.get(arr[i]);\\n            if(i - 1 >= 0) list.add(i - 1);\\n            if(i + 1 < n) list.add(i + 1);\\n            for(int j: list) {\\n                if(visited[j] == 0) {\\n                    visited[j] = dir;\\n                    forward.add(j);\\n                } else if(visited[j] != dir) return res;\\n            }\\n            list.clear();\\n        }\\n    }\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int minJumps(int[] arr) {\\n    int n = arr.length;\\n    if(n == 1) return 0;\\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n    for(int i = 0; i < n; i++) {\\n        List<Integer> list = map.get(arr[i]);\\n        if(list == null) map.put(arr[i], list = new ArrayList<>());\\n        list.add(i);\\n    }\\n    int[] visited = new int[n];\\n    Deque<Integer> forward = new LinkedList<>(), backward = new LinkedList<>();\\n    visited[0] = 1;\\n    forward.add(0);\\n    visited[n - 1] = 2;\\n    backward.add(n - 1);\\n    for(int res = 1, dir = 1; ; res++) {\\n        if(forward.size() > backward.size()) {\\n            Deque<Integer> temp = forward; forward = backward; backward = temp;\\n            dir = 3 - dir;\\n        }\\n        for(int size = forward.size(); size-- > 0; ) {\\n            int i = forward.poll();\\n            List<Integer> list = map.get(arr[i]);\\n            if(i - 1 >= 0) list.add(i - 1);\\n            if(i + 1 < n) list.add(i + 1);\\n            for(int j: list) {\\n                if(visited[j] == 0) {\\n                    visited[j] = dir;\\n                    forward.add(j);\\n                } else if(visited[j] != dir) return res;\\n            }\\n            list.clear();\\n        }\\n    }\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691100,
                "title": "this-solution-is-what-you-are-looking-for-unordered-map-int-vector-int-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        map<int,vector<int>> mp;\\n        \\n        for(int i=0;i<arr.size();i++)\\n            mp[arr[i]].push_back(i);\\n\\n        int ans = -1;\\n        queue<int> q;\\n        q.push(0);\\n\\n        while(q.size()){\\n            int sz = q.size();\\n            ans++;\\n            while(sz--){\\n                auto idx = q.front(); q.pop();\\n\\n                if(idx == arr.size()-1) return ans;\\n\\n                if(idx+1 < arr.size() and mp.count(arr[idx+1]))\\n                    q.push(idx+1);\\n\\n                if(idx-1 >= 0 and mp.count(arr[idx-1]))\\n                    q.push(idx-1);\\n\\n                for(auto nextIdx : mp[arr[idx]]){\\n                    if(idx == nextIdx) continue;\\n                    q.push(nextIdx);\\n                }\\n\\n                mp.erase(arr[idx]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        map<int,vector<int>> mp;\\n        \\n        for(int i=0;i<arr.size();i++)\\n            mp[arr[i]].push_back(i);\\n\\n        int ans = -1;\\n        queue<int> q;\\n        q.push(0);\\n\\n        while(q.size()){\\n            int sz = q.size();\\n            ans++;\\n            while(sz--){\\n                auto idx = q.front(); q.pop();\\n\\n                if(idx == arr.size()-1) return ans;\\n\\n                if(idx+1 < arr.size() and mp.count(arr[idx+1]))\\n                    q.push(idx+1);\\n\\n                if(idx-1 >= 0 and mp.count(arr[idx-1]))\\n                    q.push(idx-1);\\n\\n                for(auto nextIdx : mp[arr[idx]]){\\n                    if(idx == nextIdx) continue;\\n                    q.push(nextIdx);\\n                }\\n\\n                mp.erase(arr[idx]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696842,
                "title": "python-bfs-solution",
                "content": "```python\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for i in range(len(arr)):\\n            graph[arr[i]].append(i)\\n            \\n        visited = set()\\n        src,dest = 0,len(arr)-1\\n        queue = deque()\\n        queue.append((src,0))\\n        visited.add(src)\\n        while queue:\\n            node,dist = queue.popleft()\\n            if node == dest:\\n                return dist\\n            for child in [node-1, node+1] + graph[arr[node]][::-1]:\\n                if 0 <= child < len(arr) and child != node and child not in visited:\\n                    visited.add(child)\\n                    if child == dest:\\n                        return dist+1\\n                    queue.append((child,dist+1))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for i in range(len(arr)):\\n            graph[arr[i]].append(i)\\n            \\n        visited = set()\\n        src,dest = 0,len(arr)-1\\n        queue = deque()\\n        queue.append((src,0))\\n        visited.add(src)\\n        while queue:\\n            node,dist = queue.popleft()\\n            if node == dest:\\n                return dist\\n            for child in [node-1, node+1] + graph[arr[node]][::-1]:\\n                if 0 <= child < len(arr) and child != node and child not in visited:\\n                    visited.add(child)\\n                    if child == dest:\\n                        return dist+1\\n                    queue.append((child,dist+1))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258857,
                "title": "c-bfs-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& v) {\\n        map<int,vector<int>>m;\\n        for(int i=0;i<v.size();i++){\\n            m[v[i]].push_back(i);\\n        }\\n        int n=v.size();\\n        vector<int>vis(n,0);\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        while(q.size()){\\n                auto j = q.front();\\n                int ct=j.second;\\n                int in=j.first;\\n                q.pop();\\n                if(in==n-1)return ct;\\n                if(in-1>=0 && !vis[in-1]){\\n                    q.push({in-1,ct+1});\\n                }\\n                if(in+1<n && !vis[in+1]){\\n                    q.push({in+1,ct+1});\\n                }\\n                if(!vis[in]){\\n                    vis[in]=1;\\n                    vector<int>vec=m[v[in]];\\n                    for(int g=0;g<vec.size();g++){\\n                        if(!vis[vec[g]]){\\n                            vis[vec[g]]=1;\\n                            q.push({vec[g],ct+1});\\n                        }\\n                    }\\n                }\\n        }\\n        return 1; //it doesn\\'t matter\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/8043040d-d34a-4272-9ec5-f22791d1051f_1677996638.420801.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& v) {\\n        map<int,vector<int>>m;\\n        for(int i=0;i<v.size();i++){\\n            m[v[i]].push_back(i);\\n        }\\n        int n=v.size();\\n        vector<int>vis(n,0);\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        while(q.size()){\\n                auto j = q.front();\\n                int ct=j.second;\\n                int in=j.first;\\n                q.pop();\\n                if(in==n-1)return ct;\\n                if(in-1>=0 && !vis[in-1]){\\n                    q.push({in-1,ct+1});\\n                }\\n                if(in+1<n && !vis[in+1]){\\n                    q.push({in+1,ct+1});\\n                }\\n                if(!vis[in]){\\n                    vis[in]=1;\\n                    vector<int>vec=m[v[in]];\\n                    for(int g=0;g<vec.size();g++){\\n                        if(!vis[vec[g]]){\\n                            vis[vec[g]]=1;\\n                            q.push({vec[g],ct+1});\\n                        }\\n                    }\\n                }\\n        }\\n        return 1; //it doesn\\'t matter\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257899,
                "title": "c-beats-94-using-bfs-and-set",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>&arr) \\n    {\\n        //BFS\\n        vector<bool>reachedindex(arr.size(),false);\\n        unordered_map<int,vector<int>>indexofval;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            indexofval[arr[i]].push_back(i);\\n        }\\n        queue<int>toreach;\\n        toreach.push(0);\\n        reachedindex[0]=true;\\n        int steps=0;\\n        while(!toreach.empty())\\n        {\\n            int n=toreach.size();\\n            while(n--)\\n            {\\n                int x=toreach.front();\\n                if(x==arr.size()-1)\\n                {\\n                    return steps;\\n                }\\n                toreach.pop();\\n                for(auto j:indexofval[arr[x]])\\n                {\\n                    if(!reachedindex[j])\\n                    {\\n                        toreach.push(j);\\n                        reachedindex[j]=true;\\n                    }\\n                }\\n                if((x-1)>0 && !reachedindex[x-1])\\n                {\\n                    toreach.push(x-1);\\n                    reachedindex[x-1]=true;\\n                }\\n                if((x+1)<arr.size() && !reachedindex[x+1])\\n                {\\n                    toreach.push(x+1);\\n                    reachedindex[x+1]=true;\\n                }\\n                indexofval[arr[x]].clear();//wihtout this line code gives TLE\\n                /*since we already reached those nodes with a particular value in less steps, then why do we need to check again to reach for those nodes with some steps \\n                more than optimised steps which in worst case we need to check O(N^2) times at test case 26 I suppose....thus we clear the vector so that it never checks again*/\\n            }\\n            steps++;\\n        }\\n        return arr.size()-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>&arr) \\n    {\\n        //BFS\\n        vector<bool>reachedindex(arr.size(),false);\\n        unordered_map<int,vector<int>>indexofval;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            indexofval[arr[i]].push_back(i);\\n        }\\n        queue<int>toreach;\\n        toreach.push(0);\\n        reachedindex[0]=true;\\n        int steps=0;\\n        while(!toreach.empty())\\n        {\\n            int n=toreach.size();\\n            while(n--)\\n            {\\n                int x=toreach.front();\\n                if(x==arr.size()-1)\\n                {\\n                    return steps;\\n                }\\n                toreach.pop();\\n                for(auto j:indexofval[arr[x]])\\n                {\\n                    if(!reachedindex[j])\\n                    {\\n                        toreach.push(j);\\n                        reachedindex[j]=true;\\n                    }\\n                }\\n                if((x-1)>0 && !reachedindex[x-1])\\n                {\\n                    toreach.push(x-1);\\n                    reachedindex[x-1]=true;\\n                }\\n                if((x+1)<arr.size() && !reachedindex[x+1])\\n                {\\n                    toreach.push(x+1);\\n                    reachedindex[x+1]=true;\\n                }\\n                indexofval[arr[x]].clear();//wihtout this line code gives TLE\\n                /*since we already reached those nodes with a particular value in less steps, then why do we need to check again to reach for those nodes with some steps \\n                more than optimised steps which in worst case we need to check O(N^2) times at test case 26 I suppose....thus we clear the vector so that it never checks again*/\\n            }\\n            steps++;\\n        }\\n        return arr.size()-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012876,
                "title": "c-image-explanation-easy-to-understand",
                "content": "Let\\'s understand the problem and solve it step by step:\\n\\n```\\nGiven an array of integers arr, you are initially positioned at the first index of the array.\\n\\nIn one step you can jump from index i to index:\\n\\ni + 1 where: i + 1 < arr.length.\\ni - 1 where: i - 1 >= 0.\\nj where: arr[i] == arr[j] and i != j.\\nReturn the minimum number of steps to reach the last index of the array.\\n```\\n\\nSo from an index you can go to index + 1, index -1, and to the index where the arr[index] is same.\\nConsider each index as a node and take this as finding the shortest distance between source and destination !! \\n![image](https://assets.leetcode.com/users/images/40109ce8-2918-4ccf-a018-3f5d5b9a01f4_1651818625.0956626.jpeg)\\n\\nNow lets understand the code step by step !!\\n\\n **Step 1 :**   Take a map and map the values to the indices its present in the given array\\n **Step 2 :**  Take a visited array and init the 0th index as True and now init a queue ( BFS BABY !! ) \\n and then push the 0th index, cause its the source\\n **Step 3 :**  Usual BFS !! take the front element, pop it and check if its equal to destination index, if yes, return steps\\n **Step 4 :**  Now take a vector and use the & because, you dont want to create copies and run out of memory and then push the index + 1 and index -1 into it\\n **Step 5 :**  Now we have a vector of indices where that current index can jump to, and now check if the index is in bounds, and check if its visited or not !! and if every condtion satisfies, mark that index as visited and push it into the queue\\n **Step 6 :**  ***THE MOST IMP STEP !!*** - You must remove the mapped indices to the curr node as keeping them will give you TLE, imagine a case where every value is 100, 100, 100, . i+1, i-1....it\\'lll loop forever !! \\n **Step 7:** As usual, increment the steps by 1\\n \\n\\n```\\n    int minJumps(vector<int>& arr){\\n        //step 1;\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> indicesOfValue;\\n        for (int i = 0; i < n; i++){\\n            indicesOfValue[arr[i]].push_back(i);\\n        }\\n        //step 2;\\n        vector<bool> visited(n);\\n        visited[0] = true;\\n        queue<int> q;\\n        q.push(0);\\n        int step = 0;\\n        //step 3\\n        while (!q.empty()) {\\n            for (int size = q.size(); size > 0; --size) {\\n                int i = q.front();\\n                q.pop();\\n                if (i == n - 1){ // Reached to last index\\n                    return step;\\n                }\\n                // step 4;\\n                vector<int>& next = indicesOfValue[arr[i]];\\n                next.push_back(i - 1);\\n                next.push_back(i + 1);\\n                // step 5\\n                for (int j : next) {\\n                    if (j >= 0 && j < n && !visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                // step 6\\n                indicesOfValue[arr[i]].clear(); // avoid later lookup indicesOfValue arr[i]\\n            }\\n            // step 7\\n            step++;\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nGiven an array of integers arr, you are initially positioned at the first index of the array.\\n\\nIn one step you can jump from index i to index:\\n\\ni + 1 where: i + 1 < arr.length.\\ni - 1 where: i - 1 >= 0.\\nj where: arr[i] == arr[j] and i != j.\\nReturn the minimum number of steps to reach the last index of the array.\\n```\n```\\n    int minJumps(vector<int>& arr){\\n        //step 1;\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> indicesOfValue;\\n        for (int i = 0; i < n; i++){\\n            indicesOfValue[arr[i]].push_back(i);\\n        }\\n        //step 2;\\n        vector<bool> visited(n);\\n        visited[0] = true;\\n        queue<int> q;\\n        q.push(0);\\n        int step = 0;\\n        //step 3\\n        while (!q.empty()) {\\n            for (int size = q.size(); size > 0; --size) {\\n                int i = q.front();\\n                q.pop();\\n                if (i == n - 1){ // Reached to last index\\n                    return step;\\n                }\\n                // step 4;\\n                vector<int>& next = indicesOfValue[arr[i]];\\n                next.push_back(i - 1);\\n                next.push_back(i + 1);\\n                // step 5\\n                for (int j : next) {\\n                    if (j >= 0 && j < n && !visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                // step 6\\n                indicesOfValue[arr[i]].clear(); // avoid later lookup indicesOfValue arr[i]\\n            }\\n            // step 7\\n            step++;\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1071440,
                "title": "c-bfs-getting-rid-of-adjacent-equivalent-numbers-to-avoid-tle",
                "content": "The trick is that if we have [1 6 6 6 9], then the middle 6 is useless, don\\'t add it to the adjacency list. That\\'s it.\\n\\n```\\nclass Solution {\\n    unordered_map<int, vector<int>> idx_of_num;\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        for (int i = 0; i < arr.size(); ++i) {\\n            if (i > 0 && i+1 < arr.size() && arr[i] == arr[i+1] && arr[i] == arr[i-1]) {\\n\\t\\t\\t    // don\\'t add the number if its adjacent numbers are all the same.\\n                continue;\\n            }\\n            idx_of_num[arr[i]].push_back(i);\\n        }\\n        \\n        vector<bool> visited(arr.size());\\n        visited[0] = true;\\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        while (!q.empty()) {\\n            int idx = q.front().first;\\n            int step = q.front().second;\\n            q.pop();\\n            \\n            if (idx == arr.size()-1) {\\n                return step;\\n            }\\n            \\n            // prev.\\n            if (idx > 0 && !visited[idx-1]) {\\n                q.push({idx-1, step+1});\\n                visited[idx-1] = true;\\n            }\\n            \\n            // next.\\n            if (idx+1 < arr.size() && !visited[idx+1]) {\\n                q.push({idx+1, step+1});\\n                visited[idx+1] = true;\\n            }\\n            \\n            // same.\\n            for (int next : idx_of_num[arr[idx]]) {\\n                if (!visited[next]) {\\n                    q.push({next, step+1});\\n                    visited[next] = true;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int, vector<int>> idx_of_num;\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        for (int i = 0; i < arr.size(); ++i) {\\n            if (i > 0 && i+1 < arr.size() && arr[i] == arr[i+1] && arr[i] == arr[i-1]) {\\n\\t\\t\\t    // don\\'t add the number if its adjacent numbers are all the same.\\n                continue;\\n            }\\n            idx_of_num[arr[i]].push_back(i);\\n        }\\n        \\n        vector<bool> visited(arr.size());\\n        visited[0] = true;\\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        while (!q.empty()) {\\n            int idx = q.front().first;\\n            int step = q.front().second;\\n            q.pop();\\n            \\n            if (idx == arr.size()-1) {\\n                return step;\\n            }\\n            \\n            // prev.\\n            if (idx > 0 && !visited[idx-1]) {\\n                q.push({idx-1, step+1});\\n                visited[idx-1] = true;\\n            }\\n            \\n            // next.\\n            if (idx+1 < arr.size() && !visited[idx+1]) {\\n                q.push({idx+1, step+1});\\n                visited[idx+1] = true;\\n            }\\n            \\n            // same.\\n            for (int next : idx_of_num[arr[idx]]) {\\n                if (!visited[next]) {\\n                    q.push({next, step+1});\\n                    visited[next] = true;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997608,
                "title": "why-no-dp-but-bfs-solution-c",
                "content": "**Explain NO DP** - \\nOne of the conditions for Dynamic programming is that the topological ordering must exists which means that there     should not be any cycles. However, in this case, because of the back edges, there is a cycle. Therefore, DP cannot be       used. However , DP can be used but it will not be efficient. \\n**BFS **\\nJust a simple breadth first search, at any index where can you go. \\n    (1). All nodes which have same value as the index you are currently on.\\n    (2). Previous node (index - 1)\\n    (3). Next node (index + 1)\\n**Why should it return minimum jumps?**\\n    In traversal, we put a condition that whenever we reach last node, we return our answer, hence its minimum.\\n\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        unordered_map<int,vector<int>> Map;\\n        for(int i=0;i<n;i++){\\n            Map[arr[i]].push_back(i);\\n        }\\n        int jumps = 0;\\n        vector<bool> vis(n,false);\\n        queue<int> q;\\n        q.push(0);\\n        vis[0]=true;\\n        while(!q.empty()){\\n            queue<int> q1;\\n            while(!q.empty()){\\n                int i = q.front();\\n                q.pop();\\n                if(i==n-1){\\n                    return jumps;\\n                }\\n                vector<int>& next = Map[arr[i]];\\n                next.push_back(i-1);\\n                next.push_back(i+1);\\n                for(auto j: next){\\n                    if(j>=0 && j<n && !vis[j]){\\n                        q1.push(j);\\n                        vis[j]=true;\\n                    }\\n                }\\n                next.clear();\\n            }\\n            jumps++;\\n            swap(q,q1);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        unordered_map<int,vector<int>> Map;\\n        for(int i=0;i<n;i++){\\n            Map[arr[i]].push_back(i);\\n        }\\n        int jumps = 0;\\n        vector<bool> vis(n,false);\\n        queue<int> q;\\n        q.push(0);\\n        vis[0]=true;\\n        while(!q.empty()){\\n            queue<int> q1;\\n            while(!q.empty()){\\n                int i = q.front();\\n                q.pop();\\n                if(i==n-1){\\n                    return jumps;\\n                }\\n                vector<int>& next = Map[arr[i]];\\n                next.push_back(i-1);\\n                next.push_back(i+1);\\n                for(auto j: next){\\n                    if(j>=0 && j<n && !vis[j]){\\n                        q1.push(j);\\n                        vis[j]=true;\\n                    }\\n                }\\n                next.clear();\\n            }\\n            jumps++;\\n            swap(q,q1);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989433,
                "title": "c-python-bfs-solution-from-easy-to-hard-version",
                "content": "\\'Easy\\' Version: \\nIt is actually not easy, it is a version after so many repeated optmization.  This just to illustrate, in case you saw a beautiful solution, do not worry. Just begin with the straightforward and ugly solution. And you will get there when you get enough training. Let time be our friend.\\n\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        queue<int> q{{0}};\\n        const int n = arr.size();        \\n        vector<int> visited(n, 0);\\n        visited[0]=1;        \\n        unordered_map<int, vector<int>> equals;\\n        for(int i = 0; i < n; i++) equals[arr[i]].push_back(i);                \\n        for(int step = 0;!q.empty(); step++){\\n            for(int i = q.size(); i>0;i--){\\n                auto cur = q.front(); q.pop();\\n                if(cur == n - 1) return step;                \\n                auto& nexts = equals[arr[cur]];nexts.push_back(cur-1); nexts.push_back(cur+1);\\n                for(int next: nexts)\\n                    if(next >=0 && next < n && !visited[next]) q.push(next), visited[next]=1;                     \\n                \\n                nexts.clear(); // Important. Avoid later lookup equals arr[i]                \\n            }\\n        }\\n        return n - 1;\\n    }\\n};\\n```\\n\\n\\'Hard\\' Version: \\nwith comments. This is actually a more natural version at first thought when I encounter this question.\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        queue<int> q{{0}};\\n        const int n = arr.size();        \\n        vector<int> visited(n, 0);\\n        visited[0]=1;\\n        //unordered_map<int, unordered_set<int>> equals; \\n        //for(int i = 0; i < n; i++) equals[arr[i]].insert(i);\\n        //The following 2-line snippet is preferred than above 2-line snippet. Always be stringent on the data structure to control memory\\n        unordered_map<int, vector<int>> equals;\\n        for(int i = 0; i < n; i++) equals[arr[i]].push_back(i);                \\n        for(int step = 0;!q.empty(); step++){\\n            for(int i = q.size(); i>0;i--){\\n                auto cur = q.front(); q.pop();\\n                if(cur == n - 1) return step;                \\n                for(int next:{cur+1, cur-1})\\n                    if(next >=0 && next < n && !visited[next]) q.push(next), visited[next]=1;                \\n                \\n                auto& nexts = equals[arr[cur]];\\n                for(int next: nexts)\\n                    if(!visited[next]) q.push(next), visited[next]=1;\\n                \\n                nexts.clear(); // Important. Avoid later lookup equals arr[i]                \\n            }\\n        }\\n        return n - 1;\\n    }\\n};\\n```\\n\\nApproach 3: A tiny speed-up\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        queue<int> q{{0}};\\n        const int n = arr.size();        \\n        vector<int> visited(n, 0);\\n        visited[0]=1;        \\n        unordered_map<int, vector<int>> equals;\\n\\t\\t//for(int i = 0; i < n; i++) equals[arr[i]].push_back(i); //ok, but redandent on handling i=0\\n        for(int i = 1; i < n; i++) equals[arr[i]].push_back(i);   //{{7,{0,1,2,...,49998},{11,50000}}}             \\n        for(int step = 0;!q.empty(); step++){\\n            for(int i = q.size(); i>0;i--){\\n                auto cur = q.front(); q.pop();\\n                if(cur == n - 1) return step;                \\n                auto& nexts = equals[arr[cur]];nexts.push_back(cur-1); nexts.push_back(cur+1);\\n                for(int next: nexts)\\n                    if(next >=0 && next < n && !visited[next]) q.push(next), visited[next]=1;                     \\n                //equals.erase(arr[cur]); // okay, but not efficient enough\\n                nexts.clear(); // Important. Avoid later lookup equals arr[i]; //test case: [7*49999 11], where * means repeating\\n            }\\n        }\\n        return n - 1;\\n    }\\n};\\n```\\nFollow-up:\\nTo further speed-up,\\nBi-directional BFS can be employed.\\n\\nApproach 4: simple python coding\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        q = collections.deque([(0,0)])\\n        visited_index = set([0])\\n        equal_neibors = collections.defaultdict(list)\\n        for i, v in enumerate(arr):equal_neibors[v].append(i)\\n        while q:\\n            step, cur = q.popleft()\\n            if cur == n - 1: return step\\n            for nxt in [cur - 1, cur + 1, *equal_neibors[arr[cur]]]:\\n                if 0 <= nxt < n and nxt not in visited_index:\\n                    q.append((step+1,nxt))\\n                    visited_index.add(nxt)  \\n            del equal_neibors[arr[cur]] # VIP: avoid revisiting  \\n```\\n",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        queue<int> q{{0}};\\n        const int n = arr.size();        \\n        vector<int> visited(n, 0);\\n        visited[0]=1;        \\n        unordered_map<int, vector<int>> equals;\\n        for(int i = 0; i < n; i++) equals[arr[i]].push_back(i);                \\n        for(int step = 0;!q.empty(); step++){\\n            for(int i = q.size(); i>0;i--){\\n                auto cur = q.front(); q.pop();\\n                if(cur == n - 1) return step;                \\n                auto& nexts = equals[arr[cur]];nexts.push_back(cur-1); nexts.push_back(cur+1);\\n                for(int next: nexts)\\n                    if(next >=0 && next < n && !visited[next]) q.push(next), visited[next]=1;                     \\n                \\n                nexts.clear(); // Important. Avoid later lookup equals arr[i]                \\n            }\\n        }\\n        return n - 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        queue<int> q{{0}};\\n        const int n = arr.size();        \\n        vector<int> visited(n, 0);\\n        visited[0]=1;\\n        //unordered_map<int, unordered_set<int>> equals; \\n        //for(int i = 0; i < n; i++) equals[arr[i]].insert(i);\\n        //The following 2-line snippet is preferred than above 2-line snippet. Always be stringent on the data structure to control memory\\n        unordered_map<int, vector<int>> equals;\\n        for(int i = 0; i < n; i++) equals[arr[i]].push_back(i);                \\n        for(int step = 0;!q.empty(); step++){\\n            for(int i = q.size(); i>0;i--){\\n                auto cur = q.front(); q.pop();\\n                if(cur == n - 1) return step;                \\n                for(int next:{cur+1, cur-1})\\n                    if(next >=0 && next < n && !visited[next]) q.push(next), visited[next]=1;                \\n                \\n                auto& nexts = equals[arr[cur]];\\n                for(int next: nexts)\\n                    if(!visited[next]) q.push(next), visited[next]=1;\\n                \\n                nexts.clear(); // Important. Avoid later lookup equals arr[i]                \\n            }\\n        }\\n        return n - 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        queue<int> q{{0}};\\n        const int n = arr.size();        \\n        vector<int> visited(n, 0);\\n        visited[0]=1;        \\n        unordered_map<int, vector<int>> equals;\\n\\t\\t//for(int i = 0; i < n; i++) equals[arr[i]].push_back(i); //ok, but redandent on handling i=0\\n        for(int i = 1; i < n; i++) equals[arr[i]].push_back(i);   //{{7,{0,1,2,...,49998},{11,50000}}}             \\n        for(int step = 0;!q.empty(); step++){\\n            for(int i = q.size(); i>0;i--){\\n                auto cur = q.front(); q.pop();\\n                if(cur == n - 1) return step;                \\n                auto& nexts = equals[arr[cur]];nexts.push_back(cur-1); nexts.push_back(cur+1);\\n                for(int next: nexts)\\n                    if(next >=0 && next < n && !visited[next]) q.push(next), visited[next]=1;                     \\n                //equals.erase(arr[cur]); // okay, but not efficient enough\\n                nexts.clear(); // Important. Avoid later lookup equals arr[i]; //test case: [7*49999 11], where * means repeating\\n            }\\n        }\\n        return n - 1;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        q = collections.deque([(0,0)])\\n        visited_index = set([0])\\n        equal_neibors = collections.defaultdict(list)\\n        for i, v in enumerate(arr):equal_neibors[v].append(i)\\n        while q:\\n            step, cur = q.popleft()\\n            if cur == n - 1: return step\\n            for nxt in [cur - 1, cur + 1, *equal_neibors[arr[cur]]]:\\n                if 0 <= nxt < n and nxt not in visited_index:\\n                    q.append((step+1,nxt))\\n                    visited_index.add(nxt)  \\n            del equal_neibors[arr[cur]] # VIP: avoid revisiting  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 829482,
                "title": "javascript-97",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function(arr) {\\n    let valuePositionsMap = getValuePositionsMap(arr);\\n    let mySet = new Set();\\n    mySet.add(0);\\n    let aoArray = [0];\\n    let counter = 0;\\n    while(!mySet.has(arr.length-1)){\\n        counter++;\\n        let newArray = [];\\n        for(let currP of aoArray){\\n            for(let item of findAllOptions(arr, currP, mySet, valuePositionsMap)){\\n                newArray.push(item);\\n                mySet.add(item);\\n                if(item == arr.length-1){\\n                    break;\\n                }\\n            }\\n            if(mySet.has(arr.length-1)){\\n                break;\\n            }\\n        }\\n        aoArray = newArray;\\n    }\\n    return counter;\\n};\\n\\nfunction getValuePositionsMap(arr){\\n    let result = new Map();\\n    for(let i=arr.length-1;i>=0;i--){\\n        if(!result.has(arr[i])){\\n            result.set(arr[i], []); \\n        }\\n        result.get(arr[i]).push(i);\\n    }\\n    return result;\\n}\\n\\nfunction findAllOptions(arr, currP, mySet, valuePositionsMap){\\n    let result = [];\\n    if(currP > 0 && arr[currP-1] != arr[currP] && !mySet.has(currP-1)){\\n        result.push(currP-1);\\n    }\\n    if(currP < arr.length-1 && arr[currP+1] != arr[currP] && !mySet.has(currP+1)){\\n        result.push(currP+1);\\n    }\\n    if(valuePositionsMap.has(arr[currP])){\\n        for(let i of valuePositionsMap.get(arr[currP])){\\n            if(i != currP && !mySet.has(i)){\\n                result.push(i);\\n            }\\n        }\\n        valuePositionsMap.delete(arr[currP]);\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function(arr) {\\n    let valuePositionsMap = getValuePositionsMap(arr);\\n    let mySet = new Set();\\n    mySet.add(0);\\n    let aoArray = [0];\\n    let counter = 0;\\n    while(!mySet.has(arr.length-1)){\\n        counter++;\\n        let newArray = [];\\n        for(let currP of aoArray){\\n            for(let item of findAllOptions(arr, currP, mySet, valuePositionsMap)){\\n                newArray.push(item);\\n                mySet.add(item);\\n                if(item == arr.length-1){\\n                    break;\\n                }\\n            }\\n            if(mySet.has(arr.length-1)){\\n                break;\\n            }\\n        }\\n        aoArray = newArray;\\n    }\\n    return counter;\\n};\\n\\nfunction getValuePositionsMap(arr){\\n    let result = new Map();\\n    for(let i=arr.length-1;i>=0;i--){\\n        if(!result.has(arr[i])){\\n            result.set(arr[i], []); \\n        }\\n        result.get(arr[i]).push(i);\\n    }\\n    return result;\\n}\\n\\nfunction findAllOptions(arr, currP, mySet, valuePositionsMap){\\n    let result = [];\\n    if(currP > 0 && arr[currP-1] != arr[currP] && !mySet.has(currP-1)){\\n        result.push(currP-1);\\n    }\\n    if(currP < arr.length-1 && arr[currP+1] != arr[currP] && !mySet.has(currP+1)){\\n        result.push(currP+1);\\n    }\\n    if(valuePositionsMap.has(arr[currP])){\\n        for(let i of valuePositionsMap.get(arr[currP])){\\n            if(i != currP && !mySet.has(i)){\\n                result.push(i);\\n            }\\n        }\\n        valuePositionsMap.delete(arr[currP]);\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502786,
                "title": "dp-21-26-passed-dynamic-programming-wa-help",
                "content": "I tried solving using dynamic programming but my code **passes only 21/26 cases**.Can someone *please help me figure out what am I missing in my logic/code*.\\nPlease comment ...thanks\\n\\n```\\npublic int minJumps(int[] arr) {\\n\\n\\n\\t\\tint n=arr.length;\\n\\t\\tif(n==1 || n==0) return 0;\\n\\t\\tif( arr[0]==arr[n-1]) return 1;\\n\\n\\t\\tint [] dp=new int[n];\\n\\t\\tArrays.fill(dp,100000002);          \\n\\t\\tdp[0]=0;\\n\\n\\t\\tfor( int i=1;i<n;i++){\\n\\n\\t\\t\\tfor(int j=0;j<i;j++){\\n\\n\\t\\t\\t\\tif(arr[i]==arr[j]){\\n\\t\\t\\t\\t\\tdp[i]=Math.min(dp[i],dp[j]+1);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(arr[i]!=arr[j]) {\\n\\t\\t\\t\\t\\tif(j!=0 && arr[i]==arr[j-1]) {\\n\\n\\t\\t\\t\\t\\t\\tdp[i]=Math.min(dp[i],dp[j]+2);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(j!=i-1 && arr[i]==arr[j+1]) {\\n\\n\\t\\t\\t\\t\\t\\tdp[i]=Math.min(dp[i],dp[j]+2);\\n\\t\\t\\t\\t\\t}  \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tdp[i]=Math.min(dp[i],dp[i-1]+1);\\n\\t\\t\\tif(i!=n-1) dp[i]=Math.min(dp[i],dp[i+1]+1);\\n\\t\\t}\\n\\t\\treturn dp[n-1];\\n\\n\\n\\t}\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int minJumps(int[] arr) {\\n\\n\\n\\t\\tint n=arr.length;\\n\\t\\tif(n==1 || n==0) return 0;\\n\\t\\tif( arr[0]==arr[n-1]) return 1;\\n\\n\\t\\tint [] dp=new int[n];\\n\\t\\tArrays.fill(dp,100000002);          \\n\\t\\tdp[0]=0;\\n\\n\\t\\tfor( int i=1;i<n;i++){\\n\\n\\t\\t\\tfor(int j=0;j<i;j++){\\n\\n\\t\\t\\t\\tif(arr[i]==arr[j]){\\n\\t\\t\\t\\t\\tdp[i]=Math.min(dp[i],dp[j]+1);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(arr[i]!=arr[j]) {\\n\\t\\t\\t\\t\\tif(j!=0 && arr[i]==arr[j-1]) {\\n\\n\\t\\t\\t\\t\\t\\tdp[i]=Math.min(dp[i],dp[j]+2);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(j!=i-1 && arr[i]==arr[j+1]) {\\n\\n\\t\\t\\t\\t\\t\\tdp[i]=Math.min(dp[i],dp[j]+2);\\n\\t\\t\\t\\t\\t}  \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tdp[i]=Math.min(dp[i],dp[i-1]+1);\\n\\t\\t\\tif(i!=n-1) dp[i]=Math.min(dp[i],dp[i+1]+1);\\n\\t\\t}\\n\\t\\treturn dp[n-1];\\n\\n\\n\\t}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 502775,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            if(!map.containsKey(arr[i])) map.put(arr[i], new ArrayList());\\n            map.get(arr[i]).add(i);\\n        }\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        while(q.size() > 0) {\\n            int[] pair = q.remove();\\n            if(pair[0] == n - 1) return pair[1];\\n            if(pair[0] + 1 < n && !visited[pair[0] + 1]) {\\n                if(pair[0] + 1 == n - 1) return pair[1] + 1;\\n                q.add(new int[]{pair[0] + 1, pair[1] + 1});\\n                visited[pair[0] + 1] = true;\\n            }\\n            if(pair[0] - 1 >= 0 && !visited[pair[0] - 1]) {\\n                if(pair[0] - 1 == n - 1) return pair[1] + 1;\\n                q.add(new int[]{pair[0] - 1, pair[1] + 1});\\n                visited[pair[0] - 1] = true;\\n            }\\n            List<Integer> possible = map.get(arr[pair[0]]);\\n            for(int i = possible.size() - 1; i >= 0; i--) {\\n                if(possible.get(i) == n - 1) return pair[1] + 1;\\n                if(!visited[possible.get(i)]) {\\n                    q.add(new int[]{possible.get(i), pair[1] + 1});\\n                    visited[possible.get(i)] = true;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            if(!map.containsKey(arr[i])) map.put(arr[i], new ArrayList());\\n            map.get(arr[i]).add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3621067,
                "title": "only-bfs-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        if(arr.size()==1)return 0;\\n        queue<int> q;\\n        q.push(0);\\n        unordered_map<int,vector<int>> mp;\\n        int n=arr.size(),i,x,y;\\n        for(i = 0; i < n; i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        i = 0;\\n        x = -1;\\n        \\n        vector<bool> vis(n,false);\\n        vis[0] = true;\\n        while(!q.empty()){\\n            y = q.size();\\n            x++;\\n            while(y--){\\n                i = q.front();\\n                q.pop();\\n                if(i==n-1)return x;\\n                if(i-1>=0&&!vis[i-1]){q.push(i-1);vis[i-1] = true;}\\n                if(i+1<n&&!vis[i+1]){q.push(i+1);vis[i+1]=true;}\\n                for(auto &j: mp[arr[i]]){\\n                    if(!vis[j]){\\n                        vis[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                mp.erase(arr[i]);\\n            }\\n        }\\n        return arr.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        if(arr.size()==1)return 0;\\n        queue<int> q;\\n        q.push(0);\\n        unordered_map<int,vector<int>> mp;\\n        int n=arr.size(),i,x,y;\\n        for(i = 0; i < n; i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        i = 0;\\n        x = -1;\\n        \\n        vector<bool> vis(n,false);\\n        vis[0] = true;\\n        while(!q.empty()){\\n            y = q.size();\\n            x++;\\n            while(y--){\\n                i = q.front();\\n                q.pop();\\n                if(i==n-1)return x;\\n                if(i-1>=0&&!vis[i-1]){q.push(i-1);vis[i-1] = true;}\\n                if(i+1<n&&!vis[i+1]){q.push(i+1);vis[i+1]=true;}\\n                for(auto &j: mp[arr[i]]){\\n                    if(!vis[j]){\\n                        vis[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                mp.erase(arr[i]);\\n            }\\n        }\\n        return arr.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260574,
                "title": "simple-java-using-set-map-queue-linkedlist",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n\\n        int n=arr.length;\\n        Map<Integer,List<Integer>> valIndex=new HashMap<>();\\n\\n        for(int i=0;i<n;i++)\\n            valIndex.computeIfAbsent(arr[i],l->new ArrayList<>()).add(i);\\n\\n        Queue<Integer> q=new LinkedList<>();\\n        q.add(0);\\n\\n        Set<Integer> visited=new HashSet<>();\\n        visited.add(0);\\n\\n        int step=0;\\n\\n\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            while(size-->0){\\n                int i=q.poll();\\n\\n\\n                if(i==n-1)\\n                    return step;\\n\\n                List<Integer> adjList=valIndex.get(arr[i]);\\n\\n                adjList.add(i-1);\\n                adjList.add(i+1);\\n\\n                for(int j:adjList)\\n                {\\n                    if(j>=0&& j<n && !visited.contains(j))\\n                        {\\n                            q.add(j);\\n                            visited.add(j);\\n                        }\\n                }\\n                adjList.clear();   \\n            }\\n\\n\\n\\n            step++;\\n        }\\n\\n\\n\\n      return -1;  \\n    }\\n}\\n```\\n\\n![7abc56.jpg](https://assets.leetcode.com/users/images/d0a632d5-0e09-41aa-b3ac-84abc4071673_1678026786.5923662.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n\\n        int n=arr.length;\\n        Map<Integer,List<Integer>> valIndex=new HashMap<>();\\n\\n        for(int i=0;i<n;i++)\\n            valIndex.computeIfAbsent(arr[i],l->new ArrayList<>()).add(i);\\n\\n        Queue<Integer> q=new LinkedList<>();\\n        q.add(0);\\n\\n        Set<Integer> visited=new HashSet<>();\\n        visited.add(0);\\n\\n        int step=0;\\n\\n\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            while(size-->0){\\n                int i=q.poll();\\n\\n\\n                if(i==n-1)\\n                    return step;\\n\\n                List<Integer> adjList=valIndex.get(arr[i]);\\n\\n                adjList.add(i-1);\\n                adjList.add(i+1);\\n\\n                for(int j:adjList)\\n                {\\n                    if(j>=0&& j<n && !visited.contains(j))\\n                        {\\n                            q.add(j);\\n                            visited.add(j);\\n                        }\\n                }\\n                adjList.clear();   \\n            }\\n\\n\\n\\n            step++;\\n        }\\n\\n\\n\\n      return -1;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259615,
                "title": "jump-game-iv-c-easy-approach-fast-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n\\t    int n = arr.size(), ans = 0;\\n\\t    map<int, vector<int>> m;\\n\\t    vector<bool> vis(n, 0);\\n\\t    for (auto i = 0; i < n; i++) {\\n\\t    \\tm[arr[i]].push_back(i);\\n\\t    }\\n\\t    queue<int> q;\\n\\t    q.push(0);\\n\\t    vis[0] = true;\\n\\t    while (!q.empty()) {\\n\\t    \\tint sz = q.size();\\n\\t    \\twhile (sz--) {\\n\\t    \\t\\tint curr = q.front();\\n\\t    \\t\\tq.pop();\\n\\t    \\t\\tif (curr == n - 1) return ans;\\n\\t    \\t\\tif (curr > 0) {\\n\\t    \\t\\t\\tif (!vis[curr - 1]) {\\n\\t    \\t\\t\\t\\tq.push(curr - 1);\\n\\t    \\t\\t\\t\\tvis[curr - 1] = true;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t\\tif (curr < n - 1) {\\n\\t    \\t\\t\\tif (!vis[curr + 1]) {\\n\\t    \\t\\t\\t\\tq.push(curr + 1);\\n\\t    \\t\\t\\t\\tvis[curr + 1] = true;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t\\tif(m[arr[curr]][0] == -1) continue;\\n\\t    \\t\\tfor (auto i : m[arr[curr]]) {\\n\\t    \\t\\t\\tif (!vis[i]) {\\n\\t    \\t\\t\\t\\tq.push(i);\\n\\t    \\t\\t\\t\\tvis[i] = true;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t\\tm[arr[curr]] = {-1};\\n\\t    \\t}\\n\\t    \\tans++;\\n\\t    }\\n\\t    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n\\t    int n = arr.size(), ans = 0;\\n\\t    map<int, vector<int>> m;\\n\\t    vector<bool> vis(n, 0);\\n\\t    for (auto i = 0; i < n; i++) {\\n\\t    \\tm[arr[i]].push_back(i);\\n\\t    }\\n\\t    queue<int> q;\\n\\t    q.push(0);\\n\\t    vis[0] = true;\\n\\t    while (!q.empty()) {\\n\\t    \\tint sz = q.size();\\n\\t    \\twhile (sz--) {\\n\\t    \\t\\tint curr = q.front();\\n\\t    \\t\\tq.pop();\\n\\t    \\t\\tif (curr == n - 1) return ans;\\n\\t    \\t\\tif (curr > 0) {\\n\\t    \\t\\t\\tif (!vis[curr - 1]) {\\n\\t    \\t\\t\\t\\tq.push(curr - 1);\\n\\t    \\t\\t\\t\\tvis[curr - 1] = true;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t\\tif (curr < n - 1) {\\n\\t    \\t\\t\\tif (!vis[curr + 1]) {\\n\\t    \\t\\t\\t\\tq.push(curr + 1);\\n\\t    \\t\\t\\t\\tvis[curr + 1] = true;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t\\tif(m[arr[curr]][0] == -1) continue;\\n\\t    \\t\\tfor (auto i : m[arr[curr]]) {\\n\\t    \\t\\t\\tif (!vis[i]) {\\n\\t    \\t\\t\\t\\tq.push(i);\\n\\t    \\t\\t\\t\\tvis[i] = true;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t\\tm[arr[curr]] = {-1};\\n\\t    \\t}\\n\\t    \\tans++;\\n\\t    }\\n\\t    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258987,
                "title": "java-easy-understanding-hash-table-bfs-simple",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(hm.containsKey(arr[i])){\\n                ArrayList<Integer>al=hm.get(arr[i]);\\n                al.add(i);\\n                hm.put(arr[i],al);\\n            }\\n            else{\\n                ArrayList<Integer>al=new ArrayList<>();\\n                al.add(i);\\n                hm.put(arr[i],al);\\n            }\\n        }\\n        boolean vis[]=new boolean[arr.length];\\n        Queue<Integer>q=new LinkedList<>();\\n        q.add(0);\\n        int cnt=0;\\n        while(!q.isEmpty()){\\n            for(int k=q.size();k>0;k--){\\n                int n=q.remove();\\n                vis[n]=true;\\n                if(n==arr.length-1) return cnt;\\n                ArrayList<Integer>al=hm.get(arr[n]);\\n                al.add(n-1);\\n                al.add(n+1);\\n                for(int i:al){\\n                    if(i>=0&&i<arr.length&&!vis[i]){\\n                        q.add(i);\\n                    }\\n                }\\n                al.clear();\\n            }\\n            cnt++;\\n        }\\n        return 0;\\n    }\\n}\\n```\\nUPVOTE IF U LIKE THE APPROACH",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(hm.containsKey(arr[i])){\\n                ArrayList<Integer>al=hm.get(arr[i]);\\n                al.add(i);\\n                hm.put(arr[i],al);\\n            }\\n            else{\\n                ArrayList<Integer>al=new ArrayList<>();\\n                al.add(i);\\n                hm.put(arr[i],al);\\n            }\\n        }\\n        boolean vis[]=new boolean[arr.length];\\n        Queue<Integer>q=new LinkedList<>();\\n        q.add(0);\\n        int cnt=0;\\n        while(!q.isEmpty()){\\n            for(int k=q.size();k>0;k--){\\n                int n=q.remove();\\n                vis[n]=true;\\n                if(n==arr.length-1) return cnt;\\n                ArrayList<Integer>al=hm.get(arr[n]);\\n                al.add(n-1);\\n                al.add(n+1);\\n                for(int i:al){\\n                    if(i>=0&&i<arr.length&&!vis[i]){\\n                        q.add(i);\\n                    }\\n                }\\n                al.clear();\\n            }\\n            cnt++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258986,
                "title": "bfs-or-dfs-detailed-explanation-containing-hints-efficient-solution",
                "content": "# Intuition\\nI assume you have some idea of [Jump Game](https://leetcode.com/problems/jump-game/), [Jump Game II](https://leetcode.com/problems/jump-game-ii/) and [Jump Game III](https://leetcode.com/problems/jump-game-iii/) by now. This problem contains similar approach but we need some additional understanding.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe question says that at any index i:\\n- we can jump to index $$i-1$$.\\n- we can jump to index $$i+1$$.\\n- or we can jump to those indices that have the same jump value as current index. \\nSuppose given $$jumps = [1, 1, 2, 1, 1]$$. We are in index $$i = 0$$ currently. We can go to $$i-1$$ or, $$i+1$$. \\n  -  So, $$i-1 = 0-1 = -1$$. It is out of bound. So, we cannot take it.\\n  - $$i+1 = 0 + 1 = 1$$. We can go to that index.\\n  - You can see from the examples that index $$i = 0$$ has $$jump = 1$$. You can see that indices 1, 3 and 4 also have same value. According to the specification we should also consider those indices.\\n  - So, we can also go to $$i = 3$$ and $$i = 4$$.\\n\\n# Hints:\\nSo, first thing is you have to keep the indices with same jump value.\\nYou probably thinking of a map of list values. The key will be jump length and the values will be indices.\\n\\nWe start from index $$0$$ and we need to keep the **stepsTaken** in a variable. We want the minimum steps. Can we do a **dfs** search in this case? No, **dfs** will go deep into the tree. But for minimum finding case, we should probably use **bfs**. Because **bfs** traverses all the nodes in level order. Gradually from up to bottom. So, we will be good to use **bfs** in this case.\\n\\nWe can see the same indices can come more than once. For this case, we need to keep an array of **boolean** to keep the indices that were visited.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nUsing **BFS** would take time complexity of $$O(n+k)$$. Here, $$n$$ is the number of elements and the $$k$$ is the maximum edge connecting an element. In worst case, all the elements can be same. But as we are not calculating repeating elements, it is good to go. The time complexity will stay around $$O(n)$$.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs we are keeping a queue and also Clearing it out. There won\\'t be all the $$n$$ elements at one time in the queue. But we have also used an array of **boolean[] visited** which is of size $$n$$. So, the space complexity would be $$O(n)$$.\\n\\n# Code \\n``` java []\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int len = arr.length;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        // storing indices having same jump length..\\n        for(int i=0; i<len; i++){\\n            map.computeIfAbsent(arr[i], x -> new LinkedList<>()).add(i);\\n        }\\n        boolean[] visited = new boolean[len];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        visited[0] = true;\\n        int stepsTaken = -1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            stepsTaken++;\\n            while(size-->0){\\n                int idx = q.remove();\\n                // we reached the end\\n                if(idx==len-1)\\n                    return stepsTaken;\\n                // get all the indices with same jump length\\n                List<Integer> next = map.get(arr[idx]);\\n                // we can jump to i-1 or i+1\\n                // we don\\'t want to go out of bound...\\n                if(idx-1>=0){\\n                    next.add(idx-1);\\n                }\\n                // we don\\'t want to go out of bound...\\n                if(idx+1<len){\\n                    next.add(idx+1);\\n                }\\n                // iterate for all indices\\n                for(int i : next){\\n                    // we don\\'t want to check the already visited indices again!\\n                    if(!visited[i]){\\n                        visited[i] = true;\\n                        q.offer(i);\\n                    }\\n                }\\n                // avoid later lookup sameValueIndicesMap arr[i]\\n                map.get(arr[idx]).clear();\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> sameValueIndicesMap;\\n        for (int i = 0; i < n; i++)\\n            sameValueIndicesMap[arr[i]].push_back(i);\\n        vector<bool> visited(n); \\n        queue<int> q; \\n        q.push(0);\\n        visited[0] = true;\\n        int stepsTaken = -1;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            stepsTaken++;\\n            while (size-->0) {\\n                int i = q.front(); \\n                q.pop();\\n                // Reached to last index\\n                if (i == n - 1) {\\n                    return stepsTaken;\\n                }\\n                // get all the indices with same jump length\\n                vector<int>& next = sameValueIndicesMap[arr[i]];\\n                // we can jump to i-1 or i+1\\n                // we don\\'t want to go out of bound...\\n                if(i-1 >=0){\\n                    next.push_back(i - 1);\\n                }\\n                // we don\\'t want to go out of bound...\\n                if(i+1 < n){\\n                    next.push_back(i + 1);\\n                }\\n                // iterate for all indices\\n                for (int j : next) {\\n                    // we don\\'t want to check the already visited indices again!\\n                    if (!visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                // avoid later lookup sameValueIndicesMap arr[i]\\n                next.clear();\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/58ea33a3-d47b-44a1-9a1e-7af583173d20_1670178091.0691743.png)\\n![image](https://assets.leetcode.com/users/images/0ad03c10-9b0d-4d2c-8451-bb5a171c70ff_1670178117.9879165.png)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int len = arr.length;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        // storing indices having same jump length..\\n        for(int i=0; i<len; i++){\\n            map.computeIfAbsent(arr[i], x -> new LinkedList<>()).add(i);\\n        }\\n        boolean[] visited = new boolean[len];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        visited[0] = true;\\n        int stepsTaken = -1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            stepsTaken++;\\n            while(size-->0){\\n                int idx = q.remove();\\n                // we reached the end\\n                if(idx==len-1)\\n                    return stepsTaken;\\n                // get all the indices with same jump length\\n                List<Integer> next = map.get(arr[idx]);\\n                // we can jump to i-1 or i+1\\n                // we don\\'t want to go out of bound...\\n                if(idx-1>=0){\\n                    next.add(idx-1);\\n                }\\n                // we don\\'t want to go out of bound...\\n                if(idx+1<len){\\n                    next.add(idx+1);\\n                }\\n                // iterate for all indices\\n                for(int i : next){\\n                    // we don\\'t want to check the already visited indices again!\\n                    if(!visited[i]){\\n                        visited[i] = true;\\n                        q.offer(i);\\n                    }\\n                }\\n                // avoid later lookup sameValueIndicesMap arr[i]\\n                map.get(arr[idx]).clear();\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> sameValueIndicesMap;\\n        for (int i = 0; i < n; i++)\\n            sameValueIndicesMap[arr[i]].push_back(i);\\n        vector<bool> visited(n); \\n        queue<int> q; \\n        q.push(0);\\n        visited[0] = true;\\n        int stepsTaken = -1;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            stepsTaken++;\\n            while (size-->0) {\\n                int i = q.front(); \\n                q.pop();\\n                // Reached to last index\\n                if (i == n - 1) {\\n                    return stepsTaken;\\n                }\\n                // get all the indices with same jump length\\n                vector<int>& next = sameValueIndicesMap[arr[i]];\\n                // we can jump to i-1 or i+1\\n                // we don\\'t want to go out of bound...\\n                if(i-1 >=0){\\n                    next.push_back(i - 1);\\n                }\\n                // we don\\'t want to go out of bound...\\n                if(i+1 < n){\\n                    next.push_back(i + 1);\\n                }\\n                // iterate for all indices\\n                for (int j : next) {\\n                    // we don\\'t want to check the already visited indices again!\\n                    if (!visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                // avoid later lookup sameValueIndicesMap arr[i]\\n                next.clear();\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658643,
                "title": "python3-solution-faster-than-56-bfs-bahut-tez",
                "content": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        h={}\\n        for i,e in enumerate(arr):\\n            if e not in h:\\n                h[e] = []\\n            h[e].append(i)\\n        q = [(0,0)]\\n        while q:\\n            n,d = q.pop(0)\\n            if n == len(arr)-1:\\n                return d\\n            if n+1 == len(arr)-1:\\n                return d+1\\n            if n+1 < len(arr) and h.get(arr[n+1]):\\n                q.append((n+1,d+1))\\n            if n-1 >= 0 and h.get(arr[n-1]):\\n                q.append((n-1,d+1))\\n            for i in h[arr[n]]:\\n                if i != n:\\n                    q.append((i,d+1))\\n                if i == len(arr)-1:\\n                    return d+1\\n            h[arr[n]] = []",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "class Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        h={}",
                "codeTag": "Java"
            },
            {
                "id": 1224573,
                "title": "c-dfs-tle-bfs-accepted-easy-comments-why-dfs-memo-won-t-work",
                "content": "DFS -> TLE\\n\\n    DFS+Memoization does not work, when all of the following 3 dependency exists: \\n      - forward dependency, i.e., mem[start] depends on mem[start + 1];\\n      - backward dependncy, i.e., mem[start] depends on mem[start - 1];\\n      - jump dependency, i.e., mem[start] depends on mem[x];\\n    You mark an index visited and return the value of that index if it was visited in past\\n    but, that value may not be optimal (shotest) in DFS because DFS traverses nodes in random    \\n    order, and we only cache the first result it finds.\\n\\n    Why BFS ?\\n    With BFS you can stop as soon as you reach the goal. With DFS you might reach the goal (or memoize any result) via a sub-optimal path.\\n    To be sure you get the optimal solution with DFS, you can\\'t use memoization because you might still find a shorter path at any point in the future.\\n\\n```\\n//Approach-1 (DFS - TLE)\\nclass Solution {\\npublic:\\n    vector<bool> visited;\\n    vector<int> t;\\n    unordered_map<int, vector<int>> mp;\\n    int solve_DFS(vector<int>& arr, int idx) {\\n        //reached destination\\n        if(idx == arr.size()-1)\\n            return 0;\\n        \\n\\t\\t//No memoization check because it won\\'t give optimal result always\\n\\t\\t\\n        int min_step = INT_MAX;\\n        // jump to idx + 1\\n        if (idx + 1 < arr.size() && !visited[idx+1]) {\\n            visited[idx+1] = true;\\n            min_step = min(min_step, solve_DFS(arr, idx+1) + 1);\\n            visited[idx+1] = false; //you need to do this for trying (idx-1) and same number indices\\n        }\\n        // jump to idx - 1\\n        if (idx - 1 >= 0 && !visited[idx-1]) {\\n            visited[idx-1] = true;\\n            min_step = min(min_step, solve_DFS(arr, idx-1) + 1);\\n            visited[idx-1] = false;\\n        }\\n        // jump to same number with different idx\\n        for (int next_idx : mp[arr[idx]]) {\\n            if (next_idx == idx) {continue;}\\n            if (!visited[next_idx]) {\\n                visited[next_idx] = true;\\n                min_step = min(min_step, solve_DFS(arr, next_idx) + 1);\\n                visited[next_idx] = false;\\n            }\\n        }\\n        \\n        t[idx] = min(t[idx], min_step);\\n        return t[idx];\\n    }\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        visited.resize(n);\\n        t.resize(n, INT_MAX);\\n        mp.clear();\\n        for(int i = 0; i<n; i++) {\\n            mp[arr[i]].push_back(i);\\n        }\\n        visited[0] = true;\\n        return solve_DFS(arr, 0);\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (BFS : Accepted)\\nclass Solution {\\npublic:\\n    int solve_BFS(vector<int>& arr, int& n) {\\n        vector<bool> visited(n, false);\\n        unordered_map<int, vector<int>> mp; //why ?  Because, we need to access those indices where arr[i] == arr[j]\\n        \\n        for(int i = 0; i<n; i++) {\\n            mp[arr[i]].push_back(i);\\n        }\\n        \\n        queue<int> que;\\n        que.push(0);\\n        visited[0] = true;\\n        int steps = 0;\\n        \\n        while(!que.empty()) {\\n            int size = que.size();\\n            \\n            //check this level\\n            while(size--) {\\n                int curr = que.front();\\n                que.pop();\\n                \\n                if(curr == n-1) {\\n                    //BFS ensures minimum steps\\n                    //We are moving level by level\\n                    return steps;\\n                }\\n                \\n                int left  = curr-1;\\n                int right = curr+1;\\n                \\n                if(left >= 0 && !visited[left]) {\\n                    que.push(left);\\n                    visited[left] = true;\\n                }\\n                \\n                if(right < n && !visited[right]) {\\n                    que.push(right);\\n                    visited[right] = true;\\n                }\\n                \\n                for(const int &idx : mp[arr[curr]]) {\\n                    if(!visited[idx]) {\\n                        que.push(idx);\\n                        visited[idx] = true;\\n                    }\\n                }\\n                //If you don\\'t erase it, you may be again checking for it\\n                //in future. It will cause TLE\\n                mp.erase(arr[curr]);\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n == 1)\\n            return 0;\\n        return solve_BFS(arr, n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (DFS - TLE)\\nclass Solution {\\npublic:\\n    vector<bool> visited;\\n    vector<int> t;\\n    unordered_map<int, vector<int>> mp;\\n    int solve_DFS(vector<int>& arr, int idx) {\\n        //reached destination\\n        if(idx == arr.size()-1)\\n            return 0;\\n        \\n\\t\\t//No memoization check because it won\\'t give optimal result always\\n\\t\\t\\n        int min_step = INT_MAX;\\n        // jump to idx + 1\\n        if (idx + 1 < arr.size() && !visited[idx+1]) {\\n            visited[idx+1] = true;\\n            min_step = min(min_step, solve_DFS(arr, idx+1) + 1);\\n            visited[idx+1] = false; //you need to do this for trying (idx-1) and same number indices\\n        }\\n        // jump to idx - 1\\n        if (idx - 1 >= 0 && !visited[idx-1]) {\\n            visited[idx-1] = true;\\n            min_step = min(min_step, solve_DFS(arr, idx-1) + 1);\\n            visited[idx-1] = false;\\n        }\\n        // jump to same number with different idx\\n        for (int next_idx : mp[arr[idx]]) {\\n            if (next_idx == idx) {continue;}\\n            if (!visited[next_idx]) {\\n                visited[next_idx] = true;\\n                min_step = min(min_step, solve_DFS(arr, next_idx) + 1);\\n                visited[next_idx] = false;\\n            }\\n        }\\n        \\n        t[idx] = min(t[idx], min_step);\\n        return t[idx];\\n    }\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        visited.resize(n);\\n        t.resize(n, INT_MAX);\\n        mp.clear();\\n        for(int i = 0; i<n; i++) {\\n            mp[arr[i]].push_back(i);\\n        }\\n        visited[0] = true;\\n        return solve_DFS(arr, 0);\\n    }\\n};\\n```\n```\\n//Approach-2 (BFS : Accepted)\\nclass Solution {\\npublic:\\n    int solve_BFS(vector<int>& arr, int& n) {\\n        vector<bool> visited(n, false);\\n        unordered_map<int, vector<int>> mp; //why ?  Because, we need to access those indices where arr[i] == arr[j]\\n        \\n        for(int i = 0; i<n; i++) {\\n            mp[arr[i]].push_back(i);\\n        }\\n        \\n        queue<int> que;\\n        que.push(0);\\n        visited[0] = true;\\n        int steps = 0;\\n        \\n        while(!que.empty()) {\\n            int size = que.size();\\n            \\n            //check this level\\n            while(size--) {\\n                int curr = que.front();\\n                que.pop();\\n                \\n                if(curr == n-1) {\\n                    //BFS ensures minimum steps\\n                    //We are moving level by level\\n                    return steps;\\n                }\\n                \\n                int left  = curr-1;\\n                int right = curr+1;\\n                \\n                if(left >= 0 && !visited[left]) {\\n                    que.push(left);\\n                    visited[left] = true;\\n                }\\n                \\n                if(right < n && !visited[right]) {\\n                    que.push(right);\\n                    visited[right] = true;\\n                }\\n                \\n                for(const int &idx : mp[arr[curr]]) {\\n                    if(!visited[idx]) {\\n                        que.push(idx);\\n                        visited[idx] = true;\\n                    }\\n                }\\n                //If you don\\'t erase it, you may be again checking for it\\n                //in future. It will cause TLE\\n                mp.erase(arr[curr]);\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n == 1)\\n            return 0;\\n        return solve_BFS(arr, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988895,
                "title": "jump-game-iv-python-bfs-with-explanation",
                "content": "Breadth first search (BFS) for the single-source shortest distance in an one-dimensional space. \\n\\nThe twist here is the \"jump\" operation. To support jump, maintain a dict (`val2id`) that collects all the positions that hold the same value. At each point during the BFS, besides expand to the direct left and right, also expand to the locations where the value is the same (`val2id[a[i]]`). \\n\\nOnce you expanded for a certain value, you can delete that entry from `val2id` because even if you reach the same value later, it won\\'t give you a shorter distance. This will also ensure that you only visit the value of each location at most once, and thus bounds the time complexity  by O(n), where n being the array length.\\n\\n```python\\nclass Solution:\\n    def minJumps(self, a: List[int]) -> int:\\n        n = len(a)\\n        val2id = {}\\n        for i, x in enumerate(a):\\n            val2id.setdefault(x, []).append(i)\\n        d = [inf] * n\\n        d[0] = 0\\n        q = [0]\\n        while len(q) and q[0] != n - 1:\\n            i = q.pop(0)\\n            ii = i - 1\\n            if 0 <= ii and d[ii] is inf:\\n                d[ii] = d[i] + 1\\n                q.append(ii)\\n            ii = i + 1\\n            if ii < n and d[ii] is inf:\\n                d[ii] = d[i] + 1\\n                q.append(ii)\\n            if a[i] in val2id:\\n                for ii in val2id[a[i]]:\\n                    if d[ii] is inf:\\n                        d[ii] = d[i] + 1\\n                        q.append(ii)\\n                del val2id[a[i]]\\n        return d[n - 1]\\n```\\n\\n---\\nIf you find this helpful, please consider **upvote**. It will encourage me to write more explanations like this. Thank you! :-)",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minJumps(self, a: List[int]) -> int:\\n        n = len(a)\\n        val2id = {}\\n        for i, x in enumerate(a):\\n            val2id.setdefault(x, []).append(i)\\n        d = [inf] * n\\n        d[0] = 0\\n        q = [0]\\n        while len(q) and q[0] != n - 1:\\n            i = q.pop(0)\\n            ii = i - 1\\n            if 0 <= ii and d[ii] is inf:\\n                d[ii] = d[i] + 1\\n                q.append(ii)\\n            ii = i + 1\\n            if ii < n and d[ii] is inf:\\n                d[ii] = d[i] + 1\\n                q.append(ii)\\n            if a[i] in val2id:\\n                for ii in val2id[a[i]]:\\n                    if d[ii] is inf:\\n                        d[ii] = d[i] + 1\\n                        q.append(ii)\\n                del val2id[a[i]]\\n        return d[n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504143,
                "title": "c-solution-with-comments-and-explanation",
                "content": "As most people have already pointed out, this problem can be reduced to a basic shortest path problem, where edges have uniform weight of 1. This means we can use a BFS to get the answer quite easily. There are a few things to realize here though.\\n1. The indices of the argument array can be thought of as the vertices in a graph.\\n2. You use the \"rules\" of the game to determine the structure of the graph, as in, how the vertices are connected.\\n3. If there are multiple values in the argument array in a row which are the same (i.e. if arr was {1, 2, 2, 2, 2, 7}), you technically only need to consider the end-points of this sub-array. That is, you could treat the array as if it was {1, 2, 2, 7} and end up with the same result. Doing this will increase the efficiency of the algorithm in some cases and one of these cases was specifically tested for (final test case).\\n```java\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        if (arr.Length == 1) return 0;        \\n        \\n        // Basic shortest path setup:\\n        int[] d = new int[arr.Length];                                      // Tracks # of jumps from index 0\\n        Dictionary<int, List<int>> vd = new Dictionary<int, List<int>>();   // Maps values to indices\\n        bool[] seen = new bool[arr.Length];                                 // Tracks which indices have been seen\\n        Queue<int> q = new Queue<int>();                                    // BFS queue\\n        \\n        // Initializing \"vd\"\\n        for (int i = 0; i < arr.Length; i++) {\\n            if (!vd.ContainsKey(arr[i])) vd[arr[i]] = new List<int>() { i };\\n            else {\\n                vd[arr[i]].Add(i);\\n                // If there are multiple values that are equal in a row, we only want the endpoints for extra efficiency.\\n                // This is needed to pass the final test case.\\n                while (i < arr.Length - 1 && arr[i] == arr[i + 1]) i++;\\n                if (vd[arr[i]][vd[arr[i]].Count - 1] != i) vd[arr[i]].Add(i);\\n            }\\n        }\\n        \\n        // Setting known values\\n        d[0] = 0;               // # of jumps to index 0 from index 0 is obviously 0\\n        seen[0] = true;         // We\\'ve seen index 0\\n        q.Enqueue(0);           // Queue index 0\\n\\n        while (q.Count > 0) {\\n            int u = q.Dequeue();                                // Dequeue (standard BFS)\\n            foreach (int v in Adj(arr, u, vd))                  // Iterate over \"adjacent vertices\" (indices we can jump to)\\n                if (!seen[v]) {                                 // We only need to consider \"unseen\" vertices\\n                    seen[v] = true;                             // Mark \"vertex\" (index) as seen\\n                    d[v] = 1 + d[u];                            // Record # of jumps from \"source vertex\" (index 0)\\n                    if (v == arr.Length - 1) return d[v];       // As soon as we reach the last index, we are done.\\n                    q.Enqueue(v);                               // Queue up the unseen adjacent \"vertex\" (standard BFS)\\n                }\\n        }\\n        return -1;      // Shouldn\\'t ever return this, since there is always a \"path\" from index 0 to the last index.\\n    }\\n    \\n    // Returns a list of \"adjacent\" vertices, using the rules of the game.\\n    public static List<int> Adj(int[] arr, int i, Dictionary<int, List<int>> valueDict) {\\n        List<int> res = new List<int>();\\n        if (i > 0)res.Add(i - 1);                   // If i > 0, we can jump to the previous index\\n        if (i < arr.Length - 1)res.Add(i + 1);      // If i < arr.Length, we can jump to the next index\\n        \\n        // We can also jump to any index where the values are equal.\\n        valueDict[arr[i]].ForEach(index => { if (index != i) res.Add(index); });\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        if (arr.Length == 1) return 0;        \\n        \\n        // Basic shortest path setup:\\n        int[] d = new int[arr.Length];                                      // Tracks # of jumps from index 0\\n        Dictionary<int, List<int>> vd = new Dictionary<int, List<int>>();   // Maps values to indices\\n        bool[] seen = new bool[arr.Length];                                 // Tracks which indices have been seen\\n        Queue<int> q = new Queue<int>();                                    // BFS queue\\n        \\n        // Initializing \"vd\"\\n        for (int i = 0; i < arr.Length; i++) {\\n            if (!vd.ContainsKey(arr[i])) vd[arr[i]] = new List<int>() { i };\\n            else {\\n                vd[arr[i]].Add(i);\\n                // If there are multiple values that are equal in a row, we only want the endpoints for extra efficiency.\\n                // This is needed to pass the final test case.\\n                while (i < arr.Length - 1 && arr[i] == arr[i + 1]) i++;\\n                if (vd[arr[i]][vd[arr[i]].Count - 1] != i) vd[arr[i]].Add(i);\\n            }\\n        }\\n        \\n        // Setting known values\\n        d[0] = 0;               // # of jumps to index 0 from index 0 is obviously 0\\n        seen[0] = true;         // We\\'ve seen index 0\\n        q.Enqueue(0);           // Queue index 0\\n\\n        while (q.Count > 0) {\\n            int u = q.Dequeue();                                // Dequeue (standard BFS)\\n            foreach (int v in Adj(arr, u, vd))                  // Iterate over \"adjacent vertices\" (indices we can jump to)\\n                if (!seen[v]) {                                 // We only need to consider \"unseen\" vertices\\n                    seen[v] = true;                             // Mark \"vertex\" (index) as seen\\n                    d[v] = 1 + d[u];                            // Record # of jumps from \"source vertex\" (index 0)\\n                    if (v == arr.Length - 1) return d[v];       // As soon as we reach the last index, we are done.\\n                    q.Enqueue(v);                               // Queue up the unseen adjacent \"vertex\" (standard BFS)\\n                }\\n        }\\n        return -1;      // Shouldn\\'t ever return this, since there is always a \"path\" from index 0 to the last index.\\n    }\\n    \\n    // Returns a list of \"adjacent\" vertices, using the rules of the game.\\n    public static List<int> Adj(int[] arr, int i, Dictionary<int, List<int>> valueDict) {\\n        List<int> res = new List<int>();\\n        if (i > 0)res.Add(i - 1);                   // If i > 0, we can jump to the previous index\\n        if (i < arr.Length - 1)res.Add(i + 1);      // If i < arr.Length, we can jump to the next index\\n        \\n        // We can also jump to any index where the values are equal.\\n        valueDict[arr[i]].ForEach(index => { if (index != i) res.Add(index); });\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260687,
                "title": "java-extra-trick-with-bfs-to-make-it-o-n",
                "content": "BFS solution is straigh forward.\\n\\n1. Make a hashmap from number to list indices which will store a number mapped to list of indices where it is seen.\\n2. Do a BFS with visited array and every index we will do four case.\\n\\t1.  if currently polled index from queue is n-1 then we found answer.\\n\\t2.  add index+1 to bfs queue if its not visited.\\n\\t3. add index-1 to bfs queue if not visited.\\n\\t4. Iterate through the list which contains same number as arr[index] and add indices which are not visited.\\nwith this we will get solution.\\n\\n**NOTE:**\\nMain trick here is that as soon we iterate through the list of matches arr[index], I am clearing the list, because if indices in a list are already added once, we don\\'t need to iterate through list because next time iterating through same list only results in not adding them to queue as they will already be visited. Since we are doing clear part inside for loop we don\\'t need to use visited array we can just use (pos != index) if condition.\\n\\n\\nTime: O(N)\\nSpace: O(N)\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        \\n        Map<Integer, List<Integer>> finder = new HashMap<>();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            finder.computeIfAbsent(arr[i], v -> new ArrayList<Integer>());\\n            finder.get(arr[i]).add(i);\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        \\n        Queue<Integer> current = new LinkedList<Integer>();\\n        \\n        current.add(0);\\n        visited[0] = true;\\n        \\n        int steps = 0;\\n        while (!current.isEmpty()) {\\n            int x = current.size();\\n            \\n            for (int i = 0; i < x; ++i) {\\n                int index = current.poll();\\n                if (index == n-1) {\\n                    return steps;\\n                }\\n                \\n                if ((index + 1) < n && !visited[index+1]) {\\n                    visited[index + 1] = true;\\n                    current.add(index + 1);\\n                }\\n                \\n                if (index - 1 >= 0 && !visited[index-1]) {\\n                    visited[index - 1] = true;\\n                    current.add(index - 1);\\n                }\\n                \\n                for (int pos : finder.get(arr[index])) {\\n                    if (pos != index) {\\n                        visited[pos] = true;\\n                        current.add(pos);\\n                    }\\n                }\\n                \\n                // Clearing the list so we won\\'t stuck in forloop at step 39 every time. \\n                finder.get(arr[index]).clear();\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        \\n        Map<Integer, List<Integer>> finder = new HashMap<>();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            finder.computeIfAbsent(arr[i], v -> new ArrayList<Integer>());\\n            finder.get(arr[i]).add(i);\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        \\n        Queue<Integer> current = new LinkedList<Integer>();\\n        \\n        current.add(0);\\n        visited[0] = true;\\n        \\n        int steps = 0;\\n        while (!current.isEmpty()) {\\n            int x = current.size();\\n            \\n            for (int i = 0; i < x; ++i) {\\n                int index = current.poll();\\n                if (index == n-1) {\\n                    return steps;\\n                }\\n                \\n                if ((index + 1) < n && !visited[index+1]) {\\n                    visited[index + 1] = true;\\n                    current.add(index + 1);\\n                }\\n                \\n                if (index - 1 >= 0 && !visited[index-1]) {\\n                    visited[index - 1] = true;\\n                    current.add(index - 1);\\n                }\\n                \\n                for (int pos : finder.get(arr[index])) {\\n                    if (pos != index) {\\n                        visited[pos] = true;\\n                        current.add(pos);\\n                    }\\n                }\\n                \\n                // Clearing the list so we won\\'t stuck in forloop at step 39 every time. \\n                finder.get(arr[index]).clear();\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257955,
                "title": "rust-elixir-hashing-bfs",
                "content": "# Approach\\nUse a HashMap to store the list of indices for each arr value.\\nAfter each BFS move, delete the respective indices list from the HashMap so it won\\'t be iterated over again.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n# Rust\\n```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn min_jumps(arr: Vec<i32>) -> i32 {\\n        let mut hash = HashMap::new();\\n        for (i, &x) in arr.iter().enumerate() {\\n            hash.entry(x).or_insert(Vec::new()).push(i);\\n        }\\n        let mut visited = vec![false; arr.len()];\\n        visited[0] = true;\\n        \\n        let mut curr = vec![0];\\n        let mut next = Vec::new();\\n        for step in 0.. {\\n            for i in curr.drain(..) {\\n                if i == arr.len() - 1 {\\n                    return step;\\n                }\\n                for j in hash.remove(&arr[i])\\n                            .unwrap_or(Vec::new())\\n                            .into_iter()\\n                            .chain(vec![i.saturating_sub(1), i + 1].into_iter()) {\\n                    if !visited[j] {\\n                        next.push(j);\\n                        visited[j] = true;\\n                    }\\n                }\\n            }\\n            std::mem::swap(&mut curr, &mut next);\\n        }\\n        unreachable!()\\n    }\\n}\\n```\\n# Elixir\\n```elixir\\ndefmodule Solution do\\n  @spec min_jumps(arr :: [integer]) :: integer\\n  def min_jumps(arr) do\\n    map =\\n      Enum.with_index(arr)\\n      |> Enum.reduce(%{}, fn {x, i}, map ->\\n        Map.update(map, x, [i], &([i | &1]))\\n      end)\\n    \\n    bfs([0], [], 0, MapSet.new([0]), List.to_tuple(arr), map)\\n  end\\n\\n  defp bfs([i | _], _, step, _, t, _) when i == tuple_size(t) - 1, do: step\\n  defp bfs([i | tail], list2, step, visited, t, map) do\\n    Map.get(map, elem(t, i), [])\\n    |> Kernel.++([i - 1, i + 1])\\n    |> Enum.reduce({list2, visited}, fn j, {list2, visited} ->\\n      if j >= 0 and j < tuple_size(t) and not MapSet.member?(visited, j) do\\n        {[j | list2], MapSet.put(visited, j)}\\n      else\\n        {list2, visited}\\n      end\\n    end)\\n    |> then(fn {list2, visited} ->\\n      bfs(tail, list2, step, visited, t, Map.delete(map, elem(t, i)))\\n    end)\\n  end\\n  defp bfs([], list2, step, visited, t, map) do\\n    bfs(list2, [], step + 1, visited, t, map)\\n  end\\nend\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn min_jumps(arr: Vec<i32>) -> i32 {\\n        let mut hash = HashMap::new();\\n        for (i, &x) in arr.iter().enumerate() {\\n            hash.entry(x).or_insert(Vec::new()).push(i);\\n        }\\n        let mut visited = vec![false; arr.len()];\\n        visited[0] = true;\\n        \\n        let mut curr = vec![0];\\n        let mut next = Vec::new();\\n        for step in 0.. {\\n            for i in curr.drain(..) {\\n                if i == arr.len() - 1 {\\n                    return step;\\n                }\\n                for j in hash.remove(&arr[i])\\n                            .unwrap_or(Vec::new())\\n                            .into_iter()\\n                            .chain(vec![i.saturating_sub(1), i + 1].into_iter()) {\\n                    if !visited[j] {\\n                        next.push(j);\\n                        visited[j] = true;\\n                    }\\n                }\\n            }\\n            std::mem::swap(&mut curr, &mut next);\\n        }\\n        unreachable!()\\n    }\\n}\\n```\n```elixir\\ndefmodule Solution do\\n  @spec min_jumps(arr :: [integer]) :: integer\\n  def min_jumps(arr) do\\n    map =\\n      Enum.with_index(arr)\\n      |> Enum.reduce(%{}, fn {x, i}, map ->\\n        Map.update(map, x, [i], &([i | &1]))\\n      end)\\n    \\n    bfs([0], [], 0, MapSet.new([0]), List.to_tuple(arr), map)\\n  end\\n\\n  defp bfs([i | _], _, step, _, t, _) when i == tuple_size(t) - 1, do: step\\n  defp bfs([i | tail], list2, step, visited, t, map) do\\n    Map.get(map, elem(t, i), [])\\n    |> Kernel.++([i - 1, i + 1])\\n    |> Enum.reduce({list2, visited}, fn j, {list2, visited} ->\\n      if j >= 0 and j < tuple_size(t) and not MapSet.member?(visited, j) do\\n        {[j | list2], MapSet.put(visited, j)}\\n      else\\n        {list2, visited}\\n      end\\n    end)\\n    |> then(fn {list2, visited} ->\\n      bfs(tail, list2, step, visited, t, Map.delete(map, elem(t, i)))\\n    end)\\n  end\\n  defp bfs([], list2, step, visited, t, map) do\\n    bfs(list2, [], step + 1, visited, t, map)\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2953698,
                "title": "simple-c-solution-with-various-optimization-to-reduce-sample-spaces",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> vis(n,0);\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0] = 1;\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0; i<n; i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        unordered_set<int> us;\\n        \\n        while(!q.empty())\\n        {\\n            \\n            int sz = q.size();\\n            while(sz--)\\n            {\\n            int i = q.front().first;\\n            int step = q.front().second;\\n            //cout<<i<<\" \"<<step<<endl;\\n            q.pop();\\n            \\n            if(i==n-1) return step;\\n                \\n            if(i+1<n && !vis[i+1] && arr[i+1]!=arr[i])\\n            {\\n                q.push({i+1,step+1});\\n                vis[i+1]=1;\\n            }\\n                \\n            if(i-1>=0 && !vis[i-1] && arr[i-1]!=arr[i])\\n            {\\n                q.push({i-1,step+1});\\n                vis[i-1]=1;\\n            }   \\n               \\n            if(us.count(arr[i])) continue;\\n            us.insert(arr[i]);\\n                \\n            for(int j=0; j<mp[arr[i]].size(); j++)\\n            {\\n                if(!vis[mp[arr[i]][j]] && mp[arr[i]][j] != i)\\n                {\\n                    q.push({mp[arr[i]][j],step+1});\\n                    vis[mp[arr[i]][j]]=1;\\n                }\\n            }\\n            \\n            }\\n            //cout<<\"ek kaam\"<<endl;\\n        }\\n        return INT_MAX;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> vis(n,0);\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0] = 1;\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0; i<n; i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        unordered_set<int> us;\\n        \\n        while(!q.empty())\\n        {\\n            \\n            int sz = q.size();\\n            while(sz--)\\n            {\\n            int i = q.front().first;\\n            int step = q.front().second;\\n            //cout<<i<<\" \"<<step<<endl;\\n            q.pop();\\n            \\n            if(i==n-1) return step;\\n                \\n            if(i+1<n && !vis[i+1] && arr[i+1]!=arr[i])\\n            {\\n                q.push({i+1,step+1});\\n                vis[i+1]=1;\\n            }\\n                \\n            if(i-1>=0 && !vis[i-1] && arr[i-1]!=arr[i])\\n            {\\n                q.push({i-1,step+1});\\n                vis[i-1]=1;\\n            }   \\n               \\n            if(us.count(arr[i])) continue;\\n            us.insert(arr[i]);\\n                \\n            for(int j=0; j<mp[arr[i]].size(); j++)\\n            {\\n                if(!vis[mp[arr[i]][j]] && mp[arr[i]][j] != i)\\n                {\\n                    q.push({mp[arr[i]][j],step+1});\\n                    vis[mp[arr[i]][j]]=1;\\n                }\\n            }\\n            \\n            }\\n            //cout<<\"ek kaam\"<<endl;\\n        }\\n        return INT_MAX;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1691313,
                "title": "simple-easy-to-understand",
                "content": "**Idea?**\\n* Do a simple **breadth first search** to find out the minimum number of jumps required.\\n* Visit adjacent indices for every current index, provided they are still unvisited.\\n* Also, for a particular index i, **visit all those indices j which has same value as of arr[i]**, and there is **no need to visit those indices again.**\\n* Check Code below.\\n\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int,vector<int>> mp; // unique elements to their indices\\n        for(int i=0;i<n;i++)\\n            mp[arr[i]].push_back(i);\\n        queue<pair<int,int>> q; // {element,jumps}\\n        vector<bool> vis(n);\\n        vis[0] = true;\\n        q.push({0,0});\\n        int ans;\\n        while(!q.empty()){\\n            int v = q.front().first,jumps = q.front().second;\\n            q.pop();\\n            if(v==n-1){\\n                ans = jumps;\\n                break;\\n            }\\n            if(v+1<n and !vis[v+1]){\\n                vis[v+1] = true;\\n                q.push({v+1,jumps+1});\\n            }\\n            if(v-1>=0 and !vis[v-1]){\\n                vis[v-1] = true;\\n                q.push({v-1,jumps+1});\\n            }\\n            if(!mp.count(arr[v]))\\n                continue;\\n            for(auto& j:mp[arr[v]]){\\n                if(!vis[j]){\\n                    vis[j] = true;\\n                    q.push({j,jumps+1});\\n                }\\n            }\\n            mp.erase(arr[v]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int,vector<int>> mp; // unique elements to their indices\\n        for(int i=0;i<n;i++)\\n            mp[arr[i]].push_back(i);\\n        queue<pair<int,int>> q; // {element,jumps}\\n        vector<bool> vis(n);\\n        vis[0] = true;\\n        q.push({0,0});\\n        int ans;\\n        while(!q.empty()){\\n            int v = q.front().first,jumps = q.front().second;\\n            q.pop();\\n            if(v==n-1){\\n                ans = jumps;\\n                break;\\n            }\\n            if(v+1<n and !vis[v+1]){\\n                vis[v+1] = true;\\n                q.push({v+1,jumps+1});\\n            }\\n            if(v-1>=0 and !vis[v-1]){\\n                vis[v-1] = true;\\n                q.push({v-1,jumps+1});\\n            }\\n            if(!mp.count(arr[v]))\\n                continue;\\n            for(auto& j:mp[arr[v]]){\\n                if(!vis[j]){\\n                    vis[j] = true;\\n                    q.push({j,jumps+1});\\n                }\\n            }\\n            mp.erase(arr[v]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690927,
                "title": "python3-recursion-gives-tle-check-out-bfs-solution",
                "content": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        d = defaultdict(list)\\n        for j, i in enumerate(arr):\\n            d[i].append(j)\\n        ans = float(\"inf\")\\n        visited = set()\\n\\n        def rec(i, jump):\\n            nonlocal ans, visited, d\\n            if 0 > i or i >= len(arr) or i in visited:\\n                return\\n\\n            if i == len(arr)-1:\\n                ans = min(ans, jump)\\n                return\\n            visited.add(i)\\n            rec(i-1, jump+1)\\n            rec(i+1, jump+1)\\n            for ele in d[arr[i]]:\\n                if ele > i:\\n                    rec(ele, jump+1)\\n            visited.remove(i)\\n\\n        rec(0, 0)\\n        return ans\\n```\\n\\nIt gives TLE for [51,64,-15,58,98,31,48,72,78,-63,92,-5,64,-64,51,-48,64,48,-76,-86,-5,-64,-86,-47,92,-41,58,72,31,78,-15,-76,72,-5,-97,98,78,-97,-41,\\n-47,-86,-97,78,-97,58,-41,72,-41,72,-25,-76,51,-86,-65,78,-63,72,-15,48,-15,-63,-65,31,-41,95,51,-47,51,-41,-76,58,-81,-41,88,58,-81,88,88,-47,-48,72,-25,-86,-41,-86,-64,-15,-63]\\n\\n*If you can make the above work, then pls comment the solution, thanks in advance!! :)*\\n\\n**BFS Solution:**\\n\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        d = defaultdict(list)\\n        for j, ele in enumerate(arr):\\n            d[ele].append(j)\\n\\n        queue = deque([0])\\n        steps = 0\\n        visited = {0}\\n        n = len(arr)\\n        while queue:\\n            for _ in range(len(queue)):\\n                i = queue.popleft()\\n                if i == n - 1:\\n                    return steps\\n                for ele in [*d[arr[i]], i-1, i+1]:\\n                    if ele not in visited and 0 <= ele <= n:\\n                        visited.add(ele)\\n                        queue.append(ele)\\n                d[arr[i]].clear() # We should clear the list of index, to avoid recalculation at line **for ele in [*d[arr[i]], i-1, i+1]:**\\n            steps += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        d = defaultdict(list)\\n        for j, i in enumerate(arr):\\n            d[i].append(j)\\n        ans = float(\"inf\")\\n        visited = set()\\n\\n        def rec(i, jump):\\n            nonlocal ans, visited, d\\n            if 0 > i or i >= len(arr) or i in visited:\\n                return\\n\\n            if i == len(arr)-1:\\n                ans = min(ans, jump)\\n                return\\n            visited.add(i)\\n            rec(i-1, jump+1)\\n            rec(i+1, jump+1)\\n            for ele in d[arr[i]]:\\n                if ele > i:\\n                    rec(ele, jump+1)\\n            visited.remove(i)\\n\\n        rec(0, 0)\\n        return ans\\n```\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        d = defaultdict(list)\\n        for j, ele in enumerate(arr):\\n            d[ele].append(j)\\n\\n        queue = deque([0])\\n        steps = 0\\n        visited = {0}\\n        n = len(arr)\\n        while queue:\\n            for _ in range(len(queue)):\\n                i = queue.popleft()\\n                if i == n - 1:\\n                    return steps\\n                for ele in [*d[arr[i]], i-1, i+1]:\\n                    if ele not in visited and 0 <= ele <= n:\\n                        visited.add(ele)\\n                        queue.append(ele)\\n                d[arr[i]].clear() # We should clear the list of index, to avoid recalculation at line **for ele in [*d[arr[i]], i-1, i+1]:**\\n            steps += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055395,
                "title": "python-bfs-w-comment",
                "content": "```py\\n\\'\\'\\'\\nw: minimum steps --> BFS\\nh: 1) build a graph where node is index of the arr\\n   2) for each node, we have three choices:\\n        1) index + 1\\n        2) index - 1\\n        3) index_i to index_j where arr[i]==arr[j]\\n   3) process like regular BFS until we hit the last index\\nNote that if we only use BFS to solve, we might encounter a memory limit problem\\nthis is because [7,....,7, 11] if all the numbers are the same except the last one, the graph and queue are huge, so we need to do a compression on original arr, note that\\n[7,....,7,11] is actually the same as [7,7,11] -- this may be the hard part of this problem\\n\\'\\'\\'\\n\\nimport collections\\n\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        if len(arr) == 1:\\n            return 0\\n        \\n        if arr[0] == arr[-1]:\\n            return 1\\n        \\n        # compress the original array\\n        compressedArr = arr[0:2]\\n        for num in arr[2:]:\\n            if num == compressedArr[-1] == compressedArr[-2]:\\n                continue\\n            compressedArr.append(num)\\n        arr = compressedArr\\n        \\n        indexDic = collections.defaultdict(list)\\n        for idx, num in enumerate(arr):\\n            indexDic[num].append(idx)\\n        \\n        graph = collections.defaultdict(set)\\n        for idx, num in enumerate(arr):\\n            # 1. idx + 1 or idx-1 or both\\n            if idx == 0:\\n                graph[idx].add(idx+1)\\n            elif idx == len(arr)-1:\\n                graph[idx].add(idx-1)\\n            else:\\n                graph[idx].add(idx-1)\\n                graph[idx].add(idx+1)\\n            \\n            # 2. arr[i] == arr[j], i != j\\n            for v in indexDic[num]:\\n                if v != idx:\\n                    graph[idx].add(v)\\n        \\n        #print(graph)\\n        seen = set()\\n        deque = collections.deque([0])\\n        steps = 0\\n        \\n        while deque:\\n            size = len(deque)\\n            for _ in range(size):\\n                curr = deque.popleft()\\n                seen.add(curr)\\n                if curr == len(arr) - 1:\\n                    return steps # note that we will always hit the last index\\n                \\n                for child in graph[curr]:\\n                    if child not in seen:\\n                        deque.append(child)\\n                        seen.add(child)\\n                \\n                \\n            steps += 1   \\n            #print(deque)   \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```py\\n\\'\\'\\'\\nw: minimum steps --> BFS\\nh: 1) build a graph where node is index of the arr\\n   2) for each node, we have three choices:\\n        1) index + 1\\n        2) index - 1\\n        3) index_i to index_j where arr[i]==arr[j]\\n   3) process like regular BFS until we hit the last index\\nNote that if we only use BFS to solve, we might encounter a memory limit problem\\nthis is because [7,....,7, 11] if all the numbers are the same except the last one, the graph and queue are huge, so we need to do a compression on original arr, note that\\n[7,....,7,11] is actually the same as [7,7,11] -- this may be the hard part of this problem\\n\\'\\'\\'\\n\\nimport collections\\n\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        if len(arr) == 1:\\n            return 0\\n        \\n        if arr[0] == arr[-1]:\\n            return 1\\n        \\n        # compress the original array\\n        compressedArr = arr[0:2]\\n        for num in arr[2:]:\\n            if num == compressedArr[-1] == compressedArr[-2]:\\n                continue\\n            compressedArr.append(num)\\n        arr = compressedArr\\n        \\n        indexDic = collections.defaultdict(list)\\n        for idx, num in enumerate(arr):\\n            indexDic[num].append(idx)\\n        \\n        graph = collections.defaultdict(set)\\n        for idx, num in enumerate(arr):\\n            # 1. idx + 1 or idx-1 or both\\n            if idx == 0:\\n                graph[idx].add(idx+1)\\n            elif idx == len(arr)-1:\\n                graph[idx].add(idx-1)\\n            else:\\n                graph[idx].add(idx-1)\\n                graph[idx].add(idx+1)\\n            \\n            # 2. arr[i] == arr[j], i != j\\n            for v in indexDic[num]:\\n                if v != idx:\\n                    graph[idx].add(v)\\n        \\n        #print(graph)\\n        seen = set()\\n        deque = collections.deque([0])\\n        steps = 0\\n        \\n        while deque:\\n            size = len(deque)\\n            for _ in range(size):\\n                curr = deque.popleft()\\n                seen.add(curr)\\n                if curr == len(arr) - 1:\\n                    return steps # note that we will always hit the last index\\n                \\n                for child in graph[curr]:\\n                    if child not in seen:\\n                        deque.append(child)\\n                        seen.add(child)\\n                \\n                \\n            steps += 1   \\n            #print(deque)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 988982,
                "title": "c-with-expl-on-why-dfs-fails-and-how-to-efficiently-pass-bfs",
                "content": "Crucial Part to get rid of BFS TLE:\\n\\n\"indexMap[arr[index]].clear();\"\\nWe should be clearing the map and you might be wondering that visited array might be taking care of that which is correct but it still is iterarting over the map and hence makes sense to clear the map.\\n\\nDFS will work but will give TLE. If you try memoizing it, TLE would go away but ans would be wrong bcz you are just calculating first value you find which may not be min(optimal) bcz DFS is random order only.\\n\\nConclusion: Using BFS bcz MINIMUM distance is req and clearing map helps!\\n```\\nclass Solution {\\npublic:\\n  /**  int rec(vector<int> &arr, vector<int> visited, map<int, vector<int>> &indexMap, vector<int> &dp, int index){\\n        int ans=-1;\\n        if(index==arr.size()-1){\\n            return 0;\\n        }\\n        if(index>= arr.size() || index<0){\\n           return INT_MAX;\\n        }\\n        cout<<dp[index];\\n        \\n        visited[index]=true;\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        int ans1=INT_MAX, ans2=INT_MAX, ans3=INT_MAX;   \\n        if(index-1>=0 && !visited[index-1])\\n            ans1= rec(arr, visited, indexMap, dp,index-1);\\n        if(index+1<arr.size() && !visited[index+1])\\n            ans2= rec(arr, visited, indexMap, dp,index+1);\\n        vector<int> temp= indexMap[arr[index]];\\n        for(int i=0;i<temp.size();i++){\\n           if(temp[i]!=index && !visited[temp[i]]){\\n               ans3=rec(arr, visited, indexMap, dp,temp[i]);\\n           }\\n        }\\n        cout<<ans1<<ans2<<ans3<<endl;\\n        ans=min(ans1, min(ans2, ans3));\\n        if(ans==INT_MAX) { dp[index]=0; return 0;}\\n        else\\n         {dp[index]=ans+1; return ans+1;}\\n    }\\n    **/\\n    \\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> indexMap;\\n        for(int i=0;i<arr.size();i++){\\n            indexMap[arr[i]].push_back(i);\\n        }\\n        vector<int> visited(arr.size(),0);\\n        vector<int> dp(arr.size()+1,-1);\\n        \\n        queue<int> q;\\n        q.push(0);\\n        visited[0]=1;\\n        int steps=0;\\n        while(q.size()>0){\\n            int sz=q.size();\\n            while(sz--){\\n                int index= q.front();\\n                q.pop();\\n                if(index==arr.size()-1) return steps;\\n                if(index-1>=0 && !visited[index-1]){\\n                    q.push(index-1);\\n                    visited[index-1]=1;\\n                }\\n                if(index+1<arr.size() && !visited[index+1]){\\n                    if(index+1==arr.size()-1) return steps+1;\\n                    q.push(index+1);\\n                    visited[index+1]=1;\\n                }\\n                vector<int> temp= indexMap[arr[index]];\\n                for(int i=0;i<temp.size();i++){     \\n                    if(temp[i]==arr.size()-1) return steps+1;\\n                   if(temp[i]!=index && temp[i]!=index-1 && temp[i]!=index-1 &&!visited[temp[i]]){\\n                       \\n                       q.push(temp[i]);\\n                       visited[temp[i]]=1;\\n                   }\\n                }\\n                indexMap[arr[index]].clear();\\n                \\n                \\n            }\\n            \\n            steps++;\\n            \\n            \\n        }\\n        return steps;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  /**  int rec(vector<int> &arr, vector<int> visited, map<int, vector<int>> &indexMap, vector<int> &dp, int index){\\n        int ans=-1;\\n        if(index==arr.size()-1){\\n            return 0;\\n        }\\n        if(index>= arr.size() || index<0){\\n           return INT_MAX;\\n        }\\n        cout<<dp[index];\\n        \\n        visited[index]=true;\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        int ans1=INT_MAX, ans2=INT_MAX, ans3=INT_MAX;   \\n        if(index-1>=0 && !visited[index-1])\\n            ans1= rec(arr, visited, indexMap, dp,index-1);\\n        if(index+1<arr.size() && !visited[index+1])\\n            ans2= rec(arr, visited, indexMap, dp,index+1);\\n        vector<int> temp= indexMap[arr[index]];\\n        for(int i=0;i<temp.size();i++){\\n           if(temp[i]!=index && !visited[temp[i]]){\\n               ans3=rec(arr, visited, indexMap, dp,temp[i]);\\n           }\\n        }\\n        cout<<ans1<<ans2<<ans3<<endl;\\n        ans=min(ans1, min(ans2, ans3));\\n        if(ans==INT_MAX) { dp[index]=0; return 0;}\\n        else\\n         {dp[index]=ans+1; return ans+1;}\\n    }\\n    **/\\n    \\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> indexMap;\\n        for(int i=0;i<arr.size();i++){\\n            indexMap[arr[i]].push_back(i);\\n        }\\n        vector<int> visited(arr.size(),0);\\n        vector<int> dp(arr.size()+1,-1);\\n        \\n        queue<int> q;\\n        q.push(0);\\n        visited[0]=1;\\n        int steps=0;\\n        while(q.size()>0){\\n            int sz=q.size();\\n            while(sz--){\\n                int index= q.front();\\n                q.pop();\\n                if(index==arr.size()-1) return steps;\\n                if(index-1>=0 && !visited[index-1]){\\n                    q.push(index-1);\\n                    visited[index-1]=1;\\n                }\\n                if(index+1<arr.size() && !visited[index+1]){\\n                    if(index+1==arr.size()-1) return steps+1;\\n                    q.push(index+1);\\n                    visited[index+1]=1;\\n                }\\n                vector<int> temp= indexMap[arr[index]];\\n                for(int i=0;i<temp.size();i++){     \\n                    if(temp[i]==arr.size()-1) return steps+1;\\n                   if(temp[i]!=index && temp[i]!=index-1 && temp[i]!=index-1 &&!visited[temp[i]]){\\n                       \\n                       q.push(temp[i]);\\n                       visited[temp[i]]=1;\\n                   }\\n                }\\n                indexMap[arr[index]].clear();\\n                \\n                \\n            }\\n            \\n            steps++;\\n            \\n            \\n        }\\n        return steps;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 876699,
                "title": "rust-translated-32ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_jumps(arr: Vec<i32>) -> i32 {\\n        use std::collections::{HashMap, VecDeque};\\n\\n        let n = arr.len();\\n        let mut graph = HashMap::<i32, Vec<i32>>::new();\\n        for i in 0..n {\\n            graph.entry(arr[i as usize]).or_default().push(i as i32);\\n        }\\n        let mut visited = vec![false; n];\\n        visited[0] = true;\\n        let mut q = VecDeque::<i32>::new();\\n        q.push_back(0);\\n        let mut step = 0;\\n        while !q.is_empty() {\\n            let size = q.len();\\n            for _ in 0..size {\\n                let i = q.pop_front().unwrap();\\n                if i == n as i32 - 1 {\\n                    return step;\\n                }\\n                let next = graph.get_mut(&arr[i as usize]).unwrap();\\n                next.push(i - 1);\\n                next.push(i + 1);\\n                for &j in next.iter() {\\n                    if j >= 0 && j < n as i32 && !visited[j as usize] {\\n                        visited[j as usize] = true;\\n                        q.push_back(j);\\n                    }\\n                }\\n                next.clear()\\n            }\\n            step += 1;\\n        }\\n        -1\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_jumps() {\\n        assert_eq!(\\n            Solution::min_jumps(vec![100, -23, -23, 404, 100, 23, 23, 23, 3, 404]),\\n            3\\n        );\\n    }\\n\\n    #[test]\\n    fn test_min_jumps_02() {\\n        assert_eq!(Solution::min_jumps(vec![7]), 0);\\n    }\\n\\n    #[test]\\n    fn test_min_jumps_03() {\\n        assert_eq!(Solution::min_jumps(vec![7, 6, 9, 6, 9, 6, 9, 7]), 1);\\n    }\\n\\n    #[test]\\n    fn test_min_jumps_04() {\\n        assert_eq!(Solution::min_jumps(vec![6, 1, 9]), 2);\\n    }\\n\\n    #[test]\\n    fn test_min_jumps_05() {\\n        assert_eq!(\\n            Solution::min_jumps(vec![11, 22, 7, 7, 7, 7, 7, 7, 7, 22, 13]),\\n            3\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_jumps(arr: Vec<i32>) -> i32 {\\n        use std::collections::{HashMap, VecDeque};\\n\\n        let n = arr.len();\\n        let mut graph = HashMap::<i32, Vec<i32>>::new();\\n        for i in 0..n {\\n            graph.entry(arr[i as usize]).or_default().push(i as i32);\\n        }\\n        let mut visited = vec![false; n];\\n        visited[0] = true;\\n        let mut q = VecDeque::<i32>::new();\\n        q.push_back(0);\\n        let mut step = 0;\\n        while !q.is_empty() {\\n            let size = q.len();\\n            for _ in 0..size {\\n                let i = q.pop_front().unwrap();\\n                if i == n as i32 - 1 {\\n                    return step;\\n                }\\n                let next = graph.get_mut(&arr[i as usize]).unwrap();\\n                next.push(i - 1);\\n                next.push(i + 1);\\n                for &j in next.iter() {\\n                    if j >= 0 && j < n as i32 && !visited[j as usize] {\\n                        visited[j as usize] = true;\\n                        q.push_back(j);\\n                    }\\n                }\\n                next.clear()\\n            }\\n            step += 1;\\n        }\\n        -1\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_jumps() {\\n        assert_eq!(\\n            Solution::min_jumps(vec![100, -23, -23, 404, 100, 23, 23, 23, 3, 404]),\\n            3\\n        );\\n    }\\n\\n    #[test]\\n    fn test_min_jumps_02() {\\n        assert_eq!(Solution::min_jumps(vec![7]), 0);\\n    }\\n\\n    #[test]\\n    fn test_min_jumps_03() {\\n        assert_eq!(Solution::min_jumps(vec![7, 6, 9, 6, 9, 6, 9, 7]), 1);\\n    }\\n\\n    #[test]\\n    fn test_min_jumps_04() {\\n        assert_eq!(Solution::min_jumps(vec![6, 1, 9]), 2);\\n    }\\n\\n    #[test]\\n    fn test_min_jumps_05() {\\n        assert_eq!(\\n            Solution::min_jumps(vec![11, 22, 7, 7, 7, 7, 7, 7, 7, 22, 13]),\\n            3\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 853365,
                "title": "no-dp-faster-bidirectional-bfs-with-explanation",
                "content": "**Updated on 2020.10.16**\\nI found my previous code and the official\\'s were not concise.\\n\\nActually, if we use bidirectional BFS in this task, \\nwe don\\'t need extra DP cache to memo any past visits\\nbecause we only need to check whether any our current side\\'s nodes\\' child nodes exist in the opposite queue. \\nIf they don\\'t not meet each other, we keep them. \\n\\nTherefore, we don\\'t need to memo visited nodes(even appear again, dumping it is easy by set() and deleting node\\'s connection) \\nand can make code more concise and cleaner as possible. (the same better efficiency)\\n****\\n\\nIntuitively, we can solve this task with BFS.\\n\\nWe can see each index as an node of three kinds of search space,\\n1. move backwards(index - 1)\\n2. in place(jump to the index of the same assigned num)\\n3. move forwards(index + 1).\\n\\nTherefore, we need a map first to check where the jumping goes, the connection of nodes.\\n\\nDuring searching, \\nwe can move search level next and next until we find the end node appears in our search level. \\n\\nBFS has a downside, as searching deeper and deeper, \\nthe space of each level will become larger and larger if the end nodes are unlimited. \\nBut in this task, the end node is only one, so the search space will shrink.\\n\\nIn other words, we can ***search forwards or backwards exchangedly***, \\nbecause if we are closed to two end-side, the search space of each level will smaller than in the middle. \\nWe can ***have chance to find all nodes by the connection in smaller space*** of level, not the larger in the middle level. \\nThat will speed search and be faster than normal BFS in some extension. \\n\\n***We only need to check when the search levels of two sides intersect.***\\n\\nCode with clear comments as below.\\nWelcome suggestion, question, comments\\nIf helpful, ***please upvote! Thanks a lot!***\\n\\n```\\nclass Solution: # bidirectional, best 368 ms\\n    def minJumps(self, array):\\n        length = len(array)\\n        if len(set(array)) == length: return length - 1\\n        if array[0] == array[-1]: return 1\\n\\n        _map = defaultdict(list) # connection map\\n        for i, val in enumerate(array): _map[val].append(i)\\n\\n        curs, other = {0}, {length - 1}\\n        for step in count():\\n            # choose smaller side\\n            if len(curs) > len(other): curs, other = other, curs\\n\\n            thisLevel = set()\\n            for i in curs:\\n                # add backward and forward moves into current jumping space\\n                # make the same operation accomplished in only one loop\\n                for j in (i + 1, i - 1):\\n                    if 0 < j < length: _map[array[i]].append(j)\\n\\n                for j in _map[array[i]]:\\n                    if j in other: return step\\n                    else: thisLevel.add(j)\\n                del _map[array[i]]\\n\\n            # update current side for next round          \\n            curs = thisLevel\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution: # bidirectional, best 368 ms\\n    def minJumps(self, array):\\n        length = len(array)\\n        if len(set(array)) == length: return length - 1\\n        if array[0] == array[-1]: return 1\\n\\n        _map = defaultdict(list) # connection map\\n        for i, val in enumerate(array): _map[val].append(i)\\n\\n        curs, other = {0}, {length - 1}\\n        for step in count():\\n            # choose smaller side\\n            if len(curs) > len(other): curs, other = other, curs\\n\\n            thisLevel = set()\\n            for i in curs:\\n                # add backward and forward moves into current jumping space\\n                # make the same operation accomplished in only one loop\\n                for j in (i + 1, i - 1):\\n                    if 0 < j < length: _map[array[i]].append(j)\\n\\n                for j in _map[array[i]]:\\n                    if j in other: return step\\n                    else: thisLevel.add(j)\\n                del _map[array[i]]\\n\\n            # update current side for next round          \\n            curs = thisLevel\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503724,
                "title": "c-solution-bfs",
                "content": "```\\npublic class Solution \\n{\\n    public int MinJumps(int[] arr) \\n    {\\n        int n = arr.Length;\\n        var numToIndex = new Dictionary<int, List<int>>();\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!numToIndex.ContainsKey(arr[i])) \\n                numToIndex[arr[i]] = new List<int>();\\n            numToIndex[arr[i]].Add(i);\\n        }\\n        \\n        var visited = new bool[n];\\n        var queue = new Queue<int>();\\n        queue.Enqueue(0);\\n        visited[0] = true;\\n        int level = 0;\\n        while(queue.Count != 0)\\n        {\\n            int count = queue.Count;\\n            for(int cnt = 0; cnt < count; cnt++)\\n            {\\n                var curr = queue.Dequeue();\\n                if(curr == n - 1) return level;\\n                var list =  numToIndex[arr[curr]];\\n                if(curr - 1 >= 0) list.Add(curr - 1);\\n                if(curr + 1 < n) list.Add(curr + 1);\\n                foreach(var i in list)\\n                {\\n                    if(!visited[i])\\n                    {\\n                        visited[i] = true;\\n                        queue.Enqueue(i);\\n                    }\\n                }\\n                \\n                numToIndex[arr[curr]] = new List<int>();\\n            }\\n            \\n            level++;\\n        }\\n        \\n        return n - 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int MinJumps(int[] arr) \\n    {\\n        int n = arr.Length;\\n        var numToIndex = new Dictionary<int, List<int>>();\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!numToIndex.ContainsKey(arr[i])) \\n                numToIndex[arr[i]] = new List<int>();\\n            numToIndex[arr[i]].Add(i);\\n        }\\n        \\n        var visited = new bool[n];\\n        var queue = new Queue<int>();\\n        queue.Enqueue(0);\\n        visited[0] = true;\\n        int level = 0;\\n        while(queue.Count != 0)\\n        {\\n            int count = queue.Count;\\n            for(int cnt = 0; cnt < count; cnt++)\\n            {\\n                var curr = queue.Dequeue();\\n                if(curr == n - 1) return level;\\n                var list =  numToIndex[arr[curr]];\\n                if(curr - 1 >= 0) list.Add(curr - 1);\\n                if(curr + 1 < n) list.Add(curr + 1);\\n                foreach(var i in list)\\n                {\\n                    if(!visited[i])\\n                    {\\n                        visited[i] = true;\\n                        queue.Enqueue(i);\\n                    }\\n                }\\n                \\n                numToIndex[arr[curr]] = new List<int>();\\n            }\\n            \\n            level++;\\n        }\\n        \\n        return n - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502721,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        if len(set(arr)) == len(arr):return len(arr)-1\\n        conn = collections.defaultdict(set)\\n        for i,val in enumerate(arr):\\n            conn[val].add(i)\\n        res,cur,seen,visit = 0, {0}, {0},set()\\n        while len(arr)-1 not in seen:\\n            res += 1\\n            tmp = set()\\n            for node in seen:\\n                if node -1 > 0 and node-1 not in seen: tmp.add(node-1)\\n                if arr[node] not in visit:\\n                    tmp |= (conn[arr[node]] - seen)\\n                    visit.add(arr[node])\\n                if node +1 < len(arr) and node +1 not in seen: tmp.add(node + 1)\\n            tmp -= seen\\n            seen |= tmp\\n            cur = tmp\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        if len(set(arr)) == len(arr):return len(arr)-1\\n        conn = collections.defaultdict(set)\\n        for i,val in enumerate(arr):\\n            conn[val].add(i)\\n        res,cur,seen,visit = 0, {0}, {0},set()\\n        while len(arr)-1 not in seen:\\n            res += 1\\n            tmp = set()\\n            for node in seen:\\n                if node -1 > 0 and node-1 not in seen: tmp.add(node-1)\\n                if arr[node] not in visit:\\n                    tmp |= (conn[arr[node]] - seen)\\n                    visit.add(arr[node])\\n                if node +1 < len(arr) and node +1 not in seen: tmp.add(node + 1)\\n            tmp -= seen\\n            seen |= tmp\\n            cur = tmp\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361905,
                "title": "bfs-hashmap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size(), ans = 0;\\n        unordered_map<int, vector<int>> m;\\n        for(int i=n-1; i>=0; i--) m[arr[i]].push_back(i);\\n        \\n        queue<pair<int, int>> q;\\n        q.push({arr[0], 0});\\n\\n        vector<int> vis(n);\\n        vis[0] = 1;\\n\\n        while(q.size()) {\\n            int l = q.size();\\n            while(l--) {\\n                int val = q.front().first, idx = q.front().second;\\n                q.pop();\\n                if(idx == n - 1) return ans;\\n\\n                if(idx + 1 < n && !vis[idx + 1]) {\\n                    q.push({arr[idx + 1], idx + 1});\\n                    vis[idx + 1] = 1;\\n                }\\n                if(idx - 1 >= 0 && !vis[idx - 1]) {\\n                    q.push({arr[idx - 1], idx - 1});\\n                    vis[idx - 1] = 1;\\n                }\\n                for(int j : m[val]) {\\n                    if(idx == j || vis[j]) continue;\\n                    q.push({arr[j], j});\\n                    vis[j] = 1;\\n                }\\n                m.erase(val);\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size(), ans = 0;\\n        unordered_map<int, vector<int>> m;\\n        for(int i=n-1; i>=0; i--) m[arr[i]].push_back(i);\\n        \\n        queue<pair<int, int>> q;\\n        q.push({arr[0], 0});\\n\\n        vector<int> vis(n);\\n        vis[0] = 1;\\n\\n        while(q.size()) {\\n            int l = q.size();\\n            while(l--) {\\n                int val = q.front().first, idx = q.front().second;\\n                q.pop();\\n                if(idx == n - 1) return ans;\\n\\n                if(idx + 1 < n && !vis[idx + 1]) {\\n                    q.push({arr[idx + 1], idx + 1});\\n                    vis[idx + 1] = 1;\\n                }\\n                if(idx - 1 >= 0 && !vis[idx - 1]) {\\n                    q.push({arr[idx - 1], idx - 1});\\n                    vis[idx - 1] = 1;\\n                }\\n                for(int j : m[val]) {\\n                    if(idx == j || vis[j]) continue;\\n                    q.push({arr[j], j});\\n                    vis[j] = 1;\\n                }\\n                m.erase(val);\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261706,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    BFS\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> g;\\n    int n, vis[50005], dis[50005];\\n\\n    int bfs(int s, vector<int>& arr) {\\n        vis[s] = 1;\\n        dis[s] = 0;\\n        queue<int> q;\\n        q.push(s);\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            if(u == n-1) return dis[n-1];\\n            if(u-1 >= 0 and !vis[u-1]) {\\n                vis[u-1] = 1;\\n                dis[u-1] = dis[u] + 1;\\n                q.push(u-1);\\n            }\\n            if(u+1 < n and !vis[u+1]) {\\n                vis[u+1] = 1;\\n                dis[u+1] = dis[u] + 1;\\n                q.push(u+1);;\\n            }\\n            for(auto v: g[arr[u]]) {\\n                if(!vis[v]) {\\n                    vis[v] = 1;\\n                    dis[v] = dis[u] + 1;\\n                    q.push(v);\\n                }\\n            }\\n            g[arr[u]].clear();\\n        }\\n        return dis[n-1];\\n    }\\n\\n    int minJumps(vector<int>& arr) {\\n        n = arr.size();\\n        for(int i=0; i<n; i++) {\\n            g[arr[i]].push_back(i);\\n        }\\n        int ans = bfs(0, arr);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> g;\\n    int n, vis[50005], dis[50005];\\n\\n    int bfs(int s, vector<int>& arr) {\\n        vis[s] = 1;\\n        dis[s] = 0;\\n        queue<int> q;\\n        q.push(s);\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            if(u == n-1) return dis[n-1];\\n            if(u-1 >= 0 and !vis[u-1]) {\\n                vis[u-1] = 1;\\n                dis[u-1] = dis[u] + 1;\\n                q.push(u-1);\\n            }\\n            if(u+1 < n and !vis[u+1]) {\\n                vis[u+1] = 1;\\n                dis[u+1] = dis[u] + 1;\\n                q.push(u+1);;\\n            }\\n            for(auto v: g[arr[u]]) {\\n                if(!vis[v]) {\\n                    vis[v] = 1;\\n                    dis[v] = dis[u] + 1;\\n                    q.push(v);\\n                }\\n            }\\n            g[arr[u]].clear();\\n        }\\n        return dis[n-1];\\n    }\\n\\n    int minJumps(vector<int>& arr) {\\n        n = arr.size();\\n        for(int i=0; i<n; i++) {\\n            g[arr[i]].push_back(i);\\n        }\\n        int ans = bfs(0, arr);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261395,
                "title": "easy-solution-c-bfs",
                "content": "\\n\\n# Approach\\n# Use Graph (BFS)\\n\\n**We will make a hashmap and store the value and index**\\nelements = 100, -23, -23, 404, 100, 23, 27, 23, 3, 404\\n index   =      0  ,   1 ,   2 ,   3  ,    4 ,  5 ,  6 , 7 ,  8 ,  9\\n \\n*HashMap*\\n100 -> 0,4\\n -23 -> 1,2\\n404 ->  3,9\\n  23 ->  5,6,7\\n    3 ->  8\\n\\t\\t\\nIn this way we have make the hashmap wherein all the values which are same we have store their index.\\n\\nfrom 0 index we  have two ways to go either go to 1index or go to 4\\nThere are two ways to go from 4 you can either go to 3 or go to 5\\nFrom this 3 you can go to wither 9 or 2 or 4 but as we have already taken 4 so don\\'t consisder it.\\n\\n**We can see this is forming a graph where index denotes the nodes of the graph and steps denotes the edges and we need to find the shortest path to reach the end**\\n\\n***We will use BFS two find the Shortest Path***\\nIn BFS we take  a Queue and a Visited Array.\\nwe will also take a step variable.\\nAs in the question it is mentioned the initially we are at 0th index so we will add 0th index to our Queue.\\n\\nNow start the BFS Traversal\\n\\nfor node = 0   next = [ 1, -1, 0, 4 ]   (next denotes the next positions we can go from zero)\\n\\nif i>=0 & i<n  and should not be visited then it is val\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg](https://assets.leetcode.com/users/images/2a444788-e8cc-4cfb-ab3b-83aa2a940eef_1678039979.9747372.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> indicesOfValue;\\n        for (int i = 0; i < n; i++)\\n            indicesOfValue[arr[i]].push_back(i);\\n        vector<bool> visited(n); visited[0] = true;\\n        queue<int> q; q.push(0);\\n        int step = 0;\\n        while (!q.empty()) {\\n            for (int size = q.size(); size > 0; --size) {\\n                int i = q.front(); q.pop();\\n                if (i == n - 1) return step; // Reached to last index\\n                vector<int>& next = indicesOfValue[arr[i]];\\n                next.push_back(i - 1); next.push_back(i + 1);\\n                for (int j : next) {\\n                    if (j >= 0 && j < n && !visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                indicesOfValue[arr[i]].clear(); // avoid later lookup indicesOfValue arr[i]\\n            }\\n            step++;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> indicesOfValue;\\n        for (int i = 0; i < n; i++)\\n            indicesOfValue[arr[i]].push_back(i);\\n        vector<bool> visited(n); visited[0] = true;\\n        queue<int> q; q.push(0);\\n        int step = 0;\\n        while (!q.empty()) {\\n            for (int size = q.size(); size > 0; --size) {\\n                int i = q.front(); q.pop();\\n                if (i == n - 1) return step; // Reached to last index\\n                vector<int>& next = indicesOfValue[arr[i]];\\n                next.push_back(i - 1); next.push_back(i + 1);\\n                for (int j : next) {\\n                    if (j >= 0 && j < n && !visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                indicesOfValue[arr[i]].clear(); // avoid later lookup indicesOfValue arr[i]\\n            }\\n            step++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260817,
                "title": "hash-table-bread-first-search-o-n-beats-91-c",
                "content": "# Code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int bfs(int src, vector<int> &arr, int n, unordered_map<int, vector<int>> &m)\\n    {\\n        vector<bool> visited(n, false);\\n        queue<int> q;\\n\\n        q.push(src);\\n        int steps = 0;\\n\\n        while (!q.empty()) {\\n            int size = q.size();\\n\\n            while (size--) {\\n                int i = q.front();\\n                q.pop();\\n\\n                visited[i] = true;\\n\\n                if (i == n - 1)\\n                    return steps;\\n\\n                int val = arr[i];\\n\\n                for (auto &j: m[val]) {\\n                    if (i == j || visited[j])\\n                        continue;\\n\\n                    q.push(j);\\n                }\\n\\n                m[val].clear();\\n\\n                if (i - 1 >= 0 && !visited[i - 1])\\n                    q.push(i - 1);\\n\\n                if (i + 1 < n && !visited[i + 1])\\n                    q.push(i + 1);\\n            }\\n\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n\\n    int minJumps(vector<int> &arr) {\\n        int n = arr.size();\\n\\n        if (n == 1)\\n            return 0;\\n\\n        if (arr[0] == arr[n - 1])\\n            return 1;\\n\\n        unordered_map<int, vector<int>> m;\\n\\n        for (int i = n - 1; i >= 0; i--)\\n            m[arr[i]].push_back(i);\\n\\n        return bfs(0, arr, n, m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int bfs(int src, vector<int> &arr, int n, unordered_map<int, vector<int>> &m)\\n    {\\n        vector<bool> visited(n, false);\\n        queue<int> q;\\n\\n        q.push(src);\\n        int steps = 0;\\n\\n        while (!q.empty()) {\\n            int size = q.size();\\n\\n            while (size--) {\\n                int i = q.front();\\n                q.pop();\\n\\n                visited[i] = true;\\n\\n                if (i == n - 1)\\n                    return steps;\\n\\n                int val = arr[i];\\n\\n                for (auto &j: m[val]) {\\n                    if (i == j || visited[j])\\n                        continue;\\n\\n                    q.push(j);\\n                }\\n\\n                m[val].clear();\\n\\n                if (i - 1 >= 0 && !visited[i - 1])\\n                    q.push(i - 1);\\n\\n                if (i + 1 < n && !visited[i + 1])\\n                    q.push(i + 1);\\n            }\\n\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n\\n    int minJumps(vector<int> &arr) {\\n        int n = arr.size();\\n\\n        if (n == 1)\\n            return 0;\\n\\n        if (arr[0] == arr[n - 1])\\n            return 1;\\n\\n        unordered_map<int, vector<int>> m;\\n\\n        for (int i = n - 1; i >= 0; i--)\\n            m[arr[i]].push_back(i);\\n\\n        return bfs(0, arr, n, m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260716,
                "title": "in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can modify the BFS approach to keep track of the number of steps taken to reach a certain index. For this, we can use a separate vector to keep track of the minimum number of steps taken to reach each index. We can initialize this vector to a large value and update it with the minimum number of steps whenever we visit an index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can modify the BFS approach to keep track of the number of steps taken to reach a certain index. For this, we can use a separate vector to keep track of the minimum number of steps taken to reach each index. We can initialize this vector to a large value and update it with the minimum number of steps whenever we visit an index.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> minSteps(n, INT_MAX);\\n        minSteps[0] = 0; // starting index\\n\\n        unordered_map<int, vector<int>> indices;\\n        for (int i = 0; i < n; i++) {\\n            indices[arr[i]].push_back(i);\\n        }\\n\\n        queue<int> q;\\n        q.push(0);\\n\\n        while (!q.empty()) {\\n            int currIndex = q.front();\\n            q.pop();\\n\\n            if (currIndex == n-1) {\\n                return minSteps[currIndex];\\n            }\\n\\n            if (currIndex-1 >= 0 && minSteps[currIndex-1] == INT_MAX) {\\n                minSteps[currIndex-1] = minSteps[currIndex]+1;\\n                q.push(currIndex-1);\\n            }\\n\\n            if (currIndex+1 < n && minSteps[currIndex+1] == INT_MAX) {\\n                minSteps[currIndex+1] = minSteps[currIndex]+1;\\n                q.push(currIndex+1);\\n            }\\n\\n            for (int index : indices[arr[currIndex]]) {\\n                if (index != currIndex && minSteps[index] == INT_MAX) {\\n                    minSteps[index] = minSteps[currIndex]+1;\\n                    q.push(index);\\n                }\\n            }\\n\\n            // clear the used indices to avoid revisiting them unnecessarily\\n            indices[arr[currIndex]].clear();\\n        }\\n\\n        return -1; // unreachable\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> minSteps(n, INT_MAX);\\n        minSteps[0] = 0; // starting index\\n\\n        unordered_map<int, vector<int>> indices;\\n        for (int i = 0; i < n; i++) {\\n            indices[arr[i]].push_back(i);\\n        }\\n\\n        queue<int> q;\\n        q.push(0);\\n\\n        while (!q.empty()) {\\n            int currIndex = q.front();\\n            q.pop();\\n\\n            if (currIndex == n-1) {\\n                return minSteps[currIndex];\\n            }\\n\\n            if (currIndex-1 >= 0 && minSteps[currIndex-1] == INT_MAX) {\\n                minSteps[currIndex-1] = minSteps[currIndex]+1;\\n                q.push(currIndex-1);\\n            }\\n\\n            if (currIndex+1 < n && minSteps[currIndex+1] == INT_MAX) {\\n                minSteps[currIndex+1] = minSteps[currIndex]+1;\\n                q.push(currIndex+1);\\n            }\\n\\n            for (int index : indices[arr[currIndex]]) {\\n                if (index != currIndex && minSteps[index] == INT_MAX) {\\n                    minSteps[index] = minSteps[currIndex]+1;\\n                    q.push(index);\\n                }\\n            }\\n\\n            // clear the used indices to avoid revisiting them unnecessarily\\n            indices[arr[currIndex]].clear();\\n        }\\n\\n        return -1; // unreachable\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260616,
                "title": "jump-game-iv-most-optimised-bfs-with-coolest-explanation-comments-gauravthinks",
                "content": "# Intuition\\nThe given problem is to find the minimum number of steps to reach the last index of the array, where in one step, we can either move to the adjacent indices or to any index having the same value as the current index.\\n\\nThe approach used to solve this problem is Breadth-First Search (BFS), where we start traversing the array from the first index, and at each step, we explore all the possible jumps that can be made from the current index. We keep track of the visited indices to avoid revisiting the same indices again, and we also maintain a queue to keep track of the indices that need to be explored in the next step.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each index, we explore three possible jumps:\\n\\ni + 1, where i + 1 < arr.length\\ni - 1, where i - 1 >= 0\\nj where arr[i] == arr[j] and i != j\\n\\nIf any of the next indices haven\\'t been visited before, we mark them as visited and add them to the queue. We repeat this process until we reach the last index of the array or until there are no more indices to explore in the queue.\\n\\nThe minimum number of steps to reach the last index of the array is the number of steps required to reach the last index from the first index, which is the number of levels in the BFS tree.\\n\\nTherefore, the intuition behind this approach is to explore all the possible jumps from each index of the array in a breadth-first manner until we reach the last index, and we maintain a count of the number of steps required to reach the last index.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the BFS algorithm used to solve this problem is O(n), where n is the number of elements in the array. This is because we visit each element of the array exactly once, and for each element, we explore at most three possible jumps.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the algorithm is also O(n), as we need to store the visited array of size n and the queue of size at most n, which can happen in the worst case when all elements have the same value.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1)return 0;\\n        // declaring a map to store the same elements at different indices\\nunordered_map<int, vector<int>> naksha;\\nfor(auto i=0; i<arr.size(); i++){\\n    naksha[arr[i]].push_back(i); // push the indices into a vector in front of the element\\n    //i.e. for a given element, at how many indices it is present, is stored into the above map\\n}\\n//making visited array(which keeps record of elements already touched ) and queue(which stores the indices of the elements)\\nvector<int> vis(n,0);\\nvis[0]=1;\\nqueue<int> koo;\\nkoo.push(0); //pushing indexes\\n\\n\\nint level=0; // this is the result or the number of level in a graph to reach the last index\\n\\nwhile(!koo.empty()){\\n   int  size= koo.size();\\n   while(size--){\\n       int  top=koo.front();\\n       koo.pop();\\n        if(top== n-1) return level; // if the  top element is the last index, return the level of the index\\n        // check for the top+1-th index , if it is valid, push the elements into queue\\n        if(top+1 <n and !vis[top+1]){\\n             vis[top+1]=1; koo.push(top+1);\\n             }\\n             // check for the top-1-th index , if it is valid, push the elements into queue\\n             if(top-1>=0 and !vis[top-1]){\\n                 vis[top-1]=1;\\n                 koo.push(top-1);\\n             }\\n\\n             //push the other indices of the elements, from \\'\\'naksha\\' map\\n             for(int nxt: naksha[arr[top]]){\\n                 if(nxt!=top and !vis[nxt]){\\n\\n                     vis[nxt]=1;\\n                     koo.push(nxt);\\n                 }\\n             }\\n             naksha[arr[top]].clear();\\n       \\n   }\\n//    when one iteration is completed, increase the level by 1\\n\\n   level++;\\n}\\nreturn -1;\\n\\n\\n           }\\n};\\n```\\nIf you liked the solution and explation, do UPVOTE the solution and subscribe to our YouTube channel \\n# @GauravThinks\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1)return 0;\\n        // declaring a map to store the same elements at different indices\\nunordered_map<int, vector<int>> naksha;\\nfor(auto i=0; i<arr.size(); i++){\\n    naksha[arr[i]].push_back(i); // push the indices into a vector in front of the element\\n    //i.e. for a given element, at how many indices it is present, is stored into the above map\\n}\\n//making visited array(which keeps record of elements already touched ) and queue(which stores the indices of the elements)\\nvector<int> vis(n,0);\\nvis[0]=1;\\nqueue<int> koo;\\nkoo.push(0); //pushing indexes\\n\\n\\nint level=0; // this is the result or the number of level in a graph to reach the last index\\n\\nwhile(!koo.empty()){\\n   int  size= koo.size();\\n   while(size--){\\n       int  top=koo.front();\\n       koo.pop();\\n        if(top== n-1) return level; // if the  top element is the last index, return the level of the index\\n        // check for the top+1-th index , if it is valid, push the elements into queue\\n        if(top+1 <n and !vis[top+1]){\\n             vis[top+1]=1; koo.push(top+1);\\n             }\\n             // check for the top-1-th index , if it is valid, push the elements into queue\\n             if(top-1>=0 and !vis[top-1]){\\n                 vis[top-1]=1;\\n                 koo.push(top-1);\\n             }\\n\\n             //push the other indices of the elements, from \\'\\'naksha\\' map\\n             for(int nxt: naksha[arr[top]]){\\n                 if(nxt!=top and !vis[nxt]){\\n\\n                     vis[nxt]=1;\\n                     koo.push(nxt);\\n                 }\\n             }\\n             naksha[arr[top]].clear();\\n       \\n   }\\n//    when one iteration is completed, increase the level by 1\\n\\n   level++;\\n}\\nreturn -1;\\n\\n\\n           }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259956,
                "title": "typescript-o-n-time-and-space",
                "content": "# Intuition\\n\\nUse two queue to preform BFS: `cur` and `next` to keep track on the current node we are checking\\n\\n# Approach\\n\\nExample: [0, 1, 2, 0, 5, 6, 1, 3]\\n\\n```ts\\n// x represents being checked in this round,\\n// while n represents the JumpNode be checked in the next round\\n\\n// Round 0\\ncur = [0]\\n\\nidx = [0, 1, 2, 3, 4, 5, 6, 7] // because the map contains idx0, it will\\nval = [0, 1, 2, 0, 5, 6, 1, 3] // still be added to the next, but we will \\n       x  n     n              // skip it during the process\\n\\n// Round 1\\ncur = [0, 1, 3]\\n\\nidx = [0, 1, 2, 3, 4, 5, 6, 7]\\nval = [0, 1, 2, 0, 5, 6, 1, 3]\\n       x  x  n  x  n     n\\n\\n// Round 2\\ncur = [1, 2, 4, 6]\\nidx = [0, 1, 2, 3, 4, 5, 6, 7]\\nval = [0, 1, 2, 0, 5, 6, 1, 3]\\n       x  x  x  x  x  n  x  n\\n\\n\\n// Round 3\\ncur = [2, 4, 5, 7]\\nidx = [0, 1, 2, 3, 4, 5, 6, 7]\\nval = [0, 1, 2, 0, 5, 6, 1, 3]\\n       x  x  x  x  x  x  x  x\\n```\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n\\n```ts\\ntype JumpNode = {\\n    val: number;\\n    used: boolean;\\n    minStep: number;\\n}\\n\\nfunction minJumps(arr: number[]): number {\\n    const jompNode: Array<JumpNode> = [];\\n    \\n    // represents value: Array<idx of the value in the arr>\\n    const mp: Record<number, number[]> = {};\\n    const len = arr.length;\\n\\n    // initialisation\\n    for (let i = 0; i < len; ++i) {\\n        jompNode.push({ val: arr[i], used: false, minStep: len - 1 });\\n        if (mp[arr[i]] === undefined) { mp[arr[i]] = []; }\\n        mp[arr[i]].push(i);\\n    }\\n\\n    // cnt starts from -1 because the queue starts from index 0\\n    let cnt = -1;\\n    let cur: Array<number> = [0];\\n    let next: Set<number> = new Set<number>();\\n\\n    // whenever cur is not empty, we continue processing\\n    while (cur.length > 0) {\\n        for (const i of cur) {\\n            if (jompNode[i].used) { continue; }\\n            jompNode[i].used = true;\\n            jompNode[i].minStep = Math.min(jompNode[i].minStep, cnt + 1);\\n\\n            // if we find the last index, return directly\\n            if (i === len - 1) { return jompNode[i].minStep; }\\n\\n            // add the next and the previous idx of JumpNode to queue next\\n            if (i < len - 1 && !jompNode[i + 1].used) { next.add(i + 1); }\\n            if (i > 0 && !jompNode[i - 1].used) { next.add(i - 1); }\\n\\n            const curVal = jompNode[i].val;\\n\\n            // add idx with the same value to queue next\\n            // remove the mp to identify whether the value is already been checked\\n            if (mp[curVal]) {\\n                mp[curVal].forEach(nextIdx => next.add(nextIdx));\\n                delete mp[curVal];\\n            }\\n        }\\n        \\n        // change cur to next, clear the next\\n        cur = Array.from(next);\\n        next = new Set<number>();\\n        ++cnt;\\n    }\\n    \\n    return jompNode[len - 1].minStep;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\n// x represents being checked in this round,\\n// while n represents the JumpNode be checked in the next round\\n\\n// Round 0\\ncur = [0]\\n\\nidx = [0, 1, 2, 3, 4, 5, 6, 7] // because the map contains idx0, it will\\nval = [0, 1, 2, 0, 5, 6, 1, 3] // still be added to the next, but we will \\n       x  n     n              // skip it during the process\\n\\n// Round 1\\ncur = [0, 1, 3]\\n\\nidx = [0, 1, 2, 3, 4, 5, 6, 7]\\nval = [0, 1, 2, 0, 5, 6, 1, 3]\\n       x  x  n  x  n     n\\n\\n// Round 2\\ncur = [1, 2, 4, 6]\\nidx = [0, 1, 2, 3, 4, 5, 6, 7]\\nval = [0, 1, 2, 0, 5, 6, 1, 3]\\n       x  x  x  x  x  n  x  n\\n\\n\\n// Round 3\\ncur = [2, 4, 5, 7]\\nidx = [0, 1, 2, 3, 4, 5, 6, 7]\\nval = [0, 1, 2, 0, 5, 6, 1, 3]\\n       x  x  x  x  x  x  x  x\\n```\n```ts\\ntype JumpNode = {\\n    val: number;\\n    used: boolean;\\n    minStep: number;\\n}\\n\\nfunction minJumps(arr: number[]): number {\\n    const jompNode: Array<JumpNode> = [];\\n    \\n    // represents value: Array<idx of the value in the arr>\\n    const mp: Record<number, number[]> = {};\\n    const len = arr.length;\\n\\n    // initialisation\\n    for (let i = 0; i < len; ++i) {\\n        jompNode.push({ val: arr[i], used: false, minStep: len - 1 });\\n        if (mp[arr[i]] === undefined) { mp[arr[i]] = []; }\\n        mp[arr[i]].push(i);\\n    }\\n\\n    // cnt starts from -1 because the queue starts from index 0\\n    let cnt = -1;\\n    let cur: Array<number> = [0];\\n    let next: Set<number> = new Set<number>();\\n\\n    // whenever cur is not empty, we continue processing\\n    while (cur.length > 0) {\\n        for (const i of cur) {\\n            if (jompNode[i].used) { continue; }\\n            jompNode[i].used = true;\\n            jompNode[i].minStep = Math.min(jompNode[i].minStep, cnt + 1);\\n\\n            // if we find the last index, return directly\\n            if (i === len - 1) { return jompNode[i].minStep; }\\n\\n            // add the next and the previous idx of JumpNode to queue next\\n            if (i < len - 1 && !jompNode[i + 1].used) { next.add(i + 1); }\\n            if (i > 0 && !jompNode[i - 1].used) { next.add(i - 1); }\\n\\n            const curVal = jompNode[i].val;\\n\\n            // add idx with the same value to queue next\\n            // remove the mp to identify whether the value is already been checked\\n            if (mp[curVal]) {\\n                mp[curVal].forEach(nextIdx => next.add(nextIdx));\\n                delete mp[curVal];\\n            }\\n        }\\n        \\n        // change cur to next, clear the next\\n        cur = Array.from(next);\\n        next = new Set<number>();\\n        ++cnt;\\n    }\\n    \\n    return jompNode[len - 1].minStep;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259634,
                "title": "bfs-explained-commented-easy-to-understand-c",
                "content": "# Complexity\\n- Time complexity:\\n  $$O(n)$$  \\n\\n- Space complexity:\\n $$O(n)$$  \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        // total 3 steps \\n        // first -> go backward \\n        // second -> go forward \\n        // third -> remain at same pos and jump to next occurence of that element \\n        //Apply BFS\\n        unordered_map<int,vector<int>>index;\\n         int n = arr.size() , jump=0;\\n         for(int i=0;i<n;i++){\\n             index[arr[i]].push_back(i);\\n         }\\n        //make a visited vector which tells whether the path already visited or not \\n           vector<int>visited(n,0);\\n           queue<int>q; \\n           //initially,at 0 pos thus push 0 in queue \\n           q.push(0);\\n           while(!q.empty()){\\n               int size_to_traverse = q.size();\\n               while(size_to_traverse--){\\n                   int pos = q.front();\\n                   q.pop();\\n                   int backward = pos-1 ; \\n                   int forward = pos+1 ; \\n                   //if at last Pos we have reached destination \\n                   if(pos==n-1) return jump;\\n                   //Step 1 :- go backward if possible and not visited path \\n                   if(backward>=0 && !visited[backward]){\\n                       //push in queue and mark as visited \\n                       q.push(backward);\\n                       visited[backward]=1;\\n                   }\\n                   //Step 2 :- go forward if possible and not visited path \\n                   if(forward<n && !visited[forward]){\\n                       //push in queue and mark as visited \\n                       q.push(forward);\\n                       visited[forward]=1;\\n                   }\\n                    //Step 3 :- remain at same pos and jump to next occurence of that element \\n                    for(auto nextPos : index[arr[pos]]){\\n                        //if not visited path push in queue and mark as visited \\n                     if(!visited[nextPos]){\\n                          q.push(nextPos);  \\n                          visited[nextPos]=1;\\n                     }\\n                    }\\n                //to remove tle after taking a path for a pos don\\'t explore the remaining path \\n                // as already visited[pos] is true and we are doing unnecessary traversal i.e revisiting\\n                index[arr[pos]].clear();\\n               }\\n            jump++;\\n           }\\n           return 0;\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        // total 3 steps \\n        // first -> go backward \\n        // second -> go forward \\n        // third -> remain at same pos and jump to next occurence of that element \\n        //Apply BFS\\n        unordered_map<int,vector<int>>index;\\n         int n = arr.size() , jump=0;\\n         for(int i=0;i<n;i++){\\n             index[arr[i]].push_back(i);\\n         }\\n        //make a visited vector which tells whether the path already visited or not \\n           vector<int>visited(n,0);\\n           queue<int>q; \\n           //initially,at 0 pos thus push 0 in queue \\n           q.push(0);\\n           while(!q.empty()){\\n               int size_to_traverse = q.size();\\n               while(size_to_traverse--){\\n                   int pos = q.front();\\n                   q.pop();\\n                   int backward = pos-1 ; \\n                   int forward = pos+1 ; \\n                   //if at last Pos we have reached destination \\n                   if(pos==n-1) return jump;\\n                   //Step 1 :- go backward if possible and not visited path \\n                   if(backward>=0 && !visited[backward]){\\n                       //push in queue and mark as visited \\n                       q.push(backward);\\n                       visited[backward]=1;\\n                   }\\n                   //Step 2 :- go forward if possible and not visited path \\n                   if(forward<n && !visited[forward]){\\n                       //push in queue and mark as visited \\n                       q.push(forward);\\n                       visited[forward]=1;\\n                   }\\n                    //Step 3 :- remain at same pos and jump to next occurence of that element \\n                    for(auto nextPos : index[arr[pos]]){\\n                        //if not visited path push in queue and mark as visited \\n                     if(!visited[nextPos]){\\n                          q.push(nextPos);  \\n                          visited[nextPos]=1;\\n                     }\\n                    }\\n                //to remove tle after taking a path for a pos don\\'t explore the remaining path \\n                // as already visited[pos] is true and we are doing unnecessary traversal i.e revisiting\\n                index[arr[pos]].clear();\\n               }\\n            jump++;\\n           }\\n           return 0;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259612,
                "title": "easy-and-fast-golang-solution-with-explanation",
                "content": "# Intuition\\nThe problem can be thought of as a graph problem where each index is a node and there are edges between nodes that can be reached in one step. The goal is to find the shortest path from the first node to the last node.\\n\\n# Approach\\nFirst, we create a graph where each value in the array maps to a list of indices where that value appears. This allows us to quickly find all indices with the same value as the current index.\\n\\nWe then use breadth-first search (BFS) to find the shortest path from the first index to the last index. We start by adding the first index to a queue and marking it as visited. Then we iterate through each level of BFS until we reach the last index.\\n\\nAt each level, we iterate through all nodes in the queue and add their neighbors (indices reachable in one step) to the queue if they haven\\u2019t been visited before. We also mark them as visited.\\n\\nTo optimize this solution further, we delete values from our graph once we have processed all indices with that value. This prevents us from processing these indices again in future levels of BFS.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ since we visit each node once.\\n\\n- Space complexity: $$O(n)$$ since we need to store our graph and visited array.\\n\\n# Code\\n```\\nfunc minJumps(arr []int) int {\\n    n := len(arr)\\n    if n <= 1 {\\n        return 0\\n    }\\n    graph := make(map[int][]int)\\n    for i := 0; i < n; i++ {\\n        if _, ok := graph[arr[i]]; !ok {\\n            graph[arr[i]] = []int{i}\\n        } else {\\n            graph[arr[i]] = append(graph[arr[i]], i)\\n        }\\n    }\\n    visited := make([]bool, n)\\n    visited[0] = true\\n    queue := []int{0}\\n    step := 0\\n\\n    for len(queue) > 0 {\\n        size := len(queue)\\n        for i := 0; i < size; i++ {\\n            curr := queue[0]\\n            queue = queue[1:]\\n            if curr == n-1 {\\n                return step\\n            }\\n            nexts := append(graph[arr[curr]], curr-1)\\n            nexts = append(nexts, curr+1)\\n\\n            for _, next := range nexts {\\n                if next >= 0 && next < n && !visited[next] {\\n                    visited[next] = true\\n                    queue = append(queue, next)\\n                }\\n            }\\n\\n            delete(graph, arr[curr])\\n        }\\n        step++\\n    }\\n\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc minJumps(arr []int) int {\\n    n := len(arr)\\n    if n <= 1 {\\n        return 0\\n    }\\n    graph := make(map[int][]int)\\n    for i := 0; i < n; i++ {\\n        if _, ok := graph[arr[i]]; !ok {\\n            graph[arr[i]] = []int{i}\\n        } else {\\n            graph[arr[i]] = append(graph[arr[i]], i)\\n        }\\n    }\\n    visited := make([]bool, n)\\n    visited[0] = true\\n    queue := []int{0}\\n    step := 0\\n\\n    for len(queue) > 0 {\\n        size := len(queue)\\n        for i := 0; i < size; i++ {\\n            curr := queue[0]\\n            queue = queue[1:]\\n            if curr == n-1 {\\n                return step\\n            }\\n            nexts := append(graph[arr[curr]], curr-1)\\n            nexts = append(nexts, curr+1)\\n\\n            for _, next := range nexts {\\n                if next >= 0 && next < n && !visited[next] {\\n                    visited[next] = true\\n                    queue = append(queue, next)\\n                }\\n            }\\n\\n            delete(graph, arr[curr])\\n        }\\n        step++\\n    }\\n\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259403,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int minJumps(vector<int>& arr) \\n     {\\n        unordered_map<int,vector<int>>mp;  \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<bool>vis(arr.size(),false);   \\n        int ans=INT_MAX;\\n        queue<pair<pair<int,int>,int>>q;  \\n        q.push({{arr[0],0},0});\\n        while(!q.empty())\\n        {\\n            int idx=q.front().second;\\n            int c=q.front().first.second;\\n            int ele=q.front().first.first;\\n            if(vis[idx]==false)\\n            {\\n                vis[idx]=true;\\n            }  \\n            if(idx==arr.size()-1)\\n            {\\n                ans=min(ans,c);\\n            }\\n            q.pop();\\n            if(idx>0 and vis[idx-1]==false)\\n            {\\n                q.push({{arr[idx-1],c+1},idx-1});\\n                vis[idx-1]=true;\\n            }\\n            if(idx<arr.size()-1 and vis[idx+1]==false)\\n            {\\n                q.push({{arr[idx+1],c+1},idx+1});\\n                vis[idx+1]=true;\\n            } \\n            for(int j=0;j<mp[ele].size();j++)\\n            {\\n                if(mp[ele][j]!=idx and vis[mp[ele][j]]==false)\\n                {\\n                    q.push({{ele,c+1},mp[ele][j]});\\n                    vis[mp[ele][j]]=true;\\n                }\\n            }\\n            mp[ele].clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int minJumps(vector<int>& arr) \\n     {\\n        unordered_map<int,vector<int>>mp;  \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<bool>vis(arr.size(),false);   \\n        int ans=INT_MAX;\\n        queue<pair<pair<int,int>,int>>q;  \\n        q.push({{arr[0],0},0});\\n        while(!q.empty())\\n        {\\n            int idx=q.front().second;\\n            int c=q.front().first.second;\\n            int ele=q.front().first.first;\\n            if(vis[idx]==false)\\n            {\\n                vis[idx]=true;\\n            }  \\n            if(idx==arr.size()-1)\\n            {\\n                ans=min(ans,c);\\n            }\\n            q.pop();\\n            if(idx>0 and vis[idx-1]==false)\\n            {\\n                q.push({{arr[idx-1],c+1},idx-1});\\n                vis[idx-1]=true;\\n            }\\n            if(idx<arr.size()-1 and vis[idx+1]==false)\\n            {\\n                q.push({{arr[idx+1],c+1},idx+1});\\n                vis[idx+1]=true;\\n            } \\n            for(int j=0;j<mp[ele].size();j++)\\n            {\\n                if(mp[ele][j]!=idx and vis[mp[ele][j]]==false)\\n                {\\n                    q.push({{ele,c+1},mp[ele][j]});\\n                    vis[mp[ele][j]]=true;\\n                }\\n            }\\n            mp[ele].clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259309,
                "title": "python3-623-ms-faster-than-98-86-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/d5e657e7-ac49-41ee-912e-91677f662469_1678002372.3302972.png)\\n```\\ndef minJumps(self, arr: List[int]) -> int:\\n        if len(arr) == 1: return 0\\n        dict = collections.defaultdict(list)\\n        for i , n in enumerate(arr): dict[n].append(i)\\n\\n        N = len(arr)        \\n        visited = {0, N - 1}\\n        s1, s2 = {0}, {N - 1}\\n        step = 0\\n        while s1:\\n            if len(s1) > len(s2): s1, s2 = s2, s1\\n\\n            s3 = set()\\n            while s1:\\n                i = s1.pop()\\n                for n in [i - 1, i + 1] + dict[arr[i]]:\\n                    if n in s2: return step + 1\\n                    if n in visited: continue\\n                    if not 0 <= n < N: continue\\n                    visited.add(n)\\n                    s3.add(n)\\n                del dict[arr[i]]\\n\\n            s1 = s3\\n            if s1: step = step + 1\\n        return -1\\n```\\nThe given code is for finding the minimum number of jumps required to reach the end of an array of integers, where each integer represents the maximum number of steps that can be taken forward from that position.\\n\\nHere\\'s a stepwise explanation of the code:\\n\\n1. First, check if the length of the given array is 1, then return 0 as there is no need to jump in this case.\\n1. Create a dictionary to store the indices of all the occurrences of each element in the array.\\n1. Initialize two sets s1 and s2 with the starting and ending indices of the array, respectively.\\n1. Initialize a variable step to 0 to keep track of the number of jumps required.\\n1. While s1 is not empty, do the following:\\n\\t1. If the length of s1 is greater than s2, swap them so that s1 always contains the smaller set.\\n\\t1. Create a new set s3 to store the indices that can be reached from s1 in one jump.\\n\\t1. For each index i in s1, do the following:\\n\\t\\t1. For each index j that can be reached from i in one jump (i.e., i-1, i+1, and all the indices in the dictionary that have the same value as arr[i]), do the following:\\n\\t\\t\\t1. If j is in s2, return step+1 as we have reached the end.\\n\\t\\t\\t1.  If j is already visited, skip to the next index.  \\n\\t\\t\\t1. \\tIf j is not within the range of the array, skip to the next index.  \\n\\t\\t\\t1. \\tOtherwise, add j to the set s3 and mark it as visited.  \\n\\t\\t1. \\tRemove the key-value pair corresponding to arr[i] from the dictionary.\\n\\t1. Set s1 to s3 and increment the variable step by 1.\\n1. If we have not returned in the while loop, return -1 as it means that we have not reached the end of the array.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef minJumps(self, arr: List[int]) -> int:\\n        if len(arr) == 1: return 0\\n        dict = collections.defaultdict(list)\\n        for i , n in enumerate(arr): dict[n].append(i)\\n\\n        N = len(arr)        \\n        visited = {0, N - 1}\\n        s1, s2 = {0}, {N - 1}\\n        step = 0\\n        while s1:\\n            if len(s1) > len(s2): s1, s2 = s2, s1\\n\\n            s3 = set()\\n            while s1:\\n                i = s1.pop()\\n                for n in [i - 1, i + 1] + dict[arr[i]]:\\n                    if n in s2: return step + 1\\n                    if n in visited: continue\\n                    if not 0 <= n < N: continue\\n                    visited.add(n)\\n                    s3.add(n)\\n                del dict[arr[i]]\\n\\n            s1 = s3\\n            if s1: step = step + 1\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3259262,
                "title": "javascript-with-explanation",
                "content": "# Code\\n```\\nvar minJumps = function(arr) {\\n    const l = arr.length;\\n    const map = new Map();\\n\\n    // Create array of indexes for each value\\n    for (let i=0; i<l; i++){\\n        if (map.has(arr[i])) map.get(arr[i]).push(i)\\n        else map.set(arr[i],[i])\\n    }\\n    \\n    // Each value in indexes have to be check.\\n    // When indexes array in updated, 1 step increased\\n    let indexes = [0], steps = 0;\\n\\n    while (true) {\\n        const newIndexes = [];\\n        \\n        // For each index in indexes\\n        for (let i=0; i<indexes.length; i++) {\\n            const index = indexes[i];\\n\\n            // If we reach to the last index\\n            if (index === l-1) return steps\\n\\n            const num = arr[index]; // Get value from array\\n            arr[index] = null; // Mark as visited\\n\\n// In next 3 cases we are checking i-1, i+1 and same value conditions\\n\\n            // If arr have prev element not visited\\n            if (index-1>0 && arr[index-1]!==null) newIndexes.push(index-1)\\n\\n            // If arr have next element not visited\\n            if (arr[index+1] !== null) newIndexes.push(index + 1)\\n\\n            // If we have any of the similar element in arr not visited\\n            if (map.has(num)) {\\n                map.get(num).forEach(ind => arr[ind]!==null && newIndexes.push(ind))\\n                // This value no longer needed\\n                map.delete(num);\\n            }\\n        }\\n        \\n        // Update indexes array and increse one step\\n        indexes = newIndexes;\\n        steps++;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minJumps = function(arr) {\\n    const l = arr.length;\\n    const map = new Map();\\n\\n    // Create array of indexes for each value\\n    for (let i=0; i<l; i++){\\n        if (map.has(arr[i])) map.get(arr[i]).push(i)\\n        else map.set(arr[i],[i])\\n    }\\n    \\n    // Each value in indexes have to be check.\\n    // When indexes array in updated, 1 step increased\\n    let indexes = [0], steps = 0;\\n\\n    while (true) {\\n        const newIndexes = [];\\n        \\n        // For each index in indexes\\n        for (let i=0; i<indexes.length; i++) {\\n            const index = indexes[i];\\n\\n            // If we reach to the last index\\n            if (index === l-1) return steps\\n\\n            const num = arr[index]; // Get value from array\\n            arr[index] = null; // Mark as visited\\n\\n// In next 3 cases we are checking i-1, i+1 and same value conditions\\n\\n            // If arr have prev element not visited\\n            if (index-1>0 && arr[index-1]!==null) newIndexes.push(index-1)\\n\\n            // If arr have next element not visited\\n            if (arr[index+1] !== null) newIndexes.push(index + 1)\\n\\n            // If we have any of the similar element in arr not visited\\n            if (map.has(num)) {\\n                map.get(num).forEach(ind => arr[ind]!==null && newIndexes.push(ind))\\n                // This value no longer needed\\n                map.delete(num);\\n            }\\n        }\\n        \\n        // Update indexes array and increse one step\\n        indexes = newIndexes;\\n        steps++;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3258903,
                "title": "easiest-solution-using-simple-bfs-beats-97-rt-90-mem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> We use simple BFS to find out our required path. We just need to select the proper node connections as per given constrints.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> As per question, the nodes, from a selected index i is i-1(if exists), i+1(if exists) and all values j such that i!=j and arr[i]==arr[j]. We create an unordered map to hash all these j indices for every i. We then create a visited array and start our iterative BFS using queue starting from the first index. We get our desired answer as soon as we reach index n-1. We also push appropriate nodes into the queue as mentioned. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$ <!-- Add your time complexity here, e.g. $$O(n)$$ --> Although there is a loop inside a loop, but all in all we are visiting every index at most once.\\n\\n- Space complexity: $$O(n)$$ <!-- Add your space complexity here, e.g. $$O(n)$$ --> Extra space is required for hashing,visited array and queue.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size(),jumps[n],ans=0;\\n        unordered_map<int,vector<int>> um;\\n        for(int i=0;i<n;i++) um[arr[i]].push_back(i);\\n        vector<bool> vis(n,0);vis[0]=1;\\n        queue<int> q;q.push(0);\\n        while(!q.empty()){\\n            int s=q.size();\\n            while(s--){\\n                int f=q.front();q.pop();\\n                if(f==n-1) return ans;\\n                if(f+1<n and !vis[f+1]) q.push(f+1),vis[f+1]=1;\\n                if(f>0 and !vis[f-1]) q.push(f-1),vis[f-1]=1;\\n                for(int j:um[arr[f]]) if(!vis[j]) q.push(j),vis[j]=1;\\n                um[arr[f]].clear();\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n>  Please do upvote if it helps",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size(),jumps[n],ans=0;\\n        unordered_map<int,vector<int>> um;\\n        for(int i=0;i<n;i++) um[arr[i]].push_back(i);\\n        vector<bool> vis(n,0);vis[0]=1;\\n        queue<int> q;q.push(0);\\n        while(!q.empty()){\\n            int s=q.size();\\n            while(s--){\\n                int f=q.front();q.pop();\\n                if(f==n-1) return ans;\\n                if(f+1<n and !vis[f+1]) q.push(f+1),vis[f+1]=1;\\n                if(f>0 and !vis[f-1]) q.push(f-1),vis[f-1]=1;\\n                for(int j:um[arr[f]]) if(!vis[j]) q.push(j),vis[j]=1;\\n                um[arr[f]].clear();\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257902,
                "title": "c-language",
                "content": "```\\ntypedef struct {\\n    int key;\\n    struct ListNode *ptr;\\n    UT_hash_handle hh;\\n}node;\\ntypedef struct{\\n    int val;\\n    int *next;\\n}ListNode;\\ntypedef struct {\\n    int pos;\\n    int step;\\n}status;\\n\\nint minJumps(int* arr, int arrSize){\\n\\n    if (arrSize <= 1) return 0;\\n\\n    status obj[arrSize];\\n    int visit[arrSize];\\n    memset(visit, 0, arrSize*sizeof(int));\\n    node *hash = NULL, *s;\\n\\n    struct ListNode *tp;\\n\\n    //add all into hash and linked list\\n    for (int i = 0; i < arrSize; i++) {\\n        HASH_FIND_INT(hash, &arr[i], s);\\n        if (!s) {\\n            s = (node*)calloc(1, sizeof(node));\\n            s->key = arr[i];\\n            HASH_ADD_INT(hash, key, s);\\n        }\\n        tp = (struct ListNode*)calloc(1, sizeof(struct ListNode));\\n        tp->val = i;\\n        tp->next = s->ptr;\\n        s->ptr = tp;\\n    } \\n\\n    // initialization\\n    int top = 1, left = 0, pos, val; \\n    obj[0].step = obj[0].pos = 0;\\n    visit[0] = 1;\\n\\n    while (left < top) {\\n        if (obj[left].pos == arrSize-1)//done\\n            break;\\n        \\n        val = arr[obj[left].pos];\\n        HASH_FIND_INT(hash, &val, s);        \\n        if (s) {\\n            tp = s->ptr; \\n            while (tp) {\\n                pos = tp->val;\\n                if (!visit[pos]) {\\n                    visit[pos] = 1;\\n                    obj[top].step = obj[left].step + 1;\\n                    obj[top].pos = pos;\\n                    top++;\\n                } \\n                tp = tp->next;\\n            }\\n            HASH_DEL(hash, s);\\n        }\\n\\n        for (int i = 0; i < 2; i++) {\\n            pos = obj[left].pos + (i ? 1 : -1);\\n            if (pos < 0 || pos >= arrSize)//jump outside\\n                continue;\\n            if (visit[pos])//visited\\n                continue;\\n            obj[top].step = obj[left].step + 1;\\n            obj[top].pos = pos;\\n            visit[pos] = 1;\\n            top++;\\n        }\\n\\n        left++;\\n    }\\n    free(tp);\\n    return obj[left].step; \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct {\\n    int key;\\n    struct ListNode *ptr;\\n    UT_hash_handle hh;\\n}node;\\ntypedef struct{\\n    int val;\\n    int *next;\\n}ListNode;\\ntypedef struct {\\n    int pos;\\n    int step;\\n}status;\\n\\nint minJumps(int* arr, int arrSize){\\n\\n    if (arrSize <= 1) return 0;\\n\\n    status obj[arrSize];\\n    int visit[arrSize];\\n    memset(visit, 0, arrSize*sizeof(int));\\n    node *hash = NULL, *s;\\n\\n    struct ListNode *tp;\\n\\n    //add all into hash and linked list\\n    for (int i = 0; i < arrSize; i++) {\\n        HASH_FIND_INT(hash, &arr[i], s);\\n        if (!s) {\\n            s = (node*)calloc(1, sizeof(node));\\n            s->key = arr[i];\\n            HASH_ADD_INT(hash, key, s);\\n        }\\n        tp = (struct ListNode*)calloc(1, sizeof(struct ListNode));\\n        tp->val = i;\\n        tp->next = s->ptr;\\n        s->ptr = tp;\\n    } \\n\\n    // initialization\\n    int top = 1, left = 0, pos, val; \\n    obj[0].step = obj[0].pos = 0;\\n    visit[0] = 1;\\n\\n    while (left < top) {\\n        if (obj[left].pos == arrSize-1)//done\\n            break;\\n        \\n        val = arr[obj[left].pos];\\n        HASH_FIND_INT(hash, &val, s);        \\n        if (s) {\\n            tp = s->ptr; \\n            while (tp) {\\n                pos = tp->val;\\n                if (!visit[pos]) {\\n                    visit[pos] = 1;\\n                    obj[top].step = obj[left].step + 1;\\n                    obj[top].pos = pos;\\n                    top++;\\n                } \\n                tp = tp->next;\\n            }\\n            HASH_DEL(hash, s);\\n        }\\n\\n        for (int i = 0; i < 2; i++) {\\n            pos = obj[left].pos + (i ? 1 : -1);\\n            if (pos < 0 || pos >= arrSize)//jump outside\\n                continue;\\n            if (visit[pos])//visited\\n                continue;\\n            obj[top].step = obj[left].step + 1;\\n            obj[top].pos = pos;\\n            visit[pos] = 1;\\n            top++;\\n        }\\n\\n        left++;\\n    }\\n    free(tp);\\n    return obj[left].step; \\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3257872,
                "title": "291-ms",
                "content": "```ruby\\ndef min_jumps a\\n    return 0 if (t = a.size - 1) < 1\\n    g = a.each_index.group_by { a[_1] }\\n    s, q, v = 0, [0], [false] * t\\n    v[0] = true\\n    loop do\\n        (s += 1; q.size).times do\\n            i = q.shift\\n            c = (g[a[i]] || []) << i + 1\\n            g.delete a[i]\\n            c << i - 1 if i > 0\\n            c.each do | x |\\n                return s if x == t\\n                next if v[x]\\n                v[x] = true\\n                q << x\\n            end\\n        end\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef min_jumps a\\n    return 0 if (t = a.size - 1) < 1\\n    g = a.each_index.group_by { a[_1] }\\n    s, q, v = 0, [0], [false] * t\\n    v[0] = true\\n    loop do\\n        (s += 1; q.size).times do\\n            i = q.shift\\n            c = (g[a[i]] || []) << i + 1\\n            g.delete a[i]\\n            c << i - 1 if i > 0\\n            c.each do | x |\\n                return s if x == t\\n                next if v[x]\\n                v[x] = true\\n                q << x\\n            end\\n        end\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3257723,
                "title": "daily-leetcoding-challenge-march-day-5",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2260356,
                "title": "bfs-c-o-n-solution",
                "content": "```\\n//BFS Solution because DFS stucks in a loop\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        map<int,vector<int>>mp;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        int steps=0;\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            while(n--)\\n            {\\n                int x=q.front();\\n                if(x==arr.size()-1)return steps;\\n                q.pop();\\n                if(x-1>=0)\\n                {\\n                    if(mp.find(arr[x-1])!=mp.end())\\n                    {\\n                        q.push(x-1);\\n                    }\\n                        \\n                }\\n                if(x+1<arr.size())\\n                {\\n                    if(mp.find(arr[x+1])!=mp.end())\\n                    {\\n                        q.push(x+1);\\n                    }                        \\n                }\\n                for(auto i:mp[arr[x]])\\n                {\\n                    if(mp.find(arr[i])!=mp.end()&&i!=x)\\n                    {\\n                        q.push(i);\\n                    }\\n                }\\n                mp.erase(arr[x]);\\n            }\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n//BFS Solution because DFS stucks in a loop\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        map<int,vector<int>>mp;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        int steps=0;\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            while(n--)\\n            {\\n                int x=q.front();\\n                if(x==arr.size()-1)return steps;\\n                q.pop();\\n                if(x-1>=0)\\n                {\\n                    if(mp.find(arr[x-1])!=mp.end())\\n                    {\\n                        q.push(x-1);\\n                    }\\n                        \\n                }\\n                if(x+1<arr.size())\\n                {\\n                    if(mp.find(arr[x+1])!=mp.end())\\n                    {\\n                        q.push(x+1);\\n                    }                        \\n                }\\n                for(auto i:mp[arr[x]])\\n                {\\n                    if(mp.find(arr[i])!=mp.end()&&i!=x)\\n                    {\\n                        q.push(i);\\n                    }\\n                }\\n                mp.erase(arr[x]);\\n            }\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183694,
                "title": "easy-c-bfs-solution-good-comments",
                "content": "A BFS Solution in C++ with comments\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        \\n        // Map to store All the indices where value is present\\n        map < int, vector<int> > allIndices;;\\n        \\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            allIndices[arr[i]].push_back(i);\\n        }\\n          \\n        queue<int> Q;\\n        // Vector to check we only travel indice strictly once\\n        vector<bool> alreadyTravelled(arr.size(), false);\\n        \\n        Q.push(0);\\n        alreadyTravelled[0] = true;\\n        int step = 0, Qcount, currentIndex, n = arr.size();\\n        \\n        // To store the value of map locally \\n        vector<int> a;\\n        \\n        // Our BFS solution Starts Here\\n        // if we reach indice \"n-1\" we have completed our BFS\\n        while(!alreadyTravelled[n-1])\\n        {\\n            Qcount = Q.size();\\n            \\n            // Iterate all Q element one by one at each step\\n            for(int i=0;i<Qcount;i++)\\n            {\\n                currentIndex = Q.front();\\n                Q.pop();\\n                \\n                // checking the left indice if alreadt travelled or not\\n                // and inserting into Q\\n                if(currentIndex-1 >0 && !alreadyTravelled[currentIndex-1])\\n                {\\n                    Q.push(currentIndex-1);\\n                    alreadyTravelled[currentIndex-1] = true;\\n                }\\n                \\n                // checking the right indice if alreadt travelled or not\\n                // and inserting into Q\\n                if(currentIndex+1 <n && !alreadyTravelled[currentIndex+1])\\n                {\\n                    Q.push(currentIndex+1);\\n                    alreadyTravelled[currentIndex+1] = true;\\n                }\\n                \\n                // fetching vector of current Index Value from map\\n                a = allIndices[arr[currentIndex]];\\n                \\n                // if value is present we will have non empty vector\\n                if(!a.empty())\\n                {   \\n                    // iterate each vector item\\n                    for(int k=0;k< a.size(); k++)\\n                    {\\n                        // pushing all other indices except current into Q\\n                        if(a[k] != currentIndex)\\n                        {\\n                            Q.push(a[k]);\\n                            alreadyTravelled[a[k]] = true;\\n                        }\\n                    }\\n                    \\n                    // erasing the map for currentIndex value \\n                    // this will help in not causing infinite loops\\n                    // Eg: {0,1,2} - indices for some value at index 0\\n                    // we will insert {1, 2} in the Q\\n                    // not erasing the map will insert \"0\" again when checking map for \"1\"\\n                    allIndices.erase(arr[currentIndex]);\\n                }\\n                a.clear(); // Clearing the vector for further use   \\n            }\\n            step++; // A BFS step counter\\n        }\\n        \\n        return step;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        \\n        // Map to store All the indices where value is present\\n        map < int, vector<int> > allIndices;;\\n        \\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            allIndices[arr[i]].push_back(i);\\n        }\\n          \\n        queue<int> Q;\\n        // Vector to check we only travel indice strictly once\\n        vector<bool> alreadyTravelled(arr.size(), false);\\n        \\n        Q.push(0);\\n        alreadyTravelled[0] = true;\\n        int step = 0, Qcount, currentIndex, n = arr.size();\\n        \\n        // To store the value of map locally \\n        vector<int> a;\\n        \\n        // Our BFS solution Starts Here\\n        // if we reach indice \"n-1\" we have completed our BFS\\n        while(!alreadyTravelled[n-1])\\n        {\\n            Qcount = Q.size();\\n            \\n            // Iterate all Q element one by one at each step\\n            for(int i=0;i<Qcount;i++)\\n            {\\n                currentIndex = Q.front();\\n                Q.pop();\\n                \\n                // checking the left indice if alreadt travelled or not\\n                // and inserting into Q\\n                if(currentIndex-1 >0 && !alreadyTravelled[currentIndex-1])\\n                {\\n                    Q.push(currentIndex-1);\\n                    alreadyTravelled[currentIndex-1] = true;\\n                }\\n                \\n                // checking the right indice if alreadt travelled or not\\n                // and inserting into Q\\n                if(currentIndex+1 <n && !alreadyTravelled[currentIndex+1])\\n                {\\n                    Q.push(currentIndex+1);\\n                    alreadyTravelled[currentIndex+1] = true;\\n                }\\n                \\n                // fetching vector of current Index Value from map\\n                a = allIndices[arr[currentIndex]];\\n                \\n                // if value is present we will have non empty vector\\n                if(!a.empty())\\n                {   \\n                    // iterate each vector item\\n                    for(int k=0;k< a.size(); k++)\\n                    {\\n                        // pushing all other indices except current into Q\\n                        if(a[k] != currentIndex)\\n                        {\\n                            Q.push(a[k]);\\n                            alreadyTravelled[a[k]] = true;\\n                        }\\n                    }\\n                    \\n                    // erasing the map for currentIndex value \\n                    // this will help in not causing infinite loops\\n                    // Eg: {0,1,2} - indices for some value at index 0\\n                    // we will insert {1, 2} in the Q\\n                    // not erasing the map will insert \"0\" again when checking map for \"1\"\\n                    allIndices.erase(arr[currentIndex]);\\n                }\\n                a.clear(); // Clearing the vector for further use   \\n            }\\n            step++; // A BFS step counter\\n        }\\n        \\n        return step;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702543,
                "title": "bfs-javascript-solution-o-n-explanation",
                "content": "The intuition is that we go from the 0th position and queue all the possible paths (which counts as one step) and then queue all of it\\'s path\\'s (second step) so on and so forth until we reach the destination (the last index or length of array - 1)\\n\\nThis is sounding a lot like Breadth First Search (BFS).  We can use a queue for this implementation.\\n\\nFrom any \"node\" we can calculate the neighboring nodes as such:\\n\\n1. i - 1 (one step backwards)\\n2. i + 2 (one step forwards)\\n3. any node that is the same value\\n\\nNow 1 and 2 seem pretty easy to do, however 3 seems like it would require some work up front because it would be less optimal to find all the occurence of a value as we are traversing this graph (and possibly giving it an exponential run-time).\\n\\nBecause of this, we\\'ll first iterate through the array and create a map that will allow us to get an array of all indexes for a given value.\\n\\nSo for a given array as such:\\n\\n```\\n[100,-23,-23,404,100,23,23,23,3,404]\\n```\\n\\nWe\\'ll have a map like so:\\n```\\n{\\n  \\'3\\': [ 8 ],\\n  \\'23\\': [ 5, 6, 7 ],\\n  \\'100\\': [ 0, 4 ],\\n  \\'404\\': [ 3, 9 ],\\n  \\'-23\\': [ 1, 2 ]\\n}\\n```\\n\\nWe\\'ll start by initializing our queue with the 0th index.  We\\'ll then push any valid neighbors onto the queue (for number `1` & `2` check if values exist AND exists on the map (or else we traversed it already).\\n\\nAs we traverse through the graph, it\\'s important that we delete the key of this map.  Because otherwise we might run into TLE.  And if you think about it logically, when you come across a specific value, we\\'re able to calculate all the nodes of that value at once so there\\'s no need to calculate it again.\\n\\nThe calculation we do for every neighboring node is considered one step so after we iterate through the entirety of the queue, we increment steps or jumps (is what I called it).  So with every jump, we\\'re emptying out the queue and pushing onto it.\\n\\nBecause I increment jump before doing the traversal, it\\'s important for this implementation to check if the nodes i\\'m pushing onto the queue is the final destination so I can return it.  This is the reason for such code:  ```if (curr + 1 === arr.length - 1) return jumps```\\n\\nNotice that I did not do this check when calculating ```i - 1 ``` because it\\'s impossible for us to visit the previos node and have it be the destination :).\\n\\nJavascript Implementation:\\n\\n```\\n\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function(arr) {\\n    \\n    if (arr.length === 1) return 0\\n    \\n    let map = {};\\n    \\n    for (let i = 0; i < arr.length; i++){\\n        if (map[arr[i]]){\\n            map[arr[i]].push(i);\\n        } else {\\n            map[arr[i]] = [i];\\n        }\\n    }\\n    \\n    let jumps = 0;\\n    \\n    let q = [0];\\n    while (q.length != 0){\\n                \\n        jumps++;\\n        \\n        let clone = [...q];\\n        q = [];\\n        \\n        for (let i = 0 ; i < clone.length; i++){\\n            let curr = clone[i];\\n            \\n            if (arr[curr - 1] != undefined && map[arr[curr - 1]]) q.push(curr - 1);\\n            if (arr[curr + 1] != undefined && map[arr[curr + 1]]) {\\n                if (curr + 1 === arr.length - 1) return jumps\\n                q.push(curr + 1);\\n            }\\n            \\n            if (map[arr[curr]]){\\n                for (let j = 0; j < map[arr[curr]].length; j++){\\n                    if (map[arr[curr]][j] === arr.length - 1) return jumps\\n                }\\n                q = [...q, ...map[arr[curr]].filter((x) => x != curr)];\\n            }\\n            \\n            delete map[arr[curr]];\\n        }\\n    }\\n    \\n    return jumps;\\n};\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n[100,-23,-23,404,100,23,23,23,3,404]\\n```\n```\\n{\\n  \\'3\\': [ 8 ],\\n  \\'23\\': [ 5, 6, 7 ],\\n  \\'100\\': [ 0, 4 ],\\n  \\'404\\': [ 3, 9 ],\\n  \\'-23\\': [ 1, 2 ]\\n}\\n```\n```if (curr + 1 === arr.length - 1) return jumps```\n```i - 1 ```\n```\\n\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function(arr) {\\n    \\n    if (arr.length === 1) return 0\\n    \\n    let map = {};\\n    \\n    for (let i = 0; i < arr.length; i++){\\n        if (map[arr[i]]){\\n            map[arr[i]].push(i);\\n        } else {\\n            map[arr[i]] = [i];\\n        }\\n    }\\n    \\n    let jumps = 0;\\n    \\n    let q = [0];\\n    while (q.length != 0){\\n                \\n        jumps++;\\n        \\n        let clone = [...q];\\n        q = [];\\n        \\n        for (let i = 0 ; i < clone.length; i++){\\n            let curr = clone[i];\\n            \\n            if (arr[curr - 1] != undefined && map[arr[curr - 1]]) q.push(curr - 1);\\n            if (arr[curr + 1] != undefined && map[arr[curr + 1]]) {\\n                if (curr + 1 === arr.length - 1) return jumps\\n                q.push(curr + 1);\\n            }\\n            \\n            if (map[arr[curr]]){\\n                for (let j = 0; j < map[arr[curr]].length; j++){\\n                    if (map[arr[curr]][j] === arr.length - 1) return jumps\\n                }\\n                q = [...q, ...map[arr[curr]].filter((x) => x != curr)];\\n            }\\n            \\n            delete map[arr[curr]];\\n        }\\n    }\\n    \\n    return jumps;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1692762,
                "title": "c-simple-bfs-vs-double-ended-bfs-solutions-explained-100-time-60-space",
                "content": "This problem is oddly a hard, but all it takes it is just to recognise we have a graph to navigate from a starting point (the first element of `arr`) to an ending one (the last node of `arr`), following rules; and usually when we need to compute how many steps it takes to come out of a graph, a BFS approach is a solid one!\\n\\nTo do so, we will first rule an edge case that would make any further effort pointless (when the array has `1` or `2` elements, the result is trivially the `arr.size() - 1`, no way to do less steps than that) and then declare a few support variables:\\n* `res` will store the current number of \"steps\" we have made so far (ie: how many BFS outer loop iterations we have ground to this point);\\n* `len` will store the length of the the original input;\\n* `qLen` will store the length of our `q`, initially set to `1`, since we will always have a sole starting point;\\n* `curr`, `prev` and `nxt` will be used in our inner BFS loop to keep track of what node we are currently processing and its neighbours;\\n* `target` stores our final destination, initialised with the value of the last element of `arr`;\\n* `connected` is an array showing us how similarly valued nodes are linked, forming the backbone of our graph traversal logic later;\\n* `unexplored` will keep track of the nodes we must still visit;\\n* `mustContinue` is a microoptimisation to let us know when we are in the last or penultimate cycle of our BFS search, initially set to `true`;\\n* `q` is the queue that will store the current and next level of our traversal, as in most standard BFS approaches - initially set to contain only the first node (our starting point).\\n\\nWe will then initialise all the values in `unexplored` to be `true` and populate `connected` so that each value of `arr` (key) will tell use what nodes share it and are thus linked (value).\\n\\nOkay, time for the main course, our BFS loops!\\n\\nWe  will have a main loop that will as long as we have a reason to go on (ie: `mustContinue != false`) and in it we will:\\n* run our level traversal, valid as long as `qLen-- != 0`, that is to say it will run `qLen` times and:\\n\\t* extract the current front of `q` and assign its value to `curr`;\\n\\t* pop that element out of the queue;\\n\\t* check if we reached our target, in which case we can just stop here and `return` `res`;\\n\\t* check if we will reach it on the next run (ie: `arr[curr] == target`, meaning we are on a cell that can teleport us to destination), in which case we do not quit immediately (we might have in the queue some node which is ALREADY the destination, so one less step!), but flag this situation turning `mustContinue` to `false`;\\n\\t* in case `mustContinue` is still `true`, we will then:\\n\\t\\t* flag the current node as explored;\\n\\t\\t* check the previous node `prev = curr - 1`, assuming it was not explored already or out of bonds, adding it to the queue;\\n\\t\\t* check the next node `nxt = curr - 1`, assuming it was not explored already or out of bonds, adding it to the queue;\\n\\t\\t* check all the connected nodes (if any) adding them to the queue (we know they were all not explored yet, since once you explore one of the connected ones, you get them all) and then removing that subnetwork from `connected`, in order to avoid parsing it again;\\n* prepare for the next iteration, increasing `res` by `1` and updating `qLen` with its new value.\\n\\nFinally, if we reached the end of the loop, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        // edge cases\\n        if (arr.size() < 3) return arr.size() - 1;\\n        // support variables\\n        int res = 0, len = arr.size(), qLen = 1, curr, prev, nxt, target = arr.back();\\n        unordered_map<int, vector<int>> connected;\\n        bool unexplored[len], mustContinue = true;\\n        queue<int> q{{0}};\\n        // preparing unexplored and connected\\n        fill(unexplored, unexplored + len--, true);\\n        for (int i = 0; i <= len; i++) connected[arr[i]].push_back(i);\\n\\t\\t// BFS time!\\n        while (mustContinue) {\\n\\t\\t\\t// level traversal\\n            while (qLen--) {\\n                // extracting the current front from the q and checking if we arrived\\n                curr = q.front();\\n                q.pop();\\n                if (curr == len) return res;\\n                // checking if we will go there in the next step\\n                if (arr[curr] == target) mustContinue = false;\\n                // the rest of the logic matters only if we know we have to proceed\\n                if (mustContinue) {\\n                    // marking curr as unexplored\\n                    unexplored[curr] = false;\\n                    // checking before curr\\n                    prev = curr - 1;\\n                    if (prev >= 0 && unexplored[prev]) q.push(prev);\\n                    // checking after curr\\n                    nxt = curr + 1;\\n                    if (nxt <= len && unexplored[nxt]) q.push(nxt);\\n                    // checking the connected ones if any and clearing that subnetwork\\n                    for (int conn: connected[arr[curr]]) q.push(conn);\\n                    connected[arr[curr]].clear();\\n                }\\n            }\\n            // preparing for the next loop\\n            res++;\\n            qLen = q.size();\\n        }\\n        return res;\\n    }\\n};\\n```\\nCan we do better?\\n\\nWell, yes, burning a bit more memory for the `explored` boolean maps, so that we have now `2` of them (and `2` queues, but that would actually use less memory overall) to run the same logic, but as a double ended BFS.\\n\\nThis alternative is much faster on average and the extra memory consumption is overall moderate:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        // edge cases\\n        if (arr.size() < 3) return arr.size() - 1;\\n        // support variables\\n        int res = -1, len = arr.size(), qLen = 1, curr, prev, nxt, target = arr.back();\\n        unordered_map<int, vector<int>> connected;\\n        bool *currExplored = new bool[len], *nextExplored = new bool[len];\\n        queue<int> currQ{{0}}, nextQ{{len - 1}};\\n        // preparing unexplored and connected\\n        fill(currExplored + 1, currExplored + len, false);\\n        fill(nextExplored, nextExplored + --len, false);\\n        currExplored[0] = true;\\n        nextExplored[len] = true;\\n        for (int i = 0; i <= len; i++) connected[arr[i]].push_back(i);\\n\\t\\t// BFS time!\\n        while (qLen) {\\n\\t\\t\\t// level traversal\\n            while (qLen--) {\\n                // extracting the current front from the q and checking if we arrived\\n                curr = currQ.front();\\n                currQ.pop();\\n                if (nextExplored[curr]) return res;\\n                // marking curr as unexplored\\n                currExplored[curr] = true;\\n                // checking before curr\\n                prev = curr - 1;\\n                if (prev >= 0 && !currExplored[prev]) currQ.push(prev);\\n                // checking after curr\\n                nxt = curr + 1;\\n                if (nxt <= len && !currExplored[nxt]) currQ.push(nxt);\\n                // checking the connected ones if any and clearing that subnetwork\\n                for (int conn: connected[arr[curr]]) currQ.push(conn);\\n                connected[arr[curr]].clear();\\n\\t\\t\\t}\\n\\t\\t\\t// preparing for the next loop\\n\\t\\t\\tres++;\\n\\t\\t\\tqLen = nextQ.size();\\n\\t\\t\\tswap(currQ, nextQ);\\n            swap(currExplored, nextExplored);\\n\\t\\t\\t// swap(currExplored, nextExplored);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        // edge cases\\n        if (arr.size() < 3) return arr.size() - 1;\\n        // support variables\\n        int res = 0, len = arr.size(), qLen = 1, curr, prev, nxt, target = arr.back();\\n        unordered_map<int, vector<int>> connected;\\n        bool unexplored[len], mustContinue = true;\\n        queue<int> q{{0}};\\n        // preparing unexplored and connected\\n        fill(unexplored, unexplored + len--, true);\\n        for (int i = 0; i <= len; i++) connected[arr[i]].push_back(i);\\n\\t\\t// BFS time!\\n        while (mustContinue) {\\n\\t\\t\\t// level traversal\\n            while (qLen--) {\\n                // extracting the current front from the q and checking if we arrived\\n                curr = q.front();\\n                q.pop();\\n                if (curr == len) return res;\\n                // checking if we will go there in the next step\\n                if (arr[curr] == target) mustContinue = false;\\n                // the rest of the logic matters only if we know we have to proceed\\n                if (mustContinue) {\\n                    // marking curr as unexplored\\n                    unexplored[curr] = false;\\n                    // checking before curr\\n                    prev = curr - 1;\\n                    if (prev >= 0 && unexplored[prev]) q.push(prev);\\n                    // checking after curr\\n                    nxt = curr + 1;\\n                    if (nxt <= len && unexplored[nxt]) q.push(nxt);\\n                    // checking the connected ones if any and clearing that subnetwork\\n                    for (int conn: connected[arr[curr]]) q.push(conn);\\n                    connected[arr[curr]].clear();\\n                }\\n            }\\n            // preparing for the next loop\\n            res++;\\n            qLen = q.size();\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        // edge cases\\n        if (arr.size() < 3) return arr.size() - 1;\\n        // support variables\\n        int res = -1, len = arr.size(), qLen = 1, curr, prev, nxt, target = arr.back();\\n        unordered_map<int, vector<int>> connected;\\n        bool *currExplored = new bool[len], *nextExplored = new bool[len];\\n        queue<int> currQ{{0}}, nextQ{{len - 1}};\\n        // preparing unexplored and connected\\n        fill(currExplored + 1, currExplored + len, false);\\n        fill(nextExplored, nextExplored + --len, false);\\n        currExplored[0] = true;\\n        nextExplored[len] = true;\\n        for (int i = 0; i <= len; i++) connected[arr[i]].push_back(i);\\n\\t\\t// BFS time!\\n        while (qLen) {\\n\\t\\t\\t// level traversal\\n            while (qLen--) {\\n                // extracting the current front from the q and checking if we arrived\\n                curr = currQ.front();\\n                currQ.pop();\\n                if (nextExplored[curr]) return res;\\n                // marking curr as unexplored\\n                currExplored[curr] = true;\\n                // checking before curr\\n                prev = curr - 1;\\n                if (prev >= 0 && !currExplored[prev]) currQ.push(prev);\\n                // checking after curr\\n                nxt = curr + 1;\\n                if (nxt <= len && !currExplored[nxt]) currQ.push(nxt);\\n                // checking the connected ones if any and clearing that subnetwork\\n                for (int conn: connected[arr[curr]]) currQ.push(conn);\\n                connected[arr[curr]].clear();\\n\\t\\t\\t}\\n\\t\\t\\t// preparing for the next loop\\n\\t\\t\\tres++;\\n\\t\\t\\tqLen = nextQ.size();\\n\\t\\t\\tswap(currQ, nextQ);\\n            swap(currExplored, nextExplored);\\n\\t\\t\\t// swap(currExplored, nextExplored);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692424,
                "title": "ruby-adjacency-list-bfs-by-layers-clear-list-element",
                "content": "## Leetcode: 1345. Jump Game IV.\\n\\n\\n**Ruby: Adjacency List, BFS by layers, clear Liset element.**\\n\\n- Create a weird Adjacency List, where are values of the array are nodes as well. For each value add a set of indices.\\n- Implement BFS by layers. Where on each iteration new array for a layer is created.\\n- And a most important thing! After adding to layer all elements from the value of a weird Adjacency list, clear it! This is the only way to escape from LTS.\\n\\nBased on the [described problem solution](https://leetcode.com/problems/jump-game-iv/solution/). Really appreciate it.\\n  \\nRuby code:\\n```Ruby\\n# Leetcode: 1345. Jump Game IV.\\n# https://leetcode.com/problems/jump-game-iv/\\n# = = = = = = =\\n# Accepted.\\n# Thanks God!\\n# = = = = = = =\\n# Runtime: 710 ms, faster than 100.00% of Ruby online submissions for Jump Game IV.\\n# Memory Usage: 227.2 MB, less than 100.00% of Ruby online submissions for Jump Game IV.\\n# @param {Integer[]} arr\\n# @return {Integer}\\ndef min_jumps(arr)\\n  @d = false\\n  puts \"input: #{arr}\" if @d\\n  last_index = arr.size - 1\\n  return 0 if arr.size <= 1\\n  graph = {}\\n  arr.each_with_index do |value,index|\\n    graph[value] ||= []\\n    graph[value].push(index)\\n  end\\n  puts \"graph: #{graph.inspect}\" if @d\\n  layer = [0]\\n  used = {}\\n  used[0] = true\\n  step = 0\\n  while ! layer.empty?\\n    nxt = []\\n    layer.each do |i|\\n      puts  \"i: #{i}\" if @d\\n      return step if last_index == i\\n      [i+1,i-1].each do |j|\\n        if j.between?(0,last_index) && (!used[j])\\n          used[j] = true\\n          nxt.push(j)\\n        end\\n      end\\n      puts \"i=#{i}, arr[i] = #{arr[i]}\" if @d\\n      graph[arr[i]].each do |j|\\n        if ! used[j]\\n          used[j] = true\\n          nxt.push(j)\\n        end\\n      end\\n      # Most important line!\\n      graph[arr[i]].clear()\\n    end\\n    puts \"step #{step}: #{nxt.inspect}\" if @d\\n    step += 1\\n    layer = nxt\\n  end\\n  raise \"Must return in the BFS list.\"\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby",
                    "Breadth-First Search"
                ],
                "code": "```Ruby\\n# Leetcode: 1345. Jump Game IV.\\n# https://leetcode.com/problems/jump-game-iv/\\n# = = = = = = =\\n# Accepted.\\n# Thanks God!\\n# = = = = = = =\\n# Runtime: 710 ms, faster than 100.00% of Ruby online submissions for Jump Game IV.\\n# Memory Usage: 227.2 MB, less than 100.00% of Ruby online submissions for Jump Game IV.\\n# @param {Integer[]} arr\\n# @return {Integer}\\ndef min_jumps(arr)\\n  @d = false\\n  puts \"input: #{arr}\" if @d\\n  last_index = arr.size - 1\\n  return 0 if arr.size <= 1\\n  graph = {}\\n  arr.each_with_index do |value,index|\\n    graph[value] ||= []\\n    graph[value].push(index)\\n  end\\n  puts \"graph: #{graph.inspect}\" if @d\\n  layer = [0]\\n  used = {}\\n  used[0] = true\\n  step = 0\\n  while ! layer.empty?\\n    nxt = []\\n    layer.each do |i|\\n      puts  \"i: #{i}\" if @d\\n      return step if last_index == i\\n      [i+1,i-1].each do |j|\\n        if j.between?(0,last_index) && (!used[j])\\n          used[j] = true\\n          nxt.push(j)\\n        end\\n      end\\n      puts \"i=#{i}, arr[i] = #{arr[i]}\" if @d\\n      graph[arr[i]].each do |j|\\n        if ! used[j]\\n          used[j] = true\\n          nxt.push(j)\\n        end\\n      end\\n      # Most important line!\\n      graph[arr[i]].clear()\\n    end\\n    puts \"step #{step}: #{nxt.inspect}\" if @d\\n    step += 1\\n    layer = nxt\\n  end\\n  raise \"Must return in the BFS list.\"\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1692116,
                "title": "can-someone-explain-what-is-wrong-with-dp-failing-for-few-test-cases",
                "content": "The idea is, put all the duplicate values in the map for the condition III and keep checking the min value. \\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        \\n        int n = arr.length;\\n        Map<Integer, ArrayList<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            if(map.containsKey(arr[i])) {        \\n                 map.get(arr[i]).add(i);\\n                continue;\\n            }\\n            map.put(arr[i], new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        } \\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n - 1] = 0;\\n        for(int i = n - 1; i >= 0; i-- ) {\\n            if(i - 1 >= 0 && dp[i - 1] != Integer.MAX_VALUE){\\n                dp[i] =  Math.min(dp[i - 1] + 1 ,  dp[i]);\\n            }\\n            if(i + 1 < n && dp[i + 1] != Integer.MAX_VALUE) {\\n                dp[i] =  Math.min(dp[i + 1] + 1,  dp[i]);\\n            }\\n            int key = arr[i];\\n           \\n            if(map.containsKey(key)) {  \\n                for(int k: map.get(key)) {\\n                    if(k != i ) {\\n                        dp[k] = Math.min(dp[i] + 1, dp[k]);\\n                    }\\n                    \\n                }\\n            }\\n\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        \\n        int n = arr.length;\\n        Map<Integer, ArrayList<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            if(map.containsKey(arr[i])) {        \\n                 map.get(arr[i]).add(i);\\n                continue;\\n            }\\n            map.put(arr[i], new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        } \\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n - 1] = 0;\\n        for(int i = n - 1; i >= 0; i-- ) {\\n            if(i - 1 >= 0 && dp[i - 1] != Integer.MAX_VALUE){\\n                dp[i] =  Math.min(dp[i - 1] + 1 ,  dp[i]);\\n            }\\n            if(i + 1 < n && dp[i + 1] != Integer.MAX_VALUE) {\\n                dp[i] =  Math.min(dp[i + 1] + 1,  dp[i]);\\n            }\\n            int key = arr[i];\\n           \\n            if(map.containsKey(key)) {  \\n                for(int k: map.get(key)) {\\n                    if(k != i ) {\\n                        dp[k] = Math.min(dp[i] + 1, dp[k]);\\n                    }\\n                    \\n                }\\n            }\\n\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691025,
                "title": "javascript-efficient-bfs",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function(arr) {\\n    let visited={},queue=[],node,map={},index,jumps,neighbour;\\n    for(let i=0;i<arr.length;i++){\\n        if(map[arr[i]]===undefined){\\n            map[arr[i]] = [];\\n        }\\n        map[arr[i]].push(i);\\n    }\\n    //console.log(map)\\n    visited[0]=true;\\n    queue.push([0,0]);\\n    while(queue[0]!==undefined){\\n        node = queue.shift();\\n        index = node[0];\\n        jumps = node[1];\\n        if(index===arr.length-1){\\n            return jumps;\\n        }\\n        if(map[arr[index]]!==undefined){\\n            for(let i=0;i<map[arr[index]].length;i++){\\n                neighbour = map[arr[index]][i];\\n                if(visited[neighbour]===undefined){\\n                    visited[neighbour] = true;\\n                    queue.push([neighbour,jumps+1]);\\n                }\\n            }\\n        }\\n        //***IMPORTANT remove this key from map to prevent redundant searches, otherwise we will get Time Limit Exceeded error\\n        delete map[arr[index]];\\n        neighbour = index+1;\\n        if(neighbour>=0 && neighbour<=arr.length-1){\\n            if(visited[neighbour]===undefined){\\n                visited[neighbour] = true;\\n                queue.push([neighbour,jumps+1]);\\n            }\\n        }\\n        neighbour = index-1;\\n        if(neighbour>=0 && neighbour<=arr.length-1){\\n            if(visited[neighbour]===undefined){\\n                visited[neighbour] = true;\\n                queue.push([neighbour,jumps+1]);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function(arr) {\\n    let visited={},queue=[],node,map={},index,jumps,neighbour;\\n    for(let i=0;i<arr.length;i++){\\n        if(map[arr[i]]===undefined){\\n            map[arr[i]] = [];\\n        }\\n        map[arr[i]].push(i);\\n    }\\n    //console.log(map)\\n    visited[0]=true;\\n    queue.push([0,0]);\\n    while(queue[0]!==undefined){\\n        node = queue.shift();\\n        index = node[0];\\n        jumps = node[1];\\n        if(index===arr.length-1){\\n            return jumps;\\n        }\\n        if(map[arr[index]]!==undefined){\\n            for(let i=0;i<map[arr[index]].length;i++){\\n                neighbour = map[arr[index]][i];\\n                if(visited[neighbour]===undefined){\\n                    visited[neighbour] = true;\\n                    queue.push([neighbour,jumps+1]);\\n                }\\n            }\\n        }\\n        //***IMPORTANT remove this key from map to prevent redundant searches, otherwise we will get Time Limit Exceeded error\\n        delete map[arr[index]];\\n        neighbour = index+1;\\n        if(neighbour>=0 && neighbour<=arr.length-1){\\n            if(visited[neighbour]===undefined){\\n                visited[neighbour] = true;\\n                queue.push([neighbour,jumps+1]);\\n            }\\n        }\\n        neighbour = index-1;\\n        if(neighbour>=0 && neighbour<=arr.length-1){\\n            if(visited[neighbour]===undefined){\\n                visited[neighbour] = true;\\n                queue.push([neighbour,jumps+1]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1690887,
                "title": "java-bfs-with-explanations",
                "content": "**Idea**: \\n\\n- Use a Map to group all the indexes with the same value together.\\n\\n- Set `arr[i]` to `INT_MAX` to mark as visited\\n- Use BFS to find the shortest Path.\\n\\n- When we add all the indexes with a certain value into the BFS queue, make sure to either clear the whole list or use a set so we skip them next time. This prevents them from getting added again, which will result in TLE.\\n\\nI commented out the code that uses set, but it is worth noting that calling .clear() is twice slower than using a set to track according to LeetCode Submission Runtime (90ms for Set, 162ms for .clear()).\\n```Java\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++)\\n            map.computeIfAbsent(arr[i], o -> new ArrayList<>()).add(i);\\n\\n        Queue<Integer> queue = new ArrayDeque<>(List.of(0));\\n        // Set<Integer> seen = new HashSet<>();\\n        int ans = 0;\\n        while(!queue.isEmpty()){\\n            int sz = queue.size();\\n            while(--sz >= 0){\\n                int cur = queue.poll(), tmp = arr[cur];\\n                if (!ok(arr, cur)) continue;\\n                if (cur == arr.length - 1) return ans;\\n                arr[cur] = Integer.MAX_VALUE;\\n                if (ok(arr, cur - 1)) queue.offer(cur - 1);\\n                if (ok(arr, cur + 1)) queue.offer(cur + 1);\\n                // if (seen.contains(tmp)) continue;\\n                for (int next : map.getOrDefault(tmp, Collections.emptyList()))\\n                    if (ok(arr, next))\\n                        queue.offer(next);\\n                map.get(tmp).clear();\\n                // seen.add(tmp);\\n            }\\n\\n            ans++;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean ok(int[] arr, int idx){\\n        return idx >= 0 && idx < arr.length && arr[idx] != Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++)\\n            map.computeIfAbsent(arr[i], o -> new ArrayList<>()).add(i);\\n\\n        Queue<Integer> queue = new ArrayDeque<>(List.of(0));\\n        // Set<Integer> seen = new HashSet<>();\\n        int ans = 0;\\n        while(!queue.isEmpty()){\\n            int sz = queue.size();\\n            while(--sz >= 0){\\n                int cur = queue.poll(), tmp = arr[cur];\\n                if (!ok(arr, cur)) continue;\\n                if (cur == arr.length - 1) return ans;\\n                arr[cur] = Integer.MAX_VALUE;\\n                if (ok(arr, cur - 1)) queue.offer(cur - 1);\\n                if (ok(arr, cur + 1)) queue.offer(cur + 1);\\n                // if (seen.contains(tmp)) continue;\\n                for (int next : map.getOrDefault(tmp, Collections.emptyList()))\\n                    if (ok(arr, next))\\n                        queue.offer(next);\\n                map.get(tmp).clear();\\n                // seen.add(tmp);\\n            }\\n\\n            ans++;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean ok(int[] arr, int idx){\\n        return idx >= 0 && idx < arr.length && arr[idx] != Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690774,
                "title": "python3-bfs-memory-limit-solution",
                "content": "This was hard. The idea of the algorithm is simple. We need a minimum path to the n-1 node. BFS is a simple algorithm to reach the minimum path with edges of weight 1.\\n\\nEach node will have as adjacents the node+1, node-1, and all the nodes with the same value. To speed up the algorithm, we need to first calculate the nodes with the same value and store them in a dictionary.\\n\\nThe problem was a test that has a lot of elements 7,7,7,7,7 where we can get a memory limit. The solution is to delete the entry on the dictionary for the key = node. Line:\\n`\\nsame_value[arr[node]].clear()\\n`\\n\\nI recall that BFS is O(V+E) being V the number of nodes and E number of edges. The number of edges could be bigger than N (and it fact it is). The node 1 in example, is related to node 0 and 2 at least. If the node 1 has another node with the same value, the number of edges is going to be even bigger. So, I would state O(E) worst case being E the number of links due to E > N in this problem.\\n\\nThe other trick I\\'ve used is to keep the level in the same stack. So, I can return the length of the path directly from there.\\n\\nHere is the code:\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        \\n        n = len(arr)\\n        visited = set()\\n        \\n        \\n        if n <= 1:\\n            return 0\\n        \\n        same_value = dict()\\n        \\n        for i, v in enumerate(arr):\\n            if v not in same_value.keys():\\n                same_value[v]= [i]\\n            else:\\n                same_value[v].append(i)\\n                \\n        stack = list()\\n        level = 0\\n        \\n        stack.append((0,0))\\n        total = -1\\n        \\n        \\n        while stack:\\n            level,node = stack.pop(0)\\n        \\n            visited.add(node)\\n            \\n            if node == n-1:\\n                return level\\n            else:\\n                for a in same_value[arr[node]] :\\n                    if a != node and a not in visited:\\n                        stack.append((level+1,a))\\n                \\n                same_value[arr[node]].clear()\\n                \\n                if node+1 < n and node+1 not in visited:\\n                    stack.append((level+1,node+1))\\n                 \\n                if node-1 >=0 and node-1 not in visited:\\n                    stack.append((level+1,node-1))\\n                    \\n\\n                                 \\n        return level\\n                    \\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        \\n        n = len(arr)\\n        visited = set()\\n        \\n        \\n        if n <= 1:\\n            return 0\\n        \\n        same_value = dict()\\n        \\n        for i, v in enumerate(arr):\\n            if v not in same_value.keys():\\n                same_value[v]= [i]\\n            else:\\n                same_value[v].append(i)\\n                \\n        stack = list()\\n        level = 0\\n        \\n        stack.append((0,0))\\n        total = -1\\n        \\n        \\n        while stack:\\n            level,node = stack.pop(0)\\n        \\n            visited.add(node)\\n            \\n            if node == n-1:\\n                return level\\n            else:\\n                for a in same_value[arr[node]] :\\n                    if a != node and a not in visited:\\n                        stack.append((level+1,a))\\n                \\n                same_value[arr[node]].clear()\\n                \\n                if node+1 < n and node+1 not in visited:\\n                    stack.append((level+1,node+1))\\n                 \\n                if node-1 >=0 and node-1 not in visited:\\n                    stack.append((level+1,node-1))\\n                    \\n\\n                                 \\n        return level\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690651,
                "title": "python-bfs-with-use-hyperlink-once-trick",
                "content": "If you use a hyperlink, you can erase them so they aren\\'t used again. This way it runs in O(n) time and extra space.\\n(See `matches[arr[i]] = []` below.)\\n\\n```\\nfrom typing import List\\nfrom collections import defaultdict, Counter\\nfrom itertools import chain\\n\\n\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        start, end = 0, n-1\\n\\n        reached, frontier, matches = set(), {start}, defaultdict(list)\\n        for i, num in enumerate(arr):\\n            matches[num].append(i)\\n\\n        def next_states(i):\\n            yield from (j for j in chain([i-1, i+1], matches[arr[i]]) if i != j and 0 <= j < n)\\n            matches[arr[i]] = []\\n\\n        levels = 0\\n        while  frontier:\\n            if end in frontier:\\n                return levels\\n            newfrontier = {j for i in frontier for j in next_states(i)}\\n            reached.update(frontier)\\n            frontier = newfrontier.difference(reached)\\n            levels += 1\\n\\n        return levels\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\nfrom collections import defaultdict, Counter\\nfrom itertools import chain\\n\\n\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        start, end = 0, n-1\\n\\n        reached, frontier, matches = set(), {start}, defaultdict(list)\\n        for i, num in enumerate(arr):\\n            matches[num].append(i)\\n\\n        def next_states(i):\\n            yield from (j for j in chain([i-1, i+1], matches[arr[i]]) if i != j and 0 <= j < n)\\n            matches[arr[i]] = []\\n\\n        levels = 0\\n        while  frontier:\\n            if end in frontier:\\n                return levels\\n            newfrontier = {j for i in frontier for j in next_states(i)}\\n            reached.update(frontier)\\n            frontier = newfrontier.difference(reached)\\n            levels += 1\\n\\n        return levels\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690629,
                "title": "python-bfs-o-n-time",
                "content": "This problem asks the `minumum number of steps`. The BFS (Breadth-first-search) is known for the solution of this subject.\\n\\nLet\\'s take a look of the example `arr = [100,-23,-23,404,100,23,23,23,3,404]`\\n\\nStep0\\n![image](https://assets.leetcode.com/users/images/41c8b282-bac8-4807-b210-2ab21ba08cdf_1642207727.6492648.png)\\n\\nstep1\\n![image](https://assets.leetcode.com/users/images/0b85df85-8ddb-42e7-bd98-f13827b5925c_1642207737.4827814.png)\\n\\nstep2\\n![image](https://assets.leetcode.com/users/images/e53519f2-9eac-4abf-b3c9-14c9f60b3836_1642207746.250499.png)\\n\\nstep3\\n![image](https://assets.leetcode.com/users/images/46a9a228-1af5-4bf3-8707-d333239427fc_1642207757.079583.png)\\n\\nAs you can see above images, we visit (almost of ) all nodes only once.\\nTo prevent a cycled path, we need to mark `visited[i] = True`.\\n\\nSo, the time complexity is `O(N)`, and the space complexity is also `O(N)`.\\n\\n----\\n\\nThe `BFS` is implemented using `queue` typically, but in this problem, `(i +/- 1)` and `nums[i] == nums[j]` are duplicated sometimes.\\nOf course, we manage visiting, so it\\'s not a big problem, but to reduce the number of iteration, we use `set()` instead.\\n\\n\\n\\n```python\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        N = len(arr)\\n        if (N == 1):\\n            return 0\\n        \\n        # We build a key-values(list) dictionary\\n        # where the key is value of the array element,\\n        # and values are indicies of the elements\\n        positions = {}\\n        for i in range(N):\\n            if arr[i] not in positions:\\n                positions[arr[i]] = []\\n            positions[arr[i]].append(i)\\n        \\n        visited = [False] * N\\n        \\n        # BFS search\\n        queue = set()\\n        queue.add(0)\\n        stepCnt = 0\\n        lastIdx = N - 1\\n        \\n        while(queue):\\n            \\n            nextQ = set()\\n            for i in queue:\\n\\n                # If visited, ignore this path\\n                if visited[i]:\\n                    continue\\n                visited[i] = True\\n                \\n\\n                if i == lastIdx:\\n                    return stepCnt\\n\\n                #\\n                # i - 1 or i + 1\\n                # \\n                if (i - 1 >= 0) and (visited[i - 1] == False) and (arr[i -1] != arr[i]):\\n                    nextQ.add(i - 1)\\n                    \\n                if (i + 1 < N) and (visited[i + 1] == False) and (arr[i + 1] != arr[i]):\\n                    nextQ.add(i + 1)\\n\\n                #\\n                # Jump to the same value indicies\\n                # \\n                if (arr[i] not in positions):\\n                    continue\\n                indiciesOfsameValues = positions[arr[i]]\\n                for idx in indiciesOfsameValues:\\n                    if (visited[idx]):\\n                        continue\\n                    \\n                    nextQ.add(idx)\\n\\n                del positions[arr[i]]\\n            stepCnt += 1\\n\\n            queue = nextQ\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        N = len(arr)\\n        if (N == 1):\\n            return 0\\n        \\n        # We build a key-values(list) dictionary\\n        # where the key is value of the array element,\\n        # and values are indicies of the elements\\n        positions = {}\\n        for i in range(N):\\n            if arr[i] not in positions:\\n                positions[arr[i]] = []\\n            positions[arr[i]].append(i)\\n        \\n        visited = [False] * N\\n        \\n        # BFS search\\n        queue = set()\\n        queue.add(0)\\n        stepCnt = 0\\n        lastIdx = N - 1\\n        \\n        while(queue):\\n            \\n            nextQ = set()\\n            for i in queue:\\n\\n                # If visited, ignore this path\\n                if visited[i]:\\n                    continue\\n                visited[i] = True\\n                \\n\\n                if i == lastIdx:\\n                    return stepCnt\\n\\n                #\\n                # i - 1 or i + 1\\n                # \\n                if (i - 1 >= 0) and (visited[i - 1] == False) and (arr[i -1] != arr[i]):\\n                    nextQ.add(i - 1)\\n                    \\n                if (i + 1 < N) and (visited[i + 1] == False) and (arr[i + 1] != arr[i]):\\n                    nextQ.add(i + 1)\\n\\n                #\\n                # Jump to the same value indicies\\n                # \\n                if (arr[i] not in positions):\\n                    continue\\n                indiciesOfsameValues = positions[arr[i]]\\n                for idx in indiciesOfsameValues:\\n                    if (visited[idx]):\\n                        continue\\n                    \\n                    nextQ.add(idx)\\n\\n                del positions[arr[i]]\\n            stepCnt += 1\\n\\n            queue = nextQ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635412,
                "title": "python-bfs-optimized-with-comments-that-explain",
                "content": "Comments explain the algorithm in detail.\\n\\nTime complexity should be O(N) where N represents the number of nodes in our graph\\n\\nSpace complexity is O(N)\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        # store all possible jump candidates\\n        m = {num: [] for num in arr}\\n        \\n        for i, num in enumerate(arr):\\n            # we dismiss all nodes that we could already visit by the other mean of being able to step one up and one down\\n\\t\\t\\t# (so if a node had the same value as another and they were bordering, why store it?, \\n\\t\\t\\t# it will not matter and just adds to our unnecessary nodes to visit)\\n            if 0 < i < len(arr)-1 and arr[i - 1] == num and num == arr[i + 1]:\\n                continue\\n            m[num].append(i)\\n        \\n        # dont want to revisit the same index\\n        visited = set()\\n        \\n        n = len(arr)\\n    \\n        q = deque()\\n        # add the 0th node in our queue as that is our starting point\\n        q.append(0)\\n        res = 0\\n        while q:\\n            children = len(q)\\n\\t\\t\\t# Here we are currently doing as many iterations as there are nodes in the queue right now\\n\\t\\t\\t# The reason being that we do not want to accidentally visit nodes that were not meant to be\\n\\t\\t\\t# Visited right now\\n            for _ in range(children):\\n                i = q.popleft()\\n                # don\\'t want to revisit the same node\\n                if i in visited:\\n                    continue\\n                # if we reached the end then gg, we won\\n                if i == n-1:\\n                    return res\\n                visited.add(i)\\n                # can we move one forward?, if we can then let\\'s try that\\n                if (i+1) not in visited:\\n                    q.append(i+1)\\n                    \\n                # can we move one back? if we can then let\\'s try that\\n                if (i-1) not in visited and (i-1) >= 0:\\n                    q.append(i-1)\\n                    \\n\\n                # let\\'s add every possible value that has the same value as the current one to our list to visit\\n                for neighbor in m[arr[i]]:\\n                    if neighbor in visited:\\n                        continue\\n                    q.append(neighbor)\\n                # No longer need to visit this node\\'s partner values ever again, \\n                # so let\\'s remove all of it\\'s partner values. \\n                # This also stops the partner nodes from visiting each other again\\n                # As that is a possibility (You visit all 100s, then when you are visiting\\n                # the next 100 in your graph, you have to iterate through all 100s again, \\n\\t\\t\\t\\t# that is inefficient so we empty the 100s connections)\\n                m[arr[i]] = []\\n            res += 1\\t\\t\\t\\n        # if we don\\'t get an answer, return -1. Not needed as we are guaranteed an answer but some error checking is a best practice so why not\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        # store all possible jump candidates\\n        m = {num: [] for num in arr}\\n        \\n        for i, num in enumerate(arr):\\n            # we dismiss all nodes that we could already visit by the other mean of being able to step one up and one down\\n\\t\\t\\t# (so if a node had the same value as another and they were bordering, why store it?, \\n\\t\\t\\t# it will not matter and just adds to our unnecessary nodes to visit)\\n            if 0 < i < len(arr)-1 and arr[i - 1] == num and num == arr[i + 1]:\\n                continue\\n            m[num].append(i)\\n        \\n        # dont want to revisit the same index\\n        visited = set()\\n        \\n        n = len(arr)\\n    \\n        q = deque()\\n        # add the 0th node in our queue as that is our starting point\\n        q.append(0)\\n        res = 0\\n        while q:\\n            children = len(q)\\n\\t\\t\\t# Here we are currently doing as many iterations as there are nodes in the queue right now\\n\\t\\t\\t# The reason being that we do not want to accidentally visit nodes that were not meant to be\\n\\t\\t\\t# Visited right now\\n            for _ in range(children):\\n                i = q.popleft()\\n                # don\\'t want to revisit the same node\\n                if i in visited:\\n                    continue\\n                # if we reached the end then gg, we won\\n                if i == n-1:\\n                    return res\\n                visited.add(i)\\n                # can we move one forward?, if we can then let\\'s try that\\n                if (i+1) not in visited:\\n                    q.append(i+1)\\n                    \\n                # can we move one back? if we can then let\\'s try that\\n                if (i-1) not in visited and (i-1) >= 0:\\n                    q.append(i-1)\\n                    \\n\\n                # let\\'s add every possible value that has the same value as the current one to our list to visit\\n                for neighbor in m[arr[i]]:\\n                    if neighbor in visited:\\n                        continue\\n                    q.append(neighbor)\\n                # No longer need to visit this node\\'s partner values ever again, \\n                # so let\\'s remove all of it\\'s partner values. \\n                # This also stops the partner nodes from visiting each other again\\n                # As that is a possibility (You visit all 100s, then when you are visiting\\n                # the next 100 in your graph, you have to iterate through all 100s again, \\n\\t\\t\\t\\t# that is inefficient so we empty the 100s connections)\\n                m[arr[i]] = []\\n            res += 1\\t\\t\\t\\n        # if we don\\'t get an answer, return -1. Not needed as we are guaranteed an answer but some error checking is a best practice so why not\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458025,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        \\n        int n = arr.length;\\n        \\n        if(n<=1){\\n            return 0;\\n        }\\n        \\n        Map<Integer,Set<Integer>> graph = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            graph.putIfAbsent(arr[i],new HashSet<>());\\n            graph.get(arr[i]).add(i);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        queue.offer(0);\\n        \\n        int steps=0;\\n        \\n        while(!queue.isEmpty()){\\n            steps++;\\n            \\n            int size = queue.size();\\n            \\n            for(int i=0;i<size;i++){\\n                \\n                int jump = queue.poll();\\n                \\n                // jump-1\\n                \\n                if(jump-1>=0&&graph.containsKey(arr[jump-1])){\\n                    queue.offer(jump-1);\\n                }\\n                \\n                // jump+1\\n                if(jump+1<n&&graph.containsKey(arr[jump+1])){\\n                    if(jump+1==n-1){\\n                        return steps;\\n                    }\\n                    queue.offer(jump+1);\\n                }\\n                \\n                if(graph.containsKey(arr[jump])){\\n                    \\n                    for(int k : graph.get(arr[jump])){\\n                        if(k!=jump){\\n                            if(k==n-1){\\n                                return steps;\\n                            }\\n                            queue.offer(k);\\n                        }\\n                    }\\n                }\\n                graph.remove(arr[jump]);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        \\n        int n = arr.length;\\n        \\n        if(n<=1){\\n            return 0;\\n        }\\n        \\n        Map<Integer,Set<Integer>> graph = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            graph.putIfAbsent(arr[i],new HashSet<>());\\n            graph.get(arr[i]).add(i);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        queue.offer(0);\\n        \\n        int steps=0;\\n        \\n        while(!queue.isEmpty()){\\n            steps++;\\n            \\n            int size = queue.size();\\n            \\n            for(int i=0;i<size;i++){\\n                \\n                int jump = queue.poll();\\n                \\n                // jump-1\\n                \\n                if(jump-1>=0&&graph.containsKey(arr[jump-1])){\\n                    queue.offer(jump-1);\\n                }\\n                \\n                // jump+1\\n                if(jump+1<n&&graph.containsKey(arr[jump+1])){\\n                    if(jump+1==n-1){\\n                        return steps;\\n                    }\\n                    queue.offer(jump+1);\\n                }\\n                \\n                if(graph.containsKey(arr[jump])){\\n                    \\n                    for(int k : graph.get(arr[jump])){\\n                        if(k!=jump){\\n                            if(k==n-1){\\n                                return steps;\\n                            }\\n                            queue.offer(k);\\n                        }\\n                    }\\n                }\\n                graph.remove(arr[jump]);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263812,
                "title": "c-o-n-bfs-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        /*\\n        Logic is to apply bfs traversal and the level at which last index is found is the shortest distance.\\n        For a parent (ith index) its children will be:\\n        -> i-1, if i-1>=0\\n        -> i+1, if i+1<n\\n        -> all its duplicate element indexes except i\\n        */\\n        int n=arr.size(), level=0;\\n        vector<bool> visited(n, false);\\n        // To store nodes during bfs\\n        queue<int> bfs;\\n        //To store duplicate indexes\\n        unordered_map<int, stack<int>> duplicate_index;\\n        for (int i=0; i<n; i++)\\n            duplicate_index[arr[i]].push(i);\\n        bfs.push(0);\\n        visited[0] = true;\\n        while(!bfs.empty()){\\n            int size=bfs.size();\\n            // after while loop ends level is increased\\n            while(size--){\\n                int i=bfs.front();\\n                bfs.pop();\\n                if (i==n-1)\\n                    return level;\\n                //i-1 jump\\n                if (i-1>=0 && !visited[i-1]){\\n                    bfs.push(i-1);\\n                    visited[i-1]=true;\\n                }\\n                //i+1 jump\\n                if (i+1<n && !visited[i+1]){\\n                    bfs.push(i+1);\\n                    visited[i+1]=true;\\n                }\\n                // jump to duplicate element\\n                while (!duplicate_index[arr[i]].empty()){\\n                    int dup_i = duplicate_index[arr[i]].top();\\n                    duplicate_index[arr[i]].pop();\\n                    if (!visited[dup_i]){\\n                        bfs.push(dup_i);\\n                        visited[dup_i]=true;\\n                    }\\n                } \\n            }\\n            level++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        /*\\n        Logic is to apply bfs traversal and the level at which last index is found is the shortest distance.\\n        For a parent (ith index) its children will be:\\n        -> i-1, if i-1>=0\\n        -> i+1, if i+1<n\\n        -> all its duplicate element indexes except i\\n        */\\n        int n=arr.size(), level=0;\\n        vector<bool> visited(n, false);\\n        // To store nodes during bfs\\n        queue<int> bfs;\\n        //To store duplicate indexes\\n        unordered_map<int, stack<int>> duplicate_index;\\n        for (int i=0; i<n; i++)\\n            duplicate_index[arr[i]].push(i);\\n        bfs.push(0);\\n        visited[0] = true;\\n        while(!bfs.empty()){\\n            int size=bfs.size();\\n            // after while loop ends level is increased\\n            while(size--){\\n                int i=bfs.front();\\n                bfs.pop();\\n                if (i==n-1)\\n                    return level;\\n                //i-1 jump\\n                if (i-1>=0 && !visited[i-1]){\\n                    bfs.push(i-1);\\n                    visited[i-1]=true;\\n                }\\n                //i+1 jump\\n                if (i+1<n && !visited[i+1]){\\n                    bfs.push(i+1);\\n                    visited[i+1]=true;\\n                }\\n                // jump to duplicate element\\n                while (!duplicate_index[arr[i]].empty()){\\n                    int dup_i = duplicate_index[arr[i]].top();\\n                    duplicate_index[arr[i]].pop();\\n                    if (!visited[dup_i]){\\n                        bfs.push(dup_i);\\n                        visited[dup_i]=true;\\n                    }\\n                } \\n            }\\n            level++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202192,
                "title": "java-simple-and-easy-to-understand-solution-44-ms-faster-than-90-47-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        \\n        HashMap<Integer, ArrayList<Integer>> graph = new HashMap();\\n        \\n        for(int i = 0; i< n; i++){\\n            graph.putIfAbsent(arr[i], new ArrayList());\\n            graph.get(arr[i]).add(i);\\n        }\\n        \\n        \\n        HashSet<Integer> curr = new HashSet();\\n        curr.add(0);\\n        \\n        HashSet<Integer> other = new HashSet();\\n        other.add(n - 1);\\n        \\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        visited[n - 1] = true;\\n        \\n        int steps = 0;\\n        while(!curr.isEmpty()){\\n            \\n            //consider small size set\\n            if(curr.size() > other.size()){\\n                //swap sets\\n                HashSet<Integer> temp = curr;\\n                curr = other;\\n                other = temp;\\n            }\\n            \\n            HashSet<Integer> next = new HashSet();\\n            \\n            for(int currIndex : curr){\\n                \\n                //check same value\\n                for(int index : graph.get(arr[currIndex])){\\n                    \\n                    //check already reached to this index from other end\\n                    if(other.contains(index)) return steps + 1;\\n                \\n                    if(!visited[index]){\\n                        visited[index] = true;\\n                        next.add(index);\\n                    }\\n                }\\n                \\n                \\n                graph.get(arr[currIndex]).clear();\\n                \\n                //check already reached to this index (neighbors) from other end\\n                if(other.contains(currIndex + 1) || other.contains(currIndex - 1)) return steps + 1;\\n                \\n                \\n                //check left index\\n                if(currIndex - 1 >= 0 && !visited[currIndex - 1]){\\n                    visited[currIndex - 1] = true;\\n                    next.add(currIndex - 1);\\n                }\\n                \\n                //check right index\\n                if(currIndex + 1 <= n - 1 && !visited[currIndex + 1]){\\n                    visited[currIndex + 1] = true;\\n                    next.add(currIndex + 1);\\n                }\\n                \\n                \\n            }\\n            \\n            curr = next;\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        \\n        HashMap<Integer, ArrayList<Integer>> graph = new HashMap();\\n        \\n        for(int i = 0; i< n; i++){\\n            graph.putIfAbsent(arr[i], new ArrayList());\\n            graph.get(arr[i]).add(i);\\n        }\\n        \\n        \\n        HashSet<Integer> curr = new HashSet();\\n        curr.add(0);\\n        \\n        HashSet<Integer> other = new HashSet();\\n        other.add(n - 1);\\n        \\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        visited[n - 1] = true;\\n        \\n        int steps = 0;\\n        while(!curr.isEmpty()){\\n            \\n            //consider small size set\\n            if(curr.size() > other.size()){\\n                //swap sets\\n                HashSet<Integer> temp = curr;\\n                curr = other;\\n                other = temp;\\n            }\\n            \\n            HashSet<Integer> next = new HashSet();\\n            \\n            for(int currIndex : curr){\\n                \\n                //check same value\\n                for(int index : graph.get(arr[currIndex])){\\n                    \\n                    //check already reached to this index from other end\\n                    if(other.contains(index)) return steps + 1;\\n                \\n                    if(!visited[index]){\\n                        visited[index] = true;\\n                        next.add(index);\\n                    }\\n                }\\n                \\n                \\n                graph.get(arr[currIndex]).clear();\\n                \\n                //check already reached to this index (neighbors) from other end\\n                if(other.contains(currIndex + 1) || other.contains(currIndex - 1)) return steps + 1;\\n                \\n                \\n                //check left index\\n                if(currIndex - 1 >= 0 && !visited[currIndex - 1]){\\n                    visited[currIndex - 1] = true;\\n                    next.add(currIndex - 1);\\n                }\\n                \\n                //check right index\\n                if(currIndex + 1 <= n - 1 && !visited[currIndex + 1]){\\n                    visited[currIndex + 1] = true;\\n                    next.add(currIndex + 1);\\n                }\\n                \\n                \\n            }\\n            \\n            curr = next;\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194004,
                "title": "c-bfs-solution",
                "content": "```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        \\n        if(arr == null || arr.Length <= 1)\\n            return 0;\\n        \\n        Dictionary<int,List<int>> dic = new Dictionary<int,List<int>>();\\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            if(!dic.ContainsKey(arr[i]))\\n                dic.Add(arr[i], new List<int>(){i});\\n            else\\n                dic[arr[i]].Add(i);\\n        }\\n        \\n        bool[] visited = new bool[arr.Length];\\n        Queue<int> queue = new Queue<int>();\\n        queue.Enqueue(0);\\n        visited[0] = true;\\n        int res = 0;\\n        while(queue.Count > 0)\\n        {\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++)\\n            {\\n                int curr = queue.Dequeue();\\n                if(curr == arr.Length - 1)\\n                    return res;\\n\\n                int left = curr - 1;\\n                int right = curr + 1;\\n                if(left >= 0 && !visited[left])\\n                {\\n                    queue.Enqueue(left);\\n                    visited[left] = true;\\n                }\\n                if(right < arr.Length && !visited[right])\\n                {\\n                    queue.Enqueue(right);\\n                    visited[right] = true;\\n                }\\n                foreach(int next in dic[arr[curr]])\\n                {\\n                    if(!visited[next])\\n                    {\\n                        queue.Enqueue(next);\\n                        visited[next] = true;\\n                    }\\n                }\\n                dic[arr[curr]].Clear(); // this is critical. Once the all cells with current value are visited, no need to checck again\\n            }         \\n            res++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        \\n        if(arr == null || arr.Length <= 1)\\n            return 0;\\n        \\n        Dictionary<int,List<int>> dic = new Dictionary<int,List<int>>();\\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            if(!dic.ContainsKey(arr[i]))\\n                dic.Add(arr[i], new List<int>(){i});\\n            else\\n                dic[arr[i]].Add(i);\\n        }\\n        \\n        bool[] visited = new bool[arr.Length];\\n        Queue<int> queue = new Queue<int>();\\n        queue.Enqueue(0);\\n        visited[0] = true;\\n        int res = 0;\\n        while(queue.Count > 0)\\n        {\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++)\\n            {\\n                int curr = queue.Dequeue();\\n                if(curr == arr.Length - 1)\\n                    return res;\\n\\n                int left = curr - 1;\\n                int right = curr + 1;\\n                if(left >= 0 && !visited[left])\\n                {\\n                    queue.Enqueue(left);\\n                    visited[left] = true;\\n                }\\n                if(right < arr.Length && !visited[right])\\n                {\\n                    queue.Enqueue(right);\\n                    visited[right] = true;\\n                }\\n                foreach(int next in dic[arr[curr]])\\n                {\\n                    if(!visited[next])\\n                    {\\n                        queue.Enqueue(next);\\n                        visited[next] = true;\\n                    }\\n                }\\n                dic[arr[curr]].Clear(); // this is critical. Once the all cells with current value are visited, no need to checck again\\n            }         \\n            res++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171202,
                "title": "java-bfs-49ms-beats-81-t-c-o-n-s-c-o-n",
                "content": "\\n    class Pair {\\n\\n\\t\\tint idx;\\n\\t\\tint jump;\\n\\n\\t\\tpublic Pair(int idx, int jump) {\\n\\t\\t\\tthis.idx = idx;\\n\\t\\t\\tthis.jump = jump;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tpublic int minJumps(int[] arr) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\tHashMap<Integer, List<Integer>> map = new HashMap<>();\\n\\t\\tQueue<Pair> queue = new LinkedList<>();\\n\\t\\tboolean[] visited = new boolean[len];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tList<Integer> list = map.getOrDefault(arr[i], new ArrayList<>());\\n\\t\\t\\tlist.add(i);\\n\\t\\t\\tmap.put(arr[i], list);\\n\\t\\t}\\n\\n\\t\\tqueue.add(new Pair(0, 0));\\n\\t\\tvisited[0] = true;\\n\\n\\t\\twhile (!queue.isEmpty()) {\\n\\n\\t\\t\\tPair temp = queue.poll();\\n\\t\\t\\tint idx = temp.idx;\\n\\t\\t\\tint jump = temp.jump;\\n\\n\\t\\t\\tif (idx == len - 1)\\n\\t\\t\\t\\treturn temp.jump;\\n\\n\\t\\t\\tif (idx - 1 >= 0 && !visited[idx - 1]) {\\n\\t\\t\\t\\tvisited[idx - 1] = true;\\n\\t\\t\\t\\tqueue.add(new Pair(idx - 1, jump + 1));\\n\\t\\t\\t}\\n\\t\\t\\tif (idx + 1 < len && !visited[idx + 1]) {\\n\\t\\t\\t\\tvisited[idx + 1] = true;\\n\\t\\t\\t\\tqueue.add(new Pair(idx + 1, jump + 1));\\n\\t\\t\\t}\\n\\t\\t\\tList<Integer> nbrs = map.get(arr[idx]);\\n\\t\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\t\\tif (nbr != idx && !visited[nbr]) {\\n\\t\\t\\t\\t\\tvisited[nbr] = true;\\n\\t\\t\\t\\t\\tqueue.add(new Pair(nbr, jump + 1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnbrs.clear();\\n\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    class Pair {\\n\\n\\t\\tint idx;\\n\\t\\tint jump;\\n\\n\\t\\tpublic Pair(int idx, int jump) {\\n\\t\\t\\tthis.idx = idx;\\n\\t\\t\\tthis.jump = jump;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tpublic int minJumps(int[] arr) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\tHashMap<Integer, List<Integer>> map = new HashMap<>();\\n\\t\\tQueue<Pair> queue = new LinkedList<>();\\n\\t\\tboolean[] visited = new boolean[len];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tList<Integer> list = map.getOrDefault(arr[i], new ArrayList<>());\\n\\t\\t\\tlist.add(i);\\n\\t\\t\\tmap.put(arr[i], list);\\n\\t\\t}\\n\\n\\t\\tqueue.add(new Pair(0, 0));\\n\\t\\tvisited[0] = true;\\n\\n\\t\\twhile (!queue.isEmpty()) {\\n\\n\\t\\t\\tPair temp = queue.poll();\\n\\t\\t\\tint idx = temp.idx;\\n\\t\\t\\tint jump = temp.jump;\\n\\n\\t\\t\\tif (idx == len - 1)\\n\\t\\t\\t\\treturn temp.jump;\\n\\n\\t\\t\\tif (idx - 1 >= 0 && !visited[idx - 1]) {\\n\\t\\t\\t\\tvisited[idx - 1] = true;\\n\\t\\t\\t\\tqueue.add(new Pair(idx - 1, jump + 1));\\n\\t\\t\\t}\\n\\t\\t\\tif (idx + 1 < len && !visited[idx + 1]) {\\n\\t\\t\\t\\tvisited[idx + 1] = true;\\n\\t\\t\\t\\tqueue.add(new Pair(idx + 1, jump + 1));\\n\\t\\t\\t}\\n\\t\\t\\tList<Integer> nbrs = map.get(arr[idx]);\\n\\t\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\t\\tif (nbr != idx && !visited[nbr]) {\\n\\t\\t\\t\\t\\tvisited[nbr] = true;\\n\\t\\t\\t\\t\\tqueue.add(new Pair(nbr, jump + 1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnbrs.clear();\\n\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1102518,
                "title": "dfs-memoization-does-not-work-explanation-and-example",
                "content": "I am trying to explain why DFS + Memoization does not work, using an example. \\nI feel my explanation is still vague.\\nI eagerly want to see any better explanation or **chracterization of this kind of problems**.\\n\\n```\\n// DFS + Memoization does not work: see the comments below\\n// The following algorithm gives \"6\" and the correct value is \"5\"\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[arr[i]].push_back(i);\\n        }\\n\\n        vector<int> mem(n, INT_MAX);\\n        mem[n - 1] = 0;\\n        int start = 0;\\n        mj(arr, n, mp, 0, mem);\\n        return mem[0];\\n    }\\n\\nprivate:\\n    void mj(vector<int>& arr, int n, unordered_map<int, vector<int>>& mp, int start, vector<int>& mem) {\\n        if (start >= n || start < 0 || mem[start] != INT_MAX) {\\n            // this is incorrect, when mem[start] value is looked up\\n            // mem[start] value may not be the min value, when mem[start] is looked up;\\n            // e.g., for arr = [3, 9, 12, 11, 3, 2, 2, 11, 4, 13, 4];\\n            // mem[3] is not the min value 3, when mem[3] is looked up by mem[4] in the \"if (start - 1 >= 0)\" branch;\\n            // mem[3] is the value 4, when it is looked up in that branch.\\n            // This problem exists because mem[3] is updated later in the \"for (int x ...)\" block;\\n            //\\n            // Memoization may not work, when all of the following 3 depency exist: \\n            //  - forward dependency, i.e., mem[start] depends on mem[start + 1];\\n            //  - backward dependncy, i.e., mem[start] depends on mem[start - 1];\\n            //  - jump dependency, i.e., mem[start] depends on mem[x];\\n            return;\\n        }\\n\\n        if (start + 1 < n) {\\n            mj(arr, n, mp, start + 1, mem);\\n            mem[start] = min(mem[start], mem[start + 1]);\\n        }\\n\\n        if (start - 1 >= 0) {\\n            mj(arr, n, mp, start - 1, mem);\\n            mem[start] = min(mem[start], mem[start - 1]);\\n        }\\n\\n        for (int x : mp[arr[start]]) {\\n            if (x != start) {\\n                mj(arr, n, mp, x, mem);\\n                mem[start] = min(mem[start], mem[x]);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// DFS + Memoization does not work: see the comments below\\n// The following algorithm gives \"6\" and the correct value is \"5\"\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[arr[i]].push_back(i);\\n        }\\n\\n        vector<int> mem(n, INT_MAX);\\n        mem[n - 1] = 0;\\n        int start = 0;\\n        mj(arr, n, mp, 0, mem);\\n        return mem[0];\\n    }\\n\\nprivate:\\n    void mj(vector<int>& arr, int n, unordered_map<int, vector<int>>& mp, int start, vector<int>& mem) {\\n        if (start >= n || start < 0 || mem[start] != INT_MAX) {\\n            // this is incorrect, when mem[start] value is looked up\\n            // mem[start] value may not be the min value, when mem[start] is looked up;\\n            // e.g., for arr = [3, 9, 12, 11, 3, 2, 2, 11, 4, 13, 4];\\n            // mem[3] is not the min value 3, when mem[3] is looked up by mem[4] in the \"if (start - 1 >= 0)\" branch;\\n            // mem[3] is the value 4, when it is looked up in that branch.\\n            // This problem exists because mem[3] is updated later in the \"for (int x ...)\" block;\\n            //\\n            // Memoization may not work, when all of the following 3 depency exist: \\n            //  - forward dependency, i.e., mem[start] depends on mem[start + 1];\\n            //  - backward dependncy, i.e., mem[start] depends on mem[start - 1];\\n            //  - jump dependency, i.e., mem[start] depends on mem[x];\\n            return;\\n        }\\n\\n        if (start + 1 < n) {\\n            mj(arr, n, mp, start + 1, mem);\\n            mem[start] = min(mem[start], mem[start + 1]);\\n        }\\n\\n        if (start - 1 >= 0) {\\n            mj(arr, n, mp, start - 1, mem);\\n            mem[start] = min(mem[start], mem[start - 1]);\\n        }\\n\\n        for (int x : mp[arr[start]]) {\\n            if (x != start) {\\n                mj(arr, n, mp, x, mem);\\n                mem[start] = min(mem[start], mem[x]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989513,
                "title": "swift-solution-beats-100",
                "content": "Swift solution beats 100%\\n```\\nclass Solution {\\n    func minJumps(_ arr: [Int]) -> Int {\\n        let c = arr.count\\n        var equals = [Int: [Int]](), unvisited = [Bool](repeating: true, count: c), nextQueue = [Int](), result = 0\\n        func appendQueue(_ index: Int) {\\n            if unvisited[index] {\\n                nextQueue.append(index)\\n                unvisited[index] = false\\n            }\\n        }\\n        for i in 0..<c {\\n            equals[arr[i], default: [Int]()].append(i)\\n        }\\n        if c > 1 {\\n            nextQueue.append(0)\\n            unvisited[0] = false\\n        }\\n        while !nextQueue.isEmpty {\\n            let queue = nextQueue\\n            nextQueue = []\\n            result += 1\\n            for index in queue {\\n                if index == c - 2 {\\n                    return result\\n                }\\n                if index < c - 1 {\\n                    appendQueue(index + 1)\\n                }\\n                if index > 0 {\\n                    appendQueue(index - 1)\\n                }\\n                for nextIndex in equals[arr[index], default: [Int]()] {\\n                    if nextIndex == c - 1 {\\n                        return result\\n                    }\\n                    appendQueue(nextIndex)\\n                }\\n                equals[arr[index]] = nil\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minJumps(_ arr: [Int]) -> Int {\\n        let c = arr.count\\n        var equals = [Int: [Int]](), unvisited = [Bool](repeating: true, count: c), nextQueue = [Int](), result = 0\\n        func appendQueue(_ index: Int) {\\n            if unvisited[index] {\\n                nextQueue.append(index)\\n                unvisited[index] = false\\n            }\\n        }\\n        for i in 0..<c {\\n            equals[arr[i], default: [Int]()].append(i)\\n        }\\n        if c > 1 {\\n            nextQueue.append(0)\\n            unvisited[0] = false\\n        }\\n        while !nextQueue.isEmpty {\\n            let queue = nextQueue\\n            nextQueue = []\\n            result += 1\\n            for index in queue {\\n                if index == c - 2 {\\n                    return result\\n                }\\n                if index < c - 1 {\\n                    appendQueue(index + 1)\\n                }\\n                if index > 0 {\\n                    appendQueue(index - 1)\\n                }\\n                for nextIndex in equals[arr[index], default: [Int]()] {\\n                    if nextIndex == c - 1 {\\n                        return result\\n                    }\\n                    appendQueue(nextIndex)\\n                }\\n                equals[arr[index]] = nil\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988847,
                "title": "c-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& a) {\\n        map<int,vector<int>> mp;\\n        \\n        for(int i=0;i<a.size();i++)\\n            mp[a[i]].push_back(i);\\n        \\n        queue<int> q;\\n        q.push(0);\\n        vector<int> used(a.size());\\n        int ans=0;\\n        \\n        while(!q.empty()){\\n            int n=q.size();\\n            while(n--){\\n                int i=q.front();\\n                q.pop();\\n                \\n                if(i==a.size()-1)\\n                    return ans;\\n                \\n                used[i]=1;\\n                //i+1\\n                if(!used[i+1]&&a[i+1]!=a[i])\\n                    used[i+1]=1,q.push(i+1);\\n                //i-1\\n                if(i&&!used[i-1]&&a[i-1]!=a[i])\\n                    used[i-1]=1,q.push(i-1);\\n                //i==x\\n                for(int x : mp[a[i]]){\\n                    if(x^i&&!used[x])\\n                        used[x]=1,q.push(x);\\n                }\\n                mp[a[i]]={};\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minJumps(vector<int>& a) {\\n        map<int,vector<int>> mp;\\n        \\n        for(int i=0;i<a.size();i++)\\n            mp[a[i]].push_back(i);\\n        \\n        queue<int> q;\\n        q.push(0);\\n        vector<int> used(a.size());\\n        int ans=0;\\n        \\n        while(!q.empty()){\\n            int n=q.size();\\n            while(n--){\\n                int i=q.front();\\n                q.pop();\\n                \\n                if(i==a.size()-1)\\n                    return ans;\\n                \\n                used[i]=1;\\n                //i+1\\n                if(!used[i+1]&&a[i+1]!=a[i])\\n                    used[i+1]=1,q.push(i+1);\\n                //i-1\\n                if(i&&!used[i-1]&&a[i-1]!=a[i])\\n                    used[i-1]=1,q.push(i-1);\\n                //i==x\\n                for(int x : mp[a[i]]){\\n                    if(x^i&&!used[x])\\n                        used[x]=1,q.push(x);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 919830,
                "title": "c-bfs-clean-code-with-explanation",
                "content": "We use an unordered_set to check whether the index we have already visited. We use the queue to find the minimum length to get to the end. We use a hash map to restore same number\\'s index into an array. \\n**Notice:** We need to check the same number array from end to start to reduce searching time (closer to the end are always better :)\\n```\\nclass Solution\\n{\\npublic:\\n    int minJumps(vector<int>& arr)\\n    {\\n        if(arr.size() == 1)\\n            return 0;\\n        map<int, vector<int>> mp;\\n        unordered_set<int> vis;\\n        int n = arr.size();\\n        for(int i = 0; i < n; i++)\\n            mp[arr[i]].push_back(i);\\n        int ret = 1;\\n        queue<int> q;\\n        vis.insert(0);\\n        q.push(0);\\n        while(!q.empty())\\n        {\\n            for(int i = q.size(); i >= 1; i--)\\n            {\\n                auto idx = q.front();\\n                q.pop();\\n                for(int j = mp[arr[idx]].size() - 1; j >= 0; j--)\\n                {\\n                    if(mp[arr[idx]][j] == n - 1)\\n                        return ret;\\n                    if(mp[arr[idx]][j] != idx && !vis.count(mp[arr[idx]][j]))\\n                    {\\n                        vis.insert(mp[arr[idx]][j]);\\n                        q.push(mp[arr[idx]][j]);\\n                    }\\n                }\\n                if(idx + 1 == n - 1)\\n                    return ret;\\n                else if(!vis.count(idx + 1))\\n                {\\n                    vis.insert(idx + 1);\\n                    q.push(idx + 1);\\n                }\\n                if(idx - 1 >= 0 && !vis.count(idx - 1))\\n                {\\n                    vis.insert(idx - 1);\\n                    q.push(idx - 1);\\n                }\\n            }\\n            ret++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minJumps(vector<int>& arr)\\n    {\\n        if(arr.size() == 1)\\n            return 0;\\n        map<int, vector<int>> mp;\\n        unordered_set<int> vis;\\n        int n = arr.size();\\n        for(int i = 0; i < n; i++)\\n            mp[arr[i]].push_back(i);\\n        int ret = 1;\\n        queue<int> q;\\n        vis.insert(0);\\n        q.push(0);\\n        while(!q.empty())\\n        {\\n            for(int i = q.size(); i >= 1; i--)\\n            {\\n                auto idx = q.front();\\n                q.pop();\\n                for(int j = mp[arr[idx]].size() - 1; j >= 0; j--)\\n                {\\n                    if(mp[arr[idx]][j] == n - 1)\\n                        return ret;\\n                    if(mp[arr[idx]][j] != idx && !vis.count(mp[arr[idx]][j]))\\n                    {\\n                        vis.insert(mp[arr[idx]][j]);\\n                        q.push(mp[arr[idx]][j]);\\n                    }\\n                }\\n                if(idx + 1 == n - 1)\\n                    return ret;\\n                else if(!vis.count(idx + 1))\\n                {\\n                    vis.insert(idx + 1);\\n                    q.push(idx + 1);\\n                }\\n                if(idx - 1 >= 0 && !vis.count(idx - 1))\\n                {\\n                    vis.insert(idx - 1);\\n                    q.push(idx - 1);\\n                }\\n            }\\n            ret++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657917,
                "title": "java-simple-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        if(arr == null || arr.length<=2) return 0;\\n\\t\\t\\tMap<Integer, List<Integer>> map = new HashMap<>(); //contains values with their index occurences.\\n        for(int i = 0;i<arr.length;i++) {\\n            if(!map.containsKey(arr[i])) {\\n                map.put(arr[i], new ArrayList<>());\\n            }\\n            map.get(arr[i]).add(i);\\n        }\\n        /* start from the first index and add that to the queue.\\n\\t\\t For each index i we pick from queue, see if we can visit i+1, i-1\\n\\t\\t (if we don\\'t go out of bounds and we haven\\'t already visited it yet). We also need to\\n\\t\\t visit all the indexes for which arr[i] == arr[j] and i != j.\\n\\t\\t All these values in array are considered to be on the same level or same distance from i.\\n\\t\\t for next set of indexes increment jump by 1. if at any point we reach arr.length-1 simply return the jumps.\\n\\t\\t*/\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        Set<Integer> visited = new HashSet<>();\\n        int jumps = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for(int i=0;i<size;i++) {\\n                int idx = queue.poll();\\n                visited.add(idx);\\n                if(idx == arr.length-1) {\\n                    return jumps;\\n                }\\n                if(idx+1 <arr.length && !visited.contains(idx+1)) {\\n                    queue.add(idx+1);\\n                }\\n                if(idx-1>=0 && !visited.contains(idx-1)) {\\n                    queue.add(idx-1);\\n                }\\n                if(map.containsKey(arr[idx])) {\\n                    for(int position : map.get(arr[idx])) {\\n                        if(!visited.contains(position)) {\\n                            queue.add(position);\\n                        }\\n                    }\\n                    map.remove(arr[idx]);\\n                }\\n            }\\n            \\n            jumps++;\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        if(arr == null || arr.length<=2) return 0;\\n\\t\\t\\tMap<Integer, List<Integer>> map = new HashMap<>(); //contains values with their index occurences.\\n        for(int i = 0;i<arr.length;i++) {\\n            if(!map.containsKey(arr[i])) {\\n                map.put(arr[i], new ArrayList<>());\\n            }\\n            map.get(arr[i]).add(i);\\n        }\\n        /* start from the first index and add that to the queue.\\n\\t\\t For each index i we pick from queue, see if we can visit i+1, i-1\\n\\t\\t (if we don\\'t go out of bounds and we haven\\'t already visited it yet). We also need to\\n\\t\\t visit all the indexes for which arr[i] == arr[j] and i != j.\\n\\t\\t All these values in array are considered to be on the same level or same distance from i.\\n\\t\\t for next set of indexes increment jump by 1. if at any point we reach arr.length-1 simply return the jumps.\\n\\t\\t*/\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        Set<Integer> visited = new HashSet<>();\\n        int jumps = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for(int i=0;i<size;i++) {\\n                int idx = queue.poll();\\n                visited.add(idx);\\n                if(idx == arr.length-1) {\\n                    return jumps;\\n                }\\n                if(idx+1 <arr.length && !visited.contains(idx+1)) {\\n                    queue.add(idx+1);\\n                }\\n                if(idx-1>=0 && !visited.contains(idx-1)) {\\n                    queue.add(idx-1);\\n                }\\n                if(map.containsKey(arr[idx])) {\\n                    for(int position : map.get(arr[idx])) {\\n                        if(!visited.contains(position)) {\\n                            queue.add(position);\\n                        }\\n                    }\\n                    map.remove(arr[idx]);\\n                }\\n            }\\n            \\n            jumps++;\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633365,
                "title": "c-bfs-approach",
                "content": "//Do bfs\\n//From a particular index, visit all the index possible\\n\\nclass Solution {\\npublic:\\n\\n    int minJumps(vector<int>& arr) {\\n     if(arr.size()<=1) return 0;\\n     vector<int>distance(arr.size(),INT_MAX);\\n     distance[0]=0;\\n     unordered_map<int,vector<int>>mp;\\n     for(int i=0;i<arr.size();i++)\\n         mp[arr[i]].push_back(i);\\n     queue<int>q;\\n     q.push(0);\\n     while(!q.empty())\\n     {\\n         int f=q.front();\\n         q.pop();\\n         \\n         for(int dest:mp[arr[f]])\\n         {\\n             if(distance[dest]==INT_MAX) q.push(dest); //Visit neighbour if not visited\\n             distance[dest]=min(distance[dest],distance[f]+1); //Update smallest distance\\n         }\\n         if(f-1>=0)\\n         {\\n            if(distance[f-1]==INT_MAX) q.push(f-1);//Not visited\\n            distance[f-1]=min(distance[f-1],distance[f]+1);\\n         }\\n         if(f+1<arr.size())\\n         {\\n            if(distance[f+1]==INT_MAX) q.push(f+1);\\n            distance[f+1]=min(distance[f+1],distance[f]+1);\\n         }\\n         mp.erase(arr[f]);//Without this TLE //Erase all the similar elements //Because it will then search for it again \\n     }\\n    return distance[arr.size()-1];\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int minJumps(vector<int>& arr) {\\n     if(arr.size()<=1) return 0;\\n     vector<int>distance(arr.size(),INT_MAX);\\n     distance[0]=0;\\n     unordered_map<int,vector<int>>mp;\\n     for(int i=0;i<arr.size();i++)\\n         mp[arr[i]].push_back(i);\\n     queue<int>q;\\n     q.push(0);\\n     while(!q.empty())\\n     {\\n         int f=q.front();\\n         q.pop();\\n         \\n         for(int dest:mp[arr[f]])\\n         {\\n             if(distance[dest]==INT_MAX) q.push(dest); //Visit neighbour if not visited\\n             distance[dest]=min(distance[dest],distance[f]+1); //Update smallest distance\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 3606451,
                "title": "c-clean-bfs-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int,vector<int>> mp;\\n\\n        for(int i=0; i<n; i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n\\n        int visited[100000] = {0};\\n        queue<int> q;\\n        q.push(0);\\n        visited[0] = 1;\\n\\n        int steps = 0;\\n\\n        while(!q.empty()){\\n            int cap = q.size();\\n\\n            while(cap--){\\n                int curr = q.front();\\n                q.pop();\\n\\n                if(curr == n-1) return steps;\\n\\n                int left = curr - 1;\\n                int right = curr + 1;\\n\\n                if(left >= 0 && !visited[left]){\\n                    q.push(left);\\n                    visited[left] = 1;\\n                }\\n\\n                if(right <= n-1 && !visited[right]){\\n                    q.push(right);\\n                    visited[right] = 1;\\n                }\\n                int ele = arr[curr];\\n                for(int idx : mp[ele]){\\n                    if(!visited[idx]){\\n                        visited[idx] = 1;\\n                        q.push(idx);\\n                    }\\n                }\\n\\n                mp[ele].clear();\\n            }\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int,vector<int>> mp;\\n\\n        for(int i=0; i<n; i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n\\n        int visited[100000] = {0};\\n        queue<int> q;\\n        q.push(0);\\n        visited[0] = 1;\\n\\n        int steps = 0;\\n\\n        while(!q.empty()){\\n            int cap = q.size();\\n\\n            while(cap--){\\n                int curr = q.front();\\n                q.pop();\\n\\n                if(curr == n-1) return steps;\\n\\n                int left = curr - 1;\\n                int right = curr + 1;\\n\\n                if(left >= 0 && !visited[left]){\\n                    q.push(left);\\n                    visited[left] = 1;\\n                }\\n\\n                if(right <= n-1 && !visited[right]){\\n                    q.push(right);\\n                    visited[right] = 1;\\n                }\\n                int ele = arr[curr];\\n                for(int idx : mp[ele]){\\n                    if(!visited[idx]){\\n                        visited[idx] = 1;\\n                        q.push(idx);\\n                    }\\n                }\\n\\n                mp[ele].clear();\\n            }\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261819,
                "title": "kotlin-java-optimized-bfs-approach-explained",
                "content": "# Approach\\nIt is pretty intuitive to treat array items as nodes and the possible paths between them as edges in a graph.\\n\\nSimplest approach to find a shortest path between two nodes is to do a BFS search from start and stop when target node is encountered.\\n\\nThis solution sadly gives a TLE and we must optimize.\\n\\nThe trick is to not repeat already traversed paths. The biggest problem seem to be running through the \"same value\" paths multiple times. \\nIf we traversed all neighbors of node of some value, we don\\'t want to iterate this array again, because we\\'ll find out that every one of them is already visited. Simplest way to prevent this is to remove the value key after first visit.\\nThis optimizes greatly for that evil testcase, when there is a very large array where all nodes but last have same value.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - every node is visited once\\n\\n- Space complexity:\\n$$O(n)$$ - can be maximally allocated either in queue or visited array\\n\\n```kotlin []\\nclass Solution {\\n    fun minJumps(arr: IntArray): Int {\\n        val q: Queue<Int> = LinkedList()\\n        val visited = hashSetOf<Int>()\\n\\n        q.add(0)\\n        visited.add(0)\\n        val nodesByValue = hashMapOf<Int, ArrayList<Int>>()\\n\\n        for (i in arr.indices) {\\n            nodesByValue.computeIfAbsent(arr[i]) { arrayListOf() }.add(i)\\n        }\\n\\n        var dist = 0\\n\\n        while (q.isNotEmpty()) {\\n            val size = q.size\\n\\n            for (i in 0 until size) {\\n                val curr = q.poll()\\n                if (curr == arr.size-1) return dist\\n                for (node in nodesByValue[arr[curr]] ?: arrayListOf()) {\\n                    if (visited.contains(node)) continue\\n                    if (node == arr.size-1) return dist+1\\n                    visited.add(node)\\n                    q.add(node)\\n                }\\n\\n                nodesByValue.remove(arr[curr])\\n\\n                if (curr-1 >= 0 && !visited.contains(curr-1)) {\\n                    q.add(curr-1)\\n                    visited.add(curr-1)\\n                }\\n\\n                if (curr+1 < arr.size && !visited.contains(curr+1)) {\\n                    if (curr+1 == arr.size-1) return dist+1\\n                    q.add(curr+1)\\n                    visited.add(curr+1)\\n                }\\n            }\\n\\n            dist++\\n        }\\n\\n        return dist\\n    }\\n}\\n```\\n```java []\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        Map<Integer, List<Integer>> nodesByValue = new HashMap<>();\\n        \\n        for (int i=0; i < n; i++) {\\n            nodesByValue.computeIfAbsent(arr[i], (key) -> new ArrayList<Integer>()).add(i);\\n        }\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n        int dist = 0;\\n\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = q.poll();\\n                if (curr == n-1) return dist;\\n\\n                for (int node: nodesByValue.getOrDefault(arr[curr], new ArrayList<>())) {\\n                    if (node == n-1) return dist+1;\\n                    if (visited.contains(node)) continue;\\n                    visited.add(node);\\n                    q.add(node);\\n                }\\n\\n                nodesByValue.remove(arr[curr]);\\n\\n                if (curr-1 >= 0 && !visited.contains(curr-1)) {\\n                    visited.add(curr-1);\\n                    q.add(curr-1);\\n                }\\n\\n                if (curr+1 < n && !visited.contains(curr+1)) {\\n                    if (curr+1 == n-1) return dist+1;\\n                    visited.add(curr+1);\\n                    q.add(curr+1);\\n                }\\n            }\\n\\n            dist++;\\n        }\\n\\n        return dist;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Breadth-First Search"
                ],
                "code": "```kotlin []\\nclass Solution {\\n    fun minJumps(arr: IntArray): Int {\\n        val q: Queue<Int> = LinkedList()\\n        val visited = hashSetOf<Int>()\\n\\n        q.add(0)\\n        visited.add(0)\\n        val nodesByValue = hashMapOf<Int, ArrayList<Int>>()\\n\\n        for (i in arr.indices) {\\n            nodesByValue.computeIfAbsent(arr[i]) { arrayListOf() }.add(i)\\n        }\\n\\n        var dist = 0\\n\\n        while (q.isNotEmpty()) {\\n            val size = q.size\\n\\n            for (i in 0 until size) {\\n                val curr = q.poll()\\n                if (curr == arr.size-1) return dist\\n                for (node in nodesByValue[arr[curr]] ?: arrayListOf()) {\\n                    if (visited.contains(node)) continue\\n                    if (node == arr.size-1) return dist+1\\n                    visited.add(node)\\n                    q.add(node)\\n                }\\n\\n                nodesByValue.remove(arr[curr])\\n\\n                if (curr-1 >= 0 && !visited.contains(curr-1)) {\\n                    q.add(curr-1)\\n                    visited.add(curr-1)\\n                }\\n\\n                if (curr+1 < arr.size && !visited.contains(curr+1)) {\\n                    if (curr+1 == arr.size-1) return dist+1\\n                    q.add(curr+1)\\n                    visited.add(curr+1)\\n                }\\n            }\\n\\n            dist++\\n        }\\n\\n        return dist\\n    }\\n}\\n```\n```java []\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        Map<Integer, List<Integer>> nodesByValue = new HashMap<>();\\n        \\n        for (int i=0; i < n; i++) {\\n            nodesByValue.computeIfAbsent(arr[i], (key) -> new ArrayList<Integer>()).add(i);\\n        }\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n        int dist = 0;\\n\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = q.poll();\\n                if (curr == n-1) return dist;\\n\\n                for (int node: nodesByValue.getOrDefault(arr[curr], new ArrayList<>())) {\\n                    if (node == n-1) return dist+1;\\n                    if (visited.contains(node)) continue;\\n                    visited.add(node);\\n                    q.add(node);\\n                }\\n\\n                nodesByValue.remove(arr[curr]);\\n\\n                if (curr-1 >= 0 && !visited.contains(curr-1)) {\\n                    visited.add(curr-1);\\n                    q.add(curr-1);\\n                }\\n\\n                if (curr+1 < n && !visited.contains(curr+1)) {\\n                    if (curr+1 == n-1) return dist+1;\\n                    visited.add(curr+1);\\n                    q.add(curr+1);\\n                }\\n            }\\n\\n            dist++;\\n        }\\n\\n        return dist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261815,
                "title": "treat-indexes-as-nodes-and-given-rules-as-edges",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& a) {\\n        \\n        unordered_map<int , vector<int>> mp;\\n        int n  = a.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[a[i]].push_back(i);\\n        }\\n        queue<int> q;\\n        q.push(0);\\n        vector<bool> vis(n,false);\\n        vis[0] = true;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                int ind = q.front();\\n                if(ind==n-1) return ans;\\n                int val = a[ind];\\n                q.pop();\\n                vector<int> v = mp[val];\\n                vis[ind] = true;\\n                v.push_back(ind+1);\\n                v.push_back(ind-1);\\n                for(auto i : v)\\n                {\\n                    if(i>=n || i<0 || vis[i]) continue;\\n                    q.push(i);\\n                }\\n                mp[val].clear();\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& a) {\\n        \\n        unordered_map<int , vector<int>> mp;\\n        int n  = a.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[a[i]].push_back(i);\\n        }\\n        queue<int> q;\\n        q.push(0);\\n        vector<bool> vis(n,false);\\n        vis[0] = true;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                int ind = q.front();\\n                if(ind==n-1) return ans;\\n                int val = a[ind];\\n                q.pop();\\n                vector<int> v = mp[val];\\n                vis[ind] = true;\\n                v.push_back(ind+1);\\n                v.push_back(ind-1);\\n                for(auto i : v)\\n                {\\n                    if(i>=n || i<0 || vis[i]) continue;\\n                    q.push(i);\\n                }\\n                mp[val].clear();\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261617,
                "title": "solution-swift-bfs-beats-100",
                "content": "**TC:** O(n)\\n**SC:** O(n)\\n```\\nclass Solution {\\n    func minJumps(_ arr: [Int]) -> Int {\\n        var steps = 0\\n        var queue = Set<Int>()\\n        var visited = Set<Int>()\\n\\n        var map = [Int: [Int]]()\\n        for i in 0..<arr.count {\\n            map[arr[i], default: [Int]()].append(i)\\n        }\\n\\n        queue.insert(0)\\n        visited.insert(0)\\n\\n        while !queue.isEmpty {\\n            var next = Set<Int>()\\n            while !queue.isEmpty {\\n                let node = queue.popFirst()!\\n                if node == arr.count - 1 {\\n                    return steps\\n                }\\n\\n                visited.insert(node)\\n                if node - 1 >= 0, !visited.contains(node - 1) {\\n                    next.insert(node - 1)\\n                    visited.insert(node - 1)\\n                }\\n                if node + 1 < arr.count, !visited.contains(node + 1) {\\n                    next.insert(node + 1)\\n                    visited.insert(node + 1)\\n                }\\n                for element in (map[arr[node]] ?? []) {\\n                    if !visited.contains(element) {\\n                        next.insert(element)\\n                        visited.insert(element)\\n                    }\\n                }\\n                // Key step to avoid TLE\\n                // We don\\'t need to get back to the indecies where we were\\n                map[arr[node]] = nil\\n            }\\n            queue = next\\n            steps += 1\\n        }\\n\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func minJumps(_ arr: [Int]) -> Int {\\n        var steps = 0\\n        var queue = Set<Int>()\\n        var visited = Set<Int>()\\n\\n        var map = [Int: [Int]]()\\n        for i in 0..<arr.count {\\n            map[arr[i], default: [Int]()].append(i)\\n        }\\n\\n        queue.insert(0)\\n        visited.insert(0)\\n\\n        while !queue.isEmpty {\\n            var next = Set<Int>()\\n            while !queue.isEmpty {\\n                let node = queue.popFirst()!\\n                if node == arr.count - 1 {\\n                    return steps\\n                }\\n\\n                visited.insert(node)\\n                if node - 1 >= 0, !visited.contains(node - 1) {\\n                    next.insert(node - 1)\\n                    visited.insert(node - 1)\\n                }\\n                if node + 1 < arr.count, !visited.contains(node + 1) {\\n                    next.insert(node + 1)\\n                    visited.insert(node + 1)\\n                }\\n                for element in (map[arr[node]] ?? []) {\\n                    if !visited.contains(element) {\\n                        next.insert(element)\\n                        visited.insert(element)\\n                    }\\n                }\\n                // Key step to avoid TLE\\n                // We don\\'t need to get back to the indecies where we were\\n                map[arr[node]] = nil\\n            }\\n            queue = next\\n            steps += 1\\n        }\\n\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261565,
                "title": "c-bfs-iv",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n =arr.size();\\n        unordered_map<int,vector<int>>indexmap; // store every element index value in vector form\\n        for(int i=0;i<n;i++){\\n        indexmap[arr[i]].push_back(i); // 100-> [0,4] and so on\\n        }\\n        // simple bfs things\\n        vector<bool>vis(n); \\n        \\n        vis[0]=true;\\n        queue<int>q;\\n        q.push(0);\\n        int steps=0;\\n        \\n        while(!q.empty()){\\n            // traversing the developed graph by bfs\\n            for(int i=q.size();i>0;i--){\\n            int node =q.front();\\n            q.pop();\\n                \\n            if(node==n-1) \\n                return steps; // reached last index\\n            vector<int>&next =indexmap[arr[node]]; // ek node pe pahuch ke usse aage kha ja sakte bi btayega ye\\n            next.push_back(node-1);\\n            next.push_back(node+1);\\n                \\n            for(auto it : next){ \\n                if(it>=0&&it<n&&!vis[it]){ // all condition\\n                        vis[it]=true;\\n                        q.push(it);\\n                }\\n            }\\n                indexmap[arr[node]].clear(); //ye map pe index di gai value ko hta dega jisse                                             //dubara na traver kar de\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n};\\n    \\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n =arr.size();\\n        unordered_map<int,vector<int>>indexmap; // store every element index value in vector form\\n        for(int i=0;i<n;i++){\\n        indexmap[arr[i]].push_back(i); // 100-> [0,4] and so on\\n        }\\n        // simple bfs things\\n        vector<bool>vis(n); \\n        \\n        vis[0]=true;\\n        queue<int>q;\\n        q.push(0);\\n        int steps=0;\\n        \\n        while(!q.empty()){\\n            // traversing the developed graph by bfs\\n            for(int i=q.size();i>0;i--){\\n            int node =q.front();\\n            q.pop();\\n                \\n            if(node==n-1) \\n                return steps; // reached last index\\n            vector<int>&next =indexmap[arr[node]]; // ek node pe pahuch ke usse aage kha ja sakte bi btayega ye\\n            next.push_back(node-1);\\n            next.push_back(node+1);\\n                \\n            for(auto it : next){ \\n                if(it>=0&&it<n&&!vis[it]){ // all condition\\n                        vis[it]=true;\\n                        q.push(it);\\n                }\\n            }\\n                indexmap[arr[node]].clear(); //ye map pe index di gai value ko hta dega jisse                                             //dubara na traver kar de\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261216,
                "title": "you-will-understand",
                "content": "\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\nI tried to figure it out and found obiously it is a good graph problem hell we can think hours for it solution and can figure out others but best go for simple graph and BFS approach that make life easier for now. \\n\\n- So lets take my first appraoch what i did first form the adj list mostly that we form but here we have some conditions.\\n- Okay what are those conditions lets see-\\n```\\nIn one step you can jump from index i to index:\\ni + 1 where: i + 1 < arr.length.\\ni - 1 where: i - 1 >= 0.\\nj where: arr[i] == arr[j] and i != j.\\n```\\n- Point is here we can only go for same or for ```current-1``` or ```current+1``` thats all. \\n- Okay so how we gonna make our adj list for nodes \\n- No worry about it only we gonna make duplicates one storing all index for same elements [] and thats all at first stage \\n- wait but haven\\'t condition says that we can go for ```curr+1``` or ```curr-1``` \\n- yeah it says while doing BFS we will also take care of both condions so no worry. \\n\\n## Here is My first solultion \\uD83D\\uDC47(SImple BFS )\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if(n<=1){\\n            return 0;\\n        }\\n        HashMap<Integer, List<Integer>> hm = new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            hm.computeIfAbsent(arr[i], v->new LinkedList<>()).add(i);\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        int step = 0;\\n        Set<Integer> vis = new HashSet<>();\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                int item = q.poll();\\n                vis.add(item);\\n                if(item==n-1){\\n                    return step;\\n                }\\n                // check for same values \\n                for(int child: hm.get(arr[item])){\\n                    if(!vis.contains(child)){\\n                        q.offer(child);\\n                    }\\n                }\\n                // check sides \\n                if(item+1<n && !vis.contains(item+1)){\\n                    q.offer(item+1);\\n                }\\n                if(item-1>=0 && !vis.contains(item-1)){\\n                    q.offer(item-1);\\n                }\\n            }\\n            step++;\\n        }\\n        return step;\\n    }\\n}\\n```\\n- Here solution is good and correct the problem causing it is TLE \\n- lets take look what we are doing here \\n- a simple ```var steps``` that we increasing after all bfs of each step traversal. the point is it is like shortest way from node we can reach \\n- when we reached out we will return number of ```steps``` that we took. \\n\\nWell It is also an O(n) solution so why it is causing TLE problem \\n- right the simple reason for it is ```redundant search``` or you can say checks \\n\\n### okay then how we gonna make it more optimized \\n- No problem by simple analysis the whole point is ```node+1``` or ```node-1``` it matters and ```duplicate``` matters but here we only have to take look when it reached out ```n-1``` last index thats the point \\n- so by considering it you can already make it vis at once \\n- and also clear the list of duplicates to ```prevent redundant search``` thats all optimization it will takes \\n\\n## Solution is given \\uD83D\\uDC47\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if(n<=1){\\n            return 0;\\n        }\\n        HashMap<Integer, List<Integer>> hm = new HashMap<>();\\n\\n        for(int i=0; i<n; i++){\\n            hm.computeIfAbsent(arr[i], v->new LinkedList<>()).add(i);\\n        }\\n        List<Integer> cur = new LinkedList<>();\\n        cur.add(0);\\n        Set<Integer> vis = new HashSet<>();\\n        int step = 0;\\n        // so currently we have node 0 \\n        // our map is ready with same values \\n        // and in our bfs we also have to include node-1 and node+1\\n        while(!cur.isEmpty()){\\n            List<Integer> p = new LinkedList<>();\\n            for(int node:cur){\\n                if(node==n-1){\\n                    return step;\\n                }\\n                // this will chek for same values \\n                for(int child:hm.get(arr[node])){\\n                    if(!vis.contains(child)){\\n                        vis.add(child);\\n                        p.add(child);\\n                    }\\n                }\\n                hm.get(arr[node]).clear();\\n                // checking for sides +1 and -1\\n                if(node+1<n && !vis.contains(node+1)){\\n                    vis.add(node+1);\\n                    p.add(node+1);\\n                }\\n                if(node-1>=0 && !vis.contains(node-1)){\\n                    vis.add(node-1);\\n                    p.add(node-1);\\n                }\\n            }\\n            cur = p;\\n            step++;\\n        }\\n        return step;\\n    }\\n}\\n```\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nIn one step you can jump from index i to index:\\ni + 1 where: i + 1 < arr.length.\\ni - 1 where: i - 1 >= 0.\\nj where: arr[i] == arr[j] and i != j.\\n```\n```current-1```\n```current+1```\n```curr+1```\n```curr-1```\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if(n<=1){\\n            return 0;\\n        }\\n        HashMap<Integer, List<Integer>> hm = new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            hm.computeIfAbsent(arr[i], v->new LinkedList<>()).add(i);\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        int step = 0;\\n        Set<Integer> vis = new HashSet<>();\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                int item = q.poll();\\n                vis.add(item);\\n                if(item==n-1){\\n                    return step;\\n                }\\n                // check for same values \\n                for(int child: hm.get(arr[item])){\\n                    if(!vis.contains(child)){\\n                        q.offer(child);\\n                    }\\n                }\\n                // check sides \\n                if(item+1<n && !vis.contains(item+1)){\\n                    q.offer(item+1);\\n                }\\n                if(item-1>=0 && !vis.contains(item-1)){\\n                    q.offer(item-1);\\n                }\\n            }\\n            step++;\\n        }\\n        return step;\\n    }\\n}\\n```\n```var steps```\n```steps```\n```redundant search```\n```node+1```\n```node-1```\n```duplicate```\n```n-1```\n```prevent redundant search```\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if(n<=1){\\n            return 0;\\n        }\\n        HashMap<Integer, List<Integer>> hm = new HashMap<>();\\n\\n        for(int i=0; i<n; i++){\\n            hm.computeIfAbsent(arr[i], v->new LinkedList<>()).add(i);\\n        }\\n        List<Integer> cur = new LinkedList<>();\\n        cur.add(0);\\n        Set<Integer> vis = new HashSet<>();\\n        int step = 0;\\n        // so currently we have node 0 \\n        // our map is ready with same values \\n        // and in our bfs we also have to include node-1 and node+1\\n        while(!cur.isEmpty()){\\n            List<Integer> p = new LinkedList<>();\\n            for(int node:cur){\\n                if(node==n-1){\\n                    return step;\\n                }\\n                // this will chek for same values \\n                for(int child:hm.get(arr[node])){\\n                    if(!vis.contains(child)){\\n                        vis.add(child);\\n                        p.add(child);\\n                    }\\n                }\\n                hm.get(arr[node]).clear();\\n                // checking for sides +1 and -1\\n                if(node+1<n && !vis.contains(node+1)){\\n                    vis.add(node+1);\\n                    p.add(node+1);\\n                }\\n                if(node-1>=0 && !vis.contains(node-1)){\\n                    vis.add(node-1);\\n                    p.add(node-1);\\n                }\\n            }\\n            cur = p;\\n            step++;\\n        }\\n        return step;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260992,
                "title": "c-fully-optimised-explained-solution-using-bfs",
                "content": "# Intuition\\nTo solve this problem, we can use BFS (breadth-first search) algorithm. We will start from the first index of the array and visit all possible positions that we can jump to in one step. For each position, we will calculate the number of steps required to reach that position and add it to a queue. We will continue this process until we reach the last index of the array. At each step, we will also keep track of the indices that have been visited to avoid revisiting them.\\n\\n# Approach\\nIn this code, we first create a map indices that maps each integer value in the array to the indices where it occurs. This will allow us to efficiently find the indices that have the same value as the current index. We also create a visited array to keep track of the indices that have been visited.\\n\\nWe then add the first index (i.e., index 0) to the queue and start the BFS process. At each step, we dequeue an index from the queue and try to visit all possible positions that can be reached in one step. We add the new positions to the queue if they have not been visited before. If we reach the last index of the array, we return the number of steps required to reach it. If we cannot reach the last index, we return -1.\\n\\nNote that we use a while loop inside the main while loop to handle all the indices at the current level before moving to the next level. This ensures that we count the minimum number of steps required to reach the last index.\\n\\n# Complexity\\n- Time complexity:\\nO(N + klogk), where N is the length of the input array and k is the number of distinct values in the array.\\n\\n- Space complexity:\\nO(N + k), where N is the length of the input array and k is the number of distinct values in the array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> indices;\\n        for (int i = 0; i < n; i++) {\\n            indices[arr[i]].push_back(i);\\n        }\\n        vector<bool> visited(n);\\n        visited[0] = true;\\n        queue<int> q;\\n        q.push(0);\\n        int steps = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            while (size--) {\\n                int i = q.front();\\n                q.pop();\\n                if (i == n - 1) {\\n                    return steps;\\n                }\\n                if (i + 1 < n && !visited[i + 1]) {\\n                    visited[i + 1] = true;\\n                    q.push(i + 1);\\n                }\\n                if (i - 1 >= 0 && !visited[i - 1]) {\\n                    visited[i - 1] = true;\\n                    q.push(i - 1);\\n                }\\n                for (int j : indices[arr[i]]) {\\n                    if (!visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                indices[arr[i]].clear(); // optimization: avoid revisiting indices\\n            }\\n            steps++;\\n        }\\n        return -1; // the last index cannot be reached\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> indices;\\n        for (int i = 0; i < n; i++) {\\n            indices[arr[i]].push_back(i);\\n        }\\n        vector<bool> visited(n);\\n        visited[0] = true;\\n        queue<int> q;\\n        q.push(0);\\n        int steps = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            while (size--) {\\n                int i = q.front();\\n                q.pop();\\n                if (i == n - 1) {\\n                    return steps;\\n                }\\n                if (i + 1 < n && !visited[i + 1]) {\\n                    visited[i + 1] = true;\\n                    q.push(i + 1);\\n                }\\n                if (i - 1 >= 0 && !visited[i - 1]) {\\n                    visited[i - 1] = true;\\n                    q.push(i - 1);\\n                }\\n                for (int j : indices[arr[i]]) {\\n                    if (!visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                indices[arr[i]].clear(); // optimization: avoid revisiting indices\\n            }\\n            steps++;\\n        }\\n        return -1; // the last index cannot be reached\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260869,
                "title": "bfs-using-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n\\n        # set pos[x][0] = True as unvisited indicator\\n        pos = collections.defaultdict(lambda: [True])\\n\\n        # Store positions i based on value x=arr[i]\\n        # reverse is essential as we are finding shortest path backward\\n        for i, x in reversed(list(enumerate(arr))):\\n            pos[x].append(i)\\n\\n        # res = result table, q = BFS queue\\n        n = len(arr)\\n        res = list(range(n-1, -1, -1))\\n        q = collections.deque()\\n\\n        # start the search backward\\n        for k in range(n-1, -1, -1):\\n            q.append(k)\\n            while q:\\n                i = q.popleft()\\n                if pos[arr[i]][0]: # if unvisited\\n                    pos[arr[i]][0] = False\\n\\n                    # create jump portal for all positions with same value\\n                    for j in pos[arr[i]][1:]:\\n                        res[j] = min(res[j], res[i]+1)\\n                        q.append(j)\\n\\n                    # add adjcent posisitons to queue\\n                    for j in pos[arr[i]][1:]:\\n                        if j > 0:\\n                            res[j-1] = min(res[j-1], res[j]+1)\\n                            q.append(j-1)\\n                        if j < n-1:\\n                            res[j+1] = min(res[j+1], res[j]+1)\\n                            q.append(j+1)\\n        return res[0]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n\\n        # set pos[x][0] = True as unvisited indicator\\n        pos = collections.defaultdict(lambda: [True])\\n\\n        # Store positions i based on value x=arr[i]\\n        # reverse is essential as we are finding shortest path backward\\n        for i, x in reversed(list(enumerate(arr))):\\n            pos[x].append(i)\\n\\n        # res = result table, q = BFS queue\\n        n = len(arr)\\n        res = list(range(n-1, -1, -1))\\n        q = collections.deque()\\n\\n        # start the search backward\\n        for k in range(n-1, -1, -1):\\n            q.append(k)\\n            while q:\\n                i = q.popleft()\\n                if pos[arr[i]][0]: # if unvisited\\n                    pos[arr[i]][0] = False\\n\\n                    # create jump portal for all positions with same value\\n                    for j in pos[arr[i]][1:]:\\n                        res[j] = min(res[j], res[i]+1)\\n                        q.append(j)\\n\\n                    # add adjcent posisitons to queue\\n                    for j in pos[arr[i]][1:]:\\n                        if j > 0:\\n                            res[j-1] = min(res[j-1], res[j]+1)\\n                            q.append(j-1)\\n                        if j < n-1:\\n                            res[j+1] = min(res[j+1], res[j]+1)\\n                            q.append(j+1)\\n        return res[0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260690,
                "title": "efficiently-solving-the-jump-game-iv-problem-with-python-s-breadth-first-search-algorithm",
                "content": "\\n## 1.  Problem Statement:\\n\\nImagine you\\'re standing on a number line that has a bunch of numbers on it. Each number represents a place you can jump to. You start at the first number, which is called the origin, and you want to jump to the last number, which is called the destination. But there\\'s a catch! Some of the numbers on the number line are the same, and if you land on one of those numbers, you can jump to any other place that has the same number.\\n\\nThe problem is that you want to get to the destination in the fewest possible jumps. Can you figure out how many jumps it will take to get from the origin to the destination?\\n\\n## 2.  Methodology:\\n\\nThe solution to this problem uses a Breadth-First Search (BFS) algorithm to find the shortest path from the origin to the destination. In order to implement the BFS algorithm, we use a queue to keep track of the indices that we need to visit, and we use a distance array to keep track of the minimum number of jumps it takes to get to each index.\\n\\nWe start by creating a dictionary that maps each number in the array to a list of indices where that number appears. Then we add the origin to the queue and set its distance to 0. We then loop through the queue, visiting each index in the queue and adding its neighbors to the queue if they haven\\'t been visited yet. We also keep track of the minimum distance it takes to get to each index.\\n\\nIf we reach the destination index while visiting the indices in the queue, we return the distance to the destination. If we\\'ve visited all the indices in the queue and still haven\\'t reached the destination, it means we can\\'t get to the destination, so we return -1.\\n\\n## 3.  Time and Space Complexity:\\n\\nThe time complexity of this algorithm is $$O(n)$$, where n is the length of the input array. This is because we visit each index in the array exactly once.\\n\\nThe space complexity of this algorithm is $$O(n)$$, where n is the length of the input array. This is because we use a queue and a distance array to keep track of the indices we need to visit and their minimum distances from the origin.\\n\\n## 4.  Explanation of the Code:\\n\\nThe code starts by importing the deque function from the collections module. We then define a class called Solution and a method called minJumps that takes an array of integers called arr as input and returns an integer.\\n\\nThe first few lines of the method are used to handle some special cases. If the length of the array is 1, we return 0 since we don\\'t need to make any jumps to get to the destination. We then create a dictionary called indices that maps each number in the array to a list of indices where that number appears.\\n\\nWe then use a deque called queue to keep track of the indices we need to visit. We add the origin index (which is 0) to the queue and create a distance array of size n (where n is the length of the input array). We set all the elements in the distance array to infinity except for the first element, which we set to 0 since the distance from the origin to the origin is 0.\\n\\nWe then start the BFS algorithm by looping through the indices in the queue. We pop the first index from the queue and get its distance from the origin. We check if we\\'ve reached the destination index, and if we have, we return the distance to the destination.\\n\\nWe then add the indices that have the same value as the current index to the queue. We also update their distances in the distance array if their current distances are infinity (meaning they haven\\'t been visited yet).\\n\\nWe then clear the queue, since we don\\'t need to visit the current index again, and move on to the next index in the queue. We continue this process until we reach the destination index or we\\'ve visited all the indices in the queue.\\n\\nIf we\\'ve visited all the indices in the queue and still haven\\'t reached the destination, it means we can\\'t get to the destination, so we return -1.\\n\\n## 5.  Summary:\\n\\nTo summarize, the problem asks us to find the minimum number of jumps it takes to get from the origin to the destination on a number line with some repeating numbers. We solve this problem by using a BFS algorithm that keeps track of the minimum distance it takes to get to each index. We create a dictionary that maps each number in the array to a list of indices where that number appears, and we use a queue to keep track of the indices we need to visit. We start the BFS algorithm by visiting the origin index and adding its neighbors to the queue. We update the distances in the distance array as we visit each index, and we return the distance to the destination index if we reach it. If we\\'ve visited all the indices in the queue and still haven\\'t reached the destination, we return -1. The time complexity of this algorithm is O(n), and the space complexity is also O(n).\\n\\n# Code\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        # Get the length of the array and check if there is only one element in the array. If there is only one element, no jumps are needed, so return 0\\n        n = len(arr)\\n        if n == 1:\\n            return 0\\n        \\n        # Create a dictionary to store the indices of each value in the array\\n        indices = {}\\n        for i, val in enumerate(arr):\\n            if val not in indices:\\n                indices[val] = []\\n            indices[val].append(i)\\n        \\n        # Use BFS to traverse the array and find the minimum number of jumps required to reach the end\\n        # Create a queue using the deque function and add the first index of the array to the queue\\n        queue = deque()\\n        queue.append(0)\\n        # Create a distance array of size n and set all the elements to infinity, except for the first element which should be set to 0\\n        distance = [float(\\'inf\\')] * n\\n        distance[0] = 0\\n        \\n        # Start the BFS algorithm by visiting each index in the queue\\n        while queue:\\n            # Pop the first index from the queue and get its distance from the start\\n            curr_index = queue.popleft()\\n            curr_distance = distance[curr_index]\\n            \\n            # Check if we have reached the end of the array. If we have, return the current distance\\n            if curr_index == n-1:\\n                return curr_distance\\n            \\n            # Add the indices that have the same value as the current index to the queue\\n            for next_index in indices[arr[curr_index]]:\\n                if next_index != curr_index and distance[next_index] == float(\\'inf\\'):\\n                    distance[next_index] = curr_distance + 1\\n                    queue.append(next_index)\\n            \\n            # Clear the dictionary entry for the current index to avoid revisiting it\\n            indices[arr[curr_index]] = []\\n            \\n            # Add the adjacent indices to the queue if they haven\\'t been visited yet\\n            if curr_index > 0 and distance[curr_index-1] == float(\\'inf\\'):\\n                distance[curr_index-1] = curr_distance + 1\\n                queue.append(curr_index-1)\\n            if curr_index < n-1 and distance[curr_index+1] == float(\\'inf\\'):\\n                distance[curr_index+1] = curr_distance + 1\\n                queue.append(curr_index+1)\\n        \\n        # If we cannot reach the end of the array, return -1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        # Get the length of the array and check if there is only one element in the array. If there is only one element, no jumps are needed, so return 0\\n        n = len(arr)\\n        if n == 1:\\n            return 0\\n        \\n        # Create a dictionary to store the indices of each value in the array\\n        indices = {}\\n        for i, val in enumerate(arr):\\n            if val not in indices:\\n                indices[val] = []\\n            indices[val].append(i)\\n        \\n        # Use BFS to traverse the array and find the minimum number of jumps required to reach the end\\n        # Create a queue using the deque function and add the first index of the array to the queue\\n        queue = deque()\\n        queue.append(0)\\n        # Create a distance array of size n and set all the elements to infinity, except for the first element which should be set to 0\\n        distance = [float(\\'inf\\')] * n\\n        distance[0] = 0\\n        \\n        # Start the BFS algorithm by visiting each index in the queue\\n        while queue:\\n            # Pop the first index from the queue and get its distance from the start\\n            curr_index = queue.popleft()\\n            curr_distance = distance[curr_index]\\n            \\n            # Check if we have reached the end of the array. If we have, return the current distance\\n            if curr_index == n-1:\\n                return curr_distance\\n            \\n            # Add the indices that have the same value as the current index to the queue\\n            for next_index in indices[arr[curr_index]]:\\n                if next_index != curr_index and distance[next_index] == float(\\'inf\\'):\\n                    distance[next_index] = curr_distance + 1\\n                    queue.append(next_index)\\n            \\n            # Clear the dictionary entry for the current index to avoid revisiting it\\n            indices[arr[curr_index]] = []\\n            \\n            # Add the adjacent indices to the queue if they haven\\'t been visited yet\\n            if curr_index > 0 and distance[curr_index-1] == float(\\'inf\\'):\\n                distance[curr_index-1] = curr_distance + 1\\n                queue.append(curr_index-1)\\n            if curr_index < n-1 and distance[curr_index+1] == float(\\'inf\\'):\\n                distance[curr_index+1] = curr_distance + 1\\n                queue.append(curr_index+1)\\n        \\n        # If we cannot reach the end of the array, return -1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260573,
                "title": "c-hard-problem-made-easy",
                "content": "```\\ntypedef pair<int,pair<int,int>> pi;\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        queue<pi> q;\\n        q.push({arr[0],{0,0}});\\n        vector<int> vis(n,0);\\n        vis[0]=1;\\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int ind=q.front().second.first;\\n            int cnt=q.front().second.second;\\n            vis[ind]=1;\\n            if(ind==n-1)\\n                return cnt;\\n            q.pop();\\n            if(ind-1>=0 and !vis[ind-1])\\n            {\\n                 q.push({arr[ind-1],{ind-1,cnt+1}});\\n                vis[ind-1]=1;\\n            }\\n            if(ind+1<n and !vis[ind+1])\\n            {\\n                   q.push({arr[ind+1],{ind+1,cnt+1}});\\n                   vis[ind+1]=1;\\n            }\\n            for(int y:mp[x])\\n            {\\n                if(y!=ind and !vis[y])\\n                {\\n                    q.push({arr[y],{y,cnt+1}});\\n                    vis[y]=1;\\n                }\\n            }\\n            mp.erase(x);\\n         }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\ntypedef pair<int,pair<int,int>> pi;\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        queue<pi> q;\\n        q.push({arr[0],{0,0}});\\n        vector<int> vis(n,0);\\n        vis[0]=1;\\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int ind=q.front().second.first;\\n            int cnt=q.front().second.second;\\n            vis[ind]=1;\\n            if(ind==n-1)\\n                return cnt;\\n            q.pop();\\n            if(ind-1>=0 and !vis[ind-1])\\n            {\\n                 q.push({arr[ind-1],{ind-1,cnt+1}});\\n                vis[ind-1]=1;\\n            }\\n            if(ind+1<n and !vis[ind+1])\\n            {\\n                   q.push({arr[ind+1],{ind+1,cnt+1}});\\n                   vis[ind+1]=1;\\n            }\\n            for(int y:mp[x])\\n            {\\n                if(y!=ind and !vis[y])\\n                {\\n                    q.push({arr[y],{y,cnt+1}});\\n                    vis[y]=1;\\n                }\\n            }\\n            mp.erase(x);\\n         }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260516,
                "title": "basic-approach-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Map And Deque\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom typing import List\\nfrom collections import deque\\n\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        mapping = {}\\n        for i in range(n):\\n            if arr[i] not in mapping:\\n                mapping[arr[i]] = []\\n            mapping[arr[i]].append(i)\\n\\n        visited = [False] * n\\n        q = deque()\\n        q.append(0)\\n        visited[0] = True\\n        steps = 0\\n\\n        while q:\\n            qsize = len(q)\\n            for _ in range(qsize):\\n                i = q.popleft()\\n                if i == n - 1:\\n                    return steps\\n                if i - 1 >= 0 and not visited[i - 1]:\\n                    q.append(i - 1)\\n                    visited[i - 1] = True\\n                if i + 1 < n and not visited[i + 1]:\\n                    q.append(i + 1)\\n                    visited[i + 1] = True\\n                if arr[i] in mapping:\\n                    for neigh in mapping[arr[i]]:\\n                        if not visited[neigh]:\\n                            q.append(neigh)\\n                            visited[neigh] = True\\n                    del mapping[arr[i]]\\n            steps += 1\\n\\n        return -1 #unreachable code\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\nfrom collections import deque\\n\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        mapping = {}\\n        for i in range(n):\\n            if arr[i] not in mapping:\\n                mapping[arr[i]] = []\\n            mapping[arr[i]].append(i)\\n\\n        visited = [False] * n\\n        q = deque()\\n        q.append(0)\\n        visited[0] = True\\n        steps = 0\\n\\n        while q:\\n            qsize = len(q)\\n            for _ in range(qsize):\\n                i = q.popleft()\\n                if i == n - 1:\\n                    return steps\\n                if i - 1 >= 0 and not visited[i - 1]:\\n                    q.append(i - 1)\\n                    visited[i - 1] = True\\n                if i + 1 < n and not visited[i + 1]:\\n                    q.append(i + 1)\\n                    visited[i + 1] = True\\n                if arr[i] in mapping:\\n                    for neigh in mapping[arr[i]]:\\n                        if not visited[neigh]:\\n                            q.append(neigh)\\n                            visited[neigh] = True\\n                    del mapping[arr[i]]\\n            steps += 1\\n\\n        return -1 #unreachable code\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260295,
                "title": "go-solution-with-hash-map-and-buffirized-channel",
                "content": "# Approach\\n1) Make mapping hash-table for array values\\n2) Start deque from 0 element.\\n3) Go through every element from mapping dict and add element to queue if path to given element is None\\n4) On final step - check neighbour elements\\n5) Return answer\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n```\\ntype Pair struct {\\n\\tidx   int\\n\\tvalue int\\n}\\n\\nfunc minJumps(arr []int) int {\\n\\tmapping := make(map[int]map[Pair]bool)\\n\\tfor ind, elem := range arr {\\n\\t\\t_, ok := mapping[elem]\\n\\t\\tp := Pair{\\n\\t\\t\\tidx:   ind,\\n\\t\\t\\tvalue: elem,\\n\\t\\t}\\n\\t\\tif !ok {\\n\\t\\t\\tmm := make(map[Pair]bool)\\n\\t\\t\\tmm[p] = true\\n\\t\\t\\tmapping[elem] = mm\\n\\t\\t} else {\\n\\t\\t\\tmapping[elem][p] = true\\n\\t\\t}\\n\\t}\\n\\tpath := make(map[int]int)\\n\\tpath[0] = 0\\n\\tq := make(chan Pair, len(arr))\\n\\tq <- Pair{\\n\\t\\tidx:   0,\\n\\t\\tvalue: arr[0],\\n\\t}\\n\\tused := make(map[int]bool)\\n\\tfor {\\n\\t\\tfrom_ch := <-q\\n\\t\\tif from_ch.idx == len(arr)-1 {\\n\\t\\t\\tclose(q)\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\t_, ok := used[from_ch.value]\\n\\t\\tif !ok {\\n\\t\\t\\tfor key, _ := range mapping[from_ch.value] {\\n\\t\\t\\t\\t_, ok := path[key.idx]\\n\\t\\t\\t\\tif !ok {\\n\\t\\t\\t\\t\\tpath[key.idx] = path[from_ch.idx] + 1\\n\\t\\t\\t\\t\\tq <- key\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            used[from_ch.value] = true\\n\\t\\t}\\n\\t\\tif from_ch.idx-1 >= 0 {\\n\\t\\t\\t_, ok := path[from_ch.idx-1]\\n\\t\\t\\tif !ok {\\n\\t\\t\\t\\tpath[from_ch.idx-1] = path[from_ch.idx] + 1\\n\\t\\t\\t\\tq <- Pair{\\n\\t\\t\\t\\t\\tidx:   from_ch.idx - 1,\\n\\t\\t\\t\\t\\tvalue: arr[from_ch.idx-1],\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif from_ch.idx+1 < len(arr) {\\n\\t\\t\\t_, ok := path[from_ch.idx+1]\\n\\t\\t\\tif !ok {\\n\\t\\t\\t\\tpath[from_ch.idx+1] = path[from_ch.idx] + 1\\n\\t\\t\\t\\tq <- Pair{\\n\\t\\t\\t\\t\\tidx:   from_ch.idx + 1,\\n\\t\\t\\t\\t\\tvalue: arr[from_ch.idx+1],\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn path[len(arr)-1]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\ntype Pair struct {\\n\\tidx   int\\n\\tvalue int\\n}\\n\\nfunc minJumps(arr []int) int {\\n\\tmapping := make(map[int]map[Pair]bool)\\n\\tfor ind, elem := range arr {\\n\\t\\t_, ok := mapping[elem]\\n\\t\\tp := Pair{\\n\\t\\t\\tidx:   ind,\\n\\t\\t\\tvalue: elem,\\n\\t\\t}\\n\\t\\tif !ok {\\n\\t\\t\\tmm := make(map[Pair]bool)\\n\\t\\t\\tmm[p] = true\\n\\t\\t\\tmapping[elem] = mm\\n\\t\\t} else {\\n\\t\\t\\tmapping[elem][p] = true\\n\\t\\t}\\n\\t}\\n\\tpath := make(map[int]int)\\n\\tpath[0] = 0\\n\\tq := make(chan Pair, len(arr))\\n\\tq <- Pair{\\n\\t\\tidx:   0,\\n\\t\\tvalue: arr[0],\\n\\t}\\n\\tused := make(map[int]bool)\\n\\tfor {\\n\\t\\tfrom_ch := <-q\\n\\t\\tif from_ch.idx == len(arr)-1 {\\n\\t\\t\\tclose(q)\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\t_, ok := used[from_ch.value]\\n\\t\\tif !ok {\\n\\t\\t\\tfor key, _ := range mapping[from_ch.value] {\\n\\t\\t\\t\\t_, ok := path[key.idx]\\n\\t\\t\\t\\tif !ok {\\n\\t\\t\\t\\t\\tpath[key.idx] = path[from_ch.idx] + 1\\n\\t\\t\\t\\t\\tq <- key\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            used[from_ch.value] = true\\n\\t\\t}\\n\\t\\tif from_ch.idx-1 >= 0 {\\n\\t\\t\\t_, ok := path[from_ch.idx-1]\\n\\t\\t\\tif !ok {\\n\\t\\t\\t\\tpath[from_ch.idx-1] = path[from_ch.idx] + 1\\n\\t\\t\\t\\tq <- Pair{\\n\\t\\t\\t\\t\\tidx:   from_ch.idx - 1,\\n\\t\\t\\t\\t\\tvalue: arr[from_ch.idx-1],\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif from_ch.idx+1 < len(arr) {\\n\\t\\t\\t_, ok := path[from_ch.idx+1]\\n\\t\\t\\tif !ok {\\n\\t\\t\\t\\tpath[from_ch.idx+1] = path[from_ch.idx] + 1\\n\\t\\t\\t\\tq <- Pair{\\n\\t\\t\\t\\t\\tidx:   from_ch.idx + 1,\\n\\t\\t\\t\\t\\tvalue: arr[from_ch.idx+1],\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn path[len(arr)-1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259696,
                "title": "bfs-beats-94-python-3-solution",
                "content": "\\n\\n# Approach\\nThis code finds the minimum number of jumps needed to reach the end of an array by performing a breadth-first search. It uses a dictionary to store indices of elements with the same value, a queue to track indices to visit, and a set to track visited indices. It returns the number of steps required to reach the end.\\n\\n# Complexity\\n- Time complexity:  **O(N)**\\n- Not 100% sure about that one. If you think it\\'s different, please write down below. \\n\\n\\n\\n---\\n\\n\\n\\n- Space complexity: **O(N)**\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        edges, n = defaultdict(list), len(arr)\\n        for i in range(n):\\n            edges[arr[i]].append(i)\\n        queue, visited, steps = deque([0]), set([0]), 0\\n        while queue:\\n            for _ in range(len(queue)):\\n                idx = queue.popleft()\\n                if idx == n-1:\\n                    return steps\\n                for new_idx in [idx-1, idx+1] + edges.pop(arr[idx], []):\\n                    if 0 <= new_idx < n and new_idx not in visited:\\n                        if new_idx == n-1:\\n                            return steps + 1\\n                        queue.append(new_idx)\\n                        visited.add(new_idx)\\n            steps += 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        edges, n = defaultdict(list), len(arr)\\n        for i in range(n):\\n            edges[arr[i]].append(i)\\n        queue, visited, steps = deque([0]), set([0]), 0\\n        while queue:\\n            for _ in range(len(queue)):\\n                idx = queue.popleft()\\n                if idx == n-1:\\n                    return steps\\n                for new_idx in [idx-1, idx+1] + edges.pop(arr[idx], []):\\n                    if 0 <= new_idx < n and new_idx not in visited:\\n                        if new_idx == n-1:\\n                            return steps + 1\\n                        queue.append(new_idx)\\n                        visited.add(new_idx)\\n            steps += 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259647,
                "title": "c-simplest-solution-bfs-hash-table",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        map<int, vector<int>> hashmap;\\n        int n = arr.size();\\n        for (int i=0; i<n; i++) hashmap[arr[i]].emplace_back(i);\\n        queue<int> q;\\n        q.push(0);\\n        int steps = 0;\\n        vector<bool> visited(n, false);\\n        visited[0] = true;\\n        while (!q.empty()) {\\n            for (int size=q.size(); size>0; size--) {\\n                int i = q.front();\\n                q.pop();\\n                if (i == n-1) return steps;\\n                vector<int> &next = hashmap[arr[i]];\\n                next.emplace_back(i-1);\\n                next.emplace_back(i+1);\\n                for (auto &ind:next) {\\n                    if (ind >=0 && ind < n && !visited[ind]) {\\n                        visited[ind] = true;\\n                        q.push(ind);\\n                    }\\n                }\\n                hashmap[arr[i]].clear();\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        map<int, vector<int>> hashmap;\\n        int n = arr.size();\\n        for (int i=0; i<n; i++) hashmap[arr[i]].emplace_back(i);\\n        queue<int> q;\\n        q.push(0);\\n        int steps = 0;\\n        vector<bool> visited(n, false);\\n        visited[0] = true;\\n        while (!q.empty()) {\\n            for (int size=q.size(); size>0; size--) {\\n                int i = q.front();\\n                q.pop();\\n                if (i == n-1) return steps;\\n                vector<int> &next = hashmap[arr[i]];\\n                next.emplace_back(i-1);\\n                next.emplace_back(i+1);\\n                for (auto &ind:next) {\\n                    if (ind >=0 && ind < n && !visited[ind]) {\\n                        visited[ind] = true;\\n                        q.push(ind);\\n                    }\\n                }\\n                hashmap[arr[i]].clear();\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259450,
                "title": "golang-bfs",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfunc minJumps(arr []int) int {\\n    dict := make(map[int][]int)\\n    \\n    for id, num := range arr {\\n        dict[num] = append(dict[num], id)\\n    }\\n    \\n    visited := make([]bool , len(arr))\\n    queue := []int{0}\\n    visited[0] = true\\n    \\n    jumps := 0\\n    for len(queue) > 0 {\\n        l := len(queue)\\n        for i := 0; i < l; i++ {\\n            idx := queue[0]\\n            queue = queue[1:]            \\n            \\n            if idx == len(arr)-1 {\\n                return jumps\\n            }\\n            \\n            for _, next := range dict[arr[idx]] {\\n                if !visited[next] {\\n                    queue = append(queue, next)\\n                    visited[next] = true\\n                }\\n            }\\n            // Optimization we may check entries again and find it is already visited\\n            delete(dict, arr[idx])\\n            \\n            if idx != 0 && !visited[idx-1] {\\n                queue = append(queue, idx-1)\\n                visited[idx-1] = true\\n            }\\n            \\n            if idx+1 < len(arr) && !visited[idx+1] {\\n                queue = append(queue, idx+1)\\n                visited[idx+1] = true                \\n            }\\n        }\\n        jumps++\\n    }\\n    \\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minJumps(arr []int) int {\\n    dict := make(map[int][]int)\\n    \\n    for id, num := range arr {\\n        dict[num] = append(dict[num], id)\\n    }\\n    \\n    visited := make([]bool , len(arr))\\n    queue := []int{0}\\n    visited[0] = true\\n    \\n    jumps := 0\\n    for len(queue) > 0 {\\n        l := len(queue)\\n        for i := 0; i < l; i++ {\\n            idx := queue[0]\\n            queue = queue[1:]            \\n            \\n            if idx == len(arr)-1 {\\n                return jumps\\n            }\\n            \\n            for _, next := range dict[arr[idx]] {\\n                if !visited[next] {\\n                    queue = append(queue, next)\\n                    visited[next] = true\\n                }\\n            }\\n            // Optimization we may check entries again and find it is already visited\\n            delete(dict, arr[idx])\\n            \\n            if idx != 0 && !visited[idx-1] {\\n                queue = append(queue, idx-1)\\n                visited[idx-1] = true\\n            }\\n            \\n            if idx+1 < len(arr) && !visited[idx+1] {\\n                queue = append(queue, idx+1)\\n                visited[idx+1] = true                \\n            }\\n        }\\n        jumps++\\n    }\\n    \\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259091,
                "title": "easy-code-to-understand-bfs",
                "content": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        HashMap<Integer , ArrayList<Integer>> map = new HashMap<>();\\n        for(int i = 0 ; i < arr.length ; i++){\\n            if(!map.containsKey(arr[i])){\\n                map.put(arr[i] , new ArrayList<>());\\n            }\\n            map.get(arr[i]).add(i);\\n        }\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        int dis = 0;\\n        boolean[] isVis = new boolean[arr.length];\\n        isVis[0] = true;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                int curNode = queue.poll();\\n                if(curNode == arr.length - 1) return dis;\\n                for(int ele : map.get(arr[curNode])){\\n                    if(!isVis[ele]){\\n                        isVis[ele] = true;\\n                        queue.offer(ele);\\n                    }\\n                }\\n                map.put(arr[curNode] , new ArrayList<>()); // Removing the entry from Map,\\n\\t\\t\\t\\t//because these nodes will already be visited.\\n\\t\\t\\t\\t//For Why need to check for every same number , for loop will be active and this will cost \\n\\t\\t\\t\\t//us in time. That\\'s why I am removing the List after its first use :) \\n                if(curNode - 1 >= 0 && !isVis[curNode-1]){\\n                    isVis[curNode-1] = true;\\n                    queue.offer(curNode-1);\\n                }\\n                if(curNode + 1 < arr.length && !isVis[curNode+1]){\\n                    isVis[curNode + 1] = true;\\n                    queue.offer(curNode + 1);\\n                }\\n                \\n            }\\n            dis++;\\n        }\\n        return -1;\\n    }\\n    \\n}\\n```\\n**If you found it helpful, please Upvote :))))**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        HashMap<Integer , ArrayList<Integer>> map = new HashMap<>();\\n        for(int i = 0 ; i < arr.length ; i++){\\n            if(!map.containsKey(arr[i])){\\n                map.put(arr[i] , new ArrayList<>());\\n            }\\n            map.get(arr[i]).add(i);\\n        }\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        int dis = 0;\\n        boolean[] isVis = new boolean[arr.length];\\n        isVis[0] = true;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                int curNode = queue.poll();\\n                if(curNode == arr.length - 1) return dis;\\n                for(int ele : map.get(arr[curNode])){\\n                    if(!isVis[ele]){\\n                        isVis[ele] = true;\\n                        queue.offer(ele);\\n                    }\\n                }\\n                map.put(arr[curNode] , new ArrayList<>()); // Removing the entry from Map,\\n\\t\\t\\t\\t//because these nodes will already be visited.\\n\\t\\t\\t\\t//For Why need to check for every same number , for loop will be active and this will cost \\n\\t\\t\\t\\t//us in time. That\\'s why I am removing the List after its first use :) \\n                if(curNode - 1 >= 0 && !isVis[curNode-1]){\\n                    isVis[curNode-1] = true;\\n                    queue.offer(curNode-1);\\n                }\\n                if(curNode + 1 < arr.length && !isVis[curNode+1]){\\n                    isVis[curNode + 1] = true;\\n                    queue.offer(curNode + 1);\\n                }\\n                \\n            }\\n            dis++;\\n        }\\n        return -1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259037,
                "title": "swift-breadth-first-search-beats-100-memory-runtime",
                "content": "# Complexity\\n- Time complexity:\\nThe time complexity of the given code is O(N + K*log(K)), where N is the length of the input vector nums and K is the number of distinct elements in the input vector.\\n\\n- Space complexity:\\nThe space complexity of the code is O(N) because we use a map m to store the indexes of each element, and a queue q to implement BFS. We also use a vector vis to keep track of visited indexes. All these data structures require O(N) space in the worst case.\\n\\n# Code\\n```\\nclass Solution {\\n    func minJumps(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        var m = [Int: [Int]]()\\n        var vis = Array(repeating: 0, count: n)\\n        \\n        for i in 0..<n {\\n            m[nums[i], default: []].append(i)\\n        }\\n        \\n        var q = [Int]()\\n        q.append(0)\\n        vis[0] = 1\\n        var f = false\\n        var c = 0\\n        \\n        while !q.isEmpty {\\n            let sz = q.count\\n            for _ in 0..<sz {\\n                let i = q.removeFirst()\\n                if i == n-1 {\\n                    f = true\\n                    break\\n                }\\n                if i+1 < n && vis[i+1] == 0 {\\n                    q.append(i+1)\\n                    vis[i+1] = 1\\n                }\\n                if i-1 >= 0 && vis[i-1] == 0 {\\n                    q.append(i-1)\\n                    vis[i-1] = 1\\n                }\\n                if let indexes = m[nums[i]], !indexes.isEmpty {\\n                    for x in indexes {\\n                        if vis[x] == 0 {\\n                            q.append(x)\\n                            vis[x] = 1\\n                        }\\n                    }\\n                    m[nums[i]] = nil\\n                }\\n            }\\n            if f { break }\\n            else { c += 1 }\\n        }\\n        return c\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minJumps(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        var m = [Int: [Int]]()\\n        var vis = Array(repeating: 0, count: n)\\n        \\n        for i in 0..<n {\\n            m[nums[i], default: []].append(i)\\n        }\\n        \\n        var q = [Int]()\\n        q.append(0)\\n        vis[0] = 1\\n        var f = false\\n        var c = 0\\n        \\n        while !q.isEmpty {\\n            let sz = q.count\\n            for _ in 0..<sz {\\n                let i = q.removeFirst()\\n                if i == n-1 {\\n                    f = true\\n                    break\\n                }\\n                if i+1 < n && vis[i+1] == 0 {\\n                    q.append(i+1)\\n                    vis[i+1] = 1\\n                }\\n                if i-1 >= 0 && vis[i-1] == 0 {\\n                    q.append(i-1)\\n                    vis[i-1] = 1\\n                }\\n                if let indexes = m[nums[i]], !indexes.isEmpty {\\n                    for x in indexes {\\n                        if vis[x] == 0 {\\n                            q.append(x)\\n                            vis[x] = 1\\n                        }\\n                    }\\n                    m[nums[i]] = nil\\n                }\\n            }\\n            if f { break }\\n            else { c += 1 }\\n        }\\n        return c\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259008,
                "title": "c-solution-bfs-beats-97-of-other-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>>mp;\\n        for (int i = 0; i < n; i++) mp[arr[i]].push_back(i);\\n        \\n        queue<int>q;\\n        vector<bool>visited(n, false);\\n        q.push(0);\\n        int steps = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                int currIdx = q.front();\\n                q.pop();\\n                if (currIdx == n - 1) return steps;\\n                if (currIdx + 1 < n && !visited[currIdx + 1])\\n                {\\n                    visited[currIdx + 1] = true;\\n                    q.push(currIdx + 1);\\n                }\\n                if (currIdx - 1 >= 0 && !visited[currIdx - 1]) \\n                {\\n                    visited[currIdx - 1] = true;\\n                    q.push(currIdx - 1);\\n                }\\n                for (int newIdx : mp[arr[currIdx]])  \\n                {                                 \\n                    if (!visited[newIdx]) \\n                    {\\n                        visited[newIdx] = true;\\n                        q.push(newIdx);\\n                    }\\n                }\\n                mp[arr[currIdx]].clear();    \\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minJumps(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>>mp;\\n        for (int i = 0; i < n; i++) mp[arr[i]].push_back(i);\\n        \\n        queue<int>q;\\n        vector<bool>visited(n, false);\\n        q.push(0);\\n        int steps = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                int currIdx = q.front();\\n                q.pop();\\n                if (currIdx == n - 1) return steps;\\n                if (currIdx + 1 < n && !visited[currIdx + 1])\\n                {\\n                    visited[currIdx + 1] = true;\\n                    q.push(currIdx + 1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3258959,
                "title": "easy-implementation-bfs-using-queue-of-indices",
                "content": "$$intuition$$\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst make the graph properly. in this case using a adjacency list will be very very costly.\\nand will be approximately O(n^2) time complexity\\nso we abort that idea\\ninstead of that we make a unordered map of the values and the indices that have the same values as of that index.\\nit is more economical.\\nafter that it is just easy bfs implementation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe make a queue of pair of integers pair<int,int> in which implies that we are at the pair.second index at the pair.first time.\\nand then implement the bfs.\\nwe have to delete the used elements also accordingly because as the number of indices having the same value can be very high as well that is why we have to keep deleting the used rqdundant items. along with keeping a proper visited array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size();\\n       \\n        unordered_map<int,set<int>>adj;\\n        for(int i=0;i<arr.size();i++){\\n            adj[arr[i]].insert(i);\\n        }\\n      \\n      \\n      queue<pair<int,int>>q;\\n        vector<int>vis(n,0);\\n        vis[0]=1;\\n        q.push({0,0});\\n        int ans=1e9;\\n        while(!q.empty()){\\n            auto data=q.front();\\n            int currtime=data.first;\\n            int currind=data.second;\\n           \\n            vis[currind]=1;\\n            q.pop();\\n\\n            if(currind==n-1) {\\n              ans=min(ans,currtime);\\n            }\\n            if(currind+1<n && !vis[currind+1]){\\n                q.push({currtime+1,currind+1});\\n            }\\n             if(currind-1>=0 && !vis[currind-1]){\\n                q.push({currtime+1,currind-1});\\n            }\\n            for(auto &it:adj[arr[currind]]){\\n                if(!vis[it]){\\n                    q.push({currtime+1,it});\\n                }\\n            }\\n           adj[arr[currind]].clear();\\n        \\n        }\\nreturn ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size();\\n       \\n        unordered_map<int,set<int>>adj;\\n        for(int i=0;i<arr.size();i++){\\n            adj[arr[i]].insert(i);\\n        }\\n      \\n      \\n      queue<pair<int,int>>q;\\n        vector<int>vis(n,0);\\n        vis[0]=1;\\n        q.push({0,0});\\n        int ans=1e9;\\n        while(!q.empty()){\\n            auto data=q.front();\\n            int currtime=data.first;\\n            int currind=data.second;\\n           \\n            vis[currind]=1;\\n            q.pop();\\n\\n            if(currind==n-1) {\\n              ans=min(ans,currtime);\\n            }\\n            if(currind+1<n && !vis[currind+1]){\\n                q.push({currtime+1,currind+1});\\n            }\\n             if(currind-1>=0 && !vis[currind-1]){\\n                q.push({currtime+1,currind-1});\\n            }\\n            for(auto &it:adj[arr[currind]]){\\n                if(!vis[it]){\\n                    q.push({currtime+1,it});\\n                }\\n            }\\n           adj[arr[currind]].clear();\\n        \\n        }\\nreturn ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258893,
                "title": "c-bfs-intuition-explained",
                "content": "# Intuition\\nAfter reading the question first thing that came in my mind is that we have to store the indexes of same value in a map. Then after giving some more time to problem, I concluded that our map will work as a graph and therefore we can do a BFS on it.\\n\\n# Approach\\nCreate a map and store the indexes of the element. \\nLike arr = [1,2,1] \\nthen our map will look like this: \\n1: 0,2 this means element 1 is present at 0th index and 2nd index.\\n2: 1\\nNow do a simple BFS.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n == 1)\\n        {\\n            return 0;\\n        }\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        int ans = INT_MAX;\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({0,{arr[0],0}}); // {count,{arr[i],i}}\\n        vector<int> vis(n,0);\\n        vis[0] = 1;\\n\\n        while(!q.empty())\\n        {\\n            int count = q.front().first;\\n            int num = q.front().second.first;\\n            int idx = q.front().second.second;\\n            q.pop();\\n            vis[idx] = 1;\\n            if(idx == n - 1)\\n            {\\n                //there can be many ways to reach the last index of the array, therefore store the minimum count or steps in the answer.\\n                ans = min(ans,count);\\n                continue;\\n            }\\n            if(mp.find(num) != mp.end())\\n            {\\n                //add the same elements in the queue which we have not visited.\\n                for(auto &it : mp[num])\\n                {\\n                    if(idx != it && !vis[it])\\n                    {\\n                        q.push({count + 1,{num,it}});\\n                        vis[it] = 1;\\n                    }\\n                }\\n                mp[num].clear();\\n            }\\n            // we also need to add arr[i + 1] and arr[i - 1] in our queue and make sure that add these element only if they are not visited.\\n            if(!vis[idx + 1])\\n            {\\n                q.push({count + 1,{arr[idx + 1],idx + 1}});\\n                vis[idx + 1] = 1;\\n            }\\n            if(idx > 0 && !vis[idx - 1])\\n            {\\n                q.push({count + 1,{arr[idx - 1],idx - 1}});\\n                vis[idx - 1] = 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n == 1)\\n        {\\n            return 0;\\n        }\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        int ans = INT_MAX;\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({0,{arr[0],0}}); // {count,{arr[i],i}}\\n        vector<int> vis(n,0);\\n        vis[0] = 1;\\n\\n        while(!q.empty())\\n        {\\n            int count = q.front().first;\\n            int num = q.front().second.first;\\n            int idx = q.front().second.second;\\n            q.pop();\\n            vis[idx] = 1;\\n            if(idx == n - 1)\\n            {\\n                //there can be many ways to reach the last index of the array, therefore store the minimum count or steps in the answer.\\n                ans = min(ans,count);\\n                continue;\\n            }\\n            if(mp.find(num) != mp.end())\\n            {\\n                //add the same elements in the queue which we have not visited.\\n                for(auto &it : mp[num])\\n                {\\n                    if(idx != it && !vis[it])\\n                    {\\n                        q.push({count + 1,{num,it}});\\n                        vis[it] = 1;\\n                    }\\n                }\\n                mp[num].clear();\\n            }\\n            // we also need to add arr[i + 1] and arr[i - 1] in our queue and make sure that add these element only if they are not visited.\\n            if(!vis[idx + 1])\\n            {\\n                q.push({count + 1,{arr[idx + 1],idx + 1}});\\n                vis[idx + 1] = 1;\\n            }\\n            if(idx > 0 && !vis[idx - 1])\\n            {\\n                q.push({count + 1,{arr[idx - 1],idx - 1}});\\n                vis[idx - 1] = 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258799,
                "title": "bfs-cpp",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Problem can be solved using simple bfs.\\n    Adjacent vertices of node i = [i+1, i-1, k] where arr[i] = arr[k];\\n    time[j] = Needs minimum time to reach possition j.\\n    We need to jump only if(time[i]+1 < time[j]) means the node j not explored yet.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = size(arr);\\n        map<int,vector<int>> graph;\\n        vector<int> time(n,1e9);\\n        queue<int> q;\\n        q.push(0); time[0] = 0;\\n        for(int i=0; i<n; i++) graph[arr[i]].push_back(i);\\n        while(!q.empty()){\\n            int i = q.front(); q.pop();\\n            auto & v = graph[arr[i]];\\n            v.push_back(i-1), v.push_back(i+1);\\n            for(auto & j : v){\\n                if(j>=0 && j<n && time[j] > time[i]+1) time[j] = time[i]+1, q.push(j);\\n            }\\n            v.clear();\\n        }\\n        return time[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = size(arr);\\n        map<int,vector<int>> graph;\\n        vector<int> time(n,1e9);\\n        queue<int> q;\\n        q.push(0); time[0] = 0;\\n        for(int i=0; i<n; i++) graph[arr[i]].push_back(i);\\n        while(!q.empty()){\\n            int i = q.front(); q.pop();\\n            auto & v = graph[arr[i]];\\n            v.push_back(i-1), v.push_back(i+1);\\n            for(auto & j : v){\\n                if(j>=0 && j<n && time[j] > time[i]+1) time[j] = time[i]+1, q.push(j);\\n            }\\n            v.clear();\\n        }\\n        return time[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258649,
                "title": "easy-method-using-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minJumps(self, arr):\\n        \\n        queue    = deque()  \\n        dct      = defaultdict(list)\\n        vstd_ndx = set()  \\n        vstd_val = set()  \\n        arr_l = len(arr)\\n        for i in range(arr_l - 1, -1, -1):\\n            dct[arr[i]].append(i)\\n        \\n        st_nmb = 0       \\n        queue.append(0)  \\n        while queue:\\n            for _ in range(len(queue)): \\n                ndx = queue.popleft()   \\n                \\n                if ndx in vstd_ndx:    continue\\n                if ndx == arr_l - 1:   return st_nmb\\n                vstd_ndx.add(ndx)      \\n\\n                val = arr[ndx]\\n                if val not in vstd_val:  \\n                    queue.extend(dct[val]) \\n                    vstd_val.add(val)      \\n                if ndx < arr_l:   queue.append(ndx + 1)\\n                if ndx > 0:       queue.append(ndx - 1)\\n             \\n            st_nmb += 1   \\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr):\\n        \\n        queue    = deque()  \\n        dct      = defaultdict(list)\\n        vstd_ndx = set()  \\n        vstd_val = set()  \\n        arr_l = len(arr)\\n        for i in range(arr_l - 1, -1, -1):\\n            dct[arr[i]].append(i)\\n        \\n        st_nmb = 0       \\n        queue.append(0)  \\n        while queue:\\n            for _ in range(len(queue)): \\n                ndx = queue.popleft()   \\n                \\n                if ndx in vstd_ndx:    continue\\n                if ndx == arr_l - 1:   return st_nmb\\n                vstd_ndx.add(ndx)      \\n\\n                val = arr[ndx]\\n                if val not in vstd_val:  \\n                    queue.extend(dct[val]) \\n                    vstd_val.add(val)      \\n                if ndx < arr_l:   queue.append(ndx + 1)\\n                if ndx > 0:       queue.append(ndx - 1)\\n             \\n            st_nmb += 1   \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258497,
                "title": "bfs-hashmap-solution-c-o-n-time-space-beats-87",
                "content": "# Proper BFS Solution written below\\n    Also DFS solution given but TLE (in Comments)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bfs(vector<int>&arr, int src, unordered_map<int,vector<int>>&pos, vector<bool>&vis){\\n        int n=arr.size();\\n        queue<int> q;\\n        vector<int> jumps(n,INT_MAX);\\n        q.push(src);\\n        jumps[src]=0;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            vis[u]=true;\\n            for(int j: pos[arr[u]]){\\n                if(!vis[j] && j!=u){\\n                    vis[j]=true;\\n                    jumps[j]=min(jumps[j], jumps[u]+1);\\n                    q.push(j);\\n                }\\n                else if(j==u) continue;\\n                else break;\\n\\n            }\\n            if(u-1>=0 && !vis[u-1]){\\n                jumps[u-1]=min(jumps[u-1], jumps[u]+1);\\n                q.push(u-1);\\n            }\\n            if(u+1<n && !vis[u+1]){\\n                jumps[u+1]=min(jumps[u+1], jumps[u]+1);\\n                q.push(u+1);\\n            }\\n            \\n        }\\n        return jumps[n-1];\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>> pos;\\n        for(int i=0; i<arr.size(); i++){\\n            pos[arr[i]].push_back(i);\\n        }\\n        vector<bool>  vis(arr.size(),false);\\n        // long long int ans=dfs(arr,0,pos,vis);\\n        int ans=bfs(arr,0,pos, vis);\\n        return ans>=INT_MAX?-1:ans;\\n    }\\n    // long long int dfs(vector<int>&arr, int i, unordered_map<int,vector<int>>&pos,vector<bool>&vis){\\n    //     if(i>=arr.size() || i<0 || vis[i]) return INT_MAX;\\n    //     if(i==arr.size()-1) return 0;\\n    //     vis[i]=true;\\n    //     long long int a=dfs(arr,i+1,pos,vis);\\n    //     long long int b=dfs(arr,i-1,pos,vis);\\n    //     long long int x=INT_MAX;\\n    //     for(int j: pos[arr[i]]){\\n    //         if(!vis[j])\\n    //             x=min(x,dfs(arr,j,pos,vis));\\n    //     }\\n    //     vis[i]=false;\\n    //     return min(a,min(b,x))+1;\\n    // }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(vector<int>&arr, int src, unordered_map<int,vector<int>>&pos, vector<bool>&vis){\\n        int n=arr.size();\\n        queue<int> q;\\n        vector<int> jumps(n,INT_MAX);\\n        q.push(src);\\n        jumps[src]=0;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            vis[u]=true;\\n            for(int j: pos[arr[u]]){\\n                if(!vis[j] && j!=u){\\n                    vis[j]=true;\\n                    jumps[j]=min(jumps[j], jumps[u]+1);\\n                    q.push(j);\\n                }\\n                else if(j==u) continue;\\n                else break;\\n\\n            }\\n            if(u-1>=0 && !vis[u-1]){\\n                jumps[u-1]=min(jumps[u-1], jumps[u]+1);\\n                q.push(u-1);\\n            }\\n            if(u+1<n && !vis[u+1]){\\n                jumps[u+1]=min(jumps[u+1], jumps[u]+1);\\n                q.push(u+1);\\n            }\\n            \\n        }\\n        return jumps[n-1];\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>> pos;\\n        for(int i=0; i<arr.size(); i++){\\n            pos[arr[i]].push_back(i);\\n        }\\n        vector<bool>  vis(arr.size(),false);\\n        // long long int ans=dfs(arr,0,pos,vis);\\n        int ans=bfs(arr,0,pos, vis);\\n        return ans>=INT_MAX?-1:ans;\\n    }\\n    // long long int dfs(vector<int>&arr, int i, unordered_map<int,vector<int>>&pos,vector<bool>&vis){\\n    //     if(i>=arr.size() || i<0 || vis[i]) return INT_MAX;\\n    //     if(i==arr.size()-1) return 0;\\n    //     vis[i]=true;\\n    //     long long int a=dfs(arr,i+1,pos,vis);\\n    //     long long int b=dfs(arr,i-1,pos,vis);\\n    //     long long int x=INT_MAX;\\n    //     for(int j: pos[arr[i]]){\\n    //         if(!vis[j])\\n    //             x=min(x,dfs(arr,j,pos,vis));\\n    //     }\\n    //     vis[i]=false;\\n    //     return min(a,min(b,x))+1;\\n    // }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258441,
                "title": "c-bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> m;\\n        int n = size(arr);\\n        for (int i = 0; i < n; ++i)\\n            m[arr[i]].push_back(i);\\n        queue<int> q;\\n        q.push(0);\\n        vector<bool> visited(n);\\n        visited[0] = true;\\n        int ans = 0;\\n        while (!q.empty()) {\\n            int sz = size(q);\\n            while (sz--) {\\n                int i = q.front();\\n                q.pop();\\n                if (i == n-1)\\n                    return ans;\\n                if (i+1 < n && !visited[i+1]) {\\n                    q.push(i+1);\\n                    visited[i+1] = true;\\n                }\\n                if (i-1 >= 0 && !visited[i-1]) {\\n                    q.push(i-1);\\n                    visited[i-1] = true;\\n                }\\n                for (int j: m[arr[i]]) {\\n                    if (!visited[j]) {\\n                        q.push(j);\\n                        visited[j] = true;\\n                    }\\n                }\\n                m[arr[i]].clear();\\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> m;\\n        int n = size(arr);\\n        for (int i = 0; i < n; ++i)\\n            m[arr[i]].push_back(i);\\n        queue<int> q;\\n        q.push(0);\\n        vector<bool> visited(n);\\n        visited[0] = true;\\n        int ans = 0;\\n        while (!q.empty()) {\\n            int sz = size(q);\\n            while (sz--) {\\n                int i = q.front();\\n                q.pop();\\n                if (i == n-1)\\n                    return ans;\\n                if (i+1 < n && !visited[i+1]) {\\n                    q.push(i+1);\\n                    visited[i+1] = true;\\n                }\\n                if (i-1 >= 0 && !visited[i-1]) {\\n                    q.push(i-1);\\n                    visited[i-1] = true;\\n                }\\n                for (int j: m[arr[i]]) {\\n                    if (!visited[j]) {\\n                        q.push(j);\\n                        visited[j] = true;\\n                    }\\n                }\\n                m[arr[i]].clear();\\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258023,
                "title": "java-easy-explained-beginner-friendly",
                "content": "- The algorithm used in the code is based on Breadth First Search (BFS). The basic idea is to traverse the graph level by level, starting from the source node, and to keep track of the nodes visited so far. In this problem, the graph is represented by an array where each element is a list of indices of other elements that can be reached from it.\\n\\n- The algorithm maintains a queue of nodes to be visited next. Initially, the source node is added to the queue with a distance of 0. In each iteration, the algorithm removes a node from the front of the queue, and for each neighbor of the node that has not been visited yet, it adds the neighbor to the queue with a distance of one more than the distance of the current node.\\n\\n- In this particular implementation, the queue is implemented as a LinkedList, which provides O(1) time complexity for both adding and removing elements. The visited nodes are marked using a boolean array, which also provides O(1) time complexity for checking whether a node has been visited or not.\\n\\n- To optimize the algorithm further, the code uses a HashMap to keep track of the indices of elements with the same value. This avoids the need to scan the entire array to find all elements with the same value, which would have a time complexity of O(n).\\n\\n- Finally, the algorithm returns the distance to the last element of the array, which is the target node.\\n\\n- Overall, the time complexity of the algorithm is O(n), where n is the number of elements in the array, since each element is visited at most once. The space complexity is also O(n), since the queue and the visited array both require O(n) space. The additional space used by the HashMap is at most O(kn), where k is the maximum number of elements with the same value in the array. However, in practice, k is usually much smaller than n, so the overall space complexity is still O(n).\\n- PLEASE UPVOTE IT . THANK YOU\\n\\n# Code\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.computeIfAbsent(arr[i], k -> new ArrayList<>()).add(i);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        int jumps = 0;\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int cur = queue.poll();\\n                if (cur == n - 1) {\\n                    return jumps;\\n                }\\n                List<Integer> nextPositions = map.get(arr[cur]);\\n                nextPositions.add(cur - 1);\\n                nextPositions.add(cur + 1);\\n                for (int next : nextPositions) {\\n                    if (next >= 0 && next < n && !visited[next]) {\\n                        visited[next] = true;\\n                        queue.offer(next);\\n                    }\\n                }\\n                nextPositions.clear();\\n            }\\n            jumps++;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.computeIfAbsent(arr[i], k -> new ArrayList<>()).add(i);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        int jumps = 0;\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int cur = queue.poll();\\n                if (cur == n - 1) {\\n                    return jumps;\\n                }\\n                List<Integer> nextPositions = map.get(arr[cur]);\\n                nextPositions.add(cur - 1);\\n                nextPositions.add(cur + 1);\\n                for (int next : nextPositions) {\\n                    if (next >= 0 && next < n && !visited[next]) {\\n                        visited[next] = true;\\n                        queue.offer(next);\\n                    }\\n                }\\n                nextPositions.clear();\\n            }\\n            jumps++;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257976,
                "title": "bfs-detailed-explanation",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDE6\\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDF2 \\uD835\\uDDE9\\uD835\\uDDF6\\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDDFC \\uD835\\uDDE6\\uD835\\uDDFC\\uD835\\uDDF9\\uD835\\uDE02\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB | \\uD835\\uDDD7\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDD4\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF5 \\uD835\\uDDD8\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\n\\uD835\\uDDD6\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDEE\\uD835\\uDDFF\\uD835\\uDDF2 \\uD835\\uDDEE\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDF2\\uD835\\uDDF0\\uD835\\uDDF6\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF2\\uD835\\uDDF1\\nhttps://youtu.be/dOYfnnBxb-s\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar minJumps = function(arr) {\\n    let n = arr.length\\n    let map = new Map()\\n    for (let i = 0; i < n; i++) {\\n        let array = []\\n        if (map.has(arr[i])) array = map.get(arr[i])\\n        array.push(i)\\n        map.set(arr[i], array)\\n    }\\n\\n    let visited = new Set()\\n    let queue = [[0,0]]\\n    visited.add(0)\\n\\n    while (queue.length) {\\n        let [cur, step] = queue.shift()\\n        if (cur == n-1) return step\\n\\n        if (cur + 1 < n && !visited.has(cur+1)) {\\n            queue.push([cur+1, step+1])\\n            visited.add(cur+1)\\n        }\\n\\n        if (cur - 1 >= 0 && !visited.has(cur-1)) {\\n            queue.push([cur-1, step+1])\\n            visited.add(cur-1)\\n        }\\n        if (!map.has(arr[cur])) continue\\n        for (let idx of map.get(arr[cur])) {\\n            if (!visited.has(idx) && idx != cur) {\\n                queue.push([idx, step+1])\\n                visited.add(idx)\\n            }\\n        }  \\n\\n        map.delete(arr[cur])      \\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar minJumps = function(arr) {\\n    let n = arr.length\\n    let map = new Map()\\n    for (let i = 0; i < n; i++) {\\n        let array = []\\n        if (map.has(arr[i])) array = map.get(arr[i])\\n        array.push(i)\\n        map.set(arr[i], array)\\n    }\\n\\n    let visited = new Set()\\n    let queue = [[0,0]]\\n    visited.add(0)\\n\\n    while (queue.length) {\\n        let [cur, step] = queue.shift()\\n        if (cur == n-1) return step\\n\\n        if (cur + 1 < n && !visited.has(cur+1)) {\\n            queue.push([cur+1, step+1])\\n            visited.add(cur+1)\\n        }\\n\\n        if (cur - 1 >= 0 && !visited.has(cur-1)) {\\n            queue.push([cur-1, step+1])\\n            visited.add(cur-1)\\n        }\\n        if (!map.has(arr[cur])) continue\\n        for (let idx of map.get(arr[cur])) {\\n            if (!visited.has(idx) && idx != cur) {\\n                queue.push([idx, step+1])\\n                visited.add(idx)\\n            }\\n        }  \\n\\n        map.delete(arr[cur])      \\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3257883,
                "title": "python-clear-the-visited-index-save-my-day",
                "content": "This is a standard BFS problem. \\n\\nHowever, we can get TLE without one trick below:\\n```\\n# clear the transport as we have already visited all the index in the list\\ntransport_map[arr[cur_idx]].clear()\\n```\\n\\nAfter we visited all the connected index, we need to clear this hash map. Otherwise, we will check the same index again and again which causes TLE.\\n\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        # try BFS\\n        # there exits a transport from A to B if A == B\\n        transport_map = collections.defaultdict(list)\\n        for idx, num in enumerate(arr):\\n            transport_map[num].append(idx)\\n        \\n        len_a = len(arr)\\n        target = len_a - 1\\n        queue = collections.deque([(0, 0)])\\n        visited = {0,}\\n        while queue:\\n            cur_idx, step = queue.popleft()\\n            if cur_idx == target:\\n                return step\\n            \\n            for nstep in [1, -1]:\\n                nidx = cur_idx + nstep\\n                if nidx >= 0 and nidx < len_a and nidx not in visited:\\n                    queue.append((nidx, step + 1))\\n                    visited.add(nidx)\\n                \\n            if arr[cur_idx] in transport_map:\\n                for nidx in transport_map[arr[cur_idx]]:\\n                    if nidx not in visited:\\n                        queue.append((nidx, step + 1))\\n                        visited.add(nidx)\\n                # clear the transport as we have already visited all the index in the list\\n                transport_map[arr[cur_idx]].clear()\\n                \\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# clear the transport as we have already visited all the index in the list\\ntransport_map[arr[cur_idx]].clear()\\n```\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        # try BFS\\n        # there exits a transport from A to B if A == B\\n        transport_map = collections.defaultdict(list)\\n        for idx, num in enumerate(arr):\\n            transport_map[num].append(idx)\\n        \\n        len_a = len(arr)\\n        target = len_a - 1\\n        queue = collections.deque([(0, 0)])\\n        visited = {0,}\\n        while queue:\\n            cur_idx, step = queue.popleft()\\n            if cur_idx == target:\\n                return step\\n            \\n            for nstep in [1, -1]:\\n                nidx = cur_idx + nstep\\n                if nidx >= 0 and nidx < len_a and nidx not in visited:\\n                    queue.append((nidx, step + 1))\\n                    visited.add(nidx)\\n                \\n            if arr[cur_idx] in transport_map:\\n                for nidx in transport_map[arr[cur_idx]]:\\n                    if nidx not in visited:\\n                        queue.append((nidx, step + 1))\\n                        visited.add(nidx)\\n                # clear the transport as we have already visited all the index in the list\\n                transport_map[arr[cur_idx]].clear()\\n                \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257809,
                "title": "readable-code-c-simple-bfs-solution-using-dictionary-hashset-and-queue",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n    {\\n        public int MinJumps(int[] arr)\\n        {\\n            var moveDict = new Dictionary<int, HashSet<int>>();\\n\\n            for (int i = 0; i < arr.Length; i++)\\n            {\\n                if (!moveDict.ContainsKey(arr[i]))\\n                {\\n                    moveDict[arr[i]] = new HashSet<int>();\\n                }\\n\\n                moveDict[arr[i]].Add(i);\\n            }\\n\\n            var visited = new bool[arr.Length];\\n            visited[0] = true;\\n            var queue = new Queue<(int, int)>();\\n            queue.Enqueue((0, 0));\\n\\n            while (queue.Count > 0)\\n            {\\n                var (itemIndex, depth) = queue.Dequeue();\\n\\n                var currentItem = arr[itemIndex];\\n\\n                if (itemIndex == arr.Length - 1)\\n                {\\n                    return depth;\\n                }\\n\\n                if (arr[arr.Length - 1] == currentItem)\\n                {\\n                    return depth + 1;\\n                }\\n\\n                if (itemIndex > 0 && !visited[itemIndex - 1])\\n                {\\n                    visited[itemIndex - 1] = true;\\n                    queue.Enqueue((itemIndex - 1, depth + 1));\\n\\n                    if (arr.Length - 1 == itemIndex - 1)\\n                    {\\n                        return depth + 1;\\n                    }\\n                }\\n\\n                if (itemIndex < arr.Length && !visited[itemIndex + 1])\\n                {\\n                    visited[itemIndex + 1] = true;\\n                    queue.Enqueue((itemIndex + 1, depth + 1));\\n\\n                    if (arr.Length - 1 == itemIndex + 1)\\n                    {\\n                        return depth + 1;\\n                    }\\n                }\\n\\n                foreach (var numIndex in moveDict[currentItem])\\n                {\\n                    if (!visited[numIndex])\\n                    {\\n                        visited[numIndex] = true;\\n                        queue.Enqueue((numIndex, depth + 1));\\n\\n                        if (arr.Length - 1 == numIndex)\\n                        {\\n                            return depth + 1;\\n                        }\\n                    }\\n                }\\n\\n                moveDict[currentItem] = new HashSet<int>();\\n            }\\n\\n            return -1;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n    {\\n        public int MinJumps(int[] arr)\\n        {\\n            var moveDict = new Dictionary<int, HashSet<int>>();\\n\\n            for (int i = 0; i < arr.Length; i++)\\n            {\\n                if (!moveDict.ContainsKey(arr[i]))\\n                {\\n                    moveDict[arr[i]] = new HashSet<int>();\\n                }\\n\\n                moveDict[arr[i]].Add(i);\\n            }\\n\\n            var visited = new bool[arr.Length];\\n            visited[0] = true;\\n            var queue = new Queue<(int, int)>();\\n            queue.Enqueue((0, 0));\\n\\n            while (queue.Count > 0)\\n            {\\n                var (itemIndex, depth) = queue.Dequeue();\\n\\n                var currentItem = arr[itemIndex];\\n\\n                if (itemIndex == arr.Length - 1)\\n                {\\n                    return depth;\\n                }\\n\\n                if (arr[arr.Length - 1] == currentItem)\\n                {\\n                    return depth + 1;\\n                }\\n\\n                if (itemIndex > 0 && !visited[itemIndex - 1])\\n                {\\n                    visited[itemIndex - 1] = true;\\n                    queue.Enqueue((itemIndex - 1, depth + 1));\\n\\n                    if (arr.Length - 1 == itemIndex - 1)\\n                    {\\n                        return depth + 1;\\n                    }\\n                }\\n\\n                if (itemIndex < arr.Length && !visited[itemIndex + 1])\\n                {\\n                    visited[itemIndex + 1] = true;\\n                    queue.Enqueue((itemIndex + 1, depth + 1));\\n\\n                    if (arr.Length - 1 == itemIndex + 1)\\n                    {\\n                        return depth + 1;\\n                    }\\n                }\\n\\n                foreach (var numIndex in moveDict[currentItem])\\n                {\\n                    if (!visited[numIndex])\\n                    {\\n                        visited[numIndex] = true;\\n                        queue.Enqueue((numIndex, depth + 1));\\n\\n                        if (arr.Length - 1 == numIndex)\\n                        {\\n                            return depth + 1;\\n                        }\\n                    }\\n                }\\n\\n                moveDict[currentItem] = new HashSet<int>();\\n            }\\n\\n            return -1;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257797,
                "title": "php-solution-beats-100-at-runtime-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a Breadth-First Search (BFS) algorithm.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea behind using BFS is to consider the indices of the array as nodes in a graph and the valid jumps between indices as edges in the graph. We can start the BFS from index 0 and keep track of the minimum number of steps required to reach each index. We can terminate the BFS as soon as we reach the last index, since that will give us the minimum number of steps required to reach the end.\\n\\nDuring the BFS, we need to consider three types of jumps: forward jumps to the next index, backward jumps to the previous index, and jumps to indices with the same value. We can use a queue to keep track of the nodes to be visited, and a visited array to avoid visiting the same node multiple times.\\n\\nOne optimization we can make is to pre-process the input array and create a mapping of each value to its indices. This will allow us to quickly identify the indices that can be reached by jumping to a value, without having to search the entire array every time.\\n\\n# Complexity\\n- Time complexity: O(n + v), where n is the length of the input array `arr` and v is the number of distinct values in `arr`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n + v)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $arr\\n     * @return Integer\\n     */\\n    function minJumps($arr) {\\n        $n = count($arr);\\n        if ($n == 1) {\\n            return 0;\\n        }\\n        // Create a mapping of each value to its indices\\n        $valueToIndices = [];\\n        for ($i = 0; $i < $n; $i++) {\\n            $value = $arr[$i];\\n            if (!isset($valueToIndices[$value])) {\\n                $valueToIndices[$value] = [];\\n            }\\n            $valueToIndices[$value][] = $i;\\n        }\\n        // Perform BFS starting from index 0\\n        $queue = new SplQueue();\\n        $queue->enqueue([0, 0]); // [index, steps]\\n        $visited = array_fill(0, $n, false);\\n        $visited[0] = true;\\n        while (!$queue->isEmpty()) {\\n            [$index, $steps] = $queue->dequeue();\\n            if ($index == $n - 1) {\\n                return $steps;\\n            }\\n            // Try jumping to the next index\\n            if ($index + 1 < $n && !$visited[$index + 1]) {\\n                $queue->enqueue([$index + 1, $steps + 1]);\\n                $visited[$index + 1] = true;\\n            }\\n            // Try jumping to the previous index\\n            if ($index - 1 >= 0 && !$visited[$index - 1]) {\\n                $queue->enqueue([$index - 1, $steps + 1]);\\n                $visited[$index - 1] = true;\\n            }\\n            // Try jumping to indices with the same value\\n            $value = $arr[$index];\\n            if (isset($valueToIndices[$value])) {\\n                foreach ($valueToIndices[$value] as $nextIndex) {\\n                    if ($nextIndex != $index && !$visited[$nextIndex]) {\\n                        $queue->enqueue([$nextIndex, $steps + 1]);\\n                        $visited[$nextIndex] = true;\\n                    }\\n                }\\n                unset($valueToIndices[$value]); // optimization to avoid redundant checks\\n            }\\n        }\\n        return -1; // unreachable\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $arr\\n     * @return Integer\\n     */\\n    function minJumps($arr) {\\n        $n = count($arr);\\n        if ($n == 1) {\\n            return 0;\\n        }\\n        // Create a mapping of each value to its indices\\n        $valueToIndices = [];\\n        for ($i = 0; $i < $n; $i++) {\\n            $value = $arr[$i];\\n            if (!isset($valueToIndices[$value])) {\\n                $valueToIndices[$value] = [];\\n            }\\n            $valueToIndices[$value][] = $i;\\n        }\\n        // Perform BFS starting from index 0\\n        $queue = new SplQueue();\\n        $queue->enqueue([0, 0]); // [index, steps]\\n        $visited = array_fill(0, $n, false);\\n        $visited[0] = true;\\n        while (!$queue->isEmpty()) {\\n            [$index, $steps] = $queue->dequeue();\\n            if ($index == $n - 1) {\\n                return $steps;\\n            }\\n            // Try jumping to the next index\\n            if ($index + 1 < $n && !$visited[$index + 1]) {\\n                $queue->enqueue([$index + 1, $steps + 1]);\\n                $visited[$index + 1] = true;\\n            }\\n            // Try jumping to the previous index\\n            if ($index - 1 >= 0 && !$visited[$index - 1]) {\\n                $queue->enqueue([$index - 1, $steps + 1]);\\n                $visited[$index - 1] = true;\\n            }\\n            // Try jumping to indices with the same value\\n            $value = $arr[$index];\\n            if (isset($valueToIndices[$value])) {\\n                foreach ($valueToIndices[$value] as $nextIndex) {\\n                    if ($nextIndex != $index && !$visited[$nextIndex]) {\\n                        $queue->enqueue([$nextIndex, $steps + 1]);\\n                        $visited[$nextIndex] = true;\\n                    }\\n                }\\n                unset($valueToIndices[$value]); // optimization to avoid redundant checks\\n            }\\n        }\\n        return -1; // unreachable\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929800,
                "title": "python-3-fast-95-easy-to-understand",
                "content": "![image.png](https://assets.leetcode.com/users/images/9d93c549-98f0-408a-9d6f-a2623aba7506_1671480630.9626029.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        \\n        queue    = deque()  \\n        dct      = defaultdict(list)\\n        vstd_ndx = set()    # 2 memorizations:   vstd_ndx - for visited indexes    \\n        vstd_val = set()    #                    vstd_val - for visited values  (arr[ndx])\\n        \\n        # create dictionary {val: [ndx_100, ndx_99 ...]}\\n        # we ordered indexes in descending order \\n        # so that we could reduce number of iterations\\n        arr_l = len(arr)\\n        for i in range(arr_l - 1, -1, -1):\\n            dct[arr[i]].append(i)\\n        \\n        st_nmb = 0       # number of steps\\n        queue.append(0)  # start from index 0\\n        while queue:\\n            for _ in range(len(queue)): # iterate level by level\\n                ndx = queue.popleft()   # FIFO method: take index from the left (and add to the right)\\n                \\n                if ndx in vstd_ndx:    continue\\n                if ndx == arr_l - 1:   return st_nmb\\n                vstd_ndx.add(ndx)      # add current index to visited set\\n\\n                val = arr[ndx]\\n                if val not in vstd_val:  \\n                    queue.extend(dct[val])  # add all indexes with the same value\\n                    vstd_val.add(val)       # add current value to visited set\\n                if ndx < arr_l:   queue.append(ndx + 1) # add index to the right\\n                if ndx > 0:       queue.append(ndx - 1) # add index to the left\\n             \\n            st_nmb += 1   # increase number of steps by one\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        \\n        queue    = deque()  \\n        dct      = defaultdict(list)\\n        vstd_ndx = set()    # 2 memorizations:   vstd_ndx - for visited indexes    \\n        vstd_val = set()    #                    vstd_val - for visited values  (arr[ndx])\\n        \\n        # create dictionary {val: [ndx_100, ndx_99 ...]}\\n        # we ordered indexes in descending order \\n        # so that we could reduce number of iterations\\n        arr_l = len(arr)\\n        for i in range(arr_l - 1, -1, -1):\\n            dct[arr[i]].append(i)\\n        \\n        st_nmb = 0       # number of steps\\n        queue.append(0)  # start from index 0\\n        while queue:\\n            for _ in range(len(queue)): # iterate level by level\\n                ndx = queue.popleft()   # FIFO method: take index from the left (and add to the right)\\n                \\n                if ndx in vstd_ndx:    continue\\n                if ndx == arr_l - 1:   return st_nmb\\n                vstd_ndx.add(ndx)      # add current index to visited set\\n\\n                val = arr[ndx]\\n                if val not in vstd_val:  \\n                    queue.extend(dct[val])  # add all indexes with the same value\\n                    vstd_val.add(val)       # add current value to visited set\\n                if ndx < arr_l:   queue.append(ndx + 1) # add index to the right\\n                if ndx > 0:       queue.append(ndx - 1) # add index to the left\\n             \\n            st_nmb += 1   # increase number of steps by one\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877943,
                "title": "bfs-detail-explanation-with-analysis-efficient-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs this is a minimum path problem, the first thing to click into our mind would be using **BFS**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will perform an interative bfs. But we have to be careful of recalculating the same steps. For this, we will need an array of **boolean[] visited** to keep track of the visited **indices**. Also, when iterating for same values, we will ignore that. For this reason, when the value is first calculated in the queue, we will remove all the indices of the same value element. This way we can make this problem efficient. I got TLE several times while solving this problem.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nUsing BFS would take time complexity of *O(n+k)*. Here, *n* is the number of elements and the *k* is the maximum edge connecting an element. In worst case, all the elements can be same. But as we are not calculating repeating elements, it is good to go. The time complexity will stay around *O(n)*.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs we are keeping a queue and also Clearing it out. There won\\'t be all the *n* elements at one time in the queue. But we have also used an array of **boolean[] visited** which is of size *n*. So, the space complexity would be *O(n)*.\\n# Code\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int len = arr.length;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i=0; i<len; i++){\\n            map.computeIfAbsent(arr[i], x -> new LinkedList<>()).add(i);\\n        }\\n        boolean[] visited = new boolean[len];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        visited[0] = true;\\n        int stepsTaken = -1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            stepsTaken++;\\n            while(size-->0){\\n                int idx = q.remove();\\n                if(idx==len-1)\\n                    return stepsTaken;\\n                List<Integer> next = map.get(arr[idx]);\\n                next.add(idx-1); next.add(idx+1);\\n                for(int i : next){\\n                    if(i>=0 && i<len && !visited[i]){\\n                        visited[i] = true;\\n                        q.offer(i);\\n                    }\\n                }\\n                map.get(arr[idx]).clear();\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/58ea33a3-d47b-44a1-9a1e-7af583173d20_1670178091.0691743.png)\\n![image](https://assets.leetcode.com/users/images/0ad03c10-9b0d-4d2c-8451-bb5a171c70ff_1670178117.9879165.png)\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int len = arr.length;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i=0; i<len; i++){\\n            map.computeIfAbsent(arr[i], x -> new LinkedList<>()).add(i);\\n        }\\n        boolean[] visited = new boolean[len];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        visited[0] = true;\\n        int stepsTaken = -1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            stepsTaken++;\\n            while(size-->0){\\n                int idx = q.remove();\\n                if(idx==len-1)\\n                    return stepsTaken;\\n                List<Integer> next = map.get(arr[idx]);\\n                next.add(idx-1); next.add(idx+1);\\n                for(int i : next){\\n                    if(i>=0 && i<len && !visited[i]){\\n                        visited[i] = true;\\n                        q.offer(i);\\n                    }\\n                }\\n                map.get(arr[idx]).clear();\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839288,
                "title": "c-bfs-model-problem-as-the-graph-problem",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> graph;\\n        int n = arr.size();\\n        for (int i = 0; i < n; ++i) {\\n            graph[arr[i]].push_back(i);\\n        }\\n        auto isValid = [&] (const int _n) {\\n            return (_n >= 0 && _n < n);  \\n        };\\n        //this problem can also be modeled as the graph problems\\n        //where the adjancent cells are\\n        //(i - 1), (i + 1) indices and all the indices where arr[i] is present\\n        int steps = 0;\\n        queue<int> q;\\n        //since we are already doing the BFS on \\n        //array indices, so dont need to create a graph out of it\\n        q.push(0);\\n        vector<bool> vis(n, 0);\\n        while(q.size() > 0) {\\n            int N = q.size();\\n            while(N--) {\\n                int node = q.front();\\n                q.pop();\\n                if (node == n - 1) return steps;\\n                for (int child: graph[arr[node]]) {\\n                    if (!vis[child]) {\\n                        q.push(child);\\n                        vis[child] = 1;\\n                    }\\n                }\\n                graph[arr[node]].clear();\\n                vis[node] = true;\\n                int dir[] = {-1, 1};\\n                for (int i = 0; i < 2; ++i) {\\n                    int _node = node + dir[i];\\n                    if (isValid(_node) && !vis[_node]) {\\n                        q.push(_node);\\n                        vis[_node] = 1;\\n                    }\\n                }\\n            }\\n            ++steps;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> graph;\\n        int n = arr.size();\\n        for (int i = 0; i < n; ++i) {\\n            graph[arr[i]].push_back(i);\\n        }\\n        auto isValid = [&] (const int _n) {\\n            return (_n >= 0 && _n < n);  \\n        };\\n        //this problem can also be modeled as the graph problems\\n        //where the adjancent cells are\\n        //(i - 1), (i + 1) indices and all the indices where arr[i] is present\\n        int steps = 0;\\n        queue<int> q;\\n        //since we are already doing the BFS on \\n        //array indices, so dont need to create a graph out of it\\n        q.push(0);\\n        vector<bool> vis(n, 0);\\n        while(q.size() > 0) {\\n            int N = q.size();\\n            while(N--) {\\n                int node = q.front();\\n                q.pop();\\n                if (node == n - 1) return steps;\\n                for (int child: graph[arr[node]]) {\\n                    if (!vis[child]) {\\n                        q.push(child);\\n                        vis[child] = 1;\\n                    }\\n                }\\n                graph[arr[node]].clear();\\n                vis[node] = true;\\n                int dir[] = {-1, 1};\\n                for (int i = 0; i < 2; ++i) {\\n                    int _node = node + dir[i];\\n                    if (isValid(_node) && !vis[_node]) {\\n                        q.push(_node);\\n                        vis[_node] = 1;\\n                    }\\n                }\\n            }\\n            ++steps;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815095,
                "title": "sketch-explains-better-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n![1871. Jump Game IV.png](https://assets.leetcode.com/users/images/cda2f5c0-384c-43a5-b752-72ba954e57ec_1668451790.7851596.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n> *Next indices* for index `i` are the indices that can be reached from index `i` by doing just one jump\\n\\n> index `i`\\'s next indices are:\\n>  1. index `i - 1`\\n>   2. index `i + 1`\\n>   3. all indices that have same value as index `i`\\n>   ** All these next indices have same minimum jumps = `dp[i] + 1` (assuming the next indices haven\\'t been processed already)\\n\\n> How to find the next indices `i` ?\\n    1.Create a Map `indices`: map each value to list of indices having same value\\n    2.Now the next indices of index `i` are `i+1`, `i-1`, and `indices.get(arr[i])`\\n\\n\\n1. Create a `dp[]` that stores minimum jumps needed for each index.\\n\\n3. Start by adding index `0` to the queue with current`jump = 0`\\n\\n4. Now for each index `i` in the queue do\\n    * poll `i` from the queue\\n    * `dp[i] = jump` and\\n    *  add the `i`\\'s next indices to the queue\\n    >**Important for O(n) and not getting TLE**:\\n    It is possible that `i`\\'s next indices are already in the queue. So adding it again makes no sense. So use a `visiting` boolean array or set  that tells you if it has been added in the queue already so you can avoid adding duplicates. \\n\\n5. Do `jump++`\\n\\n6. Repeat steps 4, 5 until queue is empty\\n7. Return `dp[n-1]`\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        boolean[] processed = new boolean[n]; // tells if dp[i] is calculated\\n        Set<Integer> visiting = new HashSet<>(); // for optimization. tells if arr[i] in queue\\n        Map<Integer, List<Integer>> indices = new HashMap<>(); // Map value to indices having same value\\n\\n        // construct the map\\n        for (int i = 0; i < n; i++) indices.computeIfAbsent(arr[i], (key) -> new ArrayList<>()).add(i);\\n\\n        Queue<Integer> positionsToProcess = new ArrayDeque<>();\\n        positionsToProcess.add(0);\\n\\n        // do BFS and each BFS level represents no of jumps.\\n        int jumps = 0;\\n        while (!positionsToProcess.isEmpty()) {\\n            int queueLength = positionsToProcess.size();\\n\\n            for (int i = 0; i < queueLength; i++) {\\n\\n                int position = positionsToProcess.poll();\\n                if (processed[position]) continue;\\n                dp[position] = jumps;\\n                processed[position] = true;\\n\\n                // add only those next jump indices that are not already in the queue\\n                if (position - 1 >= 0 && !visiting.contains(arr[position - 1]))\\n                    positionsToProcess.add(position - 1);\\n                if (position + 1 < n && !visiting.contains(arr[position + 1]))\\n                    positionsToProcess.add(position + 1);\\n                if (!visiting.contains(arr[position]))\\n                    positionsToProcess.addAll(indices.get(arr[position]));\\n\\n                visiting.add(arr[position]);\\n            }\\n\\n            jumps++;\\n        }\\n\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        boolean[] processed = new boolean[n]; // tells if dp[i] is calculated\\n        Set<Integer> visiting = new HashSet<>(); // for optimization. tells if arr[i] in queue\\n        Map<Integer, List<Integer>> indices = new HashMap<>(); // Map value to indices having same value\\n\\n        // construct the map\\n        for (int i = 0; i < n; i++) indices.computeIfAbsent(arr[i], (key) -> new ArrayList<>()).add(i);\\n\\n        Queue<Integer> positionsToProcess = new ArrayDeque<>();\\n        positionsToProcess.add(0);\\n\\n        // do BFS and each BFS level represents no of jumps.\\n        int jumps = 0;\\n        while (!positionsToProcess.isEmpty()) {\\n            int queueLength = positionsToProcess.size();\\n\\n            for (int i = 0; i < queueLength; i++) {\\n\\n                int position = positionsToProcess.poll();\\n                if (processed[position]) continue;\\n                dp[position] = jumps;\\n                processed[position] = true;\\n\\n                // add only those next jump indices that are not already in the queue\\n                if (position - 1 >= 0 && !visiting.contains(arr[position - 1]))\\n                    positionsToProcess.add(position - 1);\\n                if (position + 1 < n && !visiting.contains(arr[position + 1]))\\n                    positionsToProcess.add(position + 1);\\n                if (!visiting.contains(arr[position]))\\n                    positionsToProcess.addAll(indices.get(arr[position]));\\n\\n                visiting.add(arr[position]);\\n            }\\n\\n            jumps++;\\n        }\\n\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775990,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>>mp;  \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<bool>vis(arr.size(),false);   \\n        \\n        int ans=INT_MAX;\\n        \\n        queue<pair<pair<int,int>,int>>q;  \\n        \\n        q.push({{arr[0],0},0});\\n        \\n        while(!q.empty())\\n        {\\n            int idx=q.front().second;\\n            int c=q.front().first.second;\\n            int ele=q.front().first.first;\\n            \\n            if(vis[idx]==false)\\n            {\\n                vis[idx]=true;\\n            }\\n            \\n            if(idx==arr.size()-1)\\n            {\\n                ans=min(ans,c);\\n            }\\n            \\n            q.pop();\\n            \\n            if(idx>0 and vis[idx-1]==false)\\n            {\\n                q.push({{arr[idx-1],c+1},idx-1});\\n                vis[idx-1]=true;\\n            }\\n            \\n            if(idx<arr.size()-1 and vis[idx+1]==false)\\n            {\\n                q.push({{arr[idx+1],c+1},idx+1});\\n                vis[idx+1]=true;\\n            }\\n            \\n            for(int j=0;j<mp[ele].size();j++)\\n            {\\n                if(mp[ele][j]!=idx and vis[mp[ele][j]]==false)\\n                {\\n                    q.push({{ele,c+1},mp[ele][j]});\\n                    vis[mp[ele][j]]=true;\\n                }\\n            }\\n            mp[ele].clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>>mp;  \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<bool>vis(arr.size(),false);   \\n        \\n        int ans=INT_MAX;\\n        \\n        queue<pair<pair<int,int>,int>>q;  \\n        \\n        q.push({{arr[0],0},0});\\n        \\n        while(!q.empty())\\n        {\\n            int idx=q.front().second;\\n            int c=q.front().first.second;\\n            int ele=q.front().first.first;\\n            \\n            if(vis[idx]==false)\\n            {\\n                vis[idx]=true;\\n            }\\n            \\n            if(idx==arr.size()-1)\\n            {\\n                ans=min(ans,c);\\n            }\\n            \\n            q.pop();\\n            \\n            if(idx>0 and vis[idx-1]==false)\\n            {\\n                q.push({{arr[idx-1],c+1},idx-1});\\n                vis[idx-1]=true;\\n            }\\n            \\n            if(idx<arr.size()-1 and vis[idx+1]==false)\\n            {\\n                q.push({{arr[idx+1],c+1},idx+1});\\n                vis[idx+1]=true;\\n            }\\n            \\n            for(int j=0;j<mp[ele].size();j++)\\n            {\\n                if(mp[ele][j]!=idx and vis[mp[ele][j]]==false)\\n                {\\n                    q.push({{ele,c+1},mp[ele][j]});\\n                    vis[mp[ele][j]]=true;\\n                }\\n            }\\n            mp[ele].clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730977,
                "title": "bfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<int>vis;\\n    unordered_map<int,vector<int>>mp;\\n    int minJumps(vector<int>& arr) \\n    {\\n        //preprocessing\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n\\n        queue<int>q;\\n        q.push(0);\\n\\n        int steps=0;\\n\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n\\n            for(int j=0;j<size;j++)\\n            {\\n               int i = q.front();\\n               q.pop();\\n\\n               vis.insert(i);\\n\\n               if(i==arr.size()-1)\\n               {\\n                  return steps;\\n               }\\n\\n                //i+1\\n               if((i+1)<arr.size() and vis.find(i+1)==vis.end())\\n               {\\n                  q.push(i+1);\\n                  vis.insert(i+1);\\n               }\\n               if((i-1)>=0 and vis.find(i-1)==vis.end())\\n               {\\n                  q.push(i-1);\\t\\n                  vis.insert(i-1);\\n               }\\t\\n               if(mp[arr[i]].size()>0)\\n               {\\n                  for(auto pos : mp[arr[i]])\\n                  {\\n                     if(vis.find(pos)==vis.end())\\n                     q.push(pos);\\n                  }  \\n                  mp[arr[i]].clear();\\n               }\\n               \\n            }\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<int>vis;\\n    unordered_map<int,vector<int>>mp;\\n    int minJumps(vector<int>& arr) \\n    {\\n        //preprocessing\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n\\n        queue<int>q;\\n        q.push(0);\\n\\n        int steps=0;\\n\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n\\n            for(int j=0;j<size;j++)\\n            {\\n               int i = q.front();\\n               q.pop();\\n\\n               vis.insert(i);\\n\\n               if(i==arr.size()-1)\\n               {\\n                  return steps;\\n               }\\n\\n                //i+1\\n               if((i+1)<arr.size() and vis.find(i+1)==vis.end())\\n               {\\n                  q.push(i+1);\\n                  vis.insert(i+1);\\n               }\\n               if((i-1)>=0 and vis.find(i-1)==vis.end())\\n               {\\n                  q.push(i-1);\\t\\n                  vis.insert(i-1);\\n               }\\t\\n               if(mp[arr[i]].size()>0)\\n               {\\n                  for(auto pos : mp[arr[i]])\\n                  {\\n                     if(vis.find(pos)==vis.end())\\n                     q.push(pos);\\n                  }  \\n                  mp[arr[i]].clear();\\n               }\\n               \\n            }\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730258,
                "title": "c-bfs-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>>mp;  //map will store the index of duplicates\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<bool>vis(arr.size(),false);   \\n        \\n        int ans=INT_MAX;\\n        \\n        queue<pair<pair<int,int>,int>>q;  // {{steps,ele},idx}\\n        \\n        q.push({{arr[0],0},0});\\n        \\n        while(!q.empty())\\n        {\\n            int idx=q.front().second;\\n            int c=q.front().first.second;\\n            int ele=q.front().first.first;\\n            \\n            if(vis[idx]==false)\\n            {\\n                vis[idx]=true;\\n            }\\n            \\n            if(idx==arr.size()-1)\\n            {\\n                ans=min(ans,c);\\n            }\\n            \\n            q.pop();\\n            \\n            if(idx>0 and vis[idx-1]==false)\\n            {\\n                q.push({{arr[idx-1],c+1},idx-1});\\n                vis[idx-1]=true;\\n            }\\n            \\n            if(idx<arr.size()-1 and vis[idx+1]==false)\\n            {\\n                q.push({{arr[idx+1],c+1},idx+1});\\n                vis[idx+1]=true;\\n            }\\n            \\n            for(int j=0;j<mp[ele].size();j++)\\n            {\\n                if(mp[ele][j]!=idx and vis[mp[ele][j]]==false)\\n                {\\n                    q.push({{ele,c+1},mp[ele][j]});\\n                    vis[mp[ele][j]]=true;\\n                }\\n            }\\n            mp[ele].clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>>mp;  //map will store the index of duplicates\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<bool>vis(arr.size(),false);   \\n        \\n        int ans=INT_MAX;\\n        \\n        queue<pair<pair<int,int>,int>>q;  // {{steps,ele},idx}\\n        \\n        q.push({{arr[0],0},0});\\n        \\n        while(!q.empty())\\n        {\\n            int idx=q.front().second;\\n            int c=q.front().first.second;\\n            int ele=q.front().first.first;\\n            \\n            if(vis[idx]==false)\\n            {\\n                vis[idx]=true;\\n            }\\n            \\n            if(idx==arr.size()-1)\\n            {\\n                ans=min(ans,c);\\n            }\\n            \\n            q.pop();\\n            \\n            if(idx>0 and vis[idx-1]==false)\\n            {\\n                q.push({{arr[idx-1],c+1},idx-1});\\n                vis[idx-1]=true;\\n            }\\n            \\n            if(idx<arr.size()-1 and vis[idx+1]==false)\\n            {\\n                q.push({{arr[idx+1],c+1},idx+1});\\n                vis[idx+1]=true;\\n            }\\n            \\n            for(int j=0;j<mp[ele].size();j++)\\n            {\\n                if(mp[ele][j]!=idx and vis[mp[ele][j]]==false)\\n                {\\n                    q.push({{ele,c+1},mp[ele][j]});\\n                    vis[mp[ele][j]]=true;\\n                }\\n            }\\n            mp[ele].clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499078,
                "title": "jump-game-iv-c-bfs-with-explaination-96-17-faster",
                "content": "O(N) Time and Space Complexity\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        \\n        // map stores all the indices of each unique element\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        \\n        // visited make sures that i always visit unvisited indices\\n        vector<bool> visited(n,false); \\n        queue<int> q;\\n        \\n        visited[0] = true; //visiting the first index \\n        q.push(0);\\n        \\n        int count = 0;\\n        while (!q.empty()) \\n        {\\n            int size = q.size();\\n            // traversing on size so that i can maintain the count of levels as we have to return the shortest path\\n            for (int i = 0;i < size;i++) \\n            {\\n                //visiting the index at front of queue\\n                int front = q.front();\\n                q.pop();\\n                visited[front] = true;\\n                \\n                //if front comes out to be last index then simply return true\\n                if (front == n - 1)\\n                {\\n                    return count;// Reached to last index\\n                }\\n                \\n                vector<int>& next = mp[arr[front]];\\n                if(front - 1 >= 0 && !visited[front-1])\\n                {\\n                    next.push_back(front - 1); \\n                }\\n                if(front + 1 < n && !visited[front+1])\\n                {\\n                    next.push_back(front + 1);\\n                }\\n                // next finally stores all the possible next steps from the front index\\n                \\n                //we travers on all the possible next steps \\n                for (int j : next) \\n                {\\n                    //if the next step we try to visit is already visited then there is no point in visiting the same visited node again\\n                    if (!visited[j]) \\n                    {\\n                        //mark the index as visited\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                next.clear(); // avoid later lookup mp[arr[i]]\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        \\n        // map stores all the indices of each unique element\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        \\n        // visited make sures that i always visit unvisited indices\\n        vector<bool> visited(n,false); \\n        queue<int> q;\\n        \\n        visited[0] = true; //visiting the first index \\n        q.push(0);\\n        \\n        int count = 0;\\n        while (!q.empty()) \\n        {\\n            int size = q.size();\\n            // traversing on size so that i can maintain the count of levels as we have to return the shortest path\\n            for (int i = 0;i < size;i++) \\n            {\\n                //visiting the index at front of queue\\n                int front = q.front();\\n                q.pop();\\n                visited[front] = true;\\n                \\n                //if front comes out to be last index then simply return true\\n                if (front == n - 1)\\n                {\\n                    return count;// Reached to last index\\n                }\\n                \\n                vector<int>& next = mp[arr[front]];\\n                if(front - 1 >= 0 && !visited[front-1])\\n                {\\n                    next.push_back(front - 1); \\n                }\\n                if(front + 1 < n && !visited[front+1])\\n                {\\n                    next.push_back(front + 1);\\n                }\\n                // next finally stores all the possible next steps from the front index\\n                \\n                //we travers on all the possible next steps \\n                for (int j : next) \\n                {\\n                    //if the next step we try to visit is already visited then there is no point in visiting the same visited node again\\n                    if (!visited[j]) \\n                    {\\n                        //mark the index as visited\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                next.clear(); // avoid later lookup mp[arr[i]]\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263873,
                "title": "easy-bfs-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>> mp;\\n        int n = arr.size();\\n        // putting elements in map\\n        for(int i=0;i<n;i++) {\\n            mp[arr[i]].push_back(i);\\n        }\\n        // bfs for shortest path\\n        queue<int> q;\\n        q.push(0); // start index\\n        vector<bool> visited(n, false);\\n        visited[0] = true;\\n        int cnt = 0;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            while(sz--) {\\n                int curr = q.front(); q.pop();\\n                if(curr == n-1)\\n                    return cnt;\\n                if(curr-1 >= 0 && !visited[curr-1]) {\\n                    visited[curr-1] = true;\\n                    q.push(curr-1);\\n                }\\n                if(curr+1<n && !visited[curr+1]) {\\n                    visited[curr+1] = true;\\n                    q.push(curr+1);\\n                }\\n                if(mp.count(arr[curr])) {\\n                    // cout << curr << endl;\\n                    for(int indx : mp[arr[curr]]) {\\n                        if(indx != curr && !visited[indx]) {\\n                            visited[indx] = true;\\n                            q.push(indx);\\n                        }\\n                    }\\n                }\\n                mp.erase(arr[curr]); // to stop recomputing the on the same index \\n            }\\n            cnt++;\\n        }\\n        return -1; // return -1 if can\\'t reach end of the array\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>> mp;\\n        int n = arr.size();\\n        // putting elements in map\\n        for(int i=0;i<n;i++) {\\n            mp[arr[i]].push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2258178,
                "title": "java-all-jump-game-solutions",
                "content": "https://leetcode.com/problems/jump-game/\\n**55. Jump Game: `TC: / SC: O(n) / O(1)`**\\n```\\n    public boolean canJump(int[] nums) {\\n        int max_reach = 0;\\n        \\n        for(int i =0; i < nums.length; i++) {\\n            if(i > max_reach) return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        \\n        return true;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-ii/\\n**45. Jump Game II: `TC: / SC: O(n) / O(1)`**\\n```\\n    public int jump(int[] nums) {\\n        if(nums.length == 1) return 0;\\n        \\n        int temp = 0, max = 0, count = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > temp) {\\n                temp = max;\\n                max = 0;\\n                count++;\\n            }\\n            max = Math.max(max, nums[i] + i);\\n        }\\n        \\n        return count;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-iii/\\n**1306. Jump Game III: `TC: / SC: O(n) / O(n)`**\\n```\\n    public static boolean[] jumped;\\n    public boolean canReach(int[] arr, int start) {\\n        jumped = new boolean[arr.length];\\n        \\n        return check(arr, start);\\n    }\\n    public boolean check(int[] arr, int i) {\\n        if(i >= arr.length || i < 0 || jumped[i]) return false;\\n        if(arr[i] == 0) return true;\\n        jumped[i] = true;\\n        \\n        return check(arr, i + arr[i]) || check(arr, i - arr[i]);\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-iv/\\n\\u2705**1345. Jump Game IV: `TC: / SC: O(n) / O(n)`**\\n```\\n    public int minJumps(int[] arr) {\\n        int steps = 0;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < arr.length; i++) \\n            map.computeIfAbsent(arr[i], li -> new ArrayList()).add(i);\\n        \\n        boolean[] jumped = new boolean[arr.length]; \\n        jumped[0] = true;\\n        Queue<Integer> q = new LinkedList<>(); \\n        q.offer(0);\\n        \\n        while(!q.isEmpty()) {\\n            for(int i = q.size(); i > 0; i--) {\\n                int temp = q.poll();\\n                if(temp == arr.length - 1) return steps;\\n                \\n                List<Integer> li = map.get(arr[temp]);\\n                if(temp != 0) li.add(temp - 1);\\n                if(temp != arr.length) li.add(temp + 1);\\n                \\n                for(int j : li) {\\n                    if(!jumped[j]) {\\n                        jumped[j] = true;\\n                        q.offer(j);\\n                    }\\n                }\\n                li.clear();\\n            }\\n            steps++;\\n        }\\n        \\n        return 0;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-vi/submissions/\\n**1696. Jump Game VI: `TC: / SC: O(n) / O(n)`**\\n```\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        dq.offer(0);\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[dq.peekFirst()];\\n            \\n            while(!dq.isEmpty() && nums[dq.peekLast()] <= nums[i])\\n                dq.pollLast();\\n            dq.offer(i);\\n            \\n            if(i - dq.peekFirst() >= k) dq.pollFirst();\\n        } \\n        \\n        return nums[nums.length - 1];\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-vii/submissions/\\n**1871. Jump Game VII: `TC: / SC: O(n) / O(n)`**\\n```\\n    public boolean canReach(String s, int minJump, int maxJump) {\\n        int n = s.length(), available = 0;\\n        if(s.charAt(n - 1) == \\'1\\') return false;\\n        \\n        boolean[] dp = new boolean[n];\\n        dp[0] = true;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(i >= minJump) available += dp[i - minJump] ? 1 : 0;\\n            if(i > maxJump) available -= dp[i - maxJump - 1] ? 1 : 0;\\n            \\n            dp[i] = available > 0 && s.charAt(i) == \\'0\\';\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n    public boolean canJump(int[] nums) {\\n        int max_reach = 0;\\n        \\n        for(int i =0; i < nums.length; i++) {\\n            if(i > max_reach) return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        \\n        return true;\\n    }\\n```\n```\\n    public int jump(int[] nums) {\\n        if(nums.length == 1) return 0;\\n        \\n        int temp = 0, max = 0, count = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > temp) {\\n                temp = max;\\n                max = 0;\\n                count++;\\n            }\\n            max = Math.max(max, nums[i] + i);\\n        }\\n        \\n        return count;\\n    }\\n```\n```\\n    public static boolean[] jumped;\\n    public boolean canReach(int[] arr, int start) {\\n        jumped = new boolean[arr.length];\\n        \\n        return check(arr, start);\\n    }\\n    public boolean check(int[] arr, int i) {\\n        if(i >= arr.length || i < 0 || jumped[i]) return false;\\n        if(arr[i] == 0) return true;\\n        jumped[i] = true;\\n        \\n        return check(arr, i + arr[i]) || check(arr, i - arr[i]);\\n    }\\n```\n```\\n    public int minJumps(int[] arr) {\\n        int steps = 0;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < arr.length; i++) \\n            map.computeIfAbsent(arr[i], li -> new ArrayList()).add(i);\\n        \\n        boolean[] jumped = new boolean[arr.length]; \\n        jumped[0] = true;\\n        Queue<Integer> q = new LinkedList<>(); \\n        q.offer(0);\\n        \\n        while(!q.isEmpty()) {\\n            for(int i = q.size(); i > 0; i--) {\\n                int temp = q.poll();\\n                if(temp == arr.length - 1) return steps;\\n                \\n                List<Integer> li = map.get(arr[temp]);\\n                if(temp != 0) li.add(temp - 1);\\n                if(temp != arr.length) li.add(temp + 1);\\n                \\n                for(int j : li) {\\n                    if(!jumped[j]) {\\n                        jumped[j] = true;\\n                        q.offer(j);\\n                    }\\n                }\\n                li.clear();\\n            }\\n            steps++;\\n        }\\n        \\n        return 0;\\n    }\\n```\n```\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        dq.offer(0);\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[dq.peekFirst()];\\n            \\n            while(!dq.isEmpty() && nums[dq.peekLast()] <= nums[i])\\n                dq.pollLast();\\n            dq.offer(i);\\n            \\n            if(i - dq.peekFirst() >= k) dq.pollFirst();\\n        } \\n        \\n        return nums[nums.length - 1];\\n    }\\n```\n```\\n    public boolean canReach(String s, int minJump, int maxJump) {\\n        int n = s.length(), available = 0;\\n        if(s.charAt(n - 1) == \\'1\\') return false;\\n        \\n        boolean[] dp = new boolean[n];\\n        dp[0] = true;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(i >= minJump) available += dp[i - minJump] ? 1 : 0;\\n            if(i > maxJump) available -= dp[i - maxJump - 1] ? 1 : 0;\\n            \\n            dp[i] = available > 0 && s.charAt(i) == \\'0\\';\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2191176,
                "title": "java-clean-bfs",
                "content": "```\\nclass Solution {\\n    \\n    private boolean isValidNeighb(int neighb, int n, boolean[] visited) {\\n        if(neighb>=0 && neighb<n && !visited[neighb]) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void populateFreqMap(Map<Integer, List<Integer>> freqMap, int[] arr, int n) {\\n        for(int i = 0; i<n; i++) {\\n            int value = arr[i];\\n            freqMap.putIfAbsent(value, new ArrayList<>());\\n            freqMap.get(value).add(i);\\n        }        \\n    }\\n    \\n    public int minJumps(int[] arr) {\\n        Map<Integer, List<Integer>> freqMap = new HashMap<>();\\n        int n = arr.length;\\n        populateFreqMap(freqMap, arr, n);\\n                                \\n        Queue<Integer> bfs = new LinkedList<>();\\n        boolean[] visited = new boolean[n];  \\n        int distance = 0, destination = n-1; \\n        bfs.add(0);\\n        while(bfs.size() > 0) {\\n          \\n            int size = bfs.size();\\n            for(int i = 0; i<size; i++) {\\n                int front = bfs.poll();\\n                visited[front] = true;\\n                \\n                if(front == destination) {\\n                    return distance;\\n                }\\n                   \\n                int value = arr[front];\\n                List<Integer> neighbList = freqMap.get(value);\\n                neighbList.add(front-1);\\n                neighbList.add(front+1);\\n                \\n                for(Integer neighb : neighbList) {\\n                    if(isValidNeighb(neighb, n, visited)) {\\n                        bfs.add(neighb);\\n                    }\\n                }\\n                \\n                neighbList.clear(); // traverse graph of one value single time, otherwise time complexity will bo n2 when all elements are equal\\n            }\\n            \\n            distance++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private boolean isValidNeighb(int neighb, int n, boolean[] visited) {\\n        if(neighb>=0 && neighb<n && !visited[neighb]) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void populateFreqMap(Map<Integer, List<Integer>> freqMap, int[] arr, int n) {\\n        for(int i = 0; i<n; i++) {\\n            int value = arr[i];\\n            freqMap.putIfAbsent(value, new ArrayList<>());\\n            freqMap.get(value).add(i);\\n        }        \\n    }\\n    \\n    public int minJumps(int[] arr) {\\n        Map<Integer, List<Integer>> freqMap = new HashMap<>();\\n        int n = arr.length;\\n        populateFreqMap(freqMap, arr, n);\\n                                \\n        Queue<Integer> bfs = new LinkedList<>();\\n        boolean[] visited = new boolean[n];  \\n        int distance = 0, destination = n-1; \\n        bfs.add(0);\\n        while(bfs.size() > 0) {\\n          \\n            int size = bfs.size();\\n            for(int i = 0; i<size; i++) {\\n                int front = bfs.poll();\\n                visited[front] = true;\\n                \\n                if(front == destination) {\\n                    return distance;\\n                }\\n                   \\n                int value = arr[front];\\n                List<Integer> neighbList = freqMap.get(value);\\n                neighbList.add(front-1);\\n                neighbList.add(front+1);\\n                \\n                for(Integer neighb : neighbList) {\\n                    if(isValidNeighb(neighb, n, visited)) {\\n                        bfs.add(neighb);\\n                    }\\n                }\\n                \\n                neighbList.clear(); // traverse graph of one value single time, otherwise time complexity will bo n2 when all elements are equal\\n            }\\n            \\n            distance++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099481,
                "title": "bfs-easy-solution",
                "content": "```\\nint minJumps(vector<int>& arr) {\\n if(arr.size()==1)return 0;\\n        map<int,vector<int>>m;\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]].push_back(i);\\n        }\\n        queue<int>q;\\n        \\n        int step=0;\\n       q.push(0);\\n        \\n       \\n        while(!q.empty()){\\n        step++;\\n            int si=q.size();\\n            for(int i=0;i<si;i++){\\n               int t=q.front();\\n                q.pop();\\n                \\n                if(t-1>=0 && m[arr[t-1]].size()>0){\\n                    q.push(t-1);\\n                }\\n                if(t+1<arr.size() && m[arr[t+1]].size()>0){\\n                    if(t+1==arr.size()-1)return step;\\n                    else q.push(t+1);\\n                }\\n                if(m[arr[t]].size()>0){\\n                    for(auto k:m[arr[t]]){\\n                        if(k != t){\\n                            if(k==arr.size()-1)return step;\\n                             else q.push(k);\\n                        }\\n                       \\n                    }\\n                }\\n                  m.erase(arr[t]);\\n            }\\n          \\n            \\n        }\\n        return step;\\n\\t\\t}\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nint minJumps(vector<int>& arr) {\\n if(arr.size()==1)return 0;\\n        map<int,vector<int>>m;\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]].push_back(i);\\n        }\\n        queue<int>q;\\n        \\n        int step=0;\\n       q.push(0);\\n        \\n       \\n        while(!q.empty()){\\n        step++;\\n            int si=q.size();\\n            for(int i=0;i<si;i++){\\n               int t=q.front();\\n                q.pop();\\n                \\n                if(t-1>=0 && m[arr[t-1]].size()>0){\\n                    q.push(t-1);\\n                }\\n                if(t+1<arr.size() && m[arr[t+1]].size()>0){\\n                    if(t+1==arr.size()-1)return step;\\n                    else q.push(t+1);\\n                }\\n                if(m[arr[t]].size()>0){\\n                    for(auto k:m[arr[t]]){\\n                        if(k != t){\\n                            if(k==arr.size()-1)return step;\\n                             else q.push(k);\\n                        }\\n                       \\n                    }\\n                }\\n                  m.erase(arr[t]);\\n            }\\n          \\n            \\n        }\\n        return step;\\n\\t\\t}\\n\\t\\t\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2085575,
                "title": "python-beginner-friendly-without-visited-set-efficient-solution",
                "content": "\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        \\n        jump_queue = deque([[0, 0]])\\n        same_block_jump = defaultdict(list)\\n        \\n        for index in range(len(arr)):\\n            same_block_jump[arr[index]].append(index)\\n        \\n        while jump_queue:\\n            \\n            jump_index, jump_count = jump_queue.popleft()\\n        \\n            if jump_index == len(arr) - 1:\\n                return jump_count\\n            \\n            possible_jumps = [jump_index + 1, jump_index - 1, *same_block_jump[arr[jump_index]]]\\n\\n            for jump in possible_jumps:\\n                if arr[jump] != \\'0\\' and 0 <= jump < len(arr):\\n                    jump_queue.append([jump, jump_count + 1])\\n                    \\n            same_block_jump[arr[jump_index]] = []\\n            arr[jump_index] = \\'0\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        \\n        jump_queue = deque([[0, 0]])\\n        same_block_jump = defaultdict(list)\\n        \\n        for index in range(len(arr)):\\n            same_block_jump[arr[index]].append(index)\\n        \\n        while jump_queue:\\n            \\n            jump_index, jump_count = jump_queue.popleft()\\n        \\n            if jump_index == len(arr) - 1:\\n                return jump_count\\n            \\n            possible_jumps = [jump_index + 1, jump_index - 1, *same_block_jump[arr[jump_index]]]\\n\\n            for jump in possible_jumps:\\n                if arr[jump] != \\'0\\' and 0 <= jump < len(arr):\\n                    jump_queue.append([jump, jump_count + 1])\\n                    \\n            same_block_jump[arr[jump_index]] = []\\n            arr[jump_index] = \\'0\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908576,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        int tar = n - 1;\\n        \\n        // 3 connections, i -> i - 1, i + 1, and \\n        unordered_map<int, vector<int>> sameValList; // {values : nodes}\\n        for (int i = 0; i < n; i++) {\\n            sameValList[arr[i]].push_back(i); // indicies that have the same value\\n        }\\n        \\n        queue<int> bfsQ;\\n        vector<bool> memo(n, false);\\n        bfsQ.push(0);\\n        memo[0] = true;\\n        \\n        int res = 0;\\n        while (!bfsQ.empty()) {\\n            int currQSize = bfsQ.size();\\n            while (currQSize-- > 0) {\\n                int curr = bfsQ.front(); bfsQ.pop();\\n                if (curr == tar) return res;\\n                if (curr > 0 && !memo[curr - 1]) {\\n                    memo[curr - 1] = true;\\n                    bfsQ.push(curr - 1);\\n                }\\n                if (curr + 1 < n && !memo[curr + 1]) {\\n                    memo[curr + 1] = true;\\n                    bfsQ.push(curr + 1);\\n                }\\n                // can be O(n)\\n                for (int &eachConnect : sameValList[arr[curr]]) {\\n                    if (memo[eachConnect]) continue;\\n                    memo[eachConnect] = true;\\n                    bfsQ.push(eachConnect);\\n                }\\n                sameValList[arr[curr]].clear(); // important optimization, so we dont have to recheck these connections\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        int tar = n - 1;\\n        \\n        // 3 connections, i -> i - 1, i + 1, and \\n        unordered_map<int, vector<int>> sameValList; // {values : nodes}\\n        for (int i = 0; i < n; i++) {\\n            sameValList[arr[i]].push_back(i); // indicies that have the same value\\n        }\\n        \\n        queue<int> bfsQ;\\n        vector<bool> memo(n, false);\\n        bfsQ.push(0);\\n        memo[0] = true;\\n        \\n        int res = 0;\\n        while (!bfsQ.empty()) {\\n            int currQSize = bfsQ.size();\\n            while (currQSize-- > 0) {\\n                int curr = bfsQ.front(); bfsQ.pop();\\n                if (curr == tar) return res;\\n                if (curr > 0 && !memo[curr - 1]) {\\n                    memo[curr - 1] = true;\\n                    bfsQ.push(curr - 1);\\n                }\\n                if (curr + 1 < n && !memo[curr + 1]) {\\n                    memo[curr + 1] = true;\\n                    bfsQ.push(curr + 1);\\n                }\\n                // can be O(n)\\n                for (int &eachConnect : sameValList[arr[curr]]) {\\n                    if (memo[eachConnect]) continue;\\n                    memo[eachConnect] = true;\\n                    bfsQ.push(eachConnect);\\n                }\\n                sameValList[arr[curr]].clear(); // important optimization, so we dont have to recheck these connections\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898877,
                "title": "java-bfs-and-why-dfs-memoization-doesn-t-work",
                "content": "In this question **DFS** will work if used **without** memoization but will give TLE and if we use memoization, then we will get wrong answer because here, unlike the conventional Rat in a Maze type problems (where we are allowed to move only forward or down) we can jump back also, instead of only moving forward. This can cause the memoized values to be stored incorrectly. \\n\\nAn excellent explanation of this phenomenon can be found here: [Why Memoization is not working?](https://leetcode.com/problems/jump-game-iv/discuss/1694469/Why-DP-%2B-Memoization-is-not-working) \\nSee the comment of **@dudeandcat**\\n\\nThe problem can be successfully solved using BFS algorithm :\\n\\n```\\n    public int minJumps(int[] arr) {\\n        Map<Integer, List<Integer>> equalValPosns = new HashMap<>();\\n\\n        // make map of num vs list of indices where num is present\\n        for (int i = 0; i < arr.length; i++) {\\n            List<Integer> posns = equalValPosns.getOrDefault(arr[i], new ArrayList<Integer>());\\n\\n            posns.add(i);\\n\\n            equalValPosns.put(arr[i], posns);\\n        }\\n        \\n        return minJumps(arr, equalValPosns);\\n    }\\n    \\n    private int minJumps(int[] arr, Map<Integer, List<Integer>> equalValPosns) {\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(0);\\n        \\n        int blocker = Integer.MAX_VALUE, jumps = -1;\\n        \\n        while (!queue.isEmpty()) {\\n            jumps++;\\n            \\n            int size = queue.size();\\n            \\n            while (size-- > 0) {\\n                int removedIdx = queue.remove();                \\n                \\n                if (removedIdx == arr.length - 1) {\\n                    return jumps;\\n                }\\n                    \\n                int valAtRemovedIdx = arr[removedIdx];\\n                \\n                if (valAtRemovedIdx != blocker) {\\n                    // block current index from being visited again\\n                    arr[removedIdx] = blocker;\\n\\n                    if (removedIdx > 0 && arr[removedIdx - 1] != blocker) {\\n                        queue.add(removedIdx - 1);\\n                    }\\n\\n                    if (removedIdx < arr.length - 1 && arr[removedIdx + 1] != blocker) {\\n                        queue.add(removedIdx + 1);\\n                    }\\n\\n                    for (int index : equalValPosns.get(valAtRemovedIdx)) {\\n                        if (arr[index] != blocker) {\\n                            queue.add(index);\\n                        }\\n                    }\\n                    \\n                    // to avoid iterating all the elements of list again if value is repeated\\n                    equalValPosns.put(valAtRemovedIdx, new ArrayList<>());\\n                }\\n            }\\n        }\\n        return jumps;\\n    }\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\n    public int minJumps(int[] arr) {\\n        Map<Integer, List<Integer>> equalValPosns = new HashMap<>();\\n\\n        // make map of num vs list of indices where num is present\\n        for (int i = 0; i < arr.length; i++) {\\n            List<Integer> posns = equalValPosns.getOrDefault(arr[i], new ArrayList<Integer>());\\n\\n            posns.add(i);\\n\\n            equalValPosns.put(arr[i], posns);\\n        }\\n        \\n        return minJumps(arr, equalValPosns);\\n    }\\n    \\n    private int minJumps(int[] arr, Map<Integer, List<Integer>> equalValPosns) {\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(0);\\n        \\n        int blocker = Integer.MAX_VALUE, jumps = -1;\\n        \\n        while (!queue.isEmpty()) {\\n            jumps++;\\n            \\n            int size = queue.size();\\n            \\n            while (size-- > 0) {\\n                int removedIdx = queue.remove();                \\n                \\n                if (removedIdx == arr.length - 1) {\\n                    return jumps;\\n                }\\n                    \\n                int valAtRemovedIdx = arr[removedIdx];\\n                \\n                if (valAtRemovedIdx != blocker) {\\n                    // block current index from being visited again\\n                    arr[removedIdx] = blocker;\\n\\n                    if (removedIdx > 0 && arr[removedIdx - 1] != blocker) {\\n                        queue.add(removedIdx - 1);\\n                    }\\n\\n                    if (removedIdx < arr.length - 1 && arr[removedIdx + 1] != blocker) {\\n                        queue.add(removedIdx + 1);\\n                    }\\n\\n                    for (int index : equalValPosns.get(valAtRemovedIdx)) {\\n                        if (arr[index] != blocker) {\\n                            queue.add(index);\\n                        }\\n                    }\\n                    \\n                    // to avoid iterating all the elements of list again if value is repeated\\n                    equalValPosns.put(valAtRemovedIdx, new ArrayList<>());\\n                }\\n            }\\n        }\\n        return jumps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1821279,
                "title": "jump-game-iv-using-map-and-queue-efficient-solution",
                "content": "class Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int step = 0;\\n        \\n        // Fill the map\\n        \\n        for (int i = 0; i < n; i++) {\\n            map.computeIfAbsent(arr[i], v -> new ArrayList<>()).add(i);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        \\n        while (!queue.isEmpty()) {\\n            step++;\\n            int size = queue.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                \\n                // Jump to j - 1\\n                \\n                int j = queue.poll();\\n                \\n                if (j - 1 >= 0 && map.containsKey(arr[j - 1])) {\\n                    \\n                    queue.offer(j - 1);\\n                }\\n                \\n                // Jump to j + 1\\n                \\n                if (j + 1 < n && map.containsKey(arr[j + 1])) {\\n                    \\n                    if (j + 1 == n - 1) {\\n                        \\n                        return step;\\n                    }\\n                    \\n                    queue.offer(j + 1);\\n                }\\n                \\n                // Jump to k --> arr[j] == arr[k]\\n                \\n                if (map.containsKey(arr[j])) {\\n                    \\n                    for (int k : map.get(arr[j])) {\\n                        \\n                        if (k != j) {\\n                            \\n                            if (k == n -1) {\\n                                \\n                                return step;\\n                            }\\n                            \\n                            queue.offer(k);\\n                        }\\n                    }\\n                }\\n                \\n                map.remove(arr[j]);\\n            }\\n        }\\n        \\n        return step;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if (n == 1) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1800091,
                "title": "bfs-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>> mp;\\n        int n = arr.size();\\n        int i,x;\\n        vector<int> dp(n,-1);\\n        for(i=0;i<n;i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        dp[0]=0;\\n        queue<int> q;\\n        q.push(0);\\n        \\n        while(!q.empty()){\\n            x = q.front();\\n            q.pop();\\n            if(x+1!=n && dp[x+1]==-1){\\n                dp[x+1]=dp[x]+1;\\n                q.push(x+1);\\n            }\\n            if(x!=0 && dp[x-1]==-1){\\n                dp[x-1]=dp[x]+1;\\n                q.push(x-1);\\n            }\\n            for(auto y: mp[arr[x]]){\\n                if(dp[y]==-1){\\n                    dp[y]=dp[x]+1;\\n                    q.push(y);\\n                }\\n            }\\n            mp.erase(arr[x]); //The first time we visit 7, [7,7,7,7,7,...] all the remaining 7 will be visited by next step, hence this can be removed\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>> mp;\\n        int n = arr.size();\\n        int i,x;\\n        vector<int> dp(n,-1);\\n        for(i=0;i<n;i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        dp[0]=0;\\n        queue<int> q;\\n        q.push(0);\\n        \\n        while(!q.empty()){\\n            x = q.front();\\n            q.pop();\\n            if(x+1!=n && dp[x+1]==-1){\\n                dp[x+1]=dp[x]+1;\\n                q.push(x+1);\\n            }\\n            if(x!=0 && dp[x-1]==-1){\\n                dp[x-1]=dp[x]+1;\\n                q.push(x-1);\\n            }\\n            for(auto y: mp[arr[x]]){\\n                if(dp[y]==-1){\\n                    dp[y]=dp[x]+1;\\n                    q.push(y);\\n                }\\n            }\\n            mp.erase(arr[x]); //The first time we visit 7, [7,7,7,7,7,...] all the remaining 7 will be visited by next step, hence this can be removed\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775035,
                "title": "python-easy-to-read-and-understand-bfs",
                "content": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        d = defaultdict(list)\\n        for i, val in enumerate(arr):\\n            d[val].append(i)\\n        \\n        visited = [False for _ in range(n)]\\n        q = [0]\\n        visited[0] = True\\n        ans = 0\\n        while q:\\n            for i in range(len(q)):\\n                ind = q.pop(0)\\n                #print(ind)\\n                if ind == n-1:\\n                    return ans\\n                if ind + 1 < n and visited[ind+1] == False:\\n                    visited[ind+1] = True\\n                    q.append(ind+1)\\n                if ind - 1 > 0 and visited[ind-1] == False:\\n                    visited[ind-1] = True\\n                    q.append(ind-1)\\n                for nei in d[arr[ind]]:\\n                    if visited[nei] == False:\\n                        visited[nei] = True\\n                        q.append(nei)\\n                del d[arr[ind]]\\n            ans += 1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        d = defaultdict(list)\\n        for i, val in enumerate(arr):\\n            d[val].append(i)\\n        \\n        visited = [False for _ in range(n)]\\n        q = [0]\\n        visited[0] = True\\n        ans = 0\\n        while q:\\n            for i in range(len(q)):\\n                ind = q.pop(0)\\n                #print(ind)\\n                if ind == n-1:\\n                    return ans\\n                if ind + 1 < n and visited[ind+1] == False:\\n                    visited[ind+1] = True\\n                    q.append(ind+1)\\n                if ind - 1 > 0 and visited[ind-1] == False:\\n                    visited[ind-1] = True\\n                    q.append(ind-1)\\n                for nei in d[arr[ind]]:\\n                    if visited[nei] == False:\\n                        visited[nei] = True\\n                        q.append(nei)\\n                del d[arr[ind]]\\n            ans += 1",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1822069,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822061,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822197,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1573419,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822206,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822183,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1566205,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822523,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1575545,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1565262,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822069,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822061,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822197,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1573419,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822206,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822183,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1566205,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822523,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1575545,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1565262,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1566001,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1822748,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1822510,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1822712,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1822098,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1822689,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1822553,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1822100,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 2019695,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1971643,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1883441,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1824205,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1824007,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1823421,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1823224,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1823125,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1823117,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1823114,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1823056,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1822994,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1822906,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822691,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822609,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822580,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822574,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822124,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822121,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822097,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822092,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822082,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            }
        ]
    }
]