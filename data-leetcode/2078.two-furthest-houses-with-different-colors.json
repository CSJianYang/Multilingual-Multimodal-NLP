[
    {
        "title": "The Winner University",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1576139,
                "content": [
                    {
                        "username": "xyz12345",
                        "content": "with nye as\\n(\\nselect count(student_id) as nnum\\nfrom newyork\\nwhere score >= 90)\\n\\n, cal as\\n(select count(student_id) as cnum\\nfrom california\\nwhere score >= 90)\\n\\nselect \\ncase   when  nnum > cnum then   \"New York University\"\\n          when  cnum >nnum  then   \"California University\"\\n          else    \"No Winner\"\\nend as winner\\nfrom nye, cal"
                    },
                    {
                        "username": "Paonevergivup",
                        "content": "with cte as(\\nselect \"NYU\" as School,count(student_id) as count_student\\nfrom NewYork\\nwhere score>=90\\nunion all\\nselect \"CU\" as School,count(student_id) as count_student\\nfrom California\\nwhere score>=90)\\n, cte2 as(\\nselect School, dense_rank() over(order by count_student desc) as rank_num\\nfrom cte)\\n\\nselect case when count(School)>1 then \"No Winner\" when School=\"NYU\" then \"New York University\" else \"California University\"  end as winner\\nfrom cte2\\nwhere rank_num=1"
                    }
                ]
            },
            {
                "id": 1576107,
                "content": [
                    {
                        "username": "xyz12345",
                        "content": "with nye as\\n(\\nselect count(student_id) as nnum\\nfrom newyork\\nwhere score >= 90)\\n\\n, cal as\\n(select count(student_id) as cnum\\nfrom california\\nwhere score >= 90)\\n\\nselect \\ncase   when  nnum > cnum then   \"New York University\"\\n          when  cnum >nnum  then   \"California University\"\\n          else    \"No Winner\"\\nend as winner\\nfrom nye, cal"
                    },
                    {
                        "username": "Paonevergivup",
                        "content": "with cte as(\\nselect \"NYU\" as School,count(student_id) as count_student\\nfrom NewYork\\nwhere score>=90\\nunion all\\nselect \"CU\" as School,count(student_id) as count_student\\nfrom California\\nwhere score>=90)\\n, cte2 as(\\nselect School, dense_rank() over(order by count_student desc) as rank_num\\nfrom cte)\\n\\nselect case when count(School)>1 then \"No Winner\" when School=\"NYU\" then \"New York University\" else \"California University\"  end as winner\\nfrom cte2\\nwhere rank_num=1"
                    }
                ]
            }
        ]
    },
    {
        "title": "Time Needed to Buy Tickets",
        "question_content": "<p>There are <code>n</code> people in a line queuing to buy tickets, where the <code>0<sup>th</sup></code> person is at the <strong>front</strong> of the line and the <code>(n - 1)<sup>th</sup></code> person is at the <strong>back</strong> of the line.</p>\n\n<p>You are given a <strong>0-indexed</strong> integer array <code>tickets</code> of length <code>n</code> where the number of tickets that the <code>i<sup>th</sup></code> person would like to buy is <code>tickets[i]</code>.</p>\n\n<p>Each person takes <strong>exactly 1 second</strong> to buy a ticket. A person can only buy <strong>1 ticket at a time</strong> and has to go back to <strong>the end</strong> of the line (which happens <strong>instantaneously</strong>) in order to buy more tickets. If a person does not have any tickets left to buy, the person will <strong>leave </strong>the line.</p>\n\n<p>Return <em>the <strong>time taken</strong> for the person at position </em><code>k</code><em>&nbsp;</em><strong><em>(0-indexed)</em>&nbsp;</strong><em>to finish buying tickets</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> tickets = [2,3,2], k = 2\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> \n- In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].\n- In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].\nThe person at&nbsp;position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> tickets = [5,1,1,1], k = 0\n<strong>Output:</strong> 8\n<strong>Explanation:</strong>\n- In the first pass, everyone in the line buys a ticket and the line becomes [4, 0, 0, 0].\n- In the next 4 passes, only the person in position 0 is buying tickets.\nThe person at&nbsp;position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == tickets.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= tickets[i] &lt;= 100</code></li>\n\t<li><code>0 &lt;= k &lt; n</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1576932,
                "title": "c-one-pass",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Brute Force Simulation\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/time-needed-to-buy-tickets/\\n// Author: github.com/lzl124631x\\n// Time: O(SUM(A))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& A, int k) {\\n        int step = 0;\\n        while (true) {\\n            for (int i = 0; i < A.size(); ++i) {\\n                if (A[i] == 0) continue;\\n                A[i]--;\\n                ++step;\\n                if (A[k] == 0) return step;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n## Solution 2. One Pass\\n\\nFor `i <= k`, `A[i]` contributes `min(A[k], A[i])` steps.\\n\\nFor `i > k`, `A[i]` contributes `min(A[k] - 1, A[i])` steps.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/time-needed-to-buy-tickets/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& A, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            ans += min(A[k] - (i > k), A[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/time-needed-to-buy-tickets/\\n// Author: github.com/lzl124631x\\n// Time: O(SUM(A))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& A, int k) {\\n        int step = 0;\\n        while (true) {\\n            for (int i = 0; i < A.size(); ++i) {\\n                if (A[i] == 0) continue;\\n                A[i]--;\\n                ++step;\\n                if (A[k] == 0) return step;\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/time-needed-to-buy-tickets/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& A, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            ans += min(A[k] - (i > k), A[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577093,
                "title": "o-n",
                "content": "We know the value of `k`-th element. Elements before `k` (and the element itself) will appear in the line `min(t[k], t[i])` times.\\n\\nAll elements after `k` will appear in the line  `min(t[k] - 1, t[i])` times.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def timeRequiredToBuy(self, t: List[int], k: int) -> int:\\n        return sum(min(v, t[k] if i <= k else t[k] - 1) for i, v in enumerate(t))\\n```\\n**Java**\\n```java\\npublic int timeRequiredToBuy(int[] t, int k) {\\n    return IntStream.range(0, t.length).map(i -> Math.min(t[i], i > k ? t[k] - 1 : t[k])).sum();\\n}\\n```\\n**C++**\\n```cpp\\nint timeRequiredToBuy(vector<int>& t, int k) {\\n    int res = 0, sz = t.size(), cap = t[k];\\n    for (int i = 0; i < sz; ++i)\\n        res += min(cap - (i > k), t[i]);\\n    return res;\\n}\\n```\\nAlso a (slightly mouthful) functional version.\\n```cpp\\nint timeRequiredToBuy(vector<int>& t, int k) {\\n    return accumulate(begin(t), begin(t) + k + 1, 0, [&](int s, int v){ return s + min(v, t[k]); })\\n        + accumulate(begin(t) + k + 1, end(t), 0, [&](int s, int v){ return s + min(v, t[k] - 1); });\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def timeRequiredToBuy(self, t: List[int], k: int) -> int:\\n        return sum(min(v, t[k] if i <= k else t[k] - 1) for i, v in enumerate(t))\\n```\n```java\\npublic int timeRequiredToBuy(int[] t, int k) {\\n    return IntStream.range(0, t.length).map(i -> Math.min(t[i], i > k ? t[k] - 1 : t[k])).sum();\\n}\\n```\n```cpp\\nint timeRequiredToBuy(vector<int>& t, int k) {\\n    int res = 0, sz = t.size(), cap = t[k];\\n    for (int i = 0; i < sz; ++i)\\n        res += min(cap - (i > k), t[i]);\\n    return res;\\n}\\n```\n```cpp\\nint timeRequiredToBuy(vector<int>& t, int k) {\\n    return accumulate(begin(t), begin(t) + k + 1, 0, [&](int s, int v){ return s + min(v, t[k]); })\\n        + accumulate(begin(t) + k + 1, end(t), 0, [&](int s, int v){ return s + min(v, t[k] - 1); });\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577018,
                "title": "python-bruteforce-and-o-n",
                "content": "Please upvote if you find it helpful\\n\\nBruteForce:\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        secs = 0 \\n        i = 0\\n        while tickets[k] != 0:\\n            if tickets[i] != 0: # if it is zero that means we dont have to count it anymore\\n                tickets[i] -= 1 # decrease the value by 1 everytime\\n                secs += 1 # increase secs by 1\\n\\n            i = (i + 1) % len(tickets) # since after getting to the end of the array we have to return to the first value so we use the mod operator\\n            \\n        return secs\\n```\\n\\nO(N):\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(min(x, tickets[k] if i <= k else tickets[k] - 1) for i, x in enumerate(tickets))\\n```\\nThe values before tickets[k] will appear min(x, t[x]) times and values after tickets[k] will appear min(x, t[x] -1) times\\nLet\\'s take an example:\\n`tickets = [5, 2, 3, 4]` and `k = 2`\\n```1st iteration: [4, 1, 2, 3]```\\n```2nd iteration: [3, 0, 1, 2]```\\n```3rd iteration: [2, 0, 0, 1]```\\nYou see `tickets[0]` appeared 3 times which is min(5, 3) and that is 3, \\n             `tickets[1]` appeared 2 times which is min(2, 3) that is 2, \\n\\t\\t\\t `tickets[2]` appeared 3 times which is min(3, 3) that is 3 and \\n\\t\\t\\t `tickets[3]` appeared 2 times which is min(4, 2) that is 2.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        secs = 0 \\n        i = 0\\n        while tickets[k] != 0:\\n            if tickets[i] != 0: # if it is zero that means we dont have to count it anymore\\n                tickets[i] -= 1 # decrease the value by 1 everytime\\n                secs += 1 # increase secs by 1\\n\\n            i = (i + 1) % len(tickets) # since after getting to the end of the array we have to return to the first value so we use the mod operator\\n            \\n        return secs\\n```\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(min(x, tickets[k] if i <= k else tickets[k] - 1) for i, x in enumerate(tickets))\\n```\n```1st iteration: [4, 1, 2, 3]```\n```2nd iteration: [3, 0, 1, 2]```\n```3rd iteration: [2, 0, 0, 1]```",
                "codeTag": "Java"
            },
            {
                "id": 1576926,
                "title": "java-o-n-one-pass-explained",
                "content": "**Explanation / Approach:**\\nBrute force is somewhat easy to come up with. You just need to iterate as long as tickets[k] != 0.\\n\\n**For an optimized approach :**\\n1. Add min(tickets[i],tickets[k]) upto k (inclusive).\\n2. Add min(tickets[i],tickets[k] - 1) after k.\\n3. Return the count.\\n\\nTime : O(n) , Space : O(1)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int res = 0;\\n        for(int i = 0;i<tickets.length;i++){\\n            if(i <= k){\\n                res += Math.min(tickets[k],tickets[i]);\\n            }else{\\n                res += Math.min(tickets[k] - 1,tickets[i]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int res = 0;\\n        for(int i = 0;i<tickets.length;i++){\\n            if(i <= k){\\n                res += Math.min(tickets[k],tickets[i]);\\n            }else{\\n                res += Math.min(tickets[k] - 1,tickets[i]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589830,
                "title": "c-brute-force-vs-single-pass-solution-compared-and-explained-100-time-80-space",
                "content": "Given the constraints, we can easily afford to go for a brute force-ish solution first (a fully legitimate approach during any interview, as long as you keep the computationt time reasonable - I wouldn\\'t do this if either the queue length or the amount of tickets each queuer might buy were in the order of billions!), so we will go for it first.\\n\\nIn order to solve our problem we will first of all declare an accumulator variable `res`, initially set to `0` and that will store how many turns we have to wait until the `k`th slot has bought all his tickets.\\n\\nWe will then have an outer loop just to check that - `ts[k]` still having pending tickets to buy and inside it we will run another one, using the pointer `i` to parse `ts` until `ts[k]` is not `0` and in which we will:\\n* check if the currently pointed element `ts[i]` still has elements to remove and, in case:\\n\\t* decrease `ts[i]` by `1`;\\n\\t* increase `res` by `1`.\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0;\\n        // running loops until we get all our tickets\\n        while (ts[k]) {\\n            // running one loop\\n            for (int i = 0, lmt = ts.size(); i < lmt && ts[k]; i++) {\\n                // decreasing one slot and increasing res, if the slot still queues\\n                if (ts[i]) {\\n                    ts[i]--;\\n                    res++;\\n                }\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut, wait a minute \\uD83E\\uDD14 ...\\n\\nDo we really need to decrease all the cells one by one?\\n\\nWell, probably not, since we might quickly notice that the waiting time each slot to the left of `k` contributes is equal to the minimum between its current value and `ts[k]`, that we will call `target` for convenience; and it\\'s almost the same for all the elements to the right of it, being the minimum between its current value and `target - 1` (since we will go and touch them always after having decreased `ts[k]`.\\n\\nSo, we can put this into code and get much better performance with this version:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0, target = ts[k];\\n        // parsing the queue\\n        for (int i = 0, lmt = ts.size(); i < lmt; i++) {\\n            // getting the minimum between the current value and what we need to get\\n            res += min(ts[i], target - (i > k));\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nFinal micro-optimised version to avoid one conditional inside the loop (which probably would not even shine in terms of performance compared to allocating variables for a sole `for` loop unless we were to get really big ranges):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0, target = ts[k];\\n        // parsing the queue up to k, included\\n        for (int i = 0; i <= k; i++) {\\n            // getting the minimum between the current value and target\\n            res += min(ts[i], target);\\n        }\\n        // parsing the queue up from  k, excluded\\n        target--;\\n        for (int i = k + 1, lmt = ts.size(); i < lmt; i++) {\\n            // getting the minimum between the current value and target\\n            res += min(ts[i], target);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0;\\n        // running loops until we get all our tickets\\n        while (ts[k]) {\\n            // running one loop\\n            for (int i = 0, lmt = ts.size(); i < lmt && ts[k]; i++) {\\n                // decreasing one slot and increasing res, if the slot still queues\\n                if (ts[i]) {\\n                    ts[i]--;\\n                    res++;\\n                }\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0, target = ts[k];\\n        // parsing the queue\\n        for (int i = 0, lmt = ts.size(); i < lmt; i++) {\\n            // getting the minimum between the current value and what we need to get\\n            res += min(ts[i], target - (i > k));\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& ts, int k) {\\n        // support variables\\n        int res = 0, target = ts[k];\\n        // parsing the queue up to k, included\\n        for (int i = 0; i <= k; i++) {\\n            // getting the minimum between the current value and target\\n            res += min(ts[i], target);\\n        }\\n        // parsing the queue up from  k, excluded\\n        target--;\\n        for (int i = k + 1, lmt = ts.size(); i < lmt; i++) {\\n            // getting the minimum between the current value and target\\n            res += min(ts[i], target);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577090,
                "title": "easy-to-understand",
                "content": "```\\nvar timeRequiredToBuy = function(tickets, k) {\\n     \\n    let countTime = 0;\\n\\n    while(tickets[k] !== 0){\\n\\n        for(let i = 0; i < tickets.length; i++){\\n            \\n            if(tickets[k] == 0){\\n                return countTime;\\n            }\\n            if(tickets[i] !== 0){\\n                tickets[i] = tickets[i] - 1;\\n                countTime++;\\n            }\\n        }\\n\\n    }\\n\\n    return countTime;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeRequiredToBuy = function(tickets, k) {\\n     \\n    let countTime = 0;\\n\\n    while(tickets[k] !== 0){\\n\\n        for(let i = 0; i < tickets.length; i++){\\n            \\n            if(tickets[k] == 0){\\n                return countTime;\\n            }\\n            if(tickets[i] !== 0){\\n                tickets[i] = tickets[i] - 1;\\n                countTime++;\\n            }\\n        }\\n\\n    }\\n\\n    return countTime;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1778911,
                "title": "python-o-n-easy-method",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\t#Loop through all elements in list only once.  \\n\\t\\t\\n        nums = tickets \\n        time_sec = 0\\n\\t\\t# save the number of tickets to be bought by person standing at k position\\n        least_tickets = nums[k]     \\n\\t\\t#(3) Any person nums[i] having tickets more than the k pos person, will buy tickets least_tickets times only.\\n\\t\\t#(2) Person nums[i] having tickets less than kth person ( nums[i] < least_tickets ), and standing before him(i<k), will be able to buy nums[i] amount.\\n\\t\\t#(1) Person nums[i] standing after kth person having more tickets than kth person, will be able to buy one less than the ticket kth person can buy(condition: least_tickets - 1).\\n        for i in range(len(nums)):                  \\n            if k < i and nums[i] >= least_tickets :         #(1)\\n                time_sec += (least_tickets - 1)\\n            elif nums[i] < least_tickets :                   #(2)\\n                time_sec += nums[i]\\n            else:                                            #(3)\\n                time_sec += least_tickets\\n\\t\\t\\t\\t\\n        return time_sec\\n        \\nPlease upvote if you find it useful and well-explained!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\t#Loop through all elements in list only once.  \\n\\t\\t\\n        nums = tickets \\n        time_sec = 0\\n\\t\\t# save the number of tickets to be bought by person standing at k position\\n        least_tickets = nums[k]     \\n\\t\\t#(3) Any person nums[i] having tickets more than the k pos person, will buy tickets least_tickets times only.\\n\\t\\t#(2) Person nums[i] having tickets less than kth person ( nums[i] < least_tickets ), and standing before him(i<k), will be able to buy nums[i] amount.\\n\\t\\t#(1) Person nums[i] standing after kth person having more tickets than kth person, will be able to buy one less than the ticket kth person can buy(condition: least_tickets - 1).\\n        for i in range(len(nums)):                  \\n            if k < i and nums[i] >= least_tickets :         #(1)\\n                time_sec += (least_tickets - 1)\\n            elif nums[i] < least_tickets :                   #(2)\\n                time_sec += nums[i]\\n            else:                                            #(3)\\n                time_sec += least_tickets\\n\\t\\t\\t\\t\\n        return time_sec\\n        \\nPlease upvote if you find it useful and well-explained!",
                "codeTag": "Java"
            },
            {
                "id": 1576991,
                "title": "python-1-liner",
                "content": "```python\\nreturn sum(min(tickets[k] - (i > k), num) for i, num in enumerate(tickets))\\n```",
                "solutionTags": [],
                "code": "```python\\nreturn sum(min(tickets[k] - (i > k), num) for i, num in enumerate(tickets))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577014,
                "title": "java-easy-solution-o-n",
                "content": "**Time Needed to Buy Tickets**\\n\\nSimple and crisp Solution - \\n\\n**Input:** tickets = [2,3,2], k = 2\\n**Output:** 6\\n**Explanation:** \\n- In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].\\n- In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].\\nThe person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.\\n\\n```\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n        int timeTaken = 0;\\n        while(tickets[k] > 0) {\\n        \\tfor(int i = 0; i < tickets.length; i++) {\\n        \\t\\tif(tickets[i] > 0) {\\n        \\t\\t\\ttickets[i]--;\\n        \\t\\t\\ttimeTaken++;\\n        \\t\\t}\\n                if(tickets[k] == 0)  break;\\n        \\t}\\n        }\\n        return timeTaken;\\n    }\\n```\\n\\t\\nTime Complexity - **O(n^2)**\\n\\n\\t\\n```\\n\\tpublic int timeRequiredToBuy(int[] tickets, int k) {\\n\\t      int timeTaken = 0;\\n          for(int i = 0; i < tickets.length; i++){\\n                if(tickets[i] <= tickets[k]){\\n                     timeTaken += tickets[i];\\n                }\\n                else  timeTaken += tickets[k];\\n                if(i > k && tickets[i] >= tickets[k])  timeTaken--;\\n          }\\n          return timeTaken;\\n    }\\n```\\t\\n\\t\\nTime Complexity - **O(n)**\\n\\nCredit - @yadavharsha50",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n        int timeTaken = 0;\\n        while(tickets[k] > 0) {\\n        \\tfor(int i = 0; i < tickets.length; i++) {\\n        \\t\\tif(tickets[i] > 0) {\\n        \\t\\t\\ttickets[i]--;\\n        \\t\\t\\ttimeTaken++;\\n        \\t\\t}\\n                if(tickets[k] == 0)  break;\\n        \\t}\\n        }\\n        return timeTaken;\\n    }\\n```\n```\\n\\tpublic int timeRequiredToBuy(int[] tickets, int k) {\\n\\t      int timeTaken = 0;\\n          for(int i = 0; i < tickets.length; i++){\\n                if(tickets[i] <= tickets[k]){\\n                     timeTaken += tickets[i];\\n                }\\n                else  timeTaken += tickets[k];\\n                if(i > k && tickets[i] >= tickets[k])  timeTaken--;\\n          }\\n          return timeTaken;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1584144,
                "title": "c-very-easy-o-n-my-thought",
                "content": "Hint :- Simple solustion is to count time for every element and return sum of it. \\n\\nJust bruthforces, Element before k index take min of element or that index value and ,after k index it take min of element-1 or that index. Here element-1 because in last round we will not go for element which index is greater then k.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n            int ans =0;\\n            int n = tickets.size();\\n            int ele = tickets[k];\\n            for(int i=0;i< n; i++){\\n                    if(i<=k){\\n                        ans+= min(ele, tickets[i]);\\n                    }else{\\n                        ans+= min(ele-1, tickets[i]);   \\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```\\n\\n**Upvote If like my solustion ::)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n            int ans =0;\\n            int n = tickets.size();\\n            int ele = tickets[k];\\n            for(int i=0;i< n; i++){\\n                    if(i<=k){\\n                        ans+= min(ele, tickets[i]);\\n                    }else{\\n                        ans+= min(ele-1, tickets[i]);   \\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189150,
                "title": "c-solution-beats-100-easy-to-understand-and-easy-solution",
                "content": "# Intuition\\nWe have to just keep decreasing 1 from each element.\\n\\n# Approach\\n1. We will traverse the array and keep decreasing 1 from every element till the element at kth position gets 0.\\n2. We will also keep a count variable to keep track of the steps required for kth element to reach 0.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count = 0, i = 0;\\n\\n        while(tickets[k] != 0){\\n            if(i == tickets.size()){\\n                i = 0;\\n            }\\n            if(tickets[i] == 0){\\n                i++;\\n                continue;\\n            }\\n            tickets[i]--;\\n            count++;\\n            i++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count = 0, i = 0;\\n\\n        while(tickets[k] != 0){\\n            if(i == tickets.size()){\\n                i = 0;\\n            }\\n            if(tickets[i] == 0){\\n                i++;\\n                continue;\\n            }\\n            tickets[i]--;\\n            count++;\\n            i++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582397,
                "title": "1-ms-java-solution",
                "content": "```\\n public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n        int seconds = 0;\\n        int i = 0;\\n        while(tickets[k] != 0)\\n        {\\n            if(tickets[i] != 0)\\n            {\\n                tickets[i] = tickets[i] -1;\\n                seconds++;\\n            }\\n            if(i == tickets.length - 1)\\n            {\\n                i = 0;\\n                continue;\\n            }\\n                i++;\\n        }\\n\\n        return seconds;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n        int seconds = 0;\\n        int i = 0;\\n        while(tickets[k] != 0)\\n        {\\n            if(tickets[i] != 0)\\n            {\\n                tickets[i] = tickets[i] -1;\\n                seconds++;\\n            }\\n            if(i == tickets.length - 1)\\n            {\\n                i = 0;\\n                continue;\\n            }\\n                i++;\\n        }\\n\\n        return seconds;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2037468,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<pair<int,int>>q;\\n        int time = 0;\\n        for(int i = 0; i < tickets.size(); i++)\\n        {\\n            q.push({tickets[i],i});\\n        }\\n        while(!q.empty())\\n        {\\n            pair<int,int> tmp = q.front();\\n            q.pop();\\n            --tmp.first;\\n            ++time;\\n            if(tmp.first == 0 && tmp.second == k)\\n            {\\n                break;\\n            }\\n            else if(tmp.first != 0)\\n            {\\n                q.push({tmp.first,tmp.second});\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<pair<int,int>>q;\\n        int time = 0;\\n        for(int i = 0; i < tickets.size(); i++)\\n        {\\n            q.push({tickets[i],i});\\n        }\\n        while(!q.empty())\\n        {\\n            pair<int,int> tmp = q.front();\\n            q.pop();\\n            --tmp.first;\\n            ++time;\\n            if(tmp.first == 0 && tmp.second == k)\\n            {\\n                break;\\n            }\\n            else if(tmp.first != 0)\\n            {\\n                q.push({tmp.first,tmp.second});\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577912,
                "title": "brute-deque-optimised-in-one-pass",
                "content": "1)BRUTE FORCE APPROACH -> \\nA) SIMULATE THE GIVEN PROBLEM USING DEQUE DATA STRUCTURE  \\nKEEP A COUNTER WHEN KTH ELEMENT BECOMES 0 THATS EASY :)\\n\\nTC -> O(K * ARR[K]) -> IN WORST CASE IF K IS LAST ELEMENT\\nSC -> O(2*N) -> TAKEN A PAIR\\n\\nCODE -> \\n```\\n\\t\\tdeque<pair<int,int>>dq;\\n        for(int i = 0;  i < tickets.size(); i++) {\\n            dq.push_back({tickets[i] , i});\\n        }\\n        int ans = 0;\\n        while(!dq.empty()) {\\n            int val = dq.front().first;\\n            int idx = dq.front().second;\\n            val--;\\n            ans++;\\n            if(idx == k && val == 0) {\\n                break;\\n            }\\n            if(val == 0) {\\n                dq.pop_front();\\n            } else {\\n                dq.pop_front();\\n                dq.push_back({val, idx});\\n            }\\n        }\\n        return ans;\\n```\\n\\nOPTIMISED APPROACH->\\n\\nTHINK WITH RESPECT TO K -> TAKE 2 CASES\\n1) ELEMENTS BEFORE K -> WILL TAKE MIN(ARR[I] , ARR[K]) STEPS IN TOTAL\\n2) ELEMENTS AFTER K  ->  WILL TAKE MIN(ARR[I] , ARR[K] - 1 STEPS) IN TOTAL\\n3) YOUR ANS IS (1 + 2) -> \\n\\nCODE -> \\n```\\n\\t int ans = 1;\\n        int val = tickets[k];\\n        for(int i = 0 ; i < tickets.size(); i++) {\\n            if(i < k) {\\n                //THE ELEMENTS THAT LIE BEFORE K\\n                if(tickets[i]  < val) {\\n                    ans += tickets[i];\\n                } else {\\n                    ans += val;\\n                }\\n            } else {\\n                //THE ELEMENTS THAT LIE AFTER K\\n                if(tickets[i] < val - 1) {\\n                    ans += tickets[i];\\n                } else {\\n                    ans += (val - 1);\\n                }   \\n            }   \\n        } \\n        return ans;\\n```\\n\\nTC -> O(N) SINGLE PASS\\nSC -> O(1) :)\\n\\nTHANK YOU DO SHARE AND UPVOTE IF YOU LIKED THE APPROACH\\n",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\n\\t\\tdeque<pair<int,int>>dq;\\n        for(int i = 0;  i < tickets.size(); i++) {\\n            dq.push_back({tickets[i] , i});\\n        }\\n        int ans = 0;\\n        while(!dq.empty()) {\\n            int val = dq.front().first;\\n            int idx = dq.front().second;\\n            val--;\\n            ans++;\\n            if(idx == k && val == 0) {\\n                break;\\n            }\\n            if(val == 0) {\\n                dq.pop_front();\\n            } else {\\n                dq.pop_front();\\n                dq.push_back({val, idx});\\n            }\\n        }\\n        return ans;\\n```\n```\\n\\t int ans = 1;\\n        int val = tickets[k];\\n        for(int i = 0 ; i < tickets.size(); i++) {\\n            if(i < k) {\\n                //THE ELEMENTS THAT LIE BEFORE K\\n                if(tickets[i]  < val) {\\n                    ans += tickets[i];\\n                } else {\\n                    ans += val;\\n                }\\n            } else {\\n                //THE ELEMENTS THAT LIE AFTER K\\n                if(tickets[i] < val - 1) {\\n                    ans += tickets[i];\\n                } else {\\n                    ans += (val - 1);\\n                }   \\n            }   \\n        } \\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3918164,
                "title": "brute-force-optimized-queue-interviewer-mindset",
                "content": "# Intuition\\n1. Brute force using loop iteration\\n2. optimised using one loop\\n3. Queue solution for more in depth\\n\\n# Approach\\nWe find out min of tickets[i] and tickets[k]\\n\\n\\n\\n## Brute force approach\\n- Time complexity: O(N^2)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k){\\n        int n= tickets.length;\\n        int time=0;\\n    \\n        if(tickets[k]==1) return k+1;\\n        while(tickets[k]>0){\\n            for(int i=0;i<n;i++){\\n                if(tickets[i]==0) continue;\\n                tickets[i]=tickets[i]-1;\\n                time++;\\n                if(tickets[k]==0) break;\\n            }\\n        }k--;\\n        return time;\\n    }\\n}\\n\\n```\\n## Optimized approach: without extra space\\n\\n- Time complexity: O(N)\\n- - space complexity: O(1)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        for(int i = 0;i<tickets.length;i++){\\n            if(i <= k){\\n                time += Math.min(tickets[k],tickets[i]);\\n            }else{\\n                time+= Math.min(tickets[k] - 1,tickets[i]);\\n            }\\n        }\\n        return time;\\n    }\\n}\\n\\n```\\n## Queue approach : taking extra space\\n- Time complexity: O(N)\\n- space complexity: O(N)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        for ( int i = 0; i < tickets.length; i++){\\n           q.add(i);\\n        }\\n        int count = 0;\\n        while(!q.isEmpty()){\\n            ++count;\\n            int front = q.poll();\\n            if(tickets[front] >= 1){\\n                tickets[front] -= 1;\\n            }\\n            if(k == front && tickets[front] == 0){\\n                break;\\n            }\\n            if(k != front && tickets[front] == 0){\\n                continue;\\n            }\\n            q.add(front);\\n        }\\n        return count;\\n    }\\n}\\n```\\n![cat-upvote.jpg](https://assets.leetcode.com/users/images/7c799b02-abd9-44f8-98a2-e4830340d206_1692193011.7738297.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k){\\n        int n= tickets.length;\\n        int time=0;\\n    \\n        if(tickets[k]==1) return k+1;\\n        while(tickets[k]>0){\\n            for(int i=0;i<n;i++){\\n                if(tickets[i]==0) continue;\\n                tickets[i]=tickets[i]-1;\\n                time++;\\n                if(tickets[k]==0) break;\\n            }\\n        }k--;\\n        return time;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        for(int i = 0;i<tickets.length;i++){\\n            if(i <= k){\\n                time += Math.min(tickets[k],tickets[i]);\\n            }else{\\n                time+= Math.min(tickets[k] - 1,tickets[i]);\\n            }\\n        }\\n        return time;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n\\n        for ( int i = 0; i < tickets.length; i++){\\n           q.add(i);\\n        }\\n        int count = 0;\\n        while(!q.isEmpty()){\\n            ++count;\\n            int front = q.poll();\\n            if(tickets[front] >= 1){\\n                tickets[front] -= 1;\\n            }\\n            if(k == front && tickets[front] == 0){\\n                break;\\n            }\\n            if(k != front && tickets[front] == 0){\\n                continue;\\n            }\\n            q.add(front);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615121,
                "title": "100-beats-o-n-solution-without-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n       int n=tickets.size();\\n       int total=tickets[k];\\n\\n        for(int i=0;i<k;i++){\\n            total+=min(tickets[k],tickets[i]);\\n        }\\n        for(int i=k+1;i<n;i++){\\n            total+=min(tickets[k]-1,tickets[i]);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n       int n=tickets.size();\\n       int total=tickets[k];\\n\\n        for(int i=0;i<k;i++){\\n            total+=min(tickets[k],tickets[i]);\\n        }\\n        for(int i=k+1;i<n;i++){\\n            total+=min(tickets[k]-1,tickets[i]);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567182,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n    int count=0;\\n        while(tickets[k]>0){\\n            for(int i=0;i<tickets.length;i++){\\n                if(tickets[i]>0){\\n                    tickets[i]-=1;\\n                    count++;\\n                }\\n                if(tickets[k]==0)break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n    int count=0;\\n        while(tickets[k]>0){\\n            for(int i=0;i<tickets.length;i++){\\n                if(tickets[i]>0){\\n                    tickets[i]-=1;\\n                    count++;\\n                }\\n                if(tickets[k]==0)break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489688,
                "title": "python-simple-and-clean-beats-77-69",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n##### **Single Pass Solution**\\n1. People before *k-th* person will take mininum of reqd tickets and *k-th* person ticket\\n2. People after *k-th* person will take 1 ticket less than, because after oue person takes the ticket the objective will be completed and we do not need to count more time for people **standing after him**\\n\\n##### **Implementation**\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        num = tickets[k]\\n        res = 0\\n        for i in range(k+1):\\n            res += min(tickets[i],num)\\n        for i in range(k+1,len(tickets)):\\n            res += min(tickets[i],num-1)\\n        return res\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7ab4074a-00a1-49e3-a1fb-fc62d50bfe0f_1661594988.4600484.png)\\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        num = tickets[k]\\n        res = 0\\n        for i in range(k+1):\\n            res += min(tickets[i],num)\\n        for i in range(k+1,len(tickets)):\\n            res += min(tickets[i],num-1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763737,
                "title": "java-solution-faster-than-100-of-all-submissions-o-n",
                "content": "```\\n\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n      int output = 0;\\n      int n = tickets.length;\\n      for  (int i = 0;i<n;i++){\\n          if(tickets[i] < tickets[k]){\\n              output += tickets[i];\\n          }else{\\n                if(i <= k){\\n                  output += tickets[k];\\n              }else { \\n                  output += tickets[k] - 1;\\n              } \\n          }\\n\\n      }\\n      return output;\\n    }\\n}\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n      int output = 0;\\n      int n = tickets.length;\\n      for  (int i = 0;i<n;i++){\\n          if(tickets[i] < tickets[k]){\\n              output += tickets[i];\\n          }else{\\n                if(i <= k){\\n                  output += tickets[k];\\n              }else { \\n                  output += tickets[k] - 1;\\n              } \\n          }\\n\\n      }\\n      return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577071,
                "title": "c-0ms-explained-easy-one-pass",
                "content": "Three cases possible are,\\n\\n`If` the ticket holders have less tickets to buy than our Kth ticket holder, they will have got all the tickets they wanted before kth ticket holder gets all its tickets,\\n\\n`else if` the ticket holders have more ticketsto buy than our Kth ticket holder, and they are ahead in line(position < k) then, they will have bought `tickets[k]` tickets before kth ticket holder gets all the tickets it needs,\\n\\n`else if` the ticket holders have more tickets to buy than our Kth ticket holder, and they are behind in line(position > k) then, they will have bought 1 ticket less than `tickets[k]` before kth ticket holder gets all the tickets it needs.\\n\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        int ticket = tickets[k];\\n        int res = 0;\\n        for(int i = 0; i<tickets.size(); i++){\\n          if(tickets[i] < ticket) res+=tickets[i];\\n          else if(tickets[i] >= ticket and i <= k) res+=ticket;\\n          else if(tickets[i] >= ticket and i > k) res+=ticket-1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        int ticket = tickets[k];\\n        int res = 0;\\n        for(int i = 0; i<tickets.size(); i++){\\n          if(tickets[i] < ticket) res+=tickets[i];\\n          else if(tickets[i] >= ticket and i <= k) res+=ticket;\\n          else if(tickets[i] >= ticket and i > k) res+=ticket-1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490739,
                "title": "very-easy-java-solution-using-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        int ans = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            queue.add(i);\\n        }\\n        while(!queue.isEmpty()){\\n            int index = queue.poll();\\n            tickets[index]--;\\n            ans++;\\n            if(tickets[index] == 0 && index == k){\\n                return ans;\\n            }\\n            if(tickets[index] > 0){\\n                queue.add(index);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        int ans = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            queue.add(i);\\n        }\\n        while(!queue.isEmpty()){\\n            int index = queue.poll();\\n            tickets[index]--;\\n            ans++;\\n            if(tickets[index] == 0 && index == k){\\n                return ans;\\n            }\\n            if(tickets[index] > 0){\\n                queue.add(index);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607037,
                "title": "java-simple-code-100-faster",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int seconds = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            if(tickets[i] < tickets[k]) seconds += tickets[i]; // only add the time needed to buy his tickets\\n            else{\\n                if(i <= k) seconds += tickets[k]; \\n                else seconds += tickets[k] - 1; \\n            }\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int seconds = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            if(tickets[i] < tickets[k]) seconds += tickets[i]; // only add the time needed to buy his tickets\\n            else{\\n                if(i <= k) seconds += tickets[k]; \\n                else seconds += tickets[k] - 1; \\n            }\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495619,
                "title": "one-pass-c-easy-to-understand",
                "content": "People infront of our target person will get all their tickets before our target man if they want tickets less than or equal to him. If they want more tickets than him they will only get tickets equal to him till target man gets all his tickets.\\n\\nFor people behind target man, they will get all tickets if they want tickets strictly less than him. If they want more than him, they will get one less than tickets target man wants till he gets all his tickets.\\n\\'\\'\\'\\n              \\n    class Solution {\\n    public:\\n        int timeRequiredToBuy(vector<int>& tickets, int k) {\\n            int n=tickets.size();\\n            int time=tickets[k];\\n            for(int i=0;i<tickets.size();i++){\\n            //Elements infront of target\\n                  //If they are smaller or equal to target value collect them whole \\n                  //If they are greater collect target value\\n            if(i<k){\\n                if(tickets[i]<=tickets[k]){\\n                    time+=tickets[i];\\n                }\\n                else{\\n                    time+=tickets[k];\\n                }\\n            }\\n            //Elements behind target\\n                  //If they are smaller than target value collect them whole \\n                  //If they are greater collect (target-1) value\\n            else if(i>k){\\n                if(tickets[i]<tickets[k]){\\n                    time+=tickets[i];\\n                }\\n                else{\\n                    time+=(tickets[k]-1);\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\t\\t\\t        \\n\\t\\t\\t      \\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n        int timeRequiredToBuy(vector<int>& tickets, int k) {\\n            int n=tickets.size();\\n            int time=tickets[k];\\n            for(int i=0;i<tickets.size();i++){\\n            //Elements infront of target\\n                  //If they are smaller or equal to target value collect them whole \\n                  //If they are greater collect target value\\n            if(i<k){\\n                if(tickets[i]<=tickets[k]){\\n                    time+=tickets[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1642918,
                "title": "simple-c-solution-0ms",
                "content": "This is easy to understand solution..\\nDo give a like!.\\n\\n\\n\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n    int n=tickets.size(),ans=0;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        if(i>k)\\n            ans+=min(tickets[i],tickets[k]-1);\\n        else if(i<k)\\n            ans+=min(tickets[i],tickets[k]);\\n        else\\n            ans+=tickets[k];\\n                \\n    }\\n        \\n    return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "This is easy to understand solution..\\nDo give a like!.\\n\\n\\n\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n    int n=tickets.size(),ans=0;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        if(i>k)\\n            ans+=min(tickets[i],tickets[k]-1);\\n        else if(i<k)\\n            ans+=min(tickets[i],tickets[k]);\\n        else\\n            ans+=tickets[k];\\n                \\n    }\\n        \\n    return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3485730,
                "title": "python3-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        n=len(tickets)\\n        q=deque([i for i in range(n)])\\n        \\n        time=0\\n        \\n        while q:\\n            for i in range(len(q)):\\n\\n                node=q.popleft()\\n                tickets[node]-=1\\n                if tickets[node]>=1:\\n                    q.append(node)\\n                \\n                time+=1\\n                if tickets[k]==0:\\n                    return time\\n                \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        n=len(tickets)\\n        q=deque([i for i in range(n)])\\n        \\n        time=0\\n        \\n        while q:\\n            for i in range(len(q)):\\n\\n                node=q.popleft()\\n                tickets[node]-=1\\n                if tickets[node]>=1:\\n                    q.append(node)\\n                \\n                time+=1\\n                if tickets[k]==0:\\n                    return time\\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253744,
                "title": "c-2-ways-bruteforce-optimal",
                "content": "# Method-1 [Brute Force]\\n\\n![image](https://assets.leetcode.com/users/images/c883d3c4-59d3-430e-a16d-5e1b6532e52b_1657263680.476677.png)\\n\\n**n==t.size()\\nT->O(tickets[k] * n) && S->(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint timeRequiredToBuy(vector<int>& t, int k) {\\n\\t\\t\\tint time=0;\\n\\t\\t\\twhile(1){\\n\\t\\t\\t\\tfor(int i=0;i<t.size();i++){\\n\\t\\t\\t\\t\\tif(t[i]>0){\\n\\t\\t\\t\\t\\t\\tt[i]--;\\n\\t\\t\\t\\t\\t\\ttime++;\\n\\t\\t\\t\\t\\t\\tif(t[k]==0)return time;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t\\n# Method-2 [Optimal solution]\\t\\n\\t\\n![image](https://assets.leetcode.com/users/images/98e24ff0-6f30-429b-8292-63a194bf3895_1657264759.6914196.png)\\n\\n**In one pass!\\nT->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint timeRequiredToBuy(vector<int>& t, int k) {\\n\\t\\t\\tint time=0;\\n\\t\\t\\tfor(int i=0;i<t.size();i++){\\n\\t\\t\\t\\tif(t[i]<t[k])time+=t[i];\\n\\t\\t\\t\\telse time+=t[k];\\n\\t\\t\\t\\tif(i>k && t[i]>=t[k])time--;\\n\\t\\t\\t}\\n\\t\\t\\treturn time;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint timeRequiredToBuy(vector<int>& t, int k) {\\n\\t\\t\\tint time=0;\\n\\t\\t\\twhile(1){\\n\\t\\t\\t\\tfor(int i=0;i<t.size();i++){\\n\\t\\t\\t\\t\\tif(t[i]>0){\\n\\t\\t\\t\\t\\t\\tt[i]--;\\n\\t\\t\\t\\t\\t\\ttime++;\\n\\t\\t\\t\\t\\t\\tif(t[k]==0)return time;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2147186,
                "title": "c-queue-cycle",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<int> q;\\n        for(int i : tickets) q.push(i);\\n        int res = 0;\\n        int p = k;\\n        \\n        while(true){\\n            res++;\\n            if(q.front()-- > 1) q.push(q.front());\\n            else if(p == 0) break;\\n            q.pop();\\n            if(--p < 0) p = q.size() - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<int> q;\\n        for(int i : tickets) q.push(i);\\n        int res = 0;\\n        int p = k;\\n        \\n        while(true){\\n            res++;\\n            if(q.front()-- > 1) q.push(q.front());\\n            else if(p == 0) break;\\n            q.pop();\\n            if(--p < 0) p = q.size() - 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104569,
                "title": "0-ms-java-solution",
                "content": "suppose the given array is [2,3,7,5,1,2,7] and k is pointing to element = 5.\\nwe need to find that each element is reduced how many times till we get 0 at the index 3. The element before 5 will be reduced by = **minimum of (value of ith element, value of kth element)**\\n the element before 5 are [2,3,7,5] and these will be reduced to [0,0,2,0] when the kth guy get ticket \\n \\n![image](https://assets.leetcode.com/users/images/bfea9c2c-94db-4fa0-8e6b-f20bf067424a_1654226809.5009036.png)\\n\\nnow element after 5 are [1,2,7] here we have a case, the element 1,2 will be completly reduce to 0 but the element greater than k will reduce to 1 lesser than the kth element (shown below ) because the kth element guy got the ticket and we don\\'t need to worry about the leftover.\\n\\n![image](https://assets.leetcode.com/users/images/c826088c-eaf7-4d83-9543-a55494e2c89c_1654226960.949127.png)\\n\\n**please upvote my solution if u like it \\u2764\\uFE0F** \\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        for(int i = 0 ; i < tickets.length; ++i){\\n            if(i <=k){\\n                count += Math.min(tickets[i], tickets[k]);\\n            }\\n            else\\n                count += Math.min(tickets[i], tickets[k] - 1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        for(int i = 0 ; i < tickets.length; ++i){\\n            if(i <=k){\\n                count += Math.min(tickets[i], tickets[k]);\\n            }\\n            else\\n                count += Math.min(tickets[i], tickets[k] - 1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084750,
                "title": "python-simple-readable-easy-to-understand-solution-beats-69",
                "content": "The approach is as follows:\\n1. Keep track of the number of seconds (this is what will be returned)\\n2. As long as the person at k index still has tickets to buy:\\n\\t* Sell tickets to everyone in the line who still has tickets to buy\\n\\t* Add a second for each ticket sold\\n3. Return how many seconds were needed to sell the person at k index all of their tickets\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        num_seconds = 0\\n        \\n        while tickets[k] > 0:\\n            for i in range(len(tickets)):\\n                if tickets[i] > 0 and tickets[k] > 0:\\n                    tickets[i] -= 1\\n                    num_seconds += 1\\n\\n        return num_seconds\\n```\\n![image](https://assets.leetcode.com/users/images/6c478172-bc00-416c-9d13-fbda59d8cb15_1653763898.4271393.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        num_seconds = 0\\n        \\n        while tickets[k] > 0:\\n            for i in range(len(tickets)):\\n                if tickets[i] > 0 and tickets[k] > 0:\\n                    tickets[i] -= 1\\n                    num_seconds += 1\\n\\n        return num_seconds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958399,
                "title": "c-easy-o-n",
                "content": "***Upvote If you like the solution***\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int num=tickets[k],tt=0;\\n        for(int i=0;i<tickets.size();i++){\\n            if(num>tickets[i]){\\n                tt+=tickets[i];\\n            }\\n            else if(num<=tickets[i]){\\n                tt+=num;\\n            }\\n        }\\n        for(int i=k+1;i<tickets.size();i++){\\n            if(tickets[i]>=num){\\n                tt-=1;\\n            }\\n        }\\n        return tt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int num=tickets[k],tt=0;\\n        for(int i=0;i<tickets.size();i++){\\n            if(num>tickets[i]){\\n                tt+=tickets[i];\\n            }\\n            else if(num<=tickets[i]){\\n                tt+=num;\\n            }\\n        }\\n        for(int i=k+1;i<tickets.size();i++){\\n            if(tickets[i]>=num){\\n                tt-=1;\\n            }\\n        }\\n        return tt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612829,
                "title": "python-o-n-time-complexity-faster-than-97",
                "content": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        ans = 0\\n        \\n\\t\\t# people at the front will always get 1 ticket first\\n\\t\\t# get minimum to know how many times a person will queue and buy before kth person\\n        for tix in range(k+1):\\n            ans += min(tickets[tix], tickets[k])\\n\\n\\t\\t# contrary to people at the front, \\n\\t\\t# kth person will only go behind everyone *(people initially behind k)* for tickets[k]-1 times \\n        for tix in range(k+1, len(tickets)):\\n            ans += min(tickets[tix], tickets[k]-1)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        ans = 0\\n        \\n\\t\\t# people at the front will always get 1 ticket first\\n\\t\\t# get minimum to know how many times a person will queue and buy before kth person\\n        for tix in range(k+1):\\n            ans += min(tickets[tix], tickets[k])\\n\\n\\t\\t# contrary to people at the front, \\n\\t\\t# kth person will only go behind everyone *(people initially behind k)* for tickets[k]-1 times \\n        for tix in range(k+1, len(tickets)):\\n            ans += min(tickets[tix], tickets[k]-1)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576949,
                "title": "python3-1-line",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/8d693371fa97ea3b0717d02448c77201b15e5d12) for solutions of weekly 267.\\n\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(min(tickets[k]-int(i>k), x) for i, x in enumerate(tickets))\\n```\\n\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        ans = behind = 0 \\n        for i, x in enumerate(tickets): \\n            if i > k: behind = 1\\n            if x < tickets[k] - behind: ans += x\\n            else: ans += tickets[k] - behind\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(min(tickets[k]-int(i>k), x) for i, x in enumerate(tickets))\\n```\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        ans = behind = 0 \\n        for i, x in enumerate(tickets): \\n            if i > k: behind = 1\\n            if x < tickets[k] - behind: ans += x\\n            else: ans += tickets[k] - behind\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981218,
                "title": "two-simple-solutions-in-python3-queue-ds-inifinite-looping",
                "content": "# Intuition\\nFollowing to the description of the problem, the task goal is to calculate **min amount of time**, that `K`- buyer needs to spend in order to buy tickets.\\n\\nSomehow we need to iterate over all buyers, reduce the current amount of tickets they\\'re bying at the moment, shift the current buyer to **the END of a** `queue` and repeat the process.\\n\\n---\\n\\n- **Queue DS**\\n\\nIf you haven\\'t already familiar with [Queue DS](https://en.wikipedia.org/wiki/Queue_(abstract_data_type)), just follow the link to know more!\\n\\n1. change `tickets` variable by initializing a `deque` and **map** `i` and `v` for current buyer, \\n2. initialize `ans` variable and `while` loop, that\\'ll iterate **infinitely**\\n3. pop from `tickets` current buyer\\n4. increment total amount `ans` \\n5. check, if the current buyer has bought all of the tickets, and return `ans`\\n6. otherwise, if he needs to buy **more** tickets, return him to the `tickets` queue\\n\\n```python\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        tickets = deque([[i, v] for i, v in enumerate(tickets)])\\n        ans = 0\\n\\n        while True:\\n            i, v = tickets.popleft()\\n            ans += 1\\n\\n            if i == k and v - 1 == 0:\\n                return ans\\n            \\n            if v > 1:\\n                tickets.append([i, v - 1])\\n```\\n# Complexity\\n- Time complexity: **O(n)**, because of iterating infinitely over all `tickets` buyers\\n\\n- Space complexity: **O(n)**, to map indexes and values for `tickets`\\n\\n---\\n\\n- **Inifinite looping**\\nThe approach is the same, but we **mutate** the initial values of `tickets`.\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        if tickets[k] == 0:\\n            return 0\\n        \\n        i = 0\\n        ans = 0\\n\\n        while True:\\n            if tickets[i]:\\n                tickets[i] -= 1\\n                ans += 1\\n\\n            if i == k and tickets[i] == 0:\\n                return ans\\n            \\n            i += 1\\n            \\n            if i == len(tickets):\\n                i = 0\\n\\n```\\n\\n# Complexity\\n- Time complexity: **O(n)**, because of iterating infinitely over all `tickets` buyers\\n\\n- Space complexity: **O(1)**, because we don\\'t use extra space.\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Queue"
                ],
                "code": "```python\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        tickets = deque([[i, v] for i, v in enumerate(tickets)])\\n        ans = 0\\n\\n        while True:\\n            i, v = tickets.popleft()\\n            ans += 1\\n\\n            if i == k and v - 1 == 0:\\n                return ans\\n            \\n            if v > 1:\\n                tickets.append([i, v - 1])\\n```\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\\n        if tickets[k] == 0:\\n            return 0\\n        \\n        i = 0\\n        ans = 0\\n\\n        while True:\\n            if tickets[i]:\\n                tickets[i] -= 1\\n                ans += 1\\n\\n            if i == k and tickets[i] == 0:\\n                return ans\\n            \\n            i += 1\\n            \\n            if i == len(tickets):\\n                i = 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367526,
                "title": "time-needed-to-buy-tickets-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int i, time=0;\\n        while(true)\\n        {\\n            for(i=0 ; i<tickets.size() ; i++)\\n            {\\n                if(tickets[k]==0)\\n                    return time;\\n                else if(tickets[i]>0)\\n                {\\n                    tickets[i]--;\\n                    time++;\\n                }\\n            }\\n            i=0;\\n        }\\n        return time;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int i, time=0;\\n        while(true)\\n        {\\n            for(i=0 ; i<tickets.size() ; i++)\\n            {\\n                if(tickets[k]==0)\\n                    return time;\\n                else if(tickets[i]>0)\\n                {\\n                    tickets[i]--;\\n                    time++;\\n                }\\n            }\\n            i=0;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158772,
                "title": "easy-solution-with-explanation",
                "content": "If you like it, please upvote\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    // current index\\n    let i = 0;\\n    // number of steps\\n    let steps = 0;\\n\\n    // while tickets[k] > 0\\n    while (tickets[k]) {\\n        // we do not need to reset i because it is easier to calculate index in the array\\n        const index = i % tickets.length;\\n        if (tickets[index]) {\\n            // if element is not 0 then decrement the value and increment the number of steps\\n            tickets[index]--;\\n            steps++;\\n        }\\n        // every time move to next element\\n        i++;\\n    }\\n\\n    return steps;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    // current index\\n    let i = 0;\\n    // number of steps\\n    let steps = 0;\\n\\n    // while tickets[k] > 0\\n    while (tickets[k]) {\\n        // we do not need to reset i because it is easier to calculate index in the array\\n        const index = i % tickets.length;\\n        if (tickets[index]) {\\n            // if element is not 0 then decrement the value and increment the number of steps\\n            tickets[index]--;\\n            steps++;\\n        }\\n        // every time move to next element\\n        i++;\\n    }\\n\\n    return steps;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3076905,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans =0;\\n        for(int i=0;i<tickets.length;i++){\\n            if(i<=k){\\n                ans+=Math.min(tickets[i],tickets[k]);\\n            }else{\\n                ans+=Math.min(tickets[k]-1,tickets[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans =0;\\n        for(int i=0;i<tickets.length;i++){\\n            if(i<=k){\\n                ans+=Math.min(tickets[i],tickets[k]);\\n            }else{\\n                ans+=Math.min(tickets[k]-1,tickets[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061869,
                "title": "java-1ms-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        while (tickets[k] != 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[i] > 0) {\\n                    count++;\\n                    tickets[i]--;\\n                }\\n                if (i == k && tickets[k] == 0) break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        while (tickets[k] != 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[i] > 0) {\\n                    count++;\\n                    tickets[i]--;\\n                }\\n                if (i == k && tickets[k] == 0) break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936461,
                "title": "cpp-queue-easiest-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        queue<int> q;\\n        int n=tickets.size();\\n        for(int i=0;i<n;i++) q.push(i);\\n\\n        while(true)\\n        {\\n            if(tickets[k]==0) break;\\n            int curr=q.front();\\n            time++;\\n            tickets[curr]--;\\n            q.pop();\\n            if(tickets[curr]!=0) \\n            {\\n                q.push(curr);\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        queue<int> q;\\n        int n=tickets.size();\\n        for(int i=0;i<n;i++) q.push(i);\\n\\n        while(true)\\n        {\\n            if(tickets[k]==0) break;\\n            int curr=q.front();\\n            time++;\\n            tickets[curr]--;\\n            q.pop();\\n            if(tickets[curr]!=0) \\n            {\\n                q.push(curr);\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919190,
                "title": "c-basic-solution-beats-100",
                "content": "# Intuition\\nBasic C++ Solution using logic\\n\\n# Approach\\nCounting tickets to be bought before and after k by taking minima.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        for(int i=0;i<tickets.size();i++){\\n            if(i<=k)\\n              time+=min(tickets[i],tickets[k]);\\n            else\\n              time+=min(tickets[k]-1,tickets[i]);\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        for(int i=0;i<tickets.size();i++){\\n            if(i<=k)\\n              time+=min(tickets[i],tickets[k]);\\n            else\\n              time+=min(tickets[k]-1,tickets[i]);\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903503,
                "title": "js-very-easy-and-fast-solution-o-n",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let output = 0;\\n    const kTickets = tickets[k];\\n    for (let i = 0; i < tickets.length; i++) {\\n        if (i !== k) {\\n            const currentTickets = tickets[i];\\n            const dif = currentTickets - kTickets;\\n            if (i < k) {\\n                output += kTickets + (dif < 0 ? dif : 0);\\n            } else {\\n                output += (dif + 1 > 0 ? kTickets - 1 : currentTickets);\\n            }\\n        }\\n    }\\n    return output + kTickets;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let output = 0;\\n    const kTickets = tickets[k];\\n    for (let i = 0; i < tickets.length; i++) {\\n        if (i !== k) {\\n            const currentTickets = tickets[i];\\n            const dif = currentTickets - kTickets;\\n            if (i < k) {\\n                output += kTickets + (dif < 0 ? dif : 0);\\n            } else {\\n                output += (dif + 1 > 0 ? kTickets - 1 : currentTickets);\\n            }\\n        }\\n    }\\n    return output + kTickets;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852598,
                "title": "java-code-without-queue-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n    int ans=0;\\n\\n    while(tickets[k]>0){\\n        \\n    int count=0;\\n\\n    for(int j=0;j<tickets.length;j++){\\n\\n        if(tickets[j]>0&&tickets[k]!=0){\\n            tickets[j]-=1;\\n            count+=1;\\n        }\\n\\n    }\\n\\n    ans=ans+count;\\n\\n    }\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n    int ans=0;\\n\\n    while(tickets[k]>0){\\n        \\n    int count=0;\\n\\n    for(int j=0;j<tickets.length;j++){\\n\\n        if(tickets[j]>0&&tickets[k]!=0){\\n            tickets[j]-=1;\\n            count+=1;\\n        }\\n\\n    }\\n\\n    ans=ans+count;\\n\\n    }\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724197,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int time=tickets[k];\\n        for(int i=0;i<tickets.size();i++){\\n        if(i<k){\\n            if(tickets[i]<=tickets[k]){\\n                time+=tickets[i];\\n            }\\n            else{\\n                time+=tickets[k];\\n            }\\n        }\\n        else if(i>k){\\n            if(tickets[i]<tickets[k]){\\n                time+=tickets[i];\\n            }\\n            else{\\n                time+=(tickets[k]-1);\\n            }\\n        }\\n    }\\n    return time;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int time=tickets[k];\\n        for(int i=0;i<tickets.size();i++){\\n        if(i<k){\\n            if(tickets[i]<=tickets[k]){\\n                time+=tickets[i];\\n            }\\n            else{\\n                time+=tickets[k];\\n            }\\n        }\\n        else if(i>k){\\n            if(tickets[i]<tickets[k]){\\n                time+=tickets[i];\\n            }\\n            else{\\n                time+=(tickets[k]-1);\\n            }\\n        }\\n    }\\n    return time;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596216,
                "title": "java-time-complexity-o-n-and-space-complexity-o-1-100-faster",
                "content": "Idea is quite simple\\n1. All the seconds will be consumed if tickets[i] < tickets [k].\\n2. If tickets[i] > tickets[k] then only tickets[k] will be consumed.\\n3. Just an exception to the 2nd point is that for the last iteration when all the people will consume 1 second, this will be people from 0 -> k. Hence we do tickets[k] - 1\\n\\n```\\nint minRequired = tickets[k];\\n        int output = 0;\\n\\n        for (int i = 0; i < tickets.length; i++) {\\n            if(tickets[i] < minRequired){\\n                output += tickets[i];\\n            }else {\\n\\n                if(i > k){\\n                    output--;\\n                }\\n                output += minRequired;\\n            }\\n        }\\n\\n        return output;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Idea is quite simple\\n1. All the seconds will be consumed if tickets[i] < tickets [k].\\n2. If tickets[i] > tickets[k] then only tickets[k] will be consumed.\\n3. Just an exception to the 2nd point is that for the last iteration when all the people will consume 1 second, this will be people from 0 -> k. Hence we do tickets[k] - 1\\n\\n```\\nint minRequired = tickets[k];\\n        int output = 0;\\n\\n        for (int i = 0; i < tickets.length; i++) {\\n            if(tickets[i] < minRequired){\\n                output += tickets[i];\\n            }else {\\n\\n                if(i > k){\\n                    output--;\\n                }\\n                output += minRequired;\\n            }\\n        }\\n\\n        return output;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2558725,
                "title": "java-solution-using-single-queue",
                "content": "In this solution, I multiply the target index \\'k\\' content with \\'-1\\'. to keep track of the customer.\\nAnd, I reduce the number of tickets by 1. Once the target customer\\'s tickets count reduces to zero, I return the time-taken.\\n\\n```java\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n        if(tickets[k] == 0) return 0;\\n        \\n        tickets[k] = -1 * tickets[k];\\n        \\n        Deque<Integer> queue = new ArrayDeque<>();\\n        for(int n : tickets){\\n            if(n != 0) queue.offerLast(n);\\n        }\\n        \\n        int timeTaken = 0;\\n        \\n        while(!queue.isEmpty()){\\n            int ticket = queue.pollFirst();\\n            \\n            boolean target = ticket < 0;\\n            \\n            if(ticket < 0) ticket += 1;\\n            else ticket -= 1;\\n            \\n            ++timeTaken;\\n            \\n            if(ticket == 0 && target) break;\\n            if(ticket != 0) queue.offerLast(ticket);\\n        }\\n        \\n        return timeTaken;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue",
                    "Iterator"
                ],
                "code": "```java\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        \\n        if(tickets[k] == 0) return 0;\\n        \\n        tickets[k] = -1 * tickets[k];\\n        \\n        Deque<Integer> queue = new ArrayDeque<>();\\n        for(int n : tickets){\\n            if(n != 0) queue.offerLast(n);\\n        }\\n        \\n        int timeTaken = 0;\\n        \\n        while(!queue.isEmpty()){\\n            int ticket = queue.pollFirst();\\n            \\n            boolean target = ticket < 0;\\n            \\n            if(ticket < 0) ticket += 1;\\n            else ticket -= 1;\\n            \\n            ++timeTaken;\\n            \\n            if(ticket == 0 && target) break;\\n            if(ticket != 0) queue.offerLast(ticket);\\n        }\\n        \\n        return timeTaken;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195525,
                "title": "java-o-n-100-faster-solution",
                "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int t=tickets[k],tt=0;\\n        \\n        for(int i=0;i<tickets.length;i++){\\n            if(i<=k){\\n                if(tickets[i]<=t){\\n                    tt+=tickets[i];\\n                }else{\\n                    tt+=t;\\n                }\\n            }else{\\n                if(tickets[i]<t){\\n                    tt+=tickets[i];\\n                }else{\\n                    tt+=(t-1);\\n                }\\n            }\\n        }\\n        \\n        return tt;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int t=tickets[k],tt=0;\\n        \\n        for(int i=0;i<tickets.length;i++){\\n            if(i<=k){\\n                if(tickets[i]<=t){\\n                    tt+=tickets[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2126547,
                "title": "c-solution-0ms-100-faster-explained",
                "content": "**Method:**\\n\\n* There can be 3 cases:\\n* Case 1 :\\n    * If the ticket holders have less tickets to buy than our Kth ticket holder\\n    * Then, they will have got all the tickets they wanted before kth ticket holder gets all its tickets\\n* Case 2:\\n    * if the ticket holders have more tickets to buy than our Kth ticket holder and they are ahead in line(position < k) \\n    * Then, they will have bought \"tickets[k]\" tickets before kth ticket holder gets all the tickets it needs\\n* Case 3:\\n    * if the ticket holders have more tickets to buy than our Kth ticket holder, and they are behind in line(position > k) \\n    * Then, they will have bought 1 ticket less than tickets[k] before kth ticket holder gets all the tickets it needs.\\n\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int timeRequiredToBuy(vector<int> &tickets, int k)\\n    {\\n        int n = tickets.size();\\n        int t = tickets[k];\\n        int s = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (tickets[i] < t)\\n            {\\n                s += tickets[i];\\n            }\\n            else\\n            {\\n                if (i <= k)\\n                {\\n                    s += t;\\n                }\\n                else\\n                {\\n                    s += t - 1;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int timeRequiredToBuy(vector<int> &tickets, int k)\\n    {\\n        int n = tickets.size();\\n        int t = tickets[k];\\n        int s = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (tickets[i] < t)\\n            {\\n                s += tickets[i];\\n            }\\n            else\\n            {\\n                if (i <= k)\\n                {\\n                    s += t;\\n                }\\n                else\\n                {\\n                    s += t - 1;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903082,
                "title": "python-solution-using-list-as-queue",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        c=0\\n        while(tickets[k]!=0):\\n            c+=1\\n\\t\\t\\t#check if kth element is now the first element of our queue.\\n            if(tickets[0]==1):\\n                tickets.pop(0)\\n                if(k==0):\\n                    return(c)\\n                else:\\n                    k-=1\\n            else:\\n\\t\\t\\t#if no of tickets of person at first position in queue are more than 1 we move to the back\\n                tickets.append(tickets[0]-1)\\n                tickets.pop(0)\\n                if(k==0):\\n                    k=len(tickets)-1\\n                else:\\n                    k-=1\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        c=0\\n        while(tickets[k]!=0):\\n            c+=1\\n\\t\\t\\t#check if kth element is now the first element of our queue.\\n            if(tickets[0]==1):\\n                tickets.pop(0)\\n                if(k==0):\\n                    return(c)\\n                else:\\n                    k-=1\\n            else:\\n\\t\\t\\t#if no of tickets of person at first position in queue are more than 1 we move to the back\\n                tickets.append(tickets[0]-1)\\n                tickets.pop(0)\\n                if(k==0):\\n                    k=len(tickets)-1\\n                else:\\n                    k-=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826842,
                "title": "c-solution-with-comments-faster-than-100-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int need = tickets[k];\\n        int wait = need; // k has to buy their own tickets.\\n        \\n        // For each person ahead of k in line, k has to wait for them\\n        // to buy up to as many tickets as k needs.\\n        for (int i = 0; i < k; ++i) {\\n            wait += tickets[i] > need ? need : tickets[i];\\n        }\\n        \\n        // For each person in line after k, k has to wait for them\\n        // to buy up to 1 fewer ticket than k needs.\\n        --need;\\n        for (int i = k + 1; i < tickets.size(); ++i) {\\n            wait += tickets[i] > need ? need : tickets[i];\\n        }\\n        \\n        return wait;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int need = tickets[k];\\n        int wait = need; // k has to buy their own tickets.\\n        \\n        // For each person ahead of k in line, k has to wait for them\\n        // to buy up to as many tickets as k needs.\\n        for (int i = 0; i < k; ++i) {\\n            wait += tickets[i] > need ? need : tickets[i];\\n        }\\n        \\n        // For each person in line after k, k has to wait for them\\n        // to buy up to 1 fewer ticket than k needs.\\n        --need;\\n        for (int i = k + 1; i < tickets.size(); ++i) {\\n            wait += tickets[i] > need ? need : tickets[i];\\n        }\\n        \\n        return wait;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726337,
                "title": "c-o-n-solution",
                "content": "eg: [84,49,5,24,70,77,87,8]\\n       k = 3\\n\\t   time added due to index 0(84) : 24\\n\\t   time added due to index 1(49) : 24\\n\\t   time added due to index 2(5) : 5\\n\\t   time added due to index 3(24) : 24\\n\\t   time added due to index 4(70) : 23 (because index 3 becomes 0 first).\\n\\t   time added due to index 5(77) : 23 (because index 3 becomes 0 first).\\n\\t   time added due to index 5(87) : 23 (because index 3 becomes 0 first).\\n\\t   time added due to index 6(8) : 8\\n     total time = 154 ans\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        int time = 0;\\n        for(int i = 0;i < n;i++){\\n            if(tickets[i] <= tickets[k])\\n                time += tickets[i];\\n            else\\n                time += tickets[k];\\n            if(i > k && tickets[i] >= tickets[k])\\n                time--;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        int time = 0;\\n        for(int i = 0;i < n;i++){\\n            if(tickets[i] <= tickets[k])\\n                time += tickets[i];\\n            else\\n                time += tickets[k];\\n            if(i > k && tickets[i] >= tickets[k])\\n                time--;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604802,
                "title": "python-one-pass-o-1-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        x=tickets[k]\\n        answer=0\\n        for i in range(0,k+1):\\n            answer+=min(x,tickets[i])\\n        \\n        for i in range(k+1,len(tickets)):\\n            answer+=min(x-1,tickets[i]) \\n        \\n        return answer",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        x=tickets[k]\\n        answer=0\\n        for i in range(0,k+1):\\n            answer+=min(x,tickets[i])\\n        \\n        for i in range(k+1,len(tickets)):\\n            answer+=min(x-1,tickets[i]) \\n        \\n        return answer",
                "codeTag": "Java"
            },
            {
                "id": 1599519,
                "title": "one-pass-100-solution-o-n",
                "content": "if you like it pls upvote\\n\\nJava\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int res = 0;\\n        \\n        for(int i = 0;i<k;i++){\\n            if(tickets[i] >= tickets[k])\\n                res+= tickets[k];\\n            else\\n                res+= tickets[i];\\n        }\\n        for(int i = k+1;i<tickets.length;i++){\\n            if(tickets[i] >= tickets[k]-1)\\n                res+= tickets[k]-1;\\n            else\\n                res+= tickets[i];\\n        }\\n        \\n        return res + tickets[k];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int res = 0;\\n        \\n        for(int i = 0;i<k;i++){\\n            if(tickets[i] >= tickets[k])\\n                res+= tickets[k];\\n            else\\n                res+= tickets[i];\\n        }\\n        for(int i = k+1;i<tickets.length;i++){\\n            if(tickets[i] >= tickets[k]-1)\\n                res+= tickets[k]-1;\\n            else\\n                res+= tickets[i];\\n        }\\n        \\n        return res + tickets[k];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577065,
                "title": "c-brute-force",
                "content": "```\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int res = 0;\\n        while(tickets[k] != 0){\\n            for(int i=0; i<tickets.size(); i++){\\n                if(tickets[i] > 0){\\n                    tickets[i] -= 1;\\n                    res += 1;\\n                }\\n                if(tickets[k] == 0) break;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int res = 0;\\n        while(tickets[k] != 0){\\n            for(int i=0; i<tickets.size(); i++){\\n                if(tickets[i] > 0){\\n                    tickets[i] -= 1;\\n                    res += 1;\\n                }\\n                if(tickets[k] == 0) break;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577017,
                "title": "javascript-one-pass",
                "content": "```javascript\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let total = 0;\\n    for (let i = 0; i < tickets.length; i++) {\\n        if (i === k || tickets[i] < tickets[k]) {\\n            total += tickets[i];\\n        } else if (i > k) {\\n            total +=  tickets[k] - 1;\\n        } else {\\n            total += tickets[k];\\n        }\\n    }\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let total = 0;\\n    for (let i = 0; i < tickets.length; i++) {\\n        if (i === k || tickets[i] < tickets[k]) {\\n            total += tickets[i];\\n        } else if (i > k) {\\n            total +=  tickets[k] - 1;\\n        } else {\\n            total += tickets[k];\\n        }\\n    }\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576972,
                "title": "c-2073-time-needed-to-buy-tickets",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0; \\n        for (int i = 0; i < tickets.size(); ++i) {\\n            if (i == k+1) tickets[k] -= 1; \\n            ans += min(tickets[i], tickets[k]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0; \\n        for (int i = 0; i < tickets.size(); ++i) {\\n            if (i == k+1) tickets[k] -= 1; \\n            ans += min(tickets[i], tickets[k]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576966,
                "title": "python-brute-force",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        ret = 0\\n        while tickets[k]:\\n            for i, t in enumerate(tickets):\\n                if t > 0:\\n                    tickets[i] = tickets[i] - 1\\n                    ret += 1\\n                if i == k:\\n                    if tickets[i] == 0:\\n                        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        ret = 0\\n        while tickets[k]:\\n            for i, t in enumerate(tickets):\\n                if t > 0:\\n                    tickets[i] = tickets[i] - 1\\n                    ret += 1\\n                if i == k:\\n                    if tickets[i] == 0:\\n                        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576950,
                "title": "java-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] arr, int k) {\\n        int count = 0;\\n        while(true)\\n        {\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                if(arr[i]>0)\\n                {\\n                    arr[i] = arr[i]-1;\\n                    count = count+1;\\n                }\\n                if(arr[k] == 0)\\n                {\\n                    return count;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] arr, int k) {\\n        int count = 0;\\n        while(true)\\n        {\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                if(arr[i]>0)\\n                {\\n                    arr[i] = arr[i]-1;\\n                    count = count+1;\\n                }\\n                if(arr[k] == 0)\\n                {\\n                    return count;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894192,
                "title": "c-linq",
                "content": "```\\npublic class Solution {\\n    public int TimeRequiredToBuy(int[] tickets, int k)\\n      => tickets\\n          .Select((n, i) => Math.Min(n, tickets[k]) - (i > k && n >= tickets[k] ? 1 : 0))\\n          .Sum();\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int TimeRequiredToBuy(int[] tickets, int k)\\n      => tickets\\n          .Select((n, i) => Math.Min(n, tickets[k]) - (i > k && n >= tickets[k] ? 1 : 0))\\n          .Sum();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668409,
                "title": "c-solution-using-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int summation(vector<int>tickets){\\n        int sum = 0 ; \\n        for(int i = 0 ; i < tickets.size() ; i++){\\n            sum += tickets[i];\\n        }\\n        return sum;\\n    }\\n    int solve(vector<int> tickets, int k,int mid){\\n        int i = 0;\\n        int n = tickets.size();\\n        while(mid != 0){\\n            if(tickets[i] != 0){\\n                mid--;\\n                tickets[i]--;\\n            }\\n            i = (i + 1) % n;;\\n            if(tickets[k] == 0){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int sum = summation(tickets);\\n        \\n        int s = 1 , e = sum , ans = 0;\\n\\n        while(s <= e){\\n            int mid = s + (e - s) / 2;\\n            int val = solve(tickets,k,mid);\\n\\n            if(val == 0){\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else{\\n                s = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int summation(vector<int>tickets){\\n        int sum = 0 ; \\n        for(int i = 0 ; i < tickets.size() ; i++){\\n            sum += tickets[i];\\n        }\\n        return sum;\\n    }\\n    int solve(vector<int> tickets, int k,int mid){\\n        int i = 0;\\n        int n = tickets.size();\\n        while(mid != 0){\\n            if(tickets[i] != 0){\\n                mid--;\\n                tickets[i]--;\\n            }\\n            i = (i + 1) % n;;\\n            if(tickets[k] == 0){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int sum = summation(tickets);\\n        \\n        int s = 1 , e = sum , ans = 0;\\n\\n        while(s <= e){\\n            int mid = s + (e - s) / 2;\\n            int val = solve(tickets,k,mid);\\n\\n            if(val == 0){\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else{\\n                s = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633906,
                "title": "time-needed-to-buy-tickets-queue-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI will be taking the given array index in the queue array rather than the acutal stored values.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will first enqueue index of the given array in the queue array. We are queuing the array index rather than its value because we need to focus on the person for who we need to find the time taken to buy his tickets. The time will be incremented by 1s for everytime we iterate over the loop. First we will assign the first/front element of the queue to the temp variable(here in my program it is front). Then we will dequeue that first element from the <b>queue</b>. After that we will start checking with the conditions. First condition is, we will check for the value of the tickets[front] is atleast 1 if it is, then we will decrement it by 1. Second Condition, we will check if the front(temp variable) is equal to the k and if the value of the tickets[front] is 0 if it is, then we will break the loop and return the time. Third Condition, we will check if the front!=k and the tickets[front] is equal to 0 if it is, we will continue with the iteration we don\\'t enqueue that element again in the queue. If the condition 2, 3 fails then will enqueue that front(temp variable) in the queue again.\\n\\nAt last of the code I have reintialized the head and tail to -1; As sometimes there are some unexpected behavior in leetcode while executing the test cases.\\n\\n# Code\\n```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define N 10000 \\n\\nint queue[N];\\n\\nint head=-1, tail=-1; \\n\\nint isEmpty(), isFull();\\n\\nvoid enqueue(int x), dequeue();\\nint peek();\\n\\nint isEmpty() {\\n    if(head == -1 && tail==-1) \\n        return 1;\\n    else \\n        return 0;\\n}\\n\\nint isFull() {\\n    if(tail==N-1)\\n        return 1;\\n    else\\n        return 0;\\n}\\n\\nvoid enqueue(int x) {\\n    if(isFull()) { \\n        printf(\"ERROR: queue overflow\\\\n\");\\n        exit(1); //Enqueuing Failure\\n    }\\n    else if(isEmpty()) {\\n        tail++, head++;\\n        queue[tail] = x;\\n    }\\n    else {\\n        queue[++tail] = x;\\n    }\\n}\\n\\nvoid dequeue() {\\n   if(isEmpty()) {\\n    printf(\"ERROR: queue underflow\\\\n add some elements\\\\n\");\\n   }\\n   else if(head == tail) {\\n    head = -1;\\n    tail = -1;\\n   }\\n   else if(!isEmpty()) {\\n    queue[head++];\\n   }\\n}\\n\\nint peek() {\\n    if(isEmpty()) {\\n        printf(\"NO ELEMENTS\\\\n\");\\n        return;\\n    }\\n    else {\\n       return queue[head];\\n    }\\n}\\n\\n\\nint timeRequiredToBuy(int* tickets, int ticketsSize, int k){\\n    int time=0;\\n    for(int itr=0; itr<ticketsSize; itr++) {\\n        enqueue(itr);\\n    }\\n    while(1) {\\n       time++; \\n       int front=peek();\\n       dequeue();\\n       if(tickets[front]>=1) \\n\\t       tickets[front]--;\\n       if(tickets[front]==0 && front!=k)\\n\\t       continue;\\n       if(tickets[front]==0 && front==k)\\n\\t       break;\\n       enqueue(front);\\n    }\\n    head=-1;\\n    tail=-1;\\n    return time;\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define N 10000 \\n\\nint queue[N];\\n\\nint head=-1, tail=-1; \\n\\nint isEmpty(), isFull();\\n\\nvoid enqueue(int x), dequeue();\\nint peek();\\n\\nint isEmpty() {\\n    if(head == -1 && tail==-1) \\n        return 1;\\n    else \\n        return 0;\\n}\\n\\nint isFull() {\\n    if(tail==N-1)\\n        return 1;\\n    else\\n        return 0;\\n}\\n\\nvoid enqueue(int x) {\\n    if(isFull()) { \\n        printf(\"ERROR: queue overflow\\\\n\");\\n        exit(1); //Enqueuing Failure\\n    }\\n    else if(isEmpty()) {\\n        tail++, head++;\\n        queue[tail] = x;\\n    }\\n    else {\\n        queue[++tail] = x;\\n    }\\n}\\n\\nvoid dequeue() {\\n   if(isEmpty()) {\\n    printf(\"ERROR: queue underflow\\\\n add some elements\\\\n\");\\n   }\\n   else if(head == tail) {\\n    head = -1;\\n    tail = -1;\\n   }\\n   else if(!isEmpty()) {\\n    queue[head++];\\n   }\\n}\\n\\nint peek() {\\n    if(isEmpty()) {\\n        printf(\"NO ELEMENTS\\\\n\");\\n        return;\\n    }\\n    else {\\n       return queue[head];\\n    }\\n}\\n\\n\\nint timeRequiredToBuy(int* tickets, int ticketsSize, int k){\\n    int time=0;\\n    for(int itr=0; itr<ticketsSize; itr++) {\\n        enqueue(itr);\\n    }\\n    while(1) {\\n       time++; \\n       int front=peek();\\n       dequeue();\\n       if(tickets[front]>=1) \\n\\t       tickets[front]--;\\n       if(tickets[front]==0 && front!=k)\\n\\t       continue;\\n       if(tickets[front]==0 && front==k)\\n\\t       break;\\n       enqueue(front);\\n    }\\n    head=-1;\\n    tail=-1;\\n    return time;\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3450924,
                "title": "javascript-100-o-n-time-o-1-space",
                "content": "# Approach\\n\\nTake the `tickets` array below as an example.\\n\\n`[ 8, 2, 4, 6, 1]`\\n\\nIf we wanted to compute the result for `k = 2` (`tickets[2] = 4`), we would have to consider the following scenarios:\\n\\n1. It would take 4 seconds to buy the tickets for the target person, since `tickets[k] == 4`\\n2. `tickets[0]` is 8, but we only need 4 tickets, therefore we only wait for him 4 times\\n3. `tickets[1]` is 2, which is smaller than 4. This person would leave the before we finish buying our tickets, therefore we would only wait for him 2 times\\n4. `tickets[3]` is 6, but we are initially in front of him, therefore we only wait for him after we are placed at the back of the queue, or `tickets[k] - 1` times\\n\\n```\\nfunction timeRequiredToBuy(tickets, k) {\\n    // Scenario 1\\n    let result = tickets[k];\\n\\n    // Scenario 2 and 3\\n    for (let i = 0; i < k; i++) {\\n        result += Math.min(tickets[k], tickets[i]);\\n    }\\n\\n    // Scenario 4\\n    for (let i = k + 1; i < tickets.length; i++) {\\n        result += Math.min(tickets[k] - 1, tickets[i]);\\n    }\\n\\n    return result;\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nfunction timeRequiredToBuy(tickets, k) {\\n    // Scenario 1\\n    let result = tickets[k];\\n\\n    // Scenario 2 and 3\\n    for (let i = 0; i < k; i++) {\\n        result += Math.min(tickets[k], tickets[i]);\\n    }\\n\\n    // Scenario 4\\n    for (let i = k + 1; i < tickets.length; i++) {\\n        result += Math.min(tickets[k] - 1, tickets[i]);\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3198622,
                "title": "100-easy-js-solution-explained-with-proper-intuition-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n- Implemented the problem with the *greedy approach* that involves buying tickets from a queue.\\n- The *goal* of the problem is :-\\n*\"To calculate the amount of time required to buy all the tickets at position k, where each purchase takes one unit of time and the buyer moves to the next position in the queue after each purchase.\"*\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- The *tickets* array represents the number of available tickets at each *position* in the *queue*, and the function *timeRequiredToBuy* takes *two* *arguments*: *tickets* and *k*.\\n1. The approach taken in the below code is to use a *while* loop that continues until the kth element of the tickets array becomes 0. \\n2. Within the *while* loop, the code uses a *modulo operator* to wrap around the queue and ensure that it starts over at the beginning after reaching the end.\\n3. On each *iteration* of the *while* loop, the code checks if the current position has any *available tickets*.\\n4.  If it does, it *decrements* the ticket count and increments a counter for the number of tickets purchased.\\n5. Finally, the function returns the *total count of tickets* purchased, which represents the *time required to buy all the tickets at position k.*\\n\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here N is the length of the tickets array. \\n2. This is because the while loop will continue until the kth element of the tickets array becomes 0, and each iteration of the while loop will iterate over each element of the tickets array once.\\n\\n\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. Because the only additional space used is for the variables i, count, and pos, which are all constant in size and do not depend on the size of the input.\\n2.  The tickets array is modified in place, so no additional space is used for it.\\n\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n\\n    let N = tickets.length;\\n\\n    // current index\\n    let i = 0;\\n\\n    // no. of count\\n    let count = 0;\\n\\n    while (tickets[k] > 0) {\\n\\n        let pos = i % N;\\n\\n        if (tickets[pos]) {\\n\\n            tickets[pos]--;\\n            count++;\\n        }  \\n        // moving everytime to next element\\n        i++;\\n    }\\n    return count;\\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/6f36285e-0bab-460e-9f8c-0f16bf19e852_1676657371.1775663.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Queue",
                    "Simulation"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n\\n    let N = tickets.length;\\n\\n    // current index\\n    let i = 0;\\n\\n    // no. of count\\n    let count = 0;\\n\\n    while (tickets[k] > 0) {\\n\\n        let pos = i % N;\\n\\n        if (tickets[pos]) {\\n\\n            tickets[pos]--;\\n            count++;\\n        }  \\n        // moving everytime to next element\\n        i++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2847752,
                "title": "time-needed-to-buy-tickets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n        for ( int i = 0; i < tickets.length; i++){\\n           q.add(i);\\n        }\\n        int count = 0;\\n        while(!q.isEmpty()){\\n            ++count;\\n            int front = q.poll();\\n            if(tickets[front] >= 1){\\n                tickets[front] -= 1;\\n            }\\n            if(k == front && tickets[front] == 0){\\n                break;\\n            }\\n            if(k != front && tickets[front] == 0){\\n                continue;\\n            }\\nq.add(front);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n        for ( int i = 0; i < tickets.length; i++){\\n           q.add(i);\\n        }\\n        int count = 0;\\n        while(!q.isEmpty()){\\n            ++count;\\n            int front = q.poll();\\n            if(tickets[front] >= 1){\\n                tickets[front] -= 1;\\n            }\\n            if(k == front && tickets[front] == 0){\\n                break;\\n            }\\n            if(k != front && tickets[front] == 0){\\n                continue;\\n            }\\nq.add(front);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833494,
                "title": "explained-java-soln",
                "content": "\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n\\n        int time=0;\\n\\n  \\n       for(int i =0; i<tickets.length;i++){\\n// if position i<k and tickets[i]<tickets[k], means all tickets of i will be purchase before k, hence time+=tickets[i].   \\n\\n           if(i<k){\\n               if(tickets[i]<=tickets[k])\\n                time+=tickets[i];\\n// if tickets[i]>tickets[k] and programs ends when tickets[k]==0, then no need to count time for i after k==0 , hence time+=tickets[k]\\n                else \\n                time+=tickets[k];\\n           }\\n// if position i>k and tickets[i]<tickets[k], means all tickets of i will be purchase before k, hence time+=tickets[i]. \\n\\n           if(i>k){\\n               if(tickets[i]<tickets[k])\\n                time+=tickets[i];\\n// if tickets[i]>tickets[k] and programs ends when tickets[k]==0, then no need to count time for i after k==0 , hence time+=tickets[k]-1(cause loop will break before time hits ticket[k] for later part.),\\n                else\\n                time+=tickets[k]-1;\\n           }\\n//if i==k just add time+=tickets[k]\\n\\n                if(i==k) time+=tickets[k];\\n\\n\\n\\n           \\n           System.out.println(time);\\n           \\n\\n\\n       }\\n\\n        \\n\\n        return time;\\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n\\n        int time=0;\\n\\n  \\n       for(int i =0; i<tickets.length;i++){\\n// if position i<k and tickets[i]<tickets[k], means all tickets of i will be purchase before k, hence time+=tickets[i].   \\n\\n           if(i<k){\\n               if(tickets[i]<=tickets[k])\\n                time+=tickets[i];\\n// if tickets[i]>tickets[k] and programs ends when tickets[k]==0, then no need to count time for i after k==0 , hence time+=tickets[k]\\n                else \\n                time+=tickets[k];\\n           }\\n// if position i>k and tickets[i]<tickets[k], means all tickets of i will be purchase before k, hence time+=tickets[i]. \\n\\n           if(i>k){\\n               if(tickets[i]<tickets[k])\\n                time+=tickets[i];\\n// if tickets[i]>tickets[k] and programs ends when tickets[k]==0, then no need to count time for i after k==0 , hence time+=tickets[k]-1(cause loop will break before time hits ticket[k] for later part.),\\n                else\\n                time+=tickets[k]-1;\\n           }\\n//if i==k just add time+=tickets[k]\\n\\n                if(i==k) time+=tickets[k];\\n\\n\\n\\n           \\n           System.out.println(time);\\n           \\n\\n\\n       }\\n\\n        \\n\\n        return time;\\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557446,
                "title": "js-two-approaches-with-explanation-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/09/2073-time-needed-to-buy-tickets-queue.html\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n**Javascript One Liner code**\\n\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    return tickets.reduce((x, v, i)=>x + Math.min(v, tickets[k] - (i > k)), 0);\\n};\\n```\\n\\n```\\nRuntime: 96 ms, faster than 38.86% of JavaScript online submissions for Time Needed to Buy Tickets.\\nMemory Usage: 41.6 MB, less than 89.10% of JavaScript online submissions for Time Needed to Buy Tickets.\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    return tickets.reduce((x, v, i)=>x + Math.min(v, tickets[k] - (i > k)), 0);\\n};\\n```\n```\\nRuntime: 96 ms, faster than 38.86% of JavaScript online submissions for Time Needed to Buy Tickets.\\nMemory Usage: 41.6 MB, less than 89.10% of JavaScript online submissions for Time Needed to Buy Tickets.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2553069,
                "title": "python-easy-queue-and-recursion-solution",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        queue = deque(tickets)\\n        \\n        self.time_taken = 0\\n        \\n        self.rec(queue, k)\\n        \\n        return self.time_taken\\n    \\n    def rec(self, queue, k):\\n        for idx, ele in enumerate(queue):\\n            if ele:\\n                queue[idx] -= 1\\n                if idx == k and not queue[idx]:\\n                    self.time_taken += 1\\n                    return self.time_taken\\n                else:\\n                    self.time_taken += 1\\n        self.rec(queue, k)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        queue = deque(tickets)\\n        \\n        self.time_taken = 0\\n        \\n        self.rec(queue, k)\\n        \\n        return self.time_taken\\n    \\n    def rec(self, queue, k):\\n        for idx, ele in enumerate(queue):\\n            if ele:\\n                queue[idx] -= 1\\n                if idx == k and not queue[idx]:\\n                    self.time_taken += 1\\n                    return self.time_taken\\n                else:\\n                    self.time_taken += 1\\n        self.rec(queue, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458459,
                "title": "go-simple-solution-using-queue-60-faster-70-less-memory-needed",
                "content": "func timeRequiredToBuy(tickets []int, k int) int {\\n\\n\\tout := 0\\n\\tendMainLoop := false\\n\\n\\tfor !endMainLoop {\\n\\n\\t\\tend := len(tickets)\\n\\n\\t\\tif tickets[k] == 1 {\\n\\t\\t\\tend = k + 1\\n\\t\\t\\tendMainLoop = true\\n\\t\\t}\\n\\n\\t\\tfor i := 0; i < end; i++ {\\n\\n\\t\\t\\telem := tickets[0]\\n\\n\\t\\t\\tif elem > 0 {\\n\\t\\t\\t\\telem--\\n\\t\\t\\t\\tout++\\n\\t\\t\\t}\\n\\n\\t\\t\\ttickets = append(tickets[1:], elem)\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "func timeRequiredToBuy(tickets []int, k int) int {\\n\\n\\tout := 0\\n\\tendMainLoop := false\\n\\n\\tfor !endMainLoop {\\n\\n\\t\\tend := len(tickets)\\n\\n\\t\\tif tickets[k] == 1 {\\n\\t\\t\\tend = k + 1\\n\\t\\t\\tendMainLoop = true\\n\\t\\t}\\n\\n\\t\\tfor i := 0; i < end; i++ {\\n\\n\\t\\t\\telem := tickets[0]\\n\\n\\t\\t\\tif elem > 0 {\\n\\t\\t\\t\\telem--\\n\\t\\t\\t\\tout++\\n\\t\\t\\t}\\n\\n\\t\\t\\ttickets = append(tickets[1:], elem)\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2429131,
                "title": "c-simply-explained-with-steps",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int step = 0;\\n        while (true) {\\n            for (int i = 0; i < tickets.size(); ++i) {\\n                if (tickets[i] == 0) continue; // skips element, does not count if ticket is 0, like it\\'s not even there\\n                tickets[i]--; // decreases by 1 of all elements one by one\\n                ++step; // 1 second increment\\n                if (tickets[k] == 0) return step; // if target is having 0 tickets, return total time\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int step = 0;\\n        while (true) {\\n            for (int i = 0; i < tickets.size(); ++i) {\\n                if (tickets[i] == 0) continue; // skips element, does not count if ticket is 0, like it\\'s not even there\\n                tickets[i]--; // decreases by 1 of all elements one by one\\n                ++step; // 1 second increment\\n                if (tickets[k] == 0) return step; // if target is having 0 tickets, return total time\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400565,
                "title": "c-easy-approach",
                "content": "Basically we need to find the time to make tickets[k] equals to zero.\\nIn every iteration if the element is not equal to zero then decrease it by one and increase the count of time.\\nint i could be greatter than n so use i%n so that it remains in range of array given.\\n```\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int time=0;\\n        int i=0;\\n        while(tickets[k]!=0){\\n            if(tickets[i%n]!=0){\\n                tickets[i%n]--;\\n                time++;\\n            }\\n            i++;\\n        }\\n        return time;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int time=0;\\n        int i=0;\\n        while(tickets[k]!=0){\\n            if(tickets[i%n]!=0){\\n                tickets[i%n]--;\\n                time++;\\n            }\\n            i++;\\n        }\\n        return time;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2343054,
                "title": "short-javascript-solution",
                "content": "```\\nvar timeRequiredToBuy = function (tickets, k) {\\n    let seconds = 0;\\n\\n    while (tickets[k] > 0) {\\n        for (let i = 0; i < tickets.length; i++) {\\n            if (tickets[k] === 0) break\\n            if (tickets[i] > 0) {\\n                tickets[i]--\\n                seconds++\\n            }\\n        }\\n    }\\n\\t\\n    return seconds\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeRequiredToBuy = function (tickets, k) {\\n    let seconds = 0;\\n\\n    while (tickets[k] > 0) {\\n        for (let i = 0; i < tickets.length; i++) {\\n            if (tickets[k] === 0) break\\n            if (tickets[i] > 0) {\\n                tickets[i]--\\n                seconds++\\n            }\\n        }\\n    }\\n\\t\\n    return seconds\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2326133,
                "title": "c-all-approaches-complexity-analysis-efficient-solution",
                "content": "2 APPROACHES : \\n1. Queue\\nTC : O( t )   ->t is the time ( iterations) done to make the tickets[ k ]=0 \\nSC : O(N)  -> We store N elements in queue at first\\n\\n2. Vector :\\nTC : O( t ) \\nSC : O(1) ->no extra space required\\n\\nNOTE  :The runtime and memory usage of vector soution is less than that of Queue solution .\\n(as it can be seen clearly as well from the complexity analysis) \\n\\nUPVOTE IF YOU LIKE \\uD83D\\uDE0A\\n```\\nclass Solution {\\npublic:\\n// USING QUEUE : \\n    int timeRequiredToBuy(vector<int>& nums, int k) {\\n        int ans=0;\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<nums.size();i++){\\n            q.push({nums[i],i});\\n        }\\n    \\n        while(!q.empty()){\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            p.first--;\\n            ans+=1;\\n            if(p.second==k && p.first==0)return ans;\\n            else if(p.first!=0)q.push(p);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\nUSING VECTOR :\\nRuntime and memory usage of This solution is better than the queue sol.\\n*/\\nint timeRequiredToBuy(vector<int>& nums, int k) {\\n        int ans=0;\\n        while(nums[k]!=0){\\n            for(int i=0;i<nums.size();i++){\\n                if(nums[i]==0 && i!=k)continue;\\n                nums[i]--;\\n                ans+=1;\\n                if(nums[k]==0)return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// USING QUEUE : \\n    int timeRequiredToBuy(vector<int>& nums, int k) {\\n        int ans=0;\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<nums.size();i++){\\n            q.push({nums[i],i});\\n        }\\n    \\n        while(!q.empty()){\\n            pair<int,int>p=q.front();\\n            q.pop();\\n            p.first--;\\n            ans+=1;\\n            if(p.second==k && p.first==0)return ans;\\n            else if(p.first!=0)q.push(p);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\nUSING VECTOR :\\nRuntime and memory usage of This solution is better than the queue sol.\\n*/\\nint timeRequiredToBuy(vector<int>& nums, int k) {\\n        int ans=0;\\n        while(nums[k]!=0){\\n            for(int i=0;i<nums.size();i++){\\n                if(nums[i]==0 && i!=k)continue;\\n                nums[i]--;\\n                ans+=1;\\n                if(nums[k]==0)return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319753,
                "title": "o-n-python-treat-kth-and-kth-differently",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        c=0\\n        l=len(tickets)\\n        for i in range(l):\\n            if i <= k:\\n                c+= min(tickets[k],tickets[i])\\n            else:\\n                c+= min(tickets[k]-1,tickets[i])\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        c=0\\n        l=len(tickets)\\n        for i in range(l):\\n            if i <= k:\\n                c+= min(tickets[k],tickets[i])\\n            else:\\n                c+= min(tickets[k]-1,tickets[i])\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296280,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        \"\"\"\\n        :type tickets: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        seconds = 0\\n        while tickets[k]!=0:\\n            \\n            for i in range(len(tickets)):\\n                if tickets[i]!=0 and tickets[k]!=0:\\n                    tickets[i] = tickets[i]-1\\n                    seconds +=1\\n        return seconds\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        \"\"\"\\n        :type tickets: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        seconds = 0\\n        while tickets[k]!=0:\\n            \\n            for i in range(len(tickets)):\\n                if tickets[i]!=0 and tickets[k]!=0:\\n                    tickets[i] = tickets[i]-1\\n                    seconds +=1\\n        return seconds\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282082,
                "title": "java-easy-solution-o-n-2-mehods",
                "content": "#### 1) \\n```\\nclass Solution {\\n  public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < tickets.length; i++) {\\n             ans += Math.min(tickets[i], tickets[k]);\\n\\n            if (i > k && tickets[i] >= tickets[k]) {\\n                ans--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n#### 2)\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0;\\n        while (tickets[k] != 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[k] == 0) {\\n                    return ans;\\n                }\\n                if (tickets[i] != 0) {\\n                    tickets[i] = tickets[i] - 1;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0;\\n        for (int i = 0; i < tickets.length; i++) {\\n             ans += Math.min(tickets[i], tickets[k]);\\n\\n            if (i > k && tickets[i] >= tickets[k]) {\\n                ans--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0;\\n        while (tickets[k] != 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[k] == 0) {\\n                    return ans;\\n                }\\n                if (tickets[i] != 0) {\\n                    tickets[i] = tickets[i] - 1;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271454,
                "title": "best-solution-in-c",
                "content": "**Please upvote if you like it :)**\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count=0;\\n        while(tickets[k])\\n        {\\n            for(int i=0;i<tickets.size();i++)\\n            {\\n                if(tickets[i])\\n                {\\n                    tickets[i]=tickets[i]-1;\\n                    count++;\\n                    if(tickets[k]==0)\\n                        return count;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count=0;\\n        while(tickets[k])\\n        {\\n            for(int i=0;i<tickets.size();i++)\\n            {\\n                if(tickets[i])\\n                {\\n                    tickets[i]=tickets[i]-1;\\n                    count++;\\n                    if(tickets[k]==0)\\n                        return count;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2269001,
                "title": "use-only-one-for-loop-10-lines-of-codes-bruteforce-java-solution",
                "content": "\\n2073. Time Needed to Buy Tickets\\njava solution\\nOnly 10 lines of codes\\n```\\n\\n\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n          int time=0;\\n          for(int i=0; i<tickets.length; i++){\\n              if(tickets[i]<tickets[k]) time+=tickets[i];\\n              else if(i<=k && tickets[i]>=tickets[k])time+=tickets[k];\\n              else if(i>k && tickets[i]>=tickets[k]) time+=tickets[k]-1;   \\n          }\\n          return(time);\\n    }\\n\\t\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue"
                ],
                "code": "```\\n\\n\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n          int time=0;\\n          for(int i=0; i<tickets.length; i++){\\n              if(tickets[i]<tickets[k]) time+=tickets[i];\\n              else if(i<=k && tickets[i]>=tickets[k])time+=tickets[k];\\n              else if(i>k && tickets[i]>=tickets[k]) time+=tickets[k]-1;   \\n          }\\n          return(time);\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2235304,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        \\n        //find the kth person and find m tickets to buy \\n        int times=tickets[k];\\n        \\n        //loop the array m-1 times\\n        for(int i:tickets)\\n        {   \\n            //if i>=m-1, that means this person has enough tickets to buy\\n            if(i>=times)\\n            {\\n                ans+=times-1;\\n            }else  //if i<m-1 that means this person does not have enough tickets to buy\\n            {\\n                ans+=i;\\n            }\\n        }\\n        \\n        //last lopp and stop at the person k\\n        for(int i=0;i<k+1;i++)\\n        {   ////if i>m-1, that means this person has enough tickets to buy\\n            if(tickets[i]>times-1)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n      \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        \\n        //find the kth person and find m tickets to buy \\n        int times=tickets[k];\\n        \\n        //loop the array m-1 times\\n        for(int i:tickets)\\n        {   \\n            //if i>=m-1, that means this person has enough tickets to buy\\n            if(i>=times)\\n            {\\n                ans+=times-1;\\n            }else  //if i<m-1 that means this person does not have enough tickets to buy\\n            {\\n                ans+=i;\\n            }\\n        }\\n        \\n        //last lopp and stop at the person k\\n        for(int i=0;i<k+1;i++)\\n        {   ////if i>m-1, that means this person has enough tickets to buy\\n            if(tickets[i]>times-1)\\n            {\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n      \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153645,
                "title": "c-o-n-solution-0ms-100-faster",
                "content": "**Important observations**\\n* Person standing at index i, before kth index , will buy either **tickets[k]** ticket or **tickets[i]** whichever is minimum,  before kth person buys the ticket. same is applicable for kth person.\\n* Person after kth index, will buy minimum of  **tickets[k] -1** ticket or **tickets[i]** ticket, before kth person buys all the tickets.\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int res = 0;\\n        for(int i = 0; i <= k; i++) {\\n            res += min(tickets[k], tickets[i]);\\n        }\\n        for(int i = k + 1; i < tickets.size(); i++) {\\n            res += min(tickets[k] - 1 , tickets[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int res = 0;\\n        for(int i = 0; i <= k; i++) {\\n            res += min(tickets[k], tickets[i]);\\n        }\\n        for(int i = k + 1; i < tickets.size(); i++) {\\n            res += min(tickets[k] - 1 , tickets[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098427,
                "title": "c-easy-solution-brute-force-to-optimized",
                "content": "\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        \\n// <------------------------------------------------------------------->\\n     \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t // Approach - 1 TC O(N*K) and SC O(1)\\n        int n=tickets.size();\\n        int cnt=0;\\n        while(tickets[k]>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(tickets[i]>0)\\n                {\\n                    tickets[i]--;\\n                    cnt++;\\n                }\\n                if(tickets[k]==0 )\\n                {\\n                    return cnt;\\n                }\\n            }\\n        }\\n        return cnt;\\n        \\n        \\n// <------------------------------------------------------------------->\\n\\n        // Appraoch - 2 TC O(N) and SC O(1)\\n        int i=0;\\n        int n=tickets.size();\\n        int sum=0;\\n        while(i<n)\\n        {\\n            if(i<=k)\\n                sum+=min(tickets[i],tickets[k]);\\n            else\\n                sum+=min(tickets[i],tickets[k]-1);\\n            i++;\\n        }\\n        return sum;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        \\n// <------------------------------------------------------------------->\\n     \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t \\n\\t // Approach - 1 TC O(N*K) and SC O(1)\\n        int n=tickets.size();\\n        int cnt=0;\\n        while(tickets[k]>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(tickets[i]>0)\\n                {\\n                    tickets[i]--;\\n                    cnt++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2096061,
                "title": "c-easy-solution-and-understandable",
                "content": "Solution 1 :\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int sum = 0, x = tickets[k];\\n        for(int i = 0; i <= k; i++){\\n            if(tickets[i] <= x)\\n                sum+=tickets[i];\\n            else\\n                sum+=x;\\n        }\\n        for(int i = k + 1; i < tickets.size(); i++){\\n            if(tickets[i] <= (x-1))\\n                sum+=tickets[i];\\n            else\\n                sum+=(x-1);\\n        }\\n        return sum;\\n    }\\n};\\n```\\nSolution 2 :\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int t = 0;\\n        while(tickets[k] > 0){\\n            for(int i = 0; i < tickets.size(); i++){\\n                if(tickets[i] > 0){\\n                    t++;\\n                    tickets[i]--;\\n                }\\n                if(tickets[k]==0)\\n                    break;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int sum = 0, x = tickets[k];\\n        for(int i = 0; i <= k; i++){\\n            if(tickets[i] <= x)\\n                sum+=tickets[i];\\n            else\\n                sum+=x;\\n        }\\n        for(int i = k + 1; i < tickets.size(); i++){\\n            if(tickets[i] <= (x-1))\\n                sum+=tickets[i];\\n            else\\n                sum+=(x-1);\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int t = 0;\\n        while(tickets[k] > 0){\\n            for(int i = 0; i < tickets.size(); i++){\\n                if(tickets[i] > 0){\\n                    t++;\\n                    tickets[i]--;\\n                }\\n                if(tickets[k]==0)\\n                    break;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011975,
                "title": "simple-python-solution-with-detailed-explanation-easy-to-understand",
                "content": "iterate through tickets, if any number is bigger than ticket[k], when index <= k, nums + tickets[k] (because you can\\'t go over tickets[k] steps to finish purchasing tickets for the kth person), however, for people behind kth person, you only need to purchase ticket[k]-1 steps. if tickets[i] is smaller than ticket[k], these people will only take tickets[i] steps before they leave the queue.\\n\\nif you like my solution, please give me a thumb up!\\n\\n```\\n\\n```class Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        nums = 0        \\n        \\n        for i in range(len(tickets)):       \\n                if tickets[i] >= tickets[k]:\\n                    if i <= k:\\n                        nums += tickets[k]\\n                    else:\\n                        nums += tickets[k] - 1\\n                else:\\n                        nums += tickets[i]\\n\\n        return nums",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937637,
                "title": "faster-than-94-90-javascript-solution",
                "content": "```\\nvar timeRequiredToBuy = function (tickets, k) {\\n  let ans = 0;\\n  let i = 0;\\n  while (tickets[k] !== 0) {\\n    if (i === tickets.length) {\\n      i = 0;\\n    }\\n    if (tickets[i] != 0) {\\n      tickets[i] -= 1;\\n      ans++;\\n    }\\n    i++;\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar timeRequiredToBuy = function (tickets, k) {\\n  let ans = 0;\\n  let i = 0;\\n  while (tickets[k] !== 0) {\\n    if (i === tickets.length) {\\n      i = 0;\\n    }\\n    if (tickets[i] != 0) {\\n      tickets[i] -= 1;\\n      ans++;\\n    }\\n    i++;\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934516,
                "title": "java-queue-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i=0;i <tickets.length; i++) {\\n            queue.add(i);\\n        }\\n        int count=0;\\n        while(!queue.isEmpty()) {\\n            count++;\\n            int index = queue.poll();\\n            if(tickets[index] >= 1) {\\n                tickets[index] -= 1;\\n            }\\n            //now I will check he can go back to last of queue or not\\n            if(index != k && tickets[index] == 0) { \\n                //he is the normal guy, which means he can leave the queue\\n                continue;\\n            }\\n            //he is the Kth guy, he cannot leave the Queue instead he can BREAK the Queue :)\\n            if(index == k && tickets[index] == 0) {\\n                break;\\n            }\\n            //in all other case we need to add the guy back to Queue\\n            queue.offer(index);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int time = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i=0;i <tickets.length; i++) {\\n            queue.add(i);\\n        }\\n        int count=0;\\n        while(!queue.isEmpty()) {\\n            count++;\\n            int index = queue.poll();\\n            if(tickets[index] >= 1) {\\n                tickets[index] -= 1;\\n            }\\n            //now I will check he can go back to last of queue or not\\n            if(index != k && tickets[index] == 0) { \\n                //he is the normal guy, which means he can leave the queue\\n                continue;\\n            }\\n            //he is the Kth guy, he cannot leave the Queue instead he can BREAK the Queue :)\\n            if(index == k && tickets[index] == 0) {\\n                break;\\n            }\\n            //in all other case we need to add the guy back to Queue\\n            queue.offer(index);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921486,
                "title": "c-cpp-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0,n = tickets.size();\\n        while(tickets[k] > 0){\\n            for(int i = 0;i<n && tickets[k] > 0;i++){\\n                if(tickets[i] > 0){\\n                    ans++;\\n                    tickets[i]--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/06178cb3-e0a6-4b9f-add8-fd6380c82517_1649302549.1251898.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0,n = tickets.size();\\n        while(tickets[k] > 0){\\n            for(int i = 0;i<n && tickets[k] > 0;i++){\\n                if(tickets[i] > 0){\\n                    ans++;\\n                    tickets[i]--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914472,
                "title": "python-easy-solution-one-pass-no-extra-memory",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        length = len(tickets)\\n        count = 0\\n        \\n        for i in range(k+1):\\n            if tickets[i] - tickets[k] < 0:\\n                count += tickets[i]\\n            else:\\n                count += tickets[k]\\n        \\n        for i in range(k+1, length):\\n            if tickets[i] - (tickets[k] - 1) < 0:\\n                count += tickets[i]\\n            else:\\n                count += tickets[k] - 1\\n                \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        length = len(tickets)\\n        count = 0\\n        \\n        for i in range(k+1):\\n            if tickets[i] - tickets[k] < 0:\\n                count += tickets[i]\\n            else:\\n                count += tickets[k]\\n        \\n        for i in range(k+1, length):\\n            if tickets[i] - (tickets[k] - 1) < 0:\\n                count += tickets[i]\\n            else:\\n                count += tickets[k] - 1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904304,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        n = len(tickets)\\n        item = tickets[k]\\n        time = 0\\n        \\n        while tickets[k] != 0:\\n            for i in range(n):\\n                if tickets[i] > 0:\\n                    tickets[i] -= 1\\n                    time += 1\\n                \\n                if i == k and tickets[i] == 0:\\n                    return time\\n        \\n        return time\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        n = len(tickets)\\n        item = tickets[k]\\n        time = 0\\n        \\n        while tickets[k] != 0:\\n            for i in range(n):\\n                if tickets[i] > 0:\\n                    tickets[i] -= 1\\n                    time += 1\\n                \\n                if i == k and tickets[i] == 0:\\n                    return time\\n        \\n        return time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894215,
                "title": "c-solution-o-n-time-o-1-space-just-two-loops-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n      int timeTaken = 0;\\n      int ticketsAtIndexK = tickets[k];\\n      for(int i = k+1; i < tickets.size(); i++)\\n        timeTaken += min(tickets[i], ticketsAtIndexK - 1);\\n      \\n      for(int i = 0; i <= k; i++)\\n        timeTaken += min(tickets[i], ticketsAtIndexK);\\n      \\n      return timeTaken;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n      int timeTaken = 0;\\n      int ticketsAtIndexK = tickets[k];\\n      for(int i = k+1; i < tickets.size(); i++)\\n        timeTaken += min(tickets[i], ticketsAtIndexK - 1);\\n      \\n      for(int i = 0; i <= k; i++)\\n        timeTaken += min(tickets[i], ticketsAtIndexK);\\n      \\n      return timeTaken;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888755,
                "title": "c-solution-with-queue-and-shallow-copies",
                "content": "Put references to the elements of the array in a queue. This allows you to monitor directly tickets[k], preventing you from becoming insane in keeping track of it with a variable.\\n\\n``` \\nclass Solution {\\npublic:\\n    // Time Complexity: O(n*tickets[k]), it loops for the entire queue (size = n, n times) until tickets[k] becomes 0 (k times)\\n    // Space Complexity: O(n), creates a queue of size n\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        queue<int*> q;\\n        for(int i=0; i< tickets.size(); i++)\\n            q.push(&tickets[i]);                // add references of the tickets to a queue\\n        \\n        int count = 0;\\n        while(tickets[k] != 0)                  // repeat until ticket[k] is zero\\n        {\\n            int* ptr = q.front();               // get the reference at the front of the queue, namely ticket[i]\\n            q.pop();                            // remove it from the queue\\n            (*ptr)--;                           // reduce the value of ticket[i]\\n            if(*ptr != 0)                       // if it is not zero, \\n                q.push(ptr);                    // add it back to the queue\\n            count++;                            // increase counter\\n        }\\n        return count;                           // return the counter\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n    // Time Complexity: O(n*tickets[k]), it loops for the entire queue (size = n, n times) until tickets[k] becomes 0 (k times)\\n    // Space Complexity: O(n), creates a queue of size n\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        queue<int*> q;\\n        for(int i=0; i< tickets.size(); i++)\\n            q.push(&tickets[i]);                // add references of the tickets to a queue\\n        \\n        int count = 0;\\n        while(tickets[k] != 0)                  // repeat until ticket[k] is zero\\n        {\\n            int* ptr = q.front();               // get the reference at the front of the queue, namely ticket[i]\\n            q.pop();                            // remove it from the queue\\n            (*ptr)--;                           // reduce the value of ticket[i]\\n            if(*ptr != 0)                       // if it is not zero, \\n                q.push(ptr);                    // add it back to the queue\\n            count++;                            // increase counter\\n        }\\n        return count;                           // return the counter\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857998,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        seconds = 0\\n        while True:\\n            for i in range(len(tickets)):\\n                if tickets[i] != 0:\\n                    seconds += 1\\n                    tickets[i] -= 1\\n                else:\\n                    continue\\n                if tickets[k] == 0:\\n                    return seconds",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        seconds = 0\\n        while True:\\n            for i in range(len(tickets)):\\n                if tickets[i] != 0:\\n                    seconds += 1\\n                    tickets[i] -= 1\\n                else:\\n                    continue\\n                if tickets[k] == 0:\\n                    return seconds",
                "codeTag": "Java"
            },
            {
                "id": 1820628,
                "title": "o-n-long-but-understandable-code-try-this-python",
                "content": "class Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\n        second=0\\n        a=tickets[k]\\n        while a!=0:\\n            for i in range(len(tickets)):\\n                if tickets[i]!=0:\\n                    second+=1\\n                    tickets[i]=tickets[i]-1\\n                a=tickets[k]\\n                if a==0:\\n                    return second\\n            a=tickets[k]\\n            \\n        return second",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\n        second=0\\n        a=tickets[k]\\n        while a!=0:\\n            for i in range(len(tickets)):\\n                if tickets[i]!=0:\\n                    second+=1\\n                    tickets[i]=tickets[i]-1\\n                a=tickets[k]\\n                if a==0:\\n                    return second\\n            a=tickets[k]\\n            \\n        return second",
                "codeTag": "Java"
            },
            {
                "id": 1802939,
                "title": "python-3-easy-to-understand",
                "content": "Runtime: 64 ms, faster than 43.29% of Python3 online submissions for Time Needed to Buy Tickets.\\nMemory Usage: 13.9 MB, less than 86.76% of Python3 online submissions for Time Needed to Buy Tickets\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        p = 0                       #pointer\\n        clock = 0                   #clock\\n        while tickets[k] > 0:       #stop when person k has bought all required tickets\\n            if tickets[p] != 0:     #only buy a ticket if person p still needs to buy tickets\\n                tickets[p] -= 1     #person p buys a ticket\\n                clock += 1          #increment clock whenever a ticket is bought\\n            p += 1                  #move pointer to next person\\n            p %= len(tickets)       #loop pointer from end of list to start of list\\n        return clock\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        p = 0                       #pointer\\n        clock = 0                   #clock\\n        while tickets[k] > 0:       #stop when person k has bought all required tickets\\n            if tickets[p] != 0:     #only buy a ticket if person p still needs to buy tickets\\n                tickets[p] -= 1     #person p buys a ticket\\n                clock += 1          #increment clock whenever a ticket is bought\\n            p += 1                  #move pointer to next person\\n            p %= len(tickets)       #loop pointer from end of list to start of list\\n        return clock\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793517,
                "title": "c-tc-o-n-sc-o-1-100-faster",
                "content": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        int result=0;\\n        \\n        for(int i=0;i<tickets.size();i++){\\n            \\n            result+= i<=k ?min(tickets[i],tickets[k]): min(tickets[i],tickets[k]-1);\\n            \\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        \\n        int result=0;\\n        \\n        for(int i=0;i<tickets.size();i++){\\n            \\n            result+= i<=k ?min(tickets[i],tickets[k]): min(tickets[i],tickets[k]-1);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1746430,
                "title": "typescript-100",
                "content": "Your runtime beats 100 % of typescript submissions\\nYour memory usage beats 14.29 % of typescript submissions (43.5 MB)\\n```\\nfunction timeRequiredToBuy(tickets: number[], k: number): number {\\n    let result: number = 0;\\n    for (let i: number = 0; true; i = i === tickets.length ? 0 : i + 1) {\\n        if (tickets[i] > 0) {\\n            tickets[i]--;\\n            result++;\\n            if (tickets[i] === 0 && i === k) {\\n                break;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction timeRequiredToBuy(tickets: number[], k: number): number {\\n    let result: number = 0;\\n    for (let i: number = 0; true; i = i === tickets.length ? 0 : i + 1) {\\n        if (tickets[i] > 0) {\\n            tickets[i]--;\\n            result++;\\n            if (tickets[i] === 0 && i === k) {\\n                break;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1744017,
                "title": "c-faster-than-100-of-submissions-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0;\\n        for(int i=0; i<k+1; i++){\\n            if(tickets[i]<=tickets[k]){\\n                ans+=tickets[i];\\n            }\\n            else{\\n                ans+=tickets[k];\\n            }\\n        }\\n        for(int i=k+1; i<tickets.size(); i++){\\n             if(tickets[i]<tickets[k]){\\n                ans+=tickets[i];\\n            }\\n            else{\\n                ans+=tickets[k]-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0;\\n        for(int i=0; i<k+1; i++){\\n            if(tickets[i]<=tickets[k]){\\n                ans+=tickets[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1742844,
                "title": "java-o-n-soln-easy-for-beginners",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){\\n            if(i==tickets.length-1){\\n                if(tickets[i]==0){\\n                    i=0;\\n                continue;\\n            }\\n            else{\\n                tickets[i]=tickets[i]-1;\\n                count++;\\n                i=0;\\n                continue;\\n            }\\n            }\\n            else{\\n            if(tickets[i]==0){\\n                i++;\\n                continue;\\n            }\\n            else{\\n                tickets[i]=tickets[i]-1;\\n                count++;\\n            }\\n            i++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){\\n            if(i==tickets.length-1){\\n                if(tickets[i]==0){\\n                    i=0;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1741714,
                "title": "java-easy-solution-optimal-100-faster-o-n-tc-o-1-sc",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        for(int i=k;i>=0;i--)\\n            ans+=Math.min(tickets[k],tickets[i]);\\n        for(int i=tickets.length-1;i>k;i--)\\n            ans+=Math.min(tickets[k]-1,tickets[i]);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        for(int i=k;i>=0;i--)\\n            ans+=Math.min(tickets[k],tickets[i]);\\n        for(int i=tickets.length-1;i>k;i--)\\n            ans+=Math.min(tickets[k]-1,tickets[i]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715695,
                "title": "java-easy-understanding-0ms-for-loop",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        int val = tickets[k];\\n        for(int i=0; i<tickets.length; i++){\\n            if(i <= k)\\n                count += (val > tickets[i]) ? tickets[i] : val;\\n            else\\n                count += (val > tickets[i]) ? tickets[i] : val-1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        int val = tickets[k];\\n        for(int i=0; i<tickets.length; i++){\\n            if(i <= k)\\n                count += (val > tickets[i]) ? tickets[i] : val;\\n            else\\n                count += (val > tickets[i]) ? tickets[i] : val-1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688697,
                "title": "java-o-n-easy-to-understand-intuition",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        if(tickets == null || tickets.length == 0 || k > tickets.length) \\n            return 0;\\n        \\n        /*\\n          Intuition: Since 1 ticket is bought in 1 second. Number of tickets bought will give us the total time taken. \\n          We know we have to buy \"tickets[k]\" number of tickets. 2 cases possible: \\n\\n    Case-1: Going in a loop we are purchasing tickets and until we purchase \"tickets[k]\" number of tickets the people infront(left) of us buy tickets which is equal to Math.min(tickets[i], tickets[k]) because tickets[i] can be greater/lesser than tickets[k], and we can only buy the minimum of both. \\n          Ex-1: tickets[i], tickets[k] => 2, 4 implies i\\'th person can only buy 2 tickets. \\n          Ex-2: tickets[i], tickets[k] => 5, 3 implies i\\'th person can only buy 3 tickets and he still has 2 more tickets to buy which we dont have to wait for\\n        \\n    Case-2: Once we buy all the required tickets (i.e., tickets[k] becomes 0) we no longer have to buy(count) the tickets which are behind(right) of us. That means we only have to buy tickets until the last iteration before which tickets[k] becomes 0 i.e., the previous iteration where tickets[k]-1 are the amount of tickets to be bought.\\n    \\n    Note: If above cases don\\'t make sense. Think of it this way, we have divided the cases into 2 parts. One which are on & before(to the left) of \\'k\\' and other which are to the right of \\'k\\'\\n        */\\n        \\n        \\n        int timeTaken = 0; // TimeTaken = TicketsBought\\n        \\n        \\n        // The way to calculate number of tickets bought\\n        for(int i=0; i<tickets.length; i++) {\\n            if(i <= k) {\\n                timeTaken += Math.min(tickets[i], tickets[k]);  // Case 1\\n            } else {\\n                timeTaken += Math.min(tickets[k]-1, tickets[i]); // Case 2\\n            }\\n        }\\n        \\n        return timeTaken;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        if(tickets == null || tickets.length == 0 || k > tickets.length) \\n            return 0;\\n        \\n        /*\\n          Intuition: Since 1 ticket is bought in 1 second. Number of tickets bought will give us the total time taken. \\n          We know we have to buy \"tickets[k]\" number of tickets. 2 cases possible: \\n\\n    Case-1: Going in a loop we are purchasing tickets and until we purchase \"tickets[k]\" number of tickets the people infront(left) of us buy tickets which is equal to Math.min(tickets[i], tickets[k]) because tickets[i] can be greater/lesser than tickets[k], and we can only buy the minimum of both. \\n          Ex-1: tickets[i], tickets[k] => 2, 4 implies i\\'th person can only buy 2 tickets. \\n          Ex-2: tickets[i], tickets[k] => 5, 3 implies i\\'th person can only buy 3 tickets and he still has 2 more tickets to buy which we dont have to wait for\\n        \\n    Case-2: Once we buy all the required tickets (i.e., tickets[k] becomes 0) we no longer have to buy(count) the tickets which are behind(right) of us. That means we only have to buy tickets until the last iteration before which tickets[k] becomes 0 i.e., the previous iteration where tickets[k]-1 are the amount of tickets to be bought.\\n    \\n    Note: If above cases don\\'t make sense. Think of it this way, we have divided the cases into 2 parts. One which are on & before(to the left) of \\'k\\' and other which are to the right of \\'k\\'\\n        */\\n        \\n        \\n        int timeTaken = 0; // TimeTaken = TicketsBought\\n        \\n        \\n        // The way to calculate number of tickets bought\\n        for(int i=0; i<tickets.length; i++) {\\n            if(i <= k) {\\n                timeTaken += Math.min(tickets[i], tickets[k]);  // Case 1\\n            } else {\\n                timeTaken += Math.min(tickets[k]-1, tickets[i]); // Case 2\\n            }\\n        }\\n        \\n        return timeTaken;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650061,
                "title": "0-ms-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+= min(tickets[k]-(i>k),tickets[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+= min(tickets[k]-(i>k),tickets[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650041,
                "title": "c-o-n-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(tickets[i]>=tickets[k]) ans+=(i<=k?tickets[k]:tickets[k]-1);\\n            else ans+=tickets[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n=tickets.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(tickets[i]>=tickets[k]) ans+=(i<=k?tickets[k]:tickets[k]-1);\\n            else ans+=tickets[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637234,
                "title": "java-100-faster-short-solution",
                "content": "```\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n        int timeTakenForK = 0;\\n       \\n        for(int i = 0; i < tickets.length; i++){\\n            if(i < k) timeTakenForK+=Math.min(tickets[k], tickets[i]);\\n            if(i > k) timeTakenForK+=Math.min(tickets[k] - 1, tickets[i]);\\n            if(i == k)timeTakenForK+=tickets[k];}\\n  \\n        return timeTakenForK;}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int timeRequiredToBuy(int[] tickets, int k) {\\n        int timeTakenForK = 0;\\n       \\n        for(int i = 0; i < tickets.length; i++){\\n            if(i < k) timeTakenForK+=Math.min(tickets[k], tickets[i]);\\n            if(i > k) timeTakenForK+=Math.min(tickets[k] - 1, tickets[i]);\\n            if(i == k)timeTakenForK+=tickets[k];}\\n  \\n        return timeTakenForK;}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1632040,
                "title": "easy-one-pass-o-n",
                "content": "For the people ahead of the person at `idx=k` they all get down to the minimum of their value and the value of the person at position `k`, for the people behind that person, since we stop as soon as the the person at position `k` has bought all his/her tickets, they get to minimum of  their value and the value of the person at position `k` minus `1`.\\n```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        \"\"\"\\n        :type tickets: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        tot, idx = 0, len(tickets)-1\\n\\n        while(idx>=0):\\n            tot += min(tickets[k], tickets[idx]) if idx<=k else min(tickets[k]-1, tickets[idx])\\n            idx-=1\\n            \\n        return tot \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def timeRequiredToBuy(self, tickets, k):\\n        \"\"\"\\n        :type tickets: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        tot, idx = 0, len(tickets)-1\\n\\n        while(idx>=0):\\n            tot += min(tickets[k], tickets[idx]) if idx<=k else min(tickets[k]-1, tickets[idx])\\n            idx-=1\\n            \\n        return tot \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622513,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0,n=tickets.size(),fix=tickets[k];\\n        for(int i=0;i<fix-1;i++){\\n            for(int j=0;j<n;j++){\\n                if(tickets[j]>0) ans++;\\n                tickets[j]--;\\n            }\\n        }\\n        for(int j=0;j<=k;j++){\\n            if(tickets[j]>0) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0,n=tickets.size(),fix=tickets[k];\\n        for(int i=0;i<fix-1;i++){\\n            for(int j=0;j<n;j++){\\n                if(tickets[j]>0) ans++;\\n                tickets[j]--;\\n            }\\n        }\\n        for(int j=0;j<=k;j++){\\n            if(tickets[j]>0) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603655,
                "title": "java-o-n-0ms-4-line-answer",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        for(int i=0; i<=k; i++) ans+=Math.min(tickets[i], tickets[k]);\\n        for(int i=k+1; i<tickets.length; i++)ans+=Math.min(tickets[i], tickets[k]-1);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans=0;\\n        for(int i=0; i<=k; i++) ans+=Math.min(tickets[i], tickets[k]);\\n        for(int i=k+1; i<tickets.length; i++)ans+=Math.min(tickets[i], tickets[k]-1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591130,
                "title": "java-100-easy-solution",
                "content": "Apulatjonov\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            if(tickets[i] < tickets[k]){\\n                count += tickets[i];\\n            }else{\\n                count += tickets[k];\\n            }\\n        }\\n        for(int i = k; i < tickets.length; i++){\\n            if(tickets[i] >= tickets[k])\\n                count--;\\n        }\\n        return ++count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        for(int i = 0; i < tickets.length; i++){\\n            if(tickets[i] < tickets[k]){\\n                count += tickets[i];\\n            }else{\\n                count += tickets[k];\\n            }\\n        }\\n        for(int i = k; i < tickets.length; i++){\\n            if(tickets[i] >= tickets[k])\\n                count--;\\n        }\\n        return ++count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588109,
                "title": "c-simple-for-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int t = tickets[k];\\n        for(int i = 0; i < k; i++) {\\n            t += min(tickets[i], tickets[k]);\\n        }\\n        for(int i = k+1; i<tickets.size(); i++) {\\n            t += min(tickets[i], tickets[k]-1);\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int t = tickets[k];\\n        for(int i = 0; i < k; i++) {\\n            t += min(tickets[i], tickets[k]);\\n        }\\n        for(int i = k+1; i<tickets.size(); i++) {\\n            t += min(tickets[i], tickets[k]-1);\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583361,
                "title": "javascript-brute-force",
                "content": "```\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let time = 0\\n    while(tickets[k]){\\n        for(i = 0; i < tickets.length; i++){\\n           if(tickets[i] && tickets[k]) {\\n               time+=1\\n               tickets[i]-=1\\n           } \\n        }\\n    }\\n    return time\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let time = 0\\n    while(tickets[k]){\\n        for(i = 0; i < tickets.length; i++){\\n           if(tickets[i] && tickets[k]) {\\n               time+=1\\n               tickets[i]-=1\\n           } \\n        }\\n    }\\n    return time\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1582832,
                "title": "c-gcc-100-bytes-0-ms-5-9-mb",
                "content": "```\\ni,s;timeRequiredToBuy(int*a,int n,int k){i=s=0;\\nwhile(a[k])a[i]-=a[i]?s++,1:0,i=++i<n?i:0;return s;}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ni,s;timeRequiredToBuy(int*a,int n,int k){i=s=0;\\nwhile(a[k])a[i]-=a[i]?s++,1:0,i=++i<n?i:0;return s;}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1581974,
                "title": "python-2-line-explain",
                "content": "- For k\\'s first ticket, it\\'ll take k seconds to get the turn\\n- After that, ppl before k will need -1 tickets, after k remain same\\n- Then for the remaining rounds, each ppl will buy at most ticket[k] -1 before job done, plus ticket[k] seconds for k to buy\\n\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        remaining = [t-1 for t in tickets[:k]] + tickets[k+1:]\\n        return k + sum(min(r, tickets[k] - 1) for r in remaining) + tickets[k]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        remaining = [t-1 for t in tickets[:k]] + tickets[k+1:]\\n        return k + sum(min(r, tickets[k] - 1) for r in remaining) + tickets[k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581364,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        a=tickets[k]\\n        x=0\\n        while(a!=0):\\n            for i in range(len(tickets)):\\n                if(tickets[i]!=0):\\n                    x=x+1\\n                    tickets[i]=tickets[i]-1\\n                a=tickets[k]\\n                if(a==0):\\n                    return(x)\\n\\t\\t\\t#print(tickets)\\n            a=tickets[k]\\n        return(x)\\n```\\nIf u liked the code then plz...UPVOTE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        a=tickets[k]\\n        x=0\\n        while(a!=0):\\n            for i in range(len(tickets)):\\n                if(tickets[i]!=0):\\n                    x=x+1\\n                    tickets[i]=tickets[i]-1\\n                a=tickets[k]\\n                if(a==0):\\n                    return(x)\\n\\t\\t\\t#print(tickets)\\n            a=tickets[k]\\n        return(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580231,
                "title": "python-o-n-faster-than-99",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        x = tickets[k]\\n        res = 0\\n        for i in range(k + 1):\\n            res += min(x, tickets[i])\\n\\n        for i in range(k + 1, len(tickets)):\\n            res += min(x - 1, tickets[i])\\n\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        x = tickets[k]\\n        res = 0\\n        for i in range(k + 1):\\n            res += min(x, tickets[i])\\n\\n        for i in range(k + 1, len(tickets)):\\n            res += min(x - 1, tickets[i])\\n\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1580050,
                "title": "c-o-n-tc-and-o-1-sc-clean",
                "content": "A simple Approch should be to traverse the array and adding elements eqaul to , or less than kth element .\\n\\n\\n\\'\\'\\'\\n\\n         int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int t = 0;  //time taken by kth person to buy the tickets\\n\\t\\t\\n        for(int i = 0; i<tickets.size(); i++){\\n\\t\\t\\n            if(i <= k){\\n\\t\\t\\t//for person is placed earliear than kth person \\n                t = t+ min(tickets[i],  tickets[k]);\\n            }\\n            if(i > k){\\n\\t\\t\\t// for persons placed after the kth person\\n                t = t+ min(tickets[i],  tickets[k]-1);\\n            }\\n        }return t;\\n\\t\\t\\'\\'\\'\\n\\t\\t\\nDry run this code with different test cases and eventually you will know the conditions\\n\\t\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "A simple Approch should be to traverse the array and adding elements eqaul to , or less than kth element .\\n\\n\\n\\'\\'\\'\\n\\n         int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int t = 0;  //time taken by kth person to buy the tickets\\n\\t\\t\\n        for(int i = 0; i<tickets.size(); i++){\\n\\t\\t\\n            if(i <= k){\\n\\t\\t\\t//for person is placed earliear than kth person \\n                t = t+ min(tickets[i],  tickets[k]);\\n            }\\n            if(i > k){\\n\\t\\t\\t// for persons placed after the kth person\\n                t = t+ min(tickets[i],  tickets[k]-1);\\n            }\\n        }return t;\\n\\t\\t\\'\\'\\'\\n\\t\\t\\nDry run this code with different test cases and eventually you will know the conditions\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1579383,
                "title": "python-one-pass-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        n = len(tickets)\\n        res = tickets[k] #it has to buy all at kth position\\n        \\n        for i in range(n):\\n            if i < k:\\n                res += min(tickets[i], tickets[k])  # for all pos before k it will exhaust all tickets or get till number till kth place\\n                \\n            elif i > k:\\n                res += min(tickets[i], tickets[k]-1) #for all pos after k it can exhaust all tickets or get 1 less than the kth gets finished\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        n = len(tickets)\\n        res = tickets[k] #it has to buy all at kth position\\n        \\n        for i in range(n):\\n            if i < k:\\n                res += min(tickets[i], tickets[k])  # for all pos before k it will exhaust all tickets or get till number till kth place\\n                \\n            elif i > k:\\n                res += min(tickets[i], tickets[k]-1) #for all pos after k it can exhaust all tickets or get 1 less than the kth gets finished\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578792,
                "title": "c-simple-approach-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count = 0;\\n        while(tickets[k] != 0){\\n            for(int i=0; i<tickets.size(); i++){\\n                { if(tickets[i] > 0) \\n                {\\n                    tickets[i]--;\\n                    count++;\\n                }\\n                }\\n              if(tickets[k] == 0) break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int count = 0;\\n        while(tickets[k] != 0){\\n            for(int i=0; i<tickets.size(); i++){\\n                { if(tickets[i] > 0) \\n                {\\n                    tickets[i]--;\\n                    count++;\\n                }\\n                }\\n              if(tickets[k] == 0) break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578006,
                "title": "c-solution-beats-100-o-n-onepass",
                "content": "```\\nint timeRequiredToBuy(vector<int>& tk, int k) {\\n        int val=tk[k];\\n        int ans=0;\\n        for(int i=0;i<tk.size();i++){\\n            if(tk[i]>val)ans+=val;\\n            else ans+=tk[i];\\n            if(i>k && tk[i]>=tk[k])ans--;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint timeRequiredToBuy(vector<int>& tk, int k) {\\n        int val=tk[k];\\n        int ans=0;\\n        for(int i=0;i<tk.size();i++){\\n            if(tk[i]>val)ans+=val;\\n            else ans+=tk[i];\\n            if(i>k && tk[i]>=tk[k])ans--;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577999,
                "title": "c-brute-force-to-optimal-easy-to-understand",
                "content": "Time Needed to Buy Tickets - \\n\\n\\n**1) Brute Force -**\\n\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) \\n    {\\n          int cnt=0;\\n          while(tickets[k]!=0)\\n          {\\n              for(int i=0;i<tickets.size();i++)\\n              {\\n                  if(tickets[i]>0)\\n                  {\\n                      tickets[i]-=1;\\n                      cnt++;\\n                  }\\n                 if(tickets[k]==0)\\n                  {break;}\\n              }\\n          }\\n       return cnt; \\n    }\\n};\\n```\\n\\n**2) Optimal Solution - O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) \\n    {\\n          int cnt=0;\\n          for(int i=0;i<tickets.size();i++)\\n          {\\n              cnt+=min(tickets[k] - (i>k),tickets[i]);\\n          }\\n       return cnt; \\n    }\\n};\\n```\\n\\nPlease comment if you have any doubt.\\nWill get back to you as soon as possible.\\n**UPVOTE if you find it useful!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) \\n    {\\n          int cnt=0;\\n          while(tickets[k]!=0)\\n          {\\n              for(int i=0;i<tickets.size();i++)\\n              {\\n                  if(tickets[i]>0)\\n                  {\\n                      tickets[i]-=1;\\n                      cnt++;\\n                  }\\n                 if(tickets[k]==0)\\n                  {break;}\\n              }\\n          }\\n       return cnt; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) \\n    {\\n          int cnt=0;\\n          for(int i=0;i<tickets.size();i++)\\n          {\\n              cnt+=min(tickets[k] - (i>k),tickets[i]);\\n          }\\n       return cnt; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577952,
                "title": "c-one-traversal-solution-one-pass-o-n-beats-100-of-c-codes",
                "content": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        int time = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(tickets[i] <= tickets[k])\\n                time += tickets[i];\\n            else\\n                time += tickets[k];\\n            if(i > k && tickets[i] >= tickets[k])\\n                time--;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        int time = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            if(tickets[i] <= tickets[k])\\n                time += tickets[i];\\n            else\\n                time += tickets[k];\\n            if(i > k && tickets[i] >= tickets[k])\\n                time--;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577387,
                "title": "c-one-pass-solution",
                "content": "**Intuition**\\npeople ```k``` and people before ```k``` will need to buy ```Min(tickets[i], tickets[k])```.\\npeople after ```k``` don\\'t need to buy any tickets if people ```k``` already got all the tickets, so people after ```k``` need to buy  ```Min(tickets[i], tickets[k] - 1)```.\\n\\n**Complexity**\\n- Time: O(n)\\n- Space: O(1)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public int TimeRequiredToBuy(int[] tickets, int k) {\\n        \\n        int res  = 0;\\n        \\n        for(int i = 0; i < tickets.Length; i++)\\n        {\\n            if(i <= k)\\n                res += Math.Min(tickets[i], tickets[k]);\\n            else if(i > k)\\n                res += Math.Min(tickets[i], tickets[k] - 1);\\n        }\\n       \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```k```\n```k```\n```Min(tickets[i], tickets[k])```\n```k```\n```k```\n```k```\n```Min(tickets[i], tickets[k] - 1)```\n```\\npublic class Solution {\\n    public int TimeRequiredToBuy(int[] tickets, int k) {\\n        \\n        int res  = 0;\\n        \\n        for(int i = 0; i < tickets.Length; i++)\\n        {\\n            if(i <= k)\\n                res += Math.Min(tickets[i], tickets[k]);\\n            else if(i > k)\\n                res += Math.Min(tickets[i], tickets[k] - 1);\\n        }\\n       \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577113,
                "title": "c-one-pass-simulation",
                "content": "<strong>Logical Thinking</strong>\\n<p>We can easily solve this problem through <code>simulation</code>. Suppose the <code>k<sup>th</sup></code> person needs <code>target = tickets[k]</code> tickets, then when this person leaves, the people in front of him <code>i < k</code> must have bought the same number of tickets (if they need more tickets), i.e. each of them bought <code>min(target, tickets[i])</code>. Similarly, the people behind him <code>i > k</code> must have bought <code>1</code> less tickets, i.e. <code>min(target - 1, tickets[i])</code>.</p>\\n\\n\\n<strong>C++</strong>\\n\\n```\\n//  Topic   : 2073. Time Needed to Buy Tickets (https://leetcode.com/problems/time-needed-to-buy-tickets/)\\n//  Author  : YCX\\n//  Time    : O(N)\\n//  Space   : O(1)\\n\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0, target = tickets[k], n = tickets.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i <= k)\\n                ans += min<int>(tickets[i], target);\\n            else\\n                ans += min<int>(tickets[i], target - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\n//  Topic   : 2073. Time Needed to Buy Tickets (https://leetcode.com/problems/time-needed-to-buy-tickets/)\\n//  Author  : YCX\\n//  Time    : O(N)\\n//  Space   : O(1)\\n\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans = 0, target = tickets[k], n = tickets.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i <= k)\\n                ans += min<int>(tickets[i], target);\\n            else\\n                ans += min<int>(tickets[i], target - 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577096,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    void solve(vector<int> &nums, int k)\\n    {\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==0)\\n                continue;\\n            nums[i] = nums[i]-1;\\n                ans++;\\n            if(nums[k] == 0)\\n                return;\\n        }\\n    }\\n    \\n    int timeRequiredToBuy(vector<int> &nums, int k) \\n    {    \\n        while(true)\\n        {\\n            if(nums[k]==0)\\n                break;\\n            solve(nums,k);    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n    void solve(vector<int> &nums, int k)\\n    {\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==0)\\n                continue;\\n            nums[i] = nums[i]-1;\\n                ans++;\\n            if(nums[k] == 0)\\n                return;\\n        }\\n    }\\n    \\n    int timeRequiredToBuy(vector<int> &nums, int k) \\n    {    \\n        while(true)\\n        {\\n            if(nums[k]==0)\\n                break;\\n            solve(nums,k);    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576994,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        res = i = 0\\n        \\n        while tickets[k]:\\n            try:\\n                j = tickets[i]\\n                if j:\\n                    tickets[i] = j - 1\\n                    i += 1\\n                    res += 1\\n                else:\\n                    i += 1\\n            except:\\n                i = 0\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        \\n        res = i = 0\\n        \\n        while tickets[k]:\\n            try:\\n                j = tickets[i]\\n                if j:\\n                    tickets[i] = j - 1\\n                    i += 1\\n                    res += 1\\n                else:\\n                    i += 1\\n            except:\\n                i = 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576925,
                "title": "java-brute-force-easy-to-understand",
                "content": "```\\nclass Solution\\n{\\n    public int timeRequiredToBuy(int[] tickets, int k)\\n    {\\n        int time = 0;\\n        while(true)\\n        {\\n            for(int i = 0; i < tickets.length; i++)\\n            {\\n                if(tickets[i]-- >= 1)\\n                    time++;\\n                if(tickets[k] == 0)\\n                    return time;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int timeRequiredToBuy(int[] tickets, int k)\\n    {\\n        int time = 0;\\n        while(true)\\n        {\\n            for(int i = 0; i < tickets.length; i++)\\n            {\\n                if(tickets[i]-- >= 1)\\n                    time++;\\n                if(tickets[k] == 0)\\n                    return time;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576918,
                "title": "python-java-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i, ticket in enumerate(tickets):\\n\\t\\t\\t\\tif i <= k:\\n\\t\\t\\t\\t\\tres += min(ticket, tickets[k])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif ticket < tickets[k]:\\n\\t\\t\\t\\t\\t\\tres += ticket\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres += tickets[k] - 1\\n\\t\\t\\treturn res\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tpublic int timeRequiredToBuy(int[] tickets, int k) {\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (int i = 0; i < tickets.length; i ++) {\\n\\t\\t\\t\\tif (i <= k) {\\n\\t\\t\\t\\t\\tres += Math.min(tickets[i], tickets[k]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (tickets[i] < tickets[k]) {\\n\\t\\t\\t\\t\\t\\tres += tickets[i];\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tres += tickets[k] - 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i, ticket in enumerate(tickets):\\n\\t\\t\\t\\tif i <= k:\\n\\t\\t\\t\\t\\tres += min(ticket, tickets[k])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif ticket < tickets[k]:\\n\\t\\t\\t\\t\\t\\tres += ticket\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres += tickets[k] - 1\\n\\t\\t\\treturn res\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tpublic int timeRequiredToBuy(int[] tickets, int k) {\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (int i = 0; i < tickets.length; i ++) {\\n\\t\\t\\t\\tif (i <= k) {\\n\\t\\t\\t\\t\\tres += Math.min(tickets[i], tickets[k]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4077206,
                "title": "o-n-with-readable-code-simple-for-loop",
                "content": "## Approach\\n<!-- Describe your approach to solving the problem. -->\\ndeclare variable ans = 0, this variable will be the counter (and the answer).\\nthe target is tickets[k]. \\nif the index is less or equal to k (the target index):\\n- if the tickets[index] is bigger than target add ans equals target.\\n- else (tickets[index] is less than target) add ans equals tickets[index].\\n\\nelse (index is bigger than k (the target index))\\n- if the tickets[index] is bigger than target add ans equals target-1 (-1 because we assume that in the last recursion stopped in target index).\\n- else (tickets[index] is less than target) add ans equals tickets[index].\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1) (?)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0 ;\\n        for(int x = 0 ; x<tickets.length ; x++){\\n            if(x <= k){\\n                if(tickets[x] >= tickets[k]){\\n                    ans += tickets[k];\\n                }else{\\n                    ans += tickets[x];\\n                }\\n            }else{\\n                if(tickets[x] >= tickets[k]){\\n                    ans += tickets[k]-1;\\n                }else{\\n                    ans += tickets[x];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int ans = 0 ;\\n        for(int x = 0 ; x<tickets.length ; x++){\\n            if(x <= k){\\n                if(tickets[x] >= tickets[k]){\\n                    ans += tickets[k];\\n                }else{\\n                    ans += tickets[x];\\n                }\\n            }else{\\n                if(tickets[x] >= tickets[k]){\\n                    ans += tickets[k]-1;\\n                }else{\\n                    ans += tickets[x];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061851,
                "title": "beats-100-cpp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0;\\n\\n        while(tickets[k]>0){\\n            for(int j=0;j<tickets.size();j++){\\n//decrementing ticket at j and incrementing ans only if k > 0 && j > 0\\n                if(tickets[k]!=0 && tickets[j]>0){\\n                    tickets[j]--;\\n                    ans++;\\n                }\\n        }\\n\\n        \\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int ans=0;\\n\\n        while(tickets[k]>0){\\n            for(int j=0;j<tickets.size();j++){\\n//decrementing ticket at j and incrementing ans only if k > 0 && j > 0\\n                if(tickets[k]!=0 && tickets[j]>0){\\n                    tickets[j]--;\\n                    ans++;\\n                }\\n        }\\n\\n        \\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059886,
                "title": "easiest-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust need to think how can we iterate the vector again and again\\nand to do this i have used the method of circular queue.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int cnt=0;\\n        int i=0;\\n        int n=tickets.size();\\n        while(1)\\n        {\\n            if(tickets[i]!=0)\\n            {\\n                cnt++;\\n                tickets[i]--;\\n            }\\n            if(i==k&&tickets[k]==0)\\n             return cnt;\\n            i=(i+1)%n;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int cnt=0;\\n        int i=0;\\n        int n=tickets.size();\\n        while(1)\\n        {\\n            if(tickets[i]!=0)\\n            {\\n                cnt++;\\n                tickets[i]--;\\n            }\\n            if(i==k&&tickets[k]==0)\\n             return cnt;\\n            i=(i+1)%n;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055339,
                "title": "0-ms-solution-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, we mainly take count of contribution of every index value while a loop runs.\\n\\nIf value at any index (i) **before** given index (k) is **greater**, then **it will contribute same as tickets[k**]. Because, while running the loop the value of tickets[i] will run  for (tickets[k]) times.\\n\\nIf value at any index (i) **after** given index (k) is **greater** or equals, then **it will contribute same as (tickets[k]-1)**. Because, before reaching the loop for the last time, index at k will get the ticket. So, we won\\'t take the last count.\\n\\nIf value at any index (i) is less than value at given index (k), then the we will not change the value of it. Because, it will be 0 before tickets[k] time. It will contribute tickets[i].\\n\\nWe will update the no of contibution with value of any index.\\nThen, we will take the sum of the whole array and that\\'s the answer. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int sum=0;\\n        for (int i=0;i<tickets.length;i++){\\n            if (k>i &&tickets[k]<=tickets[i]){\\n            tickets[i]=tickets[k];\\n            }\\n            if (k<i &&tickets[k]<=tickets[i]){\\n            tickets[i]=tickets[k]-1;\\n            }\\n        }\\n\\n        for (int i=0;i<tickets.length;i++){\\n            sum+=tickets[i];\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int sum=0;\\n        for (int i=0;i<tickets.length;i++){\\n            if (k>i &&tickets[k]<=tickets[i]){\\n            tickets[i]=tickets[k];\\n            }\\n            if (k<i &&tickets[k]<=tickets[i]){\\n            tickets[i]=tickets[k]-1;\\n            }\\n        }\\n\\n        for (int i=0;i<tickets.length;i++){\\n            sum+=tickets[i];\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048214,
                "title": "java-simple-using-queue-t-n",
                "content": "# Intuition\\nUsed Queue\\n\\n# Approach\\n1. Number of People in queue.(count same as ticket).\\n2. remove from queue when tickets[queue.peek()] == 0,\\n3. otherwise queue.add(queue.peek()) & queue.remove(); \\n\\n# Complexity\\n- Time complexity:\\nOnly one while loop : T(n)\\nremove and add take : O(1)\\nTherfore TimeComplexity : T(n).\\n\\n- Space complexity:\\nSpace Complexity is the space taken by queue which is O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0; i < tickets.length; i++){\\n            queue.add(i);\\n        }\\n        int count = 0;\\n        while(!queue.isEmpty()){\\n            tickets[queue.peek()]--;\\n            if(tickets[queue.peek()] == 0){\\n                queue.remove();\\n            }else if(tickets[queue.peek()] != 0){\\n                queue.add(queue.peek());\\n                queue.remove();\\n            }\\n            count++;\\n            if(tickets[k] == 0){\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i = 0; i < tickets.length; i++){\\n            queue.add(i);\\n        }\\n        int count = 0;\\n        while(!queue.isEmpty()){\\n            tickets[queue.peek()]--;\\n            if(tickets[queue.peek()] == 0){\\n                queue.remove();\\n            }else if(tickets[queue.peek()] != 0){\\n                queue.add(queue.peek());\\n                queue.remove();\\n            }\\n            count++;\\n            if(tickets[k] == 0){\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045024,
                "title": "time-needed-to-buy-tickets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndecreasing array values with base case condition until ticket[k] becomes zero.\\nAnd if there is only one ticket needs to buy then just do time = k+1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->2ms\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n39.80 mb\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int time=0;\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        if(tickets[k]==1){\\n            return k+1;\\n        }\\n        while(tickets[k]>0){\\n            for(int i = 0;i<tickets.length;i++){\\n                if(tickets[i]==0){\\n                    continue;\\n                }\\n                time++;\\n                tickets[i] = tickets[i] - 1;\\n                if(tickets[k]==0){\\n                    break;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int time=0;\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        if(tickets[k]==1){\\n            return k+1;\\n        }\\n        while(tickets[k]>0){\\n            for(int i = 0;i<tickets.length;i++){\\n                if(tickets[i]==0){\\n                    continue;\\n                }\\n                time++;\\n                tickets[i] = tickets[i] - 1;\\n                if(tickets[k]==0){\\n                    break;\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037603,
                "title": "easy-solution-to-timerequiredtobuy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- I could move the elements position for each round\\n- I just need the seconds value\\n- How do I know when to stop iterating?\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSolution with JavaScript. Reduce each element by one until the `k`$$th$$ element is equal to cero.\\n\\n# Complexity\\n- Time complexity: ---\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function (tickets, k) {\\n    let sec = 0;\\n    const ticketsLength = tickets.length;\\n    \\n    while (tickets[k]!==0) {\\n        for (let i = 0; i < ticketsLength; i++) {\\n            if (tickets[i] > 0) {\\n                tickets[i]--;\\n                sec++;\\n            }\\n            if(i===k) if(tickets[k]===0) break;\\n        }\\n    }\\n    return sec;\\n}; \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function (tickets, k) {\\n    let sec = 0;\\n    const ticketsLength = tickets.length;\\n    \\n    while (tickets[k]!==0) {\\n        for (let i = 0; i < ticketsLength; i++) {\\n            if (tickets[i] > 0) {\\n                tickets[i]--;\\n                sec++;\\n            }\\n            if(i===k) if(tickets[k]===0) break;\\n        }\\n    }\\n    return sec;\\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036091,
                "title": "easy-solution-100",
                "content": "# Approach\\nLinear Search\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tic, int k) {\\n        int ans=0;\\n        for(int i=0;i<tic.size();i++)\\n        {\\n            if(tic[i]>tic[k])\\n            {\\n                ans+=tic[k];\\n            }\\n            else\\n            {\\n                ans+=tic[i];\\n            }\\n            if(tic[i]>=tic[k]&&i>k)\\n            {\\n                ans--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tic, int k) {\\n        int ans=0;\\n        for(int i=0;i<tic.size();i++)\\n        {\\n            if(tic[i]>tic[k])\\n            {\\n                ans+=tic[k];\\n            }\\n            else\\n            {\\n                ans+=tic[i];\\n            }\\n            if(tic[i]>=tic[k]&&i>k)\\n            {\\n                ans--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033039,
                "title": "beats-100-runtime-and-100-memory",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n???\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n# @param {Integer[]} tickets\\n# @param {Integer} k\\n# @return {Integer}\\ndef time_required_to_buy(tickets, k)\\n\\n    amount_of_tickets = tickets[k]\\n    track_location_of_k = k\\n    seconds = 0\\n    index = 0\\n    val = nil\\n    while tickets.size > 0  \\n        if 0 != k\\n            k = k - 1\\n        else\\n            if tickets[k] == 1\\n                return seconds + 1\\n            end\\n\\n            k = tickets.size - 1\\n        end\\n\\n        val = tickets.shift\\n        val = val - 1\\n\\n        if val != 0\\n            tickets << val\\n        end\\n\\n        seconds = seconds + 1\\n    end\\n\\n    seconds\\nend\\n\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} tickets\\n# @param {Integer} k\\n# @return {Integer}\\ndef time_required_to_buy(tickets, k)\\n\\n    amount_of_tickets = tickets[k]\\n    track_location_of_k = k\\n    seconds = 0\\n    index = 0\\n    val = nil\\n    while tickets.size > 0  \\n        if 0 != k\\n            k = k - 1\\n        else\\n            if tickets[k] == 1\\n                return seconds + 1\\n            end\\n\\n            k = tickets.size - 1\\n        end\\n\\n        val = tickets.shift\\n        val = val - 1\\n\\n        if val != 0\\n            tickets << val\\n        end\\n\\n        seconds = seconds + 1\\n    end\\n\\n    seconds\\nend\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4032185,
                "title": "c-o-n-deque-implementation-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n     int time=0;\\n     deque<int>dq;\\n     //storing indexes of given array of tickets\\n     for(int i=0;i<tickets.size();i++){\\n         dq.push_back(i);\\n     }\\n     //k points to original array of tickets\\n     while(tickets[k]!=0){\\n         //selling ticket 1 at a time \\n         tickets[dq.front()]=tickets[dq.front()]-1;\\n         //increasing time by 1\\n         time++;\\n         //if person completes buying popping out its index from deque\\n         if(tickets[dq.front()]==0){\\n             dq.pop_front();\\n         }\\n         //pushing back that index to end of deque\\n         else{\\n             int temp=dq.front();\\n             dq.pop_front();\\n             dq.push_back(temp);\\n         }\\n     }\\n     return time;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n     int time=0;\\n     deque<int>dq;\\n     //storing indexes of given array of tickets\\n     for(int i=0;i<tickets.size();i++){\\n         dq.push_back(i);\\n     }\\n     //k points to original array of tickets\\n     while(tickets[k]!=0){\\n         //selling ticket 1 at a time \\n         tickets[dq.front()]=tickets[dq.front()]-1;\\n         //increasing time by 1\\n         time++;\\n         //if person completes buying popping out its index from deque\\n         if(tickets[dq.front()]==0){\\n             dq.pop_front();\\n         }\\n         //pushing back that index to end of deque\\n         else{\\n             int temp=dq.front();\\n             dq.pop_front();\\n             dq.push_back(temp);\\n         }\\n     }\\n     return time;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022322,
                "title": "easy-o-n",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let max = tickets[k]\\n    let total = 0\\n    let rem = 0\\n\\n    for(let idx in tickets) {\\n        let ticket = tickets[idx]\\n        if(idx > k && ticket >= max) rem++\\n        total += Math.min(max, ticket)\\n    }\\n\\n    return total - rem\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let max = tickets[k]\\n    let total = 0\\n    let rem = 0\\n\\n    for(let idx in tickets) {\\n        let ticket = tickets[idx]\\n        if(idx > k && ticket >= max) rem++\\n        total += Math.min(max, ticket)\\n    }\\n\\n    return total - rem\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008932,
                "title": "0ms-beats-100-00-of-users-with-java",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n\\n        for(int i=0;i<tickets.length;i++){\\n            if(tickets[i] >= tickets[k]){\\n                if(i>k){\\n                    count += tickets[k] - 1;\\n                }\\n                else{\\n                    count += tickets[k];\\n                }\\n            }\\n            else{\\n                count += tickets[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n\\n        for(int i=0;i<tickets.length;i++){\\n            if(tickets[i] >= tickets[k]){\\n                if(i>k){\\n                    count += tickets[k] - 1;\\n                }\\n                else{\\n                    count += tickets[k];\\n                }\\n            }\\n            else{\\n                count += tickets[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008532,
                "title": "go",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc timeRequiredToBuy(tickets []int, k int) int {\\n\\n\\tc := 0\\n\\ti := 0\\n\\n\\tfor {\\n\\n\\t\\tif tickets[i] != 0 {\\n\\t\\t\\ttickets[i] -= 1\\n\\t\\t\\tc += 1\\n\\t\\t}\\n\\t\\tfmt.Println(c, i, tickets[i])\\n\\t\\tif i == k && tickets[k] == 0 {\\n\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif len(tickets)-1 == i {\\n\\t\\t\\ti = 0\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t}\\n\\n    return c\\n\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc timeRequiredToBuy(tickets []int, k int) int {\\n\\n\\tc := 0\\n\\ti := 0\\n\\n\\tfor {\\n\\n\\t\\tif tickets[i] != 0 {\\n\\t\\t\\ttickets[i] -= 1\\n\\t\\t\\tc += 1\\n\\t\\t}\\n\\t\\tfmt.Println(c, i, tickets[i])\\n\\t\\tif i == k && tickets[k] == 0 {\\n\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif len(tickets)-1 == i {\\n\\t\\t\\ti = 0\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t}\\n\\n    return c\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002763,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n  let queue = []\\n  let totalTime = 0;\\n  for(let i = 0; i < tickets.length; i++){\\n    queue.push({pos:i, no_of_tickets_needTo_buy: tickets[i]})\\n  }\\n  while(queue.length > 0){\\n    const person = queue.shift();\\n    if(person.no_of_tickets_needTo_buy > 0){\\n      person.no_of_tickets_needTo_buy --\\n      queue.push(person)\\n      totalTime ++\\n      if(person.pos === k && person.no_of_tickets_needTo_buy === 0) return totalTime;\\n    }\\n  }\\n  return totalTime\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n  let queue = []\\n  let totalTime = 0;\\n  for(let i = 0; i < tickets.length; i++){\\n    queue.push({pos:i, no_of_tickets_needTo_buy: tickets[i]})\\n  }\\n  while(queue.length > 0){\\n    const person = queue.shift();\\n    if(person.no_of_tickets_needTo_buy > 0){\\n      person.no_of_tickets_needTo_buy --\\n      queue.push(person)\\n      totalTime ++\\n      if(person.pos === k && person.no_of_tickets_needTo_buy === 0) return totalTime;\\n    }\\n  }\\n  return totalTime\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002364,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int cnt = 0, a = 0;\\n\\n        while(tickets[k] != 0){\\n            if(a == tickets.size()){\\n                a = 0;\\n            }\\n            if(tickets[a] == 0){\\n                a++;\\n                continue;\\n            }\\n            tickets[a]--;\\n            cnt++;\\n            a++;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int cnt = 0, a = 0;\\n\\n        while(tickets[k] != 0){\\n            if(a == tickets.size()){\\n                a = 0;\\n            }\\n            if(tickets[a] == 0){\\n                a++;\\n                continue;\\n            }\\n            tickets[a]--;\\n            cnt++;\\n            a++;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001871,
                "title": "c-solution-using-queue",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<int> line;\\n        int n = tickets.size();\\n        int time = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            line.push(i);\\n        }\\n\\n        while (!line.empty()) {\\n            int current = line.front(); \\n            line.pop();\\n\\n            if (tickets[current] > 0) {\\n                tickets[current]--;\\n                time++;\\n\\n                if (current == k && tickets[k] == 0) {\\n                    break;\\n                }\\n\\n                line.push(current); \\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        queue<int> line;\\n        int n = tickets.size();\\n        int time = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            line.push(i);\\n        }\\n\\n        while (!line.empty()) {\\n            int current = line.front(); \\n            line.pop();\\n\\n            if (tickets[current] > 0) {\\n                tickets[current]--;\\n                time++;\\n\\n                if (current == k && tickets[k] == 0) {\\n                    break;\\n                }\\n\\n                line.push(current); \\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001811,
                "title": "c-iterative-solve",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        vector<int> remain = tickets;\\n        int time = 0;\\n\\n        while (remain[k] > 0) {\\n            for (int i = 0; i < n; i++) {\\n                if (remain[i] > 0) {\\n                    remain[i]--;\\n                    time++;\\n\\n                    if (i==k && remain[i]==0) { \\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int n = tickets.size();\\n        vector<int> remain = tickets;\\n        int time = 0;\\n\\n        while (remain[k] > 0) {\\n            for (int i = 0; i < n; i++) {\\n                if (remain[i] > 0) {\\n                    remain[i]--;\\n                    time++;\\n\\n                    if (i==k && remain[i]==0) { \\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return time;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998439,
                "title": "o-n-c-solution",
                "content": "# Complexity\\n- Time complexity:\\n***O(N)***\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& a, int k) {\\n        int cnt = 0;\\n        for(int i = 0;i<a.size();i++){\\n            if(i<=k)cnt+=min(a[i],a[k]);\\n            else cnt+=min(a[k]-1,a[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& a, int k) {\\n        int cnt = 0;\\n        for(int i = 0;i<a.size();i++){\\n            if(i<=k)cnt+=min(a[i],a[k]);\\n            else cnt+=min(a[k]-1,a[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998421,
                "title": "100-easy-c-solution-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& a, int k) {\\n        int cnt = 0;\\n        while(a[k]){\\n            for(int i = 0;i<a.size();i++){\\n                if(a[i])a[i]--,cnt++;\\n                if(!a[k])break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& a, int k) {\\n        int cnt = 0;\\n        while(a[k]){\\n            for(int i = 0;i<a.size();i++){\\n                if(a[i])a[i]--,cnt++;\\n                if(!a[k])break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995977,
                "title": "easy-o-1-solution-without-queue",
                "content": "# Intuition\\nnothing XD\\n\\n# Approach\\niterate over array and keep track \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int i=0;\\n        int sec=0;\\n        while(tickets[k]>0){\\n\\n            if(tickets[i]>0){\\n                tickets[i] = tickets[i]-1;\\n                i = (i+1)%tickets.length;\\n                sec++;\\n            }else{\\n                i = (i+1)%tickets.length;\\n            }\\n        }\\n\\n        return sec;\\n        \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int i=0;\\n        int sec=0;\\n        while(tickets[k]>0){\\n\\n            if(tickets[i]>0){\\n                tickets[i] = tickets[i]-1;\\n                i = (i+1)%tickets.length;\\n                sec++;\\n            }else{\\n                i = (i+1)%tickets.length;\\n            }\\n        }\\n\\n        return sec;\\n        \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985951,
                "title": "simple-c-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& t, int k) {\\n        int ans=0;\\n        while(t[k]!=0){\\n            for(int i=0;i<t.size();i++){\\n                if(t[i]>0){\\n                    t[i]=t[i]-1;\\n                    ans++;\\n                }\\n                if(t[k]==0)break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& t, int k) {\\n        int ans=0;\\n        while(t[k]!=0){\\n            for(int i=0;i<t.size();i++){\\n                if(t[i]>0){\\n                    t[i]=t[i]-1;\\n                    ans++;\\n                }\\n                if(t[k]==0)break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984228,
                "title": "simple-c-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\nLinear Time complexity\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        int i=0;\\n        int n=tickets.size();\\n        while(tickets[k]!=0){\\n            if(tickets[i%n]!=0){\\n                tickets[i%n]--;\\n                time++;\\n                i++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return time;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n        int time=0;\\n        int i=0;\\n        int n=tickets.size();\\n        while(tickets[k]!=0){\\n            if(tickets[i%n]!=0){\\n                tickets[i%n]--;\\n                time++;\\n                i++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return time;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980174,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        int n = tickets[k];\\n        while (n > 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[i]-- > 0) {\\n                    count++;\\n                    if (i == k) {\\n                        n--;\\n                    }\\n                    if (tickets[k] == 0) {\\n                        return count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count = 0;\\n        int n = tickets[k];\\n        while (n > 0) {\\n            for (int i = 0; i < tickets.length; i++) {\\n                if (tickets[i]-- > 0) {\\n                    count++;\\n                    if (i == k) {\\n                        n--;\\n                    }\\n                    if (tickets[k] == 0) {\\n                        return count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980063,
                "title": "java-easy-o-n-100-beats-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s assume there are n person standing in the queue a\\na1, a2, a3, ... ak ... an\\ni\\'th person will buy ai number of tickets. \\n\\nObservations\\nFor any person standing at the j\\'th position in the queue such that \\nj <= k, \\nthe one thing is sure, that person will make the k\\'th person to wait by min(aj, ak)\\n\\nand if \\nj > k\\nthen the j\\'th person will make the k\\'th person to wait longer by min(aj, ak-1)\\n\\nUsing the above two observations, we can write an algorithm with O(N) Time Complexity\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        // O(N) solution\\n        int time = 0; \\n        for ( int i=0; i < tickets.length; i++){\\n            if ( i <= k){\\n                time += ( tickets[i] <= tickets[k])?tickets[i]:tickets[k];\\n            }\\n            else{\\n                time += (tickets[i] < tickets[k])?tickets[i]: (tickets[k]-1);\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        // O(N) solution\\n        int time = 0; \\n        for ( int i=0; i < tickets.length; i++){\\n            if ( i <= k){\\n                time += ( tickets[i] <= tickets[k])?tickets[i]:tickets[k];\\n            }\\n            else{\\n                time += (tickets[i] < tickets[k])?tickets[i]: (tickets[k]-1);\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971374,
                "title": "js-time-o-n-space-o-1-single-for-loop",
                "content": "# Intuition & Approach\\nCycle the array, if tickets at i is greater than or equal to tickets at k you add to seconds the value of tickets at k, otherwise (if the number is smaller) you add tickets at k.\\nif the number at k is larger then the number at i and it is positioned after k so that i > k, you need to subtract 1 for each occourrence (we need to stop when tickets[k] reaches 0, so we dont need to count iterations afterwards)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let seconds = 0\\n    for(let i = 0; i < tickets.length; i++){\\n        if(tickets[i] >= tickets[k]){\\n            seconds += tickets[k]\\n            if(i > k) {\\n                seconds -= 1\\n            }\\n        } else {\\n            seconds += tickets[i]\\n        }\\n    }\\n    return seconds\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} tickets\\n * @param {number} k\\n * @return {number}\\n */\\nvar timeRequiredToBuy = function(tickets, k) {\\n    let seconds = 0\\n    for(let i = 0; i < tickets.length; i++){\\n        if(tickets[i] >= tickets[k]){\\n            seconds += tickets[k]\\n            if(i > k) {\\n                seconds -= 1\\n            }\\n        } else {\\n            seconds += tickets[i]\\n        }\\n    }\\n    return seconds\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3966793,
                "title": "with-basic-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        count=0\\n        while True:\\n            for i in range(len(tickets)):\\n                if tickets[i]>0:\\n                    tickets[i]-=1\\n                    count+=1\\n                if tickets[k]==0:\\n                    return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        count=0\\n        while True:\\n            for i in range(len(tickets)):\\n                if tickets[i]>0:\\n                    tickets[i]-=1\\n                    count+=1\\n                if tickets[k]==0:\\n                    return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963719,
                "title": "easy-to-understand-python3-solution-tc-m-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        count = 0\\n\\n        check = tickets[k]\\n\\n        while check != 0:\\n            for i in range(len(tickets)):\\n                if tickets[i] > 0:\\n                    if tickets[k] == 0:\\n                        break\\n                    count += 1\\n                    tickets[i] -= 1\\n            check = tickets[k]\\n            \\n        return count\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        count = 0\\n\\n        check = tickets[k]\\n\\n        while check != 0:\\n            for i in range(len(tickets)):\\n                if tickets[i] > 0:\\n                    if tickets[k] == 0:\\n                        break\\n                    count += 1\\n                    tickets[i] -= 1\\n            check = tickets[k]\\n            \\n        return count\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956695,
                "title": "python-one-liner",
                "content": "# Approach\\n- the ticket less than the kth customer must spend all their time\\nsum(i for i in tickets if i <= tickets[k])\\n- the ticket more than the kth customer must spend the time equal to the kth customer\\nlen([i for i in tickets if i > tickets[k]])*tickets[k]\\n- the ticket more than the kth customer but after the kth customer need to minus one seconds beacuse when the kth customer finished, the program finished\\nlen([i for i in tickets[k+1:] if i >= tickets[k]])\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(i for i in tickets if i <= tickets[k]) + len([i for i in tickets if i > tickets[k]])*tickets[k] - len([i for i in tickets[k+1:] if i >= tickets[k]])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:\\n        return sum(i for i in tickets if i <= tickets[k]) + len([i for i in tickets if i > tickets[k]])*tickets[k] - len([i for i in tickets[k+1:] if i >= tickets[k]])\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1628030,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 1928915,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 1930154,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 2010067,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 2010064,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 1969342,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            },
            {
                "id": 1919927,
                "content": [
                    {
                        "username": "tejartr445",
                        "content": "I feel this version of leetcode is not as good as old one, yeah this has many good features like it added timer and it have gave few other new features but the solutions sections and discuss sections aren\\'t that good as they were before "
                    },
                    {
                        "username": "Yash2k04",
                        "content": "and it\\'s also not support chrome extension leethub, prevoiusly all the solutions are also upload to github as well. its pretty helpful but missing in this new update. "
                    },
                    {
                        "username": "CristianM92",
                        "content": "Agree!"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "just use queue data structure ! and push the indexes in it. and increase the time count after every iteration."
                    },
                    {
                        "username": "bparanj",
                        "content": "This tip is worth 100 upvotes. Amazing!!!"
                    },
                    {
                        "username": "hancu345",
                        "content": "The most important thing to solve this problem is to take into consideration the fact that all people behind K-th person, which have more tickets to buy than K-th person, can only buy k-1 tickets. For example: if the person behind K-th person wants to buy 73 tickets, and k-th person wants to but 24, if you simulate this queue in real life you will see that at the 24th pass, the k-th person will buy the 24th ticket, but the person behind won\\'t buy the 24th ticket because k-th person has already finished buying his tickets.\\n"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "this question was asked by uber"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "use Deque!"
                    },
                    {
                        "username": "Revati_Shimpi",
                        "content": "class Solution {\\n    public int timeRequiredToBuy(int[] tickets, int k) {\\n        int count=0,i=0;\\n        while(tickets[k]!=0){ //UNTIL tickets at k =0\\n            for(i=0;i<tickets.length;i++){ //TRAVERSES THE WHOLE ARRAY AND REDUCES TICKET COUNT BY 1\\n            if(tickets[i]!=0){\\n                count++;\\n                tickets[i]--;\\n            }\\n         }\\n    }\\n    return count; //AS SOON AS TICKETS AT K=0 RETURNS THE COUNT i.e. The time at which it is over\\n    }\\n} \\nWhere is my code wrong logically?"
                    },
                    {
                        "username": "suyash_5050",
                        "content": "when your k element in array becomes 0 then to it is decreasing further element in the array always make sure to stop traversing immediate after tickets[k] == 0 !!\\n*** Just add one if condition ***\\n\\nclass Solution {\\npublic:\\n    int timeRequiredToBuy(vector<int>& tickets, int k) {\\n\\n        int time = 0;\\n        \\n        while(tickets[k] != 0){\\n\\n            for(int i=0; i<tickets.size(); i++){\\n\\n                if(tickets[i] > 0){\\n                    tickets[i]--;\\n                    time++;\\n                }\\n                if(tickets[k] == 0){\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return time;\\n    }\\n};"
                    },
                    {
                        "username": "Bek_Shoyatbekov",
                        "content": "Is it correct  problem? "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "yes\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Reverse Nodes in Even Length Groups",
        "question_content": "<p>You are given the <code>head</code> of a linked list.</p>\n\n<p>The nodes in the linked list are <strong>sequentially</strong> assigned to <strong>non-empty</strong> groups whose lengths form the sequence of the natural numbers (<code>1, 2, 3, 4, ...</code>). The <strong>length</strong> of a group is the number of nodes assigned to it. In other words,</p>\n\n<ul>\n\t<li>The <code>1<sup>st</sup></code> node is assigned to the first group.</li>\n\t<li>The <code>2<sup>nd</sup></code> and the <code>3<sup>rd</sup></code> nodes are assigned to the second group.</li>\n\t<li>The <code>4<sup>th</sup></code>, <code>5<sup>th</sup></code>, and <code>6<sup>th</sup></code> nodes are assigned to the third group, and so on.</li>\n</ul>\n\n<p>Note that the length of the last group may be less than or equal to <code>1 + the length of the second to last group</code>.</p>\n\n<p><strong>Reverse</strong> the nodes in each group with an <strong>even</strong> length, and return <em>the</em> <code>head</code> <em>of the modified linked list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/eg1.png\" style=\"width: 699px; height: 124px;\" />\n<pre>\n<strong>Input:</strong> head = [5,2,6,3,9,1,7,3,8,4]\n<strong>Output:</strong> [5,6,2,3,9,1,4,8,3,7]\n<strong>Explanation:</strong>\n- The length of the first group is 1, which is odd, hence no reversal occurs.\n- The length of the second group is 2, which is even, hence the nodes are reversed.\n- The length of the third group is 3, which is odd, hence no reversal occurs.\n- The length of the last group is 4, which is even, hence the nodes are reversed.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/eg2.png\" style=\"width: 284px; height: 114px;\" />\n<pre>\n<strong>Input:</strong> head = [1,1,0,6]\n<strong>Output:</strong> [1,0,1,6]\n<strong>Explanation:</strong>\n- The length of the first group is 1. No reversal occurs.\n- The length of the second group is 2. The nodes are reversed.\n- The length of the last group is 1. No reversal occurs.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/17/ex3.png\" style=\"width: 348px; height: 114px;\" />\n<pre>\n<strong>Input:</strong> head = [1,1,0,6,5]\n<strong>Output:</strong> [1,0,1,5,6]\n<strong>Explanation:</strong>\n- The length of the first group is 1. No reversal occurs.\n- The length of the second group is 2. The nodes are reversed.\n- The length of the last group is 2. The nodes are reversed.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1576952,
                "title": "c-well-commented-clear-code-idea-explained-in-brief",
                "content": "\\n\\n**Idea**\\n* I traverse the list in groups where the sizes are in the increasing order of natural numbers. \\n* Whenever a group with even length is encountered, that group is reversed using the reverse function and I proceed with processing the next group. \\n* The solution involves several pointers which track the current group\\u2019s head, tail and the next group\\u2019s head. \\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    \\n    // Function to reverse a linked list\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head)\\n            return head;\\n        ListNode* prev = NULL;\\n        while(head) {\\n            ListNode* temp = head -> next;\\n            head -> next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // Creating a dummy node to avoid adding checks for the first node\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        \\n        ListNode* prev = dummy;\\n        \\n        // Loop to determine the lengths of groups\\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            // Determining the length of the current group\\n            // Its maximum length can be equal to len\\n            int j = 1;\\n            while(j < len && tail && tail -> next) {\\n                tail = tail -> next;\\n                j++;\\n            }\\n            \\n            // Head of the next group\\n            nextHead = tail -> next;\\n            \\n            if((j % 2) == 0) {\\n                // If even sized group is found\\n                // Reversing the group and setting prev and head appropriately\\n                tail -> next = NULL;\\n                prev -> next = reverseList(head);\\n                prev = head;\\n                head -> next = nextHead;\\n                head = nextHead;\\n            } else {\\n                // If group is odd sized, then simply going towards the next group\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        // Returning the head\\n        return dummy -> next;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\n*Space Complexity: O(1)*\\n*Time Complexity: O(n)*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Function to reverse a linked list\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head)\\n            return head;\\n        ListNode* prev = NULL;\\n        while(head) {\\n            ListNode* temp = head -> next;\\n            head -> next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // Creating a dummy node to avoid adding checks for the first node\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        \\n        ListNode* prev = dummy;\\n        \\n        // Loop to determine the lengths of groups\\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            // Determining the length of the current group\\n            // Its maximum length can be equal to len\\n            int j = 1;\\n            while(j < len && tail && tail -> next) {\\n                tail = tail -> next;\\n                j++;\\n            }\\n            \\n            // Head of the next group\\n            nextHead = tail -> next;\\n            \\n            if((j % 2) == 0) {\\n                // If even sized group is found\\n                // Reversing the group and setting prev and head appropriately\\n                tail -> next = NULL;\\n                prev -> next = reverseList(head);\\n                prev = head;\\n                head -> next = nextHead;\\n                head = nextHead;\\n            } else {\\n                // If group is odd sized, then simply going towards the next group\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        // Returning the head\\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576911,
                "title": "java-two-pointers-stack",
                "content": "**Idea :** \\n1. \\ttemp is pointing end of a particular group\\n1. \\tstart is pointing starting of a particular group\\n1. \\twhile traversing put node\\'s values in stack (LIFO)\\n1. \\twhen the count of nodes in a group is == to the count of nodes required for that group and is even \\nthen move start pointer ahead and update values of nodes in that group.\\n```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int groupRequired = 1;\\n        ListNode temp = head;\\n        while(temp != null){\\n            int count = 0;\\n            ListNode start = temp;\\n            Stack<Integer> stack = new Stack<>();\\n            while(count != groupRequired && temp != null){\\n                stack.push(temp.val);\\n                temp = temp.next;\\n                count++;\\n            }\\n            if(count % 2 == 0) {\\n                while(start != temp){\\n                    start.val = stack.pop();\\n                    start = start.next;\\n                }\\n            }\\n            groupRequired++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int groupRequired = 1;\\n        ListNode temp = head;\\n        while(temp != null){\\n            int count = 0;\\n            ListNode start = temp;\\n            Stack<Integer> stack = new Stack<>();\\n            while(count != groupRequired && temp != null){\\n                stack.push(temp.val);\\n                temp = temp.next;\\n                count++;\\n            }\\n            if(count % 2 == 0) {\\n                while(start != temp){\\n                    start.val = stack.pop();\\n                    start = start.next;\\n                }\\n            }\\n            groupRequired++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577032,
                "title": "python-reverse-linked-list-o-1-space",
                "content": "Similiar to [25. Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/), reverse a range of linked list when the range has an even length\\n```\\ndef reverseEvenLengthGroups(head):\\n\\tprev = head\\n\\td = 2 # the head doesn\\'t need to be reversed anytime so starts with length 2\\n\\twhile prev.next:\\n\\t\\tnode, n = prev, 0\\n\\t\\tfor _ in range(d):\\n\\t\\t\\tif not node.next:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tn += 1\\n\\t\\t\\tnode = node.next\\n\\t\\tif n & 1:  # odd length\\n\\t\\t\\tprev = node\\n\\t\\telse:      # even length\\n\\t\\t\\tnode, rev = prev.next, None\\n\\t\\t\\tfor _ in range(n):\\n\\t\\t\\t\\tnode.next, node, rev = rev, node.next, node\\n\\t\\t\\tprev.next.next, prev.next, prev = node, rev, prev.next\\n\\t\\td += 1\\n\\treturn head\\n```\\n\\nCheat during the contest to save time, convert linked list to a list and then just do slice reversion.\\nOf course cost extra O(n) space\\n```\\ndef reverseEvenLengthGroups(self, head):\\n\\ta = []\\n\\tnode = head\\n\\twhile node:\\n\\t\\ta.append(node.val)\\n\\t\\tnode = node.next\\n\\ti, d, n = 0, 1, len(a)\\n\\twhile i < n:\\n\\t\\tif min(d, n-i) & 1 == 0:\\n\\t\\t\\ta[i:i+d] = a[i:i+d][::-1]\\n\\t\\ti += d\\n\\t\\td += 1\\n\\tnode = head\\n\\tfor x in a:\\n\\t\\tnode.val = x\\n\\t\\tnode = node.next\\n\\treturn head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef reverseEvenLengthGroups(head):\\n\\tprev = head\\n\\td = 2 # the head doesn\\'t need to be reversed anytime so starts with length 2\\n\\twhile prev.next:\\n\\t\\tnode, n = prev, 0\\n\\t\\tfor _ in range(d):\\n\\t\\t\\tif not node.next:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tn += 1\\n\\t\\t\\tnode = node.next\\n\\t\\tif n & 1:  # odd length\\n\\t\\t\\tprev = node\\n\\t\\telse:      # even length\\n\\t\\t\\tnode, rev = prev.next, None\\n\\t\\t\\tfor _ in range(n):\\n\\t\\t\\t\\tnode.next, node, rev = rev, node.next, node\\n\\t\\t\\tprev.next.next, prev.next, prev = node, rev, prev.next\\n\\t\\td += 1\\n\\treturn head\\n```\n```\\ndef reverseEvenLengthGroups(self, head):\\n\\ta = []\\n\\tnode = head\\n\\twhile node:\\n\\t\\ta.append(node.val)\\n\\t\\tnode = node.next\\n\\ti, d, n = 0, 1, len(a)\\n\\twhile i < n:\\n\\t\\tif min(d, n-i) & 1 == 0:\\n\\t\\t\\ta[i:i+d] = a[i:i+d][::-1]\\n\\t\\ti += d\\n\\t\\td += 1\\n\\tnode = head\\n\\tfor x in a:\\n\\t\\tnode.val = x\\n\\t\\tnode = node.next\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1577372,
                "title": "constant-memory",
                "content": "> Trap: if the last group is incomplete, we still need to reverse it if it has even number of elements.\\n\\nI re-used the `reverseList` function from my solution for [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/). It reverses `n` elements starting from a specific node.\\n\\nNow, we just need to find the groups. For each grop, we track `start` (`start->next` is the first element in the group), and the number of elements available.\\n\\n**C++**\\n```cpp\\nListNode* reverseList(ListNode* cur, int n) {\\n    ListNode *start = cur, *prev = nullptr;\\n    while (--n >= 0) {\\n        swap(cur->next, prev);\\n        if (--n >= 0)\\n            swap(prev->next, cur);\\n    }\\n    start->next = cur;\\n    return prev;\\n}  \\nListNode* reverseEvenLengthGroups(ListNode* head) {\\n    int group = 2, cnt = 0;\\n    auto *start = head, *p = head->next;\\n    while (p != nullptr) {\\n        if (++cnt == group) {\\n            if (group % 2 == 0) {\\n                p = start->next;\\n                start->next = reverseList(start->next, cnt);\\n            }\\n            start = p;\\n            cnt = 0;\\n            ++group;\\n        }\\n        p = p->next;\\n    }\\n    if (cnt % 2 == 0 && start->next != nullptr)\\n        start->next = reverseList(start->next, cnt);\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nListNode* reverseList(ListNode* cur, int n) {\\n    ListNode *start = cur, *prev = nullptr;\\n    while (--n >= 0) {\\n        swap(cur->next, prev);\\n        if (--n >= 0)\\n            swap(prev->next, cur);\\n    }\\n    start->next = cur;\\n    return prev;\\n}  \\nListNode* reverseEvenLengthGroups(ListNode* head) {\\n    int group = 2, cnt = 0;\\n    auto *start = head, *p = head->next;\\n    while (p != nullptr) {\\n        if (++cnt == group) {\\n            if (group % 2 == 0) {\\n                p = start->next;\\n                start->next = reverseList(start->next, cnt);\\n            }\\n            start = p;\\n            cnt = 0;\\n            ++group;\\n        }\\n        p = p->next;\\n    }\\n    if (cnt % 2 == 0 && start->next != nullptr)\\n        start->next = reverseList(start->next, cnt);\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577077,
                "title": "java-reverse-list-o-1-space",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // Check corner case with null.\\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        // Count number of nodes in total.\\n        ListNode ptr = head;\\n        int total = 0;\\n        while (ptr != null) {\\n            total++;\\n            ptr = ptr.next;\\n        }\\n        \\n        int numOfNodes = 1;\\n        ListNode cur = head, pre = null;\\n        while (cur != null) {\\n            numOfNodes = Math.min(numOfNodes, total);\\n            total -= numOfNodes;\\n            if (numOfNodes % 2 == 1) {\\n                // Odd: Move pointers.\\n                int cnt = 0;\\n                while (cur != null && cnt++ < numOfNodes) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            } else {\\n                // Even: Reverse List\\n                ListNode[] res = reverseList(cur, numOfNodes);\\n                pre.next = res[0];\\n                pre = cur;\\n                cur = res[1];\\n            }\\n            numOfNodes++;\\n        }\\n        return head;\\n    }\\n    \\n    // Reverse from node with n nodes.\\n    private ListNode[] reverseList(ListNode node, int n) {\\n        ListNode pre = null, cur = node, post = null;\\n        while (n-- > 0) {\\n            post = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = post;\\n        }\\n        node.next = cur;\\n        return new ListNode[]{pre, post};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // Check corner case with null.\\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        // Count number of nodes in total.\\n        ListNode ptr = head;\\n        int total = 0;\\n        while (ptr != null) {\\n            total++;\\n            ptr = ptr.next;\\n        }\\n        \\n        int numOfNodes = 1;\\n        ListNode cur = head, pre = null;\\n        while (cur != null) {\\n            numOfNodes = Math.min(numOfNodes, total);\\n            total -= numOfNodes;\\n            if (numOfNodes % 2 == 1) {\\n                // Odd: Move pointers.\\n                int cnt = 0;\\n                while (cur != null && cnt++ < numOfNodes) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            } else {\\n                // Even: Reverse List\\n                ListNode[] res = reverseList(cur, numOfNodes);\\n                pre.next = res[0];\\n                pre = cur;\\n                cur = res[1];\\n            }\\n            numOfNodes++;\\n        }\\n        return head;\\n    }\\n    \\n    // Reverse from node with n nodes.\\n    private ListNode[] reverseList(ListNode node, int n) {\\n        ListNode pre = null, cur = node, post = null;\\n        while (n-- > 0) {\\n            post = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = post;\\n        }\\n        node.next = cur;\\n        return new ListNode[]{pre, post};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577058,
                "title": "python3-using-stack",
                "content": "Downvoters, leave a comment! \\n\\nPlease check out this [commit](https://github.com/gaosanyong/leetcode/commit/8d693371fa97ea3b0717d02448c77201b15e5d12) for solutions of weekly 267.\\n```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n, node = 0, head\\n        while node: n, node = n+1, node.next\\n        \\n        k, node = 0, head \\n        while n: \\n            k += 1\\n            size = min(k, n)\\n            stack = []\\n            if not size & 1: \\n                temp = node \\n                for _ in range(size): \\n                    stack.append(temp.val)\\n                    temp = temp.next \\n            for _ in range(size): \\n                if stack: node.val = stack.pop()\\n                node = node.next \\n            n -= size\\n        return head \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        n, node = 0, head\\n        while node: n, node = n+1, node.next\\n        \\n        k, node = 0, head \\n        while n: \\n            k += 1\\n            size = min(k, n)\\n            stack = []\\n            if not size & 1: \\n                temp = node \\n                for _ in range(size): \\n                    stack.append(temp.val)\\n                    temp = temp.next \\n            for _ in range(size): \\n                if stack: node.val = stack.pop()\\n                node = node.next \\n            n -= size\\n        return head \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577265,
                "title": "java-easy-code",
                "content": "class Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        ListNode temp = head;\\n        int num=1;\\n        \\n        while(temp!=null)\\n        {\\n            int count=0;\\n            ListNode start = temp;\\n            Stack st = new Stack();\\n            \\n            while(count!=num && temp!=null)\\n            {\\n                st.push(temp.val);\\n                temp=temp.next;\\n                count++;\\n                    \\n            }\\n            \\n            if(count%2==0)\\n            {\\n                while(temp!=start)\\n                {\\n                  start.val=(int) st.pop();\\n                 start=start.next;  \\n                }\\n                \\n            }\\n            \\n            num++;\\n        }\\n        \\n        \\n        return head;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        ListNode temp = head;\\n        int num=1;\\n        \\n        while(temp!=null)\\n        {\\n            int count=0;\\n            ListNode start = temp;\\n            Stack st = new Stack();\\n            \\n            while(count!=num && temp!=null)\\n            {\\n                st.push(temp.val);\\n                temp=temp.next;\\n                count++;\\n                    \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3746598,
                "title": "java-c-o-n-solution-readable-code-illustration",
                "content": "This problem can be broken down into 2 steps:\\n\\n1.  Since we need to reverse the nodes in each group with an even length, we need to check length of each group. It it is odd then there is no need to reverse.\\n2.  If we need to reverse the **N** nodes, how to do that? Following is my idea:\\n \\n\\n\\t\\nIf the structure of the linkedlist is like this:\\n\\n\\n\\t\\t1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 \\n\\t\\n\\t\\nSince group 1 will always have one node. It doesn\\'t need to be reversed.\\n\\nWe will have node as a pointer :\\n```\\n\\tListNode node=head;\\n\\tint group=1;\\n```\\n\\nAfter we have node as the pointer, the linked list will look like this:\\n```\\n\\t1 (node) -> 2 -> 3 -> 4 -> 5 -> 6 -> 7\\n```\\nNow we will start counting & reversing from 2nd node.\\nTo count number of nodes in a group we will use following code:\\n```\\n\\tint countNodes=0;\\n    ListNode temp=node.next;\\n     while(temp!=null && countNodes<group)\\n\\t\\t {\\n\\t\\t\\t  temp=temp.next;\\n              countNodes++;\\n         }\\n```\\n\\nSuppose that there are **even** nodes to be reversed, we just use the \"reverse linked list\" trick to reverse the k nodes. Please refer to \"https://leetcode.com/problems/reverse-linked-list/\" if you don\\'t know how to reverse a linked list.\\n\\nIf **countNodes is even** i.e for second group `countNodes= 2, we can reverse 2 to 3`  using the following code:\\n\\n```\\n\\tListNode curr=node.next,prev=null,next=null;\\n     for(int i=0;i<countNodes;i++)\\n\\t\\t{\\n\\t\\t\\t  next=curr.next;\\n              curr.next=prev;\\n              prev=curr;\\n              curr=next;\\n        }             \\n```\\n\\nThis is the illustartion of the first 2 steps:\\n\\n```\\n    We will begin reversing form 2nd node\\n\\t\\n    Step1: 1 (node)  -> 2      3 -> 4 -> 5 -> 6 -> 7\\n\\tStep2: 1 (node)  -> 2 <- 3      4 -> 5 -> 6 -> 7\\n\\t\\n```\\n\\nThis is an easy and general algorithm to reverse a linked list. However, if you are careful enough, you will find that after the for-loop, the link from 3 to 4 will be cut (as shown in step 2).\\n\\nNow we need to reconstruct the linked list and fix the issue. You will figure out that at step3, the 3 is the **prev** node, 4 is the **curr** node.\\n\\n```\\nstep2: 1 (node) -> 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n```\\n\\n\\t\\nWe can fix the sequence based on the following codes. The basic idea is to link the `node to 3` and `link 2 to 4`:\\n\\n```\\n\\tListNode tail=node.next;\\n    tail.next=curr;\\n    node.next=prev;\\n    node=tail;\\n```\\n\\nThen the result is:\\n```\\n\\tafter first line:        1 (node) -> 2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\tafter second line:       1 (node) -> 2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t         |________________________\\u2191\\n\\tafter third line:   \\n\\t\\t\\t\\t\\t\\t\\t\\t |--------------------\\u2193\\n\\t\\t\\t\\t\\t\\t     1 (node)    2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t     |________________________\\u2191\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\tafter forth line:\\t     1  -> 3  -> 2  (node) -> 4 -> 5 -> 6 -> 7\\n```\\n\\nNow we get the new **node** as pointer, and we can repeat the process.\\n\\n` `**Edge Case**:  if the last group is incomplete, we still need to reverse it if it has even number of elements.\\n\\n\\n\\nIf group has odd number of nodes then we can skip the reverse process by following code:\\n```\\n\\tfor(int i=0;i<countNodes;i++)\\n\\t\\t node=node.next;\\n```\\n\\nHere is the code:\\n\\n**Java**\\n\\n```\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n\\n        //  if LL has 1 or 2 nodes only\\n        if (head.next == null || head.next.next == null) return head;\\n        ListNode node = head;\\n        int group = 1;\\n\\n        while (node != null && node.next != null) {\\n            group++;\\n\\t\\t\\t\\n            //first check number of nodes \\n            int countNodes = 0;\\n            ListNode temp = node.next;\\n            while (temp != null && countNodes < group) {\\n                temp = temp.next;\\n                countNodes++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//now we have count now we will check if it is even then do reverse else skip\\n            if (countNodes % 2 == 0) {\\n                ListNode curr = node.next, prev = null, next = null;\\n                for (int i = 0; i < countNodes; i++) {\\n                    next = curr.next;\\n                    curr.next = prev;\\n                    prev = curr;\\n                    curr = next;\\n                }\\n\\n                ListNode tail = node.next;\\n                tail.next = curr;\\n                node.next = prev;\\n                node = tail;\\n            } else {\\n                for (int i = 0; i < countNodes; i++)\\n                    node = node.next;\\n            }\\n        }\\n        return head;\\n    }\\n```\\n\\n**C++**\\n```\\nListNode* reverseEvenLengthGroups(ListNode *head)\\n\\t\\t{\\n\\t\\t\\t//  if LL has 1 or 2 nodes only\\n\\t\\t\\tif (head->next == nullptr || head->next->next == nullptr) return head;\\n\\n\\t\\t\\tListNode *node = head;\\n\\t\\t\\tint group = 1;\\n\\n\\t\\t\\twhile (node != nullptr && node->next != nullptr)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgroup++;\\n\\n\\t\\t\\t\\tint countNodes = 0;\\n\\t\\t\\t\\tListNode *temp = node->next;\\n\\t\\t\\t\\twhile (temp != nullptr && countNodes < group)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp = temp->next;\\n\\t\\t\\t\\t\\tcountNodes++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (countNodes % 2 == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tListNode *curr = node->next, *prev = nullptr, *next = nullptr;\\n\\t\\t\\t\\t\\tfor (int i = 0; i < countNodes; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnext = curr->next;\\n\\t\\t\\t\\t\\t\\tcurr->next = prev;\\n\\t\\t\\t\\t\\t\\tprev = curr;\\n\\t\\t\\t\\t\\t\\tcurr = next;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tListNode *tail = node->next;\\n\\t\\t\\t\\t\\ttail->next = curr;\\n\\t\\t\\t\\t\\tnode->next = prev;\\n\\t\\t\\t\\t\\tnode = tail;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor (int i = 0; i < countNodes; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnode = node->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn head;\\n\\t\\t}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8e188750-ff71-4621-b32f-f28d92186d1b_1689008854.9552872.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\tListNode node=head;\\n\\tint group=1;\\n```\n```\\n\\t1 (node) -> 2 -> 3 -> 4 -> 5 -> 6 -> 7\\n```\n```\\n\\tint countNodes=0;\\n    ListNode temp=node.next;\\n     while(temp!=null && countNodes<group)\\n\\t\\t {\\n\\t\\t\\t  temp=temp.next;\\n              countNodes++;\\n         }\\n```\n```\\n\\tListNode curr=node.next,prev=null,next=null;\\n     for(int i=0;i<countNodes;i++)\\n\\t\\t{\\n\\t\\t\\t  next=curr.next;\\n              curr.next=prev;\\n              prev=curr;\\n              curr=next;\\n        }             \\n```\n```\\n    We will begin reversing form 2nd node\\n\\t\\n    Step1: 1 (node)  -> 2      3 -> 4 -> 5 -> 6 -> 7\\n\\tStep2: 1 (node)  -> 2 <- 3      4 -> 5 -> 6 -> 7\\n\\t\\n```\n```\\nstep2: 1 (node) -> 2 <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n```\n```\\n\\tListNode tail=node.next;\\n    tail.next=curr;\\n    node.next=prev;\\n    node=tail;\\n```\n```\\n\\tafter first line:        1 (node) -> 2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\tafter second line:       1 (node) -> 2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t         |________________________\\u2191\\n\\tafter third line:   \\n\\t\\t\\t\\t\\t\\t\\t\\t |--------------------\\u2193\\n\\t\\t\\t\\t\\t\\t     1 (node)    2 (tail)  <- 3 (prev)    4 (curr) -> 5 -> 6 -> 7\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t     |________________________\\u2191\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\tafter forth line:\\t     1  -> 3  -> 2  (node) -> 4 -> 5 -> 6 -> 7\\n```\n```\\n\\tfor(int i=0;i<countNodes;i++)\\n\\t\\t node=node.next;\\n```\n```\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n\\n        //  if LL has 1 or 2 nodes only\\n        if (head.next == null || head.next.next == null) return head;\\n        ListNode node = head;\\n        int group = 1;\\n\\n        while (node != null && node.next != null) {\\n            group++;\\n\\t\\t\\t\\n            //first check number of nodes \\n            int countNodes = 0;\\n            ListNode temp = node.next;\\n            while (temp != null && countNodes < group) {\\n                temp = temp.next;\\n                countNodes++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//now we have count now we will check if it is even then do reverse else skip\\n            if (countNodes % 2 == 0) {\\n                ListNode curr = node.next, prev = null, next = null;\\n                for (int i = 0; i < countNodes; i++) {\\n                    next = curr.next;\\n                    curr.next = prev;\\n                    prev = curr;\\n                    curr = next;\\n                }\\n\\n                ListNode tail = node.next;\\n                tail.next = curr;\\n                node.next = prev;\\n                node = tail;\\n            } else {\\n                for (int i = 0; i < countNodes; i++)\\n                    node = node.next;\\n            }\\n        }\\n        return head;\\n    }\\n```\n```\\nListNode* reverseEvenLengthGroups(ListNode *head)\\n\\t\\t{\\n\\t\\t\\t//  if LL has 1 or 2 nodes only\\n\\t\\t\\tif (head->next == nullptr || head->next->next == nullptr) return head;\\n\\n\\t\\t\\tListNode *node = head;\\n\\t\\t\\tint group = 1;\\n\\n\\t\\t\\twhile (node != nullptr && node->next != nullptr)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgroup++;\\n\\n\\t\\t\\t\\tint countNodes = 0;\\n\\t\\t\\t\\tListNode *temp = node->next;\\n\\t\\t\\t\\twhile (temp != nullptr && countNodes < group)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ttemp = temp->next;\\n\\t\\t\\t\\t\\tcountNodes++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (countNodes % 2 == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tListNode *curr = node->next, *prev = nullptr, *next = nullptr;\\n\\t\\t\\t\\t\\tfor (int i = 0; i < countNodes; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnext = curr->next;\\n\\t\\t\\t\\t\\t\\tcurr->next = prev;\\n\\t\\t\\t\\t\\t\\tprev = curr;\\n\\t\\t\\t\\t\\t\\tcurr = next;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tListNode *tail = node->next;\\n\\t\\t\\t\\t\\ttail->next = curr;\\n\\t\\t\\t\\t\\tnode->next = prev;\\n\\t\\t\\t\\t\\tnode = tail;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor (int i = 0; i < countNodes; i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tnode = node->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn head;\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3832053,
                "title": "clean-python-solution-simple-beats-100-explanation",
                "content": "# Intuition\\nWhen considering this problem, we need to be comfortable with various linked list operations and concepts. These include understanding how to traverse a linked list, reverse a section of it without disrupting the rest of the list, and reconnect reversed segments seamlessly back into the list. With these tools in hand, the problem becomes a matter of grouping nodes, reversing the groups of even length, and then reconnecting these altered groups back into a complete linked list.\\n\\n# Approach\\nWe use a two-pointer approach to solve this problem. One pointer, `connector`, keeps track of the node preceding the current group. The other, `curr`, navigates the nodes within the current group.\\n\\nThe process begins with `curr` pointing to the head of the list and `connector` being None. We also have two counters, `group_count` to keep track of which group we are in, and `count` to track the length of the current group.\\n\\nWe have a helper function, `reverse_between`, which performs an in-place reversal of a section of the linked list starting from the node after `pre`, and does this for `n` nodes. It uses the classic three-pointer method for list reversal, with a twist to maintain the continuity of the list. Instead of breaking off the section to be reversed, it leaves the start node of this section linked to the rest of the list and moves the remaining nodes one by one to the front. This results in the list being reversed, but the original start node is now the end node of the reversed section and still connected to the rest of the list. After the reversal, the function returns the new end node of the section (which was the original start node).\\n\\nWe proceed with traversing the list, checking at each step whether we are at the end of a group. This is determined either by the counters `group_count` and `count` being equal, or by reaching the end of the list (`curr.next` is None). If we are at the end of a group and the group has an even length, we reverse it with our helper function and update the pointers accordingly. We then increment `group_count` and reset `count` to 0. We repeat this until we have traversed the entire list.\\n\\nThis approach ensures that even-length groups are reversed while maintaining the continuity of the list.\\n\\n# Complexity\\n- Time complexity: The time complexity is **O(n)**, where n is the number of nodes in the linked list. We achieve this by traversing the list only once, with each operation (reversing and reconnecting a group) taking constant time.\\n\\n- Space complexity: The space complexity is **O(1)**. We use a fixed amount of space to store our pointers and counters, and since we perform the reversal in-place, we do not use any additional data structures that scale with the size of the input.\\n\\nFor a detailed explanation of the list reversal process used in reverse_between, you can refer to this [problem](https://leetcode.com/problems/reverse-linked-list-ii/description/).\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        connector = None\\n        curr = head\\n        group_count = 1\\n        count = 1\\n\\n        def reverse_between(pre, n):\\n            start = pre.next\\n            then = start.next\\n            after = start\\n\\n            for _ in range(n - 1):\\n                start.next = then.next\\n                then.next = pre.next\\n                pre.next = then\\n                then = start.next\\n\\n            return after\\n\\n        while curr:\\n            if group_count == count or not curr.next:\\n                if count % 2 == 0:\\n                    curr = reverse_between(connector, count)\\n                connector = curr\\n                group_count += 1\\n                count = 0\\n\\n            count += 1\\n            curr = curr.next\\n\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        connector = None\\n        curr = head\\n        group_count = 1\\n        count = 1\\n\\n        def reverse_between(pre, n):\\n            start = pre.next\\n            then = start.next\\n            after = start\\n\\n            for _ in range(n - 1):\\n                start.next = then.next\\n                then.next = pre.next\\n                pre.next = then\\n                then = start.next\\n\\n            return after\\n\\n        while curr:\\n            if group_count == count or not curr.next:\\n                if count % 2 == 0:\\n                    curr = reverse_between(connector, count)\\n                connector = curr\\n                group_count += 1\\n                count = 0\\n\\n            count += 1\\n            curr = curr.next\\n\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519575,
                "title": "python-simple-neat-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        start_joint = head \\n        group_size = 1\\n        while start_joint and start_joint.next: \\n            group_size += 1\\n            start = end = start_joint.next \\n            group_num = 1 \\n            while end and end.next and group_num < group_size: \\n                end = end.next \\n                group_num += 1 \\n            end_joint = end.next \\n            if group_num % 2 != 0: \\n                start_joint = end \\n                continue \\n            start_joint.next = self.reverse(start, end, end_joint)\\n            start_joint = start \\n        return head\\n    def reverse(self, start, end, end_joint): \\n        prev, curr = end_joint, start\\n        while curr and curr != end_joint: \\n            next_node = curr.next\\n            curr.next = prev\\n            prev, curr = curr, next_node\\n        return prev\\n```\\nComments: This questions is a hard, it uses concepts from other hard questions like Reverse K-Nodes in Group, do not attempt if you are a beginner or haven\\'t had experience with those type of problems. The helper function reverse neatly reverses between start and end, makes sure the reversed end points to the node after end originally(end_joint), and `start_joint.next = self.reverse()` ties it all up. The remainder of the tricky part is handling the odd/even and not matching group_sizes. For those still confused of why there is start_joint, end_joint, this is because you need to maintain the node before and after the part that is being reversed.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        start_joint = head \\n        group_size = 1\\n        while start_joint and start_joint.next: \\n            group_size += 1\\n            start = end = start_joint.next \\n            group_num = 1 \\n            while end and end.next and group_num < group_size: \\n                end = end.next \\n                group_num += 1 \\n            end_joint = end.next \\n            if group_num % 2 != 0: \\n                start_joint = end \\n                continue \\n            start_joint.next = self.reverse(start, end, end_joint)\\n            start_joint = start \\n        return head\\n    def reverse(self, start, end, end_joint): \\n        prev, curr = end_joint, start\\n        while curr and curr != end_joint: \\n            next_node = curr.next\\n            curr.next = prev\\n            prev, curr = curr, next_node\\n        return prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577126,
                "title": "java-recursion-well-commented",
                "content": "very similar to \\n* https://leetcode.com/problems/reverse-nodes-in-k-group/\\n\\n```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // passing head and current group length\\n\\t\\treturn helper(head, 1);\\n    }\\n    \\n    public ListNode helper(ListNode head, int curr_grp){\\n        if(head == null) return head;\\n        ListNode curr = head, save = null;\\n\\t\\t// \"check\" for the last group when curr == null and we have to decide\\n\\t\\t//  whether to reverse the group or not\\n        int temp = curr_grp, check = 1;\\n        ListNode reverse_head = null;\\n        while(temp > 1){\\n            curr = curr.next;\\n            if(curr == null){\\n                if(check % 2 == 0)\\n                    return reverse(head);\\n                return head;\\n            }\\n            check++;\\n            temp--;\\n        }\\n        save = curr.next;\\n        curr.next = null;\\n        ListNode rec_ = helper(save, curr_grp + 1);\\n        if(curr != null && (curr_grp % 2) == 0){    // reversing this group\\n            reverse_head = reverse(head);\\n            head.next = rec_;\\n            return reverse_head;\\n        }\\n        curr.next = rec_;    // odd length so not required\\n        return head;\\n    }\\n\\t// reverse\\n    public ListNode reverse(ListNode head){\\n        ListNode prev = null;\\n        ListNode curr = head, frwd = curr;\\n        while(curr != null){\\n            frwd = frwd.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = frwd;\\n        }\\n        return prev;\\n    }\\n}\\n//    i was able to do this just a minute before the contest ends but then i realised i had a\\n//    penalty of 5 minutes so didn\\'t got submitted :(",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // passing head and current group length\\n\\t\\treturn helper(head, 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1576946,
                "title": "c-recursion",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode *rev(ListNode* head, int &len, int k){\\n        if(head==NULL) return head;\\n        \\n        ListNode *nextHead; // head node of next group\\n\\t\\tListNode* prevNextHead; // last node of current group\\n        nextHead=head, prevNextHead=nextHead;\\n\\t\\t\\n        for(int i=0;i<k;i++){\\n            prevNextHead=nextHead;\\n            nextHead=nextHead->next;\\n        }\\n        len-=k;\\n        \\n        ListNode *newHead=rev(nextHead,len,min(k+1,len)); // for edge cases like: [0,4,2,1,3] --> [0,2,4,3,1], we need to pass on length of next group accordingly\\n        \\n        ListNode *p, *q;\\n        p=head, q=NULL;\\n        if(k%2==0){ // if length is even, we need to reverse the links of current group\\n            while(p!=nextHead){\\n                ListNode* on=p->next;\\n                p->next=q;\\n                q=p;\\n                p=on;\\n            }\\n        }\\n        if(k%2==0){\\n            head->next=newHead; // as we have reversed the links, initial head node is now last node for the group \\n        }else{\\n            prevNextHead->next=newHead;\\n        }\\n        return (k%2==0 ? q:head);\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head==NULL || head->next==NULL) return head;\\n        \\n        ListNode* p=head;\\n        int len=1;\\n        while(p->next!=NULL){\\n            p=p->next;\\n            len++;\\n        }\\n        \\n        return rev(head,len,1);\\n    }\\n};\\n```\\n\\n**Do Upvote if it helps**",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode *rev(ListNode* head, int &len, int k){\\n        if(head==NULL) return head;\\n        \\n        ListNode *nextHead; // head node of next group\\n\\t\\tListNode* prevNextHead; // last node of current group\\n        nextHead=head, prevNextHead=nextHead;\\n\\t\\t\\n        for(int i=0;i<k;i++){\\n            prevNextHead=nextHead;\\n            nextHead=nextHead->next;\\n        }\\n        len-=k;\\n        \\n        ListNode *newHead=rev(nextHead,len,min(k+1,len)); // for edge cases like: [0,4,2,1,3] --> [0,2,4,3,1], we need to pass on length of next group accordingly\\n        \\n        ListNode *p, *q;\\n        p=head, q=NULL;\\n        if(k%2==0){ // if length is even, we need to reverse the links of current group\\n            while(p!=nextHead){\\n                ListNode* on=p->next;\\n                p->next=q;\\n                q=p;\\n                p=on;\\n            }\\n        }\\n        if(k%2==0){\\n            head->next=newHead; // as we have reversed the links, initial head node is now last node for the group \\n        }else{\\n            prevNextHead->next=newHead;\\n        }\\n        return (k%2==0 ? q:head);\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head==NULL || head->next==NULL) return head;\\n        \\n        ListNode* p=head;\\n        int len=1;\\n        while(p->next!=NULL){\\n            p=p->next;\\n            len++;\\n        }\\n        \\n        return rev(head,len,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183665,
                "title": "javascript-solution-iterative-approach",
                "content": "```\\nvar reverseEvenLengthGroups = function(head) {\\n    let groupSize = 2;\\n\\n    let start = head;\\n\\n    let prev = head;\\n    let curr = head.next;\\n\\n    let count = 0;\\n    \\n    while (curr != null) {\\n        if (count === groupSize) {\\n            if (groupSize % 2 === 0) { // we only reverse when it is even\\n                const end = curr;\\n                const tail = start.next; // the starting node of the reverse linked list will be the tail after the reverse takes place\\n                reverseList(start, end, count); // we need to reverse everything in the middle of start and end \\n                start = tail; // we set the new start to the end of the reversed linked list\\n            }\\n            else { // when groupSize is even we don\\'t need to reverse, but need to set the new start to the prev node\\n                start = prev;\\n            }\\n            count = 0; // whenever we reached the group size we need to reset our count and up our groupSize\\n            ++groupSize;\\n        }\\n        else { // just a normal traversal when we haven\\'t hit our groupSize\\n            prev = curr;        \\n            curr = curr.next;\\n            ++count;\\n        }\\n    }\\n   \\n    if (count % 2 === 0) { // in the case where we ended early on even count\\n         reverseList(start, null, count);\\n    }\\n    \\n    return head;\\n    \\n    \\n    function reverseList(start, end, count) {\\n        if (start.next == null) return start; // for case when we have a single node\\n        \\n        let prev = start;\\n        \\n        let curr = start.next;\\n        let tail = start.next;\\n        \\n        for (let i = 0; i < count; ++i) {\\n            const next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        start.next = prev;\\n        tail.next = end;\\n        \\n        return ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nvar reverseEvenLengthGroups = function(head) {\\n    let groupSize = 2;\\n\\n    let start = head;\\n\\n    let prev = head;\\n    let curr = head.next;\\n\\n    let count = 0;\\n    \\n    while (curr != null) {\\n        if (count === groupSize) {\\n            if (groupSize % 2 === 0) { // we only reverse when it is even\\n                const end = curr;\\n                const tail = start.next; // the starting node of the reverse linked list will be the tail after the reverse takes place\\n                reverseList(start, end, count); // we need to reverse everything in the middle of start and end \\n                start = tail; // we set the new start to the end of the reversed linked list\\n            }\\n            else { // when groupSize is even we don\\'t need to reverse, but need to set the new start to the prev node\\n                start = prev;\\n            }\\n            count = 0; // whenever we reached the group size we need to reset our count and up our groupSize\\n            ++groupSize;\\n        }\\n        else { // just a normal traversal when we haven\\'t hit our groupSize\\n            prev = curr;        \\n            curr = curr.next;\\n            ++count;\\n        }\\n    }\\n   \\n    if (count % 2 === 0) { // in the case where we ended early on even count\\n         reverseList(start, null, count);\\n    }\\n    \\n    return head;\\n    \\n    \\n    function reverseList(start, end, count) {\\n        if (start.next == null) return start; // for case when we have a single node\\n        \\n        let prev = start;\\n        \\n        let curr = start.next;\\n        let tail = start.next;\\n        \\n        for (let i = 0; i < count; ++i) {\\n            const next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        start.next = prev;\\n        tail.next = end;\\n        \\n        return ;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576971,
                "title": "python-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        group = 2\\n        tail = head # tail of previous group\\n        while tail and tail.next:\\n            cnt = 1 # actual size of the current group\\n            cur = tail.next # first node of the current group\\n            while cur.next and cnt < group:\\n                cur = cur.next\\n                cnt += 1\\n            pre, cur = tail, tail.next\\n            if cnt % 2 == 0: # if group size is even \\n                while cnt and cur:\\n                    nxt = cur.next\\n                    cur.next = pre\\n                    pre = cur\\n                    cur = nxt\\n                    cnt -= 1\\n                first = tail.next # first node of the original group\\n                first.next = cur\\n                tail.next = pre\\n                tail = first\\n            else:\\n                while cnt and cur:\\n                    pre, cur = cur, cur.next\\n                    cnt -= 1\\n                tail = pre\\n            group += 1\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        group = 2\\n        tail = head # tail of previous group\\n        while tail and tail.next:\\n            cnt = 1 # actual size of the current group\\n            cur = tail.next # first node of the current group\\n            while cur.next and cnt < group:\\n                cur = cur.next\\n                cnt += 1\\n            pre, cur = tail, tail.next\\n            if cnt % 2 == 0: # if group size is even \\n                while cnt and cur:\\n                    nxt = cur.next\\n                    cur.next = pre\\n                    pre = cur\\n                    cur = nxt\\n                    cnt -= 1\\n                first = tail.next # first node of the original group\\n                first.next = cur\\n                tail.next = pre\\n                tail = first\\n            else:\\n                while cnt and cur:\\n                    pre, cur = cur, cur.next\\n                    cnt -= 1\\n                tail = pre\\n            group += 1\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576942,
                "title": "c-solution-put-nodes-into-an-array",
                "content": "\\n\\nIf length of group nodes is even then reverse this group in the arr, and then re-construct the List.\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<ListNode*> arr;\\n        auto node = head;\\n        while(node) {\\n            arr.push_back(node);\\n            node = node->next;\\n        }\\n        int idx = 0;\\n        int cnt = 1;\\n        while(idx < arr.size()) {\\n            int offset = min(idx + cnt, (int)arr.size());\\n            if((offset - idx) % 2 == 0)\\n                reverse(arr.begin() + idx, arr.begin() + offset);\\n            idx += cnt;\\n            ++cnt;\\n        }\\n        for(int i = 1; i < arr.size(); i++) {\\n            arr[i - 1]->next = arr[i];\\n        }\\n        arr.back()->next = NULL;\\n        return arr[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<ListNode*> arr;\\n        auto node = head;\\n        while(node) {\\n            arr.push_back(node);\\n            node = node->next;\\n        }\\n        int idx = 0;\\n        int cnt = 1;\\n        while(idx < arr.size()) {\\n            int offset = min(idx + cnt, (int)arr.size());\\n            if((offset - idx) % 2 == 0)\\n                reverse(arr.begin() + idx, arr.begin() + offset);\\n            idx += cnt;\\n            ++cnt;\\n        }\\n        for(int i = 1; i < arr.size(); i++) {\\n            arr[i - 1]->next = arr[i];\\n        }\\n        arr.back()->next = NULL;\\n        return arr[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660389,
                "title": "c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseEvenLengthGroups(head, 1);\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head, int k) {\\n        \\n        if (head == NULL)\\n            return NULL;\\n        \\n        int count = 0;\\n        ListNode *cNode = NULL, *nNode = NULL, *pNode = NULL;\\n        \\n        for (count = 0, cNode = head; count < k && cNode != NULL; ++count)\\n            cNode = cNode->next;\\n        \\n        if (count % 2 == 1) {\\n            for (cNode = head; count > 0; --count) {\\n                pNode = cNode;\\n                cNode = cNode->next;\\n            }\\n            \\n            pNode->next = reverseEvenLengthGroups(cNode, k+1);\\n            \\n            return head;\\n        } else {\\n        \\n            for (cNode = head; count > 0; --count) {\\n                nNode = cNode->next;\\n                cNode->next = pNode;\\n                pNode = cNode;\\n                cNode = nNode;\\n            }\\n            \\n            head->next = reverseEvenLengthGroups(cNode, k+1);\\n            \\n            return pNode;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseEvenLengthGroups(head, 1);\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head, int k) {\\n        \\n        if (head == NULL)\\n            return NULL;\\n        \\n        int count = 0;\\n        ListNode *cNode = NULL, *nNode = NULL, *pNode = NULL;\\n        \\n        for (count = 0, cNode = head; count < k && cNode != NULL; ++count)\\n            cNode = cNode->next;\\n        \\n        if (count % 2 == 1) {\\n            for (cNode = head; count > 0; --count) {\\n                pNode = cNode;\\n                cNode = cNode->next;\\n            }\\n            \\n            pNode->next = reverseEvenLengthGroups(cNode, k+1);\\n            \\n            return head;\\n        } else {\\n        \\n            for (cNode = head; count > 0; --count) {\\n                nNode = cNode->next;\\n                cNode->next = pNode;\\n                pNode = cNode;\\n                cNode = nNode;\\n            }\\n            \\n            head->next = reverseEvenLengthGroups(cNode, k+1);\\n            \\n            return pNode;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577114,
                "title": "c-vector-solution",
                "content": "**Create Vector from linked list : O(n)\\nDo operations on vector : O(n)\\nCreate linked list from vector : O(n)\\n3*O(n) :\\nOverall Time : O(n)\\nSpace : O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<int> res, ans;\\n        while(head != nullptr)\\n        {\\n            res.push_back(head->val);\\n            head=head->next;\\n        }\\n        \\n        int c=1;\\n        for(int i=0; i<res.size(); i+=c-1)\\n        {\\n            vector<int> temp;\\n            int j=i, co=c;\\n            while(co-- && j<res.size())\\n            {\\n                temp.push_back(res[j]);\\n                j++;\\n            }\\n            if(temp.size()%2==0)\\n                reverse(temp.begin(), temp.end());\\n            ans.insert(ans.end(), temp.begin(), temp.end());\\n            c++;\\n        }\\n        \\n        ListNode* ptr = new ListNode(ans[0]);\\n        ListNode* h = ptr;\\n        \\n        for(int i=1; i<ans.size(); i++)\\n        {\\n            ListNode* node = new ListNode(ans[i]);\\n            ptr->next = node;\\n            ptr = node;\\n        }\\n        \\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<int> res, ans;\\n        while(head != nullptr)\\n        {\\n            res.push_back(head->val);\\n            head=head->next;\\n        }\\n        \\n        int c=1;\\n        for(int i=0; i<res.size(); i+=c-1)\\n        {\\n            vector<int> temp;\\n            int j=i, co=c;\\n            while(co-- && j<res.size())\\n            {\\n                temp.push_back(res[j]);\\n                j++;\\n            }\\n            if(temp.size()%2==0)\\n                reverse(temp.begin(), temp.end());\\n            ans.insert(ans.end(), temp.begin(), temp.end());\\n            c++;\\n        }\\n        \\n        ListNode* ptr = new ListNode(ans[0]);\\n        ListNode* h = ptr;\\n        \\n        for(int i=1; i<ans.size(); i++)\\n        {\\n            ListNode* node = new ListNode(ans[i]);\\n            ptr->next = node;\\n            ptr = node;\\n        }\\n        \\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576979,
                "title": "c-2074-reverse-nodes-in-even-length-groups",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int n = 0; \\n        for (ListNode* node = head; node; node = node->next, ++n); \\n        \\n        ListNode* node = head; \\n        for (int k = 1; n; ++k) {\\n            int size = min(k, n); \\n            stack<int> stk; \\n            if (size % 2 == 0) {\\n                ListNode* temp = node; \\n                for (int i = 0; i < size; ++i) {\\n                    stk.push(temp->val); \\n                    temp = temp->next; \\n                }\\n            }\\n            for (int i = 0; i < size; ++i) {\\n                if (stk.size()) node->val = stk.top(), stk.pop(); \\n                node = node->next; \\n            }\\n            n -= size; \\n        }\\n        return head; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int n = 0; \\n        for (ListNode* node = head; node; node = node->next, ++n); \\n        \\n        ListNode* node = head; \\n        for (int k = 1; n; ++k) {\\n            int size = min(k, n); \\n            stack<int> stk; \\n            if (size % 2 == 0) {\\n                ListNode* temp = node; \\n                for (int i = 0; i < size; ++i) {\\n                    stk.push(temp->val); \\n                    temp = temp->next; \\n                }\\n            }\\n            for (int i = 0; i < size; ++i) {\\n                if (stk.size()) node->val = stk.top(), stk.pop(); \\n                node = node->next; \\n            }\\n            n -= size; \\n        }\\n        return head; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576917,
                "title": "c-two-pass",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Two Pass\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/reverse-nodes-in-even-length-groups/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    int getLength(ListNode *head) {\\n        int len = 0;\\n        for (; head; head = head->next) ++len;\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode dummy, *tail = &dummy;\\n        for (int i = 0, total = getLength(head); head; ++i) {\\n            int len = min(total, i + 1); // the length of the current section\\n            ListNode *newTail = NULL; // The new tail if we need to reverse the current section\\n            for (int j = 0; j < len && head; ++j) {\\n                auto p = head;\\n                head = head->next;\\n                if (len % 2) { // direct append\\n                    tail->next = p;\\n                    tail = p;\\n                } else { // append in reverse order\\n                    if (newTail == NULL) newTail = p;\\n                    p->next = tail->next; \\n                    tail->next = p;\\n                }\\n            }\\n            if (newTail) tail = newTail;\\n            tail->next = NULL;\\n            total -= len;\\n        }\\n        return dummy.next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/reverse-nodes-in-even-length-groups/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    int getLength(ListNode *head) {\\n        int len = 0;\\n        for (; head; head = head->next) ++len;\\n        return len;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode dummy, *tail = &dummy;\\n        for (int i = 0, total = getLength(head); head; ++i) {\\n            int len = min(total, i + 1); // the length of the current section\\n            ListNode *newTail = NULL; // The new tail if we need to reverse the current section\\n            for (int j = 0; j < len && head; ++j) {\\n                auto p = head;\\n                head = head->next;\\n                if (len % 2) { // direct append\\n                    tail->next = p;\\n                    tail = p;\\n                } else { // append in reverse order\\n                    if (newTail == NULL) newTail = p;\\n                    p->next = tail->next; \\n                    tail->next = p;\\n                }\\n            }\\n            if (newTail) tail = newTail;\\n            tail->next = NULL;\\n            total -= len;\\n        }\\n        return dummy.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862614,
                "title": "best-c-solution-simple-approach-with-comments-beats-100",
                "content": "\\n\\n\\n### - Time complexity: O(N)\\n\\n### - Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Reverse function\\n    ListNode* reverse(ListNode* head) {\\n        if(head == NULL)\\n            return head;\\n        \\n        ListNode* prev = NULL, *forward = NULL;\\n        while(head != NULL) {\\n            forward = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = forward;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* dummy = new ListNode(), *prev = dummy;\\n        dummy->next = head;\\n        \\n        // Step 1 - determine the length of groups\\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head, *nextHead;\\n            \\n            // Determining the length of the current group\\n            // Its maximum length can be equal to len\\n            int j = 1;\\n            while(j < len && tail != NULL && tail->next != NULL) {\\n                tail = tail->next;\\n                j++;\\n            }\\n            \\n            // Head of the next group\\n            nextHead = tail->next;\\n            if((j % 2) == 0) {\\n                // If group size is even then reverse the group and set prev and head\\n                tail->next = NULL;\\n                prev->next = reverse(head);\\n                prev = head;\\n                head->next = nextHead;\\n                head = nextHead;\\n            }\\n            else {     // If group is odd sized then simply go to the next group\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Reverse function\\n    ListNode* reverse(ListNode* head) {\\n        if(head == NULL)\\n            return head;\\n        \\n        ListNode* prev = NULL, *forward = NULL;\\n        while(head != NULL) {\\n            forward = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = forward;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* dummy = new ListNode(), *prev = dummy;\\n        dummy->next = head;\\n        \\n        // Step 1 - determine the length of groups\\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head, *nextHead;\\n            \\n            // Determining the length of the current group\\n            // Its maximum length can be equal to len\\n            int j = 1;\\n            while(j < len && tail != NULL && tail->next != NULL) {\\n                tail = tail->next;\\n                j++;\\n            }\\n            \\n            // Head of the next group\\n            nextHead = tail->next;\\n            if((j % 2) == 0) {\\n                // If group size is even then reverse the group and set prev and head\\n                tail->next = NULL;\\n                prev->next = reverse(head);\\n                prev = head;\\n                head->next = nextHead;\\n                head = nextHead;\\n            }\\n            else {     // If group is odd sized then simply go to the next group\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651408,
                "title": "python-c-faster-than-90-easy-implementation-clean-concise-code",
                "content": "# Approach\\n```txt\\nk = odd\\ndummy -> 1 -> || 2 -> 3 -> 4 || -> 5 -> 6 -> 7\\n       grpPrev            kth  grpNxt   --> No Reverse \\n```\\n```txt\\nk = even\\ndummy -> 1 -> || 2 -> 3 -> 4 -> 5 || -> 6 -> 7\\n        grpPrev                kth   grpNxt  --> Reverse \\n```\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```python []\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n\\n    def getKth(self, cur, k):\\n        cnt = k\\n        while cur and cur.next and  k > 0:\\n            cur = cur.next\\n            k -= 1\\n        return [cur, cnt - k]\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(0, head)\\n        groupPrev = dummy\\n\\n        k = 1\\n        while groupPrev and groupPrev.next:\\n            kth, newK = self.getKth(groupPrev, k)\\n            k = newK\\n            groupNext = kth.next\\n\\n            if k%2:\\n                groupPrev = kth\\n            else:\\n                prev, curr = kth.next, groupPrev.next\\n                while curr and curr != groupNext:\\n                    # storing for future use\\n                    nxt = curr.next\\n\\n                    # pointing to the prev ptr\\n                    curr.next = prev\\n\\n                    # updating the ptr\\'s\\n                    prev = curr\\n                    curr = nxt\\n                tmp = groupPrev.next\\n                groupPrev.next = kth\\n                groupPrev = tmp\\n            k += 1\\n        return dummy.next\\n\\n\\n```\\n```C++ []\\n\\nclass Solution {\\npublic:\\n\\n\\nvoid swap(ListNode* A, ListNode* B)\\n{\\n    int tmp = A->val;\\n    A->val = B->val;\\n    B->val = tmp;\\n}\\n\\nvoid reverse_node(vector<ListNode*> &arr)\\n{\\n    int i = 0, j = arr.size()-1;\\n\\n    while(i<=j) swap(arr[i++], arr[j--]);\\n    \\n}\\n\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<ListNode*>res;\\n        int i = 1;\\n        int cnt = 0;\\n        \\n        ListNode *ptr = head;\\n\\n        while(ptr != NULL)\\n        {\\n           \\n           res.push_back(ptr);\\n           ptr = ptr->next;\\n           cnt++;\\n\\n           if(cnt == i)\\n           {\\n               if(cnt % 2 == 0) reverse_node(res);\\n               res.clear();\\n               cnt = 0;\\n               i++;\\n           }\\n\\n        }\\n\\n        if(cnt%2 == 0) reverse_node(res);\\n\\n\\n        return head;\\n\\n    }\\n};\\n\\n```\\n\\nYou Can also Look At My SDE Prep Repo [\\uD83E\\uDDE2 GitHub](https://github.com/Ayon-SSP/The-SDE-Prep)\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```txt\\nk = odd\\ndummy -> 1 -> || 2 -> 3 -> 4 || -> 5 -> 6 -> 7\\n       grpPrev            kth  grpNxt   --> No Reverse \\n```\n```txt\\nk = even\\ndummy -> 1 -> || 2 -> 3 -> 4 -> 5 || -> 6 -> 7\\n        grpPrev                kth   grpNxt  --> Reverse \\n```\n```python []\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n\\n    def getKth(self, cur, k):\\n        cnt = k\\n        while cur and cur.next and  k > 0:\\n            cur = cur.next\\n            k -= 1\\n        return [cur, cnt - k]\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(0, head)\\n        groupPrev = dummy\\n\\n        k = 1\\n        while groupPrev and groupPrev.next:\\n            kth, newK = self.getKth(groupPrev, k)\\n            k = newK\\n            groupNext = kth.next\\n\\n            if k%2:\\n                groupPrev = kth\\n            else:\\n                prev, curr = kth.next, groupPrev.next\\n                while curr and curr != groupNext:\\n                    # storing for future use\\n                    nxt = curr.next\\n\\n                    # pointing to the prev ptr\\n                    curr.next = prev\\n\\n                    # updating the ptr\\'s\\n                    prev = curr\\n                    curr = nxt\\n                tmp = groupPrev.next\\n                groupPrev.next = kth\\n                groupPrev = tmp\\n            k += 1\\n        return dummy.next\\n\\n\\n```\n```C++ []\\n\\nclass Solution {\\npublic:\\n\\n\\nvoid swap(ListNode* A, ListNode* B)\\n{\\n    int tmp = A->val;\\n    A->val = B->val;\\n    B->val = tmp;\\n}\\n\\nvoid reverse_node(vector<ListNode*> &arr)\\n{\\n    int i = 0, j = arr.size()-1;\\n\\n    while(i<=j) swap(arr[i++], arr[j--]);\\n    \\n}\\n\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<ListNode*>res;\\n        int i = 1;\\n        int cnt = 0;\\n        \\n        ListNode *ptr = head;\\n\\n        while(ptr != NULL)\\n        {\\n           \\n           res.push_back(ptr);\\n           ptr = ptr->next;\\n           cnt++;\\n\\n           if(cnt == i)\\n           {\\n               if(cnt % 2 == 0) reverse_node(res);\\n               res.clear();\\n               cnt = 0;\\n               i++;\\n           }\\n\\n        }\\n\\n        if(cnt%2 == 0) reverse_node(res);\\n\\n\\n        return head;\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454408,
                "title": "python-3-14-lines-w-example-t-m-97-52",
                "content": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: ListNode) -> ListNode:\\n\\n        node, nums, ans = head, [], []\\n        T = lambda x: x*(x+1)//2\\n        flip = lambda x: x if len(x)%2 else x[::-1]         #  Example: head = 1->5->4->2->6->3->0->8\\n\\n        while node:                                         #    nums = [1,5,4,2,6,3,0,8]\\n            nums.append(node.val)\\n            node = node.next\\n\\n        for i in range(ceil(-0.5+sqrt(0.25+2*len(nums)))):  #     ans = [[1], [5,4], [2,6,3], [0,8]]\\n            ans.append(nums[T(i):T(i+1)])\\n\\n        ans = chain(*map(flip,ans))                         #     ans = chain(*[[1], [4,5], [2,6,3], [8,0]])\\n                                                            #         = chain([1], [4,5], [2,6,3], [8,0])\\n                                                            #         = [1, 4,5, 2,6,3, 8,0]\\n\\n        node = head                                         #    head = 1->4->5->2->6->3->8->0\\n        for a in ans:\\n            node.val  = a\\n            node = node.next\\n\\n        return head\\n```\\n[https://leetcode.com/problems/reverse-nodes-in-even-length-groups/submissions/939576037/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: ListNode) -> ListNode:\\n\\n        node, nums, ans = head, [], []\\n        T = lambda x: x*(x+1)//2\\n        flip = lambda x: x if len(x)%2 else x[::-1]         #  Example: head = 1->5->4->2->6->3->0->8\\n\\n        while node:                                         #    nums = [1,5,4,2,6,3,0,8]\\n            nums.append(node.val)\\n            node = node.next\\n\\n        for i in range(ceil(-0.5+sqrt(0.25+2*len(nums)))):  #     ans = [[1], [5,4], [2,6,3], [0,8]]\\n            ans.append(nums[T(i):T(i+1)])\\n\\n        ans = chain(*map(flip,ans))                         #     ans = chain(*[[1], [4,5], [2,6,3], [8,0]])\\n                                                            #         = chain([1], [4,5], [2,6,3], [8,0])\\n                                                            #         = [1, 4,5, 2,6,3, 8,0]\\n\\n        node = head                                         #    head = 1->4->5->2->6->3->8->0\\n        for a in ans:\\n            node.val  = a\\n            node = node.next\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302693,
                "title": "python-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next or not head.next.next:\\n            return head\\n\\n        dummy = before = nullCheck = head\\n        before = head\\n        count = 1\\n        \\n        while head:\\n            # length check\\n            length = 0\\n            while nullCheck and length < count:\\n                nullCheck = nullCheck.next\\n                length += 1\\n            \\n            # odd length\\n            if length % 2 == 1:\\n                for _ in range(length):\\n                    before = head\\n                    head = head.next\\n            \\n            else:\\n                tail = head\\n\\n                # reverse\\n                prev = None\\n                for _ in range(length):\\n                    nextNode = head.next\\n                    head.next = prev\\n                    prev = head\\n                    head = nextNode\\n                \\n                # join\\n                before.next = prev\\n                before = tail\\n                tail.next = head\\n            \\n            count += 1\\n        \\n        return dummy\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next or not head.next.next:\\n            return head\\n\\n        dummy = before = nullCheck = head\\n        before = head\\n        count = 1\\n        \\n        while head:\\n            # length check\\n            length = 0\\n            while nullCheck and length < count:\\n                nullCheck = nullCheck.next\\n                length += 1\\n            \\n            # odd length\\n            if length % 2 == 1:\\n                for _ in range(length):\\n                    before = head\\n                    head = head.next\\n            \\n            else:\\n                tail = head\\n\\n                # reverse\\n                prev = None\\n                for _ in range(length):\\n                    nextNode = head.next\\n                    head.next = prev\\n                    prev = head\\n                    head = nextNode\\n                \\n                # join\\n                before.next = prev\\n                before = tail\\n                tail.next = head\\n            \\n            count += 1\\n        \\n        return dummy\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982897,
                "title": "c-faster-than-90-easy-implementation-clean-concise-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n\\nvoid swap(ListNode* A, ListNode* B)\\n{\\n    int tmp = A->val;\\n    A->val = B->val;\\n    B->val = tmp;\\n}\\n\\nvoid reverse_node(vector<ListNode*> &arr)\\n{\\n    int i = 0, j = arr.size()-1;\\n\\n    while(i<=j) swap(arr[i++], arr[j--]);\\n    \\n}\\n\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<ListNode*>res;\\n        int i = 1;\\n        int cnt = 0;\\n        \\n        ListNode *ptr = head;\\n\\n        while(ptr != NULL)\\n        {\\n           \\n           res.push_back(ptr);\\n           ptr = ptr->next;\\n           cnt++;\\n\\n           if(cnt == i)\\n           {\\n               if(cnt % 2 == 0) reverse_node(res);\\n               res.clear();\\n               cnt = 0;\\n               i++;\\n           }\\n\\n        }\\n\\n        if(cnt%2 == 0) reverse_node(res);\\n\\n\\n        return head;\\n\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n\\nvoid swap(ListNode* A, ListNode* B)\\n{\\n    int tmp = A->val;\\n    A->val = B->val;\\n    B->val = tmp;\\n}\\n\\nvoid reverse_node(vector<ListNode*> &arr)\\n{\\n    int i = 0, j = arr.size()-1;\\n\\n    while(i<=j) swap(arr[i++], arr[j--]);\\n    \\n}\\n\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        vector<ListNode*>res;\\n        int i = 1;\\n        int cnt = 0;\\n        \\n        ListNode *ptr = head;\\n\\n        while(ptr != NULL)\\n        {\\n           \\n           res.push_back(ptr);\\n           ptr = ptr->next;\\n           cnt++;\\n\\n           if(cnt == i)\\n           {\\n               if(cnt % 2 == 0) reverse_node(res);\\n               res.clear();\\n               cnt = 0;\\n               i++;\\n           }\\n\\n        }\\n\\n        if(cnt%2 == 0) reverse_node(res);\\n\\n\\n        return head;\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724203,
                "title": "c-94-faster-than-all-easy",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head)\\n            return head;\\n        ListNode* prev = NULL;\\n        while(head) {\\n            ListNode* temp = head -> next;\\n            head -> next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        \\n        ListNode* prev = dummy;\\n        \\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            int j = 1;\\n            while(j < len && tail && tail -> next) {\\n                tail = tail -> next;\\n                j++;\\n            }\\n            \\n            nextHead = tail -> next;\\n            \\n            if((j % 2) == 0) {\\n                tail -> next = NULL;\\n                prev -> next = reverseList(head);\\n                prev = head;\\n                head -> next = nextHead;\\n                head = nextHead;\\n            } else {\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(!head)\\n            return head;\\n        ListNode* prev = NULL;\\n        while(head) {\\n            ListNode* temp = head -> next;\\n            head -> next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        \\n        ListNode* prev = dummy;\\n        \\n        for(int len = 1; len < 1e5 && head; len++) {\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            int j = 1;\\n            while(j < len && tail && tail -> next) {\\n                tail = tail -> next;\\n                j++;\\n            }\\n            \\n            nextHead = tail -> next;\\n            \\n            if((j % 2) == 0) {\\n                tail -> next = NULL;\\n                prev -> next = reverseList(head);\\n                prev = head;\\n                head -> next = nextHead;\\n                head = nextHead;\\n            } else {\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534967,
                "title": "java-solution-with-comments-for-better-understanding",
                "content": "```\\npublic ListNode reverseEvenLengthGroups(ListNode head) {\\n        //If there is only one node or only two nodes in the list then list remains unchanged\\n        if(head.next == null || head.next.next == null) return head;\\n        \\n        \\n        //Since group 1 will always have one node\\n        ListNode temp = head;\\n        ListNode prevNode = head;\\n        int group = 1;\\n        \\n        while(temp.next != null){\\n            //Move to the next group\\n            group++;\\n\\n            //Find how many nodes will be in this group. \\n            //Number of nodes cannot exceed group number\\n            int nodes = 0;\\n            while(temp.next != null && nodes < group){\\n                temp = temp.next;\\n                nodes++;\\n            }\\n\\n            //After this loop, temp will be pointing to the last node of this group\\n            ListNode nodeAfterGroup = temp.next;\\n\\n            //If the length of this group is even then reverse this group\\n            if(nodes % 2 == 0){\\n                //Get the list to reverse\\n                ListNode listToReverse = prevNode.next;\\n                ListNode ptr = listToReverse;\\n                while(ptr != temp) ptr = ptr.next;\\n                ptr.next = null;\\n\\n                //Reverse this list\\n                listToReverse = reverse(listToReverse);\\n                ListNode revPtr = listToReverse;\\n                while(revPtr.next != null) revPtr = revPtr.next;\\n\\n                //Attach it back to the original list properly \\n                prevNode.next = listToReverse;\\n                revPtr.next = nodeAfterGroup;\\n                \\n                //Make sure temp now points to the last node of this group after we reversed it.\\n                temp = revPtr;\\n            }\\n                \\n            //Set the previousNode as temp i.e., the node just before the beginning of next group\\n            prevNode = temp;\\n        }\\n        \\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic ListNode reverseEvenLengthGroups(ListNode head) {\\n        //If there is only one node or only two nodes in the list then list remains unchanged\\n        if(head.next == null || head.next.next == null) return head;\\n        \\n        \\n        //Since group 1 will always have one node\\n        ListNode temp = head;\\n        ListNode prevNode = head;\\n        int group = 1;\\n        \\n        while(temp.next != null){\\n            //Move to the next group\\n            group++;\\n\\n            //Find how many nodes will be in this group. \\n            //Number of nodes cannot exceed group number\\n            int nodes = 0;\\n            while(temp.next != null && nodes < group){\\n                temp = temp.next;\\n                nodes++;\\n            }\\n\\n            //After this loop, temp will be pointing to the last node of this group\\n            ListNode nodeAfterGroup = temp.next;\\n\\n            //If the length of this group is even then reverse this group\\n            if(nodes % 2 == 0){\\n                //Get the list to reverse\\n                ListNode listToReverse = prevNode.next;\\n                ListNode ptr = listToReverse;\\n                while(ptr != temp) ptr = ptr.next;\\n                ptr.next = null;\\n\\n                //Reverse this list\\n                listToReverse = reverse(listToReverse);\\n                ListNode revPtr = listToReverse;\\n                while(revPtr.next != null) revPtr = revPtr.next;\\n\\n                //Attach it back to the original list properly \\n                prevNode.next = listToReverse;\\n                revPtr.next = nodeAfterGroup;\\n                \\n                //Make sure temp now points to the last node of this group after we reversed it.\\n                temp = revPtr;\\n            }\\n                \\n            //Set the previousNode as temp i.e., the node just before the beginning of next group\\n            prevNode = temp;\\n        }\\n        \\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2384715,
                "title": "c-iterative-method",
                "content": "This problem is similar as [reverse-nodes-in-k-group](https://leetcode.com/problems/reverse-nodes-in-k-group/) here k vary .\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head)\\n    {\\n        int len=0;  ListNode*cur=head;\\n        while(cur!=NULL)\\n        { len++ ;cur=cur->next;}                                                                                  //count length of linked list\\n        \\n        ListNode* dummy=new ListNode(0) ;\\n\\t\\tListNode *nex=NULL ,*prev=NULL;\\n        dummy->next=head ; prev=dummy;\\n        \\n        int k=1;\\n\\t\\t\\n        while(len>0)\\n        {\\n            cur=prev->next;\\n            nex=cur->next;\\n                                                \\n            if((k%2!=0 && len>=k) || (len<k && len%2!=0))\\n               for(int i=1;i<k && (len-i) ;i++)                                     // no reverse at odd group and if last group is odd\\n                cur=cur->next;\\n            \\n            else if((k%2==0 && len>=k) || (len<k && len%2==0)) \\n                for(int i=1;i<k && (len-i) ;i++)                                // reverse at even group and if last group is even\\n               {\\n                cur->next=nex->next;\\n                nex->next=prev->next;\\n                prev->next=nex;\\n                nex=cur->next;\\n               }\\n            \\n            len-=k;\\n            prev=cur;\\n            k++;\\n        }\\n        return dummy->next;\\n    }\\n};\\nFeel free to ask any doubt in comment section",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head)\\n    {\\n        int len=0;  ListNode*cur=head;\\n        while(cur!=NULL)\\n        { len++ ;cur=cur->next;}",
                "codeTag": "Java"
            },
            {
                "id": 1584154,
                "title": "java-easy-explained-solution-o-n-time-complexity-o-1-space-complexity",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public static ListNode reverse(ListNode head,ListNode last,int len){\\n        while(len>0){\\n            ListNode temp=head.next;\\n            head.next=last;\\n            last=head;\\n            head=temp;\\n            len--;\\n        }\\n        return last;\\n    }\\n    public static int len(ListNode node,int maxlen){\\n        int cnt=0;\\n        while(node.next!=null && maxlen>0){\\n            node=node.next;\\n            cnt++;\\n            maxlen--;\\n        }\\n        return cnt;\\n    }\\n    public static ListNode next(ListNode node,int size){\\n        while(size>0){\\n            node=node.next;\\n            size--;\\n        }\\n        return node;\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        //It is very obvious that we cann\\'t reverse grp of size 1 so head node will not change in modified LinkedList.\\n        int grpno=2;\\n        ListNode res=head;\\n        while(head!=null){\\n            \\n            //Finding the grp length of given grpno bcz it is always not true that grpno == grp length(mainly in last part of LL)\\n            int grplen=len(head,grpno);\\n            \\n            //Find the node ending at the given grplen\\n            ListNode node=next(head,grplen);\\n            \\n            ListNode temp=head.next;\\n            //reverse the grp with grplen even\\n            if(grplen%2==0){\\n                head.next=reverse(head.next,node.next,grplen);\\n                head=temp;\\n            }\\n            else{\\n                head=node;\\n            }\\n            grpno++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public static ListNode reverse(ListNode head,ListNode last,int len){\\n        while(len>0){\\n            ListNode temp=head.next;\\n            head.next=last;\\n            last=head;\\n            head=temp;\\n            len--;\\n        }\\n        return last;\\n    }\\n    public static int len(ListNode node,int maxlen){\\n        int cnt=0;\\n        while(node.next!=null && maxlen>0){\\n            node=node.next;\\n            cnt++;\\n            maxlen--;\\n        }\\n        return cnt;\\n    }\\n    public static ListNode next(ListNode node,int size){\\n        while(size>0){\\n            node=node.next;\\n            size--;\\n        }\\n        return node;\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        //It is very obvious that we cann\\'t reverse grp of size 1 so head node will not change in modified LinkedList.\\n        int grpno=2;\\n        ListNode res=head;\\n        while(head!=null){\\n            \\n            //Finding the grp length of given grpno bcz it is always not true that grpno == grp length(mainly in last part of LL)\\n            int grplen=len(head,grpno);\\n            \\n            //Find the node ending at the given grplen\\n            ListNode node=next(head,grplen);\\n            \\n            ListNode temp=head.next;\\n            //reverse the grp with grplen even\\n            if(grplen%2==0){\\n                head.next=reverse(head.next,node.next,grplen);\\n                head=temp;\\n            }\\n            else{\\n                head=node;\\n            }\\n            grpno++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055037,
                "title": "java-solution-using-arraylist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n\\n    static void reverse(ArrayList<Integer> arr, int i, int j){\\n\\n        while(i<j){\\n            int a = arr.get(i);\\n            arr.set(i,arr.get(j));\\n            arr.set(j,a);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n\\n        if(head.next==null) return head;\\n\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        ListNode t = head;\\n\\n        while(t!=null){\\n            arr.add(t.val);\\n            t=t.next;\\n        }\\n\\n        int prev = 2;\\n        int idx = -1;\\n\\n        for(int i=1; i+prev-1<arr.size();){\\n            reverse(arr,i,i+prev-1);\\n            if(i+2*prev+1>=arr.size()) idx = i+prev;\\n            else{\\n                idx = i+2*prev+1;\\n            }\\n            i=i+2*prev+1;\\n            prev=prev+2;\\n        }\\n\\n        if(arr.size()-idx>0 && (arr.size()-idx)%2==0){\\n            reverse(arr,idx,arr.size()-1);\\n        }\\n\\n        \\n\\n        ListNode ans = new ListNode(-1);\\n        t=ans;\\n        for(int i=0; i<arr.size(); i++){\\n            t.next = new ListNode(arr.get(i));\\n            t=t.next;\\n        }\\n\\n        return ans.next;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n\\n    static void reverse(ArrayList<Integer> arr, int i, int j){\\n\\n        while(i<j){\\n            int a = arr.get(i);\\n            arr.set(i,arr.get(j));\\n            arr.set(j,a);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n\\n        if(head.next==null) return head;\\n\\n        ArrayList<Integer> arr = new ArrayList<>();\\n\\n        ListNode t = head;\\n\\n        while(t!=null){\\n            arr.add(t.val);\\n            t=t.next;\\n        }\\n\\n        int prev = 2;\\n        int idx = -1;\\n\\n        for(int i=1; i+prev-1<arr.size();){\\n            reverse(arr,i,i+prev-1);\\n            if(i+2*prev+1>=arr.size()) idx = i+prev;\\n            else{\\n                idx = i+2*prev+1;\\n            }\\n            i=i+2*prev+1;\\n            prev=prev+2;\\n        }\\n\\n        if(arr.size()-idx>0 && (arr.size()-idx)%2==0){\\n            reverse(arr,idx,arr.size()-1);\\n        }\\n\\n        \\n\\n        ListNode ans = new ListNode(-1);\\n        t=ans;\\n        for(int i=0; i<arr.size(); i++){\\n            t.next = new ListNode(arr.get(i));\\n            t=t.next;\\n        }\\n\\n        return ans.next;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878657,
                "title": "not-so-fast-but-understandable-py",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n****1)First convert linked list to list.\\n\\n2)Then create the temporary list of the desired length like 1,2,3,4...\\n\\n3)Then check if length of temp list is even:\\nif it is even then first reverse it and add it to the ans list\\nelse add temp to ans directly.\\n\\n4)Then we have to check for the remaining elements:\\nlike temp of size 1,2,3 are present but of size 4 is not present, there should be 1,2,3 element remaing in the list.\\n\\n5)so we have to check the no. of remaing element is even then reverse them else add as it is to the ans list.\\n\\n6)Then The final step is to convert the list to linked list again.****\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        l = []\\n        ans = []\\n        while head:\\n            l.append(head.val)\\n            head = head.next\\n\\n        right = 1\\n        left = 0\\n        while left+right<=len(l):\\n            temp = l[left:left+right]\\n            if len(temp)%2==0:\\n                temp = temp[::-1]\\n                ans+= temp\\n            else:\\n                ans+= temp\\n            left+=right\\n            right+=1\\n\\n        remain = len(l)-len(ans)\\n        temp2=[]\\n        if remain%2==0:\\n            for i in range(-remain,0,1):\\n                temp2.append(l[i])\\n            ans+=temp2[::-1]\\n        else:    \\n            for i in range(-remain,0,1):\\n                ans.append(l[i])\\n\\n\\n        head=temp=ListNode(ans[0])\\n        for i in range(1,len(ans)):\\n            temp.next = ListNode(ans[i])\\n            temp = temp.next\\n        return head\\n\\n\\n        \\n```\\n**IF YOU LIKE IT PLEASE UPVOTE :))**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        l = []\\n        ans = []\\n        while head:\\n            l.append(head.val)\\n            head = head.next\\n\\n        right = 1\\n        left = 0\\n        while left+right<=len(l):\\n            temp = l[left:left+right]\\n            if len(temp)%2==0:\\n                temp = temp[::-1]\\n                ans+= temp\\n            else:\\n                ans+= temp\\n            left+=right\\n            right+=1\\n\\n        remain = len(l)-len(ans)\\n        temp2=[]\\n        if remain%2==0:\\n            for i in range(-remain,0,1):\\n                temp2.append(l[i])\\n            ans+=temp2[::-1]\\n        else:    \\n            for i in range(-remain,0,1):\\n                ans.append(l[i])\\n\\n\\n        head=temp=ListNode(ans[0])\\n        for i in range(1,len(ans)):\\n            temp.next = ListNode(ans[i])\\n            temp = temp.next\\n        return head\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718294,
                "title": "efficient-approach-reverse-even-length-groups-optimal-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code uses a recursive approach to reverse even-length groups of nodes in a linked list. It iterates through the list, reversing each group individually. The time complexity is O(n), and the space complexity is O(n) due to the recursive calls.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If the head is NULL or there\\'s only one node, return the head.\\n- Initialize count to 0.\\n- If the group\\'s length is even and there are enough remaining nodes, or if n is less than or equal to k and n is even, reverse the group.\\n- Within a loop, reverse the links between nodes by updating pointers.\\n- Recursively update head->next and return the reversed group\\'s head.\\n- If the group\\'s length is odd or there are fewer remaining nodes, update pointers without reversing.\\n- Recursively update prev->next and return the original head.\\n- Calculate the total number of nodes.\\n- Call the recursive function with initial parameters.\\n- Return the modified linked list.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is **O(n)** as each node is visited once. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is **O(n)** due to the recursive calls, with a maximum depth of n/2.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reveven(ListNode* head, int k, int& n){\\n        if(head==NULL|| head->next == NULL) return head;\\n        int count = 0;\\n        if((k%2 == 0 && n>=k) || (n<=k && n%2 == 0)){\\n            ListNode* curr = head;\\n            ListNode* prev = NULL;\\n            ListNode* nextt = NULL;\\n            while(count < k && curr!= NULL){\\n                nextt = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = nextt;\\n                count++;\\n                n--;\\n            }\\n            head->next = reveven(curr,k+1,n);\\n            return prev;\\n        }\\n        else{\\n            ListNode* curr = head;\\n            ListNode* prev = NULL;\\n            while(count < k && curr!= NULL){\\n                prev = curr;\\n                curr = curr->next;\\n                count++;\\n                n--;\\n            }\\n            prev->next = reveven(curr,k+1,n);\\n            return head;\\n        }\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head==NULL) return head;\\n        int n = 0;\\n        ListNode* temp = head;\\n        while(temp!=NULL){\\n            temp= temp->next;\\n            n++;\\n        }\\n\\n        return reveven(head, 1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reveven(ListNode* head, int k, int& n){\\n        if(head==NULL|| head->next == NULL) return head;\\n        int count = 0;\\n        if((k%2 == 0 && n>=k) || (n<=k && n%2 == 0)){\\n            ListNode* curr = head;\\n            ListNode* prev = NULL;\\n            ListNode* nextt = NULL;\\n            while(count < k && curr!= NULL){\\n                nextt = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = nextt;\\n                count++;\\n                n--;\\n            }\\n            head->next = reveven(curr,k+1,n);\\n            return prev;\\n        }\\n        else{\\n            ListNode* curr = head;\\n            ListNode* prev = NULL;\\n            while(count < k && curr!= NULL){\\n                prev = curr;\\n                curr = curr->next;\\n                count++;\\n                n--;\\n            }\\n            prev->next = reveven(curr,k+1,n);\\n            return head;\\n        }\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head==NULL) return head;\\n        int n = 0;\\n        ListNode* temp = head;\\n        while(temp!=NULL){\\n            temp= temp->next;\\n            n++;\\n        }\\n\\n        return reveven(head, 1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578732,
                "title": "python-solution-use-4-pointers-with-clear-explanation",
                "content": "This solution was inspired by @astroash\\'s C++ solution, which can be found at https://leetcode.com/problems/reverse-nodes-in-even-length-groups/solutions/1576952/c-well-commented-clear-code-idea-explained-in-brief/. \\nThis is an implementation of the same solution in Python. The key aspects of this solution will be outlined in this post, with emphasis on the major features and the steps taken to solve the problem.\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is essentially a variant of the \\'partial reverse linked list\\' problem, where we only reverse parts of the linked list based on some criteria. In this case, we reverse parts of the linked list that fall into groups of even lengths. Key points in solving this type of problem include:\\n\\n1. Identify the **pattern** of the specific part of the linked list that needs to be reversed and divide it into groups.\\n2. Understand the role of the **prev**, **head**, **tail**, and **next_head** pointers:\\n   - **prev** refers to the node **before** the pattern group. It links the reversed group back to the unmodified part of the list.\\n   - **head** refers to the **start** of the pattern group, which becomes the tail after the group is reversed.\\n   - **tail** refers to the **end** of the pattern group, which becomes the head after the group is reversed.\\n   - **next_head** refers to the **start** of the next group. It links the reversed group to the next part of the list.\\n3. Deal with **edge** conditions. A sentinel node is useful in dealing with edge conditions that may occur at the head or end of the linked list.\\n\\n# Approach\\n![\\u672A\\u547D\\u540D\\u6587\\u4EF6 (16).png](https://assets.leetcode.com/users/images/55cbcf64-5288-4bd4-bceb-a0963d00a90e_1685449691.6244676.png)\\n\\nWe first segment the linked list into different groups based on the provided conditions. We then check each group and reverse it if its length is even. The reversal is achieved using the prev, head, tail, and next_head pointers.\\n\\n1. We define a helper function, `reverse()`, that reverses a linked list from a specified head node and returns the head of the reversed list.\\n2. We create a sentinel node that will aid in handling edge conditions. It also simplifies our code by providing a uniform starting point for each group.\\n3. For each length from 1 to 100000, we manually segment the linked list into groups. For each group, we identify the head, tail, and next_head nodes.\\n4. We check if the group is of even length. If it is, we reverse it by calling our `reverse()` function, and then link the reversed group back to the list.\\n\\n# Complexity\\n\\n- Time complexity: O(n), where n is the number of nodes in the linked list.\\n- Space complexity: O(1), because no additional space is used apart from the original linked list.\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def reverse(head):\\n            if not head:\\n                return head\\n            prev = None\\n            while head:\\n                next_node = head.next\\n                head.next = prev\\n                prev = head\\n                head = next_node\\n            return prev\\n\\n        sentinel = ListNode(0, head)\\n        prev = sentinel\\n        for length in range(1, 100000):\\n            if not head:\\n                break\\n            tail = head\\n            j = 1\\n            while j < length and tail and tail.next:\\n                tail = tail.next\\n                j += 1\\n\\n            next_head = tail.next\\n\\n            if j % 2 == 0:\\n                tail.next = None\\n                prev.next = reverse(head)\\n                head.next = next_head\\n                prev = head\\n                head = next_head\\n            else:\\n                prev = tail\\n                head = next_head\\n\\n        return sentinel.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def reverse(head):\\n            if not head:\\n                return head\\n            prev = None\\n            while head:\\n                next_node = head.next\\n                head.next = prev\\n                prev = head\\n                head = next_node\\n            return prev\\n\\n        sentinel = ListNode(0, head)\\n        prev = sentinel\\n        for length in range(1, 100000):\\n            if not head:\\n                break\\n            tail = head\\n            j = 1\\n            while j < length and tail and tail.next:\\n                tail = tail.next\\n                j += 1\\n\\n            next_head = tail.next\\n\\n            if j % 2 == 0:\\n                tail.next = None\\n                prev.next = reverse(head)\\n                head.next = next_head\\n                prev = head\\n                head = next_head\\n            else:\\n                prev = tail\\n                head = next_head\\n\\n        return sentinel.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287091,
                "title": "simple-c-solution-faster-than-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *cur=head,*prev=NULL;\\n        int count=0;\\n        while(cur){\\n            count++;\\n            cur=cur->next;\\n        }\\n        cur=head;\\n        int grpNo=1;\\n        while(cur && grpNo<=count){\\n            int x=grpNo;\\n            while(cur && x){\\n                prev=cur;\\n                cur=cur->next;\\n                x--;\\n            }\\n            count-=grpNo;\\n            grpNo++;\\n            if(cur && grpNo<=count){\\n                ListNode *nxt;\\n                x=grpNo;\\n                while(cur->next && x-1>0){\\n                    nxt=cur->next;\\n                    cur->next=nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                    x--;\\n                }\\n                prev=cur;\\n                cur=cur->next;\\n                count-=grpNo;\\n                grpNo++;\\n            }\\n            else\\n                break;\\n        }\\n        if(count && count%2==0){\\n            ListNode *nxt;\\n                int x=count;\\n                while(cur->next && x-1>0){\\n                    nxt=cur->next;\\n                    cur->next=nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                    x--;\\n                }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *cur=head,*prev=NULL;\\n        int count=0;\\n        while(cur){\\n            count++;\\n            cur=cur->next;\\n        }\\n        cur=head;\\n        int grpNo=1;\\n        while(cur && grpNo<=count){\\n            int x=grpNo;\\n            while(cur && x){\\n                prev=cur;\\n                cur=cur->next;\\n                x--;\\n            }\\n            count-=grpNo;\\n            grpNo++;\\n            if(cur && grpNo<=count){\\n                ListNode *nxt;\\n                x=grpNo;\\n                while(cur->next && x-1>0){\\n                    nxt=cur->next;\\n                    cur->next=nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                    x--;\\n                }\\n                prev=cur;\\n                cur=cur->next;\\n                count-=grpNo;\\n                grpNo++;\\n            }\\n            else\\n                break;\\n        }\\n        if(count && count%2==0){\\n            ListNode *nxt;\\n                int x=count;\\n                while(cur->next && x-1>0){\\n                    nxt=cur->next;\\n                    cur->next=nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                    x--;\\n                }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143164,
                "title": "o-n-java-solutions-beats-97",
                "content": "# Approach\\nUse sliding window idea by keeping track of last node (of previous group), left node (of current group), pointer node (traverse list), groupSize, count of nodes in current group.\\n\\nOnce you start iterating, you will have to reverse current group if it meets the 2 conditions.\\n1. Count == groupSize\\n2. groupSize is even\\n\\nYou reverse and connect the reversed list back to your main list. Then you must update your iteration pointer since it will be in the back of the reversed list.\\n\\nAlso update last seen node (of previous group), new left node, count, and groupsize.\\n\\nDo the same reverse for the remaining nodes.\\n\\n# Complexity\\n- Time complexity:\\nO(N): One iteration of list is done.\\n\\n- Space complexity:\\nO(1): Constant # of variables/pointers\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null) return head;\\n\\n        int groupSize = 1;\\n        int count = 0;\\n        ListNode left = null;\\n        ListNode ptr = head;\\n        ListNode last = null;\\n        \\n        while(ptr != null) {\\n            count++;\\n            if(count == groupSize) {\\n                if(groupSize  % 2 == 0) {\\n                    ListNode end = ptr.next;\\n                   // reverse\\n                    ListNode cur = left;\\n                    ListNode next = null;\\n                    ListNode prev = ptr.next;\\n                    while(cur != end) {\\n                        next = cur.next;\\n                        cur.next = prev;\\n                        prev = cur;\\n                        cur = next;\\n                    }\\n                    // connect\\n                    last.next = prev;\\n                    ptr = left;\\n                   \\n                }\\n                last = ptr;\\n                left = ptr.next;\\n                count = 0;\\n                groupSize++;\\n            }\\n            ptr = ptr.next;\\n        }\\n\\n        if(count > 0 && count % 2 == 0) {\\n            // reverse\\n            ListNode cur = left;\\n            ListNode next = null;\\n            ListNode prev = ptr;\\n\\n            while(cur != null) {\\n                next = cur.next;\\n                cur.next = prev;\\n                prev = cur;\\n                cur = next;\\n            }\\n\\n            last.next = prev;\\n        }\\n\\n        return head;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null) return head;\\n\\n        int groupSize = 1;\\n        int count = 0;\\n        ListNode left = null;\\n        ListNode ptr = head;\\n        ListNode last = null;\\n        \\n        while(ptr != null) {\\n            count++;\\n            if(count == groupSize) {\\n                if(groupSize  % 2 == 0) {\\n                    ListNode end = ptr.next;\\n                   // reverse\\n                    ListNode cur = left;\\n                    ListNode next = null;\\n                    ListNode prev = ptr.next;\\n                    while(cur != end) {\\n                        next = cur.next;\\n                        cur.next = prev;\\n                        prev = cur;\\n                        cur = next;\\n                    }\\n                    // connect\\n                    last.next = prev;\\n                    ptr = left;\\n                   \\n                }\\n                last = ptr;\\n                left = ptr.next;\\n                count = 0;\\n                groupSize++;\\n            }\\n            ptr = ptr.next;\\n        }\\n\\n        if(count > 0 && count % 2 == 0) {\\n            // reverse\\n            ListNode cur = left;\\n            ListNode next = null;\\n            ListNode prev = ptr;\\n\\n            while(cur != null) {\\n                next = cur.next;\\n                cur.next = prev;\\n                prev = cur;\\n                cur = next;\\n            }\\n\\n            last.next = prev;\\n        }\\n\\n        return head;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849465,
                "title": "python-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        gr = 1\\n        stack = []\\n\\n        node = head\\n\\n        while(node):\\n            stack = []\\n\\n            temp = node\\n\\n            for _ in range(gr):\\n\\n                if temp == None:\\n                    break\\n\\n                stack.append(temp.val)\\n                temp = temp.next\\n\\n            if len(stack)%2 == 0:\\n                while(stack):\\n                    node.val = stack.pop()\\n                    node = node.next\\n            else:\\n                for _ in range(gr):\\n                    if node == None:\\n                        break\\n\\n                    node = node.next\\n\\n            gr += 1\\n\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        gr = 1\\n        stack = []\\n\\n        node = head\\n\\n        while(node):\\n            stack = []\\n\\n            temp = node\\n\\n            for _ in range(gr):\\n\\n                if temp == None:\\n                    break\\n\\n                stack.append(temp.val)\\n                temp = temp.next\\n\\n            if len(stack)%2 == 0:\\n                while(stack):\\n                    node.val = stack.pop()\\n                    node = node.next\\n            else:\\n                for _ in range(gr):\\n                    if node == None:\\n                        break\\n\\n                    node = node.next\\n\\n            gr += 1\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809531,
                "title": "java-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode dummy = new ListNode(0, head);\\n        ListNode prev = dummy;\\n        int groupSize = 1;\\n        while(prev.next != null) {\\n            ListNode curr = prev;\\n            int count = 0;\\n            for(int i = 0; i < groupSize && curr.next != null; ++i) {\\n                curr = curr.next;\\n                count += 1;\\n            }\\n            \\n            if(count % 2 == 0) {\\n                ListNode nextGroupHead = curr.next;\\n                curr.next = null;\\n                \\n                ListNode groupHead = prev.next;\\n                prev.next = reverseList(groupHead);\\n                groupHead.next = nextGroupHead;\\n                prev = groupHead;\\n            } else {\\n                prev = curr;\\n            }\\n            \\n            groupSize += 1;\\n        }\\n        \\n        return dummy.next;\\n    }\\n    \\n    private ListNode reverseList(ListNode node) {\\n        ListNode prev = null;\\n        while(node != null) {\\n            ListNode next = node.next;\\n            node.next = prev;\\n            prev = node;\\n            node = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode dummy = new ListNode(0, head);\\n        ListNode prev = dummy;\\n        int groupSize = 1;\\n        while(prev.next != null) {\\n            ListNode curr = prev;\\n            int count = 0;\\n            for(int i = 0; i < groupSize && curr.next != null; ++i) {\\n                curr = curr.next;\\n                count += 1;\\n            }\\n            \\n            if(count % 2 == 0) {\\n                ListNode nextGroupHead = curr.next;\\n                curr.next = null;\\n                \\n                ListNode groupHead = prev.next;\\n                prev.next = reverseList(groupHead);\\n                groupHead.next = nextGroupHead;\\n                prev = groupHead;\\n            } else {\\n                prev = curr;\\n            }\\n            \\n            groupSize += 1;\\n        }\\n        \\n        return dummy.next;\\n    }\\n    \\n    private ListNode reverseList(ListNode node) {\\n        ListNode prev = null;\\n        while(node != null) {\\n            ListNode next = node.next;\\n            node.next = prev;\\n            prev = node;\\n            node = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782454,
                "title": "java-concise",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n// 12:29\\n\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n        \\n        int groupSize = 1;\\n        ListNode current = head, lastOfGroup = new ListNode(-1);\\n\\n        while(current != null) {\\n            ListNode start = current, last = null, temp = current;\\n            int size = 0;\\n            while(size < groupSize && temp != null) {\\n                temp = temp.next;\\n                size++;\\n            }\\n        \\n            if (size % 2 == 0) {\\n                lastOfGroup.next = reverse(start, temp);\\n                lastOfGroup = start;\\n                current = temp;\\n            } else {\\n                current = start;\\n                for(int j = 1; j <= groupSize; j++) {\\n                    if (current != null) {\\n                        lastOfGroup.next = current; \\n                        current = current.next;\\n                        lastOfGroup = lastOfGroup.next;\\n                    }\\n                }\\n            }\\n            groupSize++;\\n        }\\n        return head;\\n    }\\n\\n    private ListNode reverse(ListNode head, ListNode tail) {\\n        ListNode current = head, prev = null, next = null;\\n        while(current != tail) {\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n// 12:29\\n\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n        \\n        int groupSize = 1;\\n        ListNode current = head, lastOfGroup = new ListNode(-1);\\n\\n        while(current != null) {\\n            ListNode start = current, last = null, temp = current;\\n            int size = 0;\\n            while(size < groupSize && temp != null) {\\n                temp = temp.next;\\n                size++;\\n            }\\n        \\n            if (size % 2 == 0) {\\n                lastOfGroup.next = reverse(start, temp);\\n                lastOfGroup = start;\\n                current = temp;\\n            } else {\\n                current = start;\\n                for(int j = 1; j <= groupSize; j++) {\\n                    if (current != null) {\\n                        lastOfGroup.next = current; \\n                        current = current.next;\\n                        lastOfGroup = lastOfGroup.next;\\n                    }\\n                }\\n            }\\n            groupSize++;\\n        }\\n        return head;\\n    }\\n\\n    private ListNode reverse(ListNode head, ListNode tail) {\\n        ListNode current = head, prev = null, next = null;\\n        while(current != tail) {\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598790,
                "title": "c-solution",
                "content": "```\\nListNode* reverse(ListNode* head,int k)\\n    {\\n        if(!head or !head->next) return head;\\n        //useful in finding len and in odd case\\n        ListNode* cur = head, *tail = head;\\n        int len = 0;\\n        //finding length of every segment each time\\n        while(cur && len < k) {\\n            tail = cur;\\n            cur = cur->next;\\n            len++;\\n        }\\n        // cout<<len<<\" \";\\n        if(len%2==0)\\n        {\\n            int cnt=len;\\n            ListNode* prev=nullptr,*cur=head,*n;\\n            while(cur and cnt--)\\n            {\\n                n=cur->next;\\n                cur->next=prev;\\n                prev=cur;\\n                cur=n;\\n            }\\n            \\n            head->next=reverse(n,len+1);\\n            return prev;\\n        }\\n        tail->next=reverse(cur,len+1);\\n        return head;        \\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(!head or !head->next) return head;\\n        return reverse(head,1);\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nListNode* reverse(ListNode* head,int k)\\n    {\\n        if(!head or !head->next) return head;\\n        //useful in finding len and in odd case\\n        ListNode* cur = head, *tail = head;\\n        int len = 0;\\n        //finding length of every segment each time\\n        while(cur && len < k) {\\n            tail = cur;\\n            cur = cur->next;\\n            len++;\\n        }\\n        // cout<<len<<\" \";\\n        if(len%2==0)\\n        {\\n            int cnt=len;\\n            ListNode* prev=nullptr,*cur=head,*n;\\n            while(cur and cnt--)\\n            {\\n                n=cur->next;\\n                cur->next=prev;\\n                prev=cur;\\n                cur=n;\\n            }\\n            \\n            head->next=reverse(n,len+1);\\n            return prev;\\n        }\\n        tail->next=reverse(cur,len+1);\\n        return head;        \\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(!head or !head->next) return head;\\n        return reverse(head,1);\\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2495340,
                "title": "python-easy-to-catch-o-n",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head.next == None:\\n            return head\\n        last: Optional[ListNode] = head\\n        first: Optional[ListNode] = head\\n        prev: Optional[ListNode] = head\\n        lastprev: Optional[ListNode] = head\\n        group: int = 1\\n        length: int = 1\\n            \\n        while last:\\n            # length += 1\\n            if length == group:\\n                if length%2==0:\\n                    prev.next = last\\n                    nextG = last.next\\n                    prev = self.reverse(first,last)\\n                    prev.next = nextG\\n                    last = nextG   \\n                    first = nextG\\n                    group += 1\\n                    length = 1\\n                    continue\\n                \\n                first = last.next\\n                prev = last\\n                group += 1\\n                length = 1\\n                last = last.next\\n                continue\\n            length += 1\\n            lastprev = last\\n            last = last.next\\n            \\n        if (length - 1) != 0 and (length - 1)%2==0:\\n            prev.next = lastprev\\n            self.reverse(first,lastprev).next = last\\n        return head\\n        \\n    def reverse(self,first: Optional[ListNode],last: Optional[ListNode]):\\n        \\n        # to reverse\\n        prev: Optional[ListNode] = None\\n        current: Optional[ListNode] = first\\n        last: Optional[ListNode] = last.next\\n        temp: Optional[ListNode]\\n            \\n        while (current != last):\\n            temp = current.next\\n            current.next = prev\\n            prev = current\\n            current = temp\\n        \\n        return first\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head.next == None:\\n            return head\\n        last: Optional[ListNode] = head\\n        first: Optional[ListNode] = head\\n        prev: Optional[ListNode] = head\\n        lastprev: Optional[ListNode] = head\\n        group: int = 1\\n        length: int = 1\\n            \\n        while last:\\n            # length += 1\\n            if length == group:\\n                if length%2==0:\\n                    prev.next = last\\n                    nextG = last.next\\n                    prev = self.reverse(first,last)\\n                    prev.next = nextG\\n                    last = nextG   \\n                    first = nextG\\n                    group += 1\\n                    length = 1\\n                    continue\\n                \\n                first = last.next\\n                prev = last\\n                group += 1\\n                length = 1\\n                last = last.next\\n                continue\\n            length += 1\\n            lastprev = last\\n            last = last.next\\n            \\n        if (length - 1) != 0 and (length - 1)%2==0:\\n            prev.next = lastprev\\n            self.reverse(first,lastprev).next = last\\n        return head\\n        \\n    def reverse(self,first: Optional[ListNode],last: Optional[ListNode]):\\n        \\n        # to reverse\\n        prev: Optional[ListNode] = None\\n        current: Optional[ListNode] = first\\n        last: Optional[ListNode] = last.next\\n        temp: Optional[ListNode]\\n            \\n        while (current != last):\\n            temp = current.next\\n            current.next = prev\\n            prev = current\\n            current = temp\\n        \\n        return first\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494303,
                "title": "python-o-n-01-easy",
                "content": "```\\n  \\nclass Solution:\\n  def length(self,head):\\n    fast= head \\n    count=0\\n    while fast and fast.next:\\n      fast = fast.next.next \\n      count+=2\\n    if fast:\\n      return count+1 \\n    return count \\n  \\n  def reverseEvenLengthGroups(self ,\\n  head):\\n    size = self.length(head)\\n    temp = head \\n    res = None\\n    updater = res \\n    even = False \\n    k = 1\\n    \\n    while (size>=k) or (size<k and size%2==0 and size>1):\\n     \\n      cond = size<k and size%2==0\\n      if (not even) and (not cond):\\n        curr = temp\\n        i = 1 \\n        while i <= k:\\n          if res==None:\\n            res = curr \\n            updater = res \\n          else:\\n            updater.next = curr \\n            updater = curr\\n          curr = curr.next\\n          i = i+1 \\n        temp = curr\\n      \\n     \\n      if even or cond:\\n        if size<k:\\n          k = size\\n        i = 1\\n        curr = temp.next\\n        prev = temp \\n        next_updater = prev \\n        while i  < k:\\n          next = curr.next\\n          curr.next = prev\\n          prev = curr \\n          curr = next \\n          i+=1\\n        \\n        updater.next = prev \\n        updater = next_updater\\n        temp = curr \\n        \\n      even = not even\\n      size -=k\\n      k+=1 \\n    \\n    updater.next = temp \\n    return res \\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n  \\nclass Solution:\\n  def length(self,head):\\n    fast= head \\n    count=0\\n    while fast and fast.next:\\n      fast = fast.next.next \\n      count+=2\\n    if fast:\\n      return count+1 \\n    return count \\n  \\n  def reverseEvenLengthGroups(self ,\\n  head):\\n    size = self.length(head)\\n    temp = head \\n    res = None\\n    updater = res \\n    even = False \\n    k = 1\\n    \\n    while (size>=k) or (size<k and size%2==0 and size>1):\\n     \\n      cond = size<k and size%2==0\\n      if (not even) and (not cond):\\n        curr = temp\\n        i = 1 \\n        while i <= k:\\n          if res==None:\\n            res = curr \\n            updater = res \\n          else:\\n            updater.next = curr \\n            updater = curr\\n          curr = curr.next\\n          i = i+1 \\n        temp = curr\\n      \\n     \\n      if even or cond:\\n        if size<k:\\n          k = size\\n        i = 1\\n        curr = temp.next\\n        prev = temp \\n        next_updater = prev \\n        while i  < k:\\n          next = curr.next\\n          curr.next = prev\\n          prev = curr \\n          curr = next \\n          i+=1\\n        \\n        updater.next = prev \\n        updater = next_updater\\n        temp = curr \\n        \\n      even = not even\\n      size -=k\\n      k+=1 \\n    \\n    updater.next = temp \\n    return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250551,
                "title": "most-straightforward-solution-with-comments",
                "content": "\\nclass Solution {\\npublic:\\n\\t\\n\\t// Reverse function to reverse the even length parts of linked list, and returns\\n\\t// the new head and tail of reversed linked list\\n    pair<ListNode*,ListNode*> reverse(ListNode *head)\\n    {\\n        pair<ListNode*,ListNode*>ans;\\n        ans.second = head;\\n        \\n        ListNode *p = head,*q = NULL,*r = NULL;\\n        \\n        while(p)\\n        {\\n            r = q;\\n            q = p;\\n            p = p->next;\\n            q->next = r;\\n        }\\n        head = q;\\n        ans.first = head;\\n        \\n        return ans;\\n    }\\n    \\n    ListNode *helper(ListNode *head,int k)\\n    {\\n         if(head == NULL)\\n        {\\n            return NULL;\\n        }\\n        \\n        ListNode *p = head,*q = head;\\n        ListNode *nhead = NULL,*ntail = NULL;\\n        int i = 1;\\n        \\n        while(q && i < k)\\n        {\\n            q = q->next;\\n            i++;\\n        }\\n        \\n        ListNode *nextHead = NULL;\\n        if(q)\\n        {\\n            nextHead = q->next;\\n            q->next = NULL;\\n        }\\n        \\n\\t\\t// important condition for reverse -> \\n\\t\\t// i) k is even (even length portion) and q!=NULL to ensure that this portion is not\\n\\t\\t// the last portion , (as last portion may have incomplete nodes)\\n\\t\\t\\n\\t\\t// ii) If k is not even but the last portion has even no. of nodes\\n\\t\\t// (i-1)%2 == 0 for even no. of nodes, i is increased +1 more before exit so -1 is done\\n\\t\\t// and q == NULL to ensure that this is the incomplete nodes portion the last portion\\n\\n        if((k%2 == 0 && q!=NULL)) || (q == NULL && (i-1)%2 == 0))\\n        {\\n            pair<ListNode*,ListNode*> ans = reverse(p);\\n            nhead = ans.first;\\n            ntail = ans.second; \\n        }\\n        else\\n        {\\n            nhead = p;\\n            ntail = q;\\n        }\\n        \\n        if(ntail)\\n        {\\n            ntail->next = helper(nextHead,k+1);\\n\\t\\t\\t// k+1 for next portion\\n        }\\n        \\n        return nhead;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head == NULL)\\n        {\\n            return NULL;\\n        }\\n        \\n        return helper(head,1);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\t\\n\\t// Reverse function to reverse the even length parts of linked list, and returns\\n\\t// the new head and tail of reversed linked list\\n    pair<ListNode*,ListNode*> reverse(ListNode *head)\\n    {\\n        pair<ListNode*,ListNode*>ans;\\n        ans.second = head;\\n        \\n        ListNode *p = head,*q = NULL,*r = NULL;\\n        \\n        while(p)\\n        {\\n            r = q;\\n            q = p;\\n            p = p->next;\\n            q->next = r;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2234029,
                "title": "c-solution-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverse(ListNode* head)\\n    {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return head;\\n        ListNode* tmp = NULL;\\n        ListNode* trav = head;\\n        ListNode *flag = head->next;\\n        \\n        while(trav != NULL)\\n        {\\n            trav->next = tmp;\\n            tmp = trav;\\n            trav = flag;\\n            if(flag != NULL) flag = flag->next;\\n        }\\n        \\n        return tmp;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return head;\\n        \\n        int len = 1, temp;\\n        vector<ListNode*> v;\\n        ListNode* trav = head;\\n        ListNode* tmp = NULL;\\n        int count = 0;\\n        \\n        while(trav != NULL)\\n        {\\n            v.push_back(trav);\\n            temp = len;\\n            for(int i=0; i<temp-1; i++)\\n            {\\n                if(trav == NULL) break;\\n                trav = trav->next;\\n            }\\n            if(trav != NULL)\\n            {\\n                tmp = trav->next;\\n                trav->next = NULL;\\n                trav = tmp;\\n                len++;\\n            }\\n            \\n        }\\n        \\n        for(int i=1; i<v.size()-1; i++)\\n        {\\n            v[i] = reverse(v[i]);\\n            i++; \\n        }\\n                \\n        for(int i=0; i<v.size()-1; i++)\\n        {\\n            trav = v[i];\\n            while(trav->next != NULL)\\n            {\\n                trav = trav->next;\\n            }\\n            if(i != v.size()-2) trav->next = v[i+1];\\n        }\\n        \\n        tmp = trav;\\n        \\n        trav = v[v.size()-1];\\n        while(trav != NULL)\\n        {\\n            trav = trav->next;\\n            count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n        {\\n            v[v.size()-1] = reverse(v[v.size()-1]);\\n        }\\n        \\n        tmp->next = v[v.size()-1];\\n        \\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverse(ListNode* head)\\n    {\\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return head;\\n        ListNode* tmp = NULL;\\n        ListNode* trav = head;\\n        ListNode *flag = head->next;\\n        \\n        while(trav != NULL)\\n        {\\n            trav->next = tmp;\\n            tmp = trav;\\n            trav = flag;\\n            if(flag != NULL) flag = flag->next;\\n        }\\n        \\n        return tmp;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head == NULL) return NULL;\\n        if(head->next == NULL) return head;\\n        \\n        int len = 1, temp;\\n        vector<ListNode*> v;\\n        ListNode* trav = head;\\n        ListNode* tmp = NULL;\\n        int count = 0;\\n        \\n        while(trav != NULL)\\n        {\\n            v.push_back(trav);\\n            temp = len;\\n            for(int i=0; i<temp-1; i++)\\n            {\\n                if(trav == NULL) break;\\n                trav = trav->next;\\n            }\\n            if(trav != NULL)\\n            {\\n                tmp = trav->next;\\n                trav->next = NULL;\\n                trav = tmp;\\n                len++;\\n            }\\n            \\n        }\\n        \\n        for(int i=1; i<v.size()-1; i++)\\n        {\\n            v[i] = reverse(v[i]);\\n            i++; \\n        }\\n                \\n        for(int i=0; i<v.size()-1; i++)\\n        {\\n            trav = v[i];\\n            while(trav->next != NULL)\\n            {\\n                trav = trav->next;\\n            }\\n            if(i != v.size()-2) trav->next = v[i+1];\\n        }\\n        \\n        tmp = trav;\\n        \\n        trav = v[v.size()-1];\\n        while(trav != NULL)\\n        {\\n            trav = trav->next;\\n            count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n        {\\n            v[v.size()-1] = reverse(v[v.size()-1]);\\n        }\\n        \\n        tmp->next = v[v.size()-1];\\n        \\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118503,
                "title": "trick-to-solve-it-very-easily",
                "content": "```\\n// This Question can be solved easily using two standard methods of LinkedList\\n// 1) addFirst (it adds node in front of the LinkedList)\\n// 2) addLast (it adds node in end of the LinkedList)\\n\\nclass Solution {\\n    \\n    static ListNode oh;\\n    static ListNode ot;\\n    static ListNode th;\\n    static ListNode tt;\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        oh = null;\\n        ot = null;\\n        th = null;\\n        tt = null;\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        int size = length(head);\\n        int idx = 1;\\n        ListNode curr = head;\\n        int group = 1;\\n        \\n        while(curr!=null)\\n        {\\n            int temp = size - idx + 1;\\n            if((temp>=group && group%2 == 0) || (temp<group && temp%2 == 0))\\n            {\\n                int k = group;\\n                while(k-->0 && curr!=null)\\n                {\\n                    ListNode t = curr.next;\\n                    curr.next = null;\\n                    addFirst(curr);\\n                    curr = t;\\n                    idx++;\\n                }\\n            }\\n            else\\n            { \\n                int k = group;\\n                while(k-->0 && curr!=null)\\n                {\\n                    ListNode t = curr.next;\\n                    curr.next = null;\\n                    addLast(curr);\\n                    curr = t;\\n                    idx++;\\n                }\\n            }\\n            \\n            if(oh==null && ot==null)\\n            {\\n                oh = th;\\n                ot = tt;\\n            }\\n            else\\n            {\\n                ot.next = th;\\n                ot = tt;\\n            }\\n            \\n            th = null;\\n            tt = null;\\n            group++;\\n        }\\n        \\n        return oh;\\n    }\\n    \\n    public int length (ListNode head)\\n    {\\n        if(head==null) return 0;\\n        ListNode curr = head;\\n        int k = 0;\\n        while(curr!=null)\\n        {\\n             k++;\\n            curr = curr.next;\\n        }\\n        return k;\\n    }\\n    \\n    public void addFirst(ListNode head)\\n    {\\n        if(tt == null && th == null)\\n        {\\n            th = head;\\n            tt = head;\\n        }\\n        else\\n        {\\n            head.next = th;\\n            th = head;\\n        }\\n    }\\n    \\n    public void addLast(ListNode head)\\n    {\\n        if(tt == null && th == null)\\n        {\\n            th = head;\\n            tt = head;\\n        }\\n        else\\n        {\\n            tt.next = head;\\n            tt = head;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// This Question can be solved easily using two standard methods of LinkedList\\n// 1) addFirst (it adds node in front of the LinkedList)\\n// 2) addLast (it adds node in end of the LinkedList)\\n\\nclass Solution {\\n    \\n    static ListNode oh;\\n    static ListNode ot;\\n    static ListNode th;\\n    static ListNode tt;\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        oh = null;\\n        ot = null;\\n        th = null;\\n        tt = null;\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        int size = length(head);\\n        int idx = 1;\\n        ListNode curr = head;\\n        int group = 1;\\n        \\n        while(curr!=null)\\n        {\\n            int temp = size - idx + 1;\\n            if((temp>=group && group%2 == 0) || (temp<group && temp%2 == 0))\\n            {\\n                int k = group;\\n                while(k-->0 && curr!=null)\\n                {\\n                    ListNode t = curr.next;\\n                    curr.next = null;\\n                    addFirst(curr);\\n                    curr = t;\\n                    idx++;\\n                }\\n            }\\n            else\\n            { \\n                int k = group;\\n                while(k-->0 && curr!=null)\\n                {\\n                    ListNode t = curr.next;\\n                    curr.next = null;\\n                    addLast(curr);\\n                    curr = t;\\n                    idx++;\\n                }\\n            }\\n            \\n            if(oh==null && ot==null)\\n            {\\n                oh = th;\\n                ot = tt;\\n            }\\n            else\\n            {\\n                ot.next = th;\\n                ot = tt;\\n            }\\n            \\n            th = null;\\n            tt = null;\\n            group++;\\n        }\\n        \\n        return oh;\\n    }\\n    \\n    public int length (ListNode head)\\n    {\\n        if(head==null) return 0;\\n        ListNode curr = head;\\n        int k = 0;\\n        while(curr!=null)\\n        {\\n             k++;\\n            curr = curr.next;\\n        }\\n        return k;\\n    }\\n    \\n    public void addFirst(ListNode head)\\n    {\\n        if(tt == null && th == null)\\n        {\\n            th = head;\\n            tt = head;\\n        }\\n        else\\n        {\\n            head.next = th;\\n            th = head;\\n        }\\n    }\\n    \\n    public void addLast(ListNode head)\\n    {\\n        if(tt == null && th == null)\\n        {\\n            th = head;\\n            tt = head;\\n        }\\n        else\\n        {\\n            tt.next = head;\\n            tt = head;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102638,
                "title": "c-solution",
                "content": "Approach: **T.C -> O(n), S.C -> O(1)**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = nullptr, *next = nullptr, *curr = head;\\n        while(curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prev = dummy;\\n        \\n        for(int len = 1; len <= 1e5 && head; len++) {\\n            // len denotes the max length of a current group\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            // Determine the length of the current group\\n            int j = 1;\\n            while(j < len and tail and tail->next) {\\n                tail = tail->next;\\n                j++;\\n            }\\n            \\n            nextHead = tail->next;\\n            \\n            if(j % 2 == 0) {\\n                \\n                // isolate and reverse the group\\n                tail->next = nullptr;\\n                prev->next = reverseList(head);\\n                prev = head;\\n                head->next = nextHead;\\n                head = nextHead;\\n            }\\n            \\n            else {\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = nullptr, *next = nullptr, *curr = head;\\n        while(curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prev = dummy;\\n        \\n        for(int len = 1; len <= 1e5 && head; len++) {\\n            // len denotes the max length of a current group\\n            ListNode* tail = head;\\n            ListNode* nextHead;\\n            \\n            // Determine the length of the current group\\n            int j = 1;\\n            while(j < len and tail and tail->next) {\\n                tail = tail->next;\\n                j++;\\n            }\\n            \\n            nextHead = tail->next;\\n            \\n            if(j % 2 == 0) {\\n                \\n                // isolate and reverse the group\\n                tail->next = nullptr;\\n                prev->next = reverseList(head);\\n                prev = head;\\n                head->next = nextHead;\\n                head = nextHead;\\n            }\\n            \\n            else {\\n                prev = tail;\\n                head = nextHead;\\n            }\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084250,
                "title": "brute-force-cpp",
                "content": "```\\n ListNode* curr=head;\\n        vector<int>v;\\n        while(curr!=NULL)\\n        {\\n            v.push_back(curr->val);\\n            curr=curr->next;\\n        }\\n        int n=v.size();\\n        int k=1,i=0;\\n        while(n>1)\\n        {\\n            if(k==1)\\n            {\\n                n-=1;\\n                k++;\\n                i++;\\n            }\\n            if(k%2==0&&n>=k)\\n            {\\n                n-=k;\\n                reverse(v.begin()+i,v.begin()+i+k);\\n                i+=k;\\n                k++;\\n            }\\n            else if(k%2!=0&&n>=k)\\n            {\\n                n-=k;\\n                i+=k;\\n                k++;\\n            }\\n            else if(n<k&&n%2==0)\\n            {\\n                reverse(v.begin()+i,v.end());\\n                n-=k;\\n            }\\n            else\\n                break;\\n            \\n        }\\n        \\n        ListNode* res=new ListNode(0);\\n        ListNode* a=res;\\n        for(auto x:v)\\n        {\\n            a->next=new ListNode(x);\\n            a=a->next;\\n        }\\n        return res->next;\\n```",
                "solutionTags": [],
                "code": "```\\n ListNode* curr=head;\\n        vector<int>v;\\n        while(curr!=NULL)\\n        {\\n            v.push_back(curr->val);\\n            curr=curr->next;\\n        }\\n        int n=v.size();\\n        int k=1,i=0;\\n        while(n>1)\\n        {\\n            if(k==1)\\n            {\\n                n-=1;\\n                k++;\\n                i++;\\n            }\\n            if(k%2==0&&n>=k)\\n            {\\n                n-=k;\\n                reverse(v.begin()+i,v.begin()+i+k);\\n                i+=k;\\n                k++;\\n            }\\n            else if(k%2!=0&&n>=k)\\n            {\\n                n-=k;\\n                i+=k;\\n                k++;\\n            }\\n            else if(n<k&&n%2==0)\\n            {\\n                reverse(v.begin()+i,v.end());\\n                n-=k;\\n            }\\n            else\\n                break;\\n            \\n        }\\n        \\n        ListNode* res=new ListNode(0);\\n        ListNode* a=res;\\n        for(auto x:v)\\n        {\\n            a->next=new ListNode(x);\\n            a=a->next;\\n        }\\n        return res->next;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1925750,
                "title": "c-easy-stack-solution",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* reverseEvenLengthGroups(ListNode* head) {\\n\\t\\t\\tListNode* root = head->next;\\n\\t\\t\\tfor(int i = 2; root; i++){\\n\\t\\t\\t\\t\\tstack<int>s; \\n\\t\\t\\t\\t\\tListNode* tmp = root;\\n\\t\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\t\\twhile(cnt!=i and tmp) cnt++,s.push(tmp->val),tmp = tmp->next; \\n\\t\\t\\t\\t\\tif((i%2==0 and cnt==i) or (cnt%2==0 and !tmp)){\\n\\t\\t\\t\\t\\t\\twhile(cnt--){\\n\\t\\t\\t\\t\\t\\t\\troot->val = s.top();s.pop(); root = root->next;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse root = tmp;\\n\\t\\t\\t}\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode* reverseEvenLengthGroups(ListNode* head) {\\n\\t\\t\\tListNode* root = head->next;\\n\\t\\t\\tfor(int i = 2; root; i++){\\n\\t\\t\\t\\t\\tstack<int>s; \\n\\t\\t\\t\\t\\tListNode* tmp = root;\\n\\t\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\t\\twhile(cnt!=i and tmp) cnt++,s.push(tmp->val),tmp = tmp->next; \\n\\t\\t\\t\\t\\tif((i%2==0 and cnt==i) or (cnt%2==0 and !tmp)){\\n\\t\\t\\t\\t\\t\\twhile(cnt--){\\n\\t\\t\\t\\t\\t\\t\\troot->val = s.top();s.pop(); root = root->next;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1822855,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode *helper(ListNode *head,int reqLen,ListNode *parent) {\\n        if(!head || !head->next) {\\n            return head;\\n        }\\n        int count=1;\\n        ListNode *tmp=head;\\n        while(count<reqLen && tmp) {\\n            tmp=tmp->next;\\n            count++;\\n        }\\n        if(!tmp) {\\n            count--;\\n        }\\n        if(count%2==0) {\\n            ListNode *later=NULL,*curr=head,*prev=NULL,*target=tmp?tmp->next:NULL;\\n            if(parent) {\\n                parent->next=NULL;\\n            }\\n            while(curr!=target) {\\n                later=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=later;\\n            }\\n            if(parent) {\\n                parent->next=prev;\\n            }\\n            head->next=target?helper(target,reqLen+1,head):head->next;\\n            return prev;\\n        }\\n        else {\\n            if(parent) {\\n                parent->next=head;\\n            }\\n            if(tmp) {\\n                tmp->next=helper(tmp->next,reqLen+1,tmp);\\n            }\\n            return head;\\n        }\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return helper(head,1,NULL);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode *helper(ListNode *head,int reqLen,ListNode *parent) {\\n        if(!head || !head->next) {\\n            return head;\\n        }\\n        int count=1;\\n        ListNode *tmp=head;\\n        while(count<reqLen && tmp) {\\n            tmp=tmp->next;\\n            count++;\\n        }\\n        if(!tmp) {\\n            count--;\\n        }\\n        if(count%2==0) {\\n            ListNode *later=NULL,*curr=head,*prev=NULL,*target=tmp?tmp->next:NULL;\\n            if(parent) {\\n                parent->next=NULL;\\n            }\\n            while(curr!=target) {\\n                later=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=later;\\n            }\\n            if(parent) {\\n                parent->next=prev;\\n            }\\n            head->next=target?helper(target,reqLen+1,head):head->next;\\n            return prev;\\n        }\\n        else {\\n            if(parent) {\\n                parent->next=head;\\n            }\\n            if(tmp) {\\n                tmp->next=helper(tmp->next,reqLen+1,tmp);\\n            }\\n            return head;\\n        }\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return helper(head,1,NULL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789918,
                "title": "lc-2074-reverse-nodes-in-even-length-groups-simple-python-maps-iteration",
                "content": "```\\n\\'\\'\\'\\nProblem: LC 2074 - Reverse Nodes in Even Length Groups\\nAuthor: Anando Zaman\\nDifficulty: Medium\\nDate: February 21, 2022\\n\\nNotes:\\nNodes are grouped based on their positions.\\nSo first node is group 1\\nNext two nodes are group 2\\nNext three nodes are group 3\\nNext four nodes are group 4.\\n\\nWe only want to reverse the groups that have even lengths\\nand return head of modified linkedList\\n\\nNOTE:\\nLength of the last group may be less than or equal to 1 + the length of the second to last group.\\n\\n\\nSOLUTION:\\nCreate three helper functions that takes the next node and a length:\\n    - NextHeadAndLastNodes_Reversed: Returns the first and last index of next sublist\\n    - NextHeadAndLastNodes_Reversed: Returns the first and last index of next reversed sublist\\n    - nextValidSubListSize: Returns the max size of the grouping possible\\n\\nUse a local variable to track the desired length of each grouping.\\nWe use the nextValidSubListSize function to determine if that length is possible, if not, return the number of nodes it supports.\\n\\nDepending on whether that result is odd or even, we return the reversed/non-reversed result\\nas a mapping of \\'head\\' and \\'last\\' nodes.\\n\\nUpdate our curr.next to point to the returned sublist, then continue reversing the next group\\nnodes starting at last.next node.\\n\\'\\'\\'\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        def nextValidSubListSize(head: ListNode, len_: int):\\n            \\n            node_cnt = 0\\n            while head and node_cnt < len_:\\n                head = head.next\\n                node_cnt += 1\\n                \\n            return node_cnt\\n            \\n        \\n        def NextHeadAndLastNodes_Reversed(head: ListNode, len_: int):\\n            if not head:\\n                return {\\'head\\':None, \\'last\\':None}\\n            \\n            last = head\\n            prev, curr = None, head\\n            \\n            while (len_ > 0 and curr):\\n                temp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = temp\\n                len_ -= 1\\n                \\n            new_head = prev\\n            last.next = curr # linkage needed so that we can reference next grouping\\n            return {\\'head\\':new_head, \\'last\\':last}\\n        \\n        def NextHeadAndLastNodes(head: ListNode, len_:int):\\n            if not head:\\n                return {\\'head\\':None, \\'last\\':None}\\n            \\n            prev = None\\n            curr = head\\n            while curr and len_ > 0:\\n                prev = curr\\n                curr = curr.next\\n                len_ -= 1\\n                \\n            return {\\'head\\':head, \\'last\\':prev}\\n        \\n        # MAIN EXECUTION\\n        nodes_len = 1\\n        curr = head\\n        while curr:\\n            nodes_len += 1\\n            nodes_size_avail =  nextValidSubListSize(curr.next, nodes_len)\\n            \\n            NextHeadLastMap = {}\\n            if nodes_size_avail % 2 == 0:\\n                NextHeadLastMap = NextHeadAndLastNodes_Reversed(curr.next, nodes_len)\\n            else:\\n                NextHeadLastMap = NextHeadAndLastNodes(curr.next, nodes_len)\\n            \\n            curr.next = NextHeadLastMap[\\'head\\']\\n            curr = NextHeadLastMap[\\'last\\']\\n            \\n        return head\\n        \\n        \\n                \\n            \\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n\\'\\'\\'\\nProblem: LC 2074 - Reverse Nodes in Even Length Groups\\nAuthor: Anando Zaman\\nDifficulty: Medium\\nDate: February 21, 2022\\n\\nNotes:\\nNodes are grouped based on their positions.\\nSo first node is group 1\\nNext two nodes are group 2\\nNext three nodes are group 3\\nNext four nodes are group 4.\\n\\nWe only want to reverse the groups that have even lengths\\nand return head of modified linkedList\\n\\nNOTE:\\nLength of the last group may be less than or equal to 1 + the length of the second to last group.\\n\\n\\nSOLUTION:\\nCreate three helper functions that takes the next node and a length:\\n    - NextHeadAndLastNodes_Reversed: Returns the first and last index of next sublist\\n    - NextHeadAndLastNodes_Reversed: Returns the first and last index of next reversed sublist\\n    - nextValidSubListSize: Returns the max size of the grouping possible\\n\\nUse a local variable to track the desired length of each grouping.\\nWe use the nextValidSubListSize function to determine if that length is possible, if not, return the number of nodes it supports.\\n\\nDepending on whether that result is odd or even, we return the reversed/non-reversed result\\nas a mapping of \\'head\\' and \\'last\\' nodes.\\n\\nUpdate our curr.next to point to the returned sublist, then continue reversing the next group\\nnodes starting at last.next node.\\n\\'\\'\\'\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        def nextValidSubListSize(head: ListNode, len_: int):\\n            \\n            node_cnt = 0\\n            while head and node_cnt < len_:\\n                head = head.next\\n                node_cnt += 1\\n                \\n            return node_cnt\\n            \\n        \\n        def NextHeadAndLastNodes_Reversed(head: ListNode, len_: int):\\n            if not head:\\n                return {\\'head\\':None, \\'last\\':None}\\n            \\n            last = head\\n            prev, curr = None, head\\n            \\n            while (len_ > 0 and curr):\\n                temp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = temp\\n                len_ -= 1\\n                \\n            new_head = prev\\n            last.next = curr # linkage needed so that we can reference next grouping\\n            return {\\'head\\':new_head, \\'last\\':last}\\n        \\n        def NextHeadAndLastNodes(head: ListNode, len_:int):\\n            if not head:\\n                return {\\'head\\':None, \\'last\\':None}\\n            \\n            prev = None\\n            curr = head\\n            while curr and len_ > 0:\\n                prev = curr\\n                curr = curr.next\\n                len_ -= 1\\n                \\n            return {\\'head\\':head, \\'last\\':prev}\\n        \\n        # MAIN EXECUTION\\n        nodes_len = 1\\n        curr = head\\n        while curr:\\n            nodes_len += 1\\n            nodes_size_avail =  nextValidSubListSize(curr.next, nodes_len)\\n            \\n            NextHeadLastMap = {}\\n            if nodes_size_avail % 2 == 0:\\n                NextHeadLastMap = NextHeadAndLastNodes_Reversed(curr.next, nodes_len)\\n            else:\\n                NextHeadLastMap = NextHeadAndLastNodes(curr.next, nodes_len)\\n            \\n            curr.next = NextHeadLastMap[\\'head\\']\\n            curr = NextHeadLastMap[\\'last\\']\\n            \\n        return head\\n        \\n        \\n                \\n            \\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776421,
                "title": "c-naive-approach-but-easy-to-understand",
                "content": "```\\n  int calculate(ListNode* head)\\n    {\\n        int count=0;\\n        while(head!=NULL)\\n        {\\n            count++;\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverse(ListNode* head,int len)\\n    {\\n        ListNode* curr=head;\\n        ListNode* prev=NULL,*next=NULL;\\n        while(curr!=NULL && len>0)\\n        {\\n             next=curr->next;\\n            ListNode* newTemp=new ListNode(curr->val);\\n             newTemp->next=prev;\\n            prev=newTemp;\\n            curr=curr->next;\\n            len--;\\n        }\\n        \\n        return prev;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int totalnodes=calculate(head);\\n        int i=1;\\n        ListNode* pseudonode=new ListNode(-1);\\n        ListNode* prev=pseudonode;\\n        while(i)\\n        {\\n            int remnodes=totalnodes-i;\\n            if(remnodes>0)\\n            {\\n                int val=i;\\n                prev->next=head;\\n                if(i%2==0)\\n                {\\n                    ListNode* newlist=reverse(head,i);\\n                    ListNode* temp=newlist;\\n                    while(temp!=NULL)\\n                    {\\n                        temp=temp->next;\\n                    }\\n                    prev->next=newlist;\\n                }\\n                 while(val>0 && head!=NULL)\\n                    {\\n                     val--;\\n                        prev=prev->next;\\n                        head=head->next;\\n                    }\\n            }\\n            else\\n            {\\n                if(totalnodes%2==0)\\n                {\\n                      ListNode* newlist=reverse(head,i);\\n                      prev->next=newlist;\\n                     return pseudonode->next;\\n                }\\n                else\\n                {\\n                    prev->next=head;\\n                    return pseudonode->next;\\n                }\\n            }\\n            totalnodes-=i; i++;\\n        }\\n        return pseudonode->next;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int calculate(ListNode* head)\\n    {\\n        int count=0;\\n        while(head!=NULL)\\n        {\\n            count++;\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n    ListNode* reverse(ListNode* head,int len)\\n    {\\n        ListNode* curr=head;\\n        ListNode* prev=NULL,*next=NULL;\\n        while(curr!=NULL && len>0)\\n        {\\n             next=curr->next;\\n            ListNode* newTemp=new ListNode(curr->val);\\n             newTemp->next=prev;\\n            prev=newTemp;\\n            curr=curr->next;\\n            len--;\\n        }\\n        \\n        return prev;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int totalnodes=calculate(head);\\n        int i=1;\\n        ListNode* pseudonode=new ListNode(-1);\\n        ListNode* prev=pseudonode;\\n        while(i)\\n        {\\n            int remnodes=totalnodes-i;\\n            if(remnodes>0)\\n            {\\n                int val=i;\\n                prev->next=head;\\n                if(i%2==0)\\n                {\\n                    ListNode* newlist=reverse(head,i);\\n                    ListNode* temp=newlist;\\n                    while(temp!=NULL)\\n                    {\\n                        temp=temp->next;\\n                    }\\n                    prev->next=newlist;\\n                }\\n                 while(val>0 && head!=NULL)\\n                    {\\n                     val--;\\n                        prev=prev->next;\\n                        head=head->next;\\n                    }\\n            }\\n            else\\n            {\\n                if(totalnodes%2==0)\\n                {\\n                      ListNode* newlist=reverse(head,i);\\n                      prev->next=newlist;\\n                     return pseudonode->next;\\n                }\\n                else\\n                {\\n                    prev->next=head;\\n                    return pseudonode->next;\\n                }\\n            }\\n            totalnodes-=i; i++;\\n        }\\n        return pseudonode->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1732265,
                "title": "kotlin-easy-recursive",
                "content": "Shortly this solution uses backtracking reverse groups from last group\\n\\n```\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        return reverse(head, arrayOf(null), intArrayOf(1), 1)\\n    }\\n    \\n    private fun reverse(head: ListNode?, tail: Array<ListNode?>, k: IntArray, g: Int): ListNode? {\\n        if (head == null || head.next == null) return head\\n        if (k[0] == g) {\\n            tail[0] = reverse(head.next, tail, intArrayOf(1), g + 1)\\n            return head.apply { this.next = tail[0] }\\n        }\\n        val rest = reverse(head.next, tail, k.apply { this[0]++ }, g)\\n        if ((k[0] and 1) == 0) {\\n            head.next.next = head\\n            head.next = tail[0]  \\n            return rest\\n        }\\n        return head\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        return reverse(head, arrayOf(null), intArrayOf(1), 1)\\n    }\\n    \\n    private fun reverse(head: ListNode?, tail: Array<ListNode?>, k: IntArray, g: Int): ListNode? {\\n        if (head == null || head.next == null) return head\\n        if (k[0] == g) {\\n            tail[0] = reverse(head.next, tail, intArrayOf(1), g + 1)\\n            return head.apply { this.next = tail[0] }\\n        }\\n        val rest = reverse(head.next, tail, k.apply { this[0]++ }, g)\\n        if ((k[0] and 1) == 0) {\\n            head.next.next = head\\n            head.next = tail[0]  \\n            return rest\\n        }\\n        return head\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697132,
                "title": "reverse-nodes-in-even-length-groups-o-n-faster-than-75-submission",
                "content": "\\tLogic is to maintain the window of even length list and reverse them .\\n...\\nListNode* reverse(ListNode* head)\\n    {\\n        if(head == NULL || head->next ==NULL )\\n            return head;\\n        \\n        ListNode* newhead = reverse(head->next);\\n        head->next->next = head;\\n        head->next = NULL;\\n        \\n        return newhead;\\n        \\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head->next == NULL)\\n            return head;\\n        \\n        ListNode* temp = head;\\n        ListNode* tempprev = head;\\n        ListNode* temphead = head;\\n        ListNode* tempheadprev = head;\\n        int k = 1;\\n        int tempk = k;\\n        bool isodd = true;\\n        int flag = 1;\\n        while(temp!=NULL)\\n        {\\n            if(isodd)\\n            {\\n                while(temp != NULL && k)\\n                {   \\n                    tempprev = temp;\\n                    temp = temp->next;\\n                    k--;\\n                    \\n                }\\n                if(k != 0 && ((tempk - k)%2) == 0)\\n                {   \\n                    //cout<<tempk<<\" \"<<k<<endl;\\n                    flag = 0;\\n                    break;\\n                }\\n                else if(k != 0 && (((tempk - k)%2) != 0))\\n                {   \\n                    break;\\n                }\\n                temphead = temp;\\n                tempheadprev = tempprev;\\n                isodd = false;\\n                k = tempk + 1;\\n                tempk++;\\n            }\\n            else\\n            {\\n                while(temp != NULL && k)\\n                {\\n                    k--;\\n                    tempprev = temp;\\n                    temp = temp->next;\\n                }\\n                \\n                    //cout<<tempk<<\" \"<<k<<endl;\\n                if(k != 0 && (((tempk - k)%2) == 0))\\n                {   \\n                    flag = 0;\\n                    break;\\n                }\\n                else if(k != 0 && (((tempk - k)%2) != 0))\\n                {   \\n                    break;\\n                }\\n                tempprev->next = NULL;\\n                ListNode* newhead = reverse(temphead);\\n                tempheadprev->next = newhead;\\n                temphead->next = temp;\\n                tempheadprev = temphead;\\n                temphead = temp;\\n                \\n                k = tempk + 1;\\n                tempk++;\\n                isodd = true;\\n            }\\n        }\\n        if(flag == 0)\\n        {   \\n            tempprev->next = NULL;\\n            ListNode* newhead = reverse(temphead);\\n            tempheadprev->next = newhead;\\n            temphead->next = temp;\\n        }\\n        return head;\\n    }\\n\\t...\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tLogic is to maintain the window of even length list and reverse them .\\n...\\nListNode* reverse(ListNode* head)\\n    {\\n        if(head == NULL || head->next ==NULL )\\n            return head;\\n        \\n        ListNode* newhead = reverse(head->next);\\n        head->next->next = head;\\n        head->next = NULL;\\n        \\n        return newhead;\\n        \\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head->next == NULL)\\n            return head;\\n        \\n        ListNode* temp = head;\\n        ListNode* tempprev = head;\\n        ListNode* temphead = head;\\n        ListNode* tempheadprev = head;\\n        int k = 1;\\n        int tempk = k;\\n        bool isodd = true;\\n        int flag = 1;\\n        while(temp!=NULL)\\n        {\\n            if(isodd)\\n            {\\n                while(temp != NULL && k)\\n                {   \\n                    tempprev = temp;\\n                    temp = temp->next;\\n                    k--;\\n                    \\n                }\\n                if(k != 0 && ((tempk - k)%2) == 0)\\n                {   \\n                    //cout<<tempk<<\" \"<<k<<endl;\\n                    flag = 0;\\n                    break;\\n                }\\n                else if(k != 0 && (((tempk - k)%2) != 0))\\n                {   \\n                    break;\\n                }\\n                temphead = temp;\\n                tempheadprev = tempprev;\\n                isodd = false;\\n                k = tempk + 1;\\n                tempk++;\\n            }\\n            else\\n            {\\n                while(temp != NULL && k)\\n                {\\n                    k--;\\n                    tempprev = temp;\\n                    temp = temp->next;\\n                }\\n                \\n                    //cout<<tempk<<\" \"<<k<<endl;\\n                if(k != 0 && (((tempk - k)%2) == 0))\\n                {   \\n                    flag = 0;\\n                    break;\\n                }\\n                else if(k != 0 && (((tempk - k)%2) != 0))\\n                {   \\n                    break;\\n                }\\n                tempprev->next = NULL;\\n                ListNode* newhead = reverse(temphead);\\n                tempheadprev->next = newhead;\\n                temphead->next = temp;\\n                tempheadprev = temphead;\\n                temphead = temp;\\n                \\n                k = tempk + 1;\\n                tempk++;\\n                isodd = true;\\n            }\\n        }\\n        if(flag == 0)\\n        {   \\n            tempprev->next = NULL;\\n            ListNode* newhead = reverse(temphead);\\n            tempheadprev->next = newhead;\\n            temphead->next = temp;\\n        }\\n        return head;\\n    }\\n\\t...\\n",
                "codeTag": "C++"
            },
            {
                "id": 1678290,
                "title": "java-solution-without-extra-space",
                "content": "This method has two helper functions.\\n\\n1) height  - to determine height of list (straightforward)\\n2) reverese - to reverse the group ( usual reverse function with little tweak by just pointing intial head to last element of the group.\\n\\nAlgo:\\n1) if your current number (count % 2 == 0) is even then do reverse else just move forward in the list.\\n2) On the each loop just decrement height by count and once the height becomes less than number,\\n   break loop in case if its even , if its odd just increment the number and continue with the loop because even will take care of it.\\n```    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp = head;\\n        int count = 1;\\n        int height = height(head);\\n        while (head != null) {\\n            if (count%2 == 0) {\\n                if (height < count && height %2 == 1)\\n                    break;\\n                ListNode next = head.next;\\n                head.next = reverse(head.next, count);\\n                head = next;\\n                if (height < count)\\n                    break;\\n            }\\n            else {\\n                if (height < count) {\\n                    if (height %2 == 1)\\n                        break;\\n                    else {\\n                        count++;\\n                        continue;\\n                    }\\n                }\\n                int index = count;\\n                while (head != null && index-- > 0 && count !=1) \\n                    head = head.next;\\n            }\\n            height -= count;\\n            count++;\\n        }\\n        return temp;\\n    }\\n    public int height (ListNode head) {\\n        int height = 0;\\n        while (head != null) {\\n            head = head.next;\\n            height++;\\n        }\\n        return height;\\n    }\\n    \\n    public ListNode reverse(ListNode head, int count) {\\n        if (head == null)\\n            return head;\\n        ListNode pointer = head, prev = null;\\n        while (head != null && count-- > 0) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        pointer.next = head;\\n        return prev;\\n    }",
                "solutionTags": [],
                "code": "This method has two helper functions.\\n\\n1) height  - to determine height of list (straightforward)\\n2) reverese - to reverse the group ( usual reverse function with little tweak by just pointing intial head to last element of the group.\\n\\nAlgo:\\n1) if your current number (count % 2 == 0) is even then do reverse else just move forward in the list.\\n2) On the each loop just decrement height by count and once the height becomes less than number,\\n   break loop in case if its even , if its odd just increment the number and continue with the loop because even will take care of it.\\n```    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp = head;\\n        int count = 1;\\n        int height = height(head);\\n        while (head != null) {\\n            if (count%2 == 0) {\\n                if (height < count && height %2 == 1)\\n                    break;\\n                ListNode next = head.next;\\n                head.next = reverse(head.next, count);\\n                head = next;\\n                if (height < count)\\n                    break;\\n            }\\n            else {\\n                if (height < count) {\\n                    if (height %2 == 1)\\n                        break;\\n                    else {\\n                        count++;\\n                        continue;\\n                    }\\n                }\\n                int index = count;\\n                while (head != null && index-- > 0 && count !=1) \\n                    head = head.next;\\n            }\\n            height -= count;\\n            count++;\\n        }\\n        return temp;\\n    }\\n    public int height (ListNode head) {\\n        int height = 0;\\n        while (head != null) {\\n            head = head.next;\\n            height++;\\n        }\\n        return height;\\n    }\\n    \\n    public ListNode reverse(ListNode head, int count) {\\n        if (head == null)\\n            return head;\\n        ListNode pointer = head, prev = null;\\n        while (head != null && count-- > 0) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        pointer.next = head;\\n        return prev;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1657173,
                "title": "java-solution-using-recursion",
                "content": "\\tclass Solution {\\n\\t\\tpublic ListNode reverseEvenLengthGroups(ListNode head) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tListNode slow = head;\\n\\n\\t\\t\\twhile(slow!=null) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tslow = slow.next;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn helper(head, count, 1);\\n\\t\\t}\\n\\n\\t\\tpublic ListNode helper(ListNode head, int length, int groupLength) {\\n\\t\\t\\tListNode current = head;\\n\\t\\t\\tListNode prev = null;\\n\\n\\t\\t\\tif(length < groupLength) groupLength = length;\\n\\n\\t\\t\\tif(groupLength%2 == 1) {\\n\\t\\t\\t\\tint k = groupLength;\\n\\t\\t\\t\\twhile(k-- > 0 && current!=null) {\\n\\t\\t\\t\\t\\tprev = current;\\n\\t\\t\\t\\t\\tcurrent = current.next;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(current!=null)\\n\\t\\t\\t\\t\\tprev.next = helper(current, length-groupLength, groupLength+1);\\n\\n\\t\\t\\t\\treturn head;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint k = groupLength;\\n\\t\\t\\t\\tListNode next = null;\\n\\n\\t\\t\\t\\twhile(k-- > 0 && current!=null) {\\n\\t\\t\\t\\t\\tnext = current.next;\\n\\t\\t\\t\\t\\tcurrent.next = prev;\\n\\t\\t\\t\\t\\tprev = current;\\n\\t\\t\\t\\t\\tcurrent = next;    \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(current!=null)\\n\\t\\t\\t\\t\\thead.next = helper(current, length-groupLength, groupLength+1);\\n\\n\\t\\t\\t\\treturn prev;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic ListNode reverseEvenLengthGroups(ListNode head) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tListNode slow = head;\\n\\n\\t\\t\\twhile(slow!=null) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tslow = slow.next;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1652176,
                "title": "python-o-1-space",
                "content": "Approach:\\n\\tCount number of nodes until they are less than those in previous group.\\n\\ti.e. **groupCount+1>count**\\n\\tIf count is odd then modify pointers.\\n\\tElse reverse those nodes and also modify pointers.\\n\\nptr1 = pointer to last node of previous group\\nptr2 = pointer to start of current group\\nptr3 = pointer to start of next group\\nptr4 = pointer to end of current group\\n\\n```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        groupCount = 0\\n        ptr1 = None\\n        ptr2 = head\\n        \\n        while ptr2:\\n            count = 0\\n            ptr3 = ptr2\\n            ptr4 = None\\n            while ptr3 and count<groupCount+1:\\n                ptr4 = ptr3\\n                ptr3 = ptr3.next\\n                count += 1\\n            \\n            if count%2:\\n                ptr1 = ptr4\\n            else:\\n                ptr1.next = self.reverse(ptr2, ptr3)\\n                ptr1 = ptr2\\n            ptr2 = ptr3\\n            groupCount += 1\\n        \\n        return head\\n            \\n    def reverse(self, curr, until):\\n        prev = until\\n        next = curr.next\\n        \\n        while next!=until:\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n            next = next.next\\n        \\n        curr.next = prev\\n        return curr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        groupCount = 0\\n        ptr1 = None\\n        ptr2 = head\\n        \\n        while ptr2:\\n            count = 0\\n            ptr3 = ptr2\\n            ptr4 = None\\n            while ptr3 and count<groupCount+1:\\n                ptr4 = ptr3\\n                ptr3 = ptr3.next\\n                count += 1\\n            \\n            if count%2:\\n                ptr1 = ptr4\\n            else:\\n                ptr1.next = self.reverse(ptr2, ptr3)\\n                ptr1 = ptr2\\n            ptr2 = ptr3\\n            groupCount += 1\\n        \\n        return head\\n            \\n    def reverse(self, curr, until):\\n        prev = until\\n        next = curr.next\\n        \\n        while next!=until:\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n            next = next.next\\n        \\n        curr.next = prev\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650251,
                "title": "python-recursion",
                "content": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def reverse(head, k):\\n            if head is None:\\n                return\\n\\t\\t\\t# traverse k node\\n            temp, kth, count = head, None, 0\\n            while temp and count < k:\\n                kth = temp\\n                temp = temp.next\\n                count += 1\\n\\t\\t\\t# return head for odd count\\n            if count % 2 and count != k: \\n                return head\\n            else:\\n                k = count # if count is even, reset k to count\\n            x = reverse(temp, k + 1)  # temp is (k + 1)th node\\n\\t\\t\\t# reverse list if k is even\\n            if k % 2 == 0:\\n                curr, pre = head, None\\n                while curr != temp:\\n                    next_ = curr.next\\n                    curr.next = pre\\n                    pre = curr\\n                    curr = next_\\n                head.next = x\\n                return pre\\n\\t\\t\\t\\n\\t\\t\\t# if k is odd\\n            kth.next = x\\n            return head\\n            \\n        return reverse(head, 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def reverse(head, k):\\n            if head is None:\\n                return\\n\\t\\t\\t# traverse k node\\n            temp, kth, count = head, None, 0\\n            while temp and count < k:\\n                kth = temp\\n                temp = temp.next\\n                count += 1\\n\\t\\t\\t# return head for odd count\\n            if count % 2 and count != k: \\n                return head\\n            else:\\n                k = count # if count is even, reset k to count\\n            x = reverse(temp, k + 1)  # temp is (k + 1)th node\\n\\t\\t\\t# reverse list if k is even\\n            if k % 2 == 0:\\n                curr, pre = head, None\\n                while curr != temp:\\n                    next_ = curr.next\\n                    curr.next = pre\\n                    pre = curr\\n                    curr = next_\\n                head.next = x\\n                return pre\\n\\t\\t\\t\\n\\t\\t\\t# if k is odd\\n            kth.next = x\\n            return head\\n            \\n        return reverse(head, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594762,
                "title": "c-solution-easy-to-understand",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverselist(ListNode*& leftnode, ListNode*& rightnode, ListNode*& head) {\\n        ListNode* prevptr=rightnode;\\n        ListNode* currptr=leftnode;\\n        ListNode* nextptr;\\n        while(currptr!=rightnode){\\n            nextptr=currptr->next;\\n            currptr->next=prevptr;\\n            prevptr=currptr;\\n            currptr=nextptr;\\n        }\\n        head=prevptr;\\n    }\\n    void reverseList(ListNode*& leftnode, ListNode*& rightnode) {\\n        ListNode* prevptr=rightnode;\\n        ListNode* currptr=leftnode->next;\\n        ListNode* nextptr;\\n        while(currptr!=rightnode){\\n            nextptr=currptr->next;\\n            currptr->next=prevptr;\\n            prevptr=currptr;\\n            currptr=nextptr;\\n        }\\n        leftnode->next=prevptr;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* rightnode=head;\\n        while(right>0 && rightnode){\\n            rightnode=rightnode->next;\\n            right--;\\n        }\\n        ListNode* leftnode=head;\\n        if(left!=1){\\n            left=left-2;\\n            while(left--) leftnode=leftnode->next;\\n            reverseList(leftnode, rightnode);\\n            return head;\\n        }\\n        reverselist(leftnode, rightnode, head);\\n        return head;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* temp=head;\\n        int length=0;\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        int k=1, i=1;\\n        while((k*(k+1)/2)<=length){\\n            if(k%2==0){\\n                head=reverseBetween(head, i, i+k-1);\\n            }\\n            i+=k;\\n            k++;\\n        }\\n        if((length-i+1)%2==0){\\n            head=reverseBetween(head, i, length);\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverselist(ListNode*& leftnode, ListNode*& rightnode, ListNode*& head) {\\n        ListNode* prevptr=rightnode;\\n        ListNode* currptr=leftnode;\\n        ListNode* nextptr;\\n        while(currptr!=rightnode){\\n            nextptr=currptr->next;\\n            currptr->next=prevptr;\\n            prevptr=currptr;\\n            currptr=nextptr;\\n        }\\n        head=prevptr;\\n    }\\n    void reverseList(ListNode*& leftnode, ListNode*& rightnode) {\\n        ListNode* prevptr=rightnode;\\n        ListNode* currptr=leftnode->next;\\n        ListNode* nextptr;\\n        while(currptr!=rightnode){\\n            nextptr=currptr->next;\\n            currptr->next=prevptr;\\n            prevptr=currptr;\\n            currptr=nextptr;\\n        }\\n        leftnode->next=prevptr;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* rightnode=head;\\n        while(right>0 && rightnode){\\n            rightnode=rightnode->next;\\n            right--;\\n        }\\n        ListNode* leftnode=head;\\n        if(left!=1){\\n            left=left-2;\\n            while(left--) leftnode=leftnode->next;\\n            reverseList(leftnode, rightnode);\\n            return head;\\n        }\\n        reverselist(leftnode, rightnode, head);\\n        return head;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* temp=head;\\n        int length=0;\\n        while(temp){\\n            length++;\\n            temp=temp->next;\\n        }\\n        int k=1, i=1;\\n        while((k*(k+1)/2)<=length){\\n            if(k%2==0){\\n                head=reverseBetween(head, i, i+k-1);\\n            }\\n            i+=k;\\n            k++;\\n        }\\n        if((length-i+1)%2==0){\\n            head=reverseBetween(head, i, length);\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581686,
                "title": "c-brute-force-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<vector<ListNode *>> arr;\\n        \\n        ListNode *p = head;\\n        if(!p)\\n            return p;\\n        \\n        \\n        int c = 0;\\n        \\n        while(p){\\n            c++;\\n            vector<ListNode *> v;\\n            for(int i = 0; i < c && p; i++){\\n                v.push_back(p);\\n                p = p->next;\\n            }\\n\\n            arr.push_back(v);\\n        }\\n        \\n        vector<ListNode *> l;\\n\\n        for(int i = 0; i < arr.size(); i++){\\n\\n            if(arr[i].size() % 2 == 0)\\n                reverse(arr[i].begin(), arr[i].end());\\n            \\n            for(int j = 0; j < arr[i].size(); j++)\\n                l.push_back(arr[i][j]);\\n        }\\n        \\n        for(int i = 1; i < l.size(); i++){\\n            l[i]->next = NULL;\\n            l[i-1]->next = l[i];\\n        }\\n            \\n        return l[0];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<vector<ListNode *>> arr;\\n        \\n        ListNode *p = head;\\n        if(!p)\\n            return p;\\n        \\n        \\n        int c = 0;\\n        \\n        while(p){\\n            c++;\\n            vector<ListNode *> v;\\n            for(int i = 0; i < c && p; i++){\\n                v.push_back(p);\\n                p = p->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1580899,
                "title": "brute-force-well-commented-and-easy-to-understand-java-solution",
                "content": "**Intuition** : we will be Creating a linkedlist (templist say) having all nodes which belongs to a single group (size k) and if k is odd then merge templist and resulting linkedlist directly and if k is even then we will reverse templist first and then merge it with resulting linkedlist.\\n**Approach :**  \\n1. traverse the given list in groups.\\n2. while traversing on a group we will be creating our templist and updating given linkedlist simultaneously.\\n3. Check if the size of the group we traversed was even ? if yes then reverse templist.\\n4. Merge templist and resulting Linkedlist.\\n\\n```\\nclass Solution {\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        //ans is going to be head of our resulting linkedlist\\n        \\n\\n//         adding 1st group nodes to ans and removing them from given list\\n//         1st group only contains head of given linkedlist\\n        ListNode ans=head;  \\n        ListNode temp=head.next;\\n        \\n        head.next=null;\\n        head=temp;\\n        int size=Size(head); //size of given likedlist\\n        \\n        int k=2;  //size of current group \\n        \\n        \\n// this loop will create a linkedlist templist having all nodes of a group (of size k)\\n        while(temp!=null && k<=size){\\n            \\n            ListNode templist=null; \\n            int count=k;\\n            \\n//             adding all nodes of group to templist and removing respective nodes from given linkedlist\\n            while(count-->0){\\n                \\n                templist=addLast(templist,temp.val);  \\n                temp=remFirst(temp);\\n                \\n            }\\n            \\n//             now check if size of group is even then\\n            if(k%2==0){\\n                templist=rev(templist);  //reverse templist\\n            }\\n            \\n            ans= add(ans,templist);  //merge ans and templist \\n            \\n            size-=k;\\n            k++; \\n        }\\n        \\n        size=Size(temp);\\n        if(size%2==0){\\n            temp=rev(temp);\\n        }\\n        ans=add(ans,temp);\\n        return ans;\\n    }\\n    \\n//     Function to determine size of the LinkedList\\n    public int Size(ListNode head){\\n        ListNode temp=head;\\n        int size=0;\\n        while(temp!=null){\\n            temp=temp.next;\\n            size++;\\n        }\\n        return size;\\n    }\\n    \\n//     this Function will add a node(having data val) at the last of linkedlist\\n    public ListNode addLast(ListNode head,int val){\\n        ListNode nn= new ListNode(val);\\n        if(head==null){\\n            return nn;\\n        }\\n        \\n        ListNode temp=head;\\n        \\n        while(temp.next!=null){\\n            temp=temp.next;\\n        }\\n        \\n        temp.next=nn;\\n        return head;\\n    }\\n    \\n    \\n//     this function will remove the first node of the linkedlist\\n    public ListNode remFirst(ListNode head){\\n        ListNode temp=head;\\n        head=head.next;\\n        temp.next=null;\\n        return head;\\n    }\\n    \\n    \\n//     This function will merge two linkedlist\\n    public ListNode add(ListNode list1,ListNode list2){\\n        \\n        ListNode temp=list1;\\n        while(temp.next!=null){\\n            temp=temp.next;\\n        }\\n        temp.next=list2;\\n        return list1;\\n    }\\n    \\n//     this Function will reverse the LinkedList\\n    public ListNode rev(ListNode head){\\n        \\n        ListNode prev=null;\\n        ListNode curr= head;\\n        while(curr!=null){\\n            ListNode currnext=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=currnext;\\n        }\\n        head=prev;\\n        return head;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        //ans is going to be head of our resulting linkedlist\\n        \\n\\n//         adding 1st group nodes to ans and removing them from given list\\n//         1st group only contains head of given linkedlist\\n        ListNode ans=head;  \\n        ListNode temp=head.next;\\n        \\n        head.next=null;\\n        head=temp;\\n        int size=Size(head); //size of given likedlist\\n        \\n        int k=2;  //size of current group \\n        \\n        \\n// this loop will create a linkedlist templist having all nodes of a group (of size k)\\n        while(temp!=null && k<=size){\\n            \\n            ListNode templist=null; \\n            int count=k;\\n            \\n//             adding all nodes of group to templist and removing respective nodes from given linkedlist\\n            while(count-->0){\\n                \\n                templist=addLast(templist,temp.val);  \\n                temp=remFirst(temp);\\n                \\n            }\\n            \\n//             now check if size of group is even then\\n            if(k%2==0){\\n                templist=rev(templist);  //reverse templist\\n            }\\n            \\n            ans= add(ans,templist);  //merge ans and templist \\n            \\n            size-=k;\\n            k++; \\n        }\\n        \\n        size=Size(temp);\\n        if(size%2==0){\\n            temp=rev(temp);\\n        }\\n        ans=add(ans,temp);\\n        return ans;\\n    }\\n    \\n//     Function to determine size of the LinkedList\\n    public int Size(ListNode head){\\n        ListNode temp=head;\\n        int size=0;\\n        while(temp!=null){\\n            temp=temp.next;\\n            size++;\\n        }\\n        return size;\\n    }\\n    \\n//     this Function will add a node(having data val) at the last of linkedlist\\n    public ListNode addLast(ListNode head,int val){\\n        ListNode nn= new ListNode(val);\\n        if(head==null){\\n            return nn;\\n        }\\n        \\n        ListNode temp=head;\\n        \\n        while(temp.next!=null){\\n            temp=temp.next;\\n        }\\n        \\n        temp.next=nn;\\n        return head;\\n    }\\n    \\n    \\n//     this function will remove the first node of the linkedlist\\n    public ListNode remFirst(ListNode head){\\n        ListNode temp=head;\\n        head=head.next;\\n        temp.next=null;\\n        return head;\\n    }\\n    \\n    \\n//     This function will merge two linkedlist\\n    public ListNode add(ListNode list1,ListNode list2){\\n        \\n        ListNode temp=list1;\\n        while(temp.next!=null){\\n            temp=temp.next;\\n        }\\n        temp.next=list2;\\n        return list1;\\n    }\\n    \\n//     this Function will reverse the LinkedList\\n    public ListNode rev(ListNode head){\\n        \\n        ListNode prev=null;\\n        ListNode curr= head;\\n        while(curr!=null){\\n            ListNode currnext=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=currnext;\\n        }\\n        head=prev;\\n        return head;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580446,
                "title": "2074-reverse-nodes-in-even-length-groups",
                "content": "---\\n\\n- Contest - https://leetcode.com/contest/weekly-contest-267/\\n  - Q1 Answer\\n    - https://leetcode.com/problems/time-needed-to-buy-tickets/discuss/1578174/2073.-Time-Needed-to-Buy-Tickets\\n  - Q2 Answer\\n    - below\\n      - https://leetcode.com/problems/reverse-nodes-in-even-length-groups/discuss/1580446/2074.-Reverse-Nodes-in-Even-Length-Groups\\n  - Q3 Answer\\n    - https://leetcode.com/problems/decode-the-slanted-ciphertext/discuss/1588186/2075.-Decode-the-Slanted-Ciphertext\\n\\n---\\n\\nTwo solutions:\\n- Creating intermediate arrays\\n- Without creating intermediate arrays\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Creating intermediate arrays**\\n\\n```\\nvar reverseEvenLengthGroups = function (head) {\\n    let values = [],\\n        temp;\\n\\n    // from linked list, fill into array\\n    temp = head;\\n    while (temp) {\\n        values.push(temp.val);\\n        temp = temp.next;\\n    }\\n\\n    // cut into parts - if length is even (2, 4, 6, .. also last can be even), reverse and overwrite\\n    let n = values.length;\\n    for (let k = 0, count = 1; k < n; k += count, count++) {\\n        let reversePart = values.slice(k, k + count).reverse();\\n        if (reversePart.length % 2 === 0)\\n            for (let i = 0; i < reversePart.length; i++) {\\n                values[k + i] = reversePart[i];\\n            }\\n    }\\n\\n    // from array, fill into linked list\\n    temp = head;\\n    for (let v of values) {\\n        temp.val = v;\\n        temp = temp.next;\\n    }\\n\\n    return head;\\n};\\n```\\n\\n---\\n\\n**Without creating intermediate arrays**\\n\\n```\\nvar reverseEvenLengthGroups = function (head) {\\n    let values = [],\\n        temp;\\n\\n    // from linked list, fill into array\\n    temp = head;\\n    while (temp) {\\n        values.push(temp.val);\\n        temp = temp.next;\\n    }\\n\\n    // take into parts - if length is even (2, 4, 6, .. also last can be even), reverse and overwrite\\n    let n = values.length;\\n    for (let k = 0, count = 1; k < n; k += count, count++) {\\n        let size = Math.min(k + count, n) - k;\\n        if (size % 2 === 0)\\n            for (let i = k, j = k + size - 1; i < j; i++, j--) {\\n                [values[i], values[j]] = [values[j], values[i]];\\n            }\\n    }\\n\\n    // from array, fill into linked list\\n    temp = head;\\n    for (let v of values) {\\n        temp.val = v;\\n        temp = temp.next;\\n    }\\n\\n    return head;\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseEvenLengthGroups = function (head) {\\n    let values = [],\\n        temp;\\n\\n    // from linked list, fill into array\\n    temp = head;\\n    while (temp) {\\n        values.push(temp.val);\\n        temp = temp.next;\\n    }\\n\\n    // cut into parts - if length is even (2, 4, 6, .. also last can be even), reverse and overwrite\\n    let n = values.length;\\n    for (let k = 0, count = 1; k < n; k += count, count++) {\\n        let reversePart = values.slice(k, k + count).reverse();\\n        if (reversePart.length % 2 === 0)\\n            for (let i = 0; i < reversePart.length; i++) {\\n                values[k + i] = reversePart[i];\\n            }\\n    }\\n\\n    // from array, fill into linked list\\n    temp = head;\\n    for (let v of values) {\\n        temp.val = v;\\n        temp = temp.next;\\n    }\\n\\n    return head;\\n};\\n```\n```\\nvar reverseEvenLengthGroups = function (head) {\\n    let values = [],\\n        temp;\\n\\n    // from linked list, fill into array\\n    temp = head;\\n    while (temp) {\\n        values.push(temp.val);\\n        temp = temp.next;\\n    }\\n\\n    // take into parts - if length is even (2, 4, 6, .. also last can be even), reverse and overwrite\\n    let n = values.length;\\n    for (let k = 0, count = 1; k < n; k += count, count++) {\\n        let size = Math.min(k + count, n) - k;\\n        if (size % 2 === 0)\\n            for (let i = k, j = k + size - 1; i < j; i++, j--) {\\n                [values[i], values[j]] = [values[j], values[i]];\\n            }\\n    }\\n\\n    // from array, fill into linked list\\n    temp = head;\\n    for (let v of values) {\\n        temp.val = v;\\n        temp = temp.next;\\n    }\\n\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580441,
                "title": "java-recursive-o-n-in-place-o-1-space",
                "content": "```\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        return rec(0,1,head)[0];\\n    }\\n    private boolean evenNumberGroup = false;\\n    //return {head, tail for rev}\\n    private ListNode[] rec(int i, int group, ListNode currNode){\\n        if(currNode == null) {\\n            evenNumberGroup = i%2==0;\\n            return new ListNode[2];\\n        }\\n        i++;\\n        ListNode[] ret = rec(i%group, group + i/group, currNode.next);\\n        if(i==group)\\n            evenNumberGroup = i%2==0;\\n        if(ret[1]!=null && evenNumberGroup && i!=group ){\\n            currNode.next = ret[1].next;\\n            ret[1].next = currNode;\\n            ret[1] = currNode;\\n            return ret;\\n        }\\n        currNode.next = ret[0];\\n        ret[1]=ret[0]=currNode;\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        return rec(0,1,head)[0];\\n    }\\n    private boolean evenNumberGroup = false;\\n    //return {head, tail for rev}\\n    private ListNode[] rec(int i, int group, ListNode currNode){\\n        if(currNode == null) {\\n            evenNumberGroup = i%2==0;\\n            return new ListNode[2];\\n        }\\n        i++;\\n        ListNode[] ret = rec(i%group, group + i/group, currNode.next);\\n        if(i==group)\\n            evenNumberGroup = i%2==0;\\n        if(ret[1]!=null && evenNumberGroup && i!=group ){\\n            currNode.next = ret[1].next;\\n            ret[1].next = currNode;\\n            ret[1] = currNode;\\n            return ret;\\n        }\\n        currNode.next = ret[0];\\n        ret[1]=ret[0]=currNode;\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580122,
                "title": "2-solution-c-clean-code-with-comment",
                "content": "```\\n//solution 1\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // not effitient solution\\n        // cheating code, convert to array then make linked list again\\n        vector<int> elements;\\n        ListNode* current = head;\\n        while(current != nullptr) {\\n            elements.push_back(current->val);\\n            current = current->next;\\n        }\\n        \\n        vector<int> ans;\\n        int index = 0;\\n        for(int len = 1; len <= elements.size(); len++) {\\n            // end of the current segment \\n            int n = min(index + len, (int)elements.size());\\n            \\n            //trick for last segment...if they have odd then no reverse\\n            //else reversly add the elements to the ans array\\n            if((n-index)%2 == 1) {\\n                for(; index < n && index < elements.size(); index++) \\n                    ans.push_back(elements[index]);\\n            }\\n            else {\\n                for(int i = n-1; i >= index; i--) \\n                    ans.push_back(elements[i]);\\n                index = n;\\n            }\\n        }\\n        \\n        // make linked list from array \\n        head = new ListNode(ans[0]);\\n        current = head;\\n        for(int i = 1; i < ans.size(); i++) {\\n            current->next = new ListNode(ans[i]);\\n            current = current-> next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n\\n\\n//solution 2\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int length = 1;\\n        ListNode* current = head;\\n        while(current != nullptr) {\\n            int count = 0;\\n            ListNode* tmp = current;\\n            stack<int> stk;\\n            while(count != length && current != nullptr) {\\n                count++;\\n                stk.push(current->val);\\n                current = current->next;\\n            }\\n            \\n            if(count%2 == 0) {\\n                while(tmp != current) {\\n                    tmp->val = stk.top();\\n                    stk.pop();\\n                    tmp = tmp->next;\\n                }\\n            }\\n            \\n            length++;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//solution 1\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // not effitient solution\\n        // cheating code, convert to array then make linked list again\\n        vector<int> elements;\\n        ListNode* current = head;\\n        while(current != nullptr) {\\n            elements.push_back(current->val);\\n            current = current->next;\\n        }\\n        \\n        vector<int> ans;\\n        int index = 0;\\n        for(int len = 1; len <= elements.size(); len++) {\\n            // end of the current segment \\n            int n = min(index + len, (int)elements.size());\\n            \\n            //trick for last segment...if they have odd then no reverse\\n            //else reversly add the elements to the ans array\\n            if((n-index)%2 == 1) {\\n                for(; index < n && index < elements.size(); index++) \\n                    ans.push_back(elements[index]);\\n            }\\n            else {\\n                for(int i = n-1; i >= index; i--) \\n                    ans.push_back(elements[i]);\\n                index = n;\\n            }\\n        }\\n        \\n        // make linked list from array \\n        head = new ListNode(ans[0]);\\n        current = head;\\n        for(int i = 1; i < ans.size(); i++) {\\n            current->next = new ListNode(ans[i]);\\n            current = current-> next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n\\n\\n//solution 2\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int length = 1;\\n        ListNode* current = head;\\n        while(current != nullptr) {\\n            int count = 0;\\n            ListNode* tmp = current;\\n            stack<int> stk;\\n            while(count != length && current != nullptr) {\\n                count++;\\n                stk.push(current->val);\\n                current = current->next;\\n            }\\n            \\n            if(count%2 == 0) {\\n                while(tmp != current) {\\n                    tmp->val = stk.top();\\n                    stk.pop();\\n                    tmp = tmp->next;\\n                }\\n            }\\n            \\n            length++;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577570,
                "title": "c-solution-brute-force-o-n-space",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<int>v;\\n        for(;head!=NULL;head=head->next)\\n        {\\n            v.push_back(head->val);\\n        }\\n        int n=v.size();\\n        map<int,vector<int>>mp;\\n        int len=1;\\n        for(int i=0;i<n;i++)\\n        {\\n             if(mp[len].size()==len)\\n            {\\n                len++;\\n            }\\n            mp[len].push_back(v[i]);\\n        }\\n        for(auto &it:mp)\\n        {\\n            if(it.second.size()%2==0)\\n            {\\n                reverse(it.second.begin(),it.second.end());\\n            }\\n        }\\n        ListNode*dummy_node=new ListNode(-1);\\n        ListNode*curr=dummy_node;\\n        for(auto it:mp)\\n        {\\n            for(auto ch:it.second)\\n            {\\n               curr->next=new ListNode(ch);\\n                curr=curr->next;\\n            }\\n        }\\n        return dummy_node->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<int>v;\\n        for(;head!=NULL;head=head->next)\\n        {\\n            v.push_back(head->val);\\n        }\\n        int n=v.size();\\n        map<int,vector<int>>mp;\\n        int len=1;\\n        for(int i=0;i<n;i++)\\n        {\\n             if(mp[len].size()==len)\\n            {\\n                len++;\\n            }\\n            mp[len].push_back(v[i]);\\n        }\\n        for(auto &it:mp)\\n        {\\n            if(it.second.size()%2==0)\\n            {\\n                reverse(it.second.begin(),it.second.end());\\n            }\\n        }\\n        ListNode*dummy_node=new ListNode(-1);\\n        ListNode*curr=dummy_node;\\n        for(auto it:mp)\\n        {\\n            for(auto ch:it.second)\\n            {\\n               curr->next=new ListNode(ch);\\n                curr=curr->next;\\n            }\\n        }\\n        return dummy_node->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577392,
                "title": "easy-to-understand-java-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode prev = new ListNode(0);\\n        prev.next = head;\\n        \\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head;\\n        \\n        int length = 0;\\n        ListNode node = head;\\n        while(node != null) {\\n            node = node.next;\\n            length++;\\n        }\\n        \\n        int currentGroup = 1;\\n        \\n        while(length > 0 ) {\\n            \\n            //next group is not last group, and number of nodes are odd\\n            if (length >= currentGroup && currentGroup % 2 != 0) {\\n                int temp = currentGroup;\\n                while(temp > 0) {\\n                    prev = head;\\n                    head = head.next;\\n                    temp = temp - 1;\\n                }\\n                length = length - currentGroup;\\n                //remining is last group, and number of nodes are odd\\n            } else if (length < currentGroup && length % 2 != 0) {\\n                break;\\n                //next group is even\\n            } else {\\n                ListNode tempNode = reverseList(prev, Math.min(currentGroup, length));\\n                head = tempNode.next;\\n                prev = tempNode;\\n                length = length - currentGroup;\\n            }\\n            \\n            currentGroup++;\\n        }\\n        return dummyHead.next;\\n    }\\n    \\n    \\n    // l >= 2\\n    private ListNode reverseList(ListNode prev, int l) {\\n\\n        ListNode curr = prev.next;\\n        ListNode temp = curr;\\n        \\n        while (curr != null && l > 0) {\\n            ListNode next = curr.next;\\n            \\n            curr.next = prev.next;\\n            prev.next = next;\\n            \\n            \\n            temp.next = next.next;\\n            next.next = curr;\\n\\n            curr = temp.next;\\n            \\n            l = l - 2;\\n        }\\n        \\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode prev = new ListNode(0);\\n        prev.next = head;\\n        \\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head;\\n        \\n        int length = 0;\\n        ListNode node = head;\\n        while(node != null) {\\n            node = node.next;\\n            length++;\\n        }\\n        \\n        int currentGroup = 1;\\n        \\n        while(length > 0 ) {\\n            \\n            //next group is not last group, and number of nodes are odd\\n            if (length >= currentGroup && currentGroup % 2 != 0) {\\n                int temp = currentGroup;\\n                while(temp > 0) {\\n                    prev = head;\\n                    head = head.next;\\n                    temp = temp - 1;\\n                }\\n                length = length - currentGroup;\\n                //remining is last group, and number of nodes are odd\\n            } else if (length < currentGroup && length % 2 != 0) {\\n                break;\\n                //next group is even\\n            } else {\\n                ListNode tempNode = reverseList(prev, Math.min(currentGroup, length));\\n                head = tempNode.next;\\n                prev = tempNode;\\n                length = length - currentGroup;\\n            }\\n            \\n            currentGroup++;\\n        }\\n        return dummyHead.next;\\n    }\\n    \\n    \\n    // l >= 2\\n    private ListNode reverseList(ListNode prev, int l) {\\n\\n        ListNode curr = prev.next;\\n        ListNode temp = curr;\\n        \\n        while (curr != null && l > 0) {\\n            ListNode next = curr.next;\\n            \\n            curr.next = prev.next;\\n            prev.next = next;\\n            \\n            \\n            temp.next = next.next;\\n            next.next = curr;\\n\\n            curr = temp.next;\\n            \\n            l = l - 2;\\n        }\\n        \\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577331,
                "title": "python-o-n-time-o-1-space",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\t#helper function which reverses the linked list upto given length\\n        def help(head,n):\\n            a=head\\n            pre=None\\n            cur=head\\n            jam=head\\n            nex=head\\n            while nex and n:\\n                n-=1\\n                cur=nex\\n                nex=nex.next\\n                cur.next=pre\\n                pre=cur\\n            jam.next=nex            \\n            return cur\\n\\t\\t# traverse through the linked list and if its odd do nothing else call helper function\\n        le=0\\n        b=head\\n        while b:#length of complete linked list\\n            le+=1\\n            b=b.next\\n        cc=1\\n        ss=0\\n        r=head\\n        par=None\\n        opp=le\\n        while ss<=opp-1 and r:#while we reach the end\\n            if cc%2!=0:#if odd traverse the linked lisst normally\\n                op=cc\\n                while op and r:\\n                    par=r\\n                    r=r.next\\n                    op-=1\\n            else:    #else call helper function and reverse\\n                par.next=help(r,cc)\\n                op=cc            \\n                while op and par:\\n                    par=par.next            \\n                    op-=1\\n                r=par.next\\n            if ss==opp-1:\\n                break\\n            le-=cc\\n            cc+=1\\n            if le<cc:#if we got the number as 4 but we only have 2 left then we need to reverse the 2 nodes this helps to solve that edge case\\n                cc=le\\n            ss+=cc\\n        return head\\n                \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\t#helper function which reverses the linked list upto given length\\n        def help(head,n):\\n            a=head\\n            pre=None\\n            cur=head\\n            jam=head\\n            nex=head\\n            while nex and n:\\n                n-=1\\n                cur=nex\\n                nex=nex.next\\n                cur.next=pre\\n                pre=cur\\n            jam.next=nex            \\n            return cur\\n\\t\\t# traverse through the linked list and if its odd do nothing else call helper function\\n        le=0\\n        b=head\\n        while b:#length of complete linked list\\n            le+=1\\n            b=b.next\\n        cc=1\\n        ss=0\\n        r=head\\n        par=None\\n        opp=le\\n        while ss<=opp-1 and r:#while we reach the end\\n            if cc%2!=0:#if odd traverse the linked lisst normally\\n                op=cc\\n                while op and r:\\n                    par=r\\n                    r=r.next\\n                    op-=1\\n            else:    #else call helper function and reverse\\n                par.next=help(r,cc)\\n                op=cc            \\n                while op and par:\\n                    par=par.next            \\n                    op-=1\\n                r=par.next\\n            if ss==opp-1:\\n                break\\n            le-=cc\\n            cc+=1\\n            if le<cc:#if we got the number as 4 but we only have 2 left then we need to reverse the 2 nodes this helps to solve that edge case\\n                cc=le\\n            ss+=cc\\n        return head\\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577047,
                "title": "easy-commented-cpp-solution",
                "content": "The idea is to keep a running `curGrpSize` which keeps the current size and compare it to `grpSize` (which keeps the natural number to corresponding to the required size for the current grp).\\nEach grp will begin from `l->next` and end at `r.`\\nAs the `grpSize == curGrpSize`, we check if grpSize is even. If it is even, we reverse the grp using revList method, otherwise we move to the next grp.\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n    // method to reverse List, returns [head, tail];\\n    vector<ListNode*> revList(ListNode* head){\\n        ListNode* prev = NULL, * curr = head, *nxt = NULL;\\n        while(curr){\\n            nxt = curr -> next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nxt;\\n        }\\n        return {prev, head};\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // grpSize will keep the Natural Number, which should be the size of the grp\\n        int grpSize = 1;\\n        // curGrpSize will keep the current size\\n        int curGrpSize = 1;\\n        // dummy will help in flipping from the next node if necessary\\n        ListNode* dummy = new ListNode();\\n        dummy->next = head;\\n        // The grp will start from l->next and end at r.\\n        ListNode* l = dummy, *r = head;\\n        while(r){\\n            // if the grp is even and has ended\\n            if(curGrpSize == grpSize and grpSize%2 == 0){\\n                // save imp pointers before flipping grp\\n                ListNode* tempHead = l->next;\\n                ListNode* tempLastNext = r->next;\\n                // make r pointer of grp as null so that reversing stops there\\n                r->next = NULL;\\n                // reverse the grp\\n                vector<ListNode*> nodes = revList(tempHead);\\n                // reconnect necessary pointers\\n                l->next = nodes[0];\\n                nodes[1]->next = tempLastNext;\\n                // prepare for next grp\\n                l =  nodes[1];\\n                r =  nodes[1]->next;\\n                grpSize++;\\n                curGrpSize = 1;\\n            }\\n            // if a grp has ended, but is odd\\n            else if(curGrpSize == grpSize){\\n                l = r;\\n                r = r->next;\\n                grpSize++;\\n                curGrpSize = 1;\\n            }\\n            // if a grp has not ended\\n            else{\\n                r = r->next;\\n                curGrpSize++;\\n            }\\n        }\\n        \\n        // if the last group is less than its Natural Number size, but is even.\\n        if((curGrpSize-1)%2 == 0){\\n            if(!l) return head;\\n            vector<ListNode*> nodes = revList(l -> next);\\n            l->next = nodes[0];\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    // method to reverse List, returns [head, tail];\\n    vector<ListNode*> revList(ListNode* head){\\n        ListNode* prev = NULL, * curr = head, *nxt = NULL;\\n        while(curr){\\n            nxt = curr -> next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nxt;\\n        }\\n        return {prev, head};\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        // grpSize will keep the Natural Number, which should be the size of the grp\\n        int grpSize = 1;\\n        // curGrpSize will keep the current size\\n        int curGrpSize = 1;\\n        // dummy will help in flipping from the next node if necessary\\n        ListNode* dummy = new ListNode();\\n        dummy->next = head;\\n        // The grp will start from l->next and end at r.\\n        ListNode* l = dummy, *r = head;\\n        while(r){\\n            // if the grp is even and has ended\\n            if(curGrpSize == grpSize and grpSize%2 == 0){\\n                // save imp pointers before flipping grp\\n                ListNode* tempHead = l->next;\\n                ListNode* tempLastNext = r->next;\\n                // make r pointer of grp as null so that reversing stops there\\n                r->next = NULL;\\n                // reverse the grp\\n                vector<ListNode*> nodes = revList(tempHead);\\n                // reconnect necessary pointers\\n                l->next = nodes[0];\\n                nodes[1]->next = tempLastNext;\\n                // prepare for next grp\\n                l =  nodes[1];\\n                r =  nodes[1]->next;\\n                grpSize++;\\n                curGrpSize = 1;\\n            }\\n            // if a grp has ended, but is odd\\n            else if(curGrpSize == grpSize){\\n                l = r;\\n                r = r->next;\\n                grpSize++;\\n                curGrpSize = 1;\\n            }\\n            // if a grp has not ended\\n            else{\\n                r = r->next;\\n                curGrpSize++;\\n            }\\n        }\\n        \\n        // if the last group is less than its Natural Number size, but is even.\\n        if((curGrpSize-1)%2 == 0){\\n            if(!l) return head;\\n            vector<ListNode*> nodes = revList(l -> next);\\n            l->next = nodes[0];\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577010,
                "title": "javascript-simple-value-change",
                "content": "```javascript\\nvar reverseEvenLengthGroups = function(head) {\\n    const headNode = new ListNode(0, head);\\n    let prev = headNode;\\n    let group = 0;\\n    while (prev.next) {\\n        group++;\\n        const values = [];\\n        let start = prev\\n        for (let count = 0; count < group && start.next; count++) {\\n            start = start.next;\\n            values.push(start.val);\\n        }\\n        if (values.length % 2 === 0) {\\n            start = prev;\\n            for (let count = 0; count < group && start.next; count++) {\\n                start = start.next;\\n                start.val = values.pop();\\n            }\\n        }\\n        for (let count = 0; count < group && prev.next; count++) {\\n            prev = prev.next;\\n        }\\n    }\\n    return headNode.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar reverseEvenLengthGroups = function(head) {\\n    const headNode = new ListNode(0, head);\\n    let prev = headNode;\\n    let group = 0;\\n    while (prev.next) {\\n        group++;\\n        const values = [];\\n        let start = prev\\n        for (let count = 0; count < group && start.next; count++) {\\n            start = start.next;\\n            values.push(start.val);\\n        }\\n        if (values.length % 2 === 0) {\\n            start = prev;\\n            for (let count = 0; count < group && start.next; count++) {\\n                start = start.next;\\n                start.val = values.pop();\\n            }\\n        }\\n        for (let count = 0; count < group && prev.next; count++) {\\n            prev = prev.next;\\n        }\\n    }\\n    return headNode.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576995,
                "title": "python3-reversing-slices",
                "content": "We change the linked list into normal list.\\nWe reverse the groups in the list.\\nWe create a new linked list and return the head.\\nTime is O(N). \\nSpace is O(N).\\n```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        nodes=[]\\n        node=head\\n        while node:\\n            nodes.append(node.val)\\n            node=node.next\\n        n=len(nodes)\\n        i=0\\n        j=1\\n        while i<n:\\n            if j%2==0 and i+j<=n or 0==(n-i)%2 and n-i<j:\\n                nodes[i:i+j]=nodes[i:i+j][::-1]\\n            i+=j\\n            j+=1\\n        \\n        newHead=ListNode(nodes[0])\\n        node=newHead\\n        for x in nodes[1:]:\\n            node.next=ListNode(x)\\n            node=node.next    \\n        \\n        return newHead\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        nodes=[]\\n        node=head\\n        while node:\\n            nodes.append(node.val)\\n            node=node.next\\n        n=len(nodes)\\n        i=0\\n        j=1\\n        while i<n:\\n            if j%2==0 and i+j<=n or 0==(n-i)%2 and n-i<j:\\n                nodes[i:i+j]=nodes[i:i+j][::-1]\\n            i+=j\\n            j+=1\\n        \\n        newHead=ListNode(nodes[0])\\n        node=newHead\\n        for x in nodes[1:]:\\n            node.next=ListNode(x)\\n            node=node.next    \\n        \\n        return newHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576945,
                "title": "python-solution-using-group-dictionary",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    \\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        group_dict = defaultdict(list)\\n        temp = head\\n        group = 1\\n        count = 0\\n        while temp:\\n            group_dict[group].append(temp)\\n            temp = temp.next\\n            count+=1\\n            if count % group == 0:\\n                count = 0\\n                group+= 1\\n        head = None\\n        curr = None\\n        for i in range(1, group+1):\\n            if i == 1:\\n                head = group_dict[i][0]\\n                head.next = None\\n                curr = head\\n                continue\\n            lst = group_dict[i]\\n            if len(lst) % 2 == 0:\\n                lst.reverse()\\n            for root  in lst:\\n                curr.next = root\\n                curr = root\\n            curr.next = None\\n                \\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    \\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        group_dict = defaultdict(list)\\n        temp = head\\n        group = 1\\n        count = 0\\n        while temp:\\n            group_dict[group].append(temp)\\n            temp = temp.next\\n            count+=1\\n            if count % group == 0:\\n                count = 0\\n                group+= 1\\n        head = None\\n        curr = None\\n        for i in range(1, group+1):\\n            if i == 1:\\n                head = group_dict[i][0]\\n                head.next = None\\n                curr = head\\n                continue\\n            lst = group_dict[i]\\n            if len(lst) % 2 == 0:\\n                lst.reverse()\\n            for root  in lst:\\n                curr.next = root\\n                curr = root\\n            curr.next = None\\n                \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059620,
                "title": "python-brute-force-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        values = []\\n        grp = 1\\n        itr = head\\n        temp = []\\n        while(itr!=None):\\n            temp.append(itr.val)\\n            if len(temp) == grp:\\n                if len(temp)%2 == 0:\\n                    temp = temp[::-1]\\n                values.append(temp)\\n                grp += 1\\n                temp = []\\n            itr = itr.next\\n        if len(temp)!= 0:\\n            if len(temp)%2 == 0:\\n                temp = temp[::-1]\\n            values.append(temp)\\n        itr = head\\n        for i in values:\\n            for j in i:\\n                itr.val = j\\n                itr = itr.next\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        values = []\\n        grp = 1\\n        itr = head\\n        temp = []\\n        while(itr!=None):\\n            temp.append(itr.val)\\n            if len(temp) == grp:\\n                if len(temp)%2 == 0:\\n                    temp = temp[::-1]\\n                values.append(temp)\\n                grp += 1\\n                temp = []\\n            itr = itr.next\\n        if len(temp)!= 0:\\n            if len(temp)%2 == 0:\\n                temp = temp[::-1]\\n            values.append(temp)\\n        itr = head\\n        for i in values:\\n            for j in i:\\n                itr.val = j\\n                itr = itr.next\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047401,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func reverseEvenLengthGroups(_ head: ListNode?) -> ListNode? {\\n\\n        func reverse(\\n            _ size: Int,\\n            _ tail: ListNode?,\\n            _ begin: ListNode?,\\n            _ end: ListNode?\\n        ) -> ListNode? {\\n            \\n            guard size != 0, size % 2 == 0 else {\\n                return end\\n            }\\n\\n            var prev = begin\\n            var cur = prev?.next\\n\\n            while true {\\n                let next = cur?.next\\n                cur?.next = prev\\n                prev = cur\\n                cur = next\\n\\n                if prev === end {\\n                    break\\n                }\\n            }\\n\\n            tail?.next = prev\\n            begin?.next = cur\\n\\n            return begin\\n        }\\n        \\n        var tail: ListNode?\\n        var begin = head\\n        var end: ListNode?\\n        var cur = head\\n\\n        var target = 1\\n        var size = 0\\n\\n        while true {\\n\\n            if cur != nil {\\n                size += 1\\n                end = cur\\n            }\\n            \\n            if size == target || cur == nil {\\n                tail = reverse(size, tail, begin, end)\\n\\n                cur = tail\\n                begin = cur?.next\\n                end = cur?.next\\n\\n                target += 1\\n                size = 0\\n            }\\n\\n            if cur == nil {\\n                break\\n            }\\n\\n            cur = cur?.next\\n        }\\n\\n        return head\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func reverseEvenLengthGroups(_ head: ListNode?) -> ListNode? {\\n\\n        func reverse(\\n            _ size: Int,\\n            _ tail: ListNode?,\\n            _ begin: ListNode?,\\n            _ end: ListNode?\\n        ) -> ListNode? {\\n            \\n            guard size != 0, size % 2 == 0 else {\\n                return end\\n            }\\n\\n            var prev = begin\\n            var cur = prev?.next\\n\\n            while true {\\n                let next = cur?.next\\n                cur?.next = prev\\n                prev = cur\\n                cur = next\\n\\n                if prev === end {\\n                    break\\n                }\\n            }\\n\\n            tail?.next = prev\\n            begin?.next = cur\\n\\n            return begin\\n        }\\n        \\n        var tail: ListNode?\\n        var begin = head\\n        var end: ListNode?\\n        var cur = head\\n\\n        var target = 1\\n        var size = 0\\n\\n        while true {\\n\\n            if cur != nil {\\n                size += 1\\n                end = cur\\n            }\\n            \\n            if size == target || cur == nil {\\n                tail = reverse(size, tail, begin, end)\\n\\n                cur = tail\\n                begin = cur?.next\\n                end = cur?.next\\n\\n                target += 1\\n                size = 0\\n            }\\n\\n            if cur == nil {\\n                break\\n            }\\n\\n            cur = cur?.next\\n        }\\n\\n        return head\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042361,
                "title": "java-o-1-space-solution-beats-96",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode oddTail = null, evenTail = null, curr = head;\\n        int currSize = 1;\\n        while (curr != null) {\\n            int mySize = 0;\\n            ListNode dummy = curr;\\n            while (dummy != null && mySize++ < currSize) dummy = dummy.next;\\n            if (mySize < currSize) currSize = mySize;\\n            if ((currSize & 1) == 1) {\\n                for (int i = 0; i < currSize; i++) {\\n                    if (i == currSize - 1) oddTail = curr;\\n                    curr = curr.next;\\n                }\\n            } else {\\n                evenTail = curr;\\n                ListNode prev = null;\\n                for (int i = 0; i < currSize && curr != null; i++) {\\n                    ListNode temp = curr.next;\\n                    curr.next = prev;\\n                    prev = curr;\\n                    curr = temp;\\n                }\\n                oddTail.next = prev;\\n                evenTail.next = curr;\\n                oddTail = evenTail;\\n            }\\n            currSize++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode oddTail = null, evenTail = null, curr = head;\\n        int currSize = 1;\\n        while (curr != null) {\\n            int mySize = 0;\\n            ListNode dummy = curr;\\n            while (dummy != null && mySize++ < currSize) dummy = dummy.next;\\n            if (mySize < currSize) currSize = mySize;\\n            if ((currSize & 1) == 1) {\\n                for (int i = 0; i < currSize; i++) {\\n                    if (i == currSize - 1) oddTail = curr;\\n                    curr = curr.next;\\n                }\\n            } else {\\n                evenTail = curr;\\n                ListNode prev = null;\\n                for (int i = 0; i < currSize && curr != null; i++) {\\n                    ListNode temp = curr.next;\\n                    curr.next = prev;\\n                    prev = curr;\\n                    curr = temp;\\n                }\\n                oddTail.next = prev;\\n                evenTail.next = curr;\\n                oddTail = evenTail;\\n            }\\n            currSize++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038421,
                "title": "python3-straightforward-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst = []\\n        while head != None:\\n            lst.append(head.val)\\n            head = head.next\\n        N = len(lst)\\n        groups = []\\n        size = 1\\n        i = 0\\n        while i+size < N:\\n            tmp = []\\n            for j in range(i, size+i):\\n                tmp.append(lst[j])\\n            groups.append(tmp)\\n            i += size\\n            size += 1\\n        tmp = []\\n        for j in range(i, N):\\n            tmp.append(lst[j])\\n        groups.append(tmp)\\n\\n        ans = []\\n        for i, g in enumerate(groups):\\n            if len(g)%2==0:\\n                for j in range(len(g)-1, -1, -1):\\n                    ans.append(g[j])\\n            else:\\n                for j in range(len(g)):\\n                    ans.append(g[j])\\n\\n        root = ListNode(ans[0])\\n        prev = root\\n        for i in range(1, len(ans)):\\n            tmp = ListNode(ans[i])\\n            prev.next = tmp\\n            prev = tmp\\n\\n        return root\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst = []\\n        while head != None:\\n            lst.append(head.val)\\n            head = head.next\\n        N = len(lst)\\n        groups = []\\n        size = 1\\n        i = 0\\n        while i+size < N:\\n            tmp = []\\n            for j in range(i, size+i):\\n                tmp.append(lst[j])\\n            groups.append(tmp)\\n            i += size\\n            size += 1\\n        tmp = []\\n        for j in range(i, N):\\n            tmp.append(lst[j])\\n        groups.append(tmp)\\n\\n        ans = []\\n        for i, g in enumerate(groups):\\n            if len(g)%2==0:\\n                for j in range(len(g)-1, -1, -1):\\n                    ans.append(g[j])\\n            else:\\n                for j in range(len(g)):\\n                    ans.append(g[j])\\n\\n        root = ListNode(ans[0])\\n        prev = root\\n        for i in range(1, len(ans)):\\n            tmp = ListNode(ans[i])\\n            prev.next = tmp\\n            prev = tmp\\n\\n        return root\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013470,
                "title": "c-c-iterative-one-pass-solution-with-five-pointers-95-time-complexity",
                "content": "Idea is very similar to solving [#25: Reverse nodes in k-group](https://leetcode.com/problems/reverse-nodes-in-k-group/). You only need five pointers to solve this problem. In the worst case, each node is traversed twice since you do not know the length of the next segment prior to visiting the node once.\\n\\n```\\nclass Solution {\\nprivate:\\n    ListNode *prev, *node, *next, *beforeprev;\\n    void reverseGroup(ListNode* beforeprev, ListNode* last, int k) {\\n        prev = beforeprev;\\n        node = prev->next;\\n        next = node->next;\\n        for (int i = 0; i < k - 1; i++) {\\n            node->next = prev;\\n            prev = node;\\n            node = next;\\n            next = node ? next->next : next;\\n        }\\n        node->next = prev;\\n        prev = node;\\n        node = next;\\n        beforeprev->next->next = last;\\n        beforeprev->next = prev;\\n    }\\n    \\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        node = head;\\n        int n = 2;\\n        while (node->next) {\\n            beforeprev = node;\\n            int i = 0;\\n            for (; i < n && node->next; i++) {\\n                node = node->next;\\n            }\\n            if (i % 2 == 0) {\\n                ListNode *save = beforeprev->next;\\n                reverseGroup(beforeprev, node ? node->next : 0, i);\\n                node = save;\\n            }\\n            n++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    ListNode *prev, *node, *next, *beforeprev;\\n    void reverseGroup(ListNode* beforeprev, ListNode* last, int k) {\\n        prev = beforeprev;\\n        node = prev->next;\\n        next = node->next;\\n        for (int i = 0; i < k - 1; i++) {\\n            node->next = prev;\\n            prev = node;\\n            node = next;\\n            next = node ? next->next : next;\\n        }\\n        node->next = prev;\\n        prev = node;\\n        node = next;\\n        beforeprev->next->next = last;\\n        beforeprev->next = prev;\\n    }\\n    \\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        node = head;\\n        int n = 2;\\n        while (node->next) {\\n            beforeprev = node;\\n            int i = 0;\\n            for (; i < n && node->next; i++) {\\n                node = node->next;\\n            }\\n            if (i % 2 == 0) {\\n                ListNode *save = beforeprev->next;\\n                reverseGroup(beforeprev, node ? node->next : 0, i);\\n                node = save;\\n            }\\n            n++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012613,
                "title": "reverse-list-in-groups-of-k-method",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findSize(ListNode *head){\\n        int ct=0;\\n        while(head) {\\n            head=head->next;\\n            ct++;\\n        }\\n        return ct;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(!head) return head;\\n        ListNode *dummy = new ListNode(-100);\\n        dummy->next=head;\\n        ListNode *prev=dummy,*curr;\\n        \\n        int size = findSize(head);\\n        \\n        for(int i=1,ct=1;i<size;i+=ct-1){\\n            curr=prev->next;\\n            // cout<<i<<\" \";\\n            for(int j=0;j<ct-1;j++){\\n                if(ct%2==0 and i+ct-1<size){\\n                    ListNode *nxt = curr->next;\\n                    curr->next = nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                }\\n                else if(i+ct-1>=size){\\n                    int sz = findSize(curr);\\n                    // cout<<sz;\\n                    if(sz%2==0){\\n                        while(curr->next){\\n                            ListNode *nxt = curr->next;\\n                            curr->next = nxt->next;\\n                            nxt->next=prev->next;\\n                            prev->next=nxt;\\n                        }\\n                    }\\n                    else break;\\n                }\\n                else curr=curr->next;\\n            }\\n            \\n            prev=curr;\\n            ct++;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findSize(ListNode *head){\\n        int ct=0;\\n        while(head) {\\n            head=head->next;\\n            ct++;\\n        }\\n        return ct;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(!head) return head;\\n        ListNode *dummy = new ListNode(-100);\\n        dummy->next=head;\\n        ListNode *prev=dummy,*curr;\\n        \\n        int size = findSize(head);\\n        \\n        for(int i=1,ct=1;i<size;i+=ct-1){\\n            curr=prev->next;\\n            // cout<<i<<\" \";\\n            for(int j=0;j<ct-1;j++){\\n                if(ct%2==0 and i+ct-1<size){\\n                    ListNode *nxt = curr->next;\\n                    curr->next = nxt->next;\\n                    nxt->next=prev->next;\\n                    prev->next=nxt;\\n                }\\n                else if(i+ct-1>=size){\\n                    int sz = findSize(curr);\\n                    // cout<<sz;\\n                    if(sz%2==0){\\n                        while(curr->next){\\n                            ListNode *nxt = curr->next;\\n                            curr->next = nxt->next;\\n                            nxt->next=prev->next;\\n                            prev->next=nxt;\\n                        }\\n                    }\\n                    else break;\\n                }\\n                else curr=curr->next;\\n            }\\n            \\n            prev=curr;\\n            ct++;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3986533,
                "title": "readable-ruby-solution-reverse-even-length-groups-in-o-n-time-o-1-space",
                "content": "# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val = 0, _next = nil)\\n#         @val = val\\n#         @next = _next\\n#     end\\n# end\\n# @param {ListNode} head\\n# @return {ListNode}\\ndef reverse_even_length_groups(head)\\n    return head if !head.next || !head.next.next\\n\\n    select = head\\n    group = 1\\n    while select && select.next\\n        group += 1\\n\\n        # Check number of nodes\\n        count = 0\\n        temp = select.next\\n        while temp && count < group\\n            temp = temp.next\\n            count += 1\\n        end\\n\\n        # IF event THEN reverse\\n        if count % 2 == 0\\n            curr = select.next\\n            prev = nil\\n            for i in 0...count\\n                next_node = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = next_node\\n            end\\n\\n            tail = select.next\\n            tail.next = curr\\n            select.next = prev\\n            select = tail\\n        else\\n            for i in 0...count\\n                select = select.next\\n            end\\n        end\\n    end\\n    head\\n    # Time Complexity: O(n)\\n    # Space Complexity: O(1)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val = 0, _next = nil)\\n#         @val = val\\n#         @next = _next\\n#     end\\n# end\\n# @param {ListNode} head\\n# @return {ListNode}\\ndef reverse_even_length_groups(head)\\n    return head if !head.next || !head.next.next\\n\\n    select = head\\n    group = 1\\n    while select && select.next\\n        group += 1\\n\\n        # Check number of nodes\\n        count = 0\\n        temp = select.next\\n        while temp && count < group\\n            temp = temp.next\\n            count += 1\\n        end\\n\\n        # IF event THEN reverse\\n        if count % 2 == 0\\n            curr = select.next\\n            prev = nil\\n            for i in 0...count\\n                next_node = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = next_node\\n            end\\n\\n            tail = select.next\\n            tail.next = curr\\n            select.next = prev\\n            select = tail\\n        else\\n            for i in 0...count\\n                select = select.next\\n            end\\n        end\\n    end\\n    head\\n    # Time Complexity: O(n)\\n    # Space Complexity: O(1)\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986487,
                "title": "readable-typescript-solution-reverse-even-length-groups-in-o-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction reverseEvenLengthGroups(head: ListNode | null): ListNode | null {\\n    if (!head.next || !head.next.next) return head;\\n    \\n    let select = head;\\n    let group = 1;\\n    while (select && select.next) {\\n        group++;\\n\\n        // Check number of nodes\\n        let count = 0;\\n        let temp = select.next;\\n        while (temp && count < group) {\\n            temp = temp.next\\n            count++;\\n        }\\n\\n        // IF even THEN reverse\\n        if (count % 2 === 0) {\\n            let curr = select.next;\\n            let prev = null;\\n            for (let i = 0; i < count; i++) {\\n                const nextNode = curr.next;\\n                curr.next = prev;\\n                prev = curr;\\n                curr = nextNode;\\n            }\\n\\n            let tail = select.next;\\n            tail.next = curr;\\n            select.next = prev;\\n            select = tail;\\n        } else {\\n            for (let i = 0; i < count; i++) {\\n                select = select.next;\\n            }\\n        }\\n    }\\n    return head;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction reverseEvenLengthGroups(head: ListNode | null): ListNode | null {\\n    if (!head.next || !head.next.next) return head;\\n    \\n    let select = head;\\n    let group = 1;\\n    while (select && select.next) {\\n        group++;\\n\\n        // Check number of nodes\\n        let count = 0;\\n        let temp = select.next;\\n        while (temp && count < group) {\\n            temp = temp.next\\n            count++;\\n        }\\n\\n        // IF even THEN reverse\\n        if (count % 2 === 0) {\\n            let curr = select.next;\\n            let prev = null;\\n            for (let i = 0; i < count; i++) {\\n                const nextNode = curr.next;\\n                curr.next = prev;\\n                prev = curr;\\n                curr = nextNode;\\n            }\\n\\n            let tail = select.next;\\n            tail.next = curr;\\n            select.next = prev;\\n            select = tail;\\n        } else {\\n            for (let i = 0; i < count; i++) {\\n                select = select.next;\\n            }\\n        }\\n    }\\n    return head;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984990,
                "title": "c-simple-implementation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseNode(ListNode*head){\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        ListNode* nxt=head->next;\\n        while(curr!=NULL){\\n            nxt=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nxt;\\n        }\\n        //setting head of reversed node\\n        return prev;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head==NULL||head->next==NULL){\\n            return head;\\n        }\\n        int group=1;\\n        ListNode* t1=head;\\n        ListNode* t2=head;\\n        //here prev and nxr refers to different context\\n        ListNode* prev=head;\\n        ListNode* nxt=head->next;\\n        ListNode* revHead=NULL;\\n        while(t1!=NULL&&t2!=NULL){\\n            if(group%2==0){\\n                //then we have to reverse it \\n                int count=1;\\n                while(t2->next!=NULL&&count!=group){\\n                    t2=t2->next;\\n                    count++;\\n                }\\n                //reverse only if in even group node\\'s length is even\\n                if(count%2==0){\\n                //storing addres of t2\\'s next group\\n                nxt=t2->next;\\n                //reverse nodes from t1 to t2\\n                t2->next=NULL;\\n                revHead=reverseNode(t1);\\n                //t1 holds head of reversed list\\n                //conneting the nodes\\n                prev->next->next=nxt;\\n                prev->next=revHead;  \\n                prev=t1;\\n                }\\n                else{\\n                    //changing prev position\\n                    prev=t2;\\n                    nxt=t2->next;                    \\n                }\\n            }else{\\n                //check if group lenght is even then only reverse it\\n                int count=1;\\n                while(t2->next!=NULL&&count!=group){\\n                    t2=t2->next;\\n                    count++;\\n                }\\n                if(count%2==0){\\n                    //its means group length is still even so reverse it\\n                     //storing addres of t2\\'s next group\\n                    nxt=t2->next;\\n                    //reverse nodes from t1 to t2\\n                    t2->next=NULL;\\n                    revHead=reverseNode(t1);\\n                //t1 holds head of reversed list\\n                //conneting the nodes\\n                prev->next->next=nxt;\\n                prev->next=revHead;  \\n                prev=t1;\\n                }else{\\n                    //changing prev position\\n                    prev=t2;\\n                    nxt=t2->next;\\n                }\\n            }\\n            t1=nxt;\\n            t2=nxt;\\n            group++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseNode(ListNode*head){\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        ListNode* nxt=head->next;\\n        while(curr!=NULL){\\n            nxt=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nxt;\\n        }\\n        //setting head of reversed node\\n        return prev;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head==NULL||head->next==NULL){\\n            return head;\\n        }\\n        int group=1;\\n        ListNode* t1=head;\\n        ListNode* t2=head;\\n        //here prev and nxr refers to different context\\n        ListNode* prev=head;\\n        ListNode* nxt=head->next;\\n        ListNode* revHead=NULL;\\n        while(t1!=NULL&&t2!=NULL){\\n            if(group%2==0){\\n                //then we have to reverse it \\n                int count=1;\\n                while(t2->next!=NULL&&count!=group){\\n                    t2=t2->next;\\n                    count++;\\n                }\\n                //reverse only if in even group node\\'s length is even\\n                if(count%2==0){\\n                //storing addres of t2\\'s next group\\n                nxt=t2->next;\\n                //reverse nodes from t1 to t2\\n                t2->next=NULL;\\n                revHead=reverseNode(t1);\\n                //t1 holds head of reversed list\\n                //conneting the nodes\\n                prev->next->next=nxt;\\n                prev->next=revHead;  \\n                prev=t1;\\n                }\\n                else{\\n                    //changing prev position\\n                    prev=t2;\\n                    nxt=t2->next;                    \\n                }\\n            }else{\\n                //check if group lenght is even then only reverse it\\n                int count=1;\\n                while(t2->next!=NULL&&count!=group){\\n                    t2=t2->next;\\n                    count++;\\n                }\\n                if(count%2==0){\\n                    //its means group length is still even so reverse it\\n                     //storing addres of t2\\'s next group\\n                    nxt=t2->next;\\n                    //reverse nodes from t1 to t2\\n                    t2->next=NULL;\\n                    revHead=reverseNode(t1);\\n                //t1 holds head of reversed list\\n                //conneting the nodes\\n                prev->next->next=nxt;\\n                prev->next=revHead;  \\n                prev=t1;\\n                }else{\\n                    //changing prev position\\n                    prev=t2;\\n                    nxt=t2->next;\\n                }\\n            }\\n            t1=nxt;\\n            t2=nxt;\\n            group++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976647,
                "title": "java-o-n-solution",
                "content": "# Intuition\\nI used ArrayList\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        List<Integer> list = new ArrayList<>();\\n        ListNode temp = head;\\n        while (temp != null) {\\n            list.add(temp.val);\\n            temp = temp.next;\\n        }\\n        int idx = 0, count = 0;\\n        while (idx < list.size()) {\\n            if ((Math.min(idx + count, list.size() - 1) - idx) % 2 == 1)\\n                reverse(list, idx, Math.min(idx + count, list.size() - 1));\\n            idx += count + 1;\\n            count++;\\n        }\\n        temp = head;\\n        count = 0;\\n        while (temp != null) {\\n            temp.val = list.get(count++);\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n\\n    private static void reverse(List<Integer> list, int l, int r) {\\n        for (int i = l, k = 0; i <= (r + l) / 2; i++) {\\n            int t = list.get(r - k);\\n            list.set(r - k++, list.get(i));\\n            list.set(i, t);\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        List<Integer> list = new ArrayList<>();\\n        ListNode temp = head;\\n        while (temp != null) {\\n            list.add(temp.val);\\n            temp = temp.next;\\n        }\\n        int idx = 0, count = 0;\\n        while (idx < list.size()) {\\n            if ((Math.min(idx + count, list.size() - 1) - idx) % 2 == 1)\\n                reverse(list, idx, Math.min(idx + count, list.size() - 1));\\n            idx += count + 1;\\n            count++;\\n        }\\n        temp = head;\\n        count = 0;\\n        while (temp != null) {\\n            temp.val = list.get(count++);\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n\\n    private static void reverse(List<Integer> list, int l, int r) {\\n        for (int i = l, k = 0; i <= (r + l) / 2; i++) {\\n            int t = list.get(r - k);\\n            list.set(r - k++, list.get(i));\\n            list.set(i, t);\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964587,
                "title": "java-beats-96-o-n-time-o-1-space-simple-solution",
                "content": "# Intuition\\nI think is HARD problem.\\nComing up with the logic of the solution is quite easy. It all consists in implementing the reversal of the linked list with the input: head, tail and the previous element behind the head\\nThe difficulty lies in writing the algorithm itself and handling the edge cases\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: (1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null) return head;\\n        ListNode node = head;\\n        ListNode temp = head;\\n        int i = 2;\\n        int ind = 0;\\n        while (node.next != null) {\\n            node = temp;\\n            ind = 0;\\n            while (ind < i && node.next != null) {\\n                node = node.next;\\n                ind++;\\n            }\\n            if ((i % 2 == 0 && node.next != null) || (node.next == null && ind % 2 == 0)) {\\n                ListNode temp1 = temp.next;\\n                temp.next = reverse(temp1, node, node.next);\\n                temp = temp1;\\n            } else if (node.next != null) {\\n                temp = node;\\n            }\\n            i++;\\n        }\\n        return head;\\n    }\\n\\n    private ListNode reverse(ListNode head, ListNode tail, ListNode prev1) {\\n        if (head == null) return head;\\n        ListNode prev = prev1;\\n        ListNode curr = head;\\n        ListNode next = curr.next == null ? null : curr.next;\\n        while (curr != tail) {\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            next = next.next == null ? null : next.next;\\n        }\\n        curr.next = prev;\\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null) return head;\\n        ListNode node = head;\\n        ListNode temp = head;\\n        int i = 2;\\n        int ind = 0;\\n        while (node.next != null) {\\n            node = temp;\\n            ind = 0;\\n            while (ind < i && node.next != null) {\\n                node = node.next;\\n                ind++;\\n            }\\n            if ((i % 2 == 0 && node.next != null) || (node.next == null && ind % 2 == 0)) {\\n                ListNode temp1 = temp.next;\\n                temp.next = reverse(temp1, node, node.next);\\n                temp = temp1;\\n            } else if (node.next != null) {\\n                temp = node;\\n            }\\n            i++;\\n        }\\n        return head;\\n    }\\n\\n    private ListNode reverse(ListNode head, ListNode tail, ListNode prev1) {\\n        if (head == null) return head;\\n        ListNode prev = prev1;\\n        ListNode curr = head;\\n        ListNode next = curr.next == null ? null : curr.next;\\n        while (curr != tail) {\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            next = next.next == null ? null : next.next;\\n        }\\n        curr.next = prev;\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960822,
                "title": "don-t-use-this-code-don-t",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI am speechless, 3 - 4 hours... I am glad I kept with it but whatever you do. Don\\'t try to understand it. I was so stubborn I didn\\'t want to look up the right way to do it so I just kept trying and trying.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode * dummy = new ListNode(0, head);\\n        ListNode * curr = dummy->next;\\n        ListNode * prevNode = nullptr;\\n        ListNode * prevprevNode = nullptr;\\n\\n        int index, nodesAccessed = 0;\\n        int needToBeAcessed = 1;\\n        int groupCount = 0;\\n\\n        bool checking = false;\\n        int checkingInt = 0;\\n\\n\\n        while(curr != nullptr)\\n        {\\n            if(nodesAccessed == needToBeAcessed)\\n            {\\n\\n                ListNode * prev = nullptr;\\n                ListNode * firstNode = nullptr;\\n\\n                if(curr->next != nullptr) firstNode = curr;\\n\\n                for(int i = 0; i < (nodesAccessed + 1); i++)\\n                {\\n                    checkingInt++;\\n                    if(curr == nullptr){\\n                        checking = true;\\n                        break;\\n                    } \\n                    ListNode* nextNode = curr->next; \\n                    curr->next = prev;            \\n                    prev = curr;                   \\n                    curr = nextNode;                \\n                }\\n\\n                \\n\\n                prevNode->next = prev;\\n                if(firstNode != nullptr && curr != nullptr) firstNode->next = curr;\\n                nodesAccessed = 0; groupCount = 0; needToBeAcessed += 2; \\n\\n                if(checking != true) checkingInt = 0;\\n                if(checking != true) groupCount = 0;\\n\\n\\n            }\\n\\n            nodesAccessed++;\\n            groupCount++;\\n\\n            index++;\\n            prevNode = curr;\\n\\n            if(curr != nullptr) curr = curr->next;\\n        }\\n\\n        if(groupCount % 2 == 0)\\n        {\\n            ListNode * first = head;\\n\\n            for(int i = 0; i < groupCount + 1; i++)\\n            {\\n                first = first->next;\\n            }\\n\\n            ListNode * second = head;\\n\\n            while(first!=nullptr)\\n            {\\n                first = first->next;\\n                second = second->next;\\n            }\\n\\n\\n            ListNode * curr = second->next;\\n            ListNode * prev = nullptr;\\n\\n            for(int j = 0; j < groupCount; j++)\\n            {\\n                if(curr == nullptr) break;\\n                ListNode* nextNode = curr->next; \\n                curr->next = prev;            \\n                prev = curr;                   \\n                curr = nextNode;   \\n            }\\n\\n            second->next = prev;\\n\\n        }\\n\\n        if(checking == true)\\n        {\\n            if(checkingInt % 2 == 0){\\n\\n\\n                ListNode * first = head;\\n\\n                for(int i = 0; i < checkingInt; i++)\\n                {\\n                    first = first->next;\\n                }\\n\\n                ListNode * second = head;\\n\\n                while(first!=nullptr)\\n                {\\n                    first = first->next;\\n                    second = second->next;\\n                }\\n\\n                ListNode * curr = second->next;\\n                ListNode * prev = nullptr;\\n\\n\\n\\n\\n                \\n\\n                for(int j = 0; j < checkingInt; j++)\\n                {\\n                    if(curr == nullptr) break;\\n                    ListNode* nextNode = curr->next; \\n                    curr->next = prev;            \\n                    prev = curr;                   \\n                    curr = nextNode;   \\n                }\\n                \\n\\n                second->next = prev;\\n            }\\n        }\\n\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode * dummy = new ListNode(0, head);\\n        ListNode * curr = dummy->next;\\n        ListNode * prevNode = nullptr;\\n        ListNode * prevprevNode = nullptr;\\n\\n        int index, nodesAccessed = 0;\\n        int needToBeAcessed = 1;\\n        int groupCount = 0;\\n\\n        bool checking = false;\\n        int checkingInt = 0;\\n\\n\\n        while(curr != nullptr)\\n        {\\n            if(nodesAccessed == needToBeAcessed)\\n            {\\n\\n                ListNode * prev = nullptr;\\n                ListNode * firstNode = nullptr;\\n\\n                if(curr->next != nullptr) firstNode = curr;\\n\\n                for(int i = 0; i < (nodesAccessed + 1); i++)\\n                {\\n                    checkingInt++;\\n                    if(curr == nullptr){\\n                        checking = true;\\n                        break;\\n                    } \\n                    ListNode* nextNode = curr->next; \\n                    curr->next = prev;            \\n                    prev = curr;                   \\n                    curr = nextNode;                \\n                }\\n\\n                \\n\\n                prevNode->next = prev;\\n                if(firstNode != nullptr && curr != nullptr) firstNode->next = curr;\\n                nodesAccessed = 0; groupCount = 0; needToBeAcessed += 2; \\n\\n                if(checking != true) checkingInt = 0;\\n                if(checking != true) groupCount = 0;\\n\\n\\n            }\\n\\n            nodesAccessed++;\\n            groupCount++;\\n\\n            index++;\\n            prevNode = curr;\\n\\n            if(curr != nullptr) curr = curr->next;\\n        }\\n\\n        if(groupCount % 2 == 0)\\n        {\\n            ListNode * first = head;\\n\\n            for(int i = 0; i < groupCount + 1; i++)\\n            {\\n                first = first->next;\\n            }\\n\\n            ListNode * second = head;\\n\\n            while(first!=nullptr)\\n            {\\n                first = first->next;\\n                second = second->next;\\n            }\\n\\n\\n            ListNode * curr = second->next;\\n            ListNode * prev = nullptr;\\n\\n            for(int j = 0; j < groupCount; j++)\\n            {\\n                if(curr == nullptr) break;\\n                ListNode* nextNode = curr->next; \\n                curr->next = prev;            \\n                prev = curr;                   \\n                curr = nextNode;   \\n            }\\n\\n            second->next = prev;\\n\\n        }\\n\\n        if(checking == true)\\n        {\\n            if(checkingInt % 2 == 0){\\n\\n\\n                ListNode * first = head;\\n\\n                for(int i = 0; i < checkingInt; i++)\\n                {\\n                    first = first->next;\\n                }\\n\\n                ListNode * second = head;\\n\\n                while(first!=nullptr)\\n                {\\n                    first = first->next;\\n                    second = second->next;\\n                }\\n\\n                ListNode * curr = second->next;\\n                ListNode * prev = nullptr;\\n\\n\\n\\n\\n                \\n\\n                for(int j = 0; j < checkingInt; j++)\\n                {\\n                    if(curr == nullptr) break;\\n                    ListNode* nextNode = curr->next; \\n                    curr->next = prev;            \\n                    prev = curr;                   \\n                    curr = nextNode;   \\n                }\\n                \\n\\n                second->next = prev;\\n            }\\n        }\\n\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953470,
                "title": "java-use-list-to-reverse-even-group-items",
                "content": "# Intuition\\n# Approach\\n- Traverse linked list for # group items and add into a list\\n- if even items in group, reverse items in list\\n- From start of group node, replace values of node using reversed list\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode curr = head;\\n        int count = 0;\\n        while(curr != null) {\\n            count++;\\n            int i=0;\\n            ListNode start = curr;\\n            List<Integer> nums = new ArrayList<>();\\n            while(i<count && curr != null) {\\n                nums.add(curr.val);\\n                curr = curr.next;\\n                i++;\\n            }\\n            if(i%2 == 0) {\\n                Collections.reverse(nums);\\n                for(int j = 0; j<i; j++) {\\n                    start.val = nums.get(j);\\n                    start = start.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode curr = head;\\n        int count = 0;\\n        while(curr != null) {\\n            count++;\\n            int i=0;\\n            ListNode start = curr;\\n            List<Integer> nums = new ArrayList<>();\\n            while(i<count && curr != null) {\\n                nums.add(curr.val);\\n                curr = curr.next;\\n                i++;\\n            }\\n            if(i%2 == 0) {\\n                Collections.reverse(nums);\\n                for(int j = 0; j<i; j++) {\\n                    start.val = nums.get(j);\\n                    start = start.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946091,
                "title": "kotlin-two-pointers",
                "content": "# Intuition\\nI\\'m new here and this problem turned out to be hard for me, so I used the hints and that\\'s what I\\'ve got :)\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        var prevGroup: ListNode? = null   // pointer to the end of the previous group\\n        var begGroup = head               // pointer to the beginning of the current group\\n        var endGroup = head               // pointer to the end of the current group\\n        var nextGroup = head?.next        // pointer to the next group\\n        var groupCount = 1\\n\\n        while (nextGroup?.next != null) {\\n            groupCount++\\n\\n            // depends on whether the previous group was even or not\\n            prevGroup = if (groupCount % 2 == 0) endGroup else begGroup\\n            begGroup = nextGroup\\n            endGroup = begGroup\\n\\n            // traverse through a group\\n            var groupLength = 1\\n            while (groupLength < groupCount && endGroup?.next != null) {\\n                endGroup = endGroup.next\\n                groupLength++\\n            }\\n            nextGroup = endGroup?.next\\n\\n            // reverse the group if the group length is even\\n            if (groupLength % 2 == 0) {\\n                reverseList(begGroup, prevGroup, nextGroup)\\n\\n                // fix the connections\\n                prevGroup!!.next = endGroup\\n                if (begGroup != null) {\\n                    begGroup!!.next = nextGroup\\n                }\\n            }\\n        }\\n\\n        return head\\n    }\\n\\n    fun reverseList(currNode: ListNode?, prevNode: ListNode?, nextGroup: ListNode?) {\\n        var curr = currNode\\n        var prev = prevNode\\n\\n        while (curr != nextGroup) {\\n            val nextNode = curr?.next\\n            curr!!.next = prev\\n            prev = curr\\n            curr = nextNode\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        var prevGroup: ListNode? = null   // pointer to the end of the previous group\\n        var begGroup = head               // pointer to the beginning of the current group\\n        var endGroup = head               // pointer to the end of the current group\\n        var nextGroup = head?.next        // pointer to the next group\\n        var groupCount = 1\\n\\n        while (nextGroup?.next != null) {\\n            groupCount++\\n\\n            // depends on whether the previous group was even or not\\n            prevGroup = if (groupCount % 2 == 0) endGroup else begGroup\\n            begGroup = nextGroup\\n            endGroup = begGroup\\n\\n            // traverse through a group\\n            var groupLength = 1\\n            while (groupLength < groupCount && endGroup?.next != null) {\\n                endGroup = endGroup.next\\n                groupLength++\\n            }\\n            nextGroup = endGroup?.next\\n\\n            // reverse the group if the group length is even\\n            if (groupLength % 2 == 0) {\\n                reverseList(begGroup, prevGroup, nextGroup)\\n\\n                // fix the connections\\n                prevGroup!!.next = endGroup\\n                if (begGroup != null) {\\n                    begGroup!!.next = nextGroup\\n                }\\n            }\\n        }\\n\\n        return head\\n    }\\n\\n    fun reverseList(currNode: ListNode?, prevNode: ListNode?, nextGroup: ListNode?) {\\n        var curr = currNode\\n        var prev = prevNode\\n\\n        while (curr != nextGroup) {\\n            val nextNode = curr?.next\\n            curr!!.next = prev\\n            prev = curr\\n            curr = nextNode\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943025,
                "title": "simple-solution-with-recursion-o-n",
                "content": "\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n \\n        prev_node, cnt, len_group = head, 1, 1\\n        while prev_node.next:\\n            if cnt == len_group:\\n                last_group = prev_node\\n                if len_group%2:\\n                    node = prev_node.next\\n                    new_head, next_node = self.reverseList(node, len_group, 0)\\n                    if new_head:             \\n                        prev_node.next = new_head\\n                        node.next = next_node\\n                    if not next_node:\\n                        return head             \\n                cnt = 0\\n                len_group += 1\\n            cnt += 1           \\n            prev_node = prev_node.next\\n            \\n        if last_group.next:\\n            node = last_group.next\\n            new_head, _ = self.reverseList(node, len_group, 0)\\n            if new_head:             \\n                last_group.next = new_head\\n                node.next = None\\n        return head  \\n\\n    def reverseList(self, head: Optional[ListNode], k, cnt) -> Optional[ListNode]:\\n        if k == cnt:\\n            return head, head.next\\n        if not head.next and cnt%2:\\n            return head, None\\n        elif not head.next:\\n            return None, None\\n        new_head, next_node = self.reverseList(head.next, k, cnt+1)\\n        if new_head:\\n            head.next.next = head\\n        return new_head, next_node\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n \\n        prev_node, cnt, len_group = head, 1, 1\\n        while prev_node.next:\\n            if cnt == len_group:\\n                last_group = prev_node\\n                if len_group%2:\\n                    node = prev_node.next\\n                    new_head, next_node = self.reverseList(node, len_group, 0)\\n                    if new_head:             \\n                        prev_node.next = new_head\\n                        node.next = next_node\\n                    if not next_node:\\n                        return head             \\n                cnt = 0\\n                len_group += 1\\n            cnt += 1           \\n            prev_node = prev_node.next\\n            \\n        if last_group.next:\\n            node = last_group.next\\n            new_head, _ = self.reverseList(node, len_group, 0)\\n            if new_head:             \\n                last_group.next = new_head\\n                node.next = None\\n        return head  \\n\\n    def reverseList(self, head: Optional[ListNode], k, cnt) -> Optional[ListNode]:\\n        if k == cnt:\\n            return head, head.next\\n        if not head.next and cnt%2:\\n            return head, None\\n        elif not head.next:\\n            return None, None\\n        new_head, next_node = self.reverseList(head.next, k, cnt+1)\\n        if new_head:\\n            head.next.next = head\\n        return new_head, next_node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938887,
                "title": "java-solution-o-n-time-and-in-place",
                "content": "\\n```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode cur = head;\\n        ListNode pre = head;\\n        int distance = 1;\\n        int remain = 0;\\n        while (cur != null) {\\n            remain++;\\n            cur = cur.next;\\n        }\\n        cur = head;\\n\\n        while (cur != null && cur.next != null) {\\n            if ((remain >= distance && distance % 2 == 1) || (remain < distance && remain % 2 == 1)) { // keep\\n                for (int i = 0; i < distance && cur.next != null; i++) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            } else { // reverse\\n                for (int i = 0; i < distance - 1 && cur.next != null; i++) {\\n                    ListNode newCur = cur.next;\\n                    cur.next = newCur.next;\\n                    newCur.next = pre.next;\\n                    pre.next = newCur;\\n                }\\n                if (cur.next != null) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            }\\n            remain -= distance;\\n            distance++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode cur = head;\\n        ListNode pre = head;\\n        int distance = 1;\\n        int remain = 0;\\n        while (cur != null) {\\n            remain++;\\n            cur = cur.next;\\n        }\\n        cur = head;\\n\\n        while (cur != null && cur.next != null) {\\n            if ((remain >= distance && distance % 2 == 1) || (remain < distance && remain % 2 == 1)) { // keep\\n                for (int i = 0; i < distance && cur.next != null; i++) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            } else { // reverse\\n                for (int i = 0; i < distance - 1 && cur.next != null; i++) {\\n                    ListNode newCur = cur.next;\\n                    cur.next = newCur.next;\\n                    newCur.next = pre.next;\\n                    pre.next = newCur;\\n                }\\n                if (cur.next != null) {\\n                    pre = cur;\\n                    cur = cur.next;\\n                }\\n            }\\n            remain -= distance;\\n            distance++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937333,
                "title": "java-easiest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp=head;\\n        int num=1;\\n        while(temp!=null){\\n            int count=0;\\n            ListNode start=temp;\\n            Stack st=new Stack();\\n            while(count!=num && temp!=null){\\n                st.push(temp.val);\\n                temp=temp.next;\\n                count++;\\n            }\\n            if(count%2==0){\\n                while(temp!=start){\\n                    start.val=(int) st.pop();\\n                    start=start.next;\\n                }\\n            }\\n            num++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp=head;\\n        int num=1;\\n        while(temp!=null){\\n            int count=0;\\n            ListNode start=temp;\\n            Stack st=new Stack();\\n            while(count!=num && temp!=null){\\n                st.push(temp.val);\\n                temp=temp.next;\\n                count++;\\n            }\\n            if(count%2==0){\\n                while(temp!=start){\\n                    start.val=(int) st.pop();\\n                    start=start.next;\\n                }\\n            }\\n            num++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924897,
                "title": "python-simple-solution-not-reverse-linked-list-in-place",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        l = []\\n        while head:\\n            l.append(head)\\n            head = head.next\\n        n = len(l)\\n        start, end, cur = 0, 1, 1\\n        while end <= n:\\n            if cur%2 == 0:\\n                #reverse\\n                l[start:end] = l[start:end][::-1]\\n            start += cur\\n            cur += 1\\n            end += cur\\n        if (n-start)%2 == 0: l[start:n] = l[start:n][::-1]\\n\\n        node = dummy = ListNode()\\n        for n in l:\\n            node.next = n\\n            node = node.next\\n        node.next = None\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        l = []\\n        while head:\\n            l.append(head)\\n            head = head.next\\n        n = len(l)\\n        start, end, cur = 0, 1, 1\\n        while end <= n:\\n            if cur%2 == 0:\\n                #reverse\\n                l[start:end] = l[start:end][::-1]\\n            start += cur\\n            cur += 1\\n            end += cur\\n        if (n-start)%2 == 0: l[start:n] = l[start:n][::-1]\\n\\n        node = dummy = ListNode()\\n        for n in l:\\n            node.next = n\\n            node = node.next\\n        node.next = None\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921501,
                "title": "explained-beats-98-c-recursive-approach-for-multiple-question",
                "content": "# Intuition\\nIs same as, Solve below in order for better understanding. \\n1. https://leetcode.com/problems/swap-nodes-in-pairs/\\n2. https://leetcode.com/problems/reverse-nodes-in-k-group/\\n\\n# Approach\\nWe will use recursive approach to handle dynamic length reversal.\\n\\nTo handling last group case\\n### Observation \\nIt can be happend in both odd/even group case when \\'curr\\' become NULL. Also you can say, last group len will always <= current group.\\n### Requirement\\nReverse the nodes in each group with an even length\\n\\nSo last group may be of any length in both cases.\\nwe can find the length using \\'k\\'. and perform re-reverse/reverse operation corresponding to if/else statement.\\n\\nIn event group case i.e. if condition, if remaining \\'k\\' is odd -> len(last group) is odd. re-reverse needed.\\n\\nIn odd  group case i.e. else condition, if remaining \\'k\\' = odd -> len(last group) is even. reverse needed.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ for recursive stack\\n\\n# Code\\n```\\nclass Solution {\\n    // for handling last group case only\\n    ListNode* reverse(ListNode* head) {\\n        ListNode* prev = NULL, *curr = head, *next = NULL;\\n\\n        while(curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head, int group = 1) {\\n        if(!head) return head;\\n\\n        ListNode *prev = NULL, *curr = head, *next = NULL;\\n        int k = group;\\n\\n        if(k % 2 == 0) {\\n            while(curr && k) {\\n                next = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = next;\\n                k--;\\n            }\\n            head->next = reverseEvenLengthGroups(curr, group+1);\\n\\n            // Since curr is NULL and we are in even group, so we need to handling last group\\n            if(k&1) { // if k is odd, len of last group will odd, so we will revert.\\n                return reverse(prev);\\n            }\\n            return prev;\\n\\n        } else {\\n            while(curr && k) {\\n                prev = curr;\\n                curr = curr->next;\\n                k--;\\n            }\\n\\n            prev->next = reverseEvenLengthGroups(curr, group+1);\\n\\n            // Since curr is NULL and we are in odd group, so we need to handling last group\\n            if(k&1) { // if k is odd, len of last group will even, so we will reverse it.\\n                return reverse(head);\\n            }\\n        }\\n\\n        return head;\\n    }\\n};\\n\\n```\\n### Below code just for reference\\n```\\n// In below code the last group case is not handled\\n\\nListNode* reverseEvenLengthGroups(ListNode* head, int group = 1) {\\n    if(!head) return head;\\n\\n    ListNode *prev = NULL, *curr = head, *next = NULL;\\n    int k = group;\\n\\n    if(k % 2 == 0) {\\n        while(curr && k) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            k--;\\n        }\\n        head->next = reverseEvenLengthGroups(curr, group+1);\\n\\n        return prev;\\n\\n    } else {\\n        while(curr && k) {\\n            prev = curr;\\n            curr = curr->next;\\n            k--;\\n        }\\n        prev->next = reverseEvenLengthGroups(curr, group+1);\\n    }\\n\\n    return head;\\n}\\n```\\n# Please Vote Up",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    // for handling last group case only\\n    ListNode* reverse(ListNode* head) {\\n        ListNode* prev = NULL, *curr = head, *next = NULL;\\n\\n        while(curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head, int group = 1) {\\n        if(!head) return head;\\n\\n        ListNode *prev = NULL, *curr = head, *next = NULL;\\n        int k = group;\\n\\n        if(k % 2 == 0) {\\n            while(curr && k) {\\n                next = curr->next;\\n                curr->next = prev;\\n                prev = curr;\\n                curr = next;\\n                k--;\\n            }\\n            head->next = reverseEvenLengthGroups(curr, group+1);\\n\\n            // Since curr is NULL and we are in even group, so we need to handling last group\\n            if(k&1) { // if k is odd, len of last group will odd, so we will revert.\\n                return reverse(prev);\\n            }\\n            return prev;\\n\\n        } else {\\n            while(curr && k) {\\n                prev = curr;\\n                curr = curr->next;\\n                k--;\\n            }\\n\\n            prev->next = reverseEvenLengthGroups(curr, group+1);\\n\\n            // Since curr is NULL and we are in odd group, so we need to handling last group\\n            if(k&1) { // if k is odd, len of last group will even, so we will reverse it.\\n                return reverse(head);\\n            }\\n        }\\n\\n        return head;\\n    }\\n};\\n\\n```\n```\\n// In below code the last group case is not handled\\n\\nListNode* reverseEvenLengthGroups(ListNode* head, int group = 1) {\\n    if(!head) return head;\\n\\n    ListNode *prev = NULL, *curr = head, *next = NULL;\\n    int k = group;\\n\\n    if(k % 2 == 0) {\\n        while(curr && k) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            k--;\\n        }\\n        head->next = reverseEvenLengthGroups(curr, group+1);\\n\\n        return prev;\\n\\n    } else {\\n        while(curr && k) {\\n            prev = curr;\\n            curr = curr->next;\\n            k--;\\n        }\\n        prev->next = reverseEvenLengthGroups(curr, group+1);\\n    }\\n\\n    return head;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918520,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 3 ms ( O ( n ) )\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverse(ListNode head){\\n         ListNode curr=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n         while(curr!=null){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n       \\n        return prev;\\n    }\\n    public ListNode solve(ListNode head,int n){\\n        if(head==null) return null;\\n        ListNode curr=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n        int c=0;\\n        if(n%2==1){\\n           while(curr!=null&&c<n){\\n               next=curr;\\n                curr=curr.next;\\n                c++;\\n           }\\n           if(c%2==0) return solve(head,n-1);\\n           if(curr!=null) next.next=solve(curr,n+1);\\n           return head;\\n\\n        }\\n        while(curr!=null&&c<n){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n            c++;\\n        }\\n        if(c%2==1) return reverse(prev);\\n        if(next!=null) head.next=solve(next,n+1);\\n        return prev;\\n\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        return solve(head,1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverse(ListNode head){\\n         ListNode curr=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n         while(curr!=null){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n       \\n        return prev;\\n    }\\n    public ListNode solve(ListNode head,int n){\\n        if(head==null) return null;\\n        ListNode curr=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n        int c=0;\\n        if(n%2==1){\\n           while(curr!=null&&c<n){\\n               next=curr;\\n                curr=curr.next;\\n                c++;\\n           }\\n           if(c%2==0) return solve(head,n-1);\\n           if(curr!=null) next.next=solve(curr,n+1);\\n           return head;\\n\\n        }\\n        while(curr!=null&&c<n){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n            c++;\\n        }\\n        if(c%2==1) return reverse(prev);\\n        if(next!=null) head.next=solve(next,n+1);\\n        return prev;\\n\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        return solve(head,1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909824,
                "title": "c-linked-list-beats-77-62-of-users-with-c",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n #define null NULL\\nclass Solution {\\npublic:\\n     ListNode* prev=null,*temp,*curr;\\n     int i,n;\\n     void even()\\n     {\\n                 int count=i;\\n                 temp=curr;\\n                 vector<int>vt;\\n                 while(count--&&temp!=null) \\n                 {\\n                     vt.insert(vt.begin(),temp->val);\\n                     temp=temp->next;\\n                 }\\n                 count=i;\\n                 int n=0;\\n                 while(count--&&curr!=null)\\n                {\\n                    curr->val=vt[n++];\\n                    prev=curr;\\n                    curr=curr->next;\\n                   \\n                }\\n\\n     }\\n     void odd()\\n     {\\n                int count=i;\\n                while(count--&&curr!=null)\\n                {\\n                    prev=curr;\\n                    curr=curr->next;\\n                }\\n     }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n         i=1;\\n         curr=head;\\n        temp=head;\\n        while(temp!=null) \\n        {\\n            n++;\\n            temp=temp->next;\\n        }\\n        while(curr!=null)\\n        {\\n            if(i%2==0)\\n            {\\n                int val=n-((i*(i-1))/2);\\n                 if(val<i)\\n                 {\\n                     if(val%2==0) even();\\n                     else odd();\\n                 }\\n                 else even();\\n            }\\n            else\\n            {\\n                  int val=n-((i*(i-1))/2);\\n                 if(val<i)\\n                 {\\n                     if(val%2!=0) odd();\\n                     else even();\\n                 }\\n                 else odd();\\n            }\\n            i++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n #define null NULL\\nclass Solution {\\npublic:\\n     ListNode* prev=null,*temp,*curr;\\n     int i,n;\\n     void even()\\n     {\\n                 int count=i;\\n                 temp=curr;\\n                 vector<int>vt;\\n                 while(count--&&temp!=null) \\n                 {\\n                     vt.insert(vt.begin(),temp->val);\\n                     temp=temp->next;\\n                 }\\n                 count=i;\\n                 int n=0;\\n                 while(count--&&curr!=null)\\n                {\\n                    curr->val=vt[n++];\\n                    prev=curr;\\n                    curr=curr->next;\\n                   \\n                }\\n\\n     }\\n     void odd()\\n     {\\n                int count=i;\\n                while(count--&&curr!=null)\\n                {\\n                    prev=curr;\\n                    curr=curr->next;\\n                }\\n     }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n         i=1;\\n         curr=head;\\n        temp=head;\\n        while(temp!=null) \\n        {\\n            n++;\\n            temp=temp->next;\\n        }\\n        while(curr!=null)\\n        {\\n            if(i%2==0)\\n            {\\n                int val=n-((i*(i-1))/2);\\n                 if(val<i)\\n                 {\\n                     if(val%2==0) even();\\n                     else odd();\\n                 }\\n                 else even();\\n            }\\n            else\\n            {\\n                  int val=n-((i*(i-1))/2);\\n                 if(val<i)\\n                 {\\n                     if(val%2!=0) odd();\\n                     else even();\\n                 }\\n                 else odd();\\n            }\\n            i++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887165,
                "title": "very-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int group = 1;\\n        ListNode node = head;\\n        while(node!=null && node.next!=null){\\n            group++;\\n            int countGps=0;\\n            ListNode temp=node.next;\\n            while(temp!=null && countGps<group ){\\n                temp=temp.next;\\n                countGps++;\\n            }\\n            if(countGps % 2==0){\\n                ListNode present = node.next;\\n                ListNode newEnd = present;\\n                ListNode prev = node;\\n                ListNode next= present.next;\\n                for(int i =0 ; i<countGps ; i++){\\n                    present.next=prev;\\n                    prev=present;\\n                    present=next;\\n                    if(next!=null){\\n                        next=next.next;\\n                    }\\n                   node.next=prev;\\n                   newEnd.next=present;\\n\\n\\n                }\\n                node=newEnd;\\n            }else{\\n                for(int i =0 ; i<countGps ;i++){\\n                    node = node.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int group = 1;\\n        ListNode node = head;\\n        while(node!=null && node.next!=null){\\n            group++;\\n            int countGps=0;\\n            ListNode temp=node.next;\\n            while(temp!=null && countGps<group ){\\n                temp=temp.next;\\n                countGps++;\\n            }\\n            if(countGps % 2==0){\\n                ListNode present = node.next;\\n                ListNode newEnd = present;\\n                ListNode prev = node;\\n                ListNode next= present.next;\\n                for(int i =0 ; i<countGps ; i++){\\n                    present.next=prev;\\n                    prev=present;\\n                    present=next;\\n                    if(next!=null){\\n                        next=next.next;\\n                    }\\n                   node.next=prev;\\n                   newEnd.next=present;\\n\\n\\n                }\\n                node=newEnd;\\n            }else{\\n                for(int i =0 ; i<countGps ;i++){\\n                    node = node.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886130,
                "title": "simple-and-fast-java-solution-list-l",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head.next==null || head.next.next==null){\\n            return head;\\n        }\\n\\n        int grup=1;\\n        ListNode node=head;\\n        while(node!=null && node.next!=null){\\n            grup++;\\n            int ct=0;\\n            ListNode temp=node.next;\\n            while(temp!=null && ct<grup){\\n                temp=temp.next;\\n                ct++;\\n            }\\n\\n            if(ct%2==0){\\n                ListNode curr=node.next;\\n                ListNode prev=null;\\n                ListNode nextNode =null;\\n\\n                for(int i=0;i<ct;i++){\\n                    nextNode=curr.next;\\n                    curr.next=prev;\\n                    prev=curr;\\n                    curr=nextNode;\\n                }\\n                ListNode tail=node.next;\\n                tail.next=curr;\\n                node.next=prev;\\n                node=tail;\\n            }\\n            else{\\n                for(int i=0;i<ct;i++){\\n                    node=node.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head.next==null || head.next.next==null){\\n            return head;\\n        }\\n\\n        int grup=1;\\n        ListNode node=head;\\n        while(node!=null && node.next!=null){\\n            grup++;\\n            int ct=0;\\n            ListNode temp=node.next;\\n            while(temp!=null && ct<grup){\\n                temp=temp.next;\\n                ct++;\\n            }\\n\\n            if(ct%2==0){\\n                ListNode curr=node.next;\\n                ListNode prev=null;\\n                ListNode nextNode =null;\\n\\n                for(int i=0;i<ct;i++){\\n                    nextNode=curr.next;\\n                    curr.next=prev;\\n                    prev=curr;\\n                    curr=nextNode;\\n                }\\n                ListNode tail=node.next;\\n                tail.next=curr;\\n                node.next=prev;\\n                node=tail;\\n            }\\n            else{\\n                for(int i=0;i<ct;i++){\\n                    node=node.next;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881612,
                "title": "java-in-memory",
                "content": "# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        int groupSize = 1; \\n\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        head = dummy; \\n\\n        while(head!=null && head.next!=null){\\n\\n            ListNode currentGroupStartNode = head.next;  \\n            ListNode temp = head; \\n            int count = 0; \\n            \\n            while(count < groupSize && temp.next!=null){\\n                temp = temp.next; \\n                count++; \\n            }\\n\\n            ListNode currentGroupEndNode = temp;\\n            ListNode nextGroupStartNode = currentGroupEndNode == null ? null : currentGroupEndNode.next; \\n\\n            boolean shouldReverse = count%2==0; \\n            if(shouldReverse){   \\n                head.next = reverse(currentGroupStartNode, nextGroupStartNode, nextGroupStartNode);\\n                head = currentGroupStartNode; \\n            }else{\\n                head = currentGroupEndNode; \\n            }\\n\\n            groupSize++;\\n        }\\n        return dummy.next; \\n    }\\n\\n    ListNode reverse(ListNode startInclusive, ListNode endNodeExclusive, ListNode currentReverse){\\n        ListNode temp = startInclusive; \\n        while(temp != endNodeExclusive){\\n            ListNode tempNext = temp.next;\\n            temp.next = currentReverse;\\n            currentReverse = temp; \\n            temp = tempNext;\\n        }\\n        return currentReverse; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n        int groupSize = 1; \\n\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        head = dummy; \\n\\n        while(head!=null && head.next!=null){\\n\\n            ListNode currentGroupStartNode = head.next;  \\n            ListNode temp = head; \\n            int count = 0; \\n            \\n            while(count < groupSize && temp.next!=null){\\n                temp = temp.next; \\n                count++; \\n            }\\n\\n            ListNode currentGroupEndNode = temp;\\n            ListNode nextGroupStartNode = currentGroupEndNode == null ? null : currentGroupEndNode.next; \\n\\n            boolean shouldReverse = count%2==0; \\n            if(shouldReverse){   \\n                head.next = reverse(currentGroupStartNode, nextGroupStartNode, nextGroupStartNode);\\n                head = currentGroupStartNode; \\n            }else{\\n                head = currentGroupEndNode; \\n            }\\n\\n            groupSize++;\\n        }\\n        return dummy.next; \\n    }\\n\\n    ListNode reverse(ListNode startInclusive, ListNode endNodeExclusive, ListNode currentReverse){\\n        ListNode temp = startInclusive; \\n        while(temp != endNodeExclusive){\\n            ListNode tempNext = temp.next;\\n            temp.next = currentReverse;\\n            currentReverse = temp; \\n            temp = tempNext;\\n        }\\n        return currentReverse; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874081,
                "title": "python-simple-solutions-faster-than-98-6-o-n",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        def get_size(node, last_length):\\n            length = 0\\n            while node:\\n                length+=1\\n                if length==last_length+1:\\n                    return length, node\\n                node = node.next\\n            return length, None\\n\\n        def reverse(node, curr_length):\\n            prev = None\\n            curr = node\\n            while curr_length>0:\\n                curr_length-=1\\n                next = curr.next\\n                curr.next = prev\\n                prev, curr = curr, next\\n\\n            return prev, node\\n\\n\\n        last_length = 1\\n        curr = head\\n        while curr and curr.next:\\n            last_length, last_node = get_size(curr.next, last_length)\\n            if last_length%2==0:\\n                if last_node:\\n                    last_node = last_node.next\\n                sub_head, tail = reverse(curr.next, last_length)\\n                curr.next = sub_head\\n                tail.next = last_node\\n                curr = tail\\n            else:\\n                curr = last_node\\n        return head\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        def get_size(node, last_length):\\n            length = 0\\n            while node:\\n                length+=1\\n                if length==last_length+1:\\n                    return length, node\\n                node = node.next\\n            return length, None\\n\\n        def reverse(node, curr_length):\\n            prev = None\\n            curr = node\\n            while curr_length>0:\\n                curr_length-=1\\n                next = curr.next\\n                curr.next = prev\\n                prev, curr = curr, next\\n\\n            return prev, node\\n\\n\\n        last_length = 1\\n        curr = head\\n        while curr and curr.next:\\n            last_length, last_node = get_size(curr.next, last_length)\\n            if last_length%2==0:\\n                if last_node:\\n                    last_node = last_node.next\\n                sub_head, tail = reverse(curr.next, last_length)\\n                curr.next = sub_head\\n                tail.next = last_node\\n                curr = tail\\n            else:\\n                curr = last_node\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870545,
                "title": "java-in-memory-reverse-time-6ms-beats-74-84-users-space-68-45mb-beats-68-54-users",
                "content": "# Intuition\\nUse in-memory reverse.\\n\\n# Approach\\n->Use in-memory reverse approach.\\n->check if current group is last or not, i.e. no. of unprocessed nodes is >= 1 + processed_group_len, is it\\'s NOT last then return -1 from isLastG(); method.\\n->if not last group, then increament \\'gLen\\' by 1 otherwise use lastGLen as \\'gLen\\'\\n->if, \\'gLen\\' is add then do NOT reversing and skip \\'gLen\\' no. of nodes of current odd group.\\n->otherwise, start reversing \"even\" group nodes as follows:-\\n\\n    -NOTE : before reversing current even-group, the first-node of even-group will become the last-node of even-group, post reversing the order by changing the \\'cur.next\\' pointer. Hence, we can take it\\'s reference for backup in \\'evenEnd\\'(variable) so that after reversing the even-group nodes the last node of even-group (i.e. \\'evenEnd\\') can be further connected to next-group first node.\\n\\n    ex : evenEnd.next = next;\\n\\n    -Also, after reversing the even-group nodes \\'prev\\' pointer would become the first-node of the reversed even-group. Hence it also need to be linked to last-node of previous group.\\n\\n    ex : prevGEnd.next = prev;\\n\\n    -Also after each reversing of even-group nodes, we need to keep updating the \\'prevGEnd\\' pointer with \\'evenEnd\\'.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int gLen = 0;\\n        ListNode cur = head;\\n        ListNode prev = null;\\n        ListNode next = null;\\n        \\n        ListNode prevGEnd = null;\\n        ListNode evenEnd = null;\\n        int count = 0;\\n        int skip = 0;\\n        int isLastG = 0;\\n        boolean isNotLastGroup = false;\\n\\n        while (cur != null) {\\n            isLastG = isLastG(cur, gLen);\\n            isNotLastGroup = isLastG == -1 ? true : false;\\n            if (isNotLastGroup) {\\n                gLen++;\\n            } else if (!isNotLastGroup) {\\n                gLen = isLastG;\\n            }\\n\\n            if ((gLen & 1) == 0) {\\n                evenEnd = cur;\\n\\n                //rev start\\n                count = gLen;\\n                prev = null;\\n                next = null;\\n                while (count-- != 0) {\\n                    next = cur.next;\\n                    cur.next = prev;\\n                    prev = cur;\\n                    cur = next;\\n                }\\n                //rev end                \\n                \\n                prevGEnd.next = prev;\\n                evenEnd.next = next;\\n                prevGEnd = evenEnd;\\n            } else {\\n                skip = gLen;\\n                while (skip-- != 0) {\\n                    prevGEnd = cur;\\n                    cur = cur.next;\\n                }\\n            }\\n        }\\n        return head;        \\n    }\\n\\n    public int isLastG(ListNode cur, int prevGLen) {\\n        int count = 0;\\n        while (cur != null) {\\n            cur = cur.next;\\n            count++;\\n            if (count > (prevGLen+1)) {\\n                count = -1;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        int gLen = 0;\\n        ListNode cur = head;\\n        ListNode prev = null;\\n        ListNode next = null;\\n        \\n        ListNode prevGEnd = null;\\n        ListNode evenEnd = null;\\n        int count = 0;\\n        int skip = 0;\\n        int isLastG = 0;\\n        boolean isNotLastGroup = false;\\n\\n        while (cur != null) {\\n            isLastG = isLastG(cur, gLen);\\n            isNotLastGroup = isLastG == -1 ? true : false;\\n            if (isNotLastGroup) {\\n                gLen++;\\n            } else if (!isNotLastGroup) {\\n                gLen = isLastG;\\n            }\\n\\n            if ((gLen & 1) == 0) {\\n                evenEnd = cur;\\n\\n                //rev start\\n                count = gLen;\\n                prev = null;\\n                next = null;\\n                while (count-- != 0) {\\n                    next = cur.next;\\n                    cur.next = prev;\\n                    prev = cur;\\n                    cur = next;\\n                }\\n                //rev end                \\n                \\n                prevGEnd.next = prev;\\n                evenEnd.next = next;\\n                prevGEnd = evenEnd;\\n            } else {\\n                skip = gLen;\\n                while (skip-- != 0) {\\n                    prevGEnd = cur;\\n                    cur = cur.next;\\n                }\\n            }\\n        }\\n        return head;        \\n    }\\n\\n    public int isLastG(ListNode cur, int prevGLen) {\\n        int count = 0;\\n        while (cur != null) {\\n            cur = cur.next;\\n            count++;\\n            if (count > (prevGLen+1)) {\\n                count = -1;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837513,
                "title": "using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode ReverseEvenLengthGroups(ListNode head) {\\n        Stack s=new Stack();\\n        int c=1;\\n        var p=head;\\n        while(head!=null){\\n                var t=head;\\n                for(int i=0;i<c;i++){\\n                            if(head!=null){\\n                                s.Push(head.val);\\n                                head=head.next;\\n                            }\\n                        }\\n                    if(s.Count%2==0 ){\\n                        for(int i=0;i<c;i++){\\n                            if(t!=null){\\n                                t.val=(int)s.Pop();\\n                                t=t.next;\\n                            }\\n                        }\\n                    }\\n                s.Clear();\\n                c=c+1;\\n                }\\n              return p;\\n        }\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode ReverseEvenLengthGroups(ListNode head) {\\n        Stack s=new Stack();\\n        int c=1;\\n        var p=head;\\n        while(head!=null){\\n                var t=head;\\n                for(int i=0;i<c;i++){\\n                            if(head!=null){\\n                                s.Push(head.val);\\n                                head=head.next;\\n                            }\\n                        }\\n                    if(s.Count%2==0 ){\\n                        for(int i=0;i<c;i++){\\n                            if(t!=null){\\n                                t.val=(int)s.Pop();\\n                                t=t.next;\\n                            }\\n                        }\\n                    }\\n                s.Clear();\\n                c=c+1;\\n                }\\n              return p;\\n        }\\n    }\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824032,
                "title": "800-ms-c-solution",
                "content": "# Intuition\\nThis problem is about traversal, reversal and counting the number of elements in the list. \\n\\n# Approach\\nSplit the problem into groups, meaning either traverse the group without changing it or reverse the group depending on the length of the group.\\n\\nLength of the group ==> group number itself, except the last group which could be length of remaining elements or group number itself. \\n\\nTo compute the length of the last group, we keep a counter \"count\" which returns the number of nodes seen thus far. In addition, we also need to know the number of nodes in the list, via `calcLength()` function. \\n\\n\\nHence, we need two methods: \\n1. `reverseN()` that reverses a list of length N while returning tail of the new list.\\n2. `traverseN()` that traverses the list of N nodes, either stops the traversal at reaching sentinel or if the method has traversed N nodes. Returns the last element of the list.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // reverses the list starting at head until head+group \\n    // and connects the reversed list to prev.\\n    ListNode* reverseN(ListNode* head, ListNode* prev, int num_nodes) {\\n        ListNode* cur = head;\\n        int i = 1;\\n        while(cur != NULL && i <= num_nodes) {\\n            ListNode* temp = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = temp;\\n            i++;\\n        }\\n        // head->next is pointing to original prev but prev is pointing\\n        // to last node of the current list\\n        // hence, point previous list end node to new list\\'s head\\n        head->next->next = prev;\\n\\n        // point the last node of the new list to first node of the \\n        // next group\\n        head->next = cur;\\n        return head;\\n    }\\n\\n    int calcLength(ListNode* cur) {\\n        int i = 0;\\n        while(cur != NULL) {\\n            i++;\\n            cur = cur->next;\\n        }\\n        return i;\\n    }\\n\\n    ListNode* traverseN(ListNode* cur, int n) {\\n        int i = 1;\\n        while(cur != NULL && i < n) {\\n            cur = cur->next;\\n            i++;\\n        }\\n        return cur;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int len = calcLength(head);\\n\\n        int count = 0;\\n        int group_num = 0;\\n        int group_len = 0;\\n        ListNode* prev = NULL;\\n        ListNode* cur = head;\\n        while(cur != NULL) {\\n            group_num++;\\n            group_len = min(len-count, group_num);\\n\\n            // reverse an even group\\n            if (group_len%2 == 0) {\\n                cur = reverseN(cur, prev, group_len);\\n                count += group_len;\\n            } else {\\n                cur = traverseN(cur, group_len);\\n                count += group_len;\\n            }\\n\\n            prev = cur;\\n            if (cur != NULL) {\\n                 cur = cur->next;    \\n            } \\n              \\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // reverses the list starting at head until head+group \\n    // and connects the reversed list to prev.\\n    ListNode* reverseN(ListNode* head, ListNode* prev, int num_nodes) {\\n        ListNode* cur = head;\\n        int i = 1;\\n        while(cur != NULL && i <= num_nodes) {\\n            ListNode* temp = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = temp;\\n            i++;\\n        }\\n        // head->next is pointing to original prev but prev is pointing\\n        // to last node of the current list\\n        // hence, point previous list end node to new list\\'s head\\n        head->next->next = prev;\\n\\n        // point the last node of the new list to first node of the \\n        // next group\\n        head->next = cur;\\n        return head;\\n    }\\n\\n    int calcLength(ListNode* cur) {\\n        int i = 0;\\n        while(cur != NULL) {\\n            i++;\\n            cur = cur->next;\\n        }\\n        return i;\\n    }\\n\\n    ListNode* traverseN(ListNode* cur, int n) {\\n        int i = 1;\\n        while(cur != NULL && i < n) {\\n            cur = cur->next;\\n            i++;\\n        }\\n        return cur;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int len = calcLength(head);\\n\\n        int count = 0;\\n        int group_num = 0;\\n        int group_len = 0;\\n        ListNode* prev = NULL;\\n        ListNode* cur = head;\\n        while(cur != NULL) {\\n            group_num++;\\n            group_len = min(len-count, group_num);\\n\\n            // reverse an even group\\n            if (group_len%2 == 0) {\\n                cur = reverseN(cur, prev, group_len);\\n                count += group_len;\\n            } else {\\n                cur = traverseN(cur, group_len);\\n                count += group_len;\\n            }\\n\\n            prev = cur;\\n            if (cur != NULL) {\\n                 cur = cur->next;    \\n            } \\n              \\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814320,
                "title": "solution-without-conversion-to-list-python",
                "content": "# Intuition\\ngo through the linked list and if sublist must be reversed, we reverse with sub-while loop\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = prev = lenHead = head\\n\\n        curr = prev.next\\n        counter = 2\\n        length = 0\\n        while lenHead:\\n            length += 1\\n            lenHead = lenHead.next\\n        total = 1\\n        while curr:\\n            countTemp = counter\\n            print((length - total), counter)\\n            if ((length - total) >= counter and counter % 2 == 0) or ((length - total) < counter and (length - total) % 2 == 0 ):\\n                seqPrev = prev\\n                seqEnd = curr\\n                prev = curr\\n                curr = curr.next\\n                while countTemp - 1 and curr:\\n                    nextNode = curr.next\\n                    curr.next = prev\\n                    prev = curr\\n                    curr = nextNode\\n                    countTemp -= 1\\n                \\n                seqPrev.next = prev\\n                seqEnd.next = curr\\n                prev = seqEnd\\n            else:\\n                while countTemp and curr:\\n                    prev = curr\\n                    curr = curr.next\\n                    countTemp -= 1\\n            total += counter\\n            counter += 1\\n            \\n        \\n        return dummy\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = prev = lenHead = head\\n\\n        curr = prev.next\\n        counter = 2\\n        length = 0\\n        while lenHead:\\n            length += 1\\n            lenHead = lenHead.next\\n        total = 1\\n        while curr:\\n            countTemp = counter\\n            print((length - total), counter)\\n            if ((length - total) >= counter and counter % 2 == 0) or ((length - total) < counter and (length - total) % 2 == 0 ):\\n                seqPrev = prev\\n                seqEnd = curr\\n                prev = curr\\n                curr = curr.next\\n                while countTemp - 1 and curr:\\n                    nextNode = curr.next\\n                    curr.next = prev\\n                    prev = curr\\n                    curr = nextNode\\n                    countTemp -= 1\\n                \\n                seqPrev.next = prev\\n                seqEnd.next = curr\\n                prev = seqEnd\\n            else:\\n                while countTemp and curr:\\n                    prev = curr\\n                    curr = curr.next\\n                    countTemp -= 1\\n            total += counter\\n            counter += 1\\n            \\n        \\n        return dummy\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805562,
                "title": "simplest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        vector<int> tmp;\\n        ListNode* n = head;\\n        ListNode* h2 = nullptr;\\n        ListNode* n2 = h2;\\n\\n        int i=1;\\n        while(n!=nullptr)\\n        {\\n            for(int j=i; j>0; j--)\\n            {\\n                if(!n)\\n                {\\n                    break;\\n                }\\n                tmp.push_back(n->val);\\n                n=n->next;\\n            }\\n            \\n            if(!(tmp.size()%2))\\n            {\\n                std::reverse(tmp.begin(), tmp.end());\\n            }\\n            \\n            for(int j=0; j<tmp.size(); j++)\\n            {\\n                if(n2)\\n                {\\n                    n2->next = new ListNode(tmp[j]);\\n                    n2 = n2->next;\\n                }\\n                else\\n                {\\n                    n2 = new ListNode(tmp[j]);\\n                    h2 = n2;\\n                }\\n            }\\n            \\n            tmp.clear();\\n            i++;\\n\\n        }\\n\\n        return h2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        vector<int> tmp;\\n        ListNode* n = head;\\n        ListNode* h2 = nullptr;\\n        ListNode* n2 = h2;\\n\\n        int i=1;\\n        while(n!=nullptr)\\n        {\\n            for(int j=i; j>0; j--)\\n            {\\n                if(!n)\\n                {\\n                    break;\\n                }\\n                tmp.push_back(n->val);\\n                n=n->next;\\n            }\\n            \\n            if(!(tmp.size()%2))\\n            {\\n                std::reverse(tmp.begin(), tmp.end());\\n            }\\n            \\n            for(int j=0; j<tmp.size(); j++)\\n            {\\n                if(n2)\\n                {\\n                    n2->next = new ListNode(tmp[j]);\\n                    n2 = n2->next;\\n                }\\n                else\\n                {\\n                    n2 = new ListNode(tmp[j]);\\n                    h2 = n2;\\n                }\\n            }\\n            \\n            tmp.clear();\\n            i++;\\n\\n        }\\n\\n        return h2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787693,
                "title": "two-methodes-o-n-tc-and-o-n-sc",
                "content": "# First method: Using math\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem here is the last group, because is the only one that can not matche the number of nodes in it. The others do, for example, group numer 3 has 3 node, groupe number 5 has 5 node...\\nThe group numer 7 if it is the last group, can have 1 node, 2, 3... or even 6 nodes.\\nIf we know the number of groups, and also the number of nodes that it contains, we can handle this problem by reverse all nodes in the even group, and in the final, reverse the last group, if the number of its items is even.\\nBut how can we do that?\\n\\nIf we take a look at the number of the elements in each group:\\n1 | 2 - 3 | 4 - 5 - 6 | ...\\nHow elements we have?\\n1 + 2 + 3 = (3 * (3-1)) // 2 (Gauss\\'s formula)\\n\\nIf we know the lenght of the input, we can know the number of the groups and the nodes in the last group.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI use two functions, one to compute the length of the listNode and the other, the nomber of groups and the number of nodes in the last group.\\nWe can add at that a third fucction that reverse the groups.\\n\\n# Complexity\\n- Time complexity $$O(n)$$:\\n1. Iterate throught the linked list $$O(n)$$;\\n2. Compute the number of group and the number of nodes in the last node $$O(log(n))$$ (using binary search for that);\\n3. Iterate throught the linked list and reverse the groupe. It takes $$O(n + n/2)$$.\\nThe result of all of that: $$O(n)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity $$O(1)$$:\\nWe don\\'t use any extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def getLength(self, head):\\n        count, current = 0, head\\n        while current:\\n            count = count + 1\\n            current = current.next\\n        return count\\n\\n    def getNumGroups(self, num: int) -> List[int]:\\n        if num == 1: return [1, 0]\\n        num_2 = num * 2\\n        start, end = 1, num_2 // 2\\n        while start <= end:\\n            mid = (start + end) // 2\\n            pr = mid * mid\\n            if pr == num_2:\\n                ans = mid\\n                break\\n            elif pr < num_2:\\n                ans = mid\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        if ans * (ans + 1) // 2 > num:\\n            # In some cases, the number is begger.\\n            ans = ans - 1\\n        carry = num - ans * (ans + 1) // 2\\n            \\n        return [ans, carry] \\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        length = self.getLength(head)\\n        groups_carry = self.getNumGroups(length)\\n\\n        num_groups, carry =  groups_carry[0], groups_carry[1]\\n\\n        count_groups, prev, current = 1, head, head\\n        while count_groups <= num_groups:\\n            count = 1\\n            tail_group = current\\n            while count < count_groups:\\n                tail_group = tail_group.next\\n                count = count + 1\\n\\n            if count_groups % 2:\\n                current = tail_group.next\\n                prev = tail_group\\n            else:\\n                node = current\\n                save_tail_next = tail_group.next\\n                while count > 0:\\n                    save_node_next = node.next\\n                    node.next = save_tail_next\\n                    save_tail_next = node\\n                    node = save_node_next\\n                    count = count - 1\\n                prev.next = tail_group\\n                prev = current\\n                current = node\\n\\n            count_groups = count_groups + 1\\n\\n        # Hindling the last group.\\n        if not carry % 2:\\n            tail = None\\n            while current:\\n                save_current_next = current.next\\n                current.next = tail\\n                tail = current\\n                current = save_current_next\\n            prev.next = tail\\n\\n        return head\\n```\\n# Second methode\\n# Complexity\\n- Time complexity $$O(n)$$:\\nIterate throught the linked list and reverse the nodes if there number is even.\\n- Space complexity $$O(1)$$:\\nWe don\\'t use any extra space.\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current, prev, num_group = head, None, 1\\n        while current:\\n            count = 1\\n            tail = current\\n            while tail.next and count < num_group:\\n                tail = tail.next\\n                count = count + 1\\n\\n            if not count % 2:\\n                node = current\\n                while count > 1:\\n                    # 1 not 0 because in the first\\n                    # iteration we make tow iterations!\\n                    save_node_next = node.next\\n                    node.next = tail.next\\n                    tail.next = node\\n                    node = save_node_next\\n                    count = count - 1\\n                prev.next = node\\n                prev = current\\n            else:\\n                prev = tail\\n\\n            current = prev.next\\n            num_group = num_group + 1\\n\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def getLength(self, head):\\n        count, current = 0, head\\n        while current:\\n            count = count + 1\\n            current = current.next\\n        return count\\n\\n    def getNumGroups(self, num: int) -> List[int]:\\n        if num == 1: return [1, 0]\\n        num_2 = num * 2\\n        start, end = 1, num_2 // 2\\n        while start <= end:\\n            mid = (start + end) // 2\\n            pr = mid * mid\\n            if pr == num_2:\\n                ans = mid\\n                break\\n            elif pr < num_2:\\n                ans = mid\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        if ans * (ans + 1) // 2 > num:\\n            # In some cases, the number is begger.\\n            ans = ans - 1\\n        carry = num - ans * (ans + 1) // 2\\n            \\n        return [ans, carry] \\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        length = self.getLength(head)\\n        groups_carry = self.getNumGroups(length)\\n\\n        num_groups, carry =  groups_carry[0], groups_carry[1]\\n\\n        count_groups, prev, current = 1, head, head\\n        while count_groups <= num_groups:\\n            count = 1\\n            tail_group = current\\n            while count < count_groups:\\n                tail_group = tail_group.next\\n                count = count + 1\\n\\n            if count_groups % 2:\\n                current = tail_group.next\\n                prev = tail_group\\n            else:\\n                node = current\\n                save_tail_next = tail_group.next\\n                while count > 0:\\n                    save_node_next = node.next\\n                    node.next = save_tail_next\\n                    save_tail_next = node\\n                    node = save_node_next\\n                    count = count - 1\\n                prev.next = tail_group\\n                prev = current\\n                current = node\\n\\n            count_groups = count_groups + 1\\n\\n        # Hindling the last group.\\n        if not carry % 2:\\n            tail = None\\n            while current:\\n                save_current_next = current.next\\n                current.next = tail\\n                tail = current\\n                current = save_current_next\\n            prev.next = tail\\n\\n        return head\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current, prev, num_group = head, None, 1\\n        while current:\\n            count = 1\\n            tail = current\\n            while tail.next and count < num_group:\\n                tail = tail.next\\n                count = count + 1\\n\\n            if not count % 2:\\n                node = current\\n                while count > 1:\\n                    # 1 not 0 because in the first\\n                    # iteration we make tow iterations!\\n                    save_node_next = node.next\\n                    node.next = tail.next\\n                    tail.next = node\\n                    node = save_node_next\\n                    count = count - 1\\n                prev.next = node\\n                prev = current\\n            else:\\n                prev = tail\\n\\n            current = prev.next\\n            num_group = num_group + 1\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780551,
                "title": "c-short-code-easy-solution-100-beats-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head->next == NULL) return head;\\n        ListNode* temp = head;\\n        ListNode* rest;\\n        int grp = 1,nodes=1;\\n        do{\\n            \\n            if(nodes==grp || !temp->next){\\n                grp++; \\n               if(nodes%2==0){\\n                   ListNode* forward = rest->next;\\n                   ListNode* Extract = forward->next;\\n                   while((nodes--)>1){\\n                       forward->next = Extract->next;\\n                       Extract->next = rest->next;\\n                       rest->next = Extract;\\n                       Extract = forward->next;\\n                   }\\n                   temp = forward;\\n                 }\\n                 nodes=0;\\n                 rest = temp;\\n            }\\n            nodes++;\\n            temp=temp->next;\\n        }while(temp);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head->next == NULL) return head;\\n        ListNode* temp = head;\\n        ListNode* rest;\\n        int grp = 1,nodes=1;\\n        do{\\n            \\n            if(nodes==grp || !temp->next){\\n                grp++; \\n               if(nodes%2==0){\\n                   ListNode* forward = rest->next;\\n                   ListNode* Extract = forward->next;\\n                   while((nodes--)>1){\\n                       forward->next = Extract->next;\\n                       Extract->next = rest->next;\\n                       rest->next = Extract;\\n                       Extract = forward->next;\\n                   }\\n                   temp = forward;\\n                 }\\n                 nodes=0;\\n                 rest = temp;\\n            }\\n            nodes++;\\n            temp=temp->next;\\n        }while(temp);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778172,
                "title": "java-solution-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncomment for explaination.\\n\\n# Complexity\\n- Time complexity:O(len*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head.next==null || head.next.next==null)return head;\\n        int len=length(head);\\n        int k=2,curr=0;\\n        int l=1;\\n        ListNode node=head;\\n        ListNode prev=head;\\n        while(node!=null){\\n            while(curr<k && node!=null){\\n                curr++;\\n                node=node.next;\\n            }\\n            ListNode temp=prev.next;\\n            if(curr%2==0){\\n                prev.next=reverse(prev.next,node);\\n            }\\n            prev=(curr%2==0)?temp:node;\\n            node=prev;\\n            l+=curr;\\n            curr=0;\\n            k++;\\n            if(k>len-l)k=len-l;\\n        }\\n        return head;\\n\\n    }\\n    public ListNode reverse(ListNode head,ListNode tail){\\n        if(tail!=null)tail=tail.next;\\n        ListNode end=tail;\\n        while(head!=null){\\n            ListNode next=head.next;\\n            head.next=tail;\\n            if(end==next)break;\\n            tail=head;\\n            head=next;\\n        }\\n        return head;\\n    }\\n    public int length(ListNode head)\\n    {\\n        int len=0;\\n        for(ListNode curr=head;curr!=null;curr=curr.next)len++;\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head.next==null || head.next.next==null)return head;\\n        int len=length(head);\\n        int k=2,curr=0;\\n        int l=1;\\n        ListNode node=head;\\n        ListNode prev=head;\\n        while(node!=null){\\n            while(curr<k && node!=null){\\n                curr++;\\n                node=node.next;\\n            }\\n            ListNode temp=prev.next;\\n            if(curr%2==0){\\n                prev.next=reverse(prev.next,node);\\n            }\\n            prev=(curr%2==0)?temp:node;\\n            node=prev;\\n            l+=curr;\\n            curr=0;\\n            k++;\\n            if(k>len-l)k=len-l;\\n        }\\n        return head;\\n\\n    }\\n    public ListNode reverse(ListNode head,ListNode tail){\\n        if(tail!=null)tail=tail.next;\\n        ListNode end=tail;\\n        while(head!=null){\\n            ListNode next=head.next;\\n            head.next=tail;\\n            if(end==next)break;\\n            tail=head;\\n            head=next;\\n        }\\n        return head;\\n    }\\n    public int length(ListNode head)\\n    {\\n        int len=0;\\n        for(ListNode curr=head;curr!=null;curr=curr.next)len++;\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772763,
                "title": "simple-java-code-with-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n\\n1. First, a check is performed to see if the input linked list is either empty or contains only a single node. If so, the function simply returns the head of the list as there is no need to reverse anything.\\n2. A `dummy` node is created and set as the initial `prev` node. The `prev` node is used to keep track of the previous node before the current node (`cur`).\\n3. The function iterates through the linked list until the last node (`cur.next != null`). Within each iteration, it checks if the current group has an even or odd length.\\n4. To determine if the group is even or odd, the function counts the number of available nodes (`availableNode`) in the current group. This is done by traversing the list using a temporary node (`checkNode`) and incrementing `availableNode` until either the end of the list is reached or the count equals the length of the current group (`count`).\\n5. If the group is even (`evenTurn` is `true`), the function reverses the nodes within the group. It uses a counter (`i`) to keep track of the number of nodes processed within the group. The reversal is done by swapping the `next` pointers of the nodes, starting from the second node up to the count (`count - 1`). The `prev` node is updated to maintain the correct connections.\\n6. If the group is odd (`evenTurn` is `false`), the function simply skips the nodes in the current group without making any changes. It advances `prev` and `cur` to the next group by moving `i` nodes ahead.\\n7. After processing the current group, the counters and variables are reset (`i = 1`, `count = count + 1`) to move to the next group.\\n8. Finally, the modified linked list is returned by accessing the `next` pointer of the `dummy` node\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n   public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        int i = 1;\\n        int count = 1;\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        ListNode cur = dummy.next;\\n\\n        while (cur.next != null) {\\n            // Count the number of available nodes in the current group\\n            ListNode checkNode = cur;\\n            int availableNode = 0;\\n            while (checkNode != null && availableNode < count) {\\n                availableNode++;\\n                checkNode = checkNode.next;\\n            }\\n\\n            boolean evenTurn = availableNode % 2 == 0;\\n\\n            if (evenTurn) {\\n                // Reverse the nodes within the even-length group\\n                while (cur.next != null && i < count) {\\n                    ListNode temp = cur.next;\\n                    cur.next = temp.next;\\n                    temp.next = prev.next;\\n                    prev.next = temp;\\n                    i++;\\n                }\\n\\n                if (cur.next != null) {\\n                    ListNode temp = cur.next;\\n                    prev = cur;\\n                    cur = temp;\\n                }\\n            } else {\\n                // Skip nodes in the odd-length group\\n                while (cur.next != null && i <= count) {\\n                    prev = cur;\\n                    cur = cur.next;\\n                    i++;\\n                }\\n            }\\n\\n            i = 1;\\n            count = count + 1;\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n   public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        int i = 1;\\n        int count = 1;\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        ListNode cur = dummy.next;\\n\\n        while (cur.next != null) {\\n            // Count the number of available nodes in the current group\\n            ListNode checkNode = cur;\\n            int availableNode = 0;\\n            while (checkNode != null && availableNode < count) {\\n                availableNode++;\\n                checkNode = checkNode.next;\\n            }\\n\\n            boolean evenTurn = availableNode % 2 == 0;\\n\\n            if (evenTurn) {\\n                // Reverse the nodes within the even-length group\\n                while (cur.next != null && i < count) {\\n                    ListNode temp = cur.next;\\n                    cur.next = temp.next;\\n                    temp.next = prev.next;\\n                    prev.next = temp;\\n                    i++;\\n                }\\n\\n                if (cur.next != null) {\\n                    ListNode temp = cur.next;\\n                    prev = cur;\\n                    cur = temp;\\n                }\\n            } else {\\n                // Skip nodes in the odd-length group\\n                while (cur.next != null && i <= count) {\\n                    prev = cur;\\n                    cur = cur.next;\\n                    i++;\\n                }\\n            }\\n\\n            i = 1;\\n            count = count + 1;\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772203,
                "title": "python-solution-in-n-time-and-constant-space",
                "content": "# Complexity\\n- Time complexity: \\u0398(n)\\n\\n- Space complexity: \\u0398(1)\\n\\n# Code\\n```\\n# Intuition is you need to reverse everytime you get a even grp LL or lst group is even\\n# So maintain odd and even which remembers the group length of prev LL group.\\n# Initially odd = 1 and even = 2\\n# when you reach an even grp of length == \"even\", you reverse it and update even += 2 and odd += 2\\n# And start counting again\\nclass Solution:\\n    def rev(self, head):\\n        nh = None\\n        while head != None:\\n            store = head.next\\n            head.next = nh\\n            nh = head\\n            head = store\\n        return nh\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        org_h = head\\n        p = head    # points to prev of LL\\n        t = head    # points to the end of the LL to be reversed\\n        c = 0 # to count nodes\\n        s = 0 # when s == 0 it means you have reached LL of even length grp and can rev else not\\n        odd = 1 # initial odd grp length of LL\\n        even = 2 # initial even grp length of LL\\n        while t != None and t.next != None:\\n            c += 1\\n            t = t.next\\n            if (c == even and s == 0) or (c % 2 == 0 and t.next == None):\\n                head = p.next\\n                n = t.next\\n                t.next = None\\n                nh = self.rev(head)\\n                head = p.next\\n                head.next = n\\n                p.next = t\\n                p = head\\n                h = n\\n                t = n\\n                c = 1\\n                s = 1\\n                even += 2\\n                odd += 2\\n            elif c == odd and s == 1:\\n                c = 0\\n                s = 0\\n                p = t\\n        return org_h\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Intuition is you need to reverse everytime you get a even grp LL or lst group is even\\n# So maintain odd and even which remembers the group length of prev LL group.\\n# Initially odd = 1 and even = 2\\n# when you reach an even grp of length == \"even\", you reverse it and update even += 2 and odd += 2\\n# And start counting again\\nclass Solution:\\n    def rev(self, head):\\n        nh = None\\n        while head != None:\\n            store = head.next\\n            head.next = nh\\n            nh = head\\n            head = store\\n        return nh\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        org_h = head\\n        p = head    # points to prev of LL\\n        t = head    # points to the end of the LL to be reversed\\n        c = 0 # to count nodes\\n        s = 0 # when s == 0 it means you have reached LL of even length grp and can rev else not\\n        odd = 1 # initial odd grp length of LL\\n        even = 2 # initial even grp length of LL\\n        while t != None and t.next != None:\\n            c += 1\\n            t = t.next\\n            if (c == even and s == 0) or (c % 2 == 0 and t.next == None):\\n                head = p.next\\n                n = t.next\\n                t.next = None\\n                nh = self.rev(head)\\n                head = p.next\\n                head.next = n\\n                p.next = t\\n                p = head\\n                h = n\\n                t = n\\n                c = 1\\n                s = 1\\n                even += 2\\n                odd += 2\\n            elif c == odd and s == 1:\\n                c = 0\\n                s = 0\\n                p = t\\n        return org_h\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772200,
                "title": "python-solution-in-n-time-and-constant-space",
                "content": "# Complexity\\n- Time complexity: \\u0398(n)\\n\\n- Space complexity: \\u0398(1)\\n\\n# Code\\n```\\n# Intuition is you need to reverse everytime you get a even grp LL or lst group is even\\n# So maintain odd and even which remembers the group length of prev LL group.\\n# Initially odd = 1 and even = 2\\n# when you reach an even grp of length == \"even\", you reverse it and update even += 2 and odd += 2\\n# And start counting again\\nclass Solution:\\n    def rev(self, head):\\n        nh = None\\n        while head != None:\\n            store = head.next\\n            head.next = nh\\n            nh = head\\n            head = store\\n        return nh\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        org_h = head\\n        p = head    # points to prev of LL\\n        t = head    # points to the end of the LL to be reversed\\n        c = 0 # to count nodes\\n        s = 0 # when s == 0 it means you have reached LL of even length grp and can rev else not\\n        odd = 1 # initial odd grp length of LL\\n        even = 2 # initial even grp length of LL\\n        while t != None and t.next != None:\\n            c += 1\\n            t = t.next\\n            if (c == even and s == 0) or (c % 2 == 0 and t.next == None):\\n                head = p.next\\n                n = t.next\\n                t.next = None\\n                nh = self.rev(head)\\n                head = p.next\\n                head.next = n\\n                p.next = t\\n                p = head\\n                h = n\\n                t = n\\n                c = 1\\n                s = 1\\n                even += 2\\n                odd += 2\\n            elif c == odd and s == 1:\\n                c = 0\\n                s = 0\\n                p = t\\n        return org_h\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Intuition is you need to reverse everytime you get a even grp LL or lst group is even\\n# So maintain odd and even which remembers the group length of prev LL group.\\n# Initially odd = 1 and even = 2\\n# when you reach an even grp of length == \"even\", you reverse it and update even += 2 and odd += 2\\n# And start counting again\\nclass Solution:\\n    def rev(self, head):\\n        nh = None\\n        while head != None:\\n            store = head.next\\n            head.next = nh\\n            nh = head\\n            head = store\\n        return nh\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        org_h = head\\n        p = head    # points to prev of LL\\n        t = head    # points to the end of the LL to be reversed\\n        c = 0 # to count nodes\\n        s = 0 # when s == 0 it means you have reached LL of even length grp and can rev else not\\n        odd = 1 # initial odd grp length of LL\\n        even = 2 # initial even grp length of LL\\n        while t != None and t.next != None:\\n            c += 1\\n            t = t.next\\n            if (c == even and s == 0) or (c % 2 == 0 and t.next == None):\\n                head = p.next\\n                n = t.next\\n                t.next = None\\n                nh = self.rev(head)\\n                head = p.next\\n                head.next = n\\n                p.next = t\\n                p = head\\n                h = n\\n                t = n\\n                c = 1\\n                s = 1\\n                even += 2\\n                odd += 2\\n            elif c == odd and s == 1:\\n                c = 0\\n                s = 0\\n                p = t\\n        return org_h\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757957,
                "title": "beats-85-o-n-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n       ListNode *connect=head,*ptr=head->next;\\n       int cnt=2;\\n       while(ptr!=NULL){\\n           ListNode *head_maintain=ptr,*prev=NULL;\\n           int i=0;\\n           while(ptr!=NULL&&i<cnt){\\n             prev=ptr;\\n             ptr=ptr->next;\\n             i+=1;\\n             }\\n             if(i%2==0){\\n                ptr=head_maintain;\\n                ListNode *preptr=NULL;\\n                int j=0;\\n                while(j<i){\\n                    ListNode *next=ptr->next;\\n                    ptr->next=preptr;\\n                    preptr=ptr;\\n                    ptr=next;\\n                    j+=1;\\n                }\\n                connect->next=preptr;\\n                connect=head_maintain;\\n            }\\n            else{\\n                connect->next=head_maintain;\\n                connect=prev;\\n            }\\n            cnt+=1;\\n        }\\n       return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n       ListNode *connect=head,*ptr=head->next;\\n       int cnt=2;\\n       while(ptr!=NULL){\\n           ListNode *head_maintain=ptr,*prev=NULL;\\n           int i=0;\\n           while(ptr!=NULL&&i<cnt){\\n             prev=ptr;\\n             ptr=ptr->next;\\n             i+=1;\\n             }\\n             if(i%2==0){\\n                ptr=head_maintain;\\n                ListNode *preptr=NULL;\\n                int j=0;\\n                while(j<i){\\n                    ListNode *next=ptr->next;\\n                    ptr->next=preptr;\\n                    preptr=ptr;\\n                    ptr=next;\\n                    j+=1;\\n                }\\n                connect->next=preptr;\\n                connect=head_maintain;\\n            }\\n            else{\\n                connect->next=head_maintain;\\n                connect=prev;\\n            }\\n            cnt+=1;\\n        }\\n       return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745102,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* reverse(ListNode* head){\\n    ListNode* prev = NULL,*curr = head,*nxt = NULL;\\n    while(curr){\\n        nxt = curr -> next;\\n        curr -> next = prev;\\n        prev = curr;\\n        curr = nxt;\\n    }\\n\\n    return prev;\\n}\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode* dummy = new ListNode(-1,head);\\n        ListNode* prev = dummy,*tail = head,*newHead = NULL,*curr = head;\\n\\n        int k = 1;\\n        while(curr){\\n            int i = 1;\\n            for( i=1;i<k && tail->next;++i) tail = tail -> next;\\n            if(tail == NULL) return dummy -> next;\\n\\n            newHead = tail -> next;\\n            if(i&1){\\n                 if(curr == NULL) return dummy -> next;\\n                 curr = tail -> next;\\n                 prev = tail;\\n                 tail = curr;\\n            }\\n            else{\\n                  tail -> next = NULL;\\n                  if(curr == NULL) return dummy -> next;\\n                \\n                  ListNode* tmp = reverse(curr);\\n                  curr -> next = newHead;\\n                  prev -> next = tmp;\\n                  tail = curr -> next;\\n                  prev = curr;\\n                  curr = tail;\\n            }\\n\\n            k += 1;\\n        }\\n\\n        return dummy -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* reverse(ListNode* head){\\n    ListNode* prev = NULL,*curr = head,*nxt = NULL;\\n    while(curr){\\n        nxt = curr -> next;\\n        curr -> next = prev;\\n        prev = curr;\\n        curr = nxt;\\n    }\\n\\n    return prev;\\n}\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        ListNode* dummy = new ListNode(-1,head);\\n        ListNode* prev = dummy,*tail = head,*newHead = NULL,*curr = head;\\n\\n        int k = 1;\\n        while(curr){\\n            int i = 1;\\n            for( i=1;i<k && tail->next;++i) tail = tail -> next;\\n            if(tail == NULL) return dummy -> next;\\n\\n            newHead = tail -> next;\\n            if(i&1){\\n                 if(curr == NULL) return dummy -> next;\\n                 curr = tail -> next;\\n                 prev = tail;\\n                 tail = curr;\\n            }\\n            else{\\n                  tail -> next = NULL;\\n                  if(curr == NULL) return dummy -> next;\\n                \\n                  ListNode* tmp = reverse(curr);\\n                  curr -> next = newHead;\\n                  prev -> next = tmp;\\n                  tail = curr -> next;\\n                  prev = curr;\\n                  curr = tail;\\n            }\\n\\n            k += 1;\\n        }\\n\\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744777,
                "title": "o-1-memory-space-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe traverse through the list step by step, each step has a length $l$, which is also the length of of the group that we are currently traversing. After traverse through the step, we reverse the list in-place, and then merge it back to the original list. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are going to solve this problem in-place to obtain O(1) memory space.\\n\\nStep 1: Traverse up-front to check the length of the group (check if it is long enough or if it reaches the end).\\nStep 2: Reverse the particular part of the list with the length we count in step 1.\\nStep 3: Merge: Noted that we need to store a variable $prev$ (the previous node of the first node in the group) and $next$ (the next node of the last node in the group). If we reverse the list, the last node (variable $tmp$) becomes the first node (variable $current$) and vice versa. We point $prev$ to $tmp$, then point $current$ to $next$ and update $prev$. Note that if we do not reverse the list, $prev$ should be updated as $tmp$.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nEven though we have nested while loop here, the time complexity is O(n). The travelling up-front part cost O(n), the reverseList cost O(n). In the next while loop, we move the the entirely new part of the list, so it is O(n) time complexity. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nHere, we only store a few variables to deal with in-place reversal, so the space complexity is O(1).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverseList(ListNode *head, int len){\\n        int count = 0;\\n        ListNode *prev = nullptr, *current = head, *next = nullptr;\\n        while(count < len && current){\\n            next = current->next;\\n            current->next = prev;\\n            prev = current;\\n            current = next;\\n            count++;\\n        }\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int l = 1, count;\\n        if(!head->next) return head;\\n        ListNode *current = head, *tmp = head; // for traversing upfront\\n        ListNode *prev = nullptr, *next = nullptr; // for merging the reversed list\\n        // start from the second node\\n        current = head->next;\\n        prev = head;\\n        while(current){\\n            l++;\\n            tmp = current;\\n            count = 1;\\n            while(count < l && tmp->next){\\n                tmp = tmp->next;\\n                count++;\\n            }\\n            next = tmp->next;   \\n            if(count%2 == 0){\\n                reverseList(current, l);\\n                //merge\\n                prev->next = tmp;\\n                current->next = next;\\n                prev = current;\\n            }else{\\n                prev = tmp;\\n            }\\n            current = next;\\n            tmp = current;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverseList(ListNode *head, int len){\\n        int count = 0;\\n        ListNode *prev = nullptr, *current = head, *next = nullptr;\\n        while(count < len && current){\\n            next = current->next;\\n            current->next = prev;\\n            prev = current;\\n            current = next;\\n            count++;\\n        }\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int l = 1, count;\\n        if(!head->next) return head;\\n        ListNode *current = head, *tmp = head; // for traversing upfront\\n        ListNode *prev = nullptr, *next = nullptr; // for merging the reversed list\\n        // start from the second node\\n        current = head->next;\\n        prev = head;\\n        while(current){\\n            l++;\\n            tmp = current;\\n            count = 1;\\n            while(count < l && tmp->next){\\n                tmp = tmp->next;\\n                count++;\\n            }\\n            next = tmp->next;   \\n            if(count%2 == 0){\\n                reverseList(current, l);\\n                //merge\\n                prev->next = tmp;\\n                current->next = next;\\n                prev = current;\\n            }else{\\n                prev = tmp;\\n            }\\n            current = next;\\n            tmp = current;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732665,
                "title": "ok",
                "content": "**time: `O(N)`; space: `O(1)`**\\n\\n![image](https://assets.leetcode.com/users/images/644226f4-b488-46f0-b048-6a4bbca78b5c_1688747083.092001.png)\\n\\nHere\\'s how inversion is made in more detail:\\n\\n![image](https://assets.leetcode.com/users/images/fa7ff2db-fb7a-46de-96ae-660941354af2_1688748747.976289.png)\\n\\nHere `x` marks the borderline between the already inverted and the not-inverted part.\\n\\n```\\nListNode* reverseEvenLengthGroups(ListNode* l) \\n{\\n\\tint n{2};\\n\\tfor(auto b{l}, e{b->next}; e; ++n)\\n\\t{\\n\\t\\tfor( ; b->next!=e; b=b->next); \\n\\t\\tint i{};\\n\\t\\tfor( ; i<n and e; e=e->next, ++i);\\n\\t\\tif(1+i&1) for(auto x{b->next}; x->next!=e; b->next = exchange(x->next, exchange(x->next->next, b->next)));   \\n\\t}\\n\\treturn l;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nListNode* reverseEvenLengthGroups(ListNode* l) \\n{\\n\\tint n{2};\\n\\tfor(auto b{l}, e{b->next}; e; ++n)\\n\\t{\\n\\t\\tfor( ; b->next!=e; b=b->next); \\n\\t\\tint i{};\\n\\t\\tfor( ; i<n and e; e=e->next, ++i);\\n\\t\\tif(1+i&1) for(auto x{b->next}; x->next!=e; b->next = exchange(x->next, exchange(x->next->next, b->next)));   \\n\\t}\\n\\treturn l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731160,
                "title": "beats-92-c-iterative-solution-for-beginners",
                "content": "\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n\\n    //make a pair class to return both head and tail from \\n    //reverse function\\n\\n    class Pair{\\n        public:\\n        ListNode* head;\\n        ListNode* tail;\\n    };\\n\\n    //recursive reverse function which returns an object of \\n    //pair class\\n\\n    Pair reverse(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            Pair ans;\\n            ans.head=head;\\n            ans.tail=head;\\n            return ans;\\n        }\\n        Pair smallAns=reverse(head->next);\\n        smallAns.tail->next=head;\\n        head->next=NULL;\\n        Pair ans;\\n        ans.head=smallAns.head;\\n        ans.tail=head;\\n        return ans;\\n    }\\npublic:\\n\\n    //maintain dummy nodes and iterate on every group\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode*dummy=head;ListNode*newHead=head;\\n        ListNode*h1=newHead->next;\\n        ListNode*t1=newHead->next;\\n        int count=0;int group=2;bool free=false;\\n        while(dummy->next!=NULL){\\n            dummy=dummy->next;\\n            count++;\\n\\n        //condition when group is of even length\\n\\n            if((count%2==0 && group%2==0 && count==group)){\\n                t1=dummy;\\n                ListNode*temp=dummy->next;\\n                t1->next=NULL;\\n                Pair ans=reverse(h1);\\n                newHead->next=ans.head;\\n                ans.tail->next=temp;\\n                newHead=ans.tail;\\n                dummy=ans.tail;\\n                count=0;group++;\\n\\n            }\\n\\n        //condition when group is of odd length\\n\\n            if(!free && count==group){\\n                count=0;\\n                group++;\\n                newHead=dummy;\\n                h1=dummy->next;\\n\\n            }\\n        }\\n\\n        //when no group is left\\n\\n        if(count==0)return head;\\n\\n        //when left nodes are even in number \\n        //then we need to reverse them \\n        //(group can be odd also in this case)\\n\\n        if(count%2==0){\\n            Pair ans=reverse(newHead->next);\\n            newHead->next=ans.head;\\n            ans.tail->next=NULL;\\n            return head;\\n        }\\n\\n        //when nodes left are odd in number\\n        //in this case no need to reverse them\\n        //simply return head\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n\\n    //make a pair class to return both head and tail from \\n    //reverse function\\n\\n    class Pair{\\n        public:\\n        ListNode* head;\\n        ListNode* tail;\\n    };\\n\\n    //recursive reverse function which returns an object of \\n    //pair class\\n\\n    Pair reverse(ListNode*head){\\n        if(head==NULL || head->next==NULL){\\n            Pair ans;\\n            ans.head=head;\\n            ans.tail=head;\\n            return ans;\\n        }\\n        Pair smallAns=reverse(head->next);\\n        smallAns.tail->next=head;\\n        head->next=NULL;\\n        Pair ans;\\n        ans.head=smallAns.head;\\n        ans.tail=head;\\n        return ans;\\n    }\\npublic:\\n\\n    //maintain dummy nodes and iterate on every group\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode*dummy=head;ListNode*newHead=head;\\n        ListNode*h1=newHead->next;\\n        ListNode*t1=newHead->next;\\n        int count=0;int group=2;bool free=false;\\n        while(dummy->next!=NULL){\\n            dummy=dummy->next;\\n            count++;\\n\\n        //condition when group is of even length\\n\\n            if((count%2==0 && group%2==0 && count==group)){\\n                t1=dummy;\\n                ListNode*temp=dummy->next;\\n                t1->next=NULL;\\n                Pair ans=reverse(h1);\\n                newHead->next=ans.head;\\n                ans.tail->next=temp;\\n                newHead=ans.tail;\\n                dummy=ans.tail;\\n                count=0;group++;\\n\\n            }\\n\\n        //condition when group is of odd length\\n\\n            if(!free && count==group){\\n                count=0;\\n                group++;\\n                newHead=dummy;\\n                h1=dummy->next;\\n\\n            }\\n        }\\n\\n        //when no group is left\\n\\n        if(count==0)return head;\\n\\n        //when left nodes are even in number \\n        //then we need to reverse them \\n        //(group can be odd also in this case)\\n\\n        if(count%2==0){\\n            Pair ans=reverse(newHead->next);\\n            newHead->next=ans.head;\\n            ans.tail->next=NULL;\\n            return head;\\n        }\\n\\n        //when nodes left are odd in number\\n        //in this case no need to reverse them\\n        //simply return head\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729175,
                "title": "python-simple-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # To be able to reverse, we need to keep the previous node that we visited\\n        curr, prev = head, None\\n        # starting the counter form 1 and will be incrementing by 1 later in the loop\\n        ctr = 1\\n        # continue until we reach the end of the loop\\n        while curr:\\n            # count the number of nodes in this step where counter is ctr\\n            i = 0\\n            # keep a pointer to the start of the node, in case the number of nodes \\n            start = curr\\n            while curr and i < ctr:\\n                # keep track of previous node in case we need to reverse\\n                next_prev_node = curr\\n                curr = curr.next\\n                i += 1\\n            # if the count of nodes in this iteration are even, then we need to reverse\\n            if not i & 1:\\n                tail = start\\n                curr = start\\n                # to reverse\\n                temp_prev = None\\n                j = 0\\n                # continue the iteration for the number of nodes seen in this step (ctr)\\n                while curr and j < i:\\n                    next_node = curr.next\\n                    curr.next = temp_prev\\n                    temp_prev = curr\\n                    curr = next_node\\n                    j += 1\\n                prev.next = temp_prev\\n                tail.next = curr\\n                # since it is reversed the new previous node will be the tail of current list\\n                prev = tail\\n            else:\\n                # if not reversed the previous node will be the next_prev_node\\n                prev = next_prev_node\\n            ctr += 1\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # To be able to reverse, we need to keep the previous node that we visited\\n        curr, prev = head, None\\n        # starting the counter form 1 and will be incrementing by 1 later in the loop\\n        ctr = 1\\n        # continue until we reach the end of the loop\\n        while curr:\\n            # count the number of nodes in this step where counter is ctr\\n            i = 0\\n            # keep a pointer to the start of the node, in case the number of nodes \\n            start = curr\\n            while curr and i < ctr:\\n                # keep track of previous node in case we need to reverse\\n                next_prev_node = curr\\n                curr = curr.next\\n                i += 1\\n            # if the count of nodes in this iteration are even, then we need to reverse\\n            if not i & 1:\\n                tail = start\\n                curr = start\\n                # to reverse\\n                temp_prev = None\\n                j = 0\\n                # continue the iteration for the number of nodes seen in this step (ctr)\\n                while curr and j < i:\\n                    next_node = curr.next\\n                    curr.next = temp_prev\\n                    temp_prev = curr\\n                    curr = next_node\\n                    j += 1\\n                prev.next = temp_prev\\n                tail.next = curr\\n                # since it is reversed the new previous node will be the tail of current list\\n                prev = tail\\n            else:\\n                # if not reversed the previous node will be the next_prev_node\\n                prev = next_prev_node\\n            ctr += 1\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727274,
                "title": "easy-solution-using-intution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst Copy all the elements of linked list. divide each group , whenever a group length is even, reverse it using stack. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI collected all the elements of the linked list using cursor, until cursor is `NULL`. Divide it into groups of increasing sizes (ind + n  gives the start of next group). until ind + n is less than size of vector. If the size of last group is even reverse that part also. \\n\\n# Complexity\\n- Time complexity:O(N2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nUpvote if you like this approach \\uD83D\\uDC4D\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    // reversing the vector from start to end\\n    void rev(vector<int>& v, int start, int end){\\n        stack<int> st; \\n        for(int i=start; i<= end; i++) st.push(v[i]); \\n        for(int i=start; i<= end; i++){v[i] = st.top(); st.pop(); }\\n\\n    }\\n\\n    //Dividing the vector into parts and reversing even sized ones\\n    void modify(vector<int>& v){\\n     // ind stores the starting index of group and n the size of group\\n      int ind = 0, n = 1; \\n      while(ind + n < v.size()){\\n          if(n%2 == 0){\\n              rev(v, ind, ind+n-1); ind += n; n++; \\n          }\\n          else {\\n              ind += n; n++; \\n          }\\n      }\\n     // checking length of last group \\n      if((v.size() - ind)%2 == 0) rev(v, ind, v.size()-1); \\n\\n\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* cursor = head; vector<int> v; \\n    // Copying the elements of linked list to a vector. \\n        while(cursor){v.push_back(cursor->val); cursor = cursor->next; }\\n        modify(v); \\n        cursor = head; \\n        for(int i=0; i<v.size(); i++){\\n            cursor->val = v[i]; cursor = cursor->next; \\n        }\\n\\n        return head; \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    // reversing the vector from start to end\\n    void rev(vector<int>& v, int start, int end){\\n        stack<int> st; \\n        for(int i=start; i<= end; i++) st.push(v[i]); \\n        for(int i=start; i<= end; i++){v[i] = st.top(); st.pop(); }\\n\\n    }\\n\\n    //Dividing the vector into parts and reversing even sized ones\\n    void modify(vector<int>& v){\\n     // ind stores the starting index of group and n the size of group\\n      int ind = 0, n = 1; \\n      while(ind + n < v.size()){\\n          if(n%2 == 0){\\n              rev(v, ind, ind+n-1); ind += n; n++; \\n          }\\n          else {\\n              ind += n; n++; \\n          }\\n      }\\n     // checking length of last group \\n      if((v.size() - ind)%2 == 0) rev(v, ind, v.size()-1); \\n\\n\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* cursor = head; vector<int> v; \\n    // Copying the elements of linked list to a vector. \\n        while(cursor){v.push_back(cursor->val); cursor = cursor->next; }\\n        modify(v); \\n        cursor = head; \\n        for(int i=0; i<v.size(); i++){\\n            cursor->val = v[i]; cursor = cursor->next; \\n        }\\n\\n        return head; \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720968,
                "title": "c-program-recursion",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode *reverseList(struct ListNode *head)\\n{\\n    if (head == NULL || head->next == NULL)\\n    {\\n        return head;\\n    }\\n    struct ListNode *prev = NULL;\\n    struct ListNode *curr = head;\\n    struct ListNode *Next = head->next;\\n    while (curr->next != NULL)\\n    {\\n        curr->next = prev;\\n        prev = curr;\\n        curr = Next;\\n        Next = curr->next;\\n    }\\n    curr->next = prev;\\n    return curr;\\n}\\nint len(struct ListNode *temp)\\n{\\n    int count = 0;\\n    while (temp != NULL)\\n    {\\n        count++;\\n        temp = temp->next;\\n    }\\n    return count;\\n}\\nstruct ListNode *reverseEven(struct ListNode *head, int k)\\n{\\n    if (len(head) < k)\\n    {\\n        if(len(head)%2==0)\\n        {\\n            return reverseList(head);\\n        }\\n        else\\n        {\\n            return head;\\n        }\\n    }\\n    else\\n    {\\n        int i = 0;\\n        if (k % 2 == 0)\\n        {\\n\\n            struct ListNode *prev = NULL;\\n            struct ListNode *curr = head;\\n            struct ListNode *Next = curr->next;\\n            struct ListNode *temp = head;\\n            while (i < k)\\n            {\\n                curr->next = prev;\\n                prev = curr;\\n                curr = Next;\\n                if (Next != NULL)\\n                {\\n\\n                    Next = curr->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n                i++;\\n            }\\n            head->next = reverseEven(curr, k+1);\\n            return prev;\\n        }\\n        else\\n        {\\n            struct ListNode *temp = head;\\n            while(i<k-1\\n            )\\n            {\\n                temp=temp->next;\\n                i++;\\n            }\\n            temp->next=reverseEven(temp->next,k+1);\\n            return head;\\n        }\\n    }\\n}\\nstruct ListNode *reverseEvenLengthGroups(struct ListNode *head)\\n{\\n    return reverseEven(head, 1);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode *reverseList(struct ListNode *head)\\n{\\n    if (head == NULL || head->next == NULL)\\n    {\\n        return head;\\n    }\\n    struct ListNode *prev = NULL;\\n    struct ListNode *curr = head;\\n    struct ListNode *Next = head->next;\\n    while (curr->next != NULL)\\n    {\\n        curr->next = prev;\\n        prev = curr;\\n        curr = Next;\\n        Next = curr->next;\\n    }\\n    curr->next = prev;\\n    return curr;\\n}\\nint len(struct ListNode *temp)\\n{\\n    int count = 0;\\n    while (temp != NULL)\\n    {\\n        count++;\\n        temp = temp->next;\\n    }\\n    return count;\\n}\\nstruct ListNode *reverseEven(struct ListNode *head, int k)\\n{\\n    if (len(head) < k)\\n    {\\n        if(len(head)%2==0)\\n        {\\n            return reverseList(head);\\n        }\\n        else\\n        {\\n            return head;\\n        }\\n    }\\n    else\\n    {\\n        int i = 0;\\n        if (k % 2 == 0)\\n        {\\n\\n            struct ListNode *prev = NULL;\\n            struct ListNode *curr = head;\\n            struct ListNode *Next = curr->next;\\n            struct ListNode *temp = head;\\n            while (i < k)\\n            {\\n                curr->next = prev;\\n                prev = curr;\\n                curr = Next;\\n                if (Next != NULL)\\n                {\\n\\n                    Next = curr->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n                i++;\\n            }\\n            head->next = reverseEven(curr, k+1);\\n            return prev;\\n        }\\n        else\\n        {\\n            struct ListNode *temp = head;\\n            while(i<k-1\\n            )\\n            {\\n                temp=temp->next;\\n                i++;\\n            }\\n            temp->next=reverseEven(temp->next,k+1);\\n            return head;\\n        }\\n    }\\n}\\nstruct ListNode *reverseEvenLengthGroups(struct ListNode *head)\\n{\\n    return reverseEven(head, 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3696908,
                "title": "beats-97-80-java-solution-linkedlist",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null) return head;\\n\\n        int grpSize = 1;\\n        int cnt = 0;\\n\\n        ListNode left = null;\\n        ListNode last = null;\\n        ListNode ptr = head;\\n\\n        while(ptr != null){\\n            cnt++;\\n            if(cnt == grpSize){\\n                if(grpSize% 2 == 0 ){\\n                    ListNode end = ptr.next;\\n                    // reverse the lst;\\n                    ListNode curr = left;\\n                    ListNode next = null;\\n                    ListNode prev = ptr.next;\\n\\n                    while(curr != end){\\n                        next = curr.next;\\n                        curr.next = prev;\\n                        prev = curr;\\n                        curr = next;\\n                    }\\n                    //connect\\n                    last.next = prev;\\n                    ptr = left;\\n                }\\n                last = ptr;\\n                left = ptr.next;\\n                cnt = 0;\\n                grpSize++;\\n            }\\n            ptr = ptr.next;\\n        }\\n\\n        if(cnt > 0 && cnt % 2 == 0) {\\n            // reverse\\n            ListNode cur = left;\\n            ListNode next = null;\\n            ListNode prev = ptr;\\n\\n            while(cur != null) {\\n                next = cur.next;\\n                cur.next = prev;\\n                prev = cur;\\n                cur = next;\\n            }\\n\\n            last.next = prev;\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null) return head;\\n\\n        int grpSize = 1;\\n        int cnt = 0;\\n\\n        ListNode left = null;\\n        ListNode last = null;\\n        ListNode ptr = head;\\n\\n        while(ptr != null){\\n            cnt++;\\n            if(cnt == grpSize){\\n                if(grpSize% 2 == 0 ){\\n                    ListNode end = ptr.next;\\n                    // reverse the lst;\\n                    ListNode curr = left;\\n                    ListNode next = null;\\n                    ListNode prev = ptr.next;\\n\\n                    while(curr != end){\\n                        next = curr.next;\\n                        curr.next = prev;\\n                        prev = curr;\\n                        curr = next;\\n                    }\\n                    //connect\\n                    last.next = prev;\\n                    ptr = left;\\n                }\\n                last = ptr;\\n                left = ptr.next;\\n                cnt = 0;\\n                grpSize++;\\n            }\\n            ptr = ptr.next;\\n        }\\n\\n        if(cnt > 0 && cnt % 2 == 0) {\\n            // reverse\\n            ListNode cur = left;\\n            ListNode next = null;\\n            ListNode prev = ptr;\\n\\n            while(cur != null) {\\n                next = cur.next;\\n                cur.next = prev;\\n                prev = cur;\\n                cur = next;\\n            }\\n\\n            last.next = prev;\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671444,
                "title": "easy-implementation-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute Force\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimulate the process .\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int len=0;\\n        ListNode* p=head;\\n        while(p!=NULL){\\n            len++;\\n            p=p->next;\\n        }\\n        int gr=1;\\n        int cov=0;\\n        ListNode* curr=head;\\n        ListNode* prev;\\n        while(curr!=NULL){\\n            if((gr%2==0 && (len-cov)>=gr)|| ((len-cov)%2==0 && (len-cov)<=gr)){\\n                ListNode* a=curr;\\n                ListNode* b=a->next;\\n                ListNode* cur=b->next;\\n                ListNode* end=curr;\\n                int ct=gr;\\n                while(ct-- && end!=NULL){\\n                    end=end->next;\\n                }\\n                while(cur!=NULL && cur!=end){\\n                    b->next=a;\\n                    a=b;\\n                    b=cur;\\n                    cur=cur->next;\\n                }\\n                b->next=a;\\n                curr->next=end;\\n                prev->next=b;\\n                prev=curr;\\n                curr=end;\\n            }else{\\n                int ct=gr;\\n                while(ct-- && curr!=NULL){\\n                    prev=curr;\\n                    curr=curr->next;\\n                }\\n            }\\n            cov+=gr;\\n            gr++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int len=0;\\n        ListNode* p=head;\\n        while(p!=NULL){\\n            len++;\\n            p=p->next;\\n        }\\n        int gr=1;\\n        int cov=0;\\n        ListNode* curr=head;\\n        ListNode* prev;\\n        while(curr!=NULL){\\n            if((gr%2==0 && (len-cov)>=gr)|| ((len-cov)%2==0 && (len-cov)<=gr)){\\n                ListNode* a=curr;\\n                ListNode* b=a->next;\\n                ListNode* cur=b->next;\\n                ListNode* end=curr;\\n                int ct=gr;\\n                while(ct-- && end!=NULL){\\n                    end=end->next;\\n                }\\n                while(cur!=NULL && cur!=end){\\n                    b->next=a;\\n                    a=b;\\n                    b=cur;\\n                    cur=cur->next;\\n                }\\n                b->next=a;\\n                curr->next=end;\\n                prev->next=b;\\n                prev=curr;\\n                curr=end;\\n            }else{\\n                int ct=gr;\\n                while(ct-- && curr!=NULL){\\n                    prev=curr;\\n                    curr=curr->next;\\n                }\\n            }\\n            cov+=gr;\\n            gr++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668258,
                "title": "i-woke-up-and-wrote-perfect-code",
                "content": "# Intuition\\nI didn\\'t like any of the solutions, so I slept. When I woke up I coded this in one go. I like how clean this is compared to my previous tries at this problem. \\nIt is verry self explanatory to just know when we are entering a odd section and even section. \\nThat is denoted by \\n\\n```\\nnodesRemaining\\n``` \\n\\nIf we enter odd, we just traverse over the section till our head is in even section\\n\\nIf we enter even we just use the reverse trick of reversing a Linked List - II problem to cover it in single pass.\\n\\n```\\nwhile(--count && head ){\\n            if(head->next){\\n                ListNode *fwd = head->next;\\n                ListNode *tmp = fwd->next;\\n                fwd->next = prev->next;\\n                head->next = tmp;\\n                prev->next = fwd;\\n            }\\n        }\\n\\n```\\neg.    lets say we just entered section of even with count 4 and want to reverse A->B->C->D\\n\\n```\\n.... X -> A -> B-> C ->D ->Z ....\\nPrev ->  X\\nHead -> A\\n\\n```\\nthen assign as following:\\n\\n```\\n.... X -> A -> B-> C ->D ->Z ....\\n     P    H    F   T\\n\\nwhere P=> prev, H=> head, F=> forward, T=>tmp\\n\\n```\\nSince, we have a pointer T to the remaining chain we can directly make F point to something else. But to what?\\n\\nIf we make it point to H, then Prev will connect to the wrong stuff for the case where :\\n\\n```\\n.... X -> C -> B-> A ->D ->Z ....\\n     P             H   F  T\\n\\n\\n```\\nSo, we  must make F go the beginning of whatever we reversed till now\\nSo \\n\\n```\\nF-> next = P-> next;\\n\\n```\\nThis was the key observation, \\nNow, we make our head drag its way always to connect with T. You can directly join H to T as H doesnt need to point to F anymore\\n\\n```\\nhead->next = tmp\\n\\n```\\nand subsequently just make P point to F since its the newest addition in the back of reversed string up till now\\n\\n```\\nprev->next = fwd;\\n\\n```\\n\\nKeep doing this till we have Head->next && --count still present as if it is present then it means there is something in front (F) of head which we must move back\\n\\n\\n```\\n.... X -> D -> C-> B -> A ->Z -> NULL\\n     P                  H   F     T\\n\\n\\n```\\n\\nAt the end Head will still be pointing to an element of even section and thats why we move it along to enter the odd section as in below code.\\n\\nWe also Need to help the prev move over the whole section once we have covered so the lines of \\n\\n```\\n prev = head;\\n        if(head->next){\\n            head = head->next;\\n        }\\n        return head;\\n```\\nSo finally we get:\\n\\n\\n```\\n.... X -> C -> B-> A ->D ->Z ....\\n                   P   H\\n                       odd section starts from D\\n\\n\\n```\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n O(2n) = O(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode *prev;\\n\\n    ListNode* traverseOdd(ListNode *head, int count){\\n        for(int i=0;i<count;i++){\\n            if(head->next != nullptr){\\n                prev = head;\\n                head = head->next;\\n            } else {\\n                return head;\\n            }\\n        }\\n        return head;\\n    }\\n\\n    ListNode* reverseEven(ListNode* head, int count){\\n        \\n        while(--count && head ){\\n            if(head->next){\\n                ListNode *fwd = head->next;\\n                ListNode *tmp = fwd->next;\\n                fwd->next = prev->next;\\n                head->next = tmp;\\n                prev->next = fwd;\\n            }\\n        }\\n        prev = head;\\n        if(head->next){\\n            head = head->next;\\n        }\\n        return head;\\n\\n    }\\n\\n    int countForward(ListNode* tmp, int count) {\\n        int j = 0;\\n        while(tmp && j<count) {\\n            tmp = tmp->next;\\n            j++;\\n        }\\n        return j;\\n\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head == nullptr){\\n            return head;\\n        }\\n        ListNode *dummy = new ListNode(0);\\n        dummy = head;\\n        int count = 1;\\n        prev = new ListNode(0);\\n        prev->next = head;\\n        while(head->next){\\n            ListNode* tmp = head;\\n            int nodesRemaining = countForward(tmp, count);\\n            if(nodesRemaining >= count){\\n                if(count%2){\\n                    head = traverseOdd(head, count);\\n                } else {\\n                    head = reverseEven(head, count); \\n                }\\n            } else {\\n                if(nodesRemaining%2){\\n                     head = traverseOdd(head, nodesRemaining);\\n                } else {\\n                    head = reverseEven(head, nodesRemaining); \\n                }\\n            }\\n            \\n        count++;\\n        }\\n        return dummy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nnodesRemaining\\n```\n```\\nwhile(--count && head ){\\n            if(head->next){\\n                ListNode *fwd = head->next;\\n                ListNode *tmp = fwd->next;\\n                fwd->next = prev->next;\\n                head->next = tmp;\\n                prev->next = fwd;\\n            }\\n        }\\n\\n```\n```\\n.... X -> A -> B-> C ->D ->Z ....\\nPrev ->  X\\nHead -> A\\n\\n```\n```\\n.... X -> A -> B-> C ->D ->Z ....\\n     P    H    F   T\\n\\nwhere P=> prev, H=> head, F=> forward, T=>tmp\\n\\n```\n```\\n.... X -> C -> B-> A ->D ->Z ....\\n     P             H   F  T\\n\\n\\n```\n```\\nF-> next = P-> next;\\n\\n```\n```\\nhead->next = tmp\\n\\n```\n```\\nprev->next = fwd;\\n\\n```\n```\\n.... X -> D -> C-> B -> A ->Z -> NULL\\n     P                  H   F     T\\n\\n\\n```\n```\\n prev = head;\\n        if(head->next){\\n            head = head->next;\\n        }\\n        return head;\\n```\n```\\n.... X -> C -> B-> A ->D ->Z ....\\n                   P   H\\n                       odd section starts from D\\n\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode *prev;\\n\\n    ListNode* traverseOdd(ListNode *head, int count){\\n        for(int i=0;i<count;i++){\\n            if(head->next != nullptr){\\n                prev = head;\\n                head = head->next;\\n            } else {\\n                return head;\\n            }\\n        }\\n        return head;\\n    }\\n\\n    ListNode* reverseEven(ListNode* head, int count){\\n        \\n        while(--count && head ){\\n            if(head->next){\\n                ListNode *fwd = head->next;\\n                ListNode *tmp = fwd->next;\\n                fwd->next = prev->next;\\n                head->next = tmp;\\n                prev->next = fwd;\\n            }\\n        }\\n        prev = head;\\n        if(head->next){\\n            head = head->next;\\n        }\\n        return head;\\n\\n    }\\n\\n    int countForward(ListNode* tmp, int count) {\\n        int j = 0;\\n        while(tmp && j<count) {\\n            tmp = tmp->next;\\n            j++;\\n        }\\n        return j;\\n\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head == nullptr){\\n            return head;\\n        }\\n        ListNode *dummy = new ListNode(0);\\n        dummy = head;\\n        int count = 1;\\n        prev = new ListNode(0);\\n        prev->next = head;\\n        while(head->next){\\n            ListNode* tmp = head;\\n            int nodesRemaining = countForward(tmp, count);\\n            if(nodesRemaining >= count){\\n                if(count%2){\\n                    head = traverseOdd(head, count);\\n                } else {\\n                    head = reverseEven(head, count); \\n                }\\n            } else {\\n                if(nodesRemaining%2){\\n                     head = traverseOdd(head, nodesRemaining);\\n                } else {\\n                    head = reverseEven(head, nodesRemaining); \\n                }\\n            }\\n            \\n        count++;\\n        }\\n        return dummy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659487,
                "title": "javascript-solution",
                "content": "# Complexity\\n- Time complexity:\\nAmortized O(n), as the check for `isEvenGroup` occurs in the last group, which increases proportionally to n, resulting in a complexity of O(sqrt(n)). However, these calculations can be shared among other groups, thus leading to an amortized complexity of O(1) for `isEvenGroup`\\n\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar reverseEvenLengthGroups = function(head) {\\n    if(head?.next?.next == null) {\\n        return head;\\n    }\\n    let fastNode = head;\\n    let slowNode = head;\\n\\n    let firstNode = head;\\n    let nthGroup = 2;\\n    while(slowNode != null && slowNode.next != null) {\\n        fastNode = fastNode?.next?.next\\n        firstNode = slowNode;\\n        slowNode = slowNode.next;\\n        if(fastNode != null && nthGroup % 2 === 0 || fastNode == null && isEvenGroup(slowNode)) {\\n            [fastNode, slowNode] = reverseNodesMutation(firstNode, slowNode, fastNode)\\n        }\\n\\n        nthGroup++\\n        for(let i = 0; i < nthGroup - 2; i++) {\\n            fastNode = fastNode?.next;\\n            slowNode = slowNode?.next;\\n        }\\n    }\\n    return head;\\n};\\n\\nfunction isEvenGroup(slowNode) {\\n    let count = 0;\\n    while(slowNode != null) {\\n        slowNode = slowNode.next;\\n        count++\\n    }\\n    return count % 2 === 0;\\n}\\n\\n// 0 | 1 2 null |\\nfunction reverseNodesMutation(firstNode, slowNode, fastNode) {\\n    const lastNode = fastNode?.next ?? null;\\n    let prevSlowNode = lastNode;\\n    let slowNodePointer = slowNode;\\n    while(slowNodePointer != lastNode) {\\n        const nextSlowNode = slowNodePointer.next;\\n        slowNodePointer.next = prevSlowNode;\\n        prevSlowNode = slowNodePointer\\n        slowNodePointer = nextSlowNode\\n    }\\n    firstNode.next = fastNode ?? prevSlowNode\\n    return [slowNode, fastNode];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar reverseEvenLengthGroups = function(head) {\\n    if(head?.next?.next == null) {\\n        return head;\\n    }\\n    let fastNode = head;\\n    let slowNode = head;\\n\\n    let firstNode = head;\\n    let nthGroup = 2;\\n    while(slowNode != null && slowNode.next != null) {\\n        fastNode = fastNode?.next?.next\\n        firstNode = slowNode;\\n        slowNode = slowNode.next;\\n        if(fastNode != null && nthGroup % 2 === 0 || fastNode == null && isEvenGroup(slowNode)) {\\n            [fastNode, slowNode] = reverseNodesMutation(firstNode, slowNode, fastNode)\\n        }\\n\\n        nthGroup++\\n        for(let i = 0; i < nthGroup - 2; i++) {\\n            fastNode = fastNode?.next;\\n            slowNode = slowNode?.next;\\n        }\\n    }\\n    return head;\\n};\\n\\nfunction isEvenGroup(slowNode) {\\n    let count = 0;\\n    while(slowNode != null) {\\n        slowNode = slowNode.next;\\n        count++\\n    }\\n    return count % 2 === 0;\\n}\\n\\n// 0 | 1 2 null |\\nfunction reverseNodesMutation(firstNode, slowNode, fastNode) {\\n    const lastNode = fastNode?.next ?? null;\\n    let prevSlowNode = lastNode;\\n    let slowNodePointer = slowNode;\\n    while(slowNodePointer != lastNode) {\\n        const nextSlowNode = slowNodePointer.next;\\n        slowNodePointer.next = prevSlowNode;\\n        prevSlowNode = slowNodePointer\\n        slowNodePointer = nextSlowNode\\n    }\\n    firstNode.next = fastNode ?? prevSlowNode\\n    return [slowNode, fastNode];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3653124,
                "title": "python-in-place-reversal-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        #count total_length\\n        def count_length(head):\\n            pointer, counter = head, 0\\n            while pointer:\\n                pointer, counter = pointer.next, counter + 1\\n            return counter\\n\\n        #reverse n nodes starting from parent.next\\n        def reverse_n_nodes(parent, n):\\n            prev, current, next_ = parent.next, parent.next.next, parent.next.next.next\\n            tail = prev\\n            for i in range(n - 1):\\n                parent.next = current\\n                current.next = prev\\n                prev, current, next_ = current, next_, next_.next if next_ else None\\n            tail.next = current\\n            return tail\\n            \\n        total_length, length, parent = count_length(head), 1, ListNode(-1, head)\\n\\n        while total_length > 0:\\n            if length % 2 == 1:\\n                # Go to the parent of the next group\\n                for i in range(length):\\n                    parent = parent.next\\n            else:\\n                #Reverse length nodes\\n                parent = reverse_n_nodes(parent, length)\\n            total_length -= length\\n            length = min(length + 1, total_length)\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        #count total_length\\n        def count_length(head):\\n            pointer, counter = head, 0\\n            while pointer:\\n                pointer, counter = pointer.next, counter + 1\\n            return counter\\n\\n        #reverse n nodes starting from parent.next\\n        def reverse_n_nodes(parent, n):\\n            prev, current, next_ = parent.next, parent.next.next, parent.next.next.next\\n            tail = prev\\n            for i in range(n - 1):\\n                parent.next = current\\n                current.next = prev\\n                prev, current, next_ = current, next_, next_.next if next_ else None\\n            tail.next = current\\n            return tail\\n            \\n        total_length, length, parent = count_length(head), 1, ListNode(-1, head)\\n\\n        while total_length > 0:\\n            if length % 2 == 1:\\n                # Go to the parent of the next group\\n                for i in range(length):\\n                    parent = parent.next\\n            else:\\n                #Reverse length nodes\\n                parent = reverse_n_nodes(parent, length)\\n            total_length -= length\\n            length = min(length + 1, total_length)\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651016,
                "title": "c-reverse-nodes-in-even-length-groups",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* Reverse(ListNode* p, ListNode* q){\\n        ListNode* prev = nullptr;\\n        ListNode* curr = p;\\n        ListNode* next = nullptr;\\n        \\n        while (curr != nullptr && curr != q) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        curr->next = prev;\\n        prev = curr;\\n        return prev;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *ans=head, *p =head->next, *curr = head, *s, *e, *t, *z;\\n        int x = 1, n = 1, a;\\n        while(p){\\n            t = p;\\n            s = p;\\n            x = 1 + x;\\n            a = x;\\n            n=1;\\n            while(a>1 && t->next){\\n                t = t->next;\\n                a--;\\n                n++;\\n            }\\n            e = t;\\n            p = t->next;\\n            if(n%2 == 0){\\n                z = Reverse(s, e);\\n                curr->next = z;\\n                while(curr->next){\\n                    curr = curr->next;\\n                }\\n            }\\n            else{\\n                curr->next = s;\\n                curr = e;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* Reverse(ListNode* p, ListNode* q){\\n        ListNode* prev = nullptr;\\n        ListNode* curr = p;\\n        ListNode* next = nullptr;\\n        \\n        while (curr != nullptr && curr != q) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        curr->next = prev;\\n        prev = curr;\\n        return prev;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *ans=head, *p =head->next, *curr = head, *s, *e, *t, *z;\\n        int x = 1, n = 1, a;\\n        while(p){\\n            t = p;\\n            s = p;\\n            x = 1 + x;\\n            a = x;\\n            n=1;\\n            while(a>1 && t->next){\\n                t = t->next;\\n                a--;\\n                n++;\\n            }\\n            e = t;\\n            p = t->next;\\n            if(n%2 == 0){\\n                z = Reverse(s, e);\\n                curr->next = z;\\n                while(curr->next){\\n                    curr = curr->next;\\n                }\\n            }\\n            else{\\n                curr->next = s;\\n                curr = e;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649759,
                "title": "kotlin-same-as-all-other-solutions-o-n-o-1-no-negative-marking-for-bad-humour",
                "content": "# Intuition\\nTrack groups with even nodes ( edge case where last group was odd but has only even nodes due to shortage, is also part of this)\\n# Approach\\nTraverse the whole LL from start to end. For each group maintain the following: \\n- Group number\\n- Number of nodes in the group\\n- Pointer to start of current group\\n\\nFor reversing the LL, we need to perform the few extra steps as follows:\\n- The start of LL will be end so store it and return so that p can be updated\\n- start and end are actually subset of a bigger LL so point the end and terminal nodes. \\n- Happy reversing. \\n\\n# Complexity\\n- Time complexity:\\nO(N + N/2)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        var group = 1   // Holds the group number\\n        var groupCounter = 0  // Number of nodes in current group\\n        var prevGroupNode = head  // Start of our current group\\n        var p = head\\n        while(p != null){\\n            ++groupCounter\\n            if(groupCounter == group || p!!.next == null){ // End of current group\\n                if(groupCounter % 2 == 0){\\n                    p = swap(prevGroupNode, prevGroupNode!!.next, prevGroupNode!!.next!!.next, p)\\n                }\\n                groupCounter = 0\\n                prevGroupNode = p\\n                ++group\\n            }\\n            p = p!!.next\\n        }\\n        return head\\n    }\\n\\n    // None of these will be [null] to begin with as we will be reversing atleast 2 nodes\\n    // Endnode is required to understand the terminal condition as it will not be null\\n    fun swap( p1: ListNode?, p2: ListNode?, p3: ListNode?, endNode: ListNode?): ListNode? { \\n\\n        // Please forgive me for shadowing some good vals. Kids this is bad coding. Don\\'t follow this at home\\n        var p1 = p1  \\n        var p2 = p2\\n        var p3 = p3\\n\\n        // Preparation\\n        var op = p2 // This will be our new p\\n        p1!!.next = endNode\\n        p2!!.next = endNode!!.next\\n\\n        // Time to move pointers after preparations\\n        p1 = p2\\n        p2 = p3\\n        p3 = p3!!.next\\n\\n        // Happy hunting\\n        while(p1 != endNode){\\n            p2!!.next = p1\\n            p1 = p2\\n            p2 = p3\\n            if(p3 != null)\\n            p3 = p3!!.next\\n        }\\n\\n        // Dinner is ready\\n        return op\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun reverseEvenLengthGroups(head: ListNode?): ListNode? {\\n        var group = 1   // Holds the group number\\n        var groupCounter = 0  // Number of nodes in current group\\n        var prevGroupNode = head  // Start of our current group\\n        var p = head\\n        while(p != null){\\n            ++groupCounter\\n            if(groupCounter == group || p!!.next == null){ // End of current group\\n                if(groupCounter % 2 == 0){\\n                    p = swap(prevGroupNode, prevGroupNode!!.next, prevGroupNode!!.next!!.next, p)\\n                }\\n                groupCounter = 0\\n                prevGroupNode = p\\n                ++group\\n            }\\n            p = p!!.next\\n        }\\n        return head\\n    }\\n\\n    // None of these will be [null] to begin with as we will be reversing atleast 2 nodes\\n    // Endnode is required to understand the terminal condition as it will not be null\\n    fun swap( p1: ListNode?, p2: ListNode?, p3: ListNode?, endNode: ListNode?): ListNode? { \\n\\n        // Please forgive me for shadowing some good vals. Kids this is bad coding. Don\\'t follow this at home\\n        var p1 = p1  \\n        var p2 = p2\\n        var p3 = p3\\n\\n        // Preparation\\n        var op = p2 // This will be our new p\\n        p1!!.next = endNode\\n        p2!!.next = endNode!!.next\\n\\n        // Time to move pointers after preparations\\n        p1 = p2\\n        p2 = p3\\n        p3 = p3!!.next\\n\\n        // Happy hunting\\n        while(p1 != endNode){\\n            p2!!.next = p1\\n            p1 = p2\\n            p2 = p3\\n            if(p3 != null)\\n            p3 = p3!!.next\\n        }\\n\\n        // Dinner is ready\\n        return op\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636539,
                "title": "short-clean-c-o-n-constant-space-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind my approach is similar to other solutions but just cleaner code for your reference. Basically it involves 3 steps:\\n1. obtain the actual current group length\\n2. reverse the group if actual length turns to be even length\\n3. reconnect the disconnected group due to reversal. Reset some pointers for the next iteration\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first 2 steps are intuitive and should be easy to implement. For the 3rd step, it\\'s a little bit tricky to get all details right. In my approach, I have the head and end pointers pointing to the starting and ending node of each group. When the reversal is happening, set the prev pointer to be the next group\\'s first node so that it automatically connects the reversed group to the rest of the linked list. Then, we only need to reconnect the previous part of the linked list by pointing prev->next to the original ending node, which is the starting node of the reveresed group.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) since we linearly iterate through the list\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) since fixed number of variables are used\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *end = head, *prev = nullptr, *newHead = head;\\n        for (int groupLen = 1; head; ++groupLen, prev = head, head = head->next, end = head) {\\n            int currLen = 1;\\n            while (currLen < groupLen && end->next) {\\n                end = end->next;\\n                ++currLen;\\n            }\\n\\n            if (currLen % 2 == 0) {\\n                reverseList(head, end->next);\\n                prev->next = end;\\n            } else {\\n                head = end;\\n            }\\n        }\\n        return newHead;\\n    }\\n\\nprivate:\\n    void reverseList(ListNode* head, ListNode* end) {\\n        ListNode *prev = end, *next = head;\\n        while (head != end) {\\n            next = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *end = head, *prev = nullptr, *newHead = head;\\n        for (int groupLen = 1; head; ++groupLen, prev = head, head = head->next, end = head) {\\n            int currLen = 1;\\n            while (currLen < groupLen && end->next) {\\n                end = end->next;\\n                ++currLen;\\n            }\\n\\n            if (currLen % 2 == 0) {\\n                reverseList(head, end->next);\\n                prev->next = end;\\n            } else {\\n                head = end;\\n            }\\n        }\\n        return newHead;\\n    }\\n\\nprivate:\\n    void reverseList(ListNode* head, ListNode* end) {\\n        ListNode *prev = end, *next = head;\\n        while (head != end) {\\n            next = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613934,
                "title": "c-solution-with-explanation",
                "content": "# EXPLANATION\\nWe started from the first node of list.\\nWe kept a count **i** for the **i**th group of list.\\nOur intuition is that we check for **i**th group.\\nIf that group has even length we reverse that set of list or else move formward to the next group.\\nFinally returning the answer.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *a=head;\\n        int i=1;\\n        while(a){\\n            i++;\\n            int j=0;\\n            ListNode *b=a->next,*c=a;\\n            while(b && j<i){\\n                c=c->next;\\n                j++;\\n                b=b->next;\\n            }\\n            if(j%2==0 && j!=0){\\n                ListNode *x=a->next,*y=NULL,*z=x,*t=a->next;\\n                while(j-->0){\\n                    z=x->next;\\n                    x->next=y;\\n                    y=x;\\n                    x=z;\\n                }\\n                a->next=y;\\n                a=t;\\n                a->next=x;\\n            }\\n            else if(b)\\n                a=c;\\n            else \\n                a=b;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *a=head;\\n        int i=1;\\n        while(a){\\n            i++;\\n            int j=0;\\n            ListNode *b=a->next,*c=a;\\n            while(b && j<i){\\n                c=c->next;\\n                j++;\\n                b=b->next;\\n            }\\n            if(j%2==0 && j!=0){\\n                ListNode *x=a->next,*y=NULL,*z=x,*t=a->next;\\n                while(j-->0){\\n                    z=x->next;\\n                    x->next=y;\\n                    y=x;\\n                    x=z;\\n                }\\n                a->next=y;\\n                a=t;\\n                a->next=x;\\n            }\\n            else if(b)\\n                a=c;\\n            else \\n                a=b;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611498,
                "title": "python-solution",
                "content": "# Intuition\\nUse a similar approach to [reverse nodes in k-group](https://leetcode.com/problems/reverse-nodes-in-k-group/solutions/3071426/c-solution/). Create a helper function to reverse a linked list that keeps track of the next node to the reversal and make sure we link each group (reversed with non-reversed).\\n\\n# Approach\\nKeep track of the groups and the size. Make a reversal function that ties together the next node from the current group being reversed. We also need to keep track of the current size of the list and choose the minimum between the group size and the remaining size.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def size(self, head):\\n        size = 0\\n        while head:\\n            size, head = size + 1, head.next\\n        return size\\n\\n    def reverse(self, head, count):\\n        # previous, current, tail is next node after reversal\\n        prev, current, tail = None, head, None\\n        while current and count > 0:\\n            next = current.next           \\n\\n            tail = next\\n            current.next = prev\\n            prev = current            \\n            current = next\\n            count -= 1\\n        # prev is the new head\\n        # head is the last\\n        # the next to head is tail\\n        head.next = tail\\n        return prev\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        sentinel = ListNode(0, head)\\n        tail, current = sentinel, sentinel.next\\n        size = self.size(head)\\n\\n        group = 1\\n        while current:\\n            group = min(group, size)\\n            if group % 2: # advance\\n                for _ in range(group):\\n                    tail.next = current\\n                    tail = tail.next\\n                    current = current.next\\n            else: # reversal\\n                tail.next = self.reverse(current, group)\\n                tail = current\\n                current = current.next\\n            size -= group\\n            group += 1        \\n        return sentinel.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def size(self, head):\\n        size = 0\\n        while head:\\n            size, head = size + 1, head.next\\n        return size\\n\\n    def reverse(self, head, count):\\n        # previous, current, tail is next node after reversal\\n        prev, current, tail = None, head, None\\n        while current and count > 0:\\n            next = current.next           \\n\\n            tail = next\\n            current.next = prev\\n            prev = current            \\n            current = next\\n            count -= 1\\n        # prev is the new head\\n        # head is the last\\n        # the next to head is tail\\n        head.next = tail\\n        return prev\\n\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        sentinel = ListNode(0, head)\\n        tail, current = sentinel, sentinel.next\\n        size = self.size(head)\\n\\n        group = 1\\n        while current:\\n            group = min(group, size)\\n            if group % 2: # advance\\n                for _ in range(group):\\n                    tail.next = current\\n                    tail = tail.next\\n                    current = current.next\\n            else: # reversal\\n                tail.next = self.reverse(current, group)\\n                tail = current\\n                current = current.next\\n            size -= group\\n            group += 1        \\n        return sentinel.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609344,
                "title": "java-solution-o-n-time-o-1-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // pointer before a group\\n        var before = head;\\n\\n        // max nodes in a group (but may be less if the group is the last)\\n        int max = 2; //start with second group right away\\n\\n        while (before.next != null) { // pass through a group\\n            int len = 0;\\n            var curr = before;\\n            \\n            while (curr.next != null && len < max) {   \\n                curr = curr.next;\\n                len++;\\n            }\\n\\n            // group is even && len is even -> reverse\\n            // group is even && len is odd -> last group (odd) -> skip\\n            // group is odd && len is even -> last group (even) -> reverse\\n            // group is odd && len is odd -> reverse\\n            // all boils down to whether len is even or not\\n            if (len % 2 == 0) { // \\n                before = reverse(before, len);\\n            } else {\\n                before = curr;\\n            }\\n            \\n            max++;\\n        }\\n        return head;\\n    }\\n\\n    ListNode reverse(ListNode before, int len) {\\n        var first = before.next; \\n        var curr = first;\\n        ListNode prev = null;\\n        \\n        int count = 0;\\n        while (count < len ) { \\n            // swap pointers\\n            var next = curr.next; \\n            curr.next = prev; \\n            prev = curr; \\n            curr = next; \\n            \\n            count++;\\n        }\\n\\n        // swap node before the current group with last node in the group and  \\n        before.next = prev;\\n        // swap first node in group with first node outside the group\\n        first.next = curr;\\n\\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        // pointer before a group\\n        var before = head;\\n\\n        // max nodes in a group (but may be less if the group is the last)\\n        int max = 2; //start with second group right away\\n\\n        while (before.next != null) { // pass through a group\\n            int len = 0;\\n            var curr = before;\\n            \\n            while (curr.next != null && len < max) {   \\n                curr = curr.next;\\n                len++;\\n            }\\n\\n            // group is even && len is even -> reverse\\n            // group is even && len is odd -> last group (odd) -> skip\\n            // group is odd && len is even -> last group (even) -> reverse\\n            // group is odd && len is odd -> reverse\\n            // all boils down to whether len is even or not\\n            if (len % 2 == 0) { // \\n                before = reverse(before, len);\\n            } else {\\n                before = curr;\\n            }\\n            \\n            max++;\\n        }\\n        return head;\\n    }\\n\\n    ListNode reverse(ListNode before, int len) {\\n        var first = before.next; \\n        var curr = first;\\n        ListNode prev = null;\\n        \\n        int count = 0;\\n        while (count < len ) { \\n            // swap pointers\\n            var next = curr.next; \\n            curr.next = prev; \\n            prev = curr; \\n            curr = next; \\n            \\n            count++;\\n        }\\n\\n        // swap node before the current group with last node in the group and  \\n        before.next = prev;\\n        // swap first node in group with first node outside the group\\n        first.next = curr;\\n\\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598856,
                "title": "6-reverse-nodes-in-even-length-groups",
                "content": "#### Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI immediately thought of using a fast and slow pointers + keeping count of the current number of nodes in the group and the maximum number of nodes in the group. The later was correct, but the former was misguided. The objectives are the position of the last element of the previous group and the last element of the current group, which are needed for reversing. In that sense, it is sliding window, with the one side fixed at the last element of the previous group, while the other is dragged out to the last element of the current group. At each window, we check the oddity of the current number of nodes and reverse if necessary.\\n\\n#### Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the left pointer and max group length.\\n2. Iterate the linked list starting at `head.next` (the first element does not need to be reversed), one window up to the max group length at a time.\\n3. If there are even number of nodes in the window, reverse it. Else, do nothing.\\n4. Return `head` after modification.\\n\\n#### Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n)$: Iterate the linked list less than two times.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$: Store only some integers.\\n\\n#### Code\\n\\nThe shorthand reversal in Python is included in comments. While it looks awesome, I think that I should avoid it here as it makes debugging impossible and is certain to confuse my colleagues.\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        group_prev = head\\n        curr_max_length = 2\\n\\n        while group_prev.next:\\n            curr = group_prev\\n            count = 0\\n            \\n            for _ in range(curr_max_length):\\n                if not curr.next:\\n                    break\\n                count += 1\\n                curr = curr.next\\n\\n            if count % 2: # Odd, do nothing\\n                group_prev = curr\\n            else:         # Even, reverse\\n                group_next = curr.next\\n                curr = group_prev.next\\n                \\n                for _ in range(count):\\n                    # curr.next, curr, group_next = group_next, curr.next, curr\\n                    curr_next = curr.next\\n                    curr.next = group_next\\n                    group_next = curr\\n                    curr = curr_next\\n                # group_prev.next.next, group_prev.next, group_prev = curr, group_next, group_prev.next\\n                prev_next = group_prev.next\\n                group_prev.next = group_next\\n                group_prev = prev_next\\n            curr_max_length += 1\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        group_prev = head\\n        curr_max_length = 2\\n\\n        while group_prev.next:\\n            curr = group_prev\\n            count = 0\\n            \\n            for _ in range(curr_max_length):\\n                if not curr.next:\\n                    break\\n                count += 1\\n                curr = curr.next\\n\\n            if count % 2: # Odd, do nothing\\n                group_prev = curr\\n            else:         # Even, reverse\\n                group_next = curr.next\\n                curr = group_prev.next\\n                \\n                for _ in range(count):\\n                    # curr.next, curr, group_next = group_next, curr.next, curr\\n                    curr_next = curr.next\\n                    curr.next = group_next\\n                    group_next = curr\\n                    curr = curr_next\\n                # group_prev.next.next, group_prev.next, group_prev = curr, group_next, group_prev.next\\n                prev_next = group_prev.next\\n                group_prev.next = group_next\\n                group_prev = prev_next\\n            curr_max_length += 1\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585351,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        def reverse(node, size):\\n            prev = None\\n            curr = node\\n            fllw = None\\n\\n            for _ in range(size):\\n                fllw = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = fllw\\n\\n            return prev\\n\\n        group_starts = []\\n        curr = head\\n        group_size = 1 \\n        while curr:\\n            group_starts.append([group_size, curr])\\n            for _ in range(group_size):\\n                if curr:\\n                    curr = curr.next\\n            group_size += 1\\n        \\n        res = []\\n        count = 0\\n        for start in group_starts:\\n            count += 1\\n            if count == len(group_starts):\\n                # last element\\n                length = 0\\n                curr = start[1]\\n                while curr:\\n                    length += 1\\n                    curr = curr.next\\n                if length % 2 == 0:\\n                    res.append([start[0], reverse(start[1], length)])\\n                else:\\n                    res.append(start)\\n            elif start[0] % 2 == 0:\\n                res.append([start[0], reverse(start[1], start[0])])\\n            else:\\n                res.append(start)\\n\\n        dummy = tail = ListNode()\\n        for pair in res:\\n            size = pair[0]\\n            node = pair[1]\\n            tail.next = node\\n            for _ in range(size):\\n                if tail:\\n                    tail = tail.next\\n        \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        def reverse(node, size):\\n            prev = None\\n            curr = node\\n            fllw = None\\n\\n            for _ in range(size):\\n                fllw = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = fllw\\n\\n            return prev\\n\\n        group_starts = []\\n        curr = head\\n        group_size = 1 \\n        while curr:\\n            group_starts.append([group_size, curr])\\n            for _ in range(group_size):\\n                if curr:\\n                    curr = curr.next\\n            group_size += 1\\n        \\n        res = []\\n        count = 0\\n        for start in group_starts:\\n            count += 1\\n            if count == len(group_starts):\\n                # last element\\n                length = 0\\n                curr = start[1]\\n                while curr:\\n                    length += 1\\n                    curr = curr.next\\n                if length % 2 == 0:\\n                    res.append([start[0], reverse(start[1], length)])\\n                else:\\n                    res.append(start)\\n            elif start[0] % 2 == 0:\\n                res.append([start[0], reverse(start[1], start[0])])\\n            else:\\n                res.append(start)\\n\\n        dummy = tail = ListNode()\\n        for pair in res:\\n            size = pair[0]\\n            node = pair[1]\\n            tail.next = node\\n            for _ in range(size):\\n                if tail:\\n                    tail = tail.next\\n        \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579251,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can\\'t determine if the current group working on has enough length while traversing the group, so we must move forward some steps to determine if it has before deciding whether we reverse or not. We\\'ll have a auxilliary function `nextnum` to do this.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDetermine if the number of nodes from the current node equals the group length at every first node of groups.\\n\\nIf it does has the right number of nodes available, and the group number is even, we reverse such number of nodes. if it\\'s odd, just iterate through such number of nodes.\\n\\nIf not, it means that we meet the last group, with possibly 0 members. if the number it contains is not 0 and it is even, just reverse it like above, but with the number of nodes reversed be the number of this group, rather than the group number, as the current group does not have so many nodes as the group number.\\n\\nAbove is the main logic. Let\\'s talk about implementation.\\n\\nThe process of reversing and iterating nodes is similar, so we can use a single segment of code to do the both. In the code segment, we check whether the number of nodes we\\'re reversing is even, if so, just add some reversing specific code, like `cur->next = prev`.\\n\\nThere\\'s one thing to notice, after reversing the nodes, we have to modify `prev`, as after reversing, the node `prev` points to is indeed the start node of the reversed region, not the end node, we should ensure `prev` points to the right node by `prev = end`.\\n\\n\\n# Complexity\\n- Time complexity:O(n) obviously\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) obviously\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *prev(head),*cur(head->next);\\n        int gn(2);\\n        int n;\\n        while ((n = nextnum(cur,gn)) == gn) {\\n            //reverse or just iterate, depending on evenness of gn\\n            traverse(prev,cur,gn);\\n            ++gn;\\n        }\\n        //meets the last group with possibly 0 member\\n        if (n != 0 && !(n & 1)) {\\n            //reverse n nodes from cur\\n            traverse(prev,cur,n);\\n        }\\n        return head;\\n    }\\nprivate:\\n    //auxilliary counting function\\n    int nextnum(ListNode *node,int n) {\\n        int cnt(0);\\n        for (; node && cnt < n; ++cnt) {\\n            node = node->next;\\n        }\\n        return cnt;\\n    }\\n    void traverse(ListNode *&prev,ListNode *&cur,int n) {\\n        //save some ordinary infos in reversing process\\n        auto begprev = prev, end = cur;\\n        for (int i(0); i < n; ++i) {\\n            auto next = cur->next;\\n            //if we are reversing, some extra work is required\\n            if (!(n & 1)) {\\n                cur->next = prev;\\n            }\\n            prev = cur;\\n            cur = next;\\n        }\\n        //if we are reversing, some extra work is required\\n        if (!(n & 1)) {\\n            begprev->next = prev;\\n            end->next = cur;\\n            //adjust prev\\n            prev = end;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode *prev(head),*cur(head->next);\\n        int gn(2);\\n        int n;\\n        while ((n = nextnum(cur,gn)) == gn) {\\n            //reverse or just iterate, depending on evenness of gn\\n            traverse(prev,cur,gn);\\n            ++gn;\\n        }\\n        //meets the last group with possibly 0 member\\n        if (n != 0 && !(n & 1)) {\\n            //reverse n nodes from cur\\n            traverse(prev,cur,n);\\n        }\\n        return head;\\n    }\\nprivate:\\n    //auxilliary counting function\\n    int nextnum(ListNode *node,int n) {\\n        int cnt(0);\\n        for (; node && cnt < n; ++cnt) {\\n            node = node->next;\\n        }\\n        return cnt;\\n    }\\n    void traverse(ListNode *&prev,ListNode *&cur,int n) {\\n        //save some ordinary infos in reversing process\\n        auto begprev = prev, end = cur;\\n        for (int i(0); i < n; ++i) {\\n            auto next = cur->next;\\n            //if we are reversing, some extra work is required\\n            if (!(n & 1)) {\\n                cur->next = prev;\\n            }\\n            prev = cur;\\n            cur = next;\\n        }\\n        //if we are reversing, some extra work is required\\n        if (!(n & 1)) {\\n            begprev->next = prev;\\n            end->next = cur;\\n            //adjust prev\\n            prev = end;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572320,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        if(!head || !head->next)\\n        {\\n            return head;\\n        }\\n\\n        int l=2;\\n\\n        ListNode *prev = head;\\n        while(prev->next)\\n        {\\n            int i;\\n            ListNode *node = prev;\\n            for(i=0;i<l;i++)\\n            {\\n                if(!node->next)\\n                {\\n                    break;\\n                }\\n                node = node->next;\\n            }\\n\\n            if(i%2) //odd len\\n            {\\n                prev=node;\\n            }\\n            else\\n            {\\n                ListNode *reverse = node->next;\\n                ListNode *current = prev->next;\\n\\n                ListNode *nextNode = nullptr;\\n                for(int k=0;k<i;k++)\\n                {\\n                    nextNode = current->next;\\n                    current->next = reverse;\\n                    reverse = current;\\n                    current = nextNode; \\n                }\\n                ListNode *prevNext = prev->next;\\n                prev->next = reverse;\\n                prev = prevNext;\\n            }\\n\\n            l++;\\n        }\\n\\n\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        if(!head || !head->next)\\n        {\\n            return head;\\n        }\\n\\n        int l=2;\\n\\n        ListNode *prev = head;\\n        while(prev->next)\\n        {\\n            int i;\\n            ListNode *node = prev;\\n            for(i=0;i<l;i++)\\n            {\\n                if(!node->next)\\n                {\\n                    break;\\n                }\\n                node = node->next;\\n            }\\n\\n            if(i%2) //odd len\\n            {\\n                prev=node;\\n            }\\n            else\\n            {\\n                ListNode *reverse = node->next;\\n                ListNode *current = prev->next;\\n\\n                ListNode *nextNode = nullptr;\\n                for(int k=0;k<i;k++)\\n                {\\n                    nextNode = current->next;\\n                    current->next = reverse;\\n                    reverse = current;\\n                    current = nextNode; \\n                }\\n                ListNode *prevNext = prev->next;\\n                prev->next = reverse;\\n                prev = prevNext;\\n            }\\n\\n            l++;\\n        }\\n\\n\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552974,
                "title": "java-o-n-solution-using-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null){\\n            return head;\\n        }\\n        if(head.next == null){\\n            return head;\\n        }\\n        if(head.next != null && head.next.next == null){\\n            return head;\\n        }\\n        ListNode dummy = head;\\n        ListNode ptr = head.next;\\n        int k = 2;\\n        while(ptr != null){\\n        ListNode curr = ptr;\\n        ListNode nextHead = curr;\\n        int start = 1;\\n        while(start < k){\\n            ptr = ptr.next;\\n            if(ptr == null){\\n                break;\\n            }\\n            start++;\\n        }\\n        if(ptr != null){\\n        ptr = ptr.next;\\n        }\\n        if(start %2 == 0){\\n        ListNode prev = ptr;\\n        while(start-- > 0){\\n        ListNode forward = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = forward;\\n        }\\n        dummy.next = prev;\\n        dummy = nextHead;\\n        }\\n        else{\\n            while(start-- > 0){\\n                dummy = dummy.next;\\n        }\\n        }\\n        k++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null){\\n            return head;\\n        }\\n        if(head.next == null){\\n            return head;\\n        }\\n        if(head.next != null && head.next.next == null){\\n            return head;\\n        }\\n        ListNode dummy = head;\\n        ListNode ptr = head.next;\\n        int k = 2;\\n        while(ptr != null){\\n        ListNode curr = ptr;\\n        ListNode nextHead = curr;\\n        int start = 1;\\n        while(start < k){\\n            ptr = ptr.next;\\n            if(ptr == null){\\n                break;\\n            }\\n            start++;\\n        }\\n        if(ptr != null){\\n        ptr = ptr.next;\\n        }\\n        if(start %2 == 0){\\n        ListNode prev = ptr;\\n        while(start-- > 0){\\n        ListNode forward = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = forward;\\n        }\\n        dummy.next = prev;\\n        dummy = nextHead;\\n        }\\n        else{\\n            while(start-- > 0){\\n                dummy = dummy.next;\\n        }\\n        }\\n        k++;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539547,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        ListNode *prev,*curr,*nxt,*t1,*t2;\\n        ListNode *dummy=new ListNode();\\n\\n        int i,k;\\n        k=1;\\n\\n        dummy->next=head;\\n        prev=NULL;\\n        curr=head;\\n        t1=dummy;\\n        t2=head;\\n\\n        while(curr!=NULL)\\n        {\\n            ListNode *temp;\\n            temp=curr;\\n\\n            for(i=0;temp!=NULL && i<k;i++)\\n            {\\n                temp=temp->next;\\n            }\\n\\n            if(temp==NULL)\\n            {\\n                k=i;\\n            }\\n\\n            for(i=0;curr!=NULL && k%2==0 && i<k;i++)\\n            {\\n                nxt=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=nxt;\\n            }\\n\\n            for(i=0;curr!=NULL && k%2==1 && i<k;i++)\\n            {\\n                nxt=curr->next;\\n                prev=curr;\\n                curr=nxt;\\n            }\\n\\n            if(k%2==0)\\n            {\\n                if(t1!=NULL)\\n                {\\n\\n                t1->next=prev;\\n                }\\n                if(t2!=NULL)\\n                {\\n\\n                t2->next=curr;\\n                }\\n                prev=t2;\\n            }\\n\\n            t1=prev;\\n            t2=curr;\\n            k++;\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        ListNode *prev,*curr,*nxt,*t1,*t2;\\n        ListNode *dummy=new ListNode();\\n\\n        int i,k;\\n        k=1;\\n\\n        dummy->next=head;\\n        prev=NULL;\\n        curr=head;\\n        t1=dummy;\\n        t2=head;\\n\\n        while(curr!=NULL)\\n        {\\n            ListNode *temp;\\n            temp=curr;\\n\\n            for(i=0;temp!=NULL && i<k;i++)\\n            {\\n                temp=temp->next;\\n            }\\n\\n            if(temp==NULL)\\n            {\\n                k=i;\\n            }\\n\\n            for(i=0;curr!=NULL && k%2==0 && i<k;i++)\\n            {\\n                nxt=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=nxt;\\n            }\\n\\n            for(i=0;curr!=NULL && k%2==1 && i<k;i++)\\n            {\\n                nxt=curr->next;\\n                prev=curr;\\n                curr=nxt;\\n            }\\n\\n            if(k%2==0)\\n            {\\n                if(t1!=NULL)\\n                {\\n\\n                t1->next=prev;\\n                }\\n                if(t2!=NULL)\\n                {\\n\\n                t2->next=curr;\\n                }\\n                prev=t2;\\n            }\\n\\n            t1=prev;\\n            t2=curr;\\n            k++;\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531254,
                "title": "c-language",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\nstruct ListNode* reverseList(struct ListNode* head)\\n{\\n    if (!head)\\n        return head;\\n    struct ListNode* prev = NULL;\\n    while (head)\\n    {\\n        struct ListNode* temp = head->next;\\n        head->next = prev;\\n        prev = head;\\n        head = temp;\\n    }\\n    return prev;\\n}\\n\\nstruct ListNode* reverseEvenLengthGroups(struct ListNode* head){\\n    struct ListNode* dummy = malloc(sizeof(struct ListNode));\\n    dummy->next = head;\\n\\n    struct ListNode* prev = dummy;\\n\\n    for (int len = 1; len < 1e5 && head; len++)\\n    {\\n        struct ListNode* tail = head;\\n        struct ListNode* nextHead;\\n\\n        int j = 1;\\n        while (j < len && tail && tail->next)\\n        {\\n            tail = tail->next;\\n            j++;\\n        }\\n\\n        nextHead = tail->next;\\n\\n        if ((j % 2) == 0)\\n        {\\n            tail->next = NULL;\\n            prev->next = reverseList(head);\\n            prev = head;\\n            head->next = nextHead;\\n            head = nextHead;\\n        }\\n        else\\n        {\\n            prev = tail;\\n            head = nextHead;\\n        }\\n    }\\n    return dummy->next;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\nstruct ListNode* reverseList(struct ListNode* head)\\n{\\n    if (!head)\\n        return head;\\n    struct ListNode* prev = NULL;\\n    while (head)\\n    {\\n        struct ListNode* temp = head->next;\\n        head->next = prev;\\n        prev = head;\\n        head = temp;\\n    }\\n    return prev;\\n}\\n\\nstruct ListNode* reverseEvenLengthGroups(struct ListNode* head){\\n    struct ListNode* dummy = malloc(sizeof(struct ListNode));\\n    dummy->next = head;\\n\\n    struct ListNode* prev = dummy;\\n\\n    for (int len = 1; len < 1e5 && head; len++)\\n    {\\n        struct ListNode* tail = head;\\n        struct ListNode* nextHead;\\n\\n        int j = 1;\\n        while (j < len && tail && tail->next)\\n        {\\n            tail = tail->next;\\n            j++;\\n        }\\n\\n        nextHead = tail->next;\\n\\n        if ((j % 2) == 0)\\n        {\\n            tail->next = NULL;\\n            prev->next = reverseList(head);\\n            prev = head;\\n            head->next = nextHead;\\n            head = nextHead;\\n        }\\n        else\\n        {\\n            prev = tail;\\n            head = nextHead;\\n        }\\n    }\\n    return dummy->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3530903,
                "title": "reverseevenlengthgroups-solved-recursively-through-the-reversekgroup-solution-code-runtime-87",
                "content": "# Intuition\\nI solved this problem after the reverseKGroup, so I thought i could use the same algorithm, using some little tweaks.\\n# Approach\\nI can use the reverseKGroup called with an initial k=1, then using a recursive call with an incremented k.\\nI can choose to reverse only the groups which have an even k, since i know that\\'s the length they will have.\\nThe only thing to fix was to check the length of the last group (recognised by the fact that the \"tail\" of the current list is None or not), since it can be \"not complete\", to choose if I have to reverse it or not.\\n\\n# Code\\n```# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverseKGroup(head, 1)\\n\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        #Base cases\\n        if (head is None) or (head.next is None):\\n            return head\\n            \\n        #Subdivision of the groups\\n        node = head\\n        for i in range(k-1):\\n            node = node.next\\n            if node.next is None:\\n                break\\n        \\n        #Recursive call\\n        app = self.reverseKGroup(node.next, k+1)\\n        node.next = app\\n\\n        #Dont reverse if it\\'s not the final group and k isn\\'t even\\n        if app is not None and (k%2) != 0:\\n            return head\\n\\n        #Counting the length of the last group to decide to reverse\\n        i = 0\\n        if app is None:\\n            node = head\\n            while node:\\n                node = node.next\\n                i += 1\\n            if (i%2) != 0:\\n                return head\\n        \\n        #Reverse the group\\n        curr = app\\n        while head is not app:\\n            node = head.next\\n            head.next = curr\\n            curr = head\\n            head = node\\n\\n        return curr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        return self.reverseKGroup(head, 1)\\n\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        #Base cases\\n        if (head is None) or (head.next is None):\\n            return head\\n            \\n        #Subdivision of the groups\\n        node = head\\n        for i in range(k-1):\\n            node = node.next\\n            if node.next is None:\\n                break\\n        \\n        #Recursive call\\n        app = self.reverseKGroup(node.next, k+1)\\n        node.next = app\\n\\n        #Dont reverse if it\\'s not the final group and k isn\\'t even\\n        if app is not None and (k%2) != 0:\\n            return head\\n\\n        #Counting the length of the last group to decide to reverse\\n        i = 0\\n        if app is None:\\n            node = head\\n            while node:\\n                node = node.next\\n                i += 1\\n            if (i%2) != 0:\\n                return head\\n        \\n        #Reverse the group\\n        curr = app\\n        while head is not app:\\n            node = head.next\\n            head.next = curr\\n            curr = head\\n            head = node\\n\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529183,
                "title": "java-easy-codes-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n           ListNode temp = head;\\n         int num=1;\\n    \\n    while(temp!=null)\\n    {\\n        int count=0;\\n        ListNode start = temp;\\n        Stack a = new Stack();\\n        \\n        while(count!=num && temp!=null)\\n        {\\n            a.push(temp.val);\\n            temp=temp.next;\\n            count++;       \\n        }\\n        if(count%2==0)\\n        {\\n            while(temp!=start)\\n            {\\n              start.val=(int) a.pop();\\n             start=start.next;  \\n                }\\n            \\n        } \\n        num++;\\n    }\\n    \\n    return head;\\n    \\n}\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        \\n           ListNode temp = head;\\n         int num=1;\\n    \\n    while(temp!=null)\\n    {\\n        int count=0;\\n        ListNode start = temp;\\n        Stack a = new Stack();\\n        \\n        while(count!=num && temp!=null)\\n        {\\n            a.push(temp.val);\\n            temp=temp.next;\\n            count++;       \\n        }\\n        if(count%2==0)\\n        {\\n            while(temp!=start)\\n            {\\n              start.val=(int) a.pop();\\n             start=start.next;  \\n                }\\n            \\n        } \\n        num++;\\n    }\\n    \\n    return head;\\n    \\n}\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526126,
                "title": "very-easy-solution-c-using-stack",
                "content": "```\\n  \\n```class Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        \\n        if(head==NULL || head->next==NULL)return head;\\n        \\n        ListNode* temp=head,*hd=head;\\n        int i=1;\\n        \\n        \\n        while(temp!=NULL){\\n           \\n           hd=temp;\\n            \\n           stack<int> st;\\n           int j=0;\\n            \\n            while(j<i && temp!=NULL){\\n               \\n                st.push(temp->val);\\n                \\n                j++;\\n                temp=temp->next;\\n            }\\n            \\n            if(st.size()%2==0){\\n                \\n                while(!st.empty()){\\n                    \\n                    hd->val=st.top();\\n                    st.pop();\\n                    hd=hd->next;\\n                }\\n            }\\n            i++;\\n        }\\n        return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516336,
                "title": "c-2-traversals-well-commented",
                "content": "# Approach\\nDo the first traversal to store the starting nodes from which we have to reverse and also store the length of the group to be reversed in a vector of pair. Now do the second traversal to actually reverse the groups based on the pointers which you saved in vector. For the last group if the length is smaller than it should be, we have to manually reverse the last group by storing the pointer of the node previous to the last group\\'s starting node and reverse the last group after the previous pointer by simply applying the logic to reverse a linked list.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        //to store the pointer of the starting node\\n        //of the group and the length of the group\\n        vector<pair<ListNode*,int>> vec;\\n        ListNode* tmp = head;\\n        //k is length of 1st group and it will increase like \\n        // 1, 2, 3 ...\\n        int k = 1;\\n        while(tmp!=NULL)\\n        {\\n            int cnt = 0;\\n            ListNode* tmp1 = tmp;\\n            while(cnt<k && tmp!=NULL)\\n            {\\n                cnt++;\\n                tmp = tmp->next;\\n            }\\n            if(cnt%2==0)\\n            {\\n                vec.push_back({tmp1,cnt});\\n            }\\n            k++;\\n        }\\n        //this is for last group if length is smaller than needed\\n        int flg = 0;\\n        ListNode* lastPtr1 = NULL;\\n        ListNode* lastPtr2 = NULL;\\n        if(vec.size()>1 && vec[vec.size()-1].second<=vec[vec.size()-2].second)\\n        {\\n            flg = 1;\\n            lastPtr1 = vec[vec.size()-1].first;\\n        }\\n        //............\\n\\n        tmp = head;\\n        int ptr = 0;\\n        while(ptr<vec.size() && tmp!=NULL)\\n        {\\n            if(tmp->next==vec[ptr].first)\\n            {\\n                int cnt = vec[ptr].second;\\n                ListNode* first = tmp->next;\\n                ListNode* prev = NULL;\\n                ListNode* cur = first;\\n                int tcnt = 0;\\n                while(cur!=NULL && tcnt<cnt)\\n                {\\n                    tcnt++;\\n                    ListNode* tm = cur->next;\\n                    cur->next = prev;\\n                    prev = cur;\\n                    cur = tm;\\n                    if(tcnt==cnt-1)\\n                    {\\n                        ListNode* tmp2 = cur->next;\\n                        \\n                        cur->next = prev;\\n                        first->next = tmp2;\\n                        //here we are storing the \\n                        //previous pointer of the \\n                        //last group\\'s first node to \\n                        // reverse it at last.\\n                        if(first->next==lastPtr1 && flg)\\n                        {\\n                            lastPtr2 = first;\\n                        }\\n                        //........\\n\\n                        tmp->next = cur;\\n                        tmp = tmp2;\\n                        break;\\n                    }\\n                }\\n                ptr++;\\n            }\\n            else\\n            {\\n                tmp = tmp->next;\\n            }\\n        }\\n\\n        //this is the code to reverse the last group if \\n        // it was not reversed in the above part.\\n        if(lastPtr2!=NULL)\\n        {\\n            ListNode* prev = NULL;\\n            ListNode* cur = lastPtr2->next;\\n            while(cur!=NULL)\\n            {\\n                ListNode* tm = cur->next;\\n                cur->next = prev;\\n                prev = cur;\\n                cur = tm;\\n            }\\n            lastPtr2->next = prev;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        //to store the pointer of the starting node\\n        //of the group and the length of the group\\n        vector<pair<ListNode*,int>> vec;\\n        ListNode* tmp = head;\\n        //k is length of 1st group and it will increase like \\n        // 1, 2, 3 ...\\n        int k = 1;\\n        while(tmp!=NULL)\\n        {\\n            int cnt = 0;\\n            ListNode* tmp1 = tmp;\\n            while(cnt<k && tmp!=NULL)\\n            {\\n                cnt++;\\n                tmp = tmp->next;\\n            }\\n            if(cnt%2==0)\\n            {\\n                vec.push_back({tmp1,cnt});\\n            }\\n            k++;\\n        }\\n        //this is for last group if length is smaller than needed\\n        int flg = 0;\\n        ListNode* lastPtr1 = NULL;\\n        ListNode* lastPtr2 = NULL;\\n        if(vec.size()>1 && vec[vec.size()-1].second<=vec[vec.size()-2].second)\\n        {\\n            flg = 1;\\n            lastPtr1 = vec[vec.size()-1].first;\\n        }\\n        //............\\n\\n        tmp = head;\\n        int ptr = 0;\\n        while(ptr<vec.size() && tmp!=NULL)\\n        {\\n            if(tmp->next==vec[ptr].first)\\n            {\\n                int cnt = vec[ptr].second;\\n                ListNode* first = tmp->next;\\n                ListNode* prev = NULL;\\n                ListNode* cur = first;\\n                int tcnt = 0;\\n                while(cur!=NULL && tcnt<cnt)\\n                {\\n                    tcnt++;\\n                    ListNode* tm = cur->next;\\n                    cur->next = prev;\\n                    prev = cur;\\n                    cur = tm;\\n                    if(tcnt==cnt-1)\\n                    {\\n                        ListNode* tmp2 = cur->next;\\n                        \\n                        cur->next = prev;\\n                        first->next = tmp2;\\n                        //here we are storing the \\n                        //previous pointer of the \\n                        //last group\\'s first node to \\n                        // reverse it at last.\\n                        if(first->next==lastPtr1 && flg)\\n                        {\\n                            lastPtr2 = first;\\n                        }\\n                        //........\\n\\n                        tmp->next = cur;\\n                        tmp = tmp2;\\n                        break;\\n                    }\\n                }\\n                ptr++;\\n            }\\n            else\\n            {\\n                tmp = tmp->next;\\n            }\\n        }\\n\\n        //this is the code to reverse the last group if \\n        // it was not reversed in the above part.\\n        if(lastPtr2!=NULL)\\n        {\\n            ListNode* prev = NULL;\\n            ListNode* cur = lastPtr2->next;\\n            while(cur!=NULL)\\n            {\\n                ListNode* tm = cur->next;\\n                cur->next = prev;\\n                prev = cur;\\n                cur = tm;\\n            }\\n            lastPtr2->next = prev;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443879,
                "title": "long-but-understandable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* reverselast(ListNode* head){\\n    ListNode* prev=nullptr;\\n    ListNode* curr=head;\\n    ListNode* right=curr->next;\\n    while(curr!=nullptr){\\nright=curr->next;\\ncurr->next=prev;\\nprev=curr;\\ncurr=right;\\n    }\\n    return prev;\\n}\\nint cnt(ListNode* head){\\n    ListNode* temp=head;\\n    int i=0;\\n    while(temp!=nullptr){\\n        i++;\\n        temp=temp->next;\\n    }\\n    return i;\\n}\\nListNode* reverse(ListNode* head,int i){\\n    if(head==nullptr){\\n        return nullptr;\\n    }\\n\\n\\n    int count=cnt(head);\\n    //yecode last ke liye\\nif(count<i){\\n    if(count%2==0){\\nreturn reverselast(head);\\n    }\\n    else{\\n        return head;\\n    }\\n}\\n////////\\nif(i%2==0){\\nint j=0;\\nListNode* prev=NULL;\\nListNode* curr=head;\\nListNode* right=curr->next;\\nwhile(j<i){\\n    right=curr->next;\\n    curr->next=prev;\\n    prev=curr;\\n    curr=right;\\n    j++;\\n}\\nif(right!=nullptr){\\n    int x=i+1;\\n    ListNode* rightkaans=reverse(right,x);\\n    head->next=rightkaans;\\n}\\nreturn prev;}\\nelse{\\n    int k=0;\\n    ListNode* temp=head;\\n    ListNode* follow=head;\\n    while(k<i){\\n        follow=temp;\\ntemp=temp->next;\\nk++;\\n    }\\n    if(temp!=nullptr){\\n         ListNode* ans=reverse(temp,++i);\\n         follow->next=ans;\\n    }\\n    return head;\\n}\\nreturn nullptr;\\n}\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int i=1;\\n        return reverse(head, i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* reverselast(ListNode* head){\\n    ListNode* prev=nullptr;\\n    ListNode* curr=head;\\n    ListNode* right=curr->next;\\n    while(curr!=nullptr){\\nright=curr->next;\\ncurr->next=prev;\\nprev=curr;\\ncurr=right;\\n    }\\n    return prev;\\n}\\nint cnt(ListNode* head){\\n    ListNode* temp=head;\\n    int i=0;\\n    while(temp!=nullptr){\\n        i++;\\n        temp=temp->next;\\n    }\\n    return i;\\n}\\nListNode* reverse(ListNode* head,int i){\\n    if(head==nullptr){\\n        return nullptr;\\n    }\\n\\n\\n    int count=cnt(head);\\n    //yecode last ke liye\\nif(count<i){\\n    if(count%2==0){\\nreturn reverselast(head);\\n    }\\n    else{\\n        return head;\\n    }\\n}\\n////////\\nif(i%2==0){\\nint j=0;\\nListNode* prev=NULL;\\nListNode* curr=head;\\nListNode* right=curr->next;\\nwhile(j<i){\\n    right=curr->next;\\n    curr->next=prev;\\n    prev=curr;\\n    curr=right;\\n    j++;\\n}\\nif(right!=nullptr){\\n    int x=i+1;\\n    ListNode* rightkaans=reverse(right,x);\\n    head->next=rightkaans;\\n}\\nreturn prev;}\\nelse{\\n    int k=0;\\n    ListNode* temp=head;\\n    ListNode* follow=head;\\n    while(k<i){\\n        follow=temp;\\ntemp=temp->next;\\nk++;\\n    }\\n    if(temp!=nullptr){\\n         ListNode* ans=reverse(temp,++i);\\n         follow->next=ans;\\n    }\\n    return head;\\n}\\nreturn nullptr;\\n}\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int i=1;\\n        return reverse(head, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439964,
                "title": "using-stack-and-loop-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* reverse_head = head;\\n        ListNode* start_index = NULL;\\n        int counter = 1;\\n        while(head!=NULL){\\n            stack<int> st;\\n            for(int i =0; i < counter; i++){\\n                if(head == NULL) break;\\n                if(i==0) start_index = head;\\n                st.push(head->val); \\n                head = head->next;\\n            }\\n            if(st.size() % 2==0){\\n                head = start_index;\\n                while(!st.empty()){\\n                    head -> val = st.top();\\n                    st.pop();\\n                    head = head->next;\\n                }\\n            }\\n            counter++;\\n        }\\n        return reverse_head;\\n    }\\n};\\n```\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* reverse_head = head;\\n        ListNode* start_index = NULL;\\n        int flag = 0, counter = 1;\\n        while(head!=NULL){\\n            stack<int> st;\\n            for(int i =0; i < counter; i++){\\n                if(head == NULL) break;\\n                if(i==0) start_index = head;\\n                st.push(head->val); \\n                if(flag == 1){\\n                    if(i==counter-1) flag = 0;\\n                }\\n                else if(flag == 0){\\n                    if(i==counter-1) flag = 1;\\n                }\\n                head = head->next;\\n            }\\n            if(st.size() % 2==0){\\n                head = start_index;\\n                while(!st.empty()){\\n                    head -> val = st.top();\\n                    st.pop();\\n                    head = head->next;\\n                }\\n            }\\n            counter++;\\n        }\\n        return reverse_head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* reverse_head = head;\\n        ListNode* start_index = NULL;\\n        int counter = 1;\\n        while(head!=NULL){\\n            stack<int> st;\\n            for(int i =0; i < counter; i++){\\n                if(head == NULL) break;\\n                if(i==0) start_index = head;\\n                st.push(head->val); \\n                head = head->next;\\n            }\\n            if(st.size() % 2==0){\\n                head = start_index;\\n                while(!st.empty()){\\n                    head -> val = st.top();\\n                    st.pop();\\n                    head = head->next;\\n                }\\n            }\\n            counter++;\\n        }\\n        return reverse_head;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ListNode* reverse_head = head;\\n        ListNode* start_index = NULL;\\n        int flag = 0, counter = 1;\\n        while(head!=NULL){\\n            stack<int> st;\\n            for(int i =0; i < counter; i++){\\n                if(head == NULL) break;\\n                if(i==0) start_index = head;\\n                st.push(head->val); \\n                if(flag == 1){\\n                    if(i==counter-1) flag = 0;\\n                }\\n                else if(flag == 0){\\n                    if(i==counter-1) flag = 1;\\n                }\\n                head = head->next;\\n            }\\n            if(st.size() % 2==0){\\n                head = start_index;\\n                while(!st.empty()){\\n                    head -> val = st.top();\\n                    st.pop();\\n                    head = head->next;\\n                }\\n            }\\n            counter++;\\n        }\\n        return reverse_head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421371,
                "title": "c-three-pointer-solution-clean-code-explanation-o-1-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nTo solve this problem, I decided to use three pointers, `prev` for the node before the first one in the current group, `start` for the first node in the group and `end` for the node after the last one in the group, or `nullptr` if the last one has no `node->next`.\\n\\nWe can track the `end_pos` and the `start_pos` to decide if the size of the group is even or not by moving the pointers and getting their new position. If it is, reverse the nodes in the group and move to the next group.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe function `move_to` tries to move the pointer to the position `target` from `position` and writes the actual position after moving to `position`. If a `nullptr` is encountered, the position will be 1 above the last non-null node.\\n\\nOn every iteration, we move the pointer `prev` to position `target` which increases by `length` every time; `length` also increases by one. Pointers `start` and `end` will be calculated using `prev` for the next group since their vaules can be inaccurate after `reverse`.\\n\\nThe function `reverse` reverses the range `(start, end)` and returns the pointer to the new start of the range. On each iteration, copy the next node `node->next` to a temp variable and set `node->next` to `prev`. Initialize `prev` with `end` so that the list stays connected and set it to the current node at the end of the loop.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* move_to(ListNode* node, int &position, int target) {\\n        for (; position < target; ++position) {\\n            if (node == nullptr) {\\n                return node;\\n            }\\n            node = node->next;\\n        }\\n        return node;\\n    }\\n    \\n    ListNode* reverse(ListNode *start, ListNode *end, int size) {\\n        ListNode *prev = end;\\n        ListNode *node = start;\\n        for (int i = 0; i < size; ++i) {\\n            ListNode *temp = node->next;\\n            node->next = prev;\\n            prev = node;\\n            node = temp;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        auto prev = head;\\n        auto start = head;\\n        auto end = head;\\n     \\n        int prev_pos = 0;\\n        int start_pos = 0;\\n        int end_pos = 1;   \\n\\n        for (int length = 2, target = 0; start != nullptr; target += length, length++) {\\n\\n            if ((end_pos - start_pos) % 2 == 0) {\\n                prev->next = reverse(start, end, end_pos - start_pos);\\n            }\\n            \\n            int position = prev_pos;\\n            prev = move_to(prev, position, target);\\n            prev_pos = position;\\n\\n            start = move_to(prev, position, position + 1);\\n            start_pos = position;\\n\\n            end = move_to(start, position, position + length);\\n            end_pos = position;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* move_to(ListNode* node, int &position, int target) {\\n        for (; position < target; ++position) {\\n            if (node == nullptr) {\\n                return node;\\n            }\\n            node = node->next;\\n        }\\n        return node;\\n    }\\n    \\n    ListNode* reverse(ListNode *start, ListNode *end, int size) {\\n        ListNode *prev = end;\\n        ListNode *node = start;\\n        for (int i = 0; i < size; ++i) {\\n            ListNode *temp = node->next;\\n            node->next = prev;\\n            prev = node;\\n            node = temp;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        auto prev = head;\\n        auto start = head;\\n        auto end = head;\\n     \\n        int prev_pos = 0;\\n        int start_pos = 0;\\n        int end_pos = 1;   \\n\\n        for (int length = 2, target = 0; start != nullptr; target += length, length++) {\\n\\n            if ((end_pos - start_pos) % 2 == 0) {\\n                prev->next = reverse(start, end, end_pos - start_pos);\\n            }\\n            \\n            int position = prev_pos;\\n            prev = move_to(prev, position, target);\\n            prev_pos = position;\\n\\n            start = move_to(prev, position, position + 1);\\n            start_pos = position;\\n\\n            end = move_to(start, position, position + length);\\n            end_pos = position;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412965,
                "title": "really-a-very-weird-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n\\n        vector<vector<ListNode*>>v;\\n        \\n        int c = 1;\\n        ListNode* t = head;\\n        vector<ListNode*>a;\\n        int grp = 1;\\n\\n        while(t){\\n            a.push_back(t);\\n            t = t->next;\\n\\n            if(a.size()==grp){\\n\\n                a[a.size()-1]->next = NULL;\\n                v.push_back(a);\\n                a.clear();\\n                grp++;\\n\\n            }\\n\\n        }\\n\\n        if(a.size()>0)v.push_back(a);\\n        vector<ListNode*>temp;\\n\\n        for(auto i : v){\\n\\n            vector<ListNode*>k = i;\\n\\n            if(k.size()%2==0){\\n                reverse(k.begin(),k.end());\\n            \\n            }\\n\\n            for(auto j : k)temp.push_back(j);\\n        }\\n        int i = 1;\\n        while(i<temp.size()){\\n\\n            temp[i-1]->next = temp[i];\\n            i++;\\n        }\\n        temp[temp.size()-1]->next = NULL;\\n        return temp[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n\\n        vector<vector<ListNode*>>v;\\n        \\n        int c = 1;\\n        ListNode* t = head;\\n        vector<ListNode*>a;\\n        int grp = 1;\\n\\n        while(t){\\n            a.push_back(t);\\n            t = t->next;\\n\\n            if(a.size()==grp){\\n\\n                a[a.size()-1]->next = NULL;\\n                v.push_back(a);\\n                a.clear();\\n                grp++;\\n\\n            }\\n\\n        }\\n\\n        if(a.size()>0)v.push_back(a);\\n        vector<ListNode*>temp;\\n\\n        for(auto i : v){\\n\\n            vector<ListNode*>k = i;\\n\\n            if(k.size()%2==0){\\n                reverse(k.begin(),k.end());\\n            \\n            }\\n\\n            for(auto j : k)temp.push_back(j);\\n        }\\n        int i = 1;\\n        while(i<temp.size()){\\n\\n            temp[i-1]->next = temp[i];\\n            i++;\\n        }\\n        temp[temp.size()-1]->next = NULL;\\n        return temp[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406451,
                "title": "beats-90-full-explained-cpp-code-pls-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthis is a very good q consist of reversing linked list and in a group of k\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The first while loop is used to count the total number of nodes in the linked list. This is done by iterating through each node of the list and incrementing the cnt variable for each node.\\n\\nThe next while loop is used to process the linked list in groups of even length. The cnt variable is used to keep track of the remaining nodes to be processed. The size variable is used to keep track of the size of the current group, which is initially set to 1.\\n\\nInside this while loop, if cnt is less than size, then size is set to cnt. This is because if the remaining number of nodes is less than the size of the current group, then the group size should be reduced accordingly.\\n\\nNext, if the group size t is even, then the group is reversed. A new pointer prev is set to the current node, and another pointer curr is set to the next node. Then the prev and curr pointers are swapped, and the next pointer is updated to point to the next node after curr. This process is repeated t-1 times to reverse the even-sized group. Finally, the tail of the previous group is updated to point to the head of the reversed group, and the tail of the reversed group is updated to point to the next node after the reversed group\\'s tail. The temp pointer is then updated to point to the next node after the reversed group\\'s tail.\\n\\nIf the group size t is odd, then the current node is skipped, and the tail pointer is set to the current node. Then the tail pointer is updated by iterating t-1 times to point to the node before the next group\\'s head. The temp pointer is then updated to point to the next node after the current group\\'s tail.\\n\\nFinally, the size variable is incremented, and the while loop continues until all nodes in the linked list are processed.\\n\\nThe function then returns the new head of the modified linked list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n        ListNode* temp=head;\\n        int cnt=0;\\n        while(temp){\\n            cnt++;\\n            temp=temp->next;\\n        }\\n              temp=head;\\n              ListNode* tail=head;\\n        int size=1;\\n        while(cnt){\\n            if(cnt<size) size=cnt;\\n            cnt-=size;\\n                int t=size;\\n                if(t%2==0){\\n                    t--;\\n                  ListNode* prev=temp;\\n                  ListNode* curr=temp->next;\\n                  prev->next=NULL;\\n                  ListNode* next=curr;\\n                  while(t--){\\n                      next=curr->next;\\n                        curr->next=prev;\\n                         prev=curr;\\n                         curr=next;\\n                  }\\n                  tail->next=prev;\\n                  tail=temp;\\n                  temp->next=curr;\\n                  temp=curr;\\n                }\\n                else{\\n                    tail=temp;\\n                    temp=temp->next;\\n                    t--;\\n                    while(t--){\\n                        tail=temp;\\n                        temp=temp->next;\\n                    }\\n                }\\n                  size++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n        ListNode* temp=head;\\n        int cnt=0;\\n        while(temp){\\n            cnt++;\\n            temp=temp->next;\\n        }\\n              temp=head;\\n              ListNode* tail=head;\\n        int size=1;\\n        while(cnt){\\n            if(cnt<size) size=cnt;\\n            cnt-=size;\\n                int t=size;\\n                if(t%2==0){\\n                    t--;\\n                  ListNode* prev=temp;\\n                  ListNode* curr=temp->next;\\n                  prev->next=NULL;\\n                  ListNode* next=curr;\\n                  while(t--){\\n                      next=curr->next;\\n                        curr->next=prev;\\n                         prev=curr;\\n                         curr=next;\\n                  }\\n                  tail->next=prev;\\n                  tail=temp;\\n                  temp->next=curr;\\n                  temp=curr;\\n                }\\n                else{\\n                    tail=temp;\\n                    temp=temp->next;\\n                    t--;\\n                    while(t--){\\n                        tail=temp;\\n                        temp=temp->next;\\n                    }\\n                }\\n                  size++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401470,
                "title": "c-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<vector<int>> v;\\n        ListNode* h = head;\\n        int k=0;\\n        while(h!=NULL)\\n        {\\n            k++;\\n            int count=0;\\n            ListNode* h1 = h;\\n            vector<int> v1;\\n            while(h1!=NULL)\\n            {\\n                \\n                count++;\\n                if(count==k)\\n                    break;\\n                else\\n                    v1.push_back(h1->val);\\n                h1=h1->next;\\n            }\\n            v.push_back(v1);\\n            h=h1;\\n\\n        }\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i].size()%2==0)\\n            {\\n                reverse(v[i].begin(),v[i].end());\\n            }\\n        }\\n        ListNode* h1 = new ListNode(0);\\n        ListNode* ans = h1;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[i].size();j++)\\n            {\\n                h1->next=new ListNode(v[i][j]);\\n                h1=h1->next;\\n            }\\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        vector<vector<int>> v;\\n        ListNode* h = head;\\n        int k=0;\\n        while(h!=NULL)\\n        {\\n            k++;\\n            int count=0;\\n            ListNode* h1 = h;\\n            vector<int> v1;\\n            while(h1!=NULL)\\n            {\\n                \\n                count++;\\n                if(count==k)\\n                    break;\\n                else\\n                    v1.push_back(h1->val);\\n                h1=h1->next;\\n            }\\n            v.push_back(v1);\\n            h=h1;\\n\\n        }\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i].size()%2==0)\\n            {\\n                reverse(v[i].begin(),v[i].end());\\n            }\\n        }\\n        ListNode* h1 = new ListNode(0);\\n        ListNode* ans = h1;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[i].size();j++)\\n            {\\n                h1->next=new ListNode(v[i][j]);\\n                h1=h1->next;\\n            }\\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401055,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode curr = null;\\n\\n    public ListNode reverse(ListNode head,int m){\\n        ListNode c = head;\\n        ListNode next = head;\\n        ListNode p = null;\\n        ListNode n = null;\\n        while(m > 0 && c!=null){\\n            n = c.next;\\n            c.next = p;\\n            p = c;\\n            c = n;\\n            m--;\\n        }\\n        curr = c;\\n        return p;\\n    }\\n    public int length(ListNode head){\\n        int count = 0;\\n        while(head != null){\\n            head = head.next;\\n            count++;\\n        }\\n        return count;\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode res = head;\\n        ListNode run = head;\\n        int len = length(head);\\n        int n = 0;\\n        int i = 1;\\n        while(n < len){\\n            int min = Math.min(i,len - n);\\n            if(min%2 == 1){\\n                for(int j = 0;j<min && head != null;j++){\\n                    run = head;\\n                    head = head.next;\\n                }\\n            }\\n            else{\\n                ListNode temp = reverse(head,min);\\n                run.next = temp;\\n                head.next = curr;\\n                run = head;\\n                head = curr;\\n            }\\n            i++;\\n            n += min;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode curr = null;\\n\\n    public ListNode reverse(ListNode head,int m){\\n        ListNode c = head;\\n        ListNode next = head;\\n        ListNode p = null;\\n        ListNode n = null;\\n        while(m > 0 && c!=null){\\n            n = c.next;\\n            c.next = p;\\n            p = c;\\n            c = n;\\n            m--;\\n        }\\n        curr = c;\\n        return p;\\n    }\\n    public int length(ListNode head){\\n        int count = 0;\\n        while(head != null){\\n            head = head.next;\\n            count++;\\n        }\\n        return count;\\n    }\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode res = head;\\n        ListNode run = head;\\n        int len = length(head);\\n        int n = 0;\\n        int i = 1;\\n        while(n < len){\\n            int min = Math.min(i,len - n);\\n            if(min%2 == 1){\\n                for(int j = 0;j<min && head != null;j++){\\n                    run = head;\\n                    head = head.next;\\n                }\\n            }\\n            else{\\n                ListNode temp = reverse(head,min);\\n                run.next = temp;\\n                head.next = curr;\\n                run = head;\\n                head = curr;\\n            }\\n            i++;\\n            n += min;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386218,
                "title": "python-simple-solution",
                "content": "```\\ndef reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tlst, cur, node, n, k = [], [], head, head, 1\\n\\twhile(node):\\n\\t\\tcur.append(node.val)\\n\\t\\tnode = node.next\\n\\t\\tif len(cur)==k or not node:\\n\\t\\t\\tif len(cur)%2==0:\\n\\t\\t\\t\\tcur = cur[::-1]\\n\\t\\t\\tlst.extend(cur)\\n\\t\\t\\tcur, k = [], k+1\\n\\tfor i in range(len(lst)):\\n\\t\\tn.val = lst[i]\\n\\t\\tn = n.next\\n\\treturn head\\n```",
                "solutionTags": [],
                "code": "```\\ndef reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tlst, cur, node, n, k = [], [], head, head, 1\\n\\twhile(node):\\n\\t\\tcur.append(node.val)\\n\\t\\tnode = node.next\\n\\t\\tif len(cur)==k or not node:\\n\\t\\t\\tif len(cur)%2==0:\\n\\t\\t\\t\\tcur = cur[::-1]\\n\\t\\t\\tlst.extend(cur)\\n\\t\\t\\tcur, k = [], k+1\\n\\tfor i in range(len(lst)):\\n\\t\\tn.val = lst[i]\\n\\t\\tn = n.next\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3370953,
                "title": "o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current_node = head\\n        current_tail = None\\n        group_size = 1\\n        while(current_node):\\n            group_start, group_tail, next_node = Solution.consume_group(group_size, current_node)\\n            if current_tail:\\n                current_tail.next = group_start\\n                current_tail = group_tail\\n            else:\\n                current_tail = group_tail\\n            \\n            current_node = next_node\\n            group_size += 1\\n\\n        return head\\n\\n    @staticmethod\\n    def consume_group(group_size, head):\\n        \"\"\"\\n\\n        :param group_size: will try to consume that many nodes\\n        :param head: the first_node in the group\\n        :return: the start of the group, the tail of the group, next_node\\n        \"\"\"\\n        if group_size == 0 or not head:\\n            return None, None, None\\n\\n        count = 0\\n\\n        current = head\\n\\n        if group_size % 2 == 0:\\n            group_tail = None\\n            group = None\\n            while current and count < group_size :\\n                next_node = current.next\\n                current.next = group\\n                if not group:\\n                    group_tail = current\\n\\n                group = current\\n                current = next_node\\n                count += 1\\n\\n            if count < group_size and count % 2 == 1:\\n                return Solution.reverse_linked_list(group)\\n            else:\\n                return group, group_tail, current\\n\\n        else:\\n            prev = None\\n            group = head\\n            while current and count < group_size:\\n                if prev:\\n                    prev.next = current\\n\\n                prev = current\\n\\n                current = current.next\\n                count += 1\\n\\n            if count < group_size and count % 2 == 0:\\n                # reverse linked list\\n                return Solution.reverse_linked_list(group)\\n            else:\\n                return group, prev, current\\n\\n\\n\\n    @staticmethod\\n    def reverse_linked_list(head):\\n        result = None\\n        tail = None\\n        while(head):\\n            next_node = head.next\\n            head.next = result\\n            if not result:\\n                tail = head\\n\\n            result = head\\n            head = next_node\\n\\n        return result, tail, head\\n\\n\\n\\n\\n\\n\\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseEvenLengthGroups(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        current_node = head\\n        current_tail = None\\n        group_size = 1\\n        while(current_node):\\n            group_start, group_tail, next_node = Solution.consume_group(group_size, current_node)\\n            if current_tail:\\n                current_tail.next = group_start\\n                current_tail = group_tail\\n            else:\\n                current_tail = group_tail\\n            \\n            current_node = next_node\\n            group_size += 1\\n\\n        return head\\n\\n    @staticmethod\\n    def consume_group(group_size, head):\\n        \"\"\"\\n\\n        :param group_size: will try to consume that many nodes\\n        :param head: the first_node in the group\\n        :return: the start of the group, the tail of the group, next_node\\n        \"\"\"\\n        if group_size == 0 or not head:\\n            return None, None, None\\n\\n        count = 0\\n\\n        current = head\\n\\n        if group_size % 2 == 0:\\n            group_tail = None\\n            group = None\\n            while current and count < group_size :\\n                next_node = current.next\\n                current.next = group\\n                if not group:\\n                    group_tail = current\\n\\n                group = current\\n                current = next_node\\n                count += 1\\n\\n            if count < group_size and count % 2 == 1:\\n                return Solution.reverse_linked_list(group)\\n            else:\\n                return group, group_tail, current\\n\\n        else:\\n            prev = None\\n            group = head\\n            while current and count < group_size:\\n                if prev:\\n                    prev.next = current\\n\\n                prev = current\\n\\n                current = current.next\\n                count += 1\\n\\n            if count < group_size and count % 2 == 0:\\n                # reverse linked list\\n                return Solution.reverse_linked_list(group)\\n            else:\\n                return group, prev, current\\n\\n\\n\\n    @staticmethod\\n    def reverse_linked_list(head):\\n        result = None\\n        tail = None\\n        while(head):\\n            next_node = head.next\\n            head.next = result\\n            if not result:\\n                tail = head\\n\\n            result = head\\n            head = next_node\\n\\n        return result, tail, head\\n\\n\\n\\n\\n\\n\\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358401,
                "title": "simplest-c-solution",
                "content": "# Intuition-\\nfirst reverse k node than call for reversing k+1 node so on.\\n\\n# Approach\\nkeep track of last group ..if length even than only reverse\\n\\n# Complexity\\n- Time complexity:\\n time complexity  O(n) only once traversing in linkedlist-->\\n\\n- Space complexity:\\n!--  space complexity O(\\u221An) --\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n ListNode* reverseK(ListNode* head,int k) {\\n     if(head==NULL or head->next==NULL )return head;\\n     ListNode *temp=head;\\n         int i=1;\\n         while(temp!=NULL and i<k){temp=temp->next;i++; }\\n         if(temp==NULL)\\n         {   i--;\\n             if(i%2==0)\\n             {\\n                 ListNode *curr=head,*next=NULL,*pre=NULL;\\n                 i=0;\\n                while(curr!=NULL)\\n                {\\n                  next=curr->next;\\n                   curr->next=pre;\\n                    pre=curr;curr=next;i++;\\n                }\\n                return pre;\\n             }\\n             return head;\\n         }\\n        // cout<<endl;\\n     if(k%2)\\n     {\\n          if(temp->next!=NULL) temp->next=reverseK(temp->next,k+1);\\n           return head;\\n     }\\n     ListNode *curr=head,*next=NULL,*pre=NULL;\\n      i=0;\\n     while(curr!=NULL and i<k)\\n     {\\n        next=curr->next;\\n        curr->next=pre;\\n        pre=curr;curr=next;i++;\\n     }\\n     if(curr)head->next=reverseK(next,k+1);\\n     return pre;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseK(head,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n ListNode* reverseK(ListNode* head,int k) {\\n     if(head==NULL or head->next==NULL )return head;\\n     ListNode *temp=head;\\n         int i=1;\\n         while(temp!=NULL and i<k){temp=temp->next;i++; }\\n         if(temp==NULL)\\n         {   i--;\\n             if(i%2==0)\\n             {\\n                 ListNode *curr=head,*next=NULL,*pre=NULL;\\n                 i=0;\\n                while(curr!=NULL)\\n                {\\n                  next=curr->next;\\n                   curr->next=pre;\\n                    pre=curr;curr=next;i++;\\n                }\\n                return pre;\\n             }\\n             return head;\\n         }\\n        // cout<<endl;\\n     if(k%2)\\n     {\\n          if(temp->next!=NULL) temp->next=reverseK(temp->next,k+1);\\n           return head;\\n     }\\n     ListNode *curr=head,*next=NULL,*pre=NULL;\\n      i=0;\\n     while(curr!=NULL and i<k)\\n     {\\n        next=curr->next;\\n        curr->next=pre;\\n        pre=curr;curr=next;i++;\\n     }\\n     if(curr)head->next=reverseK(next,k+1);\\n     return pre;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseK(head,1);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3355200,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n        ListNode* pre=NULL;\\n        ListNode* cur=head;\\n        while(cur!=NULL)\\n        {\\n            ListNode* nex=cur->next;\\n            cur->next=pre;\\n            pre=cur;\\n            cur=nex;\\n        }\\n        head=pre;\\n        return head;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        int k=1;\\n        ListNode* temp=head;\\n        ListNode* prev=NULL;\\n        while(temp)\\n        {\\n            if(k%2==0)\\n            {\\n                ListNode* n=temp; // previous head\\n                ListNode* t=n;    //\\n                int cnt=0, f=0;\\n                for(int x=1; x<k; x++)\\n                {\\n                    t=t->next;\\n                    cnt++;\\n                    if(!t && cnt%2) return head;\\n                    if(!t)\\n                    {\\n                        f=1;break;\\n                    }\\n                }\\n                if(f)\\n                {\\n                    prev->next=NULL;\\n                    ListNode* l=reverseList(n);\\n                    prev->next=l;\\n                    return head;\\n                }\\n                ListNode* nex=t->next;\\n                t->next=NULL;\\n                prev->next=NULL;\\n                ListNode* l=reverseList(n);\\n                n->next=nex;\\n                temp=n;\\n                prev->next=l;\\n            }\\n            else\\n            {\\n                int cnt=1, f=0;\\n                ListNode* n=temp;\\n                for(int x=1; x<k; x++)\\n                {\\n                    temp=temp->next;\\n                    cnt++;\\n                    if(!temp)\\n                    {\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                if(f && cnt%2)\\n                {\\n                    prev->next=NULL;\\n                    ListNode* l=reverseList(n);\\n                    prev->next=l;\\n                }\\n            }\\n            k++;\\n            prev=temp;\\n            if(temp)temp=temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n        ListNode* pre=NULL;\\n        ListNode* cur=head;\\n        while(cur!=NULL)\\n        {\\n            ListNode* nex=cur->next;\\n            cur->next=pre;\\n            pre=cur;\\n            cur=nex;\\n        }\\n        head=pre;\\n        return head;\\n    }\\n    ListNode* reverseEvenLengthGroups(ListNode* head) \\n    {\\n        int k=1;\\n        ListNode* temp=head;\\n        ListNode* prev=NULL;\\n        while(temp)\\n        {\\n            if(k%2==0)\\n            {\\n                ListNode* n=temp; // previous head\\n                ListNode* t=n;    //\\n                int cnt=0, f=0;\\n                for(int x=1; x<k; x++)\\n                {\\n                    t=t->next;\\n                    cnt++;\\n                    if(!t && cnt%2) return head;\\n                    if(!t)\\n                    {\\n                        f=1;break;\\n                    }\\n                }\\n                if(f)\\n                {\\n                    prev->next=NULL;\\n                    ListNode* l=reverseList(n);\\n                    prev->next=l;\\n                    return head;\\n                }\\n                ListNode* nex=t->next;\\n                t->next=NULL;\\n                prev->next=NULL;\\n                ListNode* l=reverseList(n);\\n                n->next=nex;\\n                temp=n;\\n                prev->next=l;\\n            }\\n            else\\n            {\\n                int cnt=1, f=0;\\n                ListNode* n=temp;\\n                for(int x=1; x<k; x++)\\n                {\\n                    temp=temp->next;\\n                    cnt++;\\n                    if(!temp)\\n                    {\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                if(f && cnt%2)\\n                {\\n                    prev->next=NULL;\\n                    ListNode* l=reverseList(n);\\n                    prev->next=l;\\n                }\\n            }\\n            k++;\\n            prev=temp;\\n            if(temp)temp=temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337342,
                "title": "c-beats-99-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a position integer and a pointer, then keep on reversing the substrings when needed.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverseList(struct ListNode*& first, struct ListNode*& last) {\\n    if (first == nullptr || last == nullptr || first == last) {\\n        return;\\n    }\\n\\n    struct ListNode* prev = nullptr;\\n    struct ListNode* curr = first;\\n    struct ListNode* next = nullptr;\\n\\n    while (curr != last) {\\n        next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n\\n    curr->next = prev;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int pos=0, len=1; //len is length to achieve\\n        struct ListNode* first, *last, *curr;\\n        curr = head;\\n        while(curr){\\n            pos++;\\n            if(pos==int(len*(len+1)/2)){\\n                if(len%2==0){\\n                    last=curr;\\n                    curr = curr->next;\\n                    \\n                    // cout<<\"the value of last is \"<<last->val<<endl;\\n            \\n                    // reverse starts\\n                    reverseList(first->next, last);\\n                    first->next->next = curr;\\n                    first->next = last;\\n                    // reverse ends\\n                    for(int i=0;i<len;i++) first = first->next;\\n                    // cout<<\"the value of len is \"<<len<<endl;\\n                  \\n                    len++;\\n                    }\\n                else{ len++; if(len%2==0) first=curr; curr = curr->next; }\\n            }\\n            else{ curr=curr->next;}            \\n        }\\n\\n        // the loop has ended, last values are remaining\\n        cout<<\"the value of first is \"<<first->val<<endl;\\n        // if(len%2!=0)\\n        // first = first->next;\\n        if(first)\\n        cout<<\"the value of first is \"<<first->val<<endl;\\n\\n        \\n        len = pos-int(len*(len-1)/2);\\n        if(len>0 && len%2==0){\\n            last = first;\\n            for(int i=0;i<len;i++) last = last->next;\\n            // cout<<\"the value of last is \"<<last->val<<endl;\\n\\n            // reverse starts\\n            reverseList(first->next, last);\\n            first->next->next = curr;\\n            first->next = last;\\n            // reverse ends\\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void reverseList(struct ListNode*& first, struct ListNode*& last) {\\n    if (first == nullptr || last == nullptr || first == last) {\\n        return;\\n    }\\n\\n    struct ListNode* prev = nullptr;\\n    struct ListNode* curr = first;\\n    struct ListNode* next = nullptr;\\n\\n    while (curr != last) {\\n        next = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n    }\\n\\n    curr->next = prev;\\n    }\\n\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        int pos=0, len=1; //len is length to achieve\\n        struct ListNode* first, *last, *curr;\\n        curr = head;\\n        while(curr){\\n            pos++;\\n            if(pos==int(len*(len+1)/2)){\\n                if(len%2==0){\\n                    last=curr;\\n                    curr = curr->next;\\n                    \\n                    // cout<<\"the value of last is \"<<last->val<<endl;\\n            \\n                    // reverse starts\\n                    reverseList(first->next, last);\\n                    first->next->next = curr;\\n                    first->next = last;\\n                    // reverse ends\\n                    for(int i=0;i<len;i++) first = first->next;\\n                    // cout<<\"the value of len is \"<<len<<endl;\\n                  \\n                    len++;\\n                    }\\n                else{ len++; if(len%2==0) first=curr; curr = curr->next; }\\n            }\\n            else{ curr=curr->next;}            \\n        }\\n\\n        // the loop has ended, last values are remaining\\n        cout<<\"the value of first is \"<<first->val<<endl;\\n        // if(len%2!=0)\\n        // first = first->next;\\n        if(first)\\n        cout<<\"the value of first is \"<<first->val<<endl;\\n\\n        \\n        len = pos-int(len*(len-1)/2);\\n        if(len>0 && len%2==0){\\n            last = first;\\n            for(int i=0;i<len;i++) last = last->next;\\n            // cout<<\"the value of last is \"<<last->val<<endl;\\n\\n            // reverse starts\\n            reverseList(first->next, last);\\n            first->next->next = curr;\\n            first->next = last;\\n            // reverse ends\\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3337219,
                "title": "java-solution-with-map-and-deque",
                "content": "```\\n public static ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp = head;\\n        Map<Integer, Deque<ListNode>> map = new LinkedHashMap<>();\\n        int counter=1;\\n        while (temp!=null){\\n            for (int i = 0; i < counter; i++) {\\n                if(temp==null)\\n                    break;\\n                map.computeIfAbsent(counter,e->new ArrayDeque<>()).addLast(temp);\\n                temp=temp.next;\\n            }\\n            counter++;\\n        }\\n        temp=null;\\n        for (int i = 1; i <counter;  i++) {\\n            if(map.get(i).size()%2!=0 ){\\n                if(temp!=null)\\n                    temp.next=map.get(i).getFirst();\\n                temp= map.get(i).getLast();\\n            }\\n            else if(map.get(i).size()%2==0){\\n                int indexCounter=map.get(i).size();\\n                for (int j = 0; j <indexCounter; j++) {\\n                    temp.next=map.get(i).getLast();\\n                    temp=map.get(i).removeLast();\\n                }\\n            }\\n        }\\n        temp.next=null;\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\n public static ListNode reverseEvenLengthGroups(ListNode head) {\\n        ListNode temp = head;\\n        Map<Integer, Deque<ListNode>> map = new LinkedHashMap<>();\\n        int counter=1;\\n        while (temp!=null){\\n            for (int i = 0; i < counter; i++) {\\n                if(temp==null)\\n                    break;\\n                map.computeIfAbsent(counter,e->new ArrayDeque<>()).addLast(temp);\\n                temp=temp.next;\\n            }\\n            counter++;\\n        }\\n        temp=null;\\n        for (int i = 1; i <counter;  i++) {\\n            if(map.get(i).size()%2!=0 ){\\n                if(temp!=null)\\n                    temp.next=map.get(i).getFirst();\\n                temp= map.get(i).getLast();\\n            }\\n            else if(map.get(i).size()%2==0){\\n                int indexCounter=map.get(i).size();\\n                for (int j = 0; j <indexCounter; j++) {\\n                    temp.next=map.get(i).getLast();\\n                    temp=map.get(i).removeLast();\\n                }\\n            }\\n        }\\n        temp.next=null;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3331872,
                "title": "simple-and-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n   Leetcode K-Reversal for better understanding\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode *s,ListNode *e){\\n        ListNode *prev=NULL,*curr=s,*nex=s->next;\\n        while(prev!=e){\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nex;\\n            if(nex){\\n                nex=nex->next;\\n            }\\n        }\\n        return prev;\\n    }\\n \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode *dummy=new ListNode(-1);\\n        dummy->next=head;\\n        ListNode *prev=dummy;\\n        for(int i=1;head!=NULL && 1e5;i++){\\n            ListNode *temp=head;\\n            ListNode *nexthead;\\n            int j=1;\\n            while(j<i && temp && temp->next){\\n                temp=temp->next;\\n                j++;\\n            }\\n            nexthead=temp->next;\\n            if((j%2)==0){\\n                 reverse(head,temp);\\n                 prev->next=temp;\\n                 prev=head;\\n                 head->next=nexthead;\\n                 head=nexthead;\\n            }\\n            else{\\n                prev=temp;\\n                head=nexthead;\\n            }\\n        }\\n       return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode *s,ListNode *e){\\n        ListNode *prev=NULL,*curr=s,*nex=s->next;\\n        while(prev!=e){\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nex;\\n            if(nex){\\n                nex=nex->next;\\n            }\\n        }\\n        return prev;\\n    }\\n \\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode *dummy=new ListNode(-1);\\n        dummy->next=head;\\n        ListNode *prev=dummy;\\n        for(int i=1;head!=NULL && 1e5;i++){\\n            ListNode *temp=head;\\n            ListNode *nexthead;\\n            int j=1;\\n            while(j<i && temp && temp->next){\\n                temp=temp->next;\\n                j++;\\n            }\\n            nexthead=temp->next;\\n            if((j%2)==0){\\n                 reverse(head,temp);\\n                 prev->next=temp;\\n                 prev=head;\\n                 head->next=nexthead;\\n                 head=nexthead;\\n            }\\n            else{\\n                prev=temp;\\n                head=nexthead;\\n            }\\n        }\\n       return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324768,
                "title": "simple-using-recursion-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reverse(ListNode* start,ListNode* end){\\n        ListNode* prev=NULL;\\n        //ListNode* curr=head;\\n        ListNode* next=start;\\n        while(start!=end){\\n            next=start->next;\\n            start->next=prev;\\n            prev=start;\\n            start=next;\\n        }\\n        return prev;\\n    }\\n    ListNode* reverseeven(ListNode* head,int len){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int count=0;\\n        ListNode* start=head;\\n        ListNode* end=head;\\n        while(start!=NULL && count<len){\\n            end=start;\\n            start=start->next;\\n            count++;\\n        }\\n        if(count%2==0){\\n            ListNode* temp=reverse(head,start);\\n            head->next=reverseeven(start,len+1);\\n            return temp;\\n        }\\n        end->next=reverseeven(start,len+1);\\n        return head;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseeven(head,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reverse(ListNode* start,ListNode* end){\\n        ListNode* prev=NULL;\\n        //ListNode* curr=head;\\n        ListNode* next=start;\\n        while(start!=end){\\n            next=start->next;\\n            start->next=prev;\\n            prev=start;\\n            start=next;\\n        }\\n        return prev;\\n    }\\n    ListNode* reverseeven(ListNode* head,int len){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        int count=0;\\n        ListNode* start=head;\\n        ListNode* end=head;\\n        while(start!=NULL && count<len){\\n            end=start;\\n            start=start->next;\\n            count++;\\n        }\\n        if(count%2==0){\\n            ListNode* temp=reverse(head,start);\\n            head->next=reverseeven(start,len+1);\\n            return temp;\\n        }\\n        end->next=reverseeven(start,len+1);\\n        return head;\\n    }\\npublic:\\n    ListNode* reverseEvenLengthGroups(ListNode* head) {\\n        return reverseeven(head,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322065,
                "title": "swift-hashmap-approach",
                "content": "# Swift | HashMap\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func reverseEvenLengthGroups(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head!.next == nil {\\n            return head \\n        }\\n\\n        var dict = [Int: [ListNode?]]()\\n        var prev: ListNode? = nil\\n        var dummy = head\\n        var currentGroup = 1\\n        \\n        while dummy != nil {\\n            for _ in 1...currentGroup {\\n                prev = dummy\\n                dict[currentGroup, default: []].append(dummy)\\n                dummy = dummy?.next\\n                if dummy == nil { break }\\n            }\\n\\n            prev?.next = nil\\n            var count = dict[currentGroup]!.count\\n\\n            if count.isMultiple(of: 2) {\\n                var head = reverseList(dict[currentGroup]!.first!)\\n                dict[currentGroup]!.swapAt(0, count-1)\\n                dict[currentGroup-1]?.last!!.next = head\\n            } else {\\n                dict[currentGroup-1]?.last!!.next = dict[currentGroup]!.first!\\n            }\\n\\n            currentGroup += 1\\n        }\\n       \\n        return head\\n    }\\n\\n    func reverseList(_ head: ListNode?) -> ListNode? {\\n        var dummy = head\\n        var prev: ListNode? = nil\\n\\n        while dummy != nil {\\n            var nextNode = dummy?.next\\n            dummy?.next = prev\\n            prev = dummy\\n            dummy = nextNode\\n        }\\n        return prev\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func reverseEvenLengthGroups(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head!.next == nil {\\n            return head \\n        }\\n\\n        var dict = [Int: [ListNode?]]()\\n        var prev: ListNode? = nil\\n        var dummy = head\\n        var currentGroup = 1\\n        \\n        while dummy != nil {\\n            for _ in 1...currentGroup {\\n                prev = dummy\\n                dict[currentGroup, default: []].append(dummy)\\n                dummy = dummy?.next\\n                if dummy == nil { break }\\n            }\\n\\n            prev?.next = nil\\n            var count = dict[currentGroup]!.count\\n\\n            if count.isMultiple(of: 2) {\\n                var head = reverseList(dict[currentGroup]!.first!)\\n                dict[currentGroup]!.swapAt(0, count-1)\\n                dict[currentGroup-1]?.last!!.next = head\\n            } else {\\n                dict[currentGroup-1]?.last!!.next = dict[currentGroup]!.first!\\n            }\\n\\n            currentGroup += 1\\n        }\\n       \\n        return head\\n    }\\n\\n    func reverseList(_ head: ListNode?) -> ListNode? {\\n        var dummy = head\\n        var prev: ListNode? = nil\\n\\n        while dummy != nil {\\n            var nextNode = dummy?.next\\n            dummy?.next = prev\\n            prev = dummy\\n            dummy = nextNode\\n        }\\n        return prev\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1769960,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1960006,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1794919,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1761796,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1898418,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1771113,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2054286,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2018696,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1860681,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2062205,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1769960,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1960006,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1794919,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1761796,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1898418,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1771113,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2054286,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2018696,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 1860681,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            },
            {
                "id": 2062205,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it is hard problem. \\ni spent probably 3 hours to find a solution, and hard prob i did before: reverse in k-group was way much easier. \\nso, it can\\'t be mid. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "[@N1ghtstalker2022](/N1ghtstalker2022) \\nLeetcode should change easy medium hard to five stars for difficulty,This would be 4/5.Average mediums are 3/5."
                    },
                    {
                        "username": "N1ghtstalker2022",
                        "content": "Almost same. Cause me several hours..."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I will highly recommend using pen and paper to draw a diagram and some sequences of the examples to figure out the algorithm. Most of the linked list questions require visualization which is very easy to get using pen and paper."
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "This problem deserves a Hard category.\\nReason being, despite the list group is even, if the no. of nodes are odd, then there is no need to reverse the list."
                    },
                    {
                        "username": "2_NEMONE",
                        "content": "This should be hard for sure."
                    },
                    {
                        "username": "layyy",
                        "content": "try implementing \"reverse nodes in k-group\" before this "
                    },
                    {
                        "username": "bollineniyokesh",
                        "content": "Make this \"HARD\" ! "
                    },
                    {
                        "username": "anasansari_777",
                        "content": "Reverse Linked List II could be used here.\\n"
                    },
                    {
                        "username": "steven520142",
                        "content": "If you wanna do it in place, it is a hard problem.\\nOn the other hand, if you store the node in a list and rebuild linked list after doing the reverse, it is a medium problem."
                    },
                    {
                        "username": "anthonyche",
                        "content": "I know this one is a HARD problem just from reading the descriptions, it is ridiculous to put it in a medium category."
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this must be hard sum"
                    }
                ]
            }
        ]
    },
    {
        "title": "Decode the Slanted Ciphertext",
        "question_content": "<p>A string <code>originalText</code> is encoded using a <strong>slanted transposition cipher</strong> to a string <code>encodedText</code> with the help of a matrix having a <strong>fixed number of rows</strong> <code>rows</code>.</p>\n\n<p><code>originalText</code> is placed first in a top-left to bottom-right manner.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/exa11.png\" style=\"width: 300px; height: 185px;\" />\n<p>The blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of <code>originalText</code>. The arrow indicates the order in which the cells are filled. All empty cells are filled with <code>&#39; &#39;</code>. The number of columns is chosen such that the rightmost column will <strong>not be empty</strong> after filling in <code>originalText</code>.</p>\n\n<p><code>encodedText</code> is then formed by appending all characters of the matrix in a row-wise fashion.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/exa12.png\" style=\"width: 300px; height: 200px;\" />\n<p>The characters in the blue cells are appended first to <code>encodedText</code>, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed.</p>\n\n<p>For example, if <code>originalText = &quot;cipher&quot;</code> and <code>rows = 3</code>, then we encode it in the following manner:</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/25/desc2.png\" style=\"width: 281px; height: 211px;\" />\n<p>The blue arrows depict how <code>originalText</code> is placed in the matrix, and the red arrows denote the order in which <code>encodedText</code> is formed. In the above example, <code>encodedText = &quot;ch ie pr&quot;</code>.</p>\n\n<p>Given the encoded string <code>encodedText</code> and number of rows <code>rows</code>, return <em>the original string</em> <code>originalText</code>.</p>\n\n<p><strong>Note:</strong> <code>originalText</code> <strong>does not</strong> have any trailing spaces <code>&#39; &#39;</code>. The test cases are generated such that there is only one possible <code>originalText</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> encodedText = &quot;ch   ie   pr&quot;, rows = 3\n<strong>Output:</strong> &quot;cipher&quot;\n<strong>Explanation:</strong> This is the same example described in the problem description.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/exam1.png\" style=\"width: 250px; height: 168px;\" />\n<pre>\n<strong>Input:</strong> encodedText = &quot;iveo    eed   l te   olc&quot;, rows = 4\n<strong>Output:</strong> &quot;i love leetcode&quot;\n<strong>Explanation:</strong> The figure above denotes the matrix that was used to encode originalText. \nThe blue arrows show how we can find originalText from encodedText.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/26/eg2.png\" style=\"width: 300px; height: 51px;\" />\n<pre>\n<strong>Input:</strong> encodedText = &quot;coding&quot;, rows = 1\n<strong>Output:</strong> &quot;coding&quot;\n<strong>Explanation:</strong> Since there is only 1 row, both originalText and encodedText are the same.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= encodedText.length &lt;= 10<sup>6</sup></code></li>\n\t<li><code>encodedText</code> consists of lowercase English letters and <code>&#39; &#39;</code> only.</li>\n\t<li><code>encodedText</code> is a valid encoding of some <code>originalText</code> that <strong>does not</strong> have trailing spaces.</li>\n\t<li><code>1 &lt;= rows &lt;= 1000</code></li>\n\t<li>The testcases are generated such that there is <strong>only one</strong> possible <code>originalText</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1576914,
                "title": "jump-columns-1",
                "content": "Knowing `rows`, we can find out `cols`. Knowing `cols`, we can jump to the next letter (`cols + 1`).\\n\\nExample: `\"ch   ie   pr\"`, rows = 3, columns = 12 / 3 = 4.\\n0: [0, 5, 10] `\"cip\"`\\n1: [1, 6, 11] `\"her\"`\\n2: [2, 7] `\"  \"` <- we will trim this.\\n3: [3, 8] `\"  \"` <- we will trim this.\\n\\n**Java**\\n```java\\npublic String decodeCiphertext(String encodedText, int rows) {\\n    int sz = encodedText.length(), cols = sz / rows;\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < cols; ++i)\\n        for (int j = i; j < sz; j += cols + 1)\\n            sb.append(encodedText.charAt(j));\\n    return sb.toString().stripTrailing();\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols, res = len(encodedText) // rows, \"\"\\n        for i in range(cols):\\n            for j in range(i, len(encodedText), cols + 1):\\n                res += encodedText[j]\\n        return res.rstrip()\\n```\\n**C++**\\n```cpp\\nstring decodeCiphertext(string encodedText, int rows) {\\n    int sz = encodedText.size(), cols = sz / rows;\\n    string res;\\n    for (int i = 0; i < cols; ++i)\\n        for (int j = i; j < sz; j += cols + 1)\\n            res += encodedText[j];\\n    while (!res.empty() && isspace(res.back()))\\n        res.pop_back();\\n    return res;\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```java\\npublic String decodeCiphertext(String encodedText, int rows) {\\n    int sz = encodedText.length(), cols = sz / rows;\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < cols; ++i)\\n        for (int j = i; j < sz; j += cols + 1)\\n            sb.append(encodedText.charAt(j));\\n    return sb.toString().stripTrailing();\\n}\\n```\n```python\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols, res = len(encodedText) // rows, \"\"\\n        for i in range(cols):\\n            for j in range(i, len(encodedText), cols + 1):\\n                res += encodedText[j]\\n        return res.rstrip()\\n```\n```cpp\\nstring decodeCiphertext(string encodedText, int rows) {\\n    int sz = encodedText.size(), cols = sz / rows;\\n    string res;\\n    for (int i = 0; i < cols; ++i)\\n        for (int j = i; j < sz; j += cols + 1)\\n            res += encodedText[j];\\n    while (!res.empty() && isspace(res.back()))\\n        res.pop_back();\\n    return res;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577049,
                "title": "java-c-python-soluiton-with-explanation",
                "content": "# **Observations**\\n1. `s.length() = rows * cols`\\n2. `s[i]` and `s[i+cols+1]` are adjacent characters in original text.\\nFor example,\\n`\"cipher\"` to `\"ch   ie   pr\"`, `cols = 3`\\n`s[0] = \\'c\\'`\\n`s[4] = \\'i\\'`\\n`s[8] = \\'p\\'`\\n<br>\\n\\n# **Explanation**\\nFor every character in the first row in the matrix,\\nfind it\\'s adjacent characters in diagonal position in the matrix.\\nRead all these chara one by one,\\nreturn the trimmed result string.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public String decodeCiphertext(String s, int rows) {\\n        int n = s.length(), cols = n / rows;\\n        StringBuilder res = new StringBuilder(10);\\n        for (int i = 0; i < cols; ++i)\\n            for (int j = i; j < n; j += cols + 1)\\n                res.append(s.charAt(j));\\n        while (res.length()  > 0 && res.charAt(res.length() - 1) == \\' \\')\\n            res.setLength(res.length() - 1);\\n        return res.toString();\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    string decodeCiphertext(string s, int rows) {\\n        int n = s.size(), cols = n / rows;\\n        string res;\\n        for (int i = 0; i < cols; ++i)\\n            for (int j = i; j < n; j += cols + 1)\\n                res += s[j];\\n        while (res.back() == \\' \\')\\n            res.pop_back();\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def decodeCiphertext(self, s, n):\\n        m = len(s) / n\\n        res = []\\n        for i in xrange(m):\\n            while i < len(s):\\n                res.append(s[i])\\n                i += m + 1\\n        return \\'\\'.join(res).rstrip()\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public String decodeCiphertext(String s, int rows) {\\n        int n = s.length(), cols = n / rows;\\n        StringBuilder res = new StringBuilder(10);\\n        for (int i = 0; i < cols; ++i)\\n            for (int j = i; j < n; j += cols + 1)\\n                res.append(s.charAt(j));\\n        while (res.length()  > 0 && res.charAt(res.length() - 1) == \\' \\')\\n            res.setLength(res.length() - 1);\\n        return res.toString();\\n    }\\n```\n```cpp\\n    string decodeCiphertext(string s, int rows) {\\n        int n = s.size(), cols = n / rows;\\n        string res;\\n        for (int i = 0; i < cols; ++i)\\n            for (int j = i; j < n; j += cols + 1)\\n                res += s[j];\\n        while (res.back() == \\' \\')\\n            res.pop_back();\\n        return res;\\n    }\\n```\n```py\\n    def decodeCiphertext(self, s, n):\\n        m = len(s) / n\\n        res = []\\n        for i in xrange(m):\\n            while i < len(s):\\n                res.append(s[i])\\n                i += m + 1\\n        return \\'\\'.join(res).rstrip()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1576943,
                "title": "c-concise-commented-code-idea-explained",
                "content": "\\n\\n**Idea**\\n* Since the encoded text contains all the characters of the matrix, we can determine the number of columns of the matrix and then form the matrix.\\n* Once the matrix is ready, we need to traverse it diagonally to obtain the original text. After taking some examples it becomes clear that when a boundary is hit, the pointer for row resets to 0, and the pointer for column is subtracted by the *currentrow minus 1*. \\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        \\n        // Determining the number of columns\\n        int cols = n / rows;\\n        vector<vector<char>> mat(rows, vector<char>(cols, \\' \\'));\\n        int i = 0, j = 0;\\n        int k = 0;\\n        \\n        \\n        string ans = \"\";\\n        \\n        // Filling the matrix using encodedText\\n        // Row wise\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                mat[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n        // Only the upper triangular part of the matrix will\\n        // contain characters of the originalText\\n        // so, this loop traverses that area\\n        for(int k = 0; k < n - (rows * (rows - 1)) / 2; k++) {\\n            // i, j are the two pointers for tracking rows and columns\\n            ans.push_back(mat[i++][j++]);\\n            \\n            // If any boundary is hit, then column pointer is subtracted \\n            // by row_pointer - 1\\n            // and row pointer is reset to 0\\n            if(i == rows || j == cols) {\\n                j -= (i - 1);\\n                i = 0;\\n            }\\n        }\\n        \\n        // Removing all trailing spaces\\n        while(ans.back() == \\' \\')\\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\n*Space Complexity: O(n), where n is the size of encodedText*\\n*Time Complexity: O(n), where n is the size of encodedText*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        \\n        // Determining the number of columns\\n        int cols = n / rows;\\n        vector<vector<char>> mat(rows, vector<char>(cols, \\' \\'));\\n        int i = 0, j = 0;\\n        int k = 0;\\n        \\n        \\n        string ans = \"\";\\n        \\n        // Filling the matrix using encodedText\\n        // Row wise\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                mat[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n        // Only the upper triangular part of the matrix will\\n        // contain characters of the originalText\\n        // so, this loop traverses that area\\n        for(int k = 0; k < n - (rows * (rows - 1)) / 2; k++) {\\n            // i, j are the two pointers for tracking rows and columns\\n            ans.push_back(mat[i++][j++]);\\n            \\n            // If any boundary is hit, then column pointer is subtracted \\n            // by row_pointer - 1\\n            // and row pointer is reset to 0\\n            if(i == rows || j == cols) {\\n                j -= (i - 1);\\n                i = 0;\\n            }\\n        }\\n        \\n        // Removing all trailing spaces\\n        while(ans.back() == \\' \\')\\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577269,
                "title": "detailed-explanation-with-clean-code-diagonal-traversal",
                "content": "<br/>\\n\\n>  You can solve this problem using the diagram given in sample testcase\\n\\n<br/>\\n<img src=\"https://assets.leetcode.com/uploads/2021/10/26/exam1.png\" height=\"200px\" />\\n\\n<br/>\\n\\nIf you are just confused about the diagonal traversal, you can see the last part of this blog :)\\n\\n**Steps:**\\n\\n* cols = encodedText.size() / rows\\n* Fill all the characters in a 2D vector of size rows * cols (including spaces)\\n* Add all the diagonals to answer string\\n* Remove trailing zeros\\n\\nFor the example shown in above image when you traverse diagonally, you will get these substrings\\n```\\n\"i lo\" \\n\"ve l\"\\n\"eetc\"\\n\"ode\"\\n\"  \"\\n\" \"\\n```\\nAnd when you keep adding these character by character, you will have original text as\\n`\"i love leetcode  \"`\\nthen you can remove the trailing spaces\\n<br/>\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encoded, int rows) {\\n        \\n        int n = encoded.size();\\n        int cols = n / rows;\\n        vector<vector<char>> arr(rows, vector<char>(cols));\\n        int k = 0;\\n        \\n\\t\\t// filling the vector\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                arr[i][j] = encoded[k++];\\n            }\\n        }\\n        \\n        string original = \"\";\\n        \\n\\t\\t// diagonal traversal as shown in image \\n        for(int col = 0; col < cols; col++) {\\n            int r = 0;\\n            int c = col;\\n            while(c < cols and r < rows) {\\n                original += arr[r++][c++];\\n            }\\n        }\\n        \\n\\t\\t// removing trailing zeros\\n        while(original.back() == \\' \\') original.pop_back();\\n        \\n        return original;\\n    }\\n};\\n```\\n\\n<br/>\\n\\n**If you are confused about how to traverse diagonally:**\\n\\n<p>Traversing diagonals in a matrix simply means going from `row = 0; row < rows` and `col = 0; col < cols\\n` by doing `row++, col++` at each stage\\n<br/>\\n\\n**Diagonal traversal for matrix of size (4 * 6) (Shown in image) will be as follows:**\\n\\n```\\n(0, 0) -> (1, 1) -> (2, 2) -> (3, 3)\\n(0, 1) -> (1, 2) -> (2, 3) -> (3, 4)\\n(0, 2) -> (1, 3) -> (2, 4) -> (3, 5)\\n(0, 3) -> (1, 4) -> (2, 5)\\n(0, 4) -> (1, 5)\\n(0, 5)\\n```\\n\\n</p>\\n\\n**Time complexity = Space complexity = O(n) = O(rows * cols)**\\n\\n<br/>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\"i lo\" \\n\"ve l\"\\n\"eetc\"\\n\"ode\"\\n\"  \"\\n\" \"\\n```\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encoded, int rows) {\\n        \\n        int n = encoded.size();\\n        int cols = n / rows;\\n        vector<vector<char>> arr(rows, vector<char>(cols));\\n        int k = 0;\\n        \\n\\t\\t// filling the vector\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                arr[i][j] = encoded[k++];\\n            }\\n        }\\n        \\n        string original = \"\";\\n        \\n\\t\\t// diagonal traversal as shown in image \\n        for(int col = 0; col < cols; col++) {\\n            int r = 0;\\n            int c = col;\\n            while(c < cols and r < rows) {\\n                original += arr[r++][c++];\\n            }\\n        }\\n        \\n\\t\\t// removing trailing zeros\\n        while(original.back() == \\' \\') original.pop_back();\\n        \\n        return original;\\n    }\\n};\\n```\n```\\n(0, 0) -> (1, 1) -> (2, 2) -> (3, 3)\\n(0, 1) -> (1, 2) -> (2, 3) -> (3, 4)\\n(0, 2) -> (1, 3) -> (2, 4) -> (3, 5)\\n(0, 3) -> (1, 4) -> (2, 5)\\n(0, 4) -> (1, 5)\\n(0, 5)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577075,
                "title": "python-build-the-cipher-matrix",
                "content": "This solution works as the problem states \"the rightmost column will not be empty after filling in `originalText`\". But then just wonder why it not avoid corner cases as `len(originalText) == 0`. Anyway, testcase like `\"a    \", 4` is treated as invalid case.\\n```\\ndef decodeCiphertext(s, r):\\n\\tk = len(s) // r\\n\\tmat = [s[i*k+i:i*k+k] for i in range(r)]\\n\\tmat[-1] += \" \"  # handle trailing characters for rows in mat[:-1]\\n\\treturn \"\".join(map(\"\".join, zip(*mat))).rstrip()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef decodeCiphertext(s, r):\\n\\tk = len(s) // r\\n\\tmat = [s[i*k+i:i*k+k] for i in range(r)]\\n\\tmat[-1] += \" \"  # handle trailing characters for rows in mat[:-1]\\n\\treturn \"\".join(map(\"\".join, zip(*mat))).rstrip()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2455783,
                "title": "c-easy-understanding-comments-images",
                "content": "![image](https://assets.leetcode.com/users/images/490d4bba-7328-4e7f-b735-38f2bf6e03b9_1661026373.273487.png)\\n![image](https://assets.leetcode.com/users/images/823894aa-6fac-44e2-9cf6-185e8c27e290_1661026380.454058.png)\\n![image](https://assets.leetcode.com/users/images/02554695-2d77-4b9e-aee3-0e0dc62a9893_1661026913.1704528.png)\\n\\n\\n\\tCODE\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring decodeCiphertext(string e, int rows) {\\n\\t\\t\\tint size=e.size();\\n\\t\\t\\tint col=size/rows;\\n\\t\\t\\tstring ans;\\n\\t\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\twhile (isspace(ans.back()))\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n\\t\\t\\n\\t\\t\\nComplexity Analysis\\nSpace Complexity: O(n), where n is the size of encodedText\\nTime Complexity: O(n), where n is the size of encodedText",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring decodeCiphertext(string e, int rows) {\\n\\t\\t\\tint size=e.size();\\n\\t\\t\\tint col=size/rows;\\n\\t\\t\\tstring ans;\\n\\t\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1594638,
                "title": "intuition-explained-simple-simulation-c-clean-code",
                "content": "# **Approach 1:** \\n**Intuition :**\\n\\n* Idea here is to just do what we are asked to perform. That is **simulate** decoding steps. \\n* First, we need to make `cipher` matrix using `encodedText`. \\n* Then, for each column in first row, we traverse diagonally and add those characters to `decodedText` string.\\n* In the end, since trailing spaces are not allowed, so we remove it from `decodedString`. \\n* We can have two cases. \\n\\t* One when `rows = 1`. In this case, we `decodedText` is same as `encodedText`.\\n\\t* And other when `rows > 1`. In this, we need to perform above simulation. \\n\\n* Lets understand through simple example : \\n\\n\\t\\tCase 1 : if rows == 1\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t  Ex: \"c o d i n g\"\\n            \\n\\t\\t\\t-> In this case we do not need to decode text. We can simply return encodedText directly. \\n\\t\\t\\t-> This is because all characters are in first row.\\n\\t\\t\\n\\t\\tCase 2: if rows > 1\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\tEx: encodedText = \"ch   ie   pr\" , rows = 3\\n\\t\\t\\t\\n\\t\\t\\tcipher matrix : \\n\\t\\t\\t\\t  \"c h _ _\\n\\t\\t\\t       _ i e _  \\n\\t\\t\\t\\t   _ _ p r\"\\n           \\n\\t\\t   -> Note : Here, just for sake of explanation, I have take space(\" \") as underscore(_).\\n\\t\\t   \\n            i. k = 0 => {(0,0) : \\'c\\'}, {(1,1) : \\'i\\'}, {(2,2) : \\'p\\'} \\n            ii. k = 1 => {(0,1) : \\'h\\'}, {(1,2) : \\'e\\'}, {(2,3) : \\'r\\'}\\n\\t\\t\\tiii. k = 2 => {(0,2) : \\'_\\'}, {(1,3) : \\'_\\'}\\n\\t\\t\\t\\n\\t\\t\\tThus, decodedString with trailing spaces = \"cipher_ _\". \\n\\t\\t\\tWe need to remove these trailing spaces, and then return resultant string.\\n        \\n\\t\\t\\t\\n# Code :\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if(rows == 1) {\\n            return encodedText;\\n        }\\n        \\n        int cols = encodedText.size() / rows;\\n        \\n        vector<vector<char>> cipher(rows, vector<char>(cols));\\n        \\n        int k = 0;\\n        for(int i=0; i<rows; i++) {\\n            for(int j=0; j<cols; j++) {\\n                cipher[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n\\t\\t// Just added to print cipher \\n        // for(auto& r : cipher) {\\n        //     for(auto& c : r) {\\n        //         cout << c << \" \";\\n        //     }\\n        //     cout << endl;\\n        // }\\n        \\n        string decodedText = \"\";\\n\\t\\t\\n\\t\\t// Traverse diagonally for each column\\n        for(int k=0; k<cols; k++) {\\n            int i=0, j=k;\\n            while(i<rows && j<cols) {\\n                decodedText.push_back(cipher[i++][j++]);\\n            }\\n        }\\n        \\n        // Remove trailing spaces\\n        while(decodedText.back() == \\' \\') {\\n            decodedText.pop_back();\\n        }\\n        \\n        return decodedText;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N + N)`, create `cipher` matrix, and build `decodedText` string.\\n\\t* N is size of `encodedText` string\\n\\n* Space : `O(N)`, for `cipher` matrix for simulation.\\n-------------------------------------------------------\\n------------------------------------------------------\\n# **Approach 2:** \\n\\n**Intuition :**\\n\\n* We can optimize it further, by skipping `cipher` matrix part. We can directly get using `encodedText.` \\n\\n* Idea here is to move `(col+1)` steps each time in `encodedText`, to get next diagonal element. \\n* Since, if we are some coordinate `[i,j]`, then next diagonal element i.e `[i+1, j+1]`. \\n* Now, this is at a distance `(cols + 1)` from `[i,j]`. \\n* So we can directly move by this distance to get next character of `decodedText`\\n\\n# Code : \\n\\n```\\nstring decodeCiphertext(string encodedText, int rows) {\\n        \\n\\tint n = encodedText.size();\\n\\tint cols = n / rows;\\n\\n\\tstring decodedText = \"\";\\n\\n\\tfor(int i=0; i < cols; i++) {\\n\\t\\t// Move by distance (col+1) to get next character\\n\\t\\tfor(int j=i; j<n; j += (cols+1)) {\\n\\t\\t\\tdecodedText += encodedText[j];\\n\\t\\t}\\n\\t}\\n\\n\\twhile(decodedText.back() == \\' \\') decodedText.pop_back();\\n\\n\\treturn decodedText;\\n}\\n```\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if(rows == 1) {\\n            return encodedText;\\n        }\\n        \\n        int cols = encodedText.size() / rows;\\n        \\n        vector<vector<char>> cipher(rows, vector<char>(cols));\\n        \\n        int k = 0;\\n        for(int i=0; i<rows; i++) {\\n            for(int j=0; j<cols; j++) {\\n                cipher[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n\\t\\t// Just added to print cipher \\n        // for(auto& r : cipher) {\\n        //     for(auto& c : r) {\\n        //         cout << c << \" \";\\n        //     }\\n        //     cout << endl;\\n        // }\\n        \\n        string decodedText = \"\";\\n\\t\\t\\n\\t\\t// Traverse diagonally for each column\\n        for(int k=0; k<cols; k++) {\\n            int i=0, j=k;\\n            while(i<rows && j<cols) {\\n                decodedText.push_back(cipher[i++][j++]);\\n            }\\n        }\\n        \\n        // Remove trailing spaces\\n        while(decodedText.back() == \\' \\') {\\n            decodedText.pop_back();\\n        }\\n        \\n        return decodedText;\\n    }\\n};\\n```\n```\\nstring decodeCiphertext(string encodedText, int rows) {\\n        \\n\\tint n = encodedText.size();\\n\\tint cols = n / rows;\\n\\n\\tstring decodedText = \"\";\\n\\n\\tfor(int i=0; i < cols; i++) {\\n\\t\\t// Move by distance (col+1) to get next character\\n\\t\\tfor(int j=i; j<n; j += (cols+1)) {\\n\\t\\t\\tdecodedText += encodedText[j];\\n\\t\\t}\\n\\t}\\n\\n\\twhile(decodedText.back() == \\' \\') decodedText.pop_back();\\n\\n\\treturn decodedText;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1580595,
                "title": "c-straight-forward",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string text, int rows) {\\n        int cols = text.length()/rows;\\n        \\n        char** array = new char*[rows];\\n        for(int i = 0; i < rows; i++)\\n            array[i] = new char[cols];\\n        \\n        int index = 0;\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) \\n                array[i][j] = text[index++];\\n        }\\n        \\n        string ans = \"\";\\n        for(int i = 0; i < cols; i++) {\\n            int r = 0, c = i;\\n            while(r < rows && c < cols) \\n                ans += array[r++][c++];\\n        }\\n        \\n        if(ans.size() == 0) \\n            return ans;\\n        \\n        while(ans[ans.size()-1] == \\' \\') \\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string text, int rows) {\\n        int cols = text.length()/rows;\\n        \\n        char** array = new char*[rows];\\n        for(int i = 0; i < rows; i++)\\n            array[i] = new char[cols];\\n        \\n        int index = 0;\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) \\n                array[i][j] = text[index++];\\n        }\\n        \\n        string ans = \"\";\\n        for(int i = 0; i < cols; i++) {\\n            int r = 0, c = i;\\n            while(r < rows && c < cols) \\n                ans += array[r++][c++];\\n        }\\n        \\n        if(ans.size() == 0) \\n            return ans;\\n        \\n        while(ans[ans.size()-1] == \\' \\') \\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576999,
                "title": "javascript-string-builder",
                "content": "```javascript\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const numColumns = encodedText.length / rows;\\n    const stringBuilder = [];\\n    let nextCol = 1;\\n    let row = 0;\\n    let col = 0;\\n    let index = 0\\n    while (index < encodedText.length) {\\n        stringBuilder.push(encodedText[index]);\\n        if (row === rows - 1 || col === numColumns - 1) {\\n            row = 0;\\n            col = nextCol;\\n            nextCol++;\\n        } else {\\n            row++;\\n            col++;\\n        }\\n        index = calcIndex(row, col, numColumns);\\n    }\\n    while (stringBuilder[stringBuilder.length - 1] === \\' \\') {\\n        stringBuilder.pop();\\n    }\\n    return stringBuilder.join(\\'\\');\\n};\\n\\nfunction calcIndex(row, col, numColumns) {\\n    return row * numColumns + col;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```javascript\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const numColumns = encodedText.length / rows;\\n    const stringBuilder = [];\\n    let nextCol = 1;\\n    let row = 0;\\n    let col = 0;\\n    let index = 0\\n    while (index < encodedText.length) {\\n        stringBuilder.push(encodedText[index]);\\n        if (row === rows - 1 || col === numColumns - 1) {\\n            row = 0;\\n            col = nextCol;\\n            nextCol++;\\n        } else {\\n            row++;\\n            col++;\\n        }\\n        index = calcIndex(row, col, numColumns);\\n    }\\n    while (stringBuilder[stringBuilder.length - 1] === \\' \\') {\\n        stringBuilder.pop();\\n    }\\n    return stringBuilder.join(\\'\\');\\n};\\n\\nfunction calcIndex(row, col, numColumns) {\\n    return row * numColumns + col;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576924,
                "title": "c-simulation",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Simulation\\n\\nSimply traverse the string diagonally. Position `(x, y)` corresponds to `s[y * col + x]`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/decode-the-slanted-ciphertext/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int row) {\\n        int col = s.size() / row;\\n        string ans;\\n        for (int i = 0; i < col; ++i) { // start from each column\\n            for (int x = i, y = 0; x < col && y < row; ++x, ++y) ans += s[y * col + x]; // traverse the string diagonally\\n        }\\n        while (ans.size() && ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/decode-the-slanted-ciphertext/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int row) {\\n        int col = s.size() / row;\\n        string ans;\\n        for (int i = 0; i < col; ++i) { // start from each column\\n            for (int x = i, y = 0; x < col && y < row; ++x, ++y) ans += s[y * col + x]; // traverse the string diagonally\\n        }\\n        while (ans.size() && ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688232,
                "title": "simple-and-easy-explained-every-steps",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(encodedText == \"\")return encodedText;    // base cases\\n        if(rows == 1) return encodedText;           // if rows = 1 simply return\\n        \\n        \\n// create a mat matix where we store our encodedText lineraly row by row as shown in example\\n        // mat\\'s row = rows\\n        // mat\\'s col = encodedText.size() / rows\\n        \\n        vector<vector<char>> mat(rows, vector<char>(encodedText.size() / rows, \\' \\'));\\n        int k = 0;\\n        for(int i = 0; i < mat.size(); i++){\\n            for(int j = 0; j < mat[i].size(); j++){\\n                mat[i][j] = encodedText[k];\\n                k += 1;\\n            }\\n        }\\n        \\n        \\n        \\n        string ret = \"\";\\n        int i = 0;\\n        int col = mat[0].size();\\n        \\n    // now traversing diagonally in mat matix to store answer in ret\\n        while(i != col){\\n            int temp_i = 0;\\n            int temp_j = i;\\n            while(temp_i < rows && temp_j < col){\\n                ret += mat[temp_i][temp_j];\\n                temp_i += 1;\\n                temp_j += 1;\\n            }\\n            i += 1;\\n        }\\n        \\n// erasing tralling space as there are the possibilities that we might find tralling spaces while traversing diagonally \\n        \\n        int last = ret.size() - 1;\\n        while(ret[last] == \\' \\'){\\n            ret.erase(ret.begin() + last);\\n            last -= 1;\\n        }\\n        \\n        return ret;  //returning the decoded string\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(encodedText == \"\")return encodedText;    // base cases\\n        if(rows == 1) return encodedText;           // if rows = 1 simply return\\n        \\n        \\n// create a mat matix where we store our encodedText lineraly row by row as shown in example\\n        // mat\\'s row = rows\\n        // mat\\'s col = encodedText.size() / rows\\n        \\n        vector<vector<char>> mat(rows, vector<char>(encodedText.size() / rows, \\' \\'));\\n        int k = 0;\\n        for(int i = 0; i < mat.size(); i++){\\n            for(int j = 0; j < mat[i].size(); j++){\\n                mat[i][j] = encodedText[k];\\n                k += 1;\\n            }\\n        }\\n        \\n        \\n        \\n        string ret = \"\";\\n        int i = 0;\\n        int col = mat[0].size();\\n        \\n    // now traversing diagonally in mat matix to store answer in ret\\n        while(i != col){\\n            int temp_i = 0;\\n            int temp_j = i;\\n            while(temp_i < rows && temp_j < col){\\n                ret += mat[temp_i][temp_j];\\n                temp_i += 1;\\n                temp_j += 1;\\n            }\\n            i += 1;\\n        }\\n        \\n// erasing tralling space as there are the possibilities that we might find tralling spaces while traversing diagonally \\n        \\n        int last = ret.size() - 1;\\n        while(ret[last] == \\' \\'){\\n            ret.erase(ret.begin() + last);\\n            last -= 1;\\n        }\\n        \\n        return ret;  //returning the decoded string\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588641,
                "title": "simple-python-solution-using-matrix-and-performing-operations-as-given-in-question-brute-force",
                "content": "![image](https://assets.leetcode.com/users/images/f4dad618-812b-4567-acfb-b02c4394eb06_1637437871.282986.png)\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        #print(len(encodedText),rows,len(encodedText)//rows)\\n        if len(encodedText)==0:\\n            return \"\"\\n        ans =\\'\\'\\n        x =[]\\n        c = len(encodedText)//rows\\n        for i in range(0,len(encodedText),c):\\n            x.append(list(encodedText[i:i+c]))\\n        #print(x)\\n        for i in range(c):\\n            k = i\\n            p=\\'\\'\\n            for j in range(rows):\\n                try:\\n                    p = p+x[j][k]\\n                except:\\n                    pass\\n                k = k+1\\n            ans = ans+p\\n        return ans.rstrip()\\n```\\n#  Upvote if useful",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        #print(len(encodedText),rows,len(encodedText)//rows)\\n        if len(encodedText)==0:\\n            return \"\"\\n        ans =\\'\\'\\n        x =[]\\n        c = len(encodedText)//rows\\n        for i in range(0,len(encodedText),c):\\n            x.append(list(encodedText[i:i+c]))\\n        #print(x)\\n        for i in range(c):\\n            k = i\\n            p=\\'\\'\\n            for j in range(rows):\\n                try:\\n                    p = p+x[j][k]\\n                except:\\n                    pass\\n                k = k+1\\n            ans = ans+p\\n        return ans.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578294,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        char[] chars = encodedText.toCharArray();\\n        \\n        int cols = chars.length / rows;\\n        \\n        int i = 0;\\n        int j = 0;\\n        //use this variable to reset j\\'s value.\\n        int counter = 0;\\n        \\n        while (j < cols) {\\n            while (i < rows && j < cols) {\\n                int arrayIndex = i * cols + j;\\n                sb.append(chars[arrayIndex]);\\n                i++;\\n                j++;\\n            }\\n            counter++;\\n            \\n            i = 0;\\n            j = counter;\\n        }\\n        \\n        return removeSpaces(sb).toString();\\n    }\\n    \\n    private StringBuilder removeSpaces(StringBuilder sb) {\\n        if (sb.length() < 1) return sb;\\n        \\n        while(sb.charAt(sb.length() - 1) == \\' \\') {\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        \\n        return sb;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        char[] chars = encodedText.toCharArray();\\n        \\n        int cols = chars.length / rows;\\n        \\n        int i = 0;\\n        int j = 0;\\n        //use this variable to reset j\\'s value.\\n        int counter = 0;\\n        \\n        while (j < cols) {\\n            while (i < rows && j < cols) {\\n                int arrayIndex = i * cols + j;\\n                sb.append(chars[arrayIndex]);\\n                i++;\\n                j++;\\n            }\\n            counter++;\\n            \\n            i = 0;\\n            j = counter;\\n        }\\n        \\n        return removeSpaces(sb).toString();\\n    }\\n    \\n    private StringBuilder removeSpaces(StringBuilder sb) {\\n        if (sb.length() < 1) return sb;\\n        \\n        while(sb.charAt(sb.length() - 1) == \\' \\') {\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        \\n        return sb;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577027,
                "title": "java-fast-and-also-memory-efficient",
                "content": "```\\n int column = encodedText.length() / rows;\\n        char[][] array = new char[rows][column];\\n\\n        int counter = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < column; j++) {\\n                array[i][j] = encodedText.charAt(counter);\\n                counter++;\\n            }\\n        }\\n\\n        StringBuilder builder = new StringBuilder();\\n\\n        for (int i = 0; i < column; i++) {\\n            int cnt = i;\\n            for (int j = 0; j < rows; j++) {\\n                if (cnt < column)\\n                    builder.append(array[j][cnt++]);\\n            }\\n        }\\n\\n        String result = builder.toString();\\n\\n        return result.stripTrailing();\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n int column = encodedText.length() / rows;\\n        char[][] array = new char[rows][column];\\n\\n        int counter = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < column; j++) {\\n                array[i][j] = encodedText.charAt(counter);\\n                counter++;\\n            }\\n        }\\n\\n        StringBuilder builder = new StringBuilder();\\n\\n        for (int i = 0; i < column; i++) {\\n            int cnt = i;\\n            for (int j = 0; j < rows; j++) {\\n                if (cnt < column)\\n                    builder.append(array[j][cnt++]);\\n            }\\n        }\\n\\n        String result = builder.toString();\\n\\n        return result.stripTrailing();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576933,
                "title": "java-bruteforce-concise-solution",
                "content": "`\\n\\njAVA BRUTE FORCE SOLUTION\\n\\n    public String decodeCiphertext(String str, int rows) {\\n        \\n        if(rows==1) return str;\\n        int num=0;\\n        \\n        int i=0,len=str.length();\\n        int j=0;\\n        int temp=len/rows+1;\\n        if(len%rows!=0) temp++;\\n        \\n        char arr[][]=new char[rows][temp];\\n        while(i<len){\\n            int c=Math.min(temp,len-i);\\n            if(c!=temp){\\n                for(int k=0;k<c;k++){\\n                    arr[j][k]=str.charAt(i+k);\\n                }\\n            }\\n            else{\\n                arr[j++]=str.substring(i,i+temp).toCharArray();\\n            }\\n            \\n            i+=temp;\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(i=0;i<temp;i++){\\n            for(j=0;j<rows;j++){\\n                sb.append(arr[j][i]);\\n            }\\n        }\\n        str=sb.toString();\\n        i=str.length()-1;\\n        while(i>=0 && (str.charAt(i)==\\'\\\\u0000\\' || str.charAt(i)==\\' \\')) i--;\\n        return str.substring(0,i+1);\\n    }\\n\\t\\n\\tAPPROACH 2\\n\\t  public String decodeCiphertext(String encodedText, int rows) {\\n        int l = (encodedText.length() % rows == 0) ? encodedText.length()/rows : encodedText.length()/rows + 1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int j = 0; j < l; j++) {     \\n            for (int i = 0; i < rows; i++) {\\n                if (i + j + i * l < encodedText.length())\\n                    sb.append(encodedText.charAt(i + j + i * l));\\n            }\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "`\\n\\njAVA BRUTE FORCE SOLUTION\\n\\n    public String decodeCiphertext(String str, int rows) {\\n        \\n        if(rows==1) return str;\\n        int num=0;\\n        \\n        int i=0,len=str.length();\\n        int j=0;\\n        int temp=len/rows+1;\\n        if(len%rows!=0) temp++;\\n        \\n        char arr[][]=new char[rows][temp];\\n        while(i<len){\\n            int c=Math.min(temp,len-i);\\n            if(c!=temp){\\n                for(int k=0;k<c;k++){\\n                    arr[j][k]=str.charAt(i+k);\\n                }\\n            }\\n            else{\\n                arr[j++]=str.substring(i,i+temp).toCharArray();\\n            }\\n            \\n            i+=temp;\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(i=0;i<temp;i++){\\n            for(j=0;j<rows;j++){\\n                sb.append(arr[j][i]);\\n            }\\n        }\\n        str=sb.toString();\\n        i=str.length()-1;\\n        while(i>=0 && (str.charAt(i)==\\'\\\\u0000\\' || str.charAt(i)==\\' \\')) i--;\\n        return str.substring(0,i+1);\\n    }\\n\\t\\n\\tAPPROACH 2\\n\\t  public String decodeCiphertext(String encodedText, int rows) {\\n        int l = (encodedText.length() % rows == 0) ? encodedText.length()/rows : encodedText.length()/rows + 1;\\n        StringBuilder sb = new StringBuilder();\\n        for (int j = 0; j < l; j++) {     \\n            for (int i = 0; i < rows; i++) {\\n                if (i + j + i * l < encodedText.length())\\n                    sb.append(encodedText.charAt(i + j + i * l));\\n            }\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3735249,
                "title": "c-o-1-space-o-n-time-10-lines-easy-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string eT, int rows) {\\n        int n=eT.size();\\n        int col=n/rows;\\n        string s=\"\";\\n        for(int i=0;i<col;i++){\\n            int j=i;\\n            while(j<n){\\n                s+=eT[j];\\n                j=j+col+1;\\n            }\\n        }\\n        while(isspace(s.back())){\\n            s.pop_back();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string eT, int rows) {\\n        int n=eT.size();\\n        int col=n/rows;\\n        string s=\"\";\\n        for(int i=0;i<col;i++){\\n            int j=i;\\n            while(j<n){\\n                s+=eT[j];\\n                j=j+col+1;\\n            }\\n        }\\n        while(isspace(s.back())){\\n            s.pop_back();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645156,
                "title": "beats-90-easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor encoded text length times traverse diagonally and add it to the result. remove all the trail spaces and return. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntraverse no of columns times and add characters diagonally (2d array as 1d array method) until it crosses limits. and remove trailing spaces. \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(encodedText == \"\")  return encodedText; \\n        int columns = ceil(encodedText.length()/rows);\\n        string ans = \"\"; \\n        for(int i=0; i<columns; i++){\\n            int r = 0, c = i; \\n            while(c < columns && r<rows){ ans += encodedText[r*columns + c]; r++; c++;}\\n        }\\n        int len = ans.length(); \\n        while(ans[len-1] == \\' \\') len--;\\n        ans = ans.substr(0, len); \\n\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(encodedText == \"\")  return encodedText; \\n        int columns = ceil(encodedText.length()/rows);\\n        string ans = \"\"; \\n        for(int i=0; i<columns; i++){\\n            int r = 0, c = i; \\n            while(c < columns && r<rows){ ans += encodedText[r*columns + c]; r++; c++;}\\n        }\\n        int len = ans.length(); \\n        while(ans[len-1] == \\' \\') len--;\\n        ans = ans.substr(0, len); \\n\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404765,
                "title": "python3-solution-time-99-33-space-100",
                "content": "![Capture d\\u2019\\xE9cran (96).png](https://assets.leetcode.com/users/images/3e9f8a31-b0d3-4995-ae49-64d20c8c39d1_1681219407.2042663.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\\n        if rows == 1:\\n            return encoded_text\\n\\n        N = len(encoded_text)\\n        cols = N // rows\\n        i, j, k = 0, 0, 0\\n        original_text = []\\n\\n        while k < N:\\n            original_text.append(encoded_text[k])\\n            i += 1\\n            if i == rows:\\n                i = 0\\n                j += 1\\n            k = i*(cols + 1) + j\\n\\n        return \\'\\'.join(original_text).rstrip()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\\n        if rows == 1:\\n            return encoded_text\\n\\n        N = len(encoded_text)\\n        cols = N // rows\\n        i, j, k = 0, 0, 0\\n        original_text = []\\n\\n        while k < N:\\n            original_text.append(encoded_text[k])\\n            i += 1\\n            if i == rows:\\n                i = 0\\n                j += 1\\n            k = i*(cols + 1) + j\\n\\n        return \\'\\'.join(original_text).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102251,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int m = rows;\\n        int n = (encodedText.length()/rows);\\n        vector<vector<char>> vc(m,vector<char>(n));\\n        int ind = 0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<n;j++){\\n                vc[i][j]=encodedText[j+ind];\\n            }\\n            ind+=n;\\n        } \\n        string ans = \"\";\\n        for(int j=0;j<n;j++){\\n            int starti = 0;\\n            int startj = j;\\n            while(starti<m && startj<n){\\n                ans+=vc[starti][startj];\\n                starti++;\\n                startj++;\\n            }\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int m = rows;\\n        int n = (encodedText.length()/rows);\\n        vector<vector<char>> vc(m,vector<char>(n));\\n        int ind = 0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<n;j++){\\n                vc[i][j]=encodedText[j+ind];\\n            }\\n            ind+=n;\\n        } \\n        string ans = \"\";\\n        for(int j=0;j<n;j++){\\n            int starti = 0;\\n            int startj = j;\\n            while(starti<m && startj<n){\\n                ans+=vc[starti][startj];\\n                starti++;\\n                startj++;\\n            }\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943766,
                "title": "c-2d-index-conversion",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int r) {\\n        int c = s.size() / r;\\n        string ans = \"\";\\n        for (int i = 0; i < c; ++i)\\n            ans += findDiagonal(0, i, s, c, r);\\n        while (!ans.empty() && ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n    string findDiagonal(int i, int y, string& s, int& c, int& r){\\n        int nextInd = i * c + y;\\n        if (nextInd >= s.size()) return \"\";\\n        return s[nextInd] + findDiagonal(i + 1, y + 1, s, c, r);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int r) {\\n        int c = s.size() / r;\\n        string ans = \"\";\\n        for (int i = 0; i < c; ++i)\\n            ans += findDiagonal(0, i, s, c, r);\\n        while (!ans.empty() && ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n    string findDiagonal(int i, int y, string& s, int& c, int& r){\\n        int nextInd = i * c + y;\\n        if (nextInd >= s.size()) return \"\";\\n        return s[nextInd] + findDiagonal(i + 1, y + 1, s, c, r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724209,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   string decodeCiphertext(string e, int rows) {\\n\\t\\tint size=e.size();\\n\\t\\tint col=size/rows;\\n\\t\\tstring ans;\\n\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (isspace(ans.back()))\\n\\t\\t{\\n\\t\\t\\tans.pop_back();\\n\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string decodeCiphertext(string e, int rows) {\\n\\t\\tint size=e.size();\\n\\t\\tint col=size/rows;\\n\\t\\tstring ans;\\n\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (isspace(ans.back()))\\n\\t\\t{\\n\\t\\t\\tans.pop_back();\\n\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396405,
                "title": "memory-limit-exceeded",
                "content": "If your answer is in string ans.\\ndon\\'t do ans = ans + char\\n\\nThis causes MLE!",
                "solutionTags": [
                    "C"
                ],
                "code": "If your answer is in string ans.\\ndon\\'t do ans = ans + char\\n\\nThis causes MLE!",
                "codeTag": "Unknown"
            },
            {
                "id": 2034993,
                "title": "javascript-solution-simulation",
                "content": "```\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const n = encodedText.length;\\n    const cols = n / rows;\\n    let res = \"\";\\n    \\n    for (let i = 0; i < cols; ++i) {\\n        let str = \"\";\\n        \\n        let row = 0;\\n        let col = i % cols;\\n        \\n        while (row < rows && col < cols) {\\n            const idx = (row * cols) + col;\\n            \\n            str += encodedText.charAt(idx);\\n            \\n            row += 1;\\n            col += 1;\\n        }\\n        \\n        res += str;\\n    }\\n\\n    return res.trimEnd();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Simulation"
                ],
                "code": "```\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const n = encodedText.length;\\n    const cols = n / rows;\\n    let res = \"\";\\n    \\n    for (let i = 0; i < cols; ++i) {\\n        let str = \"\";\\n        \\n        let row = 0;\\n        let col = i % cols;\\n        \\n        while (row < rows && col < cols) {\\n            const idx = (row * cols) + col;\\n            \\n            str += encodedText.charAt(idx);\\n            \\n            row += 1;\\n            col += 1;\\n        }\\n        \\n        res += str;\\n    }\\n\\n    return res.trimEnd();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1813633,
                "title": "c-solution-with-simple-explanation-diagonal-traversal",
                "content": "Idea: - Its given in Question that matrix would be filled up till last coloumn and we will always be starting from (0,0) ,and we are given encrypted string and rows . we will find no of cols then  firstly we will construct a 2D matrix and fill our encypted string just as shown in question\\'s pic . Then we will traverse it diagonally and construct our orignal string . In the last step we will remove extra spaces at end of orignal string\\n\\n\\n**Step 1 :** To find no of cols , its basically length of encypted string / rows .(because we know from question that filling would start from (0,0) and go uptill last col for sure )\\n\\n**Step 2 :**  Now we will fill our encypted string in that matrix . Will fill first row then move to second row and continue this uptill last row\\n\\n**Step 3 :** -  Now all we need to do is traverse diagonally and start building up our orignal string .lets see this step in detail . eg we need to traverse  matrix of row=4 , col=6 (example of I love leetcoding matrix given in question)\\n\\n(0,0)  -> (1,1) -> (2,2) -> (3,3)\\n(0,1)  -> (1,2) -> (2,3) -> (3,4)\\n(0,2)  -> (1,3) -> (2,4) -> (3,5)\\n(0,3)  -> (1,4) -> (2,5)\\n(0,4)  -> (1,5)\\n(0,5)\\n\\nHere we clearly see we need to do 6 iteration (or we can say no of iteration=no of cols), and in every iteration ith index will start from 0 and go at max till no of rows -1 , jth index starts 0 in first iteration , from 1 in second iteration and will go at max till col-1 . Now we just need to write that in code \\n\\n\\n\\n```\\nstring decodeCiphertext(string encodedText, int rows) \\n    {\\n      int n=encodedText.size();\\n\\t  \\n\\t  // finding no of cols (Step 1)\\n\\t  \\n      int col=n/rows;\\n      \\n      // creating 2D matrix  (Step 2)\\n\\t  \\n      vector<vector<char>>matrix(rows,vector<char>(col));\\n      \\n      int index=0;\\n\\t  \\n\\t  // Filling 2D matrix (Step 2)\\n\\t  \\n      for(int i=0;i<rows;i++)\\n      {\\n        for(int j=0;j<col;j++)\\n        {\\n          matrix[i][j]=encodedText[index++];\\n        }\\n      }\\n      \\n\\t  \\n\\t  // Traversing diagonally (Step 3)\\n\\t  \\n      string ans=\"\";\\n\\t  \\n      for(int j = 0; j < col; j++) \\n      {\\n            int r = 0;\\n            int c = j;\\n            while(c < col and r < rows) \\n            {\\n                ans += matrix[r++][c++];\\n            }\\n      }\\n      \\n     \\n\\t // Last Step (Removing extra spaces from our orignal string)\\n\\t \\n     while (!ans.empty() && ans.back() == \\' \\') \\n     {\\n            ans.pop_back();\\n     }\\n      \\n      return ans;\\n      \\n\\n      \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring decodeCiphertext(string encodedText, int rows) \\n    {\\n      int n=encodedText.size();\\n\\t  \\n\\t  // finding no of cols (Step 1)\\n\\t  \\n      int col=n/rows;\\n      \\n      // creating 2D matrix  (Step 2)\\n\\t  \\n      vector<vector<char>>matrix(rows,vector<char>(col));\\n      \\n      int index=0;\\n\\t  \\n\\t  // Filling 2D matrix (Step 2)\\n\\t  \\n      for(int i=0;i<rows;i++)\\n      {\\n        for(int j=0;j<col;j++)\\n        {\\n          matrix[i][j]=encodedText[index++];\\n        }\\n      }\\n      \\n\\t  \\n\\t  // Traversing diagonally (Step 3)\\n\\t  \\n      string ans=\"\";\\n\\t  \\n      for(int j = 0; j < col; j++) \\n      {\\n            int r = 0;\\n            int c = j;\\n            while(c < col and r < rows) \\n            {\\n                ans += matrix[r++][c++];\\n            }\\n      }\\n      \\n     \\n\\t // Last Step (Removing extra spaces from our orignal string)\\n\\t \\n     while (!ans.empty() && ans.back() == \\' \\') \\n     {\\n            ans.pop_back();\\n     }\\n      \\n      return ans;\\n      \\n\\n      \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1776864,
                "title": "js-simple-solution-easy-to-understand",
                "content": "```\\nvar decodeCiphertext = function(encodedText, rows) {\\n    if(encodedText.length == 0)\\n        return \"\"\\n    var mat= [];\\n    var n=(encodedText.length/rows);\\n    var temp = [];\\n    for(var i=0, c=1; i<encodedText.length; i++, c++)\\n        {\\n            temp.push(encodedText[i]);\\n            if(c == n)\\n                {\\n                    mat.push(temp);\\n                    c=0;\\n                    temp = [];\\n                }\\n        }\\n    var output = \"\";\\n    for(var i=0; i<mat[0].length; i++)\\n        {\\n            var r=0, c=i;\\n            while(r<mat.length && c<mat[0].length)\\n                {\\n                    output+=mat[r++][c++];\\n                }\\n        }\\n    return output.trimEnd();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decodeCiphertext = function(encodedText, rows) {\\n    if(encodedText.length == 0)\\n        return \"\"\\n    var mat= [];\\n    var n=(encodedText.length/rows);\\n    var temp = [];\\n    for(var i=0, c=1; i<encodedText.length; i++, c++)\\n        {\\n            temp.push(encodedText[i]);\\n            if(c == n)\\n                {\\n                    mat.push(temp);\\n                    c=0;\\n                    temp = [];\\n                }\\n        }\\n    var output = \"\";\\n    for(var i=0; i<mat[0].length; i++)\\n        {\\n            var r=0, c=i;\\n            while(r<mat.length && c<mat[0].length)\\n                {\\n                    output+=mat[r++][c++];\\n                }\\n        }\\n    return output.trimEnd();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1753881,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, s: str, rows: int) -> str:\\n        if not s: return \"\"\\n        n=len(s)\\n        cols=n//rows\\n        arr=[\" \"]*n\\n        for i in range(rows):\\n            for j in range(cols):\\n                if i>j: continue\\n                arr[i+rows*(j-i)]=s[i*cols+j]\\n        i=n-1\\n        while i>=0 and arr[i]==\" \":\\n            i-=1\\n        return \\'\\'.join(arr[:i+1])\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, s: str, rows: int) -> str:\\n        if not s: return \"\"\\n        n=len(s)\\n        cols=n//rows\\n        arr=[\" \"]*n\\n        for i in range(rows):\\n            for j in range(cols):\\n                if i>j: continue\\n                arr[i+rows*(j-i)]=s[i*cols+j]\\n        i=n-1\\n        while i>=0 and arr[i]==\" \":\\n            i-=1\\n        return \\'\\'.join(arr[:i+1])\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682589,
                "title": "easy-cpp-col-1-jumps",
                "content": "```\\ncommented for better explanation , tried best to deliver the concept of code\\n```\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) \\n    {\\n        // to find the col of the table we are doing this \\n        int sz = s.size();\\n        int col = sz/rows;\\n        // we move till col and add the chars using col+1 jumps on full string \\n        string ans;\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=i;j<sz;j+=col+1)\\n            {\\n                ans+=s[j];\\n               \\n            }\\n        }\\n        // at last we will left with some spaces , to clear we make this \\n        // to return our result correct \\n        while(!ans.empty() and ans.back()==\\' \\')\\n        {\\n            ans.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ncommented for better explanation , tried best to deliver the concept of code\\n```\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) \\n    {\\n        // to find the col of the table we are doing this \\n        int sz = s.size();\\n        int col = sz/rows;\\n        // we move till col and add the chars using col+1 jumps on full string \\n        string ans;\\n        for(int i=0;i<col;i++)\\n        {\\n            for(int j=i;j<sz;j+=col+1)\\n            {\\n                ans+=s[j];\\n               \\n            }\\n        }\\n        // at last we will left with some spaces , to clear we make this \\n        // to return our result correct \\n        while(!ans.empty() and ans.back()==\\' \\')\\n        {\\n            ans.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627031,
                "title": "python3-260ms-runtime-faster-than-96-and-uses-91-less-memory",
                "content": "`Execution Result`\\n\\n```\\nRuntime: 260 ms, faster than 96.14% of Python3 online submissions for Decode the Slanted Ciphertext.\\nMemory Usage: 26.8 MB, less than 91.49% of Python3 online submissions for Decode the Slanted Ciphertext.\\n```\\n\\n`Code`\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        op = \\'\\'\\n        total_cols = int(   len(encodedText) / rows )\\n        row = 0\\n        col = 0\\n        while True:\\n            try:\\n                calc = (row*total_cols)+row+col\\n                char = encodedText[calc]\\n            except IndexError:\\n                break\\n            op += char\\n            row+=1\\n            if row == rows:\\n                row = 0\\n                col+=1\\n        return op.rstrip()\\n```\\n\\n`Tests`\\n```\\nprint(Solution().decodeCiphertext(encodedText = \"ch   ie   pr\", rows = 3))\\nprint(Solution().decodeCiphertext(encodedText = \"iveo    eed   l te   olc\", rows = 4))\\nprint(Solution().decodeCiphertext(encodedText = \"coding\", rows = 1))\\nprint(Solution().decodeCiphertext(encodedText = \" b  ac\", rows = 2))\\nprint(Solution().decodeCiphertext(\"wmihfwf bddhzaizuzhbuoovyyjstardqceaqzafdzihjbj ywly amkeemr jmvsfaavbpgiafgxzciwmrrtasthc hqfrtwoizoilw\", 2)  )\\nN = pow(10, 6)\\nimport random, string\\nprint(Solution().decodeCiphertext(encodedText = \\'\\'.join(random.choices(string.ascii_lowercase + \\' \\', k=N)), rows = pow(10, 3)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nRuntime: 260 ms, faster than 96.14% of Python3 online submissions for Decode the Slanted Ciphertext.\\nMemory Usage: 26.8 MB, less than 91.49% of Python3 online submissions for Decode the Slanted Ciphertext.\\n```\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        op = \\'\\'\\n        total_cols = int(   len(encodedText) / rows )\\n        row = 0\\n        col = 0\\n        while True:\\n            try:\\n                calc = (row*total_cols)+row+col\\n                char = encodedText[calc]\\n            except IndexError:\\n                break\\n            op += char\\n            row+=1\\n            if row == rows:\\n                row = 0\\n                col+=1\\n        return op.rstrip()\\n```\n```\\nprint(Solution().decodeCiphertext(encodedText = \"ch   ie   pr\", rows = 3))\\nprint(Solution().decodeCiphertext(encodedText = \"iveo    eed   l te   olc\", rows = 4))\\nprint(Solution().decodeCiphertext(encodedText = \"coding\", rows = 1))\\nprint(Solution().decodeCiphertext(encodedText = \" b  ac\", rows = 2))\\nprint(Solution().decodeCiphertext(\"wmihfwf bddhzaizuzhbuoovyyjstardqceaqzafdzihjbj ywly amkeemr jmvsfaavbpgiafgxzciwmrrtasthc hqfrtwoizoilw\", 2)  )\\nN = pow(10, 6)\\nimport random, string\\nprint(Solution().decodeCiphertext(encodedText = \\'\\'.join(random.choices(string.ascii_lowercase + \\' \\', k=N)), rows = pow(10, 3)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606713,
                "title": "simple-and-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int col = n/rows;  //bcs n = rows*cols(always) -> observation\\n        string res;\\n        for(int i=0;i<col;i++){\\n            for(int j=i; j<n; j+=(col+1)) //we can observe that to travel diagonallly we have to increamnt by (col+1)\\n                res += (encodedText[j]);\\n        }\\n        while(res.back() == \\' \\') res.pop_back();\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int col = n/rows;  //bcs n = rows*cols(always) -> observation\\n        string res;\\n        for(int i=0;i<col;i++){\\n            for(int j=i; j<n; j+=(col+1)) //we can observe that to travel diagonallly we have to increamnt by (col+1)\\n                res += (encodedText[j]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1592079,
                "title": "golang-solution-with-explanation",
                "content": "The main idea of this solution is to find the number of columns. The solution comes together pretty quickly after that.\\n\\nTo explain my thinking to how I found the number of columns we have to take a matrix. We should know the number rows and columns in that matrix. For example:\\n\\n`[a][d][g][ ]`\\n`[ ][b][e][h]`\\n`[ ][ ][c][f]`\\n\\nWe have a matrix with 3 rows and 4 columns, and 12 items. `3 * 4 = 12`, so if we are given a matrix of size 12 and 3 rows, we can do `12 / 3 = 4` to get the number of columns. Since we know that the number of values in the matrix can be shown using `len(encodedText)` and the problem gives us the number of rows, we can do `len(encodedText) / rows = cols`.\\n\\nThen all we have to do is add all the letters in a particular order.\\n\\nNote that `res` is not a `string` because that will output a TLE.\\n\\n``` go\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n    n := len(encodedText)\\n    cols := n / rows\\n    res := []string{}\\n    \\n    for i := 0; i < cols; i++ {\\n        for j := i; j < n; j += cols + 1 {\\n            res = append(res, string(encodedText[j]))\\n        }\\n    }\\n    \\n    return strings.TrimRight(strings.Join(res, \"\"), \" \")\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n    n := len(encodedText)\\n    cols := n / rows\\n    res := []string{}\\n    \\n    for i := 0; i < cols; i++ {\\n        for j := i; j < n; j += cols + 1 {\\n            res = append(res, string(encodedText[j]))\\n        }\\n    }\\n    \\n    return strings.TrimRight(strings.Join(res, \"\"), \" \")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1584499,
                "title": "python3-solution-time-o-n-space-o-1",
                "content": "Python3 Solution\\n\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        total_index = cols*rows\\n        final_str = \"\"\\n        for i in range(cols):\\n            cur_ind = i\\n            \\n            while cur_ind < total_index:\\n                final_str += encodedText[cur_ind]\\n                cur_ind += cols+1\\n                \\n\\n            \\n        return final_str.rstrip()\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        total_index = cols*rows\\n        final_str = \"\"\\n        for i in range(cols):\\n            cur_ind = i\\n            \\n            while cur_ind < total_index:\\n                final_str += encodedText[cur_ind]\\n                cur_ind += cols+1\\n                \\n\\n            \\n        return final_str.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580159,
                "title": "c-o-n-solution",
                "content": "**Example:**\\n```\\n// \\'_\\' - space\\n// encodedText = \"c h _ _ _ i e _ _ _ p r\",  encodedLength = 12, rows = 3, \\n// columns = encodedText.Length/rows = 4\\n// encodedText[0] = c\\n// encodedText[5] = i\\n// encodedText[10] = p\\n// encodedText[1] = h\\n// encodedText[6] = e\\n// encodedText[11] = r\\n// encodedText[2] = _  \\n// encodedText[7] = _\\n// encodedText[3] = _\\nHere we can see pattern - 0, 5, 10, 1, 6, 11, ...\\n```\\n\\n**Solution with array:**\\n\\n```\\n\\tpublic string DecodeCiphertext(string encodedText, int rows) {\\n        if (rows == 1 || encodedText.Length == 0)\\n            return encodedText;\\n        \\n        int columns = encodedText.Length / rows;\\n        int offset = columns+1; \\n        var decodedArr = new char[encodedText.Length];\\n        var decodedIndex = 0;\\n        var lastLetterIndex = 0;\\n        for (int start=0; start<columns; start++) \\n        {\\n            for (int index = start; index < encodedText.Length; index += offset) \\n            {\\n                decodedArr[decodedIndex] = encodedText[index];\\n                if (Char.IsLower(decodedArr[decodedIndex]))\\n                    lastLetterIndex = decodedIndex;\\n                decodedIndex++;\\n            }\\n        }\\n        return new string(decodedArr, 0, lastLetterIndex+1); // remove all trailing spaces\\n    }\\n```\\n\\n**Solution with StringBuilder:**\\n```\\n\\tpublic string DecodeCiphertext(string encodedText, int rows) {\\n        if (rows == 1 || encodedText.Length == 0)\\n            return encodedText;\\n        \\n        var sb = new StringBuilder(encodedText.Length);\\n        int columns = encodedText.Length / rows;\\n        int offset = columns+1;\\n        for (int start=0; start<columns; start++) \\n            for (int index = start; index < encodedText.Length; index += offset) \\n                sb.Append(encodedText[index]);\\n        \\n        return sb.ToString().TrimEnd();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n// \\'_\\' - space\\n// encodedText = \"c h _ _ _ i e _ _ _ p r\",  encodedLength = 12, rows = 3, \\n// columns = encodedText.Length/rows = 4\\n// encodedText[0] = c\\n// encodedText[5] = i\\n// encodedText[10] = p\\n// encodedText[1] = h\\n// encodedText[6] = e\\n// encodedText[11] = r\\n// encodedText[2] = _  \\n// encodedText[7] = _\\n// encodedText[3] = _\\nHere we can see pattern - 0, 5, 10, 1, 6, 11, ...\\n```\n```\\n\\tpublic string DecodeCiphertext(string encodedText, int rows) {\\n        if (rows == 1 || encodedText.Length == 0)\\n            return encodedText;\\n        \\n        int columns = encodedText.Length / rows;\\n        int offset = columns+1; \\n        var decodedArr = new char[encodedText.Length];\\n        var decodedIndex = 0;\\n        var lastLetterIndex = 0;\\n        for (int start=0; start<columns; start++) \\n        {\\n            for (int index = start; index < encodedText.Length; index += offset) \\n            {\\n                decodedArr[decodedIndex] = encodedText[index];\\n                if (Char.IsLower(decodedArr[decodedIndex]))\\n                    lastLetterIndex = decodedIndex;\\n                decodedIndex++;\\n            }\\n        }\\n        return new string(decodedArr, 0, lastLetterIndex+1); // remove all trailing spaces\\n    }\\n```\n```\\n\\tpublic string DecodeCiphertext(string encodedText, int rows) {\\n        if (rows == 1 || encodedText.Length == 0)\\n            return encodedText;\\n        \\n        var sb = new StringBuilder(encodedText.Length);\\n        int columns = encodedText.Length / rows;\\n        int offset = columns+1;\\n        for (int start=0; start<columns; start++) \\n            for (int index = start; index < encodedText.Length; index += offset) \\n                sb.Append(encodedText[index]);\\n        \\n        return sb.ToString().TrimEnd();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580075,
                "title": "c-diagonal-traversal-o-n-time-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string res = \"\";\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        vector<vector<char>> v(rows, vector<char>(cols));\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                v[i][j] = encodedText[i*cols + j];\\n            }\\n        }\\n        for(int g=0; g<cols; g++){\\n            for(int i=0, j=i+g; i<rows && j<cols; i++, j++){\\n                res += v[i][j];\\n            }\\n        }\\n        int l = res.length();\\n        while(l > 0 && res[l-1] == \\' \\'){\\n            res.pop_back();\\n            l--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string res = \"\";\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        vector<vector<char>> v(rows, vector<char>(cols));\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                v[i][j] = encodedText[i*cols + j];\\n            }\\n        }\\n        for(int g=0; g<cols; g++){\\n            for(int i=0, j=i+g; i<rows && j<cols; i++, j++){\\n                res += v[i][j];\\n            }\\n        }\\n        int l = res.length();\\n        while(l > 0 && res[l-1] == \\' \\'){\\n            res.pop_back();\\n            l--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579817,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        res = []\\n        cols = n // rows\\n        \\n        for i in range(cols):\\n            for j in range(i, n, cols+1):\\n                res.append(encodedText[j])  # it is observed that skipping cols+1 from a given pos gives the required char\\n                \\n        return \\'\\'.join(res).rstrip(\\' \\')  # removes trailing spaces from right\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        res = []\\n        cols = n // rows\\n        \\n        for i in range(cols):\\n            for j in range(i, n, cols+1):\\n                res.append(encodedText[j])  # it is observed that skipping cols+1 from a given pos gives the required char\\n                \\n        return \\'\\'.join(res).rstrip(\\' \\')  # removes trailing spaces from right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578286,
                "title": "python-2-approaches",
                "content": "Python O(n**2) / O(n) - matrix construction\\n```\\nclass Solution:\\n    def generate_matrix(self, s, rows, cols, N):\\n        i = 0\\n        m = [[None] * cols for _ in range(rows)]\\n        for r in range(rows):\\n            for c in range(cols):\\n                m[r][c] = s[i]\\n                i += 1\\n                if i >= N: return m\\n                \\n    def decipher_by_matrix(self, m, rows, cols, N):\\n        i = 0        \\n        result = []\\n        \\n        for c in range(cols):\\n            ci, ri = c, 0\\n            if i >= N: return result  \\n            while ci < cols and ri < rows and i < N:\\n                result.append(m[ri][ci])\\n                ri += 1\\n                ci += 1\\n                i += 1\\n                \\n        return result  \\n    \\n    def decodeCiphertext(self, s: str, rows: int) -> str:\\n        N = len(s)        \\n        cols = N // rows\\n        \\n        m = self.generate_matrix(s, rows, cols, N)                \\n        result = self.decipher_by_matrix(m, rows, cols, N)\\n                                    \\n        return \\'\\'.join(result).rstrip()\\n```\\n\\nPython O(n)/O(1)\\n```\\nclass Solution:\\n    def decodeCiphertext(self, s, rows):\\n        cols, N, result = len(s) // rows, len(s), []\\n        for col in range(cols):\\n            for move in range(col, N, cols + 1):\\n                result.append(s[move])                \\n        return \\'\\'.join(result).rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generate_matrix(self, s, rows, cols, N):\\n        i = 0\\n        m = [[None] * cols for _ in range(rows)]\\n        for r in range(rows):\\n            for c in range(cols):\\n                m[r][c] = s[i]\\n                i += 1\\n                if i >= N: return m\\n                \\n    def decipher_by_matrix(self, m, rows, cols, N):\\n        i = 0        \\n        result = []\\n        \\n        for c in range(cols):\\n            ci, ri = c, 0\\n            if i >= N: return result  \\n            while ci < cols and ri < rows and i < N:\\n                result.append(m[ri][ci])\\n                ri += 1\\n                ci += 1\\n                i += 1\\n                \\n        return result  \\n    \\n    def decodeCiphertext(self, s: str, rows: int) -> str:\\n        N = len(s)        \\n        cols = N // rows\\n        \\n        m = self.generate_matrix(s, rows, cols, N)                \\n        result = self.decipher_by_matrix(m, rows, cols, N)\\n                                    \\n        return \\'\\'.join(result).rstrip()\\n```\n```\\nclass Solution:\\n    def decodeCiphertext(self, s, rows):\\n        cols, N, result = len(s) // rows, len(s), []\\n        for col in range(cols):\\n            for move in range(col, N, cols + 1):\\n                result.append(s[move])                \\n        return \\'\\'.join(result).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578283,
                "title": "python-solution-with-explanation-approach",
                "content": "First we need to understand the format in which the encrypted answer is given. We get it in the length of (math.ceil(len(encodedText)/rows)).\\nNow just start 2 for loops. One for the ith element and the other for the row. \\nIf we visualize it becomes,\\nFIrst word first letter, Second Word second letter, Third word third letter till end\\nThen the next time it\\'s First word second letter, second word third letter and so on.\\n\\n\\n\\n```\\ndef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = (math.ceil(len(encodedText)/rows))\\n        if rows==1:\\n            return encodedText\\n        if n==0:\\n            return \"\"\\n        out = [(encodedText[i:i+n]) for i in range(0, len(encodedText), n)]\\n        res = \"\"\\n        for i in range(n):\\n            for j in range(0,rows):\\n                try:\\n                    if j+i<=n:\\n                        res += out[j][j+i]\\n                    else:\\n                        return res\\n                except:\\n                    return res.rstrip()\\n\\t```\\n\\t\\n\\tNot the best explaination but I learning how to explain my approach to others. Do ask if any doubt.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = (math.ceil(len(encodedText)/rows))\\n        if rows==1:\\n            return encodedText\\n        if n==0:\\n            return \"\"\\n        out = [(encodedText[i:i+n]) for i in range(0, len(encodedText), n)]\\n        res = \"\"\\n        for i in range(n):\\n            for j in range(0,rows):\\n                try:\\n                    if j+i<=n:\\n                        res += out[j][j+i]\\n                    else:\\n                        return res\\n                except:\\n                    return res.rstrip()\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1577063,
                "title": "python3-simulation",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/8d693371fa97ea3b0717d02448c77201b15e5d12) for solutions of weekly 267.\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        ans = []\\n        for offset in range(cols): \\n            i, j = 0, offset\\n            while i*cols+j < len(encodedText): \\n                ans.append(encodedText[i*cols+j])\\n                i, j = i+1, j+1\\n        return \"\".join(ans).rstrip()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        ans = []\\n        for offset in range(cols): \\n            i, j = 0, offset\\n            while i*cols+j < len(encodedText): \\n                ans.append(encodedText[i*cols+j])\\n                i, j = i+1, j+1\\n        return \"\".join(ans).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576987,
                "title": "c-2075-decode-the-slanted-ciphertext",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cols = encodedText.size() / rows; \\n        string ans; \\n        for (int offset = 0; offset < cols; ++offset) \\n            for (int i = 0, j = offset;  i*cols+j < encodedText.size(); ++i, ++j) \\n                ans.push_back(encodedText[i*cols+j]); \\n        return ans.substr(0, 1+ans.find_last_not_of(\\' \\')); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cols = encodedText.size() / rows; \\n        string ans; \\n        for (int offset = 0; offset < cols; ++offset) \\n            for (int i = 0, j = offset;  i*cols+j < encodedText.size(); ++i, ++j) \\n                ans.push_back(encodedText[i*cols+j]); \\n        return ans.substr(0, 1+ans.find_last_not_of(\\' \\')); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576961,
                "title": "c-easy-simple-iterate",
                "content": "1) Just create matrix from given encoded text.\\n2) Iterate Diagonally\\n\\nNote : the number of column is **ceil value of (size of given string / given rows)**\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int r) {\\n        int c = s.size()/r + (s.size()%r!=0);\\n        vector<vector<char>>vc(r,vector<char>(c));\\n        int row = -1 , col = -1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(i%c==0)\\n            {\\n                row++;\\n                col=0;\\n            }\\n            vc[row][col++] = s[i];\\n        }\\n        \\n//         for(int i=0;i<r;i++)\\n//         {\\n//             for(int j=0;j<c;j++)\\n//             {\\n//                 cout<<vc[i][j];\\n    \\n//             }\\n//             cout<<endl;\\n//         }\\n        string ans = \"\";\\n        int column=0;\\n        while(column<c)\\n        {\\n            int crRow = 0;\\n            int crCol = column;\\n            while(crRow<r and crCol<c)\\n            {\\n                ans+=vc[crRow++][crCol++];\\n            }\\n            column++;\\n        }\\n        while(ans.back()==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int r) {\\n        int c = s.size()/r + (s.size()%r!=0);\\n        vector<vector<char>>vc(r,vector<char>(c));\\n        int row = -1 , col = -1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(i%c==0)\\n            {\\n                row++;\\n                col=0;\\n            }\\n            vc[row][col++] = s[i];\\n        }\\n        \\n//         for(int i=0;i<r;i++)\\n//         {\\n//             for(int j=0;j<c;j++)\\n//             {\\n//                 cout<<vc[i][j];\\n    \\n//             }\\n//             cout<<endl;\\n//         }\\n        string ans = \"\";\\n        int column=0;\\n        while(column<c)\\n        {\\n            int crRow = 0;\\n            int crCol = column;\\n            while(crRow<r and crCol<c)\\n            {\\n                ans+=vc[crRow++][crCol++];\\n            }\\n            column++;\\n        }\\n        while(ans.back()==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1576940,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        \\n        ans = \"\"\\n        \\n        # Iterate over each index of first row\\n        for i in range(cols):\\n            # Keep adding letters with an interval of (cols+1) (diagonally) till you reach the end of the matrix\\n            for j in range(i, rows*cols, cols+1):\\n                ans += encodedText[j]\\n        \\n        # Remove the trailing spaces\\n        return ans.rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        \\n        ans = \"\"\\n        \\n        # Iterate over each index of first row\\n        for i in range(cols):\\n            # Keep adding letters with an interval of (cols+1) (diagonally) till you reach the end of the matrix\\n            for j in range(i, rows*cols, cols+1):\\n                ans += encodedText[j]\\n        \\n        # Remove the trailing spaces\\n        return ans.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576938,
                "title": "c-straightforward-solution",
                "content": "\\n\\nGet col number with `encodedText.size() / rows` and then re-construct the answer with the rules.\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cols = encodedText.size() / rows;\\n        string ans;\\n        for(int i = 0; i < cols; i++) {\\n            for(int j = 0; j < rows; j++) {\\n                int idx = j * cols + j + i;\\n                if(idx >= encodedText.size()) break;\\n                ans += encodedText[idx];\\n            }\\n        }\\n        while(ans.back() == \\' \\' && ans.size())ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cols = encodedText.size() / rows;\\n        string ans;\\n        for(int i = 0; i < cols; i++) {\\n            for(int j = 0; j < rows; j++) {\\n                int idx = j * cols + j + i;\\n                if(idx >= encodedText.size()) break;\\n                ans += encodedText[idx];\\n            }\\n        }\\n        while(ans.back() == \\' \\' && ans.size())ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576915,
                "title": "java-iterate-diagonally",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String str, int rows) {\\n\\n        //first find column size!!\\n    \\tint cols=str.length()/rows;\\n    \\tStringBuilder res=new StringBuilder(),new_res=new StringBuilder();;\\n    \\tfor(int i=0;i<cols;i++) {\\n        \\n            //iterating diagonally!!\\n            for(int j=i;j<str.length();j+=cols+1)\\n    \\t\\t\\tres.append(str.charAt(j));\\n    \\t}\\n        \\n        //removing last spaces!!!\\n        int fg=0;\\n        for(int i=res.length()-1;i>=0;i--) {\\n            \\n            if(fg==0&&res.charAt(i)==\\' \\')\\n                continue;\\n            fg=1;\\n            new_res.append(res.charAt(i));\\n        }\\n        return new_res.reverse().toString();\\n    }\\n}\\n````",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String str, int rows) {\\n\\n        //first find column size!!\\n    \\tint cols=str.length()/rows;\\n    \\tStringBuilder res=new StringBuilder(),new_res=new StringBuilder();;\\n    \\tfor(int i=0;i<cols;i++) {\\n        \\n            //iterating diagonally!!\\n            for(int j=i;j<str.length();j+=cols+1)\\n    \\t\\t\\tres.append(str.charAt(j));\\n    \\t}\\n        \\n        //removing last spaces!!!\\n        int fg=0;\\n        for(int i=res.length()-1;i>=0;i--) {\\n            \\n            if(fg==0&&res.charAt(i)==\\' \\')\\n                continue;\\n            fg=1;\\n            new_res.append(res.charAt(i));\\n        }\\n        return new_res.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063729,
                "title": "simple-simulation-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        c=ceil(len(encodedText)/rows)\\n        ans=\"\"\\n        for i in range(c):\\n            j=0\\n            while(i+j<len(encodedText)):\\n                ans+=encodedText[i+j]\\n                j+=c+1\\n        i=len(ans)-1\\n        while(i>=0):\\n            if(ans[i]==\\' \\'):\\n                i-=1\\n            else: break\\n\\n        return ans[:i+1]\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        c=ceil(len(encodedText)/rows)\\n        ans=\"\"\\n        for i in range(c):\\n            j=0\\n            while(i+j<len(encodedText)):\\n                ans+=encodedText[i+j]\\n                j+=c+1\\n        i=len(ans)-1\\n        while(i>=0):\\n            if(ans[i]==\\' \\'):\\n                i-=1\\n            else: break\\n\\n        return ans[:i+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872331,
                "title": "step-by-step-beginner-s-friendly-explanation",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$ \\n\\n- Space complexity: $$O(n^2)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n\\n     //step 1 : find no. of columns needed in the matrix\\n     int cols = encodedText.length()/rows;\\n     string ans = \"\"; \\n     int k = 0, i = 0, j = 0, nxtCol = 1;\\n\\n     //step 2 : form the matrix from the given string\\n     vector<vector<char>> grid(rows,vector<char>(cols,\\' \\'));\\n      for(int i=0; i<rows; i++){\\n           for(int j=0; j<cols; j++){\\n                 grid[i][j] = encodedText[k++];\\n           }\\n       }\\n\\n      //step 3 : form the decoded string by traversing the matrix diagonally\\n       k = 0;\\n       while(nxtCol <= cols)\\n       {\\n           if(i >= rows || j >= cols) //always keep i and j as valid index\\n           {\\n               i = 0;\\n               j = nxtCol;\\n               nxtCol++;\\n           }\\n          if(j < cols) ans += grid[i][j];\\n          i++;\\n          j++;\\n       }\\n\\n      //step 4 : remove leading spaces, if any\\n       while(!ans.empty() && ans.back() == \\' \\')\\n        ans.pop_back();\\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n\\n     //step 1 : find no. of columns needed in the matrix\\n     int cols = encodedText.length()/rows;\\n     string ans = \"\"; \\n     int k = 0, i = 0, j = 0, nxtCol = 1;\\n\\n     //step 2 : form the matrix from the given string\\n     vector<vector<char>> grid(rows,vector<char>(cols,\\' \\'));\\n      for(int i=0; i<rows; i++){\\n           for(int j=0; j<cols; j++){\\n                 grid[i][j] = encodedText[k++];\\n           }\\n       }\\n\\n      //step 3 : form the decoded string by traversing the matrix diagonally\\n       k = 0;\\n       while(nxtCol <= cols)\\n       {\\n           if(i >= rows || j >= cols) //always keep i and j as valid index\\n           {\\n               i = 0;\\n               j = nxtCol;\\n               nxtCol++;\\n           }\\n          if(j < cols) ans += grid[i][j];\\n          i++;\\n          j++;\\n       }\\n\\n      //step 4 : remove leading spaces, if any\\n       while(!ans.empty() && ans.back() == \\' \\')\\n        ans.pop_back();\\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584778,
                "title": "just-construct-matrix-and-traverse-diagonally",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n=encodedText.size();\\n        int c=n/rows;\\n        vector<vector<char>>m(rows,vector<char>(c));\\n        int k=0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<c;j++){\\n                m[i][j]=encodedText[k++];\\n            }\\n        }\\n        string ans;\\n        for(int k=0;k<c;k++){\\n                int j=k;\\n                int i=0;\\n                while(i<rows && j<c){\\n                    ans+=m[i][j];\\n                    i++;\\n                    j++;\\n                }\\n            }\\n        bool f=true;\\n        string s;\\n        for(int i=ans.size()-1;i>=0;i--){\\n            if(f && ans[i]==\\' \\'){\\n               \\n            }\\n            else{\\n                f=false;\\n                s+=ans[i];\\n            }\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n=encodedText.size();\\n        int c=n/rows;\\n        vector<vector<char>>m(rows,vector<char>(c));\\n        int k=0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<c;j++){\\n                m[i][j]=encodedText[k++];\\n            }\\n        }\\n        string ans;\\n        for(int k=0;k<c;k++){\\n                int j=k;\\n                int i=0;\\n                while(i<rows && j<c){\\n                    ans+=m[i][j];\\n                    i++;\\n                    j++;\\n                }\\n            }\\n        bool f=true;\\n        string s;\\n        for(int i=ans.size()-1;i>=0;i--){\\n            if(f && ans[i]==\\' \\'){\\n               \\n            }\\n            else{\\n                f=false;\\n                s+=ans[i];\\n            }\\n        }\\n        reverse(s.begin(),s.end());\\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516695,
                "title": "c-easy-solution-simulation-diagonal-traversal",
                "content": "# Intuition\\n**Columns = encodedText.size/rows** . Now make the grid as given in example and do diagonal traversal from every column.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string eT, int rows) {\\n        int n = eT.size();\\n        if(n==0)\\n        return \"\";\\n        int cols = n/rows;\\n        vector<vector<char>> grid(rows,vector<char>(cols));\\n        int ptr = 0;\\n        int col = 0;\\n        int row = 0;\\n        while(ptr<n)\\n        {\\n            grid[row][col] = eT[ptr];\\n            ptr++;\\n            col = (col+1)%cols;\\n            if(col==0)\\n            row++;\\n        }\\n        string ans = \"\";\\n        for(int j=0;j<cols;j++)\\n        {\\n            int c = j;\\n            int r = 0;\\n            while(c<cols && r<rows)\\n            {\\n                ans+=grid[r][c];\\n                c++;\\n                r++;\\n            }\\n        }\\n        while(ans[ans.size()-1]==\\' \\')\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string eT, int rows) {\\n        int n = eT.size();\\n        if(n==0)\\n        return \"\";\\n        int cols = n/rows;\\n        vector<vector<char>> grid(rows,vector<char>(cols));\\n        int ptr = 0;\\n        int col = 0;\\n        int row = 0;\\n        while(ptr<n)\\n        {\\n            grid[row][col] = eT[ptr];\\n            ptr++;\\n            col = (col+1)%cols;\\n            if(col==0)\\n            row++;\\n        }\\n        string ans = \"\";\\n        for(int j=0;j<cols;j++)\\n        {\\n            int c = j;\\n            int r = 0;\\n            while(c<cols && r<rows)\\n            {\\n                ans+=grid[r][c];\\n                c++;\\n                r++;\\n            }\\n        }\\n        while(ans[ans.size()-1]==\\' \\')\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470468,
                "title": "simulation-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) \\n    {\\n        if(rows==1) return encodedText;\\n        int cols=encodedText.size()/rows;\\n        vector<vector<char>> v(rows, vector<char> (cols,\\' \\'));\\n        int i=0, done=0;\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                v[x][y]=encodedText[i++];\\n                if(i==encodedText.size()) \\n                {\\n                    done=1;\\n                    break;\\n                }\\n            }\\n            if(done) break;\\n        }\\n        string ans=\"\";\\n        int r=0, c=0, col=0;\\n        while(col<cols)\\n        {\\n            ans+=v[r][c];\\n            r++, c++;\\n            if(r==rows || c==cols)\\n            {\\n                r=0; col++;\\n                c=col;\\n            }\\n        }\\n        int j=ans.size()-1;\\n        while(j>=0 && ans[j]==\\' \\') j--;\\n        ans=ans.substr(0,j+1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) \\n    {\\n        if(rows==1) return encodedText;\\n        int cols=encodedText.size()/rows;\\n        vector<vector<char>> v(rows, vector<char> (cols,\\' \\'));\\n        int i=0, done=0;\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                v[x][y]=encodedText[i++];\\n                if(i==encodedText.size()) \\n                {\\n                    done=1;\\n                    break;\\n                }\\n            }\\n            if(done) break;\\n        }\\n        string ans=\"\";\\n        int r=0, c=0, col=0;\\n        while(col<cols)\\n        {\\n            ans+=v[r][c];\\n            r++, c++;\\n            if(r==rows || c==cols)\\n            {\\n                r=0; col++;\\n                c=col;\\n            }\\n        }\\n        int j=ans.size()-1;\\n        while(j>=0 && ans[j]==\\' \\') j--;\\n        ans=ans.substr(0,j+1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416162,
                "title": "c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        string ans = \"\";\\n        for(int i = 0; i < cols; i++) {\\n            for(int j = i; j < n; j += cols + 1) {\\n                ans += encodedText[j];\\n            }\\n        }\\n        while(ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        string ans = \"\";\\n        for(int i = 0; i < cols; i++) {\\n            for(int j = i; j < n; j += cols + 1) {\\n                ans += encodedText[j];\\n            }\\n        }\\n        while(ans.back() == \\' \\') ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382410,
                "title": "python-solution-with-explanation",
                "content": "### simulation\\n\\n```python\\n\\'\\'\\'\\ntraverse string diagonally, \\nif the index of row or columns is out of bound,\\nback to the fisrt row.\\ntc is O(n), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1: return encodedText\\n        numCol = len(encodedText) // rows\\n        ans = []  \\n        mapping = lambda r, c: numCol * r + c\\n        for curCol in range(numCol):\\n            r, c = 0, curCol\\n            while mapping(r, c) < rows * numCol:\\n                ans.append(encodedText[mapping(r, c)])\\n                r += 1\\n                c += 1\\n        return \\'\\'.join(ans).rstrip()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\\'\\'\\'\\ntraverse string diagonally, \\nif the index of row or columns is out of bound,\\nback to the fisrt row.\\ntc is O(n), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1: return encodedText\\n        numCol = len(encodedText) // rows\\n        ans = []  \\n        mapping = lambda r, c: numCol * r + c\\n        for curCol in range(numCol):\\n            r, c = 0, curCol\\n            while mapping(r, c) < rows * numCol:\\n                ans.append(encodedText[mapping(r, c)])\\n                r += 1\\n                c += 1\\n        return \\'\\'.join(ans).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365847,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size() ;\\n        int cols = n/rows ;\\n        vector<vector<char>>mat(rows, vector<char>(cols)) ;\\n        for(int i = 0; i < n; i++){\\n            mat[i/cols][i%cols] = encodedText[i] ;\\n        }\\n        string ret ;\\n        for(int i = 0; i < cols; i++){\\n            int r = 0, c = i ;\\n            while(r < rows && c < cols){\\n                ret.push_back(mat[r][c] ) ;\\n                r++ ;\\n                c++ ;\\n            }\\n        }\\n        while(ret.size() && ret.back() == \\' \\')\\n            ret.pop_back() ;\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size() ;\\n        int cols = n/rows ;\\n        vector<vector<char>>mat(rows, vector<char>(cols)) ;\\n        for(int i = 0; i < n; i++){\\n            mat[i/cols][i%cols] = encodedText[i] ;\\n        }\\n        string ret ;\\n        for(int i = 0; i < cols; i++){\\n            int r = 0, c = i ;\\n            while(r < rows && c < cols){\\n                ret.push_back(mat[r][c] ) ;\\n                r++ ;\\n                c++ ;\\n            }\\n        }\\n        while(ret.size() && ret.back() == \\' \\')\\n            ret.pop_back() ;\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325766,
                "title": "c-stright-forward",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string et, int rows) {\\n        cout << et.size() << \" \" << rows;\\n        string res = \"\";\\n        int col = et.size() / rows;\\n        int idx = 0;\\n        string space = \"\";\\n        // cout << col << \" \" << rows << \" \";\\n        while(idx < col - rows + 2) {\\n            for(int i = 0; i < rows && idx + i + i * col < et.size(); i++) {\\n                if(et[idx + i + i * col] == \\' \\')\\n                    space += \\' \\';\\n                else {\\n                    res += (space + et[idx + i + i * col]);                    \\n                    space = \"\";\\n                }\\n\\n            }\\n            idx++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string et, int rows) {\\n        cout << et.size() << \" \" << rows;\\n        string res = \"\";\\n        int col = et.size() / rows;\\n        int idx = 0;\\n        string space = \"\";\\n        // cout << col << \" \" << rows << \" \";\\n        while(idx < col - rows + 2) {\\n            for(int i = 0; i < rows && idx + i + i * col < et.size(); i++) {\\n                if(et[idx + i + i * col] == \\' \\')\\n                    space += \\' \\';\\n                else {\\n                    res += (space + et[idx + i + i * col]);                    \\n                    space = \"\";\\n                }\\n\\n            }\\n            idx++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3324281,
                "title": "2-solutions-beginner-friendly-c",
                "content": "***Please do upvote \\u2B06\\uFE0F my solution to keep me motivated :)***\\n***Doubts?? I am super active at the comments section. \\uD83D\\uDE00***\\n\\n\\n\\n## Brute Force \\n**Tc - O(m*n)**\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n/rows;\\n        vector<vector<char>> mat(rows,vector<char>(cols,\\' \\'));\\n        int i=0;\\n        for(int r=0;r<rows;r++) {\\n            for(int c=0;c<cols;c++) {\\n                if(i<n) {\\n                    mat[r][c] = encodedText[i++];\\n                }\\n            }\\n        }\\n\\n        for(int r=0;r<rows;r++) {\\n            for(int c=0;c<cols;c++) {\\n                cout<<mat[r][c]<<\" \";\\n            }\\n            cout<<endl;\\n        }\\n\\n        string originalText = \"\";\\n        int r=0;\\n        for(int c=0;c<cols;c++) {\\n            int tc = c;\\n                while(r!=rows && tc!=cols) {\\n                originalText += mat[r][tc];\\n                r++;\\n                tc++;\\n            }\\n            r = 0;\\n        }\\n        while(originalText.back()==\\' \\') {\\n            originalText.pop_back();\\n        }\\n        return originalText;\\n    }\\n};\\n``` \\n## Optimised Solution\\n**Tc - O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n/rows;\\n        string originalText = \"\";\\n        for(int i=0;i<cols;i++) {\\n            for(int j=i;j<n;j+=cols+1) {\\n                originalText += encodedText[j];\\n            }\\n        }\\n\\n        while(originalText.back()==\\' \\') {\\n            originalText.pop_back();\\n        }\\n        return originalText;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n/rows;\\n        vector<vector<char>> mat(rows,vector<char>(cols,\\' \\'));\\n        int i=0;\\n        for(int r=0;r<rows;r++) {\\n            for(int c=0;c<cols;c++) {\\n                if(i<n) {\\n                    mat[r][c] = encodedText[i++];\\n                }\\n            }\\n        }\\n\\n        for(int r=0;r<rows;r++) {\\n            for(int c=0;c<cols;c++) {\\n                cout<<mat[r][c]<<\" \";\\n            }\\n            cout<<endl;\\n        }\\n\\n        string originalText = \"\";\\n        int r=0;\\n        for(int c=0;c<cols;c++) {\\n            int tc = c;\\n                while(r!=rows && tc!=cols) {\\n                originalText += mat[r][tc];\\n                r++;\\n                tc++;\\n            }\\n            r = 0;\\n        }\\n        while(originalText.back()==\\' \\') {\\n            originalText.pop_back();\\n        }\\n        return originalText;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n/rows;\\n        string originalText = \"\";\\n        for(int i=0;i<cols;i++) {\\n            for(int j=i;j<n;j+=cols+1) {\\n                originalText += encodedText[j];\\n            }\\n        }\\n\\n        while(originalText.back()==\\' \\') {\\n            originalText.pop_back();\\n        }\\n        return originalText;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3269614,
                "title": "easy-c-solution-string-and-index-manipulation",
                "content": "```\\n    string decodeCiphertext(string text, int rows) {\\n        \\n        string ans = \"\";\\n        int n = text.size();\\n        int fac = n/rows;\\n        \\n        for(int i = 0;i<fac;i++){\\n            int temp = i;\\n            while(temp<n){\\n                ans+=text[temp];\\n                temp+=(fac+1);\\n            }\\n        }\\n        \\n        while(!ans.empty() and ans.back()==\\' \\'){\\n            ans.pop_back();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n    string decodeCiphertext(string text, int rows) {\\n        \\n        string ans = \"\";\\n        int n = text.size();\\n        int fac = n/rows;\\n        \\n        for(int i = 0;i<fac;i++){\\n            int temp = i;\\n            while(temp<n){\\n                ans+=text[temp];\\n                temp+=(fac+1);\\n            }\\n        }\\n        \\n        while(!ans.empty() and ans.back()==\\' \\'){\\n            ans.pop_back();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3260455,
                "title": "javascript-100-runtime",
                "content": "```\\nconst decodeCiphertext = (text, rows) => {\\n  if (rows == 1 || text.length < rows) return text;\\n\\n  const reg = new RegExp(`.{1,${text.length / rows}}`, \"g\");\\n  rows = text.match(reg);\\n\\n  let res = \"\";\\n  for (let i = 0; i < rows[0].length; i++) {\\n    for (let j = 0, k = i; j < rows.length; j++, k++) {\\n      if (k > rows[0].length - 1) return res.replace(/\\\\s+$/, \"\");\\n      res += rows[j][k];\\n    }\\n  }\\n\\n  return res.replace(/\\\\s+$/, \"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst decodeCiphertext = (text, rows) => {\\n  if (rows == 1 || text.length < rows) return text;\\n\\n  const reg = new RegExp(`.{1,${text.length / rows}}`, \"g\");\\n  rows = text.match(reg);\\n\\n  let res = \"\";\\n  for (let i = 0; i < rows[0].length; i++) {\\n    for (let j = 0, k = i; j < rows.length; j++, k++) {\\n      if (k > rows[0].length - 1) return res.replace(/\\\\s+$/, \"\");\\n      res += rows[j][k];\\n    }\\n  }\\n\\n  return res.replace(/\\\\s+$/, \"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3199343,
                "title": "python-solution",
                "content": "```\\ndef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        str_len = len(encodedText)\\n        print(str_len)\\n        m = rows\\n        n = str_len // m\\n        def read(i, remain, arr):\\n            if remain > 0:\\n                print(encodedText[i])\\n                arr.append(encodedText[i])\\n                next_i = i + n + 1\\n                read(next_i, remain - 1, arr)\\n        remain = m\\n        res_arr = []\\n        for i in range(n):\\n            if i <= n - m:\\n                read(i, remain, res_arr)\\n            else:\\n                new_remain = n - i\\n                read(i, new_remain, res_arr)\\n        res_str1 = \"\".join(res_arr)\\n        res_str2 = res_str1.rstrip()\\n        return res_str2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        str_len = len(encodedText)\\n        print(str_len)\\n        m = rows\\n        n = str_len // m\\n        def read(i, remain, arr):\\n            if remain > 0:\\n                print(encodedText[i])\\n                arr.append(encodedText[i])\\n                next_i = i + n + 1\\n                read(next_i, remain - 1, arr)\\n        remain = m\\n        res_arr = []\\n        for i in range(n):\\n            if i <= n - m:\\n                read(i, remain, res_arr)\\n            else:\\n                new_remain = n - i\\n                read(i, new_remain, res_arr)\\n        res_str1 = \"\".join(res_arr)\\n        res_str2 = res_str1.rstrip()\\n        return res_str2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3196538,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def decodeCiphertext(encodedText: String, rows: Int): String = {\\n        if(encodedText.length < 1) return encodedText\\n        val rowlength = encodedText.length / rows\\n        val ts = encodedText.sliding(rowlength, rowlength)\\n        val res = (0 until rows).foldLeft(new Array[String](rows))((ans, i) =>{\\n            val t = ts.next()\\n            ans(i) = t.drop(i) + (\" \" * rows)\\n            ans\\n        })\\n        (for{j<- 0 until rowlength\\n            i <- 0 until rows} yield res(i)(j)).mkString.reverse.dropWhile(_ == \\' \\').reverse\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def decodeCiphertext(encodedText: String, rows: Int): String = {\\n        if(encodedText.length < 1) return encodedText\\n        val rowlength = encodedText.length / rows\\n        val ts = encodedText.sliding(rowlength, rowlength)\\n        val res = (0 until rows).foldLeft(new Array[String](rows))((ans, i) =>{\\n            val t = ts.next()\\n            ans(i) = t.drop(i) + (\" \" * rows)\\n            ans\\n        })\\n        (for{j<- 0 until rowlength\\n            i <- 0 until rows} yield res(i)(j)).mkString.reverse.dropWhile(_ == \\' \\').reverse\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3186887,
                "title": "beats-100-runtime-memory-typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first if statement checks if the encodedText is empty and returns an empty string if it is.\\n\\nNext, charIdx and nextColumnIdx are initialized to 0 and 1 respectively. The charIdx variable represents the index of the character in the encoded text that we are currently processing. The nextColumnIdx variable is used to keep track of the next column index when we have finished decoding the current column.\\n\\nThe number of columns is calculated based on the encoded text\\'s length and the number of rows used for encoding. If the length of the encoded text is not a multiple of the number of rows, the function returns the original encoded text.\\n\\nA result variable is initialized as an empty string, which will hold the decoded text.\\n\\nThe while loop decodes the text one character at a time, starting from the first character in the first row. We add the current character to the result string and then move to the next character in the same column by adding the number of columns to the current index and moving to the next row.\\n\\nIf we have reached the last column, we break out of the loop as we have finished decoding the text. If we have not reached the last column, we continue decoding by moving to the next column.\\n\\nIf we have reached the end of the rows, we move to the next column and start decoding from the first row of the next column.\\n\\nFinally, we return the result string with any trailing spaces removed.\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    if (encodedText.length == 0) return \"\"\\n    let charIdx: number = 0;\\n    let nextColumnIdx: number = 1\\n    const columns = encodedText.length / rows\\n    if (encodedText.length !== rows * columns)\\n        return encodedText\\n    let result: string = \"\"\\n    while (true) {\\n        result += encodedText[charIdx]\\n        // break when reached last column\\n        if (charIdx === columns - 1) break;\\n        // move one row below, one column right\\n        charIdx = charIdx + columns + 1;\\n        // move up to first row if passed the row limit\\n        if (charIdx > columns * rows - 1) {\\n            charIdx = nextColumnIdx\\n            nextColumnIdx++\\n        }\\n    }\\n    return result.trimEnd()\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    if (encodedText.length == 0) return \"\"\\n    let charIdx: number = 0;\\n    let nextColumnIdx: number = 1\\n    const columns = encodedText.length / rows\\n    if (encodedText.length !== rows * columns)\\n        return encodedText\\n    let result: string = \"\"\\n    while (true) {\\n        result += encodedText[charIdx]\\n        // break when reached last column\\n        if (charIdx === columns - 1) break;\\n        // move one row below, one column right\\n        charIdx = charIdx + columns + 1;\\n        // move up to first row if passed the row limit\\n        if (charIdx > columns * rows - 1) {\\n            charIdx = nextColumnIdx\\n            nextColumnIdx++\\n        }\\n    }\\n    return result.trimEnd()\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3181434,
                "title": "c-easy-undestanding-one-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) {\\n        int n=s.size(),k=0;\\n        vector<string>v(rows);\\n        for(int i=0;i<rows;i++)\\n            for(int j=0;j<n/rows;j++)\\n                v[i].push_back(s[k++]);\\n        s=\"\";\\n        for(int k=0;k<n/rows;k++)\\n            for(int i=0,j=k;i<rows && j<n/rows;i++,j++)\\n                    s+=v[i][j];\\n        n=s.size()-1;\\n        while(n>=0 && s[n]==\\' \\')\\n            n--;\\n        return s.substr(0,n+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) {\\n        int n=s.size(),k=0;\\n        vector<string>v(rows);\\n        for(int i=0;i<rows;i++)\\n            for(int j=0;j<n/rows;j++)\\n                v[i].push_back(s[k++]);\\n        s=\"\";\\n        for(int k=0;k<n/rows;k++)\\n            for(int i=0,j=k;i<rows && j<n/rows;i++,j++)\\n                    s+=v[i][j];\\n        n=s.size()-1;\\n        while(n>=0 && s[n]==\\' \\')\\n            n--;\\n        return s.substr(0,n+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086658,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string str, int rows) {\\n        int l = str.size();\\n        int m = l / rows;\\n        \\n        string ans;\\n        for(int i = 0; i < m; i++) {\\n            int j = i;\\n            while(j < l) {\\n                ans += str[j];\\n                j += m + 1;\\n            }\\n        }\\n\\n        for(int i = ans.size() - 1; i >= 0 and ans[i] == \\' \\'; i--)\\n            ans.pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string str, int rows) {\\n        int l = str.size();\\n        int m = l / rows;\\n        \\n        string ans;\\n        for(int i = 0; i < m; i++) {\\n            int j = i;\\n            while(j < l) {\\n                ans += str[j];\\n                j += m + 1;\\n            }\\n        }\\n\\n        for(int i = ans.size() - 1; i >= 0 and ans[i] == \\' \\'; i--)\\n            ans.pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085408,
                "title": "c-simple-solution-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string enctext, int rows) {\\n        if(rows==1) return enctext;\\n        int len = enctext.length();\\n        int col = len/rows;\\n        string ans;\\n        int count = 0;\\n        for(char c : enctext) if(c!=\\' \\') count++;\\n        for(int i=0;i<len;i++){\\n            int j = i;\\n            while(j<len){\\n                if(count==0) break;\\n                if(enctext[j]!=\\' \\') count--;\\n                ans+=enctext[j];\\n                j+=col+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string enctext, int rows) {\\n        if(rows==1) return enctext;\\n        int len = enctext.length();\\n        int col = len/rows;\\n        string ans;\\n        int count = 0;\\n        for(char c : enctext) if(c!=\\' \\') count++;\\n        for(int i=0;i<len;i++){\\n            int j = i;\\n            while(j<len){\\n                if(count==0) break;\\n                if(enctext[j]!=\\' \\') count--;\\n                ans+=enctext[j];\\n                j+=col+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072911,
                "title": "python-simulation-simple-solution-o-mn",
                "content": "# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        matrix = [[0]*cols for _ in range(rows)]\\n        for i in range(rows):\\n            for j in range(cols):\\n                matrix[i][j] = encodedText[i*cols + j]\\n        i,j = 0,0\\n        res = []\\n        while 0<=i<rows and 0<=j<cols:\\n            res.append(matrix[i][j])\\n            i = (i+1)%rows\\n            j += 1\\n            j = j-(rows-1)*(i==0)\\n        return \"\".join(res).rstrip()\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        matrix = [[0]*cols for _ in range(rows)]\\n        for i in range(rows):\\n            for j in range(cols):\\n                matrix[i][j] = encodedText[i*cols + j]\\n        i,j = 0,0\\n        res = []\\n        while 0<=i<rows and 0<=j<cols:\\n            res.append(matrix[i][j])\\n            i = (i+1)%rows\\n            j += 1\\n            j = j-(rows-1)*(i==0)\\n        return \"\".join(res).rstrip()\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047748,
                "title": "simple-java-o-n-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int count = 0;\\n        for (char c : encodedText.toCharArray()) if (c != \\' \\') count++;\\n        int col = encodedText.length() / rows;\\n        StringBuilder sb = new StringBuilder();\\n        int r = 0, c = 0;\\n        while (count > 0) {\\n            int index = col * r + c;\\n            if (encodedText.charAt(index) != \\' \\') count--;\\n            sb.append(encodedText.charAt(index));\\n            r++;\\n            c++;\\n            if (r == rows) {\\n                r = 0;\\n                c -= rows - 1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int count = 0;\\n        for (char c : encodedText.toCharArray()) if (c != \\' \\') count++;\\n        int col = encodedText.length() / rows;\\n        StringBuilder sb = new StringBuilder();\\n        int r = 0, c = 0;\\n        while (count > 0) {\\n            int index = col * r + c;\\n            if (encodedText.charAt(index) != \\' \\') count--;\\n            sb.append(encodedText.charAt(index));\\n            r++;\\n            c++;\\n            if (r == rows) {\\n                r = 0;\\n                c -= rows - 1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989033,
                "title": "rust-translating-x-y-coors-to-a-1d-index",
                "content": "# Intuition and Approach\\nThis is a fairly simple diagonal traversal solution. The examples paint things pretty clearly such that we may just follow the arrows to a satisfactory solution. Basically we want a simple loop over a 2 dimensional cipher like this:\\n\\n`cipher[j][i+j] for i in 0..columns for j in 0..rows if i + j < columns`\\n\\nInstead of building the cipher as a matrix, we may index into our string directly by simply translating matrix indices to an integer. This is a straight forward translation:\\n\\n```\\n[y][x] == num_columns * y + x \\n# or in a more complete, algorithmic form\\n[encoded_text[j * columns + j + i] for i in range(columns) for j in range(rows) if i + j < columns]\\n```\\n\\n# Complexity\\n- Time complexity:\\n`O(n)`\\n\\n- Space complexity:\\n`O(n)`\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn decode_ciphertext(encoded_text: String, rows: i32) -> String {\\n        let len = encoded_text.len() / (rows as usize);\\n        let encoded_text = encoded_text.chars().collect::<Vec<char>>();\\n        let mut output = String::from(\"\");\\n        for i in 0..len {\\n            let mut x = i;\\n            let mut y = 0;\\n            while y < rows as usize && x < len {\\n                output.push(encoded_text[len * y + x]);\\n                y += 1;\\n                x += 1;\\n            }\\n        }\\n\\n        String::from(output.trim_end())\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n[y][x] == num_columns * y + x \\n# or in a more complete, algorithmic form\\n[encoded_text[j * columns + j + i] for i in range(columns) for j in range(rows) if i + j < columns]\\n```\n```\\nimpl Solution {\\n    pub fn decode_ciphertext(encoded_text: String, rows: i32) -> String {\\n        let len = encoded_text.len() / (rows as usize);\\n        let encoded_text = encoded_text.chars().collect::<Vec<char>>();\\n        let mut output = String::from(\"\");\\n        for i in 0..len {\\n            let mut x = i;\\n            let mut y = 0;\\n            while y < rows as usize && x < len {\\n                output.push(encoded_text[len * y + x]);\\n                y += 1;\\n                x += 1;\\n            }\\n        }\\n\\n        String::from(output.trim_end())\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2980186,
                "title": "c-o-1-space-o-endodedstring-size-time-optimized-explained",
                "content": "# Intuition\\nMy main objective was not to construct the matrix, for that i tried to somehow map the useful indexes of the matrix to the ```endodedString``` index\\n\\n# Approach\\nEverytime we move one row down in the matrix we leave ```cols``` number of characters behind, I used to the same to comeup with the solution.\\n\\n# Complexity\\n- Time complexity: O(```embededText.size()```)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) , if we do not consider the output, else O(```outputLength```)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cur=0,n=encodedText.size(),cols=n/rows;\\n\\n        string res=\"\";\\n        for(int j=0;j<cols;j++){\\n            int x=0,y=j;\\n            while(x<rows && y<cols){\\n                res+=encodedText[(x*cols)+y];\\n                x++,y++;\\n            }\\n        }\\n\\n        int idx=-1;\\n        for(int i=0;i<res.size();i++){\\n            if(res[i]!=\\' \\'){\\n                idx=i;\\n            }\\n        }\\n\\n        return res.substr(0,idx+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```endodedString```\n```cols```\n```embededText.size()```\n```outputLength```\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int cur=0,n=encodedText.size(),cols=n/rows;\\n\\n        string res=\"\";\\n        for(int j=0;j<cols;j++){\\n            int x=0,y=j;\\n            while(x<rows && y<cols){\\n                res+=encodedText[(x*cols)+y];\\n                x++,y++;\\n            }\\n        }\\n\\n        int idx=-1;\\n        for(int i=0;i<res.size();i++){\\n            if(res[i]!=\\' \\'){\\n                idx=i;\\n            }\\n        }\\n\\n        return res.substr(0,idx+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894756,
                "title": "beginner-friendly-python-easy-to-understand-and-fast-approach",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        arr = [[\\'\\' for i in range(cols)] for j in range(rows)]\\n        ith = 0\\n        for i in range(rows):\\n            for j in range(cols):\\n                arr[i][j] = encodedText[ith]\\n                ith += 1\\n        wrapup = \\'\\'\\n        for i in range(cols):\\n            cntr = i\\n            for j in range(rows):\\n                try:\\n                    wrapup += arr[j][cntr]\\n                except:\\n                    return wrapup.rstrip()\\n                cntr += 1\\n        return wrapup.rstrip()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        arr = [[\\'\\' for i in range(cols)] for j in range(rows)]\\n        ith = 0\\n        for i in range(rows):\\n            for j in range(cols):\\n                arr[i][j] = encodedText[ith]\\n                ith += 1\\n        wrapup = \\'\\'\\n        for i in range(cols):\\n            cntr = i\\n            for j in range(rows):\\n                try:\\n                    wrapup += arr[j][cntr]\\n                except:\\n                    return wrapup.rstrip()\\n                cntr += 1\\n        return wrapup.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883787,
                "title": "python3-one-liner-explained-with-extended-version",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne liners are not really readable which is bad, but using list comprehensions/generators in python is likely to be quicker than extended loop.\\n\\nBelow you can find three versions, which gradually become more complex and shorter. The last version calls the join operator immediately over the generator of characters which might be the fastest and most efficient regarding memory.\\n\\nBUT: It is utterly unreadable and Python is not exactly the right language to worry about memory efficiency. I just wanted to share my approach, maybe it helps somebody.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe start at a column (outer loop) of the first row and then traverse diagonal downwards (step: column + 1 for diagonal).\\n\\nThis gives us the characters in the right order.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO((N*M)/2) where N is the amount of rows and M is the amount of columns.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) if we omit solution space in the last function.\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext_extended(self, encodedText: str, rows: int) -> str:\\n        column = len(encodedText)//rows\\n        solution = []\\n        for cx in range(column):\\n            for strx in range(cx, len(encodedText), len(encodedText)//rows+1):\\n                solution.append(encodedText[strx])\\n        return \"\".join(solution).rstrip()\\n    \\n    def decodeCiphertext_mixed(self, encodedText: str, rows: int) -> str:\\n        text = [encodedText[strx] for cx in range(len(encodedText)//rows+1) for strx in range(cx, len(encodedText), len(encodedText)//rows+1)]\\n        return \"\".join(text).rstrip()\\n    \\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        return \"\".join(encodedText[strx] for cx in range(len(encodedText)//rows+1) for strx in range(cx, len(encodedText), len(encodedText)//rows+1)).rstrip()\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext_extended(self, encodedText: str, rows: int) -> str:\\n        column = len(encodedText)//rows\\n        solution = []\\n        for cx in range(column):\\n            for strx in range(cx, len(encodedText), len(encodedText)//rows+1):\\n                solution.append(encodedText[strx])\\n        return \"\".join(solution).rstrip()\\n    \\n    def decodeCiphertext_mixed(self, encodedText: str, rows: int) -> str:\\n        text = [encodedText[strx] for cx in range(len(encodedText)//rows+1) for strx in range(cx, len(encodedText), len(encodedText)//rows+1)]\\n        return \"\".join(text).rstrip()\\n    \\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        return \"\".join(encodedText[strx] for cx in range(len(encodedText)//rows+1) for strx in range(cx, len(encodedText), len(encodedText)//rows+1)).rstrip()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849828,
                "title": "python-simple-iterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        \\n        res = \"\"\\n        \\n        for i in range(cols):\\n            idx = i\\n            for j in range(rows):\\n                if idx >= len(encodedText):\\n                    break\\n                    \\n                res += encodedText[idx]\\n                idx += (cols+1)\\n                \\n        i = len(res)-1       \\n        while i >= 0:\\n            if res[i] !=  \" \":\\n                break\\n            i -= 1\\n                \\n        return res[:i+1]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        \\n        res = \"\"\\n        \\n        for i in range(cols):\\n            idx = i\\n            for j in range(rows):\\n                if idx >= len(encodedText):\\n                    break\\n                    \\n                res += encodedText[idx]\\n                idx += (cols+1)\\n                \\n        i = len(res)-1       \\n        while i >= 0:\\n            if res[i] !=  \" \":\\n                break\\n            i -= 1\\n                \\n        return res[:i+1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838084,
                "title": "rust",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn decode_ciphertext(encoded_text: String, rows: i32) -> String {\\n        if rows == 1 {\\n            return encoded_text;\\n        }\\n        let col_count = encoded_text.len() as i32 / rows;\\n        let mut new_vec = vec![vec![]; rows as usize];\\n        let mut res: Vec<char> = Vec::new();\\n        let _ =\\n            encoded_text\\n                .chars()\\n                .into_iter()\\n                .fold((0, 0), |(mut tmp_row, mut tmp_col), item| {\\n                    if tmp_col >= col_count {\\n                        tmp_col = 0;\\n                        tmp_row += 1;\\n                    }\\n                    new_vec[tmp_row].push(item);\\n                    tmp_col += 1;\\n\\n                    (tmp_row, tmp_col)\\n                });\\n\\n        for i in 0..col_count {\\n            for (j, _) in new_vec.iter().enumerate().take(rows as usize) {\\n                let y = i as i32 + j as i32;\\n                if y >= col_count {\\n                    break;\\n                }\\n                res.push(new_vec[j][y as usize]);\\n            }\\n        }\\n\\n        res.iter().collect::<String>().trim_end().to_owned()\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn decode_ciphertext(encoded_text: String, rows: i32) -> String {\\n        if rows == 1 {\\n            return encoded_text;\\n        }\\n        let col_count = encoded_text.len() as i32 / rows;\\n        let mut new_vec = vec![vec![]; rows as usize];\\n        let mut res: Vec<char> = Vec::new();\\n        let _ =\\n            encoded_text\\n                .chars()\\n                .into_iter()\\n                .fold((0, 0), |(mut tmp_row, mut tmp_col), item| {\\n                    if tmp_col >= col_count {\\n                        tmp_col = 0;\\n                        tmp_row += 1;\\n                    }\\n                    new_vec[tmp_row].push(item);\\n                    tmp_col += 1;\\n\\n                    (tmp_row, tmp_col)\\n                });\\n\\n        for i in 0..col_count {\\n            for (j, _) in new_vec.iter().enumerate().take(rows as usize) {\\n                let y = i as i32 + j as i32;\\n                if y >= col_count {\\n                    break;\\n                }\\n                res.push(new_vec[j][y as usize]);\\n            }\\n        }\\n\\n        res.iter().collect::<String>().trim_end().to_owned()\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2803981,
                "title": "decode-the-slanted-ciphertext-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string text, int r) {\\n        int c=text.length()/r;\\n        \\n        vector<vector<char>> grid(r, vector<char>(c, \\' \\'));\\n        \\n        int i=0, j=0;\\n        for(int k=0; k<text.length(); k++){\\n            grid[i][j++]=text[k];\\n            if((k+1)%c==0){\\n                i++;\\n                j=0;\\n            }            \\n        }\\n        \\n        int x=0;\\n        i=0; j=x;\\n        string ans=\"\";\\n        \\n        while(i<r && j<c){\\n            ans+=grid[i++][j++];\\n            if(i==r || j==c){\\n                i=0;\\n                j=++x;\\n            }\\n        }\\n        \\n        while(ans.back()==\\' \\') ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string text, int r) {\\n        int c=text.length()/r;\\n        \\n        vector<vector<char>> grid(r, vector<char>(c, \\' \\'));\\n        \\n        int i=0, j=0;\\n        for(int k=0; k<text.length(); k++){\\n            grid[i][j++]=text[k];\\n            if((k+1)%c==0){\\n                i++;\\n                j=0;\\n            }            \\n        }\\n        \\n        int x=0;\\n        i=0; j=x;\\n        string ans=\"\";\\n        \\n        while(i<r && j<c){\\n            ans+=grid[i++][j++];\\n            if(i==r || j==c){\\n                i=0;\\n                j=++x;\\n            }\\n        }\\n        \\n        while(ans.back()==\\' \\') ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724208,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   string decodeCiphertext(string e, int rows) {\\n\\t\\tint size=e.size();\\n\\t\\tint col=size/rows;\\n\\t\\tstring ans;\\n\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (isspace(ans.back()))\\n\\t\\t{\\n\\t\\t\\tans.pop_back();\\n\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string decodeCiphertext(string e, int rows) {\\n\\t\\tint size=e.size();\\n\\t\\tint col=size/rows;\\n\\t\\tstring ans;\\n\\t\\tfor(int i=0;i<col;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i;j<size;j+=col+1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans+=e[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (isspace(ans.back()))\\n\\t\\t{\\n\\t\\t\\tans.pop_back();\\n\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721989,
                "title": "c-sol-run-97-mem-96-simple-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int find_next(int &r,int &c,int rows,int cols) { // Function to find and set next r and c in matrix\\n        if(r!=rows-1) { // If not last row, traverse diagonally\\n            r++;c++;\\n        }\\n        else { // If last row reset to top row of matrix and set column respectively\\n            r=0;c=c-(rows-2); \\n        }\\n        return r*cols+c; // Finding index in the given string\\n    }\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int r=0,c=0,index=0;\\n        string ans=\"\";\\n        int cols=encodedText.length()/rows;\\n        while(index<encodedText.length()) {\\n            ans+=encodedText[index];\\n            index=find_next(r,c,rows,cols);\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back(); // Removing trailing spaces in the answer\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_next(int &r,int &c,int rows,int cols) { // Function to find and set next r and c in matrix\\n        if(r!=rows-1) { // If not last row, traverse diagonally\\n            r++;c++;\\n        }\\n        else { // If last row reset to top row of matrix and set column respectively\\n            r=0;c=c-(rows-2); \\n        }\\n        return r*cols+c; // Finding index in the given string\\n    }\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int r=0,c=0,index=0;\\n        string ans=\"\";\\n        int cols=encodedText.length()/rows;\\n        while(index<encodedText.length()) {\\n            ans+=encodedText[index];\\n            index=find_next(r,c,rows,cols);\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back(); // Removing trailing spaces in the answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721766,
                "title": "python-solution-matrix",
                "content": "# Algorithm\\nThe solution makes use of a matrix. From the problem statement we are given the following:\\n1. encodedText\\n2. Number of rows\\n\\nFrom the above, we can calculate the number of columns.\\n**Number of columns (cols) = length of the text / number of rows**\\n\\nSteps for matrix creation:\\n1. Create an **index** to iterate over the encodedText, **row** and **col** to iterate through the matrix.\\n2. For each cell in the matrix insert the character from the text\\n\\n# Example\\nMatrix created from \\nencodedText = \"ch   ie   pr\" => ***(length = 12)***\\nrows = 3\\ncols = 4  => ***(12 / 3)***\\n\\n[[\\'c\\', \\'h\\', \\' \\', \\' \\'], \\n [\\' \\', \\'i\\', \\'e\\', \\' \\'], \\n [\\' \\', \\' \\', \\'p\\', \\'r\\']]\\n \\n Iterate though the cols. For each column increment though the row.\\n \\n#  Code\\n```\\n\\t\\tmatrix = []\\n        cols = len(encodedText) // rows\\n        index = 0\\n        for row in range(rows):\\n            temp = []\\n            for col in range(cols):\\n                char = encodedText[index]\\n                temp.append(char)\\n                index += 1\\n            matrix.append(temp)\\n        result = \"\"\\n        \\n        col = 0 # Keeping track of the start after completion of the inner for loop\\n        for _ in range(cols):\\n            r_index, c_index = 0, _\\n            while r_index < rows and c_index < cols:\\n                result += matrix[r_index][c_index]\\n                r_index += 1\\n                c_index += 1\\n            col += 1\\n        return result.rstrip()\\n```",
                "solutionTags": [
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\n\\t\\tmatrix = []\\n        cols = len(encodedText) // rows\\n        index = 0\\n        for row in range(rows):\\n            temp = []\\n            for col in range(cols):\\n                char = encodedText[index]\\n                temp.append(char)\\n                index += 1\\n            matrix.append(temp)\\n        result = \"\"\\n        \\n        col = 0 # Keeping track of the start after completion of the inner for loop\\n        for _ in range(cols):\\n            r_index, c_index = 0, _\\n            while r_index < rows and c_index < cols:\\n                result += matrix[r_index][c_index]\\n                r_index += 1\\n                c_index += 1\\n            col += 1\\n        return result.rstrip()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2690629,
                "title": "python-easy-way",
                "content": "# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1:\\n            return encodedText\\n        \\n        col = int(len(encodedText) / rows)\\n        lines = [[\\' \\' for _ in range(col)] for _ in range(rows)]\\n        for idx, c in enumerate(encodedText):\\n            lines[idx // col][(idx % col)] = c\\n        \\n        originalText = \"\"\\n\\n        for c in range(col):\\n            begin = c\\n            i = 0\\n            for r in range(rows):\\n                if c+i >= col:\\n                    break\\n\\n                originalText += lines[r][c+i]\\n                i += 1\\n        \\n\\n        return originalText.rstrip()\\n                \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1:\\n            return encodedText\\n        \\n        col = int(len(encodedText) / rows)\\n        lines = [[\\' \\' for _ in range(col)] for _ in range(rows)]\\n        for idx, c in enumerate(encodedText):\\n            lines[idx // col][(idx % col)] = c\\n        \\n        originalText = \"\"\\n\\n        for c in range(col):\\n            begin = c\\n            i = 0\\n            for r in range(rows):\\n                if c+i >= col:\\n                    break\\n\\n                originalText += lines[r][c+i]\\n                i += 1\\n        \\n\\n        return originalText.rstrip()\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652361,
                "title": "easy-c-clean-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows == 1)\\n            return encodedText;\\n        int l = encodedText.length();\\n        int col = l/rows;\\n        vector<vector<char>> mat(rows, vector<char> (col));\\n        int val = 0;\\n        for(int i = 0 ; i < rows; i++)\\n        {\\n            for(int j = 0 ; j < col ;j++)\\n            {\\n                mat[i][j] = encodedText[val];\\n                val++;\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i < col; i++)\\n        {\\n            int row = 0;\\n            int c = i;\\n            while(c < col and row < rows)\\n                ans += mat[row++][c++];\\n        }\\n        while(ans.back() == \\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows == 1)\\n            return encodedText;\\n        int l = encodedText.length();\\n        int col = l/rows;\\n        vector<vector<char>> mat(rows, vector<char> (col));\\n        int val = 0;\\n        for(int i = 0 ; i < rows; i++)\\n        {\\n            for(int j = 0 ; j < col ;j++)\\n            {\\n                mat[i][j] = encodedText[val];\\n                val++;\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i < col; i++)\\n        {\\n            int row = 0;\\n            int c = i;\\n            while(c < col and row < rows)\\n                ans += mat[row++][c++];\\n        }\\n        while(ans.back() == \\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647509,
                "title": "cpp-solution-easy-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        vector<vector<char>> arr(rows, vector<char>(cols));\\n        int k = 0;\\n        \\n\\t\\t// filling the vector\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                arr[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n        string original = \"\";\\n        \\n\\t\\t// diagonal traversal as shown in image \\n        for(int col = 0; col < cols; col++) {\\n            int r = 0;\\n            int c = col;\\n            while(c < cols and r < rows) {\\n                original += arr[r++][c++];\\n            }\\n        }\\n        \\n\\t\\t// removing trailing zeros\\n        while(original.back() == \\' \\') original.pop_back();\\n        \\n        return original;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        vector<vector<char>> arr(rows, vector<char>(cols));\\n        int k = 0;\\n        \\n\\t\\t// filling the vector\\n        for(int i = 0; i < rows; i++) {\\n            for(int j = 0; j < cols; j++) {\\n                arr[i][j] = encodedText[k++];\\n            }\\n        }\\n        \\n        string original = \"\";\\n        \\n\\t\\t// diagonal traversal as shown in image \\n        for(int col = 0; col < cols; col++) {\\n            int r = 0;\\n            int c = col;\\n            while(c < cols and r < rows) {\\n                original += arr[r++][c++];\\n            }\\n        }\\n        \\n\\t\\t// removing trailing zeros\\n        while(original.back() == \\' \\') original.pop_back();\\n        \\n        return original;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619486,
                "title": "java-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int len = encodedText.length();\\n        int cols = (len % rows == 0) ? len / rows : (len / rows + 1);\\n\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        int count = 0;\\n        \\n        while (i * cols + (i + count) < len) {\\n            sb.append(encodedText.charAt(i * cols + (i + count)));\\n            count += (i + 1) / rows;\\n            i = (i + 1) % rows;\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n    // Time complexity: O(N)\\n    // Space complexity: O(1)\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int len = encodedText.length();\\n        int cols = (len % rows == 0) ? len / rows : (len / rows + 1);\\n\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        int count = 0;\\n        \\n        while (i * cols + (i + count) < len) {\\n            sb.append(encodedText.charAt(i * cols + (i + count)));\\n            count += (i + 1) / rows;\\n            i = (i + 1) % rows;\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n    // Time complexity: O(N)\\n    // Space complexity: O(1)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616890,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string e, int rows) {\\n        \\n        int c=e.length()/rows;\\n        string ans; \\n        \\n        for(int j=0;j<c;j++)\\n        {  \\n            int rh=0;\\n            int ch=j;\\n            for(int i=0;i<rows;i++)\\n            {\\n                 int z=rh*c+ ch;\\n                ans.push_back(e[z]);\\n                  rh++;\\n                  ch++;\\n                \\n                if(rh>=rows ||ch>=c)\\n                    break;\\n            }       \\n        }   \\n            \\n        for(int i=ans.length()-1;i>=0;i--)\\n        {\\n            if(ans[i]==\\' \\')\\n               ans.pop_back();\\n            else\\n                break;\\n        }\\n                return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string e, int rows) {\\n        \\n        int c=e.length()/rows;\\n        string ans; \\n        \\n        for(int j=0;j<c;j++)\\n        {  \\n            int rh=0;\\n            int ch=j;\\n            for(int i=0;i<rows;i++)\\n            {\\n                 int z=rh*c+ ch;\\n                ans.push_back(e[z]);\\n                  rh++;\\n                  ch++;\\n                \\n                if(rh>=rows ||ch>=c)\\n                    break;\\n            }       \\n        }   \\n            \\n        for(int i=ans.length()-1;i>=0;i--)\\n        {\\n            if(ans[i]==\\' \\')\\n               ans.pop_back();\\n            else\\n                break;\\n        }\\n                return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604545,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        numRows, numCols, res = rows, len(encodedText) // rows, []\\n        for first in range(numCols):\\n            res.append(encodedText[first])\\n            for second in range(first + numCols + 1, numRows * numCols, numCols + 1):\\n                res.append(encodedText[second])\\n        return \\'\\'.join(res).rstrip()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        numRows, numCols, res = rows, len(encodedText) // rows, []\\n        for first in range(numCols):\\n            res.append(encodedText[first])\\n            for second in range(first + numCols + 1, numRows * numCols, numCols + 1):\\n                res.append(encodedText[second])\\n        return \\'\\'.join(res).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603496,
                "title": "javascript",
                "content": "```\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    let colunm = encodedText.length / rows;\\n    let output = \\'\\';\\n    for (var i = 0; i < colunm; i++) {\\n        output += encodedText[i];\\n        let j = i + colunm + 1;\\n        while(j < encodedText.length) {\\n            output += encodedText[j];\\n            j = j + colunm +1;\\n        }\\n    }\\n    return output.replace(/\\\\s*$/, \\'\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    let colunm = encodedText.length / rows;\\n    let output = \\'\\';\\n    for (var i = 0; i < colunm; i++) {\\n        output += encodedText[i];\\n        let j = i + colunm + 1;\\n        while(j < encodedText.length) {\\n            output += encodedText[j];\\n            j = j + colunm +1;\\n        }\\n    }\\n    return output.replace(/\\\\s*$/, \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2550611,
                "title": "java-two-pointer-approach-optimized-code",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length()/rows ;\\n        int m = encodedText.length() ;\\n        StringBuffer originalText = new StringBuffer() ;\\n        \\n        for (int i = 0; i < n; i++) {\\n            originalText.append(encodedText.charAt(i)) ;\\n            for (int j = i+n+1; j < m; j += n+1)\\n                originalText.append(encodedText.charAt(j)) ;\\n        }\\n        int lastIndex = originalText.length()-1 ;\\n        \\n        for (int k = lastIndex; k >= 0; k--)\\n            if (originalText.charAt(k) == \\' \\') lastIndex-- ;\\n            else break ;\\n        \\n        String result = originalText.toString() ;\\n        return result.substring(0, lastIndex+1) ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length()/rows ;\\n        int m = encodedText.length() ;\\n        StringBuffer originalText = new StringBuffer() ;\\n        \\n        for (int i = 0; i < n; i++) {\\n            originalText.append(encodedText.charAt(i)) ;\\n            for (int j = i+n+1; j < m; j += n+1)\\n                originalText.append(encodedText.charAt(j)) ;\\n        }\\n        int lastIndex = originalText.length()-1 ;\\n        \\n        for (int k = lastIndex; k >= 0; k--)\\n            if (originalText.charAt(k) == \\' \\') lastIndex-- ;\\n            else break ;\\n        \\n        String result = originalText.toString() ;\\n        return result.substring(0, lastIndex+1) ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510951,
                "title": "python-solution-simple-explanation",
                "content": "res=\"\"\\n\\n        \\n        #find the number of columns for the matrix\\n        col=int(len(encodedText)/rows)\\n        lst= [[0]*col for i in range(rows)] \\n        \\n        \\n        #create matrix and put the characters of the string to its correct location\\n        for i in range(rows):\\n            lst[i]= encodedText[i*col:(i*col)+col]\\n            \\n        \\n        \\n        # retrive the matrix to get original string    \\n        for i in range(col):\\n            for j in range(rows):\\n                if i+j > col-1:\\n                    break\\n                else:\\n                    res=res+lst[j][j+i]\\n\\t\\t\\t\\t\\t\\n\\t\\t#return the decoded string with right trailing space removed\\t\\t\\t\\n        return res.rstrip()",
                "solutionTags": [
                    "String"
                ],
                "code": "res=\"\"\\n\\n        \\n        #find the number of columns for the matrix\\n        col=int(len(encodedText)/rows)\\n        lst= [[0]*col for i in range(rows)] \\n        \\n        \\n        #create matrix and put the characters of the string to its correct location\\n        for i in range(rows):\\n            lst[i]= encodedText[i*col:(i*col)+col]\\n            \\n        \\n        \\n        # retrive the matrix to get original string    \\n        for i in range(col):\\n            for j in range(rows):\\n                if i+j > col-1:\\n                    break\\n                else:\\n                    res=res+lst[j][j+i]\\n\\t\\t\\t\\t\\t\\n\\t\\t#return the decoded string with right trailing space removed\\t\\t\\t\\n        return res.rstrip()",
                "codeTag": "Unknown"
            },
            {
                "id": 2493684,
                "title": "c-solution-simulation",
                "content": "### C++:\\n```\\nclass Solution {\\n    void removeTrailingSpaces(string& str)\\n    {\\n        int end = str.size()-1;\\n\\n        for (int i = str.size()-1; i >= 0; i--)\\n        {\\n            if (str[i] != \\' \\')\\n                break;\\n            else\\n                end--;\\n        }\\n        \\n        str.erase(str.begin()+end+1,str.end());\\n    }\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if (encodedText.empty())\\n            return \"\";\\n        \\n        int columns = encodedText.size() / rows;\\n        \\n        vector<vector<char>> matrix(rows, vector<char>(columns));\\n        \\n        int encodedIndex = 0;\\n        for (int i = 0; i < rows; i++)\\n        {\\n            for (int j = 0; j < columns; j++)\\n            {\\n                if (encodedIndex < encodedText.size())\\n                    matrix[i][j] = encodedText[encodedIndex++];\\n            }\\n        }\\n        \\n        string res;\\n        int i = 0, j = 0;\\n        int orgJ = 0;\\n        \\n        while (true)\\n        {\\n            res.push_back(matrix[i][j]);\\n            \\n            if (i+1 == rows or j+1 == columns)\\n            {\\n                if (orgJ == columns-1)\\n                    break;\\n                \\n                i = 0;\\n                j = ++orgJ;\\n            }\\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n            \\n        }\\n        \\n        removeTrailingSpaces(res);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void removeTrailingSpaces(string& str)\\n    {\\n        int end = str.size()-1;\\n\\n        for (int i = str.size()-1; i >= 0; i--)\\n        {\\n            if (str[i] != \\' \\')\\n                break;\\n            else\\n                end--;\\n        }\\n        \\n        str.erase(str.begin()+end+1,str.end());\\n    }\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if (encodedText.empty())\\n            return \"\";\\n        \\n        int columns = encodedText.size() / rows;\\n        \\n        vector<vector<char>> matrix(rows, vector<char>(columns));\\n        \\n        int encodedIndex = 0;\\n        for (int i = 0; i < rows; i++)\\n        {\\n            for (int j = 0; j < columns; j++)\\n            {\\n                if (encodedIndex < encodedText.size())\\n                    matrix[i][j] = encodedText[encodedIndex++];\\n            }\\n        }\\n        \\n        string res;\\n        int i = 0, j = 0;\\n        int orgJ = 0;\\n        \\n        while (true)\\n        {\\n            res.push_back(matrix[i][j]);\\n            \\n            if (i+1 == rows or j+1 == columns)\\n            {\\n                if (orgJ == columns-1)\\n                    break;\\n                \\n                i = 0;\\n                j = ++orgJ;\\n            }\\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n            \\n        }\\n        \\n        removeTrailingSpaces(res);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490448,
                "title": "python-3-straightforward",
                "content": "\\tclass Solution:\\n\\t\\tdef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n\\t\\t\\tres=[]\\n\\t\\t\\tsize=len(encodedText)//rows\\n\\t\\t\\tfor i in range(size):\\n\\t\\t\\t\\tfor k in range(i,len(encodedText),size+1):\\n\\t\\t\\t\\t\\tres.append(encodedText[k])\\n\\t\\t\\treturn \\'\\'.join(res).rstrip()",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n\\t\\t\\tres=[]\\n\\t\\t\\tsize=len(encodedText)//rows\\n\\t\\t\\tfor i in range(size):\\n\\t\\t\\t\\tfor k in range(i,len(encodedText),size+1):\\n\\t\\t\\t\\t\\tres.append(encodedText[k])\\n\\t\\t\\treturn \\'\\'.join(res).rstrip()",
                "codeTag": "Java"
            },
            {
                "id": 2484168,
                "title": "leap-numberofcolumns-1",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring decodeCiphertext(string str, int rows) {\\n\\t\\t\\tint c=str.length()/rows;\\n\\t\\t\\tstring res=\"\";\\n\\t\\t\\tfor(int i=0;i<c;i++){\\n\\t\\t\\t\\tfor(int j=i;j<str.length();j+=c+1){\\n\\t\\t\\t\\t\\tres+=str[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint n=res.length()-1;\\n\\t\\t\\twhile(n>=0&&res[n]==\\' \\') n--;\\n\\t\\t\\tres=res.substr(0,n+1);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring decodeCiphertext(string str, int rows) {\\n\\t\\t\\tint c=str.length()/rows;\\n\\t\\t\\tstring res=\"\";\\n\\t\\t\\tfor(int i=0;i<c;i++){\\n\\t\\t\\t\\tfor(int j=i;j<str.length();j+=c+1){\\n\\t\\t\\t\\t\\tres+=str[j];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2449161,
                "title": "java-easy-implementation",
                "content": "```\\n   class Solution {\\n        public String decodeCiphertext(String encodedText, int rows) {\\n\\n            int col = encodedText.length() / rows;\\n            char[][] mat = new char[rows][col];\\n            for (char[] c : mat) Arrays.fill(c, \\' \\');\\n            \\n            int r = 0, c = 0;\\n            for (int i = 0; i < encodedText.length(); i++) {\\n                if (c >= col) {\\n                    c = 0;\\n                    ++r;\\n                }\\n                \\n                mat[r][c++] = encodedText.charAt(i);\\n            }\\n\\n            StringBuilder sb = new StringBuilder();\\n            int p, q;\\n            int ind = 0;\\n            while (ind < col) {\\n                p = 0;\\n                q = ind;\\n\\n                // keep mv diagonally down\\n                while (p < rows && q < col) sb.append(mat[p++][q++]);\\n                ind++;\\n            }\\n\\n            return sb.toString().replaceFirst(\"\\\\\\\\s++$\", \"\");\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   class Solution {\\n        public String decodeCiphertext(String encodedText, int rows) {\\n\\n            int col = encodedText.length() / rows;\\n            char[][] mat = new char[rows][col];\\n            for (char[] c : mat) Arrays.fill(c, \\' \\');\\n            \\n            int r = 0, c = 0;\\n            for (int i = 0; i < encodedText.length(); i++) {\\n                if (c >= col) {\\n                    c = 0;\\n                    ++r;\\n                }\\n                \\n                mat[r][c++] = encodedText.charAt(i);\\n            }\\n\\n            StringBuilder sb = new StringBuilder();\\n            int p, q;\\n            int ind = 0;\\n            while (ind < col) {\\n                p = 0;\\n                q = ind;\\n\\n                // keep mv diagonally down\\n                while (p < rows && q < col) sb.append(mat[p++][q++]);\\n                ind++;\\n            }\\n\\n            return sb.toString().replaceFirst(\"\\\\\\\\s++$\", \"\");\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366242,
                "title": "python-simple-solution-and-a-bonus-one-liner-solution",
                "content": "- Simple solution:\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        cols = n // rows\\n        step = cols + 1\\n        res = \"\"\\n        \\n        for i in range(cols):\\n            for j in range(i, n, step):\\n                res += encodedText[j]\\n            \\n        return res.rstrip()\\n```\\n\\n- Looking at the previous solution, we can see that it can be transformed into a one-liner:\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n         return \"\".join(encodedText[j] for i in range(len(encodedText) // rows) for j in range(i, len(encodedText), len(encodedText) // rows + 1)).rstrip()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        cols = n // rows\\n        step = cols + 1\\n        res = \"\"\\n        \\n        for i in range(cols):\\n            for j in range(i, n, step):\\n                res += encodedText[j]\\n            \\n        return res.rstrip()\\n```\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n         return \"\".join(encodedText[j] for i in range(len(encodedText) // rows) for j in range(i, len(encodedText), len(encodedText) // rows + 1)).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336258,
                "title": "simple",
                "content": "![image](https://assets.leetcode.com/users/images/c2fdab4a-2b0d-4d75-8362-e67029591305_1658843882.4257522.png)\\n\\nDeletion of trailing spaces:\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/edf9dee2-654a-4ece-9656-8fd61f219ef1_1658850236.0707505.png)\\n\\n<br>\\n\\n```\\nstring decodeCiphertext(string e, int r)\\n{\\n\\tstring out{};\\n\\tfor(int j{}, w(size(e)/r); j<w; ++j)\\n\\t\\tfor(int i{}; i<min(r,w-j); out.push_back(e[i*(w+1)+j]));\\t\\t\\t\\n\\treturn {begin(out), begin(out)+1+out.find_last_not_of(\\' \\')};\\n}\\n```\\n||\\n```\\nstring decodeCiphertext(string e, int r)\\n{\\n\\tstring out;\\n\\tint w(size(e)/r), end{};\\n\\tfor(int j{}; j<w; ++j)\\n\\t\\tfor(int i{}; i<min(r,w-j); ++i)\\n\\t\\t{\\n\\t\\t\\tint x=i*(w+1)+j;\\n\\t\\t\\tout.push_back(e[x]);\\n\\t\\t\\tif(e[x]!=\\' \\') end=size(out);\\n\\t\\t}\\n\\treturn {begin(out), begin(out)+end};\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring decodeCiphertext(string e, int r)\\n{\\n\\tstring out{};\\n\\tfor(int j{}, w(size(e)/r); j<w; ++j)\\n\\t\\tfor(int i{}; i<min(r,w-j); out.push_back(e[i*(w+1)+j]));\\t\\t\\t\\n\\treturn {begin(out), begin(out)+1+out.find_last_not_of(\\' \\')};\\n}\\n```\n```\\nstring decodeCiphertext(string e, int r)\\n{\\n\\tstring out;\\n\\tint w(size(e)/r), end{};\\n\\tfor(int j{}; j<w; ++j)\\n\\t\\tfor(int i{}; i<min(r,w-j); ++i)\\n\\t\\t{\\n\\t\\t\\tint x=i*(w+1)+j;\\n\\t\\t\\tout.push_back(e[x]);\\n\\t\\t\\tif(e[x]!=\\' \\') end=size(out);\\n\\t\\t}\\n\\treturn {begin(out), begin(out)+end};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2251018,
                "title": "simple-python-solution-7-lines-of-code-only",
                "content": "1. Notice that the next letter is always ```cols+1``` away from the current letter.\\n2. Once we reach the end of ```encodedText```, we continue from the next column in the first row.\\n\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        results = []\\n        for i in range(cols):\\n            while i < len(encodedText):\\n                results.append(encodedText[i])\\n                i += cols + 1\\n            \\n        return \\'\\'.join(results).rstrip()\\n```",
                "solutionTags": [],
                "code": "```cols+1```\n```encodedText```\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        cols = len(encodedText)//rows\\n        results = []\\n        for i in range(cols):\\n            while i < len(encodedText):\\n                results.append(encodedText[i])\\n                i += cols + 1\\n            \\n        return \\'\\'.join(results).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226175,
                "title": "iterative-solution-no-extra-space-c",
                "content": "Please upvote if you like my solution .\\n```\\nclass Solution {\\npublic:\\n    \\n    string decodeCiphertext(string eT, int r) {\\n        int len = eT.length();\\n        if(len == 0) return eT;\\n        if(r == 1) return eT;\\n        string ans;\\n        int c = len/r;\\n        int i=0,u=0;\\n        while(i != c-1){\\n            int l = ans.length()-1;\\n            ans += eT[i];\\n            i += c+1;\\n            if(i>=len) i = ++u;\\n        }\\n        ans += eT[i];\\n        while(ans[ans.size() - 1] == \\' \\')  ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string decodeCiphertext(string eT, int r) {\\n        int len = eT.length();\\n        if(len == 0) return eT;\\n        if(r == 1) return eT;\\n        string ans;\\n        int c = len/r;\\n        int i=0,u=0;\\n        while(i != c-1){\\n            int l = ans.length()-1;\\n            ans += eT[i];\\n            i += c+1;\\n            if(i>=len) i = ++u;\\n        }\\n        ans += eT[i];\\n        while(ans[ans.size() - 1] == \\' \\')  ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190758,
                "title": "python-compute-the-index-one-pass-easy-to-understand",
                "content": "The logic is to find the number of columns based on the length of encodedText. The floor or integer divison is helpful here. \\n\\nI compute the index of row and column of imaginary matrix (no need to build the matrix). Then compute the corresponding index in the encodedText. We traverse the diagonal to reach end of current diagonal. That means the r (row_index) has reached to last row (rows - 1). Then increase the curr_diag (current diagnoal index) and continue from the top row again with the col starting at curr_diag. \\n\\n\\t\\n\\tdef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows==1:\\n            return encodedText\\n        \\n        num_col = len(encodedText) // rows\\n        ans = []\\n        r, c, curr_diag = 0, 0, 0\\n        \\n        while curr_diag < num_col:\\n            idx = r * num_col + c\\n            # we reached the right top position in the matrix\\n            if idx >= len(encodedText):\\n                break\\n            ans.append(encodedText[idx])\\n            if r == rows - 1:\\n                curr_diag += 1\\n                r = 0\\n                c = curr_diag\\n            else:\\n                r += 1\\n                c += 1\\n        \\n        return \\'\\'.join(ans).rstrip()\\n    \\nI thinkg the time complexity is linear O(N) where N is the len(encodedText) and Space complexity is O(M) where M is the length of the decoded message since I have to create the string in the end. Otherwise, during the computation, I only have few pointers and I need O(1) space for them.\\t\\n\\nPlease share your suggestions on how to improve the solution.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "The logic is to find the number of columns based on the length of encodedText. The floor or integer divison is helpful here. \\n\\nI compute the index of row and column of imaginary matrix (no need to build the matrix). Then compute the corresponding index in the encodedText. We traverse the diagonal to reach end of current diagonal. That means the r (row_index) has reached to last row (rows - 1). Then increase the curr_diag (current diagnoal index) and continue from the top row again with the col starting at curr_diag. \\n\\n\\t\\n\\tdef decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows==1:\\n            return encodedText\\n        \\n        num_col = len(encodedText) // rows\\n        ans = []\\n        r, c, curr_diag = 0, 0, 0\\n        \\n        while curr_diag < num_col:\\n            idx = r * num_col + c\\n            # we reached the right top position in the matrix\\n            if idx >= len(encodedText):\\n                break\\n            ans.append(encodedText[idx])\\n            if r == rows - 1:\\n                curr_diag += 1\\n                r = 0\\n                c = curr_diag\\n            else:\\n                r += 1\\n                c += 1\\n        \\n        return \\'\\'.join(ans).rstrip()\\n    \\nI thinkg the time complexity is linear O(N) where N is the len(encodedText) and Space complexity is O(M) where M is the length of the decoded message since I have to create the string in the end. Otherwise, during the computation, I only have few pointers and I need O(1) space for them.\\t\\n\\nPlease share your suggestions on how to improve the solution.",
                "codeTag": "Python3"
            },
            {
                "id": 2159521,
                "title": "step-by-step-approach-easyy-intuitive-thinking",
                "content": "```\\n string decodeCiphertext(string encode, int rows) {\\n        \\n        if(encode.empty())  //if encode kuch hai hi nahi\\n            return \"\";\\n        \\n        int k=0,cols=encode.size()/rows;    //  cols= total_size/rows  (SIMPLE)\\n        vector<vector<char>> arr(rows,vector<char> (cols,\\' \\'));\\n        \\n        //step 1 Fill the code in the matrix\\n        \\n        for(int i=0;i<rows;i++)\\n           for(int j=0;j<cols;j++)\\n                arr[i][j]=encode[k++];\\n         \\n        //Step 2 Decode the code through diagonal traversal\\n        \\n        string ans=\"\";\\n        for(int k=0;k<cols;k++)\\n        {\\n            int i=0,j=k;\\n            while(i<rows and j<cols)\\n                ans+=arr[i++][j++];\\n        }\\n        \\n        //Step 3 Removing trailing whitespaces from answer\\n        int idx=ans.size()-1;\\n        while(ans[idx]==\\' \\')\\n            idx--;\\n        \\n        return ans.substr(0,idx+1);\\n    }",
                "solutionTags": [],
                "code": "```\\n string decodeCiphertext(string encode, int rows) {\\n        \\n        if(encode.empty())  //if encode kuch hai hi nahi\\n            return \"\";\\n        \\n        int k=0,cols=encode.size()/rows;    //  cols= total_size/rows  (SIMPLE)\\n        vector<vector<char>> arr(rows,vector<char> (cols,\\' \\'));\\n        \\n        //step 1 Fill the code in the matrix\\n        \\n        for(int i=0;i<rows;i++)\\n           for(int j=0;j<cols;j++)\\n                arr[i][j]=encode[k++];\\n         \\n        //Step 2 Decode the code through diagonal traversal\\n        \\n        string ans=\"\";\\n        for(int k=0;k<cols;k++)\\n        {\\n            int i=0,j=k;\\n            while(i<rows and j<cols)\\n                ans+=arr[i++][j++];\\n        }\\n        \\n        //Step 3 Removing trailing whitespaces from answer\\n        int idx=ans.size()-1;\\n        while(ans[idx]==\\' \\')\\n            idx--;\\n        \\n        return ans.substr(0,idx+1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2065097,
                "title": "c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n       string res; \\n       if (!rows ||!encodedText.size()) return res;\\n       int col = encodedText.size()/rows;    \\n       int step = 0, x = 0, y = 0;\\n       while(step < col) { \\n            res += encodedText[y*col+x];             \\n            x++; y++; \\n            if (y >= rows || x >= col) { y = 0; x = ++step; }   \\n       } \\n       while(res.back()==\\' \\') res.resize(res.size()-1); \\n       return res; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n       string res; \\n       if (!rows ||!encodedText.size()) return res;\\n       int col = encodedText.size()/rows;    \\n       int step = 0, x = 0, y = 0;\\n       while(step < col) { \\n            res += encodedText[y*col+x];             \\n            x++; y++; \\n            if (y >= rows || x >= col) { y = 0; x = ++step; }   \\n       } \\n       while(res.back()==\\' \\') res.resize(res.size()-1); \\n       return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045726,
                "title": "python-solution-clean-code",
                "content": "```\\nclass Solution:\\n\\tdef decodeCiphertext(self, e: str, r: int) -> str:\\n        n = len(e)\\n        it = (n // r) + 1\\n        ans = \"\"\\n        if r == 1:\\n            return e\\n        for i in range(it - 1):\\n            ans += e[i:n:it]\\n        return ans.rstrip(\" \")\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\tdef decodeCiphertext(self, e: str, r: int) -> str:\\n        n = len(e)\\n        it = (n // r) + 1\\n        ans = \"\"\\n        if r == 1:\\n            return e\\n        for i in range(it - 1):\\n            ans += e[i:n:it]\\n        return ans.rstrip(\" \")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031681,
                "title": "calculate-columns-and-jump-column-1-java",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(rows==1||encodedText.length()==0){\\n            return encodedText;\\n        }\\n        int col=encodedText.length()/rows;\\n        StringBuilder ans=new StringBuilder();\\n        for(int i=0;i<col;i++){\\n            int k=i;\\n            for(int j=0;j<rows&&k<encodedText.length();j++){\\n            ans.append(encodedText.charAt(k));\\n            k+=col+1;\\n            }\\n        }\\n        \\n        int j=ans.length()-1;\\n        while(ans.charAt(j)==\\' \\'){\\n                j--;\\n        }\\n        return ans.substring(0,j+1);\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(rows==1||encodedText.length()==0){\\n            return encodedText;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1976128,
                "title": "python-solution-by-building-the-grid",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        ans = [\"\"] * n\\n        cols = n//rows\\n        \\n        grid = [[\" \"] * cols for _ in range(rows)]\\n        k = 0\\n        for i, j in product(range(rows), range(cols)):\\n            grid[i][j] = encodedText[k]\\n            k += 1\\n        i, j = 0, 0\\n        l = 0\\n        t = 0\\n        while i < rows and j < cols:\\n            ans[l] = grid[i][j]\\n            i += 1\\n            j += 1\\n            l += 1\\n            if i >= rows:\\n                t += 1\\n                i = 0\\n                j = t\\n            if j >= cols:\\n                break\\n        \\n        finalAns = (\\'\\'.join(ans)).rstrip()\\n        return finalAns\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        ans = [\"\"] * n\\n        cols = n//rows\\n        \\n        grid = [[\" \"] * cols for _ in range(rows)]\\n        k = 0\\n        for i, j in product(range(rows), range(cols)):\\n            grid[i][j] = encodedText[k]\\n            k += 1\\n        i, j = 0, 0\\n        l = 0\\n        t = 0\\n        while i < rows and j < cols:\\n            ans[l] = grid[i][j]\\n            i += 1\\n            j += 1\\n            l += 1\\n            if i >= rows:\\n                t += 1\\n                i = 0\\n                j = t\\n            if j >= cols:\\n                break\\n        \\n        finalAns = (\\'\\'.join(ans)).rstrip()\\n        return finalAns\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1951361,
                "title": "python-solution-with-anti-diag-property",
                "content": "Important property of 2D matrix:\\n1. a constant value for the **sum** of diag element index: **i+j**\\n2. a constant value for the **difference** of anti_diag element index: **i-j**\\nNote that all of cells are empty in lower-triangle, so we will consider **j-i** only\\n\\n```\\nclass Solution:\\n    def decodeCiphertext(self, txt: str, r: int) -> str:\\n        c = len(txt)//r\\n        res = [[] for _ in range(max(r,c))]\\n        for k in range(len(txt)):\\n            i, j = k//c, k%c\\n            res[j-i].append(txt[k])\\n        res = [\\'\\'.join(l) for l in res]\\n        return \\'\\'.join(res).rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, txt: str, r: int) -> str:\\n        c = len(txt)//r\\n        res = [[] for _ in range(max(r,c))]\\n        for k in range(len(txt)):\\n            i, j = k//c, k%c\\n            res[j-i].append(txt[k])\\n        res = [\\'\\'.join(l) for l in res]\\n        return \\'\\'.join(res).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1951081,
                "title": "python-short-and-fast-faster-than-95-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/65d90c3c-bea1-4128-990a-3d8e6119ed1c_1650056602.9725244.png)\\n\\'v\\' is the number of slanted lines needed in the cipher table. The algorithm basically is to read along a sloping line and jump a gap and turn to the next one.\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        l = n//rows\\n        v= l-(rows-1)\\n        ans = \\'\\'\\n        r,i=0,0\\n        while r<v+1:\\n            if i<n:\\n                ans+=encodedText[i]\\n                i+=(l+1)\\n            else:\\n                r+=1;i=r\\n        return ans.rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        n = len(encodedText)\\n        l = n//rows\\n        v= l-(rows-1)\\n        ans = \\'\\'\\n        r,i=0,0\\n        while r<v+1:\\n            if i<n:\\n                ans+=encodedText[i]\\n                i+=(l+1)\\n            else:\\n                r+=1;i=r\\n        return ans.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946110,
                "title": "c-95-faster-no-extra-space-no-matrix",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows == 1) return encodedText;\\n        if(encodedText.size()<=1) return encodedText;\\n        string s;\\n        int size = encodedText.length();\\n        int len = size/rows;\\n        for(int i = 0 ; i < len ; i++){\\n            for(int j = 0; j < min(len-i , rows) ; j++){\\n                s += encodedText[i+(len+1)*j];\\n            }\\n        }\\n\\t\\t// to remove extra spaces in the back\\n        size = s.length();\\n        while(s[size-1] == \\' \\')size--;\\n        s = s.substr(0,size);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows == 1) return encodedText;\\n        if(encodedText.size()<=1) return encodedText;\\n        string s;\\n        int size = encodedText.length();\\n        int len = size/rows;\\n        for(int i = 0 ; i < len ; i++){\\n            for(int j = 0; j < min(len-i , rows) ; j++){\\n                s += encodedText[i+(len+1)*j];\\n            }\\n        }\\n\\t\\t// to remove extra spaces in the back\\n        size = s.length();\\n        while(s[size-1] == \\' \\')size--;\\n        s = s.substr(0,size);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944085,
                "title": "easy-solution-by-preparing-and-traversing-matrix-in-c",
                "content": "```\\npublic class Solution {\\n    public string DecodeCiphertext(string str, int row) {\\n        if(row == 1) return str;\\n        \\n        int k = 0;\\n        int col = str.Length/row;\\n        char[][] matrix = new char[row][];\\n        for(int i =0;i<row;++i)\\n        {\\n            matrix[i] = new char[col];\\n        }\\n        \\n        for(int i = 0; i<row;++i)\\n        {\\n            for(int j = 0; j<col;j++)\\n            {\\n                matrix[i][j] = str[k++];\\n            }\\n        }\\n        \\n        var sb = new StringBuilder();\\n        for(int i = 0; i<col;++i)\\n        {\\n            for(int j = 0; j<row && i+j < col;j++)\\n            {\\n                var ch = matrix[j][i+j];\\n                sb.Append(ch);\\n            }\\n        }\\n        \\n        return sb.ToString().TrimEnd(\\' \\');\\n    }\\n}",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution {\\n    public string DecodeCiphertext(string str, int row) {\\n        if(row == 1) return str;\\n        \\n        int k = 0;\\n        int col = str.Length/row;\\n        char[][] matrix = new char[row][];\\n        for(int i =0;i<row;++i)\\n        {\\n            matrix[i] = new char[col];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1930015,
                "title": "c-easy-to-understand-simple-logic-diagonal-traversal",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    void solve(string encodedText,string& ans,int row,int m)\\n    {\\n        \\n       for(int j=0;j<m;j++)\\n       {\\n           int r=0;\\n           int c=j;\\n           while(r<row && c<m)\\n           {\\n               ans+=encodedText[r*m+c];\\n               r++;\\n               c++;\\n           }\\n       }\\n    }\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string ans=\"\";\\n        int n=encodedText.length();\\n        int m=n/rows; //no of column\\n      \\n        \\n        solve(encodedText,ans,rows,m);\\n        \\n        while(ans.length()>=1 && ans[ans.length()-1]==\\' \\') //if trailing spaces \\' \\'\\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void solve(string encodedText,string& ans,int row,int m)\\n    {\\n        \\n       for(int j=0;j<m;j++)\\n       {\\n           int r=0;\\n           int c=j;\\n           while(r<row && c<m)\\n           {\\n               ans+=encodedText[r*m+c];\\n               r++;\\n               c++;\\n           }\\n       }\\n    }\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string ans=\"\";\\n        int n=encodedText.length();\\n        int m=n/rows; //no of column\\n      \\n        \\n        solve(encodedText,ans,rows,m);\\n        \\n        while(ans.length()>=1 && ans[ans.length()-1]==\\' \\') //if trailing spaces \\' \\'\\n            ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879453,
                "title": "java-simple-two-approach",
                "content": "1st\\n```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        char[][] ch = new char[rows][encodedText.length()/rows];\\n        int index = 0;\\n        for(int i=0;i<ch.length;i++){\\n            for(int j=0;j<ch[0].length;j++){\\n                ch[i][j]= encodedText.charAt(index++);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int gap =0;gap<ch[0].length;gap++){\\n            for(int i=0,j=gap;i<rows && j<encodedText.length()/rows;i++,j++){\\n                sb.append(ch[i][j]);\\n            }\\n        }\\n        while(sb.length()>0 && sb.charAt(sb.length()-1) == \\' \\'){\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n\\n2nd \\n```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(rows == 1 || encodedText.length() == 0){\\n            return encodedText;\\n        }\\n        int cur = 0;\\n        int start = 0;\\n        int inc = encodedText.length()/rows + 1;\\n        StringBuilder sb = new StringBuilder();\\n        while(start<inc){\\n            sb.append(encodedText.charAt(cur));\\n            cur+=inc;\\n            if(cur>=encodedText.length()){\\n                cur = ++start;\\n            }\\n        }\\n        while(sb.length()>0 && sb.charAt(sb.length()-1) == \\' \\'){\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        char[][] ch = new char[rows][encodedText.length()/rows];\\n        int index = 0;\\n        for(int i=0;i<ch.length;i++){\\n            for(int j=0;j<ch[0].length;j++){\\n                ch[i][j]= encodedText.charAt(index++);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int gap =0;gap<ch[0].length;gap++){\\n            for(int i=0,j=gap;i<rows && j<encodedText.length()/rows;i++,j++){\\n                sb.append(ch[i][j]);\\n            }\\n        }\\n        while(sb.length()>0 && sb.charAt(sb.length()-1) == \\' \\'){\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(rows == 1 || encodedText.length() == 0){\\n            return encodedText;\\n        }\\n        int cur = 0;\\n        int start = 0;\\n        int inc = encodedText.length()/rows + 1;\\n        StringBuilder sb = new StringBuilder();\\n        while(start<inc){\\n            sb.append(encodedText.charAt(cur));\\n            cur+=inc;\\n            if(cur>=encodedText.length()){\\n                cur = ++start;\\n            }\\n        }\\n        while(sb.length()>0 && sb.charAt(sb.length()-1) == \\' \\'){\\n            sb.deleteCharAt(sb.length()-1);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842300,
                "title": "python3-simple-to-understand",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        res=[]\\n        cols=len(encodedText)//rows\\n        for j in range(cols):\\n            idx=j\\n            while idx<len(encodedText):\\n                res.append(encodedText[idx])\\n                idx+=cols+1\\n        return \\'\\'.join(res).rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        res=[]\\n        cols=len(encodedText)//rows\\n        for j in range(cols):\\n            idx=j\\n            while idx<len(encodedText):\\n                res.append(encodedText[idx])\\n                idx+=cols+1\\n        return \\'\\'.join(res).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798577,
                "title": "c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int row) {\\n        string str = \"\";\\n        if(encodedText==\"\")\\n            return str;\\n        if(row == 1)\\n            return encodedText;\\n        int col = encodedText.size()/row;\\n        \\n        vector<char>mat[row];\\n       \\n        for(int k = 0;k<encodedText.size();k++){\\n            int x = floor(k/col);\\n            mat[x].push_back(encodedText[k]);\\n        }\\n        \\n        string res = \"\";\\n        for(int i = 0;i<= mat[0].size();i++){\\n            int j = 0,k = i;\\n            while(j<row && k<col){\\n                res.push_back(mat[j][k]);\\n                j++;\\n                k++;\\n            }\\n        }\\n        int j = res.size()-1;\\n        while(res[j] == \\' \\')\\n            j--;\\n        res = res.substr(0,j+1);\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int row) {\\n        string str = \"\";\\n        if(encodedText==\"\")\\n            return str;\\n        if(row == 1)\\n            return encodedText;\\n        int col = encodedText.size()/row;\\n        \\n        vector<char>mat[row];\\n       \\n        for(int k = 0;k<encodedText.size();k++){\\n            int x = floor(k/col);\\n            mat[x].push_back(encodedText[k]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1779780,
                "title": "java-recursive",
                "content": "```\\nclass Solution {\\n    private static int ROWS, COLS;\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        ROWS = rows;\\n        COLS = encodedText.length()/rows;\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        for(int c = 0; c < COLS; c++){\\n            diag(encodedText, 0, c, res);\\n        }\\n        int l = res.length()-1;\\n        while(l>=0){\\n            if(res.charAt(l)!=\\' \\') break;\\n            l--;\\n        }\\n        res.setLength(l+1);\\n        return res.toString();\\n    }\\n    \\n    private void diag(String enc, int r, int c, StringBuilder res){\\n        \\n        if(r>=ROWS || c>=COLS) return;\\n        \\n        int pos = r*COLS + c;\\n        \\n        res.append(enc.charAt(pos));\\n        diag(enc, ++r, ++c, res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static int ROWS, COLS;\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        ROWS = rows;\\n        COLS = encodedText.length()/rows;\\n        \\n        StringBuilder res = new StringBuilder();\\n        \\n        for(int c = 0; c < COLS; c++){\\n            diag(encodedText, 0, c, res);\\n        }\\n        int l = res.length()-1;\\n        while(l>=0){\\n            if(res.charAt(l)!=\\' \\') break;\\n            l--;\\n        }\\n        res.setLength(l+1);\\n        return res.toString();\\n    }\\n    \\n    private void diag(String enc, int r, int c, StringBuilder res){\\n        \\n        if(r>=ROWS || c>=COLS) return;\\n        \\n        int pos = r*COLS + c;\\n        \\n        res.append(enc.charAt(pos));\\n        diag(enc, ++r, ++c, res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1757057,
                "title": "simple",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(encodedText.length() == 0 || rows < 2) return encodedText;\\n        \\n        int cols = encodedText.length() / rows;\\n        Map<Integer, Integer> map = new HashMap();\\n        \\n        int row = 0;\\n        for(int x = 1; x <= rows; x++) {\\n            map.put(x, row);\\n            row = 1 + row + cols;\\n        }\\n        \\n        final StringBuilder sb = new StringBuilder();\\n        while(map.size() > 0) {\\n            for(int key = 1 ; key <= rows ; key++) {\\n                if(map.containsKey(key)) {\\n                    int idx = map.get(key);\\n                    if(idx < encodedText.length()) sb.append(encodedText.charAt(idx));\\n\\n                    if((idx + 1) % cols== 0) {\\n                        map.remove(key);\\n                    } else {\\n                        map.put(key, idx + 1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while(sb.charAt(sb.length() -1) == \\' \\') {\\n            sb.deleteCharAt(sb.length() -1);\\n        }\\n        \\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if(encodedText.length() == 0 || rows < 2) return encodedText;\\n        \\n        int cols = encodedText.length() / rows;\\n        Map<Integer, Integer> map = new HashMap();\\n        \\n        int row = 0;\\n        for(int x = 1; x <= rows; x++) {\\n            map.put(x, row);\\n            row = 1 + row + cols;\\n        }\\n        \\n        final StringBuilder sb = new StringBuilder();\\n        while(map.size() > 0) {\\n            for(int key = 1 ; key <= rows ; key++) {\\n                if(map.containsKey(key)) {\\n                    int idx = map.get(key);\\n                    if(idx < encodedText.length()) sb.append(encodedText.charAt(idx));\\n\\n                    if((idx + 1) % cols== 0) {\\n                        map.remove(key);\\n                    } else {\\n                        map.put(key, idx + 1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while(sb.charAt(sb.length() -1) == \\' \\') {\\n            sb.deleteCharAt(sb.length() -1);\\n        }\\n        \\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740992,
                "title": "time-memory-o-n-construct-matrix-and-read-diagonally",
                "content": "### Idea\\n\\nConstruct a matrix for decoding, and read the matrix diagonally from `[0, 0]`.\\n\\n### Complexity\\n\\nTime: `O(n)`\\nSpace: `O(n)`\\nwhere `n = encodedText.length`\\n\\n```typescript\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    const m = rows\\n    const n = encodedText.length / m\\n    const mat = [...Array(m)].map(() => [])\\n    for (let i=0; i<encodedText.length; i+=1) {\\n        mat[Math.floor(i / n)].push(encodedText[i])\\n    }\\n    let text = \"\"\\n    for (let x=0; x<=mat[0].length; x+=1) {\\n        for (let i=0; i<Math.min(m, n-x); i+=1) {\\n            text += mat[i][x+i]\\n        }\\n    }\\n    return text.trimEnd()\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction decodeCiphertext(encodedText: string, rows: number): string {\\n    const m = rows\\n    const n = encodedText.length / m\\n    const mat = [...Array(m)].map(() => [])\\n    for (let i=0; i<encodedText.length; i+=1) {\\n        mat[Math.floor(i / n)].push(encodedText[i])\\n    }\\n    let text = \"\"\\n    for (let x=0; x<=mat[0].length; x+=1) {\\n        for (let i=0; i<Math.min(m, n-x); i+=1) {\\n            text += mat[i][x+i]\\n        }\\n    }\\n    return text.trimEnd()\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1736145,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int encodedLength =  encodedText.length();\\n        \\n        int cols = encodedLength/rows;\\n        \\n       StringBuilder res= new StringBuilder();\\n        \\n        \\n        for(int j=0; j<cols; j++) {\\n            int k = j;\\n            for(int i=0; i<rows; i++) {\\n                if(cols*i+k < encodedLength) {\\n                  res.append(encodedText.charAt(cols*i+k));\\n                  k++;\\n                }\\n            }\\n        }\\n        \\n        return res.toString().stripTrailing();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int encodedLength =  encodedText.length();\\n        \\n        int cols = encodedLength/rows;\\n        \\n       StringBuilder res= new StringBuilder();\\n        \\n        \\n        for(int j=0; j<cols; j++) {\\n            int k = j;\\n            for(int i=0; i<rows; i++) {\\n                if(cols*i+k < encodedLength) {\\n                  res.append(encodedText.charAt(cols*i+k));\\n                  k++;\\n                }\\n            }\\n        }\\n        \\n        return res.toString().stripTrailing();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726703,
                "title": "2075-decode-the-slanted-ciphertext-beats-98",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if(encodedText.length()==0)\\n            return \"\";\\n        string ans=\"\";\\n        \\n        int i=0;\\n        int j=0;\\n        int cols=encodedText.length()/rows;\\n        int k=0;\\n        while(i<rows && j<cols && k<cols)\\n        {\\n            ans+=encodedText[i++*cols+k++]; \\n            if(i==rows)\\n            {\\n                j++;\\n                k=j;\\n                i=0;\\n            }\\n        }\\n        \\n        while(ans[ans.length()-1]==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        \\n        if(encodedText.length()==0)\\n            return \"\";\\n        string ans=\"\";\\n        \\n        int i=0;\\n        int j=0;\\n        int cols=encodedText.length()/rows;\\n        int k=0;\\n        while(i<rows && j<cols && k<cols)\\n        {\\n            ans+=encodedText[i++*cols+k++]; \\n            if(i==rows)\\n            {\\n                j++;\\n                k=j;\\n                i=0;\\n            }\\n        }\\n        \\n        while(ans[ans.length()-1]==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700561,
                "title": "simple-diagonal-traversal",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        m, n = rows, len(encodedText) // rows\\n        op = \"\"\\n        for i in range(n):\\n            for j in range(m):\\n                if i + j < n:\\n                    op += encodedText[(n + 1) * j + i]\\n        return op.rstrip()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        m, n = rows, len(encodedText) // rows\\n        op = \"\"\\n        for i in range(n):\\n            for j in range(m):\\n                if i + j < n:\\n                    op += encodedText[(n + 1) * j + i]\\n        return op.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682307,
                "title": "javascript-code",
                "content": "```\\n/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    if(encodedText == \"\"){\\n        return \"\";\\n    }\\n    var result = [];\\n    var output = \"\";\\n    var data = encodedText.split(\\'\\');\\n    var col = Math.floor(data.length /rows);\\n    \\n    for(let i = 0; i< data.length; i++){\\n        if(i%col == 0){\\n            result.push([]);\\n        }\\n        result[parseInt(i/col)].push(data[i]);\\n    }\\n    \\n    for(let colum = 0; colum < result[0].length; colum++){\\n        let rowNum = 0;\\n        let colNum = colum;\\n        output = output + result[rowNum][colum];\\n        \\n        while(rowNum + 1 <= result.length - 1 && colNum + 1 <= result[0].length - 1){\\n            output = output + result[rowNum + 1][colNum + 1];\\n            rowNum++;\\n            colNum++;\\n        }\\n    }\\n    return output.trimEnd();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    if(encodedText == \"\"){\\n        return \"\";\\n    }\\n    var result = [];\\n    var output = \"\";\\n    var data = encodedText.split(\\'\\');\\n    var col = Math.floor(data.length /rows);\\n    \\n    for(let i = 0; i< data.length; i++){\\n        if(i%col == 0){\\n            result.push([]);\\n        }\\n        result[parseInt(i/col)].push(data[i]);\\n    }\\n    \\n    for(let colum = 0; colum < result[0].length; colum++){\\n        let rowNum = 0;\\n        let colNum = colum;\\n        output = output + result[rowNum][colum];\\n        \\n        while(rowNum + 1 <= result.length - 1 && colNum + 1 <= result[0].length - 1){\\n            output = output + result[rowNum + 1][colNum + 1];\\n            rowNum++;\\n            colNum++;\\n        }\\n    }\\n    return output.trimEnd();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1669760,
                "title": "dfs-java",
                "content": "```\\n\\n        StringBuilder sb;\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        \\n        if(rows==1) return encodedText ; \\n        \\n        //1000 \\n        \\n        //constructing the grid  O(n*n)\\n        \\n        //traversing and creating the string O(n*n)\\n        \\n        int col = encodedText.length()/rows; \\n        \\n        \\n        char[][] grid = new char[rows][col];\\n        \\n        int k = 0 ; \\n        \\n        for(int i=0 ;i<rows ; i++){\\n            \\n            for(int j=0 ; j<col ; j++){\\n                \\n                grid[i][j] = encodedText.charAt(k); \\n                \\n                k++;\\n                \\n            }\\n        }\\n        \\n        \\n        sb = new StringBuilder(); \\n        \\n        for(int i=0 ; i<col ; i++){\\n            \\n            dfs(0,i,grid);\\n            \\n        }\\n         \\n        \\n       String regex = \"\\\\\\\\s+$\";\\n        \\n       return sb.toString().replaceAll(regex,\"\");\\n    }\\n    \\n    void dfs(int i , int j, char[][] grid){\\n        \\n        if(i<0 || i>grid.length-1 || j<0 || j>grid[0].length-1) return ;\\n        \\n        sb.append(grid[i][j]);\\n        \\n        dfs(i+1,j+1,grid);\\n        \\n        return ;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n        StringBuilder sb;\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        \\n        if(rows==1) return encodedText ; \\n        \\n        //1000 \\n        \\n        //constructing the grid  O(n*n)\\n        \\n        //traversing and creating the string O(n*n)\\n        \\n        int col = encodedText.length()/rows; \\n        \\n        \\n        char[][] grid = new char[rows][col];\\n        \\n        int k = 0 ; \\n        \\n        for(int i=0 ;i<rows ; i++){\\n            \\n            for(int j=0 ; j<col ; j++){\\n                \\n                grid[i][j] = encodedText.charAt(k); \\n                \\n                k++;\\n                \\n            }\\n        }\\n        \\n        \\n        sb = new StringBuilder(); \\n        \\n        for(int i=0 ; i<col ; i++){\\n            \\n            dfs(0,i,grid);\\n            \\n        }\\n         \\n        \\n       String regex = \"\\\\\\\\s+$\";\\n        \\n       return sb.toString().replaceAll(regex,\"\");\\n    }\\n    \\n    void dfs(int i , int j, char[][] grid){\\n        \\n        if(i<0 || i>grid.length-1 || j<0 || j>grid[0].length-1) return ;\\n        \\n        sb.append(grid[i][j]);\\n        \\n        dfs(i+1,j+1,grid);\\n        \\n        return ;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1661876,
                "title": "bfs-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n\\t/*\\n\\t\\t1. Add the starting index of each appendable characters from each row in a queue.\\n\\t\\t\\n\\t\\t2. Now extract the element, add it into the answer string and push the next character \\n\\t\\tfrom the same row in the queue.\\n\\t\\t\\n\\t\\t3. Do it for the length of the encodedText. Later, trim the ending spaces from the answer string.\\n\\t*/\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        queue<int> bfs;\\n        string ans = \"\";\\n        \\n        int i = 1, pointer = 0;\\n        while(i <= rows) {\\n            bfs.push(pointer);\\n            pointer += cols;\\n            pointer += 1;\\n            i++;\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            int t = bfs.front();\\n            bfs.pop();\\n            if(t<0 || t>=n) continue;            \\n            ans += encodedText[t++];\\n            bfs.push(t);\\n        }\\n        \\n        int j;\\n        for(j=ans.size()-1; j>=0; j--) {            \\n            if(ans[j] >= \\'a\\' && ans[j] <=\\'z\\') break;\\n        }\\n        \\n        ans.erase(ans.begin()+j+1, ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t/*\\n\\t\\t1. Add the starting index of each appendable characters from each row in a queue.\\n\\t\\t\\n\\t\\t2. Now extract the element, add it into the answer string and push the next character \\n\\t\\tfrom the same row in the queue.\\n\\t\\t\\n\\t\\t3. Do it for the length of the encodedText. Later, trim the ending spaces from the answer string.\\n\\t*/\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        int cols = n / rows;\\n        queue<int> bfs;\\n        string ans = \"\";\\n        \\n        int i = 1, pointer = 0;\\n        while(i <= rows) {\\n            bfs.push(pointer);\\n            pointer += cols;\\n            pointer += 1;\\n            i++;\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            int t = bfs.front();\\n            bfs.pop();\\n            if(t<0 || t>=n) continue;            \\n            ans += encodedText[t++];\\n            bfs.push(t);\\n        }\\n        \\n        int j;\\n        for(j=ans.size()-1; j>=0; j--) {            \\n            if(ans[j] >= \\'a\\' && ans[j] <=\\'z\\') break;\\n        }\\n        \\n        ans.erase(ans.begin()+j+1, ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659037,
                "title": "c-accepted-solution-explained-on-basis-of-hint-s",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int encodeSize = encodedText.size();\\n\\t\\t// HINT 1 - Get Column , using rows and encodedText\\n        int columns = encodeSize/rows;\\n        vector<vector<char>> mat;\\n        int counter = 0;\\n        vector<char> v;\\n\\t\\t// HINT 2 -- Place in matrix\\n        for(int i=0;i<encodeSize;i++)\\n        {\\n\\n            counter++;\\n            v.push_back(encodedText[i]);\\n            if(counter==columns)\\n            {\\n                counter = 0;\\n                mat.push_back(v);\\n                v.clear();\\n            }\\n        }\\n        string ans;\\n        int colCounter = 0;\\n\\t\\t// HINT 3 - Traverse to get originalText\\n        for(int i=0;i<columns;i++)\\n        {\\n            int rowCounter = 0;\\n            for(int j=0;j<rows && j+colCounter<columns;j++)\\n            {\\n                ans.push_back(mat[rowCounter][j+colCounter]);\\n                rowCounter++;\\n            }\\n            colCounter++;\\n        }\\n\\t\\t//Remove extra spaces at last. Can alternatively use pop_back() also\\n        int lastCharCounter = 0;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(ans[i]!=\\' \\')\\n                lastCharCounter = i;\\n        }\\n        return ans.substr(0,lastCharCounter+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int encodeSize = encodedText.size();\\n\\t\\t// HINT 1 - Get Column , using rows and encodedText\\n        int columns = encodeSize/rows;\\n        vector<vector<char>> mat;\\n        int counter = 0;\\n        vector<char> v;\\n\\t\\t// HINT 2 -- Place in matrix\\n        for(int i=0;i<encodeSize;i++)\\n        {\\n\\n            counter++;\\n            v.push_back(encodedText[i]);\\n            if(counter==columns)\\n            {\\n                counter = 0;\\n                mat.push_back(v);\\n                v.clear();\\n            }\\n        }\\n        string ans;\\n        int colCounter = 0;\\n\\t\\t// HINT 3 - Traverse to get originalText\\n        for(int i=0;i<columns;i++)\\n        {\\n            int rowCounter = 0;\\n            for(int j=0;j<rows && j+colCounter<columns;j++)\\n            {\\n                ans.push_back(mat[rowCounter][j+colCounter]);\\n                rowCounter++;\\n            }\\n            colCounter++;\\n        }\\n\\t\\t//Remove extra spaces at last. Can alternatively use pop_back() also\\n        int lastCharCounter = 0;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(ans[i]!=\\' \\')\\n                lastCharCounter = i;\\n        }\\n        return ans.substr(0,lastCharCounter+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653689,
                "title": "js-simple-solution-string-array-string-builder",
                "content": "```\\n\\t/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const cols = Math.round(encodedText.length / rows);\\n    const matrix = new Array(rows).fill(null).map(item => []);\\n    let c = 0;\\n    for (let i = 0; i < rows; i++) {\\n        for (let j = 0; j < cols; j++) {\\n            const char = encodedText.charAt(c++); \\n            matrix[i][j] = char;\\n        }\\n    }\\n    let result = \\'\\';\\n    for (let i = 0; i < cols; i++) {\\n        for (let j = 0; j < rows; j++) {\\n            if (matrix[j][i + j]) result += matrix[j][i + j]\\n        }\\n    }\\n    return result.trimRight();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\t/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const cols = Math.round(encodedText.length / rows);\\n    const matrix = new Array(rows).fill(null).map(item => []);\\n    let c = 0;\\n    for (let i = 0; i < rows; i++) {\\n        for (let j = 0; j < cols; j++) {\\n            const char = encodedText.charAt(c++); \\n            matrix[i][j] = char;\\n        }\\n    }\\n    let result = \\'\\';\\n    for (let i = 0; i < cols; i++) {\\n        for (let j = 0; j < rows; j++) {\\n            if (matrix[j][i + j]) result += matrix[j][i + j]\\n        }\\n    }\\n    return result.trimRight();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1650044,
                "title": "o-n-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int n) {\\n        int m=encodedText.length()/n;\\n        string s=\"\";\\n        for(int j=0;j<m;j++){\\n            for(int i=0;i+j<m && i<n;i++){\\n                s+= encodedText[i*m+i+j];\\n            }\\n        }\\n        while(s.size() && s.back()==\\' \\') s.pop_back();\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int n) {\\n        int m=encodedText.length()/n;\\n        string s=\"\";\\n        for(int j=0;j<m;j++){\\n            for(int i=0;i+j<m && i<n;i++){\\n                s+= encodedText[i*m+i+j];\\n            }\\n        }\\n        while(s.size() && s.back()==\\' \\') s.pop_back();\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649232,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if len(encodedText) == 0: return \"\"\\n        \\n        m, n, ls = rows, len(encodedText) // rows, []    \\n        matrix = [encodedText[n * i: n * (i + 1)] for i in range(m)]\\n\\n        i, j, idx = 0, 0, 0\\n        while True:\\n            ls.append(matrix[i][j])\\n            if i == 0 and j == n - 1: break\\n            if i == m - 1 or j == n - 1:\\n                idx += 1\\n                i, j = 0, idx\\n            else:\\n                i += 1\\n                j += 1\\n        \\n        while ls[-1] == \\' \\': ls.pop()\\n\\n        return \\'\\'.join(ls)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if len(encodedText) == 0: return \"\"\\n        \\n        m, n, ls = rows, len(encodedText) // rows, []    \\n        matrix = [encodedText[n * i: n * (i + 1)] for i in range(m)]\\n\\n        i, j, idx = 0, 0, 0\\n        while True:\\n            ls.append(matrix[i][j])\\n            if i == 0 and j == n - 1: break\\n            if i == m - 1 or j == n - 1:\\n                idx += 1\\n                i, j = 0, idx\\n            else:\\n                i += 1\\n                j += 1\\n        \\n        while ls[-1] == \\' \\': ls.pop()\\n\\n        return \\'\\'.join(ls)",
                "codeTag": "Java"
            },
            {
                "id": 1646892,
                "title": "python-o-n-by-diagonal-decode-w-visualization",
                "content": "Python O(n) by diagonal decode.\\n\\n![image](https://assets.leetcode.com/users/images/5c422b5a-921a-4c3b-8c2b-83a3264fd292_1640454409.9887652.png)\\n\\n\\n---\\n**Hint** and **Algorithm**:\\n\\nStep_1.\\nGet the codec matrix **heigh** and **width**, \\nwhere height is given = rows, and \\nwidth = len(encode string) // rows \\n\\nStep_2.\\nDecode order is blue axis, then red axis, then yellow axis, ..., and so on \\n\\nStep_3.\\nThose characters belong to same axis has the index **offset (width+1)** in **encode string** by observation\\n\\nTake blue axis for example\\n```\\nindex on codec matrix :(0, 0) -> (1, 1)  -> (2, 2)   -> ...\\nindex in encode text:  s[ 0 ] -> s[w+1]  -> s[2w+2 ] -> ...\\n```\\n\\nStep_4.\\nDecode each diagonal axis one by one to generate plain text.\\nPaintext on blue axis = join ( s[ 0 ], s[ 0 + w + 1 ], s[ 0 + 2w + 2 ], ... )\\n\\nPaintext on red axis = join ( s[ 1 ], s[ 1 + w + 1], s[ 1 + 2w + 2 ], ... )\\n\\nPaintext on yellow axis = join ( s[ 2 ], s[ 2 + w + 1], s[ 2 + 2w + 2 ], ... )\\n...and so on till we reach last column\\n\\nStep_5.\\nFinally, **remember to remove redundant whitespaces** on the tail.\\n\\n---\\n\\n**Implementation** by diagonal decode:\\n\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n\\n        if rows == 1:\\n            # Quick response on simple case\\n            return encodedText\\n        \\n        # get the codec matrix dimension\\n        h = rows\\n        w = len(encodedText) // h\\n        \\n        # Concatenate diagonal string level by level\\n        # Remeber to remove redundant whitespaces on the tail\\n        return \"\".join( encodedText[diag_level::w+1]for diag_level in range(w)).rstrip()\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "String"
                ],
                "code": "```\\nindex on codec matrix :(0, 0) -> (1, 1)  -> (2, 2)   -> ...\\nindex in encode text:  s[ 0 ] -> s[w+1]  -> s[2w+2 ] -> ...\\n```\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n\\n        if rows == 1:\\n            # Quick response on simple case\\n            return encodedText\\n        \\n        # get the codec matrix dimension\\n        h = rows\\n        w = len(encodedText) // h\\n        \\n        # Concatenate diagonal string level by level\\n        # Remeber to remove redundant whitespaces on the tail\\n        return \"\".join( encodedText[diag_level::w+1]for diag_level in range(w)).rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637753,
                "title": "simple-logical-solution",
                "content": "\\n\\n\\nstring decodeCiphertext(string encodedText, int rows) \\n\\n{\\n        \\n\\t\\t\\n\\t\\tint n = encodedText.length();\\n        int cols = n/rows;\\n        \\n        string ans = \"\";\\n        for(int i=0; i<cols; i=i+1){\\n            //if(encodedText[i] == \\' \\')\\n               //break;\\n            for(int j=i; j<n; j=j+cols+1)\\n               ans += encodedText[j];\\n        }\\n        while(ans.back()==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }",
                "solutionTags": [
                    "String"
                ],
                "code": "\\n\\n\\nstring decodeCiphertext(string encodedText, int rows) \\n\\n{\\n        \\n\\t\\t\\n\\t\\tint n = encodedText.length();\\n        int cols = n/rows;\\n        \\n        string ans = \"\";\\n        for(int i=0; i<cols; i=i+1){\\n            //if(encodedText[i] == \\' \\')\\n               //break;\\n            for(int j=i; j<n; j=j+cols+1)\\n               ans += encodedText[j];\\n        }\\n        while(ans.back()==\\' \\')\\n            ans.pop_back();\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1625315,
                "title": "cpp-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) {\\n        if(s==\"\" || rows==1)return s; //BASE CASE\\n       vector<vector<char>>arr(rows,vector<char>(s.size()/rows,\\' \\')); //CREATING MATRIX;\\n        int ind=0;\\n        for(int i=0;i<arr.size();i++) //FILLING MATRIX WITH CHARACTERS;\\n        {\\n            for(int j=0;j<arr[0].size();j++)\\n            {\\n                if(ind<s.size())\\n                {\\n                    arr[i][j]=s[ind++];\\n                }\\n            }\\n        }\\n        s=\"\";\\n        for(int i=0;i<arr[0].size();i++) //TRAVERSING MATRIX ACCORDING TO QUESTION;\\n        {\\n            int j=0,t=i;\\n            while(j<arr.size()&&t<arr[0].size())\\n            {\\n                s+=arr[j][t];\\n                j++;\\n                t++;\\n            }\\n        }\\n        while(s[s.size()-1]==\\' \\')s.pop_back(); //REMOVE TRAILING SPACES;\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string s, int rows) {\\n        if(s==\"\" || rows==1)return s; //BASE CASE\\n       vector<vector<char>>arr(rows,vector<char>(s.size()/rows,\\' \\')); //CREATING MATRIX;\\n        int ind=0;\\n        for(int i=0;i<arr.size();i++) //FILLING MATRIX WITH CHARACTERS;\\n        {\\n            for(int j=0;j<arr[0].size();j++)\\n            {\\n                if(ind<s.size())\\n                {\\n                    arr[i][j]=s[ind++];\\n                }\\n            }\\n        }\\n        s=\"\";\\n        for(int i=0;i<arr[0].size();i++) //TRAVERSING MATRIX ACCORDING TO QUESTION;\\n        {\\n            int j=0,t=i;\\n            while(j<arr.size()&&t<arr[0].size())\\n            {\\n                s+=arr[j][t];\\n                j++;\\n                t++;\\n            }\\n        }\\n        while(s[s.size()-1]==\\' \\')s.pop_back(); //REMOVE TRAILING SPACES;\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622063,
                "title": "c-solution",
                "content": "Matrix Rebuilding\\n```\\npublic class Solution {\\n    public string DecodeCiphertext(string e, int rows) {\\n        if (rows == 1 || string.IsNullOrEmpty(e)) return e;\\n        \\n        int l = e.Length, cols = l / rows;\\n        char[,] m = new char[rows, cols];\\n        int k = 0;\\n        for (int i = 0; i < rows; ++i) {\\n            for (int j = 0; j < cols; ++j) {\\n                m[i, j] = e[k++];\\n            }\\n        }\\n        \\n        StringBuilder r = new StringBuilder();\\n        for (int i = 0; i < m.GetLength(1); ++i) {\\n            int row = 0, col = i;\\n            while (row < rows && col < cols) r.Append(m[row++, col++]);\\n        }\\n        \\n        while (r[r.Length - 1] == \\' \\') r.Length--;\\n        \\n        return r.ToString();\\n    }\\n}\\n```\\n\\nColumn Index Hopping\\n```\\npublic class Solution {\\n    public string DecodeCiphertext(string et, int rows) {\\n        int l = et.Length, cols = et.Length / rows;\\n        \\n        StringBuilder r = new StringBuilder();\\n        for (int i = 0; i < cols; ++i) { \\n            for (int j = i; j < et.Length; j += cols + 1) { // + 1 for the leading space \\n                r.Append(et[j]);\\n            }\\n        }\\n        \\n        return r.ToString().TrimEnd();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string DecodeCiphertext(string e, int rows) {\\n        if (rows == 1 || string.IsNullOrEmpty(e)) return e;\\n        \\n        int l = e.Length, cols = l / rows;\\n        char[,] m = new char[rows, cols];\\n        int k = 0;\\n        for (int i = 0; i < rows; ++i) {\\n            for (int j = 0; j < cols; ++j) {\\n                m[i, j] = e[k++];\\n            }\\n        }\\n        \\n        StringBuilder r = new StringBuilder();\\n        for (int i = 0; i < m.GetLength(1); ++i) {\\n            int row = 0, col = i;\\n            while (row < rows && col < cols) r.Append(m[row++, col++]);\\n        }\\n        \\n        while (r[r.Length - 1] == \\' \\') r.Length--;\\n        \\n        return r.ToString();\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public string DecodeCiphertext(string et, int rows) {\\n        int l = et.Length, cols = et.Length / rows;\\n        \\n        StringBuilder r = new StringBuilder();\\n        for (int i = 0; i < cols; ++i) { \\n            for (int j = i; j < et.Length; j += cols + 1) { // + 1 for the leading space \\n                r.Append(et[j]);\\n            }\\n        }\\n        \\n        return r.ToString().TrimEnd();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604184,
                "title": "javascript-time-o-m-n-space-o-1",
                "content": "```\\n/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const len = encodedText.length\\n    const cols = len / rows\\n    function getCh(i, j) {\\n        const index = i * cols + j\\n        return encodedText[index]\\n    }\\n    \\n    \\n    const chs = []\\n    for (let j = 0; j < cols; j++) {\\n        for (let i = 0; i < rows && j + i < cols; i++) {\\n            const ch = getCh(i, i + j)\\n            chs.push(ch)\\n        }\\n    }\\n    \\n    \\n    let result = chs.join(\\'\\')\\n    result = result.trimEnd()\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} encodedText\\n * @param {number} rows\\n * @return {string}\\n */\\nvar decodeCiphertext = function(encodedText, rows) {\\n    const len = encodedText.length\\n    const cols = len / rows\\n    function getCh(i, j) {\\n        const index = i * cols + j\\n        return encodedText[index]\\n    }\\n    \\n    \\n    const chs = []\\n    for (let j = 0; j < cols; j++) {\\n        for (let i = 0; i < rows && j + i < cols; i++) {\\n            const ch = getCh(i, i + j)\\n            chs.push(ch)\\n        }\\n    }\\n    \\n    \\n    let result = chs.join(\\'\\')\\n    result = result.trimEnd()\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1588867,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string str, int r) {\\n        int c = str.size() / r; \\n        string ret; \\n        for(int i = 0;i<c;i++) {\\n            for(int j = 0;j<r&&i+j<c;j++) {\\n                ret.push_back(str[j*c + i + j]);\\n            }\\n        }\\n        ret.erase(ret.find_last_not_of(\\' \\')+1);\\n        return ret; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string str, int r) {\\n        int c = str.size() / r; \\n        string ret; \\n        for(int i = 0;i<c;i++) {\\n            for(int j = 0;j<r&&i+j<c;j++) {\\n                ret.push_back(str[j*c + i + j]);\\n            }\\n        }\\n        ret.erase(ret.find_last_not_of(\\' \\')+1);\\n        return ret; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588272,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    \\n\\tpublic String decodeCiphertext(String encodedText, int rows) {\\n        \\n        int l=encodedText.length();\\n        \\n        int x,c=l/rows;\\n        \\n        if(l==0)\\n            return \"\";\\n        \\n        int j=0;\\n        StringBuilder d= new StringBuilder();\\n        while(j<c){\\n            int y=j;\\n            x=0;\\n            while(y<l){\\n                d=d.append(encodedText.charAt(y));\\n                y=y+c+1;\\n            }\\n            j++;\\n        }\\n        \\n        String t=d.toString();\\n        \\n        int y=t.length();\\n        \\n      while(y>=0 && t.charAt(y-1)==\\' \\')\\n          y--;\\n        \\n        if(y==-1)\\n            return \"\";\\n        \\n        return t.substring(0,y);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n\\tpublic String decodeCiphertext(String encodedText, int rows) {\\n        \\n        int l=encodedText.length();\\n        \\n        int x,c=l/rows;\\n        \\n        if(l==0)\\n            return \"\";\\n        \\n        int j=0;\\n        StringBuilder d= new StringBuilder();\\n        while(j<c){\\n            int y=j;\\n            x=0;\\n            while(y<l){\\n                d=d.append(encodedText.charAt(y));\\n                y=y+c+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1588186,
                "title": "2075-decode-the-slanted-ciphertext",
                "content": "---\\n\\n- Contest - https://leetcode.com/contest/weekly-contest-267/\\n  - Q1 Answer\\n    - https://leetcode.com/problems/time-needed-to-buy-tickets/discuss/1578174/2073.-Time-Needed-to-Buy-Tickets\\n  - Q2 Answer\\n    - https://leetcode.com/problems/reverse-nodes-in-even-length-groups/discuss/1580446/2074.-Reverse-Nodes-in-Even-Length-Groups\\n  - Q3 Answer\\n    - below\\n      - https://leetcode.com/problems/decode-the-slanted-ciphertext/discuss/1588186/2075.-Decode-the-Slanted-Ciphertext\\n\\n---\\n\\n- Code from my contest, worked out on paper for 15 mins, and 4 mins of coding, 1 min of submission. Passed on 1st submit.\\n  - See Q3 at https://leetcode.com/contest/weekly-contest-267/ranking/72/\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar decodeCiphertext = function (encodedText, rows) {\\n    let n = encodedText.length;\\n\\n    let ans = \\'\\';\\n    let cols = Math.round(n / rows);\\n    for (let i = 0; i < cols; i++) {\\n        for (let j = i; j < n; j += cols + 1) {\\n            ans += encodedText[j];\\n        }\\n    }\\n    return ans.trimRight();\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decodeCiphertext = function (encodedText, rows) {\\n    let n = encodedText.length;\\n\\n    let ans = \\'\\';\\n    let cols = Math.round(n / rows);\\n    for (let i = 0; i < cols; i++) {\\n        for (let j = i; j < n; j += cols + 1) {\\n            ans += encodedText[j];\\n        }\\n    }\\n    return ans.trimRight();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1588102,
                "title": "pick-characters-columns-1-distant-apart",
                "content": "```\\n// time: O(n) || space : O(1)\\n\\npublic String decodeCiphertext(String encodedText, int rows) {\\n\\tint textLen = encodedText.length();\\n\\tint cols = textLen / rows;\\n\\n\\tStringBuffer decodedStrBuf = new StringBuffer();\\n\\tfor(int i = 0; i < cols; i++) {\\n\\t\\tfor(int j = i; j < textLen; j += (cols + 1)) {\\n\\t\\t\\tdecodedStrBuf.append(encodedText.charAt(j));\\n\\t\\t}\\n\\t}\\n\\n\\treturn decodedStrBuf.toString().stripTrailing();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// time: O(n) || space : O(1)\\n\\npublic String decodeCiphertext(String encodedText, int rows) {\\n\\tint textLen = encodedText.length();\\n\\tint cols = textLen / rows;\\n\\n\\tStringBuffer decodedStrBuf = new StringBuffer();\\n\\tfor(int i = 0; i < cols; i++) {\\n\\t\\tfor(int j = i; j < textLen; j += (cols + 1)) {\\n\\t\\t\\tdecodedStrBuf.append(encodedText.charAt(j));\\n\\t\\t}\\n\\t}\\n\\n\\treturn decodedStrBuf.toString().stripTrailing();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1587671,
                "title": "go-solution-with-explanation",
                "content": "1. we can get the column of the matrix: `len(encodedText)/rows`\\n2. we can locate the character in every `blow arrows` if we know where the first character is (0, y). Actually, we know it, they are all in the first `column` character of encodedText. For example, in `example 1`, it\\'s `ch`, in `example 2`, it\\'s `iveo`.\\n3. the latest column must have character, so the second place`(rows-2, column-1)` from last in last column `column-1` may have character. However, the third place`(rows-3, column-1)` from last in last column `column-1` must have no character, actually, the blue arrows including the `(rows-3, column-1)`  must have no character. That is, there are most `column-rows+2` characters in the first line. \\n\\n```go\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n\\tif rows == 1 {\\n\\t\\treturn encodedText\\n\\t}\\n\\tcolumn := len(encodedText) / rows\\n\\tans := \"\"\\n\\tvar index int\\n\\tfor round := 0; round <= column-rows+1; round++ {\\n\\t\\toriginIndex := round\\n\\t\\tfor i := 0; i < rows; i++ {\\n\\t\\t\\tindex = originIndex + i*column + i\\n\\t\\t\\tif index >= len(encodedText) {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tans += string(encodedText[index])\\n\\t\\t}\\n\\t}\\n\\treturn strings.TrimRight(ans, \" \")\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n\\tif rows == 1 {\\n\\t\\treturn encodedText\\n\\t}\\n\\tcolumn := len(encodedText) / rows\\n\\tans := \"\"\\n\\tvar index int\\n\\tfor round := 0; round <= column-rows+1; round++ {\\n\\t\\toriginIndex := round\\n\\t\\tfor i := 0; i < rows; i++ {\\n\\t\\t\\tindex = originIndex + i*column + i\\n\\t\\t\\tif index >= len(encodedText) {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tans += string(encodedText[index])\\n\\t\\t}\\n\\t}\\n\\treturn strings.TrimRight(ans, \" \")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1587467,
                "title": "clarifying-the-question",
                "content": "Just want to clarify what the question requires, so others can know exactly what the question is asking for. It took me 3 wrong submissions to figure it out. \\n1. The word starts at where the blue blocks are as shown in the instruction  (I thought that it starts at the bottom left corner.)\\n2. Any group of slanted blocks that contain nothing but spaces should be retained if they are not at the very end.  (I thought those should be removed)\\n3. There is no trailing space but leading space is allowed (instruction mentioned this but I missed it).\\n\\nHope it help someone.",
                "solutionTags": [],
                "code": "Just want to clarify what the question requires, so others can know exactly what the question is asking for. It took me 3 wrong submissions to figure it out. \\n1. The word starts at where the blue blocks are as shown in the instruction  (I thought that it starts at the bottom left corner.)\\n2. Any group of slanted blocks that contain nothing but spaces should be retained if they are not at the very end.  (I thought those should be removed)\\n3. There is no trailing space but leading space is allowed (instruction mentioned this but I missed it).\\n\\nHope it help someone.",
                "codeTag": "Unknown"
            },
            {
                "id": 1583890,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int len = encodedText.length();\\n        if(len==0) return encodedText;\\n        int cols = len/rows;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<cols; i++){\\n            for(int row=0; row<rows; row++){\\n                int idx = cols*row+i+row;\\n                if(idx<len)\\n                    sb.append(encodedText.charAt(idx));\\n                else break;\\n            }\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int len = encodedText.length();\\n        if(len==0) return encodedText;\\n        int cols = len/rows;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<cols; i++){\\n            for(int row=0; row<rows; row++){\\n                int idx = cols*row+i+row;\\n                if(idx<len)\\n                    sb.append(encodedText.charAt(idx));\\n                else break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1583724,
                "title": "after-finding-the-columns-read-off-the-matrix",
                "content": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if not encodedText: return \\'\\'\\n        \\n        C=len(encodedText)//rows\\n        matrix=[]\\n        for i in range(0,len(encodedText),C):\\n            matrix.append(encodedText[i:i+C])\\n        \\n        output=\\'\\'\\n        \\n        for i in range(C):\\n            k=0\\n            while k<rows and i+k<C:\\n                output+=matrix[k][i+k]\\n                k+=1\\n        \\n        return output.rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if not encodedText: return \\'\\'\\n        \\n        C=len(encodedText)//rows\\n        matrix=[]\\n        for i in range(0,len(encodedText),C):\\n            matrix.append(encodedText[i:i+C])\\n        \\n        output=\\'\\'\\n        \\n        for i in range(C):\\n            k=0\\n            while k<rows and i+k<C:\\n                output+=matrix[k][i+k]\\n                k+=1\\n        \\n        return output.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583477,
                "title": "giving-heap-overflow-working-fine-on-my-compiler",
                "content": "This code is giving heap overflow please help me find my mistake.\\n\\n\\n class Solution {\\npublic:\\n    string trim(string& line)\\n{\\n     for(int i=line.size()-1;i>=0;--i){\\n         if(line[i]>=\\'a\\' and line[i] <= \\'z\\'){\\n            return line.substr(0,i+1);\\n         }\\n     }\\n    return line;\\n}\\n    \\n    string decodeCiphertext(string encodedText, int rows) {\\n        int size = encodedText.size();\\n        int col = ceil(size/(rows*1.0));\\n        vector<string> parts;\\n        for(int i=0;i<encodedText.size();i+=col){\\n            parts.push_back(encodedText.substr(i,col));\\n        }\\n        string original;\\n        for(int i=0;i<col;++i){\\n            int temp_col = i;\\n            for(int j=0;j<rows;++j,++temp_col){\\n                original+=parts[j][temp_col];\\n            }\\n        }\\n        \\n        return trim(original);\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string trim(string& line)\\n{\\n     for(int i=line.size()-1;i>=0;--i){\\n         if(line[i]>=\\'a\\' and line[i] <= \\'z\\'){\\n            return line.substr(0,i+1);\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1583160,
                "title": "java-easy-intuitive-solution",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        // if(rows==0||encodedText.length()==0)return \"\";\\n        int len=encodedText.length();\\n        int cols=len/rows;\\n        char mat[][]=new char[rows][cols];\\n        int idx=len-1;int r=rows-1,c=cols-1,nr=0,nc=0;\\n        // System.out.println(rows+\"  \"+cols+\"  \"+len);\\n        while(idx>=0){\\n            if(c==0){\\n                nr=r-1;\\n                nc=cols-1;\\n            }else{\\n                nr=r;\\n                nc=c-1;\\n            }\\n            char ch=encodedText.charAt(idx--);\\n            // System.out.println(ch);\\n            // if(ch==\\' \\'){\\n            // mat[r][c]=\\'.\\';    \\n            // }else{\\n                mat[r][c]=ch;\\n            // }\\n            r=nr;\\n            c=nc;\\n            \\n        }\\n        // for(int i=0;i<rows;i++){\\n        //     for(int j=0;j<cols;j++){\\n        //         System.out.print(\" \"+mat[i][j]+\" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        StringBuilder sb=new StringBuilder();\\n        for(int d=0;d<Math.max(rows,cols);d++){\\n            for(int i=0,j=i+d;j<cols&&i<rows;i++,j++){\\n                sb.append(mat[i][j]);\\n            }\\n            \\n        }\\n        System.out.println(sb);\\n        int i=sb.length()-1;\\n        String s=sb.toString();\\n        while(i>=0&&s.charAt(i)==\\' \\'){\\n            i--;\\n        }\\n        return s.substring(0,i+1);\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        // if(rows==0||encodedText.length()==0)return \"\";\\n        int len=encodedText.length();\\n        int cols=len/rows;\\n        char mat[][]=new char[rows][cols];\\n        int idx=len-1;int r=rows-1,c=cols-1,nr=0,nc=0;\\n        // System.out.println(rows+\"  \"+cols+\"  \"+len);\\n        while(idx>=0){\\n            if(c==0){\\n                nr=r-1;\\n                nc=cols-1;\\n            }else{\\n                nr=r;\\n                nc=c-1;\\n            }\\n            char ch=encodedText.charAt(idx--);\\n            // System.out.println(ch);\\n            // if(ch==\\' \\'){\\n            // mat[r][c]=\\'.\\';    \\n            // }else{\\n                mat[r][c]=ch;\\n            // }\\n            r=nr;\\n            c=nc;\\n            \\n        }\\n        // for(int i=0;i<rows;i++){\\n        //     for(int j=0;j<cols;j++){\\n        //         System.out.print(\" \"+mat[i][j]+\" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        StringBuilder sb=new StringBuilder();\\n        for(int d=0;d<Math.max(rows,cols);d++){\\n            for(int i=0,j=i+d;j<cols&&i<rows;i++,j++){\\n                sb.append(mat[i][j]);\\n            }\\n            \\n        }\\n        System.out.println(sb);\\n        int i=sb.length()-1;\\n        String s=sb.toString();\\n        while(i>=0&&s.charAt(i)==\\' \\'){\\n            i--;\\n        }\\n        return s.substring(0,i+1);\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581454,
                "title": "java-straightforward-solution-with-two-pointers",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length()/rows, m = rows, i = 0, j = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while(i<m && j<n){\\n            int runI = 0, runJ = j++;\\n            while(runI < m && runJ < n){\\n                sb.append(encodedText.charAt(runI++ * n + runJ++));\\n            }\\n        }\\n        return trimFromLast(sb.toString());\\n    }\\n    public String trimFromLast(String str){\\n        int i = str.length()-1;\\n        while(i>=0){\\n            if(Character.isAlphabetic(str.charAt(i--)))\\n                return str.substring(0,i+2);\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length()/rows, m = rows, i = 0, j = 0;\\n        StringBuilder sb = new StringBuilder();\\n        while(i<m && j<n){\\n            int runI = 0, runJ = j++;\\n            while(runI < m && runJ < n){\\n                sb.append(encodedText.charAt(runI++ * n + runJ++));\\n            }\\n        }\\n        return trimFromLast(sb.toString());\\n    }\\n    public String trimFromLast(String str){\\n        int i = str.length()-1;\\n        while(i>=0){\\n            if(Character.isAlphabetic(str.charAt(i--)))\\n                return str.substring(0,i+2);\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581290,
                "title": "c-observation-beginner-level",
                "content": "jumping columns \\n\\'\\'\\'\\n\\n        string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        string str = \"\";\\n        \\n        //exceptional case of str = \"\" \\n        if(n == 0) return str;\\n       \\n        int col = n/rows ;\\n       // col times\\n        for(int i = 0; i<col; i++){\\n            \\n         //((row*col)/ col+1)\\n            for(int j = i; j< n; j+= col + 1){\\n                \\n              str +=   encodedText[j];\\n            }\\n        }\\n        // removes end spaces \\n        while(str[str.size()-1] == \\' \\') str.pop_back();\\n        return str;\\n        \\n    }\\n\\t\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "jumping columns \\n\\'\\'\\'\\n\\n        string decodeCiphertext(string encodedText, int rows) {\\n        int n = encodedText.size();\\n        string str = \"\";\\n        \\n        //exceptional case of str = \"\" \\n        if(n == 0) return str;\\n       \\n        int col = n/rows ;\\n       // col times\\n        for(int i = 0; i<col; i++){\\n            \\n         //((row*col)/ col+1)\\n            for(int j = i; j< n; j+= col + 1){\\n                \\n              str +=   encodedText[j];\\n            }\\n        }\\n        // removes end spaces \\n        while(str[str.size()-1] == \\' \\') str.pop_back();\\n        return str;\\n        \\n    }\\n\\t\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1581065,
                "title": "java-tiny-solution-in-place",
                "content": "```\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int cols = encodedText.length() / rows;        \\n        StringBuilder sb = new StringBuilder();\\n        for(int jj=0;jj<cols;jj++){\\n            for(int i=0,j=jj; i<rows && j<cols; i++,j++){\\n                sb.append(encodedText.charAt(i*cols+j));\\n            }\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int cols = encodedText.length() / rows;        \\n        StringBuilder sb = new StringBuilder();\\n        for(int jj=0;jj<cols;jj++){\\n            for(int i=0,j=jj; i<rows && j<cols; i++,j++){\\n                sb.append(encodedText.charAt(i*cols+j));\\n            }\\n        }\\n        return sb.toString().stripTrailing();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580811,
                "title": "optimized-for-time-10ms",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if (encodedText.length() <= 1) {\\n            return encodedText;\\n        }\\n        \\n        int n = encodedText.length() / rows;\\n        char[][] cipher = new char[rows][n];\\n        for (int i=0; i < rows; i++) {\\n            int start = i * n;\\n            cipher[i] = encodedText.substring(start, start + n).toCharArray();\\n        }\\n        \\n        int numColumnsToProcess = n-rows+1;\\n        char[] val = new char[encodedText.length() - (rows * (rows - 1))];\\n        int count=0;\\n        for(int i = 0; i<numColumnsToProcess; i++) {\\n            for(int j = 0; j<rows; j++) {\\n                val[count++] = cipher[j][i+j];\\n            }\\n        }\\n        \\n        StringBuilder extraBuilder = new StringBuilder();\\n        for(int j=0; j<rows-1; j++) {\\n            extraBuilder.append(cipher[j][numColumnsToProcess+j]);\\n        }\\n        \\n        String extra = extraBuilder.toString();  \\n        if (extra.trim().isEmpty()) {\\n            return new String(val);\\n        } \\n        \\n        int length = extraBuilder.length() - 1;\\n        while (length > 0 && extraBuilder.charAt(length) == \\' \\') {\\n            length--;\\n        }\\n        extraBuilder.setLength(length + 1);        \\n              \\n        \\n        return new String(val) + extraBuilder.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if (encodedText.length() <= 1) {\\n            return encodedText;\\n        }\\n        \\n        int n = encodedText.length() / rows;\\n        char[][] cipher = new char[rows][n];\\n        for (int i=0; i < rows; i++) {\\n            int start = i * n;\\n            cipher[i] = encodedText.substring(start, start + n).toCharArray();\\n        }\\n        \\n        int numColumnsToProcess = n-rows+1;\\n        char[] val = new char[encodedText.length() - (rows * (rows - 1))];\\n        int count=0;\\n        for(int i = 0; i<numColumnsToProcess; i++) {\\n            for(int j = 0; j<rows; j++) {\\n                val[count++] = cipher[j][i+j];\\n            }\\n        }\\n        \\n        StringBuilder extraBuilder = new StringBuilder();\\n        for(int j=0; j<rows-1; j++) {\\n            extraBuilder.append(cipher[j][numColumnsToProcess+j]);\\n        }\\n        \\n        String extra = extraBuilder.toString();  \\n        if (extra.trim().isEmpty()) {\\n            return new String(val);\\n        } \\n        \\n        int length = extraBuilder.length() - 1;\\n        while (length > 0 && extraBuilder.charAt(length) == \\' \\') {\\n            length--;\\n        }\\n        extraBuilder.setLength(length + 1);        \\n              \\n        \\n        return new String(val) + extraBuilder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580534,
                "title": "c-easy-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n=encodedText.size();\\n        int col=n/rows;\\n        string ans=\"\";\\n        for(int i=0;i<col;i++) // We have to just move column number of times in original string //\\n        {\\n            for(int j=i;j<n;j+=col+1)    // We get the next character at every column+1 ahead //\\n              ans+=encodedText[j];\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back();   // Remove the spaces at the end //\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int n=encodedText.size();\\n        int col=n/rows;\\n        string ans=\"\";\\n        for(int i=0;i<col;i++) // We have to just move column number of times in original string //\\n        {\\n            for(int j=i;j<n;j+=col+1)    // We get the next character at every column+1 ahead //\\n              ans+=encodedText[j];\\n        }\\n        while(ans.back()==\\' \\') ans.pop_back();   // Remove the spaces at the end //\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579425,
                "title": "simple-c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public string DecodeCiphertext(string encodedText, int rows)\\n    {\\n        int col = encodedText.Length / rows;\\n        char[] orginal = new char[encodedText.Length];\\n        int startc = 0;\\n        int c = 0;\\n        int length = 0;\\n        for (int i = 0; i < orginal.Length; i++)\\n        {\\n            int r = i % rows;\\n            if (r == 0)\\n                c = startc++;\\n            else\\n                c++;\\n            if (c >= col)\\n                break;\\n            orginal[i] = encodedText[r * col + c];\\n            length++;\\n        }\\n        return new string(orginal, 0, length).TrimEnd();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    public string DecodeCiphertext(string encodedText, int rows)\\n    {\\n        int col = encodedText.Length / rows;\\n        char[] orginal = new char[encodedText.Length];\\n        int startc = 0;\\n        int c = 0;\\n        int length = 0;\\n        for (int i = 0; i < orginal.Length; i++)\\n        {\\n            int r = i % rows;\\n            if (r == 0)\\n                c = startc++;\\n            else\\n                c++;\\n            if (c >= col)\\n                break;\\n            orginal[i] = encodedText[r * col + c];\\n            length++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1579310,
                "title": "cut-the-string-and-zip-longest-100-speed-100-memory",
                "content": "![image](https://assets.leetcode.com/users/images/58be7acc-e1a6-456c-8883-4bd064907f04_1636965633.6376953.png)\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1:\\n            return encodedText\\n        cols = len(encodedText) // rows\\n        matrix = [encodedText[i * cols + i: (i + 1) * cols] for i in range(rows)]\\n        return \"\".join(\"\".join(c)\\n                       for c in zip_longest(*matrix, fillvalue=\" \")).rstrip(\" \")\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        if rows == 1:\\n            return encodedText\\n        cols = len(encodedText) // rows\\n        matrix = [encodedText[i * cols + i: (i + 1) * cols] for i in range(rows)]\\n        return \"\".join(\"\".join(c)\\n                       for c in zip_longest(*matrix, fillvalue=\" \")).rstrip(\" \")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579257,
                "title": "c-easy-to-understand",
                "content": "```\\npublic class Solution {\\n      public string DecodeCiphertext(string encodedText, int rows)\\n        {\\n            if(rows == 1)\\n            {\\n                return encodedText;\\n            }\\n\\n            int cols = encodedText.Length / rows;\\n            char[,] matrix = new char[rows, cols];\\n            int it = 0;\\n            StringBuilder sb = new();\\n\\n            for (int i = 0; i < matrix.GetLength(0); i++)\\n            {\\n                for (int j = 0; j < matrix.GetLength(1); j++)\\n                {\\n                    matrix[i, j] = encodedText[it++];\\n                }\\n            }\\n\\n\\n            for (int i = 0; i < matrix.GetLength(1); i++)\\n            {\\n                int sI = 0, sJ = i;\\n\\n                while (sI < matrix.GetLength(0) && sJ < matrix.GetLength(1))\\n                {\\n                    sb.Append(matrix[sI, sJ]);\\n                    sI++; sJ++;\\n                }\\n            }\\n\\n            string res = sb.ToString().TrimEnd();\\n\\n            return res;\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n      public string DecodeCiphertext(string encodedText, int rows)\\n        {\\n            if(rows == 1)\\n            {\\n                return encodedText;\\n            }\\n\\n            int cols = encodedText.Length / rows;\\n            char[,] matrix = new char[rows, cols];\\n            int it = 0;\\n            StringBuilder sb = new();\\n\\n            for (int i = 0; i < matrix.GetLength(0); i++)\\n            {\\n                for (int j = 0; j < matrix.GetLength(1); j++)\\n                {\\n                    matrix[i, j] = encodedText[it++];\\n                }\\n            }\\n\\n\\n            for (int i = 0; i < matrix.GetLength(1); i++)\\n            {\\n                int sI = 0, sJ = i;\\n\\n                while (sI < matrix.GetLength(0) && sJ < matrix.GetLength(1))\\n                {\\n                    sb.Append(matrix[sI, sJ]);\\n                    sI++; sJ++;\\n                }\\n            }\\n\\n            string res = sb.ToString().TrimEnd();\\n\\n            return res;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579218,
                "title": "java-solution-o-n-5-lines",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0, cols=encodedText.length()/rows; i<cols; i++)\\n            for(int j=i; j<encodedText.length(); j+=(cols+1))\\n                sb.append(encodedText.charAt(j));\\n        return sb.toString().stripTrailing();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0, cols=encodedText.length()/rows; i<cols; i++)\\n            for(int j=i; j<encodedText.length(); j+=(cols+1))\\n                sb.append(encodedText.charAt(j));\\n        return sb.toString().stripTrailing();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578849,
                "title": "javascript-matrix-diagonal-traverse-180ms",
                "content": "```\\n///////////////////////////////////////////// Template //////////////////////////////////////////////////////////////////////////////\\nconst initialize2DArrayNew = (n, m) => { let data = []; for (let i = 0; i < n; i++) { let tmp = Array(m).fill(0); data.push(tmp); } return data; };\\nconst diagonal_traverse_topLeft_to_bottomRight = (g) => {\\n    let n = g.length;\\n    let m = g[0].length;\\n    let top = [];\\n    for (let j = 0; j < m; j++) { // first row as starting point\\n        let tmp = [];\\n        let share = 0; // shared increase control\\n        while (share < n && j + share < m) { // read Diagonally\\n            tmp.push(g[share][j + share]); // row++ col++\\n            share++;\\n        }\\n         if (tmp.length > 0) top.push(tmp);\\n    }\\n    return top;\\n};\\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst decodeCiphertext = (s, n) => {\\n    let sn = s.length;\\n    if (n == 1) return s;\\n    let m = sn / n;\\n    let g = initialize2DArrayNew(n, m);\\n    let idx = 0;\\n    for (let i = 0; i < n; i++) { // read string into matrix\\n        for (let j = 0; j < m; j++) {\\n            g[i][j] = s[idx];\\n            idx++;\\n        }\\n    }\\n    let res = \"\";\\n    let d = diagonal_traverse_topLeft_to_bottomRight(g); // get each diagonal traverse(d[i] array) from first row as starting point\\n    let start = 0; end = d.length - 1; // start: first diagonal starting point idx in d,  end: last diagonal starting point idx in d\\n    for (let i = d.length - 1; i >= start; i--) { // get end idx\\n        if (hasChar(d[i])) {\\n            end = i;\\n            break;\\n        }\\n    }\\n    for (let i = start; i <= end; i++) { // append ans from d[start] and d[end]\\n        if (i == end && start != end) { // d[end] last diagonal should ignore empty string in the end\\n            let curEnd = d[i].length - 1;\\n            for (let j = curEnd; j >= 0; j--) {\\n                let c = d[i][j];\\n                if (c != \\' \\') {\\n                    curEnd = j; // get the end index of d[end] last diagonal\\n                    break;\\n                }\\n            }\\n            for (let j = 0; j <= curEnd; j++)  res += d[i][j]; // append chars for last diagonal\\n        } else {\\n            for (const c of d[i]) res += c; // append all chars for all other diagonals\\n        }\\n    }\\n    return res;\\n};\\n\\nconst hasChar = (a) => {\\n    for (const c of a) {\\n        if (c != \\' \\') return true;\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Matrix"
                ],
                "code": "```\\n///////////////////////////////////////////// Template //////////////////////////////////////////////////////////////////////////////\\nconst initialize2DArrayNew = (n, m) => { let data = []; for (let i = 0; i < n; i++) { let tmp = Array(m).fill(0); data.push(tmp); } return data; };\\nconst diagonal_traverse_topLeft_to_bottomRight = (g) => {\\n    let n = g.length;\\n    let m = g[0].length;\\n    let top = [];\\n    for (let j = 0; j < m; j++) { // first row as starting point\\n        let tmp = [];\\n        let share = 0; // shared increase control\\n        while (share < n && j + share < m) { // read Diagonally\\n            tmp.push(g[share][j + share]); // row++ col++\\n            share++;\\n        }\\n         if (tmp.length > 0) top.push(tmp);\\n    }\\n    return top;\\n};\\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\nconst decodeCiphertext = (s, n) => {\\n    let sn = s.length;\\n    if (n == 1) return s;\\n    let m = sn / n;\\n    let g = initialize2DArrayNew(n, m);\\n    let idx = 0;\\n    for (let i = 0; i < n; i++) { // read string into matrix\\n        for (let j = 0; j < m; j++) {\\n            g[i][j] = s[idx];\\n            idx++;\\n        }\\n    }\\n    let res = \"\";\\n    let d = diagonal_traverse_topLeft_to_bottomRight(g); // get each diagonal traverse(d[i] array) from first row as starting point\\n    let start = 0; end = d.length - 1; // start: first diagonal starting point idx in d,  end: last diagonal starting point idx in d\\n    for (let i = d.length - 1; i >= start; i--) { // get end idx\\n        if (hasChar(d[i])) {\\n            end = i;\\n            break;\\n        }\\n    }\\n    for (let i = start; i <= end; i++) { // append ans from d[start] and d[end]\\n        if (i == end && start != end) { // d[end] last diagonal should ignore empty string in the end\\n            let curEnd = d[i].length - 1;\\n            for (let j = curEnd; j >= 0; j--) {\\n                let c = d[i][j];\\n                if (c != \\' \\') {\\n                    curEnd = j; // get the end index of d[end] last diagonal\\n                    break;\\n                }\\n            }\\n            for (let j = 0; j <= curEnd; j++)  res += d[i][j]; // append chars for last diagonal\\n        } else {\\n            for (const c of d[i]) res += c; // append all chars for all other diagonals\\n        }\\n    }\\n    return res;\\n};\\n\\nconst hasChar = (a) => {\\n    for (const c of a) {\\n        if (c != \\' \\') return true;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578764,
                "title": "from-tle-to-100",
                "content": "At first, I got TLE 37/39. And that case only has 1 row.\\n```\\nclass Solution(object):\\n    def decodeCiphertext(self, es, rows):\\n        \"\"\"\\n        :type encodedText: str\\n        :type rows: int\\n        :rtype: str\\n        \"\"\"\\n        mn=len(es)\\n        m=mn/rows\\n        mat=[]\\n        if m==0:\\n            return \"\"\\n        res=\"\"\\n        for j in range(m-rows+1):\\n            for i in range(rows):\\n                res+=es[i*m+i+j]\\n        j=m-rows+1\\n        for i in range(rows-1):\\n            res+=es[i*m+i+j]\\n        return res.rstrip()\\n```\\nThen I add one more condition for this case. It is 100%. \\n```\\nclass Solution(object):\\n    def decodeCiphertext(self, es, rows):\\n        \"\"\"\\n        :type encodedText: str\\n        :type rows: int\\n        :rtype: str\\n        \"\"\"\\n        mn=len(es)\\n        m=mn/rows\\n        mat=[]\\n        if m==0:\\n            return \"\"\\n        if rows==1:\\n            return es\\n        #print mat\\n        res=\"\"\\n        for j in range(m-rows+1):\\n            for i in range(rows):\\n                res+=es[i*m+i+j]\\n        j=m-rows+1\\n        for i in range(rows-1):\\n            res+=es[i*m+i+j]\\n        return res.rstrip()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def decodeCiphertext(self, es, rows):\\n        \"\"\"\\n        :type encodedText: str\\n        :type rows: int\\n        :rtype: str\\n        \"\"\"\\n        mn=len(es)\\n        m=mn/rows\\n        mat=[]\\n        if m==0:\\n            return \"\"\\n        res=\"\"\\n        for j in range(m-rows+1):\\n            for i in range(rows):\\n                res+=es[i*m+i+j]\\n        j=m-rows+1\\n        for i in range(rows-1):\\n            res+=es[i*m+i+j]\\n        return res.rstrip()\\n```\n```\\nclass Solution(object):\\n    def decodeCiphertext(self, es, rows):\\n        \"\"\"\\n        :type encodedText: str\\n        :type rows: int\\n        :rtype: str\\n        \"\"\"\\n        mn=len(es)\\n        m=mn/rows\\n        mat=[]\\n        if m==0:\\n            return \"\"\\n        if rows==1:\\n            return es\\n        #print mat\\n        res=\"\"\\n        for j in range(m-rows+1):\\n            for i in range(rows):\\n                res+=es[i*m+i+j]\\n        j=m-rows+1\\n        for i in range(rows-1):\\n            res+=es[i*m+i+j]\\n        return res.rstrip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578623,
                "title": "c-python3-worst-solution",
                "content": "C++\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int N = encodedText.size();\\n        int cols = N/rows;\\n        string re = \"\";\\n        for(int j=0;j<cols;++j){\\n            for(int k=j;k<=N;k+=cols+1 ){\\n                if(k==N){//optimizer: Return as soon as hitting the invalid index of encodedText\\n                    while(re.back()==\\' \\')\\n                        re.pop_back();\\n                    return re;\\n                }\\n                re += encodedText[k];\\n            }\\n        }\\n        return re;//In case never hitting the invalid index of encodedText.\\n    }\\n};\\n```\\n\\nPython 3\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        N = len(encodedText)\\n        cols = N//rows\\n        re = \"\"\\n        for j in range(cols):\\n            for k in range(j,N+1,cols+1):\\n                if(k==N): #Return as soon as hitting the invalid index of encodedText\\n                   return re.rstrip(\" \")\\n                re += encodedText[k];\\n        return re #In case never hitting the invalid index of encodedText.\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        int N = encodedText.size();\\n        int cols = N/rows;\\n        string re = \"\";\\n        for(int j=0;j<cols;++j){\\n            for(int k=j;k<=N;k+=cols+1 ){\\n                if(k==N){//optimizer: Return as soon as hitting the invalid index of encodedText\\n                    while(re.back()==\\' \\')\\n                        re.pop_back();\\n                    return re;\\n                }\\n                re += encodedText[k];\\n            }\\n        }\\n        return re;//In case never hitting the invalid index of encodedText.\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        N = len(encodedText)\\n        cols = N//rows\\n        re = \"\"\\n        for j in range(cols):\\n            for k in range(j,N+1,cols+1):\\n                if(k==N): #Return as soon as hitting the invalid index of encodedText\\n                   return re.rstrip(\" \")\\n                re += encodedText[k];\\n        return re #In case never hitting the invalid index of encodedText.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578508,
                "title": "python-3-simple-traversing-solution-better-time-and-memory-than-83-of-submission",
                "content": "\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        nrows = rows\\n        decoded_str = \"\"\\n        ncols = int(len(encodedText)/nrows)\\n        ## the total number of slanted lines will be equal to the number of columns. so we print each slanted line, indexed by j, using the first loop below.\\n\\t\\tfor j in range(ncols):\\n\\t\\t\\t## the \"first\" slanted lines will have a length equal to the number of rows but the slanted line near the end of string will have a length lower than the number of rows\\n\\t\\t\\t## because you will hit the final column, and it prevents you from having a slanted line with length of number of rows. the value i, shows the indices of rows that contribute\\n\\t\\t\\t## to the current slanted line ( indexed by j) before.\\n            for i in range(0,min(ncols-j, nrows)):\\n\\t\\t\\t\\t\\t\\t# addressing the value of encodedTextMatrix[i,j] without actually construcing the matrix from encodedText. you can replace this line with\\n\\t\\t\\t\\t\\t\\t# decoded_str += encodedTextMatrix[i,j] if you prefer to first reconstruct the encodedTextMatrix matrix to keep things nice and clean\\n                        decoded_str += encodedText[i*ncols+i+j]\\n        return decoded_str.rstrip(\" \")\\n                \\n```\\ntime complexity is O(n^2) as we add all elements from the original matrix (including the trailing spaces) and then will remove them. \\na simple modification can turn the algorithm to O(n) though. simply check if all of non-space characters are already added to decoded_str and in that case just stop.\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        nrows = rows\\n        decoded_str = \"\"\\n\\t\\t## keep track of characters from encodedText that were added to our to-be-returned result string (decoded_str)\\n        used_chars = defaultdict(int)\\n\\t\\t## length of non-space characters in encodedText\\n        all_chars = len([encodedText[i] for i in range(len(encodedText)) if encodedText[i]!=\" \"])\\n        ncols = int(len(encodedText)/nrows)\\n        for j in range(ncols):\\n\\t\\t\\t# check if all non-space characters from encodedText are already added to decoded_str\\n            if len(used_chars) == all_chars:\\n                break       \\n            for i in range(0,min(ncols-j, nrows)):\\n                        ind = i*ncols+i+j\\n\\t\\t\\t\\t\\t\\t## if current chracter is not space, add it to used_chars\\n                        if encodedText[ind] != \" \":\\n                            used_chars[ind] = 1\\n                        decoded_str += encodedText[ind]\\n\\t\\t# we may still have a few (less than n) spaced at the end of string but it doesn\\'t affect time complexity and can get stripped simply. \\n\\t\\t#the reason is that you can\\'t break from the inner loop in a nested loops in python! and doing that would make the code a bit ugly\\n        return decoded_str.rstrip(\" \")\\n                \\n```\\ntime complexity O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        nrows = rows\\n        decoded_str = \"\"\\n        ncols = int(len(encodedText)/nrows)\\n        ## the total number of slanted lines will be equal to the number of columns. so we print each slanted line, indexed by j, using the first loop below.\\n\\t\\tfor j in range(ncols):\\n\\t\\t\\t## the \"first\" slanted lines will have a length equal to the number of rows but the slanted line near the end of string will have a length lower than the number of rows\\n\\t\\t\\t## because you will hit the final column, and it prevents you from having a slanted line with length of number of rows. the value i, shows the indices of rows that contribute\\n\\t\\t\\t## to the current slanted line ( indexed by j) before.\\n            for i in range(0,min(ncols-j, nrows)):\\n\\t\\t\\t\\t\\t\\t# addressing the value of encodedTextMatrix[i,j] without actually construcing the matrix from encodedText. you can replace this line with\\n\\t\\t\\t\\t\\t\\t# decoded_str += encodedTextMatrix[i,j] if you prefer to first reconstruct the encodedTextMatrix matrix to keep things nice and clean\\n                        decoded_str += encodedText[i*ncols+i+j]\\n        return decoded_str.rstrip(\" \")\\n                \\n```\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def decodeCiphertext(self, encodedText: str, rows: int) -> str:\\n        nrows = rows\\n        decoded_str = \"\"\\n\\t\\t## keep track of characters from encodedText that were added to our to-be-returned result string (decoded_str)\\n        used_chars = defaultdict(int)\\n\\t\\t## length of non-space characters in encodedText\\n        all_chars = len([encodedText[i] for i in range(len(encodedText)) if encodedText[i]!=\" \"])\\n        ncols = int(len(encodedText)/nrows)\\n        for j in range(ncols):\\n\\t\\t\\t# check if all non-space characters from encodedText are already added to decoded_str\\n            if len(used_chars) == all_chars:\\n                break       \\n            for i in range(0,min(ncols-j, nrows)):\\n                        ind = i*ncols+i+j\\n\\t\\t\\t\\t\\t\\t## if current chracter is not space, add it to used_chars\\n                        if encodedText[ind] != \" \":\\n                            used_chars[ind] = 1\\n                        decoded_str += encodedText[ind]\\n\\t\\t# we may still have a few (less than n) spaced at the end of string but it doesn\\'t affect time complexity and can get stripped simply. \\n\\t\\t#the reason is that you can\\'t break from the inner loop in a nested loops in python! and doing that would make the code a bit ugly\\n        return decoded_str.rstrip(\" \")\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578401,
                "title": "detailed-explanation-pictures-included-time-complexity-o-n-c",
                "content": "Lets take an Example of \\n\"iveo    eed   l te   olc\", rows = 4\\n![image](https://assets.leetcode.com/users/images/0e48373f-3ed3-436a-bdb7-15bb3da81f00_1636918352.7840478.png)\\n\\nFor the final answer , we can assume ,\\nour final matrix will look like \\n\\n![image](https://assets.leetcode.com/users/images/700fb0e5-ccc7-40d1-a66b-1de51d4345a2_1636918445.377144.png)\\n\\n( all the element at 0,0 will be appended , same for 0,1 )\\nSo for the (0,0) we\\'ll have \\n![image](https://assets.leetcode.com/users/images/2d640e3c-dfad-4ac8-b982-eb4faa804904_1636919025.3151329.png)\\nto->\\n\\n![image](https://assets.leetcode.com/users/images/4cef7439-0431-4828-a09b-50e4efa7d105_1636919300.2266514.png)\\n\\nand for (0,1)\\nwe have \\n![image](https://assets.leetcode.com/users/images/72e759aa-b918-4a08-9a0f-97831722ddb1_1636919551.0411148.png)\\nand so on .\\nWith little manupulation , we can omit the 2D array and it can we solved with 1D ,\\nbecause \\nall the (0,0) cells can we appended at index 0 in 1D array , \\nall the (0,1) cells can we appended at index 1 in 1D array              \\nall the (0,2) cells can we appended at index 2 in 1D array\\nand so on . \\n\\n```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows ==1){\\n            return encodedText;\\n        }\\n        if(encodedText.size()==0){\\n            return \"\";\\n        }\\n        int cols = encodedText.size()/rows;\\n        vector<string>temp(cols,\"\");\\n \\n        int c = -1;\\n        for(int i = 0;i<encodedText.size();i++){\\n            if(i%cols == 0){\\n                c++;\\n            }\\n            \\n            if((i%cols)-c >=0)\\n            temp[(i%cols)-c] += encodedText[i];\\n        }\\n        string ans = \"\";\\n        for(auto x: temp){\\n            ans = ans+x;\\n        }\\n        int n = ans.size()-1;\\n        c = 0;\\n        while(ans[n]==\\' \\'){\\n            n--;\\n            c++;\\n        }\\n        ans = ans.substr(0,ans.size()-c);\\n        return ans;\\n    }\\n};\\n```\\nTime complexity O(n) : n-> size of encodedText . \\nHope , it helps :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        if(rows ==1){\\n            return encodedText;\\n        }\\n        if(encodedText.size()==0){\\n            return \"\";\\n        }\\n        int cols = encodedText.size()/rows;\\n        vector<string>temp(cols,\"\");\\n \\n        int c = -1;\\n        for(int i = 0;i<encodedText.size();i++){\\n            if(i%cols == 0){\\n                c++;\\n            }\\n            \\n            if((i%cols)-c >=0)\\n            temp[(i%cols)-c] += encodedText[i];\\n        }\\n        string ans = \"\";\\n        for(auto x: temp){\\n            ans = ans+x;\\n        }\\n        int n = ans.size()-1;\\n        c = 0;\\n        while(ans[n]==\\' \\'){\\n            n--;\\n            c++;\\n        }\\n        ans = ans.substr(0,ans.size()-c);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578400,
                "title": "golang-solution",
                "content": "```\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n    cols := len(encodedText)/rows\\n    var sb strings.Builder\\n    for i:=0;i<cols;i++ {\\n        for j:=i;j<len(encodedText);j+=cols+1 {\\n            sb.WriteByte(encodedText[j])\\n        }\\n    }\\n    return strings.TrimRight(sb.String(), \" \")\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc decodeCiphertext(encodedText string, rows int) string {\\n    cols := len(encodedText)/rows\\n    var sb strings.Builder\\n    for i:=0;i<cols;i++ {\\n        for j:=i;j<len(encodedText);j+=cols+1 {\\n            sb.WriteByte(encodedText[j])\\n        }\\n    }\\n    return strings.TrimRight(sb.String(), \" \")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578265,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length();\\n        int cols = n/rows,index=0;\\n        char[][] array = new char[rows][cols];\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                array[i][j]=encodedText.charAt(index++);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<cols;i++){\\n            int start=0,end=i;\\n            StringBuilder curr = new StringBuilder();\\n            while(start<rows && end<cols){\\n                curr.append(array[start][end]);\\n                start++;end++;\\n            }\\n            sb.append(curr);\\n        }\\n        int len = sb.length();\\n        int i=len-1;\\n        for(;i>=0&&sb.charAt(i)==\\' \\';i--);\\n        return sb.toString().substring(0,i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        int n = encodedText.length();\\n        int cols = n/rows,index=0;\\n        char[][] array = new char[rows][cols];\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                array[i][j]=encodedText.charAt(index++);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<cols;i++){\\n            int start=0,end=i;\\n            StringBuilder curr = new StringBuilder();\\n            while(start<rows && end<cols){\\n                curr.append(array[start][end]);\\n                start++;end++;\\n            }\\n            sb.append(curr);\\n        }\\n        int len = sb.length();\\n        int i=len-1;\\n        for(;i>=0&&sb.charAt(i)==\\' \\';i--);\\n        return sb.toString().substring(0,i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578209,
                "title": "c-o-n-solution",
                "content": "```\\nstring decodeCiphertext(string str, int rows) {\\n        if(rows==1)\\n            return str;\\n        string res;\\n        int n=rows, m=str.size()/rows, i=0,j=0,x,y;\\n        \\n        while(j<m) {\\n            \\n            x=i; y=j;\\n            while(x<n && y<m) {\\n                res.push_back(str[x*m + y]);\\n                ++x;\\n                ++y;\\n            }\\n            ++j;\\n        }        \\n        while(res.size() && res.back()==\\' \\')\\n            res.pop_back();\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring decodeCiphertext(string str, int rows) {\\n        if(rows==1)\\n            return str;\\n        string res;\\n        int n=rows, m=str.size()/rows, i=0,j=0,x,y;\\n        \\n        while(j<m) {\\n            \\n            x=i; y=j;\\n            while(x<n && y<m) {\\n                res.push_back(str[x*m + y]);\\n                ++x;\\n                ++y;\\n            }\\n            ++j;\\n        }        \\n        while(res.size() && res.back()==\\' \\')\\n            res.pop_back();\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578132,
                "title": "java-solution-with-clean-code",
                "content": "```\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if (rows == 1) {\\n            return encodedText;\\n        }\\n\\n        int columns = encodedText.length() / rows;\\n\\n        char[][] matrix = new char[rows][columns];\\n        for (int i = 0; i < rows; i++) {\\n            matrix[i] = encodedText.substring(i * columns, (i + 1) * columns).toCharArray();\\n        }\\n\\n        StringBuilder result = new StringBuilder();\\n\\n        for (int i = 0; i < columns; i++) {\\n            int counter = i;\\n            for (int j = 0; j < rows; j++) {\\n                if (counter < columns) {\\n                    result.append(matrix[j][counter++]);\\n                }\\n            }\\n        }\\n\\n        return result.toString().replaceAll(\"\\\\\\\\s+$\", \"\");\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public String decodeCiphertext(String encodedText, int rows) {\\n        if (rows == 1) {\\n            return encodedText;\\n        }\\n\\n        int columns = encodedText.length() / rows;\\n\\n        char[][] matrix = new char[rows][columns];\\n        for (int i = 0; i < rows; i++) {\\n            matrix[i] = encodedText.substring(i * columns, (i + 1) * columns).toCharArray();\\n        }\\n\\n        StringBuilder result = new StringBuilder();\\n\\n        for (int i = 0; i < columns; i++) {\\n            int counter = i;\\n            for (int j = 0; j < rows; j++) {\\n                if (counter < columns) {\\n                    result.append(matrix[j][counter++]);\\n                }\\n            }\\n        }\\n\\n        return result.toString().replaceAll(\"\\\\\\\\s+$\", \"\");\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578068,
                "title": "c-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string last_string=\"\",ans=\"\",anss=\"\";\\n        if (encodedText.length()==0) \\n            return \"\";\\n        int col= encodedText.size()/rows;\\n        if (col==0 || rows==1) return encodedText;\\n        char mat[rows][col];\\n        // to keep track of the visited diagonals\\n        vector<vector<int>> visited(rows, vector<int>(col, 0));\\n        int k=0;\\n        for (int i=0;i<rows;i++){\\n            for (int j=0;j<col;j++){\\n                mat[i][j]=encodedText[k];\\n                k++;\\n            }\\n        }\\n        // once we visit a diagonal mark all the elements as in visited matrix 1 to ensure we dont visit same diagonal to reuce time complexity\\n        for (int i=0;i<rows;i++){\\n            for (int j=0;j<col;j++){\\n                int a=i,b=j;\\n                if (visited[a][b]==0){\\n                   while (a< rows && b < col){\\n                         ans+=mat[a][b];\\n                         visited[a][b]=1;\\n                         a++;\\n                         b++;\\n                    }\\n                }\\n            }\\n        }\\n        int i=ans.length()-1;\\n        // to erase trailing spaces in answer\\n        while (ans[i]==\\' \\'){\\n            ans.pop_back();\\n            i--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string decodeCiphertext(string encodedText, int rows) {\\n        string last_string=\"\",ans=\"\",anss=\"\";\\n        if (encodedText.length()==0) \\n            return \"\";\\n        int col= encodedText.size()/rows;\\n        if (col==0 || rows==1) return encodedText;\\n        char mat[rows][col];\\n        // to keep track of the visited diagonals\\n        vector<vector<int>> visited(rows, vector<int>(col, 0));\\n        int k=0;\\n        for (int i=0;i<rows;i++){\\n            for (int j=0;j<col;j++){\\n                mat[i][j]=encodedText[k];\\n                k++;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1738999,
                "content": [
                    {
                        "username": "ranjeet43",
                        "content": "Approach 1:\\nIntuition :\\n\\nIdea here is to just do what we are asked to perform. That is simulate decoding steps.\\n\\nFirst, we need to make cipher matrix using encodedText.\\n\\nThen, for each column in first row, we traverse diagonally and add those characters to decodedText string.\\n\\nIn the end, since trailing spaces are not allowed, so we remove it from decodedString.\\n\\nWe can have two cases.\\n\\nOne when rows = 1. In this case, we decodedText is same as encodedText.\\nAnd other when rows > 1. In this, we need to perform above simulation.\\nLets understand through simple example :\\n\\n  Case 1 : if rows == 1\\n  \\t\\t\\t\\t\\n    Ex: \"c o d i n g\"\\n      \\n  \\t-> In this case we do not need to decode text. We can simply return encodedText directly. \\n  \\t-> This is because all characters are in first row.\\n  \\n  Case 2: if rows > 1\\n  \\t\\t\\t\\t\\n  \\tEx: encodedText = \"ch   ie   pr\" , rows = 3\\n  \\t\\n  \\tcipher matrix : \\n  \\t\\t  \"c h _ _\\n  \\t       _ i e _  \\n  \\t\\t   _ _ p r\"\\n     \\n     -> Note : Here, just for sake of explanation, I have take space(\" \") as underscore(_).\\n     \\n      i. k = 0 => {(0,0) : \\'c\\'}, {(1,1) : \\'i\\'}, {(2,2) : \\'p\\'} \\n      ii. k = 1 => {(0,1) : \\'h\\'}, {(1,2) : \\'e\\'}, {(2,3) : \\'r\\'}\\n  \\tiii. k = 2 => {(0,2) : \\'_\\'}, {(1,3) : \\'_\\'}\\n  \\t\\n  \\tThus, decodedString with trailing spaces = \"cipher_ _\". \\n  \\tWe need to remove these trailing spaces, and then return resultant string.\\n  \\n  \\t"
                    }
                ]
            }
        ]
    },
    {
        "title": "Process Restricted Friend Requests",
        "question_content": "<p>You are given an integer <code>n</code> indicating the number of people in a network. Each person is labeled from <code>0</code> to <code>n - 1</code>.</p>\n\n<p>You are also given a <strong>0-indexed</strong> 2D integer array <code>restrictions</code>, where <code>restrictions[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> means that person <code>x<sub>i</sub></code> and person <code>y<sub>i</sub></code> <strong>cannot </strong>become <strong>friends</strong>,<strong> </strong>either <strong>directly</strong> or <strong>indirectly</strong> through other people.</p>\n\n<p>Initially, no one is friends with each other. You are given a list of friend requests as a <strong>0-indexed</strong> 2D integer array <code>requests</code>, where <code>requests[j] = [u<sub>j</sub>, v<sub>j</sub>]</code> is a friend request between person <code>u<sub>j</sub></code> and person <code>v<sub>j</sub></code>.</p>\n\n<p>A friend request is <strong>successful </strong>if <code>u<sub>j</sub></code> and <code>v<sub>j</sub></code> can be <strong>friends</strong>. Each friend request is processed in the given order (i.e., <code>requests[j]</code> occurs before <code>requests[j + 1]</code>), and upon a successful request, <code>u<sub>j</sub></code> and <code>v<sub>j</sub></code> <strong>become direct friends</strong> for all future friend requests.</p>\n\n<p>Return <em>a <strong>boolean array</strong> </em><code>result</code>,<em> where each </em><code>result[j]</code><em> is </em><code>true</code><em> if the </em><code>j<sup>th</sup></code><em> friend request is <strong>successful</strong> or </em><code>false</code><em> if it is not</em>.</p>\n\n<p><strong>Note:</strong> If <code>u<sub>j</sub></code> and <code>v<sub>j</sub></code> are already direct friends, the request is still <strong>successful</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]\n<strong>Output:</strong> [true,false]\n<strong>Explanation:\n</strong>Request 0: Person 0 and person 2 can be friends, so they become direct friends. \nRequest 1: Person 2 and person 1 cannot be friends since person 0 and person 1 would be indirect friends (1--2--0).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]]\n<strong>Output:</strong> [true,false]\n<strong>Explanation:\n</strong>Request 0: Person 1 and person 2 can be friends, so they become direct friends.\nRequest 1: Person 0 and person 2 cannot be friends since person 0 and person 1 would be indirect friends (0--2--1).\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]]\n<strong>Output:</strong> [true,false,true,false]\n<strong>Explanation:\n</strong>Request 0: Person 0 and person 4 can be friends, so they become direct friends.\nRequest 1: Person 1 and person 2 cannot be friends since they are directly restricted.\nRequest 2: Person 3 and person 1 can be friends, so they become direct friends.\nRequest 3: Person 3 and person 4 cannot be friends since person 0 and person 1 would be indirect friends (0--4--3--1).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= restrictions.length &lt;= 1000</code></li>\n\t<li><code>restrictions[i].length == 2</code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= n - 1</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li><code>1 &lt;= requests.length &lt;= 1000</code></li>\n\t<li><code>requests[j].length == 2</code></li>\n\t<li><code>0 &lt;= u<sub>j</sub>, v<sub>j</sub> &lt;= n - 1</code></li>\n\t<li><code>u<sub>j</sub> != v<sub>j</sub></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1576935,
                "title": "c-union-find",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Union Find\\n\\nGiven the constraints, a solution with `O(R * B)` is acceptable -- for each request, check if it obeys all the bans.\\n\\nFor the check, we can do it in `O(1)` time using UnionFind. For each prior valid requests, we connect the two friends. For a new request, we just need to check if the leaders of the two parties are in any of those bans.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/process-restricted-friend-requests/\\n// Author: github.com/lzl124631x\\n// Time: O(R * B) where `R`/`B` is the length of `requests`/`bans`\\n// Space: O(N)\\nclass UnionFind {\\n    vector<int> id;\\npublic:\\n    UnionFind(int n) : id(n) {\\n        iota(begin(id), end(id), 0);\\n    }\\n    void connect(int a, int b) {\\n        id[find(a)] = find(b);\\n    }\\n    int find(int a) {\\n        return id[a] == a ? a : (id[a] = find(id[a]));\\n    }\\n    int connected(int a, int b) {\\n        return find(a) == find(b);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& bans, vector<vector<int>>& requests) {\\n        vector<bool> ans;\\n        UnionFind uf(n);\\n        for (auto &r : requests) {\\n            int p = uf.find(r[0]), q = uf.find(r[1]); // the leaders of the two parties\\n            bool valid = true;\\n            if (!uf.connected(p, q)) { // Only need to check the bans if the two parties are not already connected\\n                for (auto &b : bans) {\\n                    int x = uf.find(b[0]), y = uf.find(b[1]); // the leaders of the two banned parties\\n                    if ((x == p && y == q) || (x == q && y == p)) {\\n                        valid = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            ans.push_back(valid);\\n            if (valid) uf.connect(p, q); // connect two parties if request is valid\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/process-restricted-friend-requests/\\n// Author: github.com/lzl124631x\\n// Time: O(R * B) where `R`/`B` is the length of `requests`/`bans`\\n// Space: O(N)\\nclass UnionFind {\\n    vector<int> id;\\npublic:\\n    UnionFind(int n) : id(n) {\\n        iota(begin(id), end(id), 0);\\n    }\\n    void connect(int a, int b) {\\n        id[find(a)] = find(b);\\n    }\\n    int find(int a) {\\n        return id[a] == a ? a : (id[a] = find(id[a]));\\n    }\\n    int connected(int a, int b) {\\n        return find(a) == find(b);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& bans, vector<vector<int>>& requests) {\\n        vector<bool> ans;\\n        UnionFind uf(n);\\n        for (auto &r : requests) {\\n            int p = uf.find(r[0]), q = uf.find(r[1]); // the leaders of the two parties\\n            bool valid = true;\\n            if (!uf.connected(p, q)) { // Only need to check the bans if the two parties are not already connected\\n                for (auto &b : bans) {\\n                    int x = uf.find(b[0]), y = uf.find(b[1]); // the leaders of the two banned parties\\n                    if ((x == p && y == q) || (x == q && y == p)) {\\n                        valid = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            ans.push_back(valid);\\n            if (valid) uf.connect(p, q); // connect two parties if request is valid\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576913,
                "title": "python-usual-union-find-explained",
                "content": "The idea is that given problem constraints, we can allow to use union find. The idea is to traverse `x, y in requests` and check if we can make these persons friends or not. We can make them if we do not have restrictions: we go through all restrictions and check that we do not have restriction for two given connected components.\\n\\n#### Complexity\\nIt is `O(n * m * log(n))` for time and `O(n)` for space, where `m = len(requests)`.\\n\\n```python\\nclass DSU:\\n    def __init__(self, N):\\n        self.p = list(range(N))\\n\\n    def find(self, x):\\n        if self.p[x] != x:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n\\n    def union(self, x, y):\\n        xr = self.find(x)\\n        yr = self.find(y)\\n        self.p[xr] = yr\\n\\nclass Solution:\\n    def friendRequests(self, n, restr, requests):\\n        dsu, ans = DSU(n), []\\n        for x, y in requests:\\n            x_p, y_p = dsu.find(x), dsu.find(y)\\n            bad = True\\n            for a, b in restr:\\n                a_p, b_p = dsu.find(a), dsu.find(b)\\n                if set([a_p, b_p]) == set([x_p, y_p]):\\n                    bad = False\\n                    break\\n                    \\n            ans += [bad]\\n            if bad: dsu.union(x, y)\\n                \\n        return ans\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```python\\nclass DSU:\\n    def __init__(self, N):\\n        self.p = list(range(N))\\n\\n    def find(self, x):\\n        if self.p[x] != x:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n\\n    def union(self, x, y):\\n        xr = self.find(x)\\n        yr = self.find(y)\\n        self.p[xr] = yr\\n\\nclass Solution:\\n    def friendRequests(self, n, restr, requests):\\n        dsu, ans = DSU(n), []\\n        for x, y in requests:\\n            x_p, y_p = dsu.find(x), dsu.find(y)\\n            bad = True\\n            for a, b in restr:\\n                a_p, b_p = dsu.find(a), dsu.find(b)\\n                if set([a_p, b_p]) == set([x_p, y_p]):\\n                    bad = False\\n                    break\\n                    \\n            ans += [bad]\\n            if bad: dsu.union(x, y)\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576912,
                "title": "c-union-find-simple-straightforward-idea-explained",
                "content": "\\n\\nThis problem is generous in terms of constraints and we can leverage that to come up with an easily understandable solution!\\n\\n**Union Find**\\nA Union Find data structure, also known as the Disjoint Set data structure, stores a collection of disjoint (non overlapping) sets. It mainly has two operations:\\n* Union(x, y): It unifies the two arguments into a single set\\n* Find(x): It finds the root or the parent of the set which the argument belongs to.\\n\\nThis data structure is perfect for our current problem as we can group all the friends in disjoint sets and make use of the operations to efficiently do so. I also employ something known as path compression which makes the complexity of both *union* and *find* operations to be amortized O(1). You can learn more about Union Find on Hackerearth and GFG. In fact, I have prepared my template from these sites. \\n\\n**Idea**\\nNow that it is clear we are going to use Union Find here, let us proceed to discussing about how exactly are we planning to do so. \\nThe idea is simple and straightforward. We maintain a Union Find data structure which stores all the friends. When we encounter a new friend request, we *accept* it but not really! What I mean is we temporarily accept to check whether it causes any violation of the restrictions or not. \\nHow do we do so? \\nBy making a copy of our Union Find data structure and unifying the participants of the request in the copy. Then we traverse the list of restrictions and individually check if we are violating any. This is done by checking that the roots/parents of the members of the restriction are same or not. If they are, then they belong to the same friend group which is a violation. If we face no violations, then we can *accept* this friend request in our original data structure as well.\\n\\nThat\\'s it!\\n\\nThe code might look big, but that is only because of the template. \\n\\n**C++**\\n```\\nclass UnionFind {\\npublic:\\n    vector<int> parent;\\n\\n    UnionFind(int n) {\\n        parent.resize(n + 1, -1);\\n    }\\n\\n    int find(int x) {\\n        int root = x;\\n        while (parent[root] >= 0) {\\n            root = parent[root];\\n        }\\n\\n        // Path Compression\\n        while (parent[x] >= 0) {\\n            int next = parent[x];\\n            parent[x] = root;\\n            x = next;\\n        }\\n\\n        return root;\\n    }\\n\\n    void unionz(int x, int y) {\\n        int root1 = find(x);\\n        int root2 = find(y);\\n\\n        if (root1 == root2)\\n            return;\\n\\n        if (parent[root1] < parent[root2]) {\\n            parent[root1] += parent[root2];\\n            parent[root2] = root1;\\n        } else {\\n            parent[root2] += parent[root1];\\n            parent[root1] = root2;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int m = requests.size();\\n        vector<bool> ans(m, 0);\\n        \\n        UnionFind UF(n);\\n        \\n        for(int i = 0; i < m; i++) {\\n            UnionFind temp = UF;\\n            temp.unionz(requests[i][0], requests[i][1]);\\n            bool flag = true;\\n            for(vector<int>& v : restrictions) {\\n                if(temp.find(v[0]) == temp.find(v[1])) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag) {\\n                ans[i] = true;\\n                UF.unionz(requests[i][0], requests[i][1]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\n*Space Complexity (Auxiliary): O(n)*\\n*Time Complexity: O(m * n)*",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind {\\npublic:\\n    vector<int> parent;\\n\\n    UnionFind(int n) {\\n        parent.resize(n + 1, -1);\\n    }\\n\\n    int find(int x) {\\n        int root = x;\\n        while (parent[root] >= 0) {\\n            root = parent[root];\\n        }\\n\\n        // Path Compression\\n        while (parent[x] >= 0) {\\n            int next = parent[x];\\n            parent[x] = root;\\n            x = next;\\n        }\\n\\n        return root;\\n    }\\n\\n    void unionz(int x, int y) {\\n        int root1 = find(x);\\n        int root2 = find(y);\\n\\n        if (root1 == root2)\\n            return;\\n\\n        if (parent[root1] < parent[root2]) {\\n            parent[root1] += parent[root2];\\n            parent[root2] = root1;\\n        } else {\\n            parent[root2] += parent[root1];\\n            parent[root1] = root2;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int m = requests.size();\\n        vector<bool> ans(m, 0);\\n        \\n        UnionFind UF(n);\\n        \\n        for(int i = 0; i < m; i++) {\\n            UnionFind temp = UF;\\n            temp.unionz(requests[i][0], requests[i][1]);\\n            bool flag = true;\\n            for(vector<int>& v : restrictions) {\\n                if(temp.find(v[0]) == temp.find(v[1])) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag) {\\n                ans[i] = true;\\n                UF.unionz(requests[i][0], requests[i][1]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576992,
                "title": "python-union-friends",
                "content": "# **Explanation**\\nUse union-found to union friends.\\nFor each request, check if doesn\\'t obey any restrictions.\\n<br>\\n\\n# **Complexity**\\nUnion-find operation with rank and path comression,has amotized `O(1)`\\nTime `O(requests * restrictions)`\\nSpace `O(n)`\\n<br>\\n\\n**Python**\\n```py\\n    def friendRequests(self, n, restrictions, requests):\\n        uf = {i: i for i in xrange(n)}\\n        res = []\\n\\n        def find(i):\\n            if i != uf[i]:\\n                uf[i] = find(uf[i])\\n            return uf[i]\\n\\n        for i, j in requests:\\n            success = True\\n            pi, pj = find(i), find(j)\\n            if pi != pj:\\n                for x, y in restrictions:\\n                    px, py = find(x), find(y)\\n                    if (px, py) == (pi, pj) or (px, py) == (pj, pi):\\n                        success = False\\n                        break\\n            if success:\\n                uf[pj] = pi\\n            res.append(success)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def friendRequests(self, n, restrictions, requests):\\n        uf = {i: i for i in xrange(n)}\\n        res = []\\n\\n        def find(i):\\n            if i != uf[i]:\\n                uf[i] = find(uf[i])\\n            return uf[i]\\n\\n        for i, j in requests:\\n            success = True\\n            pi, pj = find(i), find(j)\\n            if pi != pj:\\n                for x, y in restrictions:\\n                    px, py = find(x), find(y)\\n                    if (px, py) == (pi, pj) or (px, py) == (pj, pi):\\n                        success = False\\n                        break\\n            if success:\\n                uf[pj] = pi\\n            res.append(success)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1577293,
                "title": "python-union-find-beat-100-by-updating-restrictions",
                "content": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        parents = [i for i in range(n)]\\n        ranks = [0] * n\\n        forbidden = collections.defaultdict(set)\\n        for i, j in restrictions:\\n            forbidden[i].add(j)\\n            forbidden[j].add(i)\\n        \\n        def find(i):\\n            if i != parents[i]:\\n                parents[i] = find(parents[i])\\n            return parents[i]\\n        \\n        def union(p1, p2):\\n            if ranks[p1] > ranks[p2]:\\n                parents[p2] = p1\\n            elif ranks[p1] < ranks[p2]:\\n                parents[p1] = p2\\n                p1, p2 = p2, p1\\n            else:\\n                ranks[p1] += 1\\n                parents[p2] = p1\\n                \\n            forbidden[p1] |= forbidden[p2]\\n            for i in forbidden[p2]:\\n                forbidden[i].remove(p2)\\n                forbidden[i].add(p1)\\n            del forbidden[p2]\\n        \\n        ans = []\\n        for i, j in requests:\\n            p1 = find(i)\\n            p2 = find(j)\\n            if p1 == p2:\\n                ans.append(True)         \\n            elif p2 in forbidden[p1]:\\n                ans.append(False)\\n            else:\\n                union(p1, p2)\\n                ans.append(True)\\n\\n        return ans\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        parents = [i for i in range(n)]\\n        ranks = [0] * n\\n        forbidden = collections.defaultdict(set)\\n        for i, j in restrictions:\\n            forbidden[i].add(j)\\n            forbidden[j].add(i)\\n        \\n        def find(i):\\n            if i != parents[i]:\\n                parents[i] = find(parents[i])\\n            return parents[i]\\n        \\n        def union(p1, p2):\\n            if ranks[p1] > ranks[p2]:\\n                parents[p2] = p1\\n            elif ranks[p1] < ranks[p2]:\\n                parents[p1] = p2\\n                p1, p2 = p2, p1\\n            else:\\n                ranks[p1] += 1\\n                parents[p2] = p1\\n                \\n            forbidden[p1] |= forbidden[p2]\\n            for i in forbidden[p2]:\\n                forbidden[i].remove(p2)\\n                forbidden[i].add(p1)\\n            del forbidden[p2]\\n        \\n        ans = []\\n        for i, j in requests:\\n            p1 = find(i)\\n            p2 = find(j)\\n            if p1 == p2:\\n                ans.append(True)         \\n            elif p2 in forbidden[p1]:\\n                ans.append(False)\\n            else:\\n                union(p1, p2)\\n                ans.append(True)\\n\\n        return ans\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578306,
                "title": "java-clean-and-commented-code-with-explanation-union-find-algorithm",
                "content": "**PREREQUISITE: UNION-FIND ALGORITHM**\\n\\nThis problem is pretty straightforwad. Basically they are saying that two people can be friends if they have no restrictions or any of their mutual friends have no restriction.\\n\\nThe simplest way to solve this would be to use the union-find technique to link all the persons with mutual friends to one common ancestor. Now for every request we simply check that whether those ancestors have any restrictions or not. If they do they can\\'t be friends or else they can be.\\n\\n**EDIT - There is a nice optimization that could be done inside findParent, check @chinghsuanwei0206\\'s comment for explanation.**\\n\\nHere is the code for the same,\\n\\n```\\nclass Solution {\\n    \\n    //Classic Union-Find Algorithm to find Common Ancestor\\n    private int findParent(int[] parent, int index) {\\n        if(parent[index] == index) return index;\\n        return findParent(parent, parent[index]);\\n    }\\n   \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int resLength = restrictions.length, reqLength = requests.length;\\n        boolean[] result = new boolean[reqLength];\\n        int[] parent = new int[n];\\n        \\n        //Initially ith person\\'s parent is i itself\\n        for(int i = 0; i < n; i++) parent[i] = i;\\n        \\n\\n        for(int i = 0; i < reqLength; i++) {\\n            //finding the parents of the first person and second person of ith request\\n            int firstParent = findParent(parent, requests[i][0]);\\n            int secondParent = findParent(parent, requests[i][1]);\\n            \\n            //if they have same parents i.e. mutual friends they can be friends\\n            if(firstParent == secondParent) {\\n                result[i] = true;\\n                continue;\\n            }\\n            \\n            //iterating through the restrictions array to find whether the parents of first ans second person have a conflict \\n            boolean flag = true;\\n            for(int j = 0; j < resLength; j++) {\\n                //finding parents of the restriction persons\\n                int firstRestriction = findParent(parent, restrictions[j][0]);\\n                int secondRestriction = findParent(parent, restrictions[j][1]);\\n                \\n                //if any of the parents are matching i.e. if the parents of first and second person have a mutual conflict they can\\'t be friend\\n                if((firstRestriction == firstParent && secondRestriction == secondParent) || (secondRestriction == firstParent && firstRestriction == secondParent)) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag) {\\n                result[i] = true;\\n                parent[firstParent] = secondParent; //setting the common ancestor -> classic union find technique\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //Classic Union-Find Algorithm to find Common Ancestor\\n    private int findParent(int[] parent, int index) {\\n        if(parent[index] == index) return index;\\n        return findParent(parent, parent[index]);\\n    }\\n   \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int resLength = restrictions.length, reqLength = requests.length;\\n        boolean[] result = new boolean[reqLength];\\n        int[] parent = new int[n];\\n        \\n        //Initially ith person\\'s parent is i itself\\n        for(int i = 0; i < n; i++) parent[i] = i;\\n        \\n\\n        for(int i = 0; i < reqLength; i++) {\\n            //finding the parents of the first person and second person of ith request\\n            int firstParent = findParent(parent, requests[i][0]);\\n            int secondParent = findParent(parent, requests[i][1]);\\n            \\n            //if they have same parents i.e. mutual friends they can be friends\\n            if(firstParent == secondParent) {\\n                result[i] = true;\\n                continue;\\n            }\\n            \\n            //iterating through the restrictions array to find whether the parents of first ans second person have a conflict \\n            boolean flag = true;\\n            for(int j = 0; j < resLength; j++) {\\n                //finding parents of the restriction persons\\n                int firstRestriction = findParent(parent, restrictions[j][0]);\\n                int secondRestriction = findParent(parent, restrictions[j][1]);\\n                \\n                //if any of the parents are matching i.e. if the parents of first and second person have a mutual conflict they can\\'t be friend\\n                if((firstRestriction == firstParent && secondRestriction == secondParent) || (secondRestriction == firstParent && firstRestriction == secondParent)) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag) {\\n                result[i] = true;\\n                parent[firstParent] = secondParent; //setting the common ancestor -> classic union find technique\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577308,
                "title": "union-find",
                "content": "I thought there is some clever way to track enemies, and wasted a lot of time. Should have looked at constraints closelly - `1000` is not a big number for a `n * m` solution. \\n\\nSo we join frieds using union-find. But before we do, we scan through all `restrictions`, to make sure that sets of friends that we are joining do not include any restricted pair.\\n\\n**C++**\\n```cpp\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nvector<bool> friendRequests(int n, vector<vector<int>>& enemies, vector<vector<int>>& requests) {\\n    vector<bool> res;\\n    vector<int> ds(n, -1);\\n    for (auto &req : requests) {\\n        int i = find(ds, req[0]), j = find(ds, req[1]);\\n        bool friends = i == j;\\n        if (!friends) {\\n            friends = true;\\n            for (int k = 0; friends && k < enemies.size(); ++k) {\\n                int x = find(ds, enemies[k][0]), y = find(ds, enemies[k][1]);\\n                friends = (x != i || y != j) && (x != j || y != i);\\n            }\\n            if (friends)\\n                ds[j] = i;\\n        }\\n        res.push_back(friends);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nvector<bool> friendRequests(int n, vector<vector<int>>& enemies, vector<vector<int>>& requests) {\\n    vector<bool> res;\\n    vector<int> ds(n, -1);\\n    for (auto &req : requests) {\\n        int i = find(ds, req[0]), j = find(ds, req[1]);\\n        bool friends = i == j;\\n        if (!friends) {\\n            friends = true;\\n            for (int k = 0; friends && k < enemies.size(); ++k) {\\n                int x = find(ds, enemies[k][0]), y = find(ds, enemies[k][1]);\\n                friends = (x != i || y != j) && (x != j || y != i);\\n            }\\n            if (friends)\\n                ds[j] = i;\\n        }\\n        res.push_back(friends);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577236,
                "title": "c-bitset-union-find-50ms",
                "content": "This problem is the perfect one to use bitset. since # is less than 1000.\\nwe have 2 bitset array \\nvector<bitset<1000>> hate;\\nvector<bitset<1000>> g;\\nrepresent a group\\'s member, and a group\\'s members\\'s hate-list(can not be friend with).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<bitset<1000>> hate;\\n    vector<bitset<1000>> g;\\n    int findp(int p) {\\n        return (parent[p] == p) ? p : parent[p]=findp(parent[p]);\\n    }\\n    bool tryun(int a, int b) {\\n        int pa = findp(a);\\n        int pb = findp(b);\\n        if (pa == pb) return true;\\n        if ((hate[pa] & g[pb]).any()) return false;\\n        g[pa] |= g[pb];\\n        hate[pa] |= hate[pb];\\n        parent[pb] = pa;\\n        return true;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        parent.resize(n);\\n        hate.resize(n);\\n        g.resize(n);\\n        for (int i = 0; i < n; i++) { parent[i] = i; g[i][i] = 1;} \\n        for (auto& r : restrictions)  { hate[r[0]][r[1]] = 1; hate[r[1]][r[0]] = 1;}\\n        vector<bool> ans;\\n        for (auto& r : requests) ans.push_back(tryun(r[0], r[1]));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<bitset<1000>> hate;\\n    vector<bitset<1000>> g;\\n    int findp(int p) {\\n        return (parent[p] == p) ? p : parent[p]=findp(parent[p]);\\n    }\\n    bool tryun(int a, int b) {\\n        int pa = findp(a);\\n        int pb = findp(b);\\n        if (pa == pb) return true;\\n        if ((hate[pa] & g[pb]).any()) return false;\\n        g[pa] |= g[pb];\\n        hate[pa] |= hate[pb];\\n        parent[pb] = pa;\\n        return true;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        parent.resize(n);\\n        hate.resize(n);\\n        g.resize(n);\\n        for (int i = 0; i < n; i++) { parent[i] = i; g[i][i] = 1;} \\n        for (auto& r : restrictions)  { hate[r[0]][r[1]] = 1; hate[r[1]][r[0]] = 1;}\\n        vector<bool> ans;\\n        for (auto& r : requests) ans.push_back(tryun(r[0], r[1]));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598078,
                "title": "intuition-explained-straight-forward-dsu-c-clean-code",
                "content": "# Code: \\n\\n```\\n// Standard DSU Class\\nclass DSU {\\n    vector<int> parent, size;\\npublic: \\n    \\n    DSU(int n) {\\n        for(int i=0; i<=n; i++) {\\n            parent.push_back(i);\\n            size.push_back(1);\\n        }\\n    }\\n    \\n    int findParent(int num) {\\n        if(parent[num] == num) return num;\\n        return parent[num] = findParent(parent[num]);\\n    }\\n    \\n\\t// Directly getting parents of u and v\\n\\t// To avoid finding parent multiple times\\n    void unionBySize(int parU, int parV) {\\n        \\n        if(size[parU] < size[parV]) {\\n            size[parV] += size[parU];\\n            parent[parU] = parV;\\n        }\\n        else {\\n            size[parU] += size[parV];\\n            parent[parV] = parU;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        DSU dsu(n);\\n        \\n        vector<bool> successful;\\n        \\n        for(auto& request : requests) {\\n            \\n            int u = request[0], v = request[1];\\n            \\n            int parU = dsu.findParent(u), parV = dsu.findParent(v);\\n            \\n            bool flag = true;\\n            \\n            if(parU != parV) {\\n                \\n\\t\\t\\t\\t// Check if current friend requested is restricted or not.\\n                for(auto& restriction : restrictions) {\\n                    int restricted_U = restriction[0], restricted_V = restriction[1];\\n                    \\n                    int restricted_parU = dsu.findParent(restricted_U);\\n                    int restricted_parV = dsu.findParent(restricted_V);\\n                    \\n                    if((parU == restricted_parU && parV == restricted_parV) || (parU == restricted_parV && parV == restricted_parU)) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n\\t\\t\\t\\t// Union u and v by passing parents\\n\\t\\t\\t\\t// Since it is already calculated above\\n                if(flag) {\\n                    dsu.unionBySize(parU, parV);\\n                }\\n            }\\n            \\n            successful.push_back(flag);\\n        }\\n        \\n        return successful;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\n// Standard DSU Class\\nclass DSU {\\n    vector<int> parent, size;\\npublic: \\n    \\n    DSU(int n) {\\n        for(int i=0; i<=n; i++) {\\n            parent.push_back(i);\\n            size.push_back(1);\\n        }\\n    }\\n    \\n    int findParent(int num) {\\n        if(parent[num] == num) return num;\\n        return parent[num] = findParent(parent[num]);\\n    }\\n    \\n\\t// Directly getting parents of u and v\\n\\t// To avoid finding parent multiple times\\n    void unionBySize(int parU, int parV) {\\n        \\n        if(size[parU] < size[parV]) {\\n            size[parV] += size[parU];\\n            parent[parU] = parV;\\n        }\\n        else {\\n            size[parU] += size[parV];\\n            parent[parV] = parU;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        DSU dsu(n);\\n        \\n        vector<bool> successful;\\n        \\n        for(auto& request : requests) {\\n            \\n            int u = request[0], v = request[1];\\n            \\n            int parU = dsu.findParent(u), parV = dsu.findParent(v);\\n            \\n            bool flag = true;\\n            \\n            if(parU != parV) {\\n                \\n\\t\\t\\t\\t// Check if current friend requested is restricted or not.\\n                for(auto& restriction : restrictions) {\\n                    int restricted_U = restriction[0], restricted_V = restriction[1];\\n                    \\n                    int restricted_parU = dsu.findParent(restricted_U);\\n                    int restricted_parV = dsu.findParent(restricted_V);\\n                    \\n                    if((parU == restricted_parU && parV == restricted_parV) || (parU == restricted_parV && parV == restricted_parU)) {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                \\n\\t\\t\\t\\t// Union u and v by passing parents\\n\\t\\t\\t\\t// Since it is already calculated above\\n                if(flag) {\\n                    dsu.unionBySize(parU, parV);\\n                }\\n            }\\n            \\n            successful.push_back(flag);\\n        }\\n        \\n        return successful;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578485,
                "title": "java-beats-98-with-comments-and-complexity-analysis",
                "content": "time complexity:\\nnumber of persons: n\\nnumber of restrictions: m\\nnumber of requests: k\\n\\ninitialize friends and enemies: O(n + m)\\nCollaping find: O(n)\\nmerge enemies set: O(m)\\n\\nin total: n + m + k * (n + m) = O (k * (n + m))\\n\\n\\nSpace: O(n + m)\\n\\n```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        \\n        Set<Integer>[] enemies = new Set[n];\\n        int[] friends = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            friends[i] = i;\\n            enemies[i] = new HashSet<>();\\n        }\\n        \\n        for (int i = 0; i < restrictions.length; i++) {\\n            //add person A to person B\\'s enmey circle.\\n            //add person B to person A\\'s enemy circle.\\n            enemies[restrictions[i][0]].add(restrictions[i][1]);\\n            enemies[restrictions[i][1]].add(restrictions[i][0]);\\n        }\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            int personA = findRootFriend(friends, requests[i][0]);\\n            int personB = findRootFriend(friends, requests[i][1]);\\n            Set<Integer> personAEnemies = enemies[personA];\\n            Set<Integer> personBEnemies = enemies[personB]; \\n            \\n            if (personA == personB) {\\n                res[i] = true;\\n            } else if (!personAEnemies.contains(personB) && !personBEnemies.contains(personA)) {\\n                //can merge. update personB\\'s root to be person A\\n                friends[personB] = personA;\\n                \\n                // add all B\\'s enemies to A\\'s enemyies\\n                personAEnemies.addAll(personBEnemies);\\n                \\n                // inform all B\\'s enemies that A is a new enemy\\n                for (int k : personBEnemies) {\\n                    enemies[k].add(personA);\\n                }\\n                \\n                res[i] = true;\\n            } else {\\n                res[i] = false;\\n            }\\n        } \\n        \\n        return res;\\n    }\\n    \\n    private int findRootFriend(int[] friends, int i) {\\n        if (friends[i] == i) {\\n            return i;\\n        }\\n        \\n        return findRootFriend(friends, friends[i]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        \\n        Set<Integer>[] enemies = new Set[n];\\n        int[] friends = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            friends[i] = i;\\n            enemies[i] = new HashSet<>();\\n        }\\n        \\n        for (int i = 0; i < restrictions.length; i++) {\\n            //add person A to person B\\'s enmey circle.\\n            //add person B to person A\\'s enemy circle.\\n            enemies[restrictions[i][0]].add(restrictions[i][1]);\\n            enemies[restrictions[i][1]].add(restrictions[i][0]);\\n        }\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            int personA = findRootFriend(friends, requests[i][0]);\\n            int personB = findRootFriend(friends, requests[i][1]);\\n            Set<Integer> personAEnemies = enemies[personA];\\n            Set<Integer> personBEnemies = enemies[personB]; \\n            \\n            if (personA == personB) {\\n                res[i] = true;\\n            } else if (!personAEnemies.contains(personB) && !personBEnemies.contains(personA)) {\\n                //can merge. update personB\\'s root to be person A\\n                friends[personB] = personA;\\n                \\n                // add all B\\'s enemies to A\\'s enemyies\\n                personAEnemies.addAll(personBEnemies);\\n                \\n                // inform all B\\'s enemies that A is a new enemy\\n                for (int k : personBEnemies) {\\n                    enemies[k].add(personA);\\n                }\\n                \\n                res[i] = true;\\n            } else {\\n                res[i] = false;\\n            }\\n        } \\n        \\n        return res;\\n    }\\n    \\n    private int findRootFriend(int[] friends, int i) {\\n        if (friends[i] == i) {\\n            return i;\\n        }\\n        \\n        return findRootFriend(friends, friends[i]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576960,
                "title": "java-union-find",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] re, int[][] requests) {\\n        UnionFind uf = new UnionFind();\\n        boolean[] res = new boolean[requests.length];\\n        Arrays.fill(res,true);\\n        for(int i = 0; i < requests.length; i++){\\n            int[] r =requests[i];\\n            int a = r[0], b = r[1];\\n            int a1 = uf.find(a), b1 = uf.find(b);\\n            for(int[] t: re){\\n                int t1 = uf.find(t[0]), t2 = uf.find(t[1]);\\n                if(t1 == a1 && b1 == t2 || a1 == t2 && b1 == t1){\\n                    res[i] = false;\\n                    break;\\n                }\\n            }\\n            if(res[i]) uf.union(a,b);\\n        }\\n        return res;\\n    }\\n    \\n}\\n\\nclass UnionFind{\\n    Map<Integer, Integer> map = new HashMap<>();\\n    int find(int n){\\n        map.putIfAbsent(n,n);\\n        while(n != map.get(n)){\\n            map.put(n, map.get(map.get(n)));\\n            n = map.get(n);\\n        }\\n        return n;\\n    }\\n    void union(int a, int b){\\n        map.put(find(a), find(b));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] re, int[][] requests) {\\n        UnionFind uf = new UnionFind();\\n        boolean[] res = new boolean[requests.length];\\n        Arrays.fill(res,true);\\n        for(int i = 0; i < requests.length; i++){\\n            int[] r =requests[i];\\n            int a = r[0], b = r[1];\\n            int a1 = uf.find(a), b1 = uf.find(b);\\n            for(int[] t: re){\\n                int t1 = uf.find(t[0]), t2 = uf.find(t[1]);\\n                if(t1 == a1 && b1 == t2 || a1 == t2 && b1 == t1){\\n                    res[i] = false;\\n                    break;\\n                }\\n            }\\n            if(res[i]) uf.union(a,b);\\n        }\\n        return res;\\n    }\\n    \\n}\\n\\nclass UnionFind{\\n    Map<Integer, Integer> map = new HashMap<>();\\n    int find(int n){\\n        map.putIfAbsent(n,n);\\n        while(n != map.get(n)){\\n            map.put(n, map.get(map.get(n)));\\n            n = map.get(n);\\n        }\\n        return n;\\n    }\\n    void union(int a, int b){\\n        map.put(find(a), find(b));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458609,
                "title": "c-simple-c-code-90-time-union-find",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    vector<int> parents;\\n    int find_set(int v)\\n    {\\n        if(v == parents[v])\\n            return v;\\n        return parents[v] = find_set(parents[v]);\\n    }\\n    void union_set(int a, int b)\\n    {\\n        a = find_set(a);\\n        b = find_set(b);\\n        if(a == b)\\n            return;\\n        if(a != b)\\n            parents[b] = a;\\n        return;\\n    }\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        for(int i = 0; i < n; i++)\\n            parents.push_back(i);\\n        vector<bool> ans;\\n        for(vector<int> &req : requests)\\n        {\\n            int v = 1;\\n            int a = find_set(req[0]);\\n            int b = find_set(req[1]);\\n            for(vector<int> &res : restrictions)\\n            {\\n                int r1 = find_set(res[0]);\\n                int r2 = find_set(res[1]);\\n                if((a == r1 && b == r2) || (b == r1 && a == r2))\\n                {\\n                    v = 0;\\n                    break;\\n                }\\n            }\\n            ans.push_back(v);\\n            if(v)\\n            {\\n                union_set(a,b);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> parents;\\n    int find_set(int v)\\n    {\\n        if(v == parents[v])\\n            return v;\\n        return parents[v] = find_set(parents[v]);\\n    }\\n    void union_set(int a, int b)\\n    {\\n        a = find_set(a);\\n        b = find_set(b);\\n        if(a == b)\\n            return;\\n        if(a != b)\\n            parents[b] = a;\\n        return;\\n    }\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        for(int i = 0; i < n; i++)\\n            parents.push_back(i);\\n        vector<bool> ans;\\n        for(vector<int> &req : requests)\\n        {\\n            int v = 1;\\n            int a = find_set(req[0]);\\n            int b = find_set(req[1]);\\n            for(vector<int> &res : restrictions)\\n            {\\n                int r1 = find_set(res[0]);\\n                int r2 = find_set(res[1]);\\n                if((a == r1 && b == r2) || (b == r1 && a == r2))\\n                {\\n                    v = 0;\\n                    break;\\n                }\\n            }\\n            ans.push_back(v);\\n            if(v)\\n            {\\n                union_set(a,b);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620457,
                "title": "python-union-find-beats-98-runtime-and-34-space",
                "content": "I think it is easy for everyone to see this problem requires union find. \\nThe key point is about how to detect if the friend request is restricted or not. \\nWe can of course iterate through all restricted ones and check, but that will be too expensive. \\nHere I have maintained a map called `excluded`, which is `{people => { set of restricted peoples } }`.\\nThis map is updated whenever a successful union happens.\\nWe use `DisjointSet` to keep the information of friend circles, like everyone would do.\\n\\nSo the algorithm has only 3 conditions for people1 trying to make friend with people2:\\n1. people1 and people2 are already in the same group (directly or indirectly), that is just fine. `res = True`\\n2. people2 is in people1\\'s excluding list, then they cannot be friends. `res = False`\\n3. people1 and people2 are not in the same friend circle, and they are not mutually excluded, then we just merge their friend circles. The merge happens by updating the excluded map (more details in the next paragraph) and DisjointSet. `res = True`\\n\\nThe excluded map update is straight forward, it does 2 things to update:\\n1. Merge names from people2\\'s list to people1\\'s list. Because people1 and people2 are in the same group now, and the excluded people should be merged.\\n2. For every people excluded by people2, they also exclude people2, and we need them to exclude people1 as well\\n\\nHere is the code:\\n```python\\nclass DisjointSet:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        from collections import defaultdict\\n        excluded = defaultdict(set)\\n        for people1, people2 in restrictions: # exclusion is mutual\\n            excluded[people1].add(people2) \\n            excluded[people2].add(people1)\\n\\t\\t\\t\\n        def update_exclusion(from_p, to_p): # update exclusion map\\n            targets = excluded.pop(from_p, [])\\n            for people in targets: # people being excluded by people2 should now also exclude people1\\n                excluded[people].remove(from_p)\\n                excluded[people].add(to_p)\\n            excluded[to_p].update(targets) # people1 should exclude people that are excluded by people2\\n\\t\\t\\t\\n        res = []\\n        disjoint_set = DisjointSet(n)\\n        for people1, people2 in requests:\\n            circle1 = disjoint_set.find(people1)\\n            circle2 = disjoint_set.find(people2)\\n            if circle1 == circle2: \\n                res.append(True)\\n            elif circle2 in excluded[circle1]:\\n                res.append(False)\\n            else:\\n                update_exclusion(circle2, circle1)\\n                disjoint_set.parent[circle2] = circle1\\n                res.append(True)\\n        return res\\n                \\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```python\\nclass DisjointSet:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        from collections import defaultdict\\n        excluded = defaultdict(set)\\n        for people1, people2 in restrictions: # exclusion is mutual\\n            excluded[people1].add(people2) \\n            excluded[people2].add(people1)\\n\\t\\t\\t\\n        def update_exclusion(from_p, to_p): # update exclusion map\\n            targets = excluded.pop(from_p, [])\\n            for people in targets: # people being excluded by people2 should now also exclude people1\\n                excluded[people].remove(from_p)\\n                excluded[people].add(to_p)\\n            excluded[to_p].update(targets) # people1 should exclude people that are excluded by people2\\n\\t\\t\\t\\n        res = []\\n        disjoint_set = DisjointSet(n)\\n        for people1, people2 in requests:\\n            circle1 = disjoint_set.find(people1)\\n            circle2 = disjoint_set.find(people2)\\n            if circle1 == circle2: \\n                res.append(True)\\n            elif circle2 in excluded[circle1]:\\n                res.append(False)\\n            else:\\n                update_exclusion(circle2, circle1)\\n                disjoint_set.parent[circle2] = circle1\\n                res.append(True)\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582784,
                "title": "python-unionfind-easy-to-understand-with-explanation",
                "content": "```\\nclass UnionFindSet(object):\\n    def __init__(self, n):\\n        self.data = range(n)\\n\\n    def find(self, x):\\n        while x <> self.data[x]:\\n            x = self.data[x]\\n        return x\\n\\n    def union(self, x, y):\\n        self.data[self.find(x)] = self.find(y)\\n\\n    def speedup(self):\\n        for i in range(len(self.data)):\\n            self.data[i] = self.find(i)\\n\\n\\nclass Solution(object):\\n    def friendRequests(self, n, restrictions, requests):\\n        uf = UnionFindSet(n)\\n        ret = [True] * len(requests)\\n        for k, [x, y] in enumerate(requests):  # Process Requests Sequentially\\n            xh = uf.find(x)  # backup the head of x for undo\\n            uf.union(x, y)  # link [x, y] and verify if any restriction triggers\\n            for [i, j] in restrictions:\\n                if uf.find(i) == uf.find(j):\\n                    ret[k] = False\\n                    break\\n            if not ret[k]:  # if any restriction triggers, undo\\n                uf.data[xh] = xh\\n            else:\\n                uf.speedup()\\n        return ret\\n```\\n**If you have any questoins, feel free to ask. If you like the solution and explanation, please upvote!**",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFindSet(object):\\n    def __init__(self, n):\\n        self.data = range(n)\\n\\n    def find(self, x):\\n        while x <> self.data[x]:\\n            x = self.data[x]\\n        return x\\n\\n    def union(self, x, y):\\n        self.data[self.find(x)] = self.find(y)\\n\\n    def speedup(self):\\n        for i in range(len(self.data)):\\n            self.data[i] = self.find(i)\\n\\n\\nclass Solution(object):\\n    def friendRequests(self, n, restrictions, requests):\\n        uf = UnionFindSet(n)\\n        ret = [True] * len(requests)\\n        for k, [x, y] in enumerate(requests):  # Process Requests Sequentially\\n            xh = uf.find(x)  # backup the head of x for undo\\n            uf.union(x, y)  # link [x, y] and verify if any restriction triggers\\n            for [i, j] in restrictions:\\n                if uf.find(i) == uf.find(j):\\n                    ret[k] = False\\n                    break\\n            if not ret[k]:  # if any restriction triggers, undo\\n                uf.data[xh] = xh\\n            else:\\n                uf.speedup()\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580219,
                "title": "c-dsu-2-approaches",
                "content": "# **Approach 1**\\n```\\nclass DSU {\\nprivate: \\n\\tvector<int> parent, size, rank; \\n \\n\\tpublic:\\n    DSU(int n) {\\n\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\tparent.push_back(i); \\n\\t\\t\\tsize.push_back(1); \\n\\t\\t\\trank.push_back(0); \\n\\t\\t}\\n\\t}\\n \\n \\npublic: \\n\\tint findPar(int node) {\\n\\t\\tif(parent[node] == node) {\\n\\t\\t\\treturn node; \\n\\t\\t}\\n\\t\\treturn parent[node] = findPar(parent[node]); \\n\\t}\\n \\npublic:\\n\\tvoid unionSize(int u, int v) {\\n\\t\\tint pu = findPar(u); \\n\\t\\tint pv = findPar(v); \\n\\t\\tif(pu == pv) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tif(size[pu] < size[pv]) {\\n\\t\\t\\tparent[pu] = pv; \\n\\t\\t\\tsize[pv] += size[pu]; \\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pv] = pu; \\n\\t\\t\\tsize[pu] += size[pv]; \\n\\t\\t}\\n\\t}\\npublic:\\n\\tvoid unionRank(int u, int v) {\\n\\t\\tint pu = findPar(u); \\n\\t\\tint pv = findPar(v); \\n\\t\\tif(pu == pv) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tif(rank[pu] < rank[pv]) {\\n\\t\\t\\tparent[pu] = pv; \\n\\t\\t}\\n\\t\\telse if(rank[pv] < rank[pu]){\\n\\t\\t\\tparent[pv] = pu; \\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pu] = pv;\\n\\t\\t\\trank[pv]++; \\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU dsu(n);\\n        vector<bool> ans;\\n        \\n        for(auto it: requests){\\n            int x = it[0];\\n            int y = it[1];\\n            \\n            DSU temp = dsu;\\n            \\n            temp.unionRank(x, y);\\n            \\n            bool flag = true;\\n            for(auto itr: restrictions){\\n                int x1 = itr[0];\\n                int y1 = itr[1];\\n                \\n                if(temp.findPar(x1)==temp.findPar(y1)){\\n                    flag=false; \\n                    break;\\n                }\\n            }\\n            \\n            if(flag==true){\\n                ans.push_back(true);\\n                dsu.unionRank(x, y);\\n            }\\n            else{\\n                ans.push_back(false);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# **Approach 2**\\n**(with better space complexity)**\\n\\n```\\nclass DSU {\\nprivate: \\n\\tvector<int> parent, size, rank; \\n \\n\\tpublic:\\n    DSU(int n) {\\n\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\tparent.push_back(i); \\n\\t\\t\\tsize.push_back(1); \\n\\t\\t\\trank.push_back(0); \\n\\t\\t}\\n\\t}\\n \\n \\npublic: \\n\\tint findPar(int node) {\\n\\t\\tif(parent[node] == node) {\\n\\t\\t\\treturn node; \\n\\t\\t}\\n\\t\\treturn parent[node] = findPar(parent[node]); \\n\\t}\\n \\npublic:\\n\\tvoid unionSize(int u, int v) {\\n\\t\\tint pu = findPar(u); \\n\\t\\tint pv = findPar(v); \\n\\t\\tif(pu == pv) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tif(size[pu] < size[pv]) {\\n\\t\\t\\tparent[pu] = pv; \\n\\t\\t\\tsize[pv] += size[pu]; \\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pv] = pu; \\n\\t\\t\\tsize[pu] += size[pv]; \\n\\t\\t}\\n\\t}\\npublic:\\n\\tvoid unionRank(int u, int v) {\\n\\t\\tint pu = findPar(u); \\n\\t\\tint pv = findPar(v); \\n\\t\\tif(pu == pv) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tif(rank[pu] < rank[pv]) {\\n\\t\\t\\tparent[pu] = pv; \\n\\t\\t}\\n\\t\\telse if(rank[pv] < rank[pu]){\\n\\t\\t\\tparent[pv] = pu; \\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pu] = pv;\\n\\t\\t\\trank[pv]++; \\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU dsu(n);\\n        vector<bool> ans;\\n        \\n        for(auto &it: requests){\\n            int x = it[0];\\n            int y = it[1];\\n            int px = dsu.findPar(x);\\n            int py = dsu.findPar(y);\\n            \\n            bool flag=true;\\n            if(px!=py){\\n                for(auto &itr: restrictions){\\n                    int pu = dsu.findPar(itr[0]);\\n                    int pv = dsu.findPar(itr[1]);\\n                    \\n                    if((pu==px && pv==py) || pu==py && pv==px){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag==false){\\n                ans.push_back(false);\\n            }\\n            else{\\n                ans.push_back(true);\\n                dsu.unionRank(x, y);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU {\\nprivate: \\n\\tvector<int> parent, size, rank; \\n \\n\\tpublic:\\n    DSU(int n) {\\n\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\tparent.push_back(i); \\n\\t\\t\\tsize.push_back(1); \\n\\t\\t\\trank.push_back(0); \\n\\t\\t}\\n\\t}\\n \\n \\npublic: \\n\\tint findPar(int node) {\\n\\t\\tif(parent[node] == node) {\\n\\t\\t\\treturn node; \\n\\t\\t}\\n\\t\\treturn parent[node] = findPar(parent[node]); \\n\\t}\\n \\npublic:\\n\\tvoid unionSize(int u, int v) {\\n\\t\\tint pu = findPar(u); \\n\\t\\tint pv = findPar(v); \\n\\t\\tif(pu == pv) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tif(size[pu] < size[pv]) {\\n\\t\\t\\tparent[pu] = pv; \\n\\t\\t\\tsize[pv] += size[pu]; \\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pv] = pu; \\n\\t\\t\\tsize[pu] += size[pv]; \\n\\t\\t}\\n\\t}\\npublic:\\n\\tvoid unionRank(int u, int v) {\\n\\t\\tint pu = findPar(u); \\n\\t\\tint pv = findPar(v); \\n\\t\\tif(pu == pv) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tif(rank[pu] < rank[pv]) {\\n\\t\\t\\tparent[pu] = pv; \\n\\t\\t}\\n\\t\\telse if(rank[pv] < rank[pu]){\\n\\t\\t\\tparent[pv] = pu; \\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pu] = pv;\\n\\t\\t\\trank[pv]++; \\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU dsu(n);\\n        vector<bool> ans;\\n        \\n        for(auto it: requests){\\n            int x = it[0];\\n            int y = it[1];\\n            \\n            DSU temp = dsu;\\n            \\n            temp.unionRank(x, y);\\n            \\n            bool flag = true;\\n            for(auto itr: restrictions){\\n                int x1 = itr[0];\\n                int y1 = itr[1];\\n                \\n                if(temp.findPar(x1)==temp.findPar(y1)){\\n                    flag=false; \\n                    break;\\n                }\\n            }\\n            \\n            if(flag==true){\\n                ans.push_back(true);\\n                dsu.unionRank(x, y);\\n            }\\n            else{\\n                ans.push_back(false);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass DSU {\\nprivate: \\n\\tvector<int> parent, size, rank; \\n \\n\\tpublic:\\n    DSU(int n) {\\n\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\tparent.push_back(i); \\n\\t\\t\\tsize.push_back(1); \\n\\t\\t\\trank.push_back(0); \\n\\t\\t}\\n\\t}\\n \\n \\npublic: \\n\\tint findPar(int node) {\\n\\t\\tif(parent[node] == node) {\\n\\t\\t\\treturn node; \\n\\t\\t}\\n\\t\\treturn parent[node] = findPar(parent[node]); \\n\\t}\\n \\npublic:\\n\\tvoid unionSize(int u, int v) {\\n\\t\\tint pu = findPar(u); \\n\\t\\tint pv = findPar(v); \\n\\t\\tif(pu == pv) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tif(size[pu] < size[pv]) {\\n\\t\\t\\tparent[pu] = pv; \\n\\t\\t\\tsize[pv] += size[pu]; \\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pv] = pu; \\n\\t\\t\\tsize[pu] += size[pv]; \\n\\t\\t}\\n\\t}\\npublic:\\n\\tvoid unionRank(int u, int v) {\\n\\t\\tint pu = findPar(u); \\n\\t\\tint pv = findPar(v); \\n\\t\\tif(pu == pv) {\\n\\t\\t\\treturn; \\n\\t\\t}\\n\\t\\tif(rank[pu] < rank[pv]) {\\n\\t\\t\\tparent[pu] = pv; \\n\\t\\t}\\n\\t\\telse if(rank[pv] < rank[pu]){\\n\\t\\t\\tparent[pv] = pu; \\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[pu] = pv;\\n\\t\\t\\trank[pv]++; \\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU dsu(n);\\n        vector<bool> ans;\\n        \\n        for(auto &it: requests){\\n            int x = it[0];\\n            int y = it[1];\\n            int px = dsu.findPar(x);\\n            int py = dsu.findPar(y);\\n            \\n            bool flag=true;\\n            if(px!=py){\\n                for(auto &itr: restrictions){\\n                    int pu = dsu.findPar(itr[0]);\\n                    int pv = dsu.findPar(itr[1]);\\n                    \\n                    if((pu==px && pv==py) || pu==py && pv==px){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(flag==false){\\n                ans.push_back(false);\\n            }\\n            else{\\n                ans.push_back(true);\\n                dsu.unionRank(x, y);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576909,
                "title": "c-make-friends",
                "content": "**Hint/Thought Process**\\n- If x is a friend of y, and y is a friend of z, then x will be a friend of z. So, we can say, friends will form a connected component.\\n\\t- => Hint for using disjoint set union.\\n\\n**Algorithm**\\n- We process requests sequentially.\\n\\t- Let\\'s say we are processing request[ i ] = [u,v]\\n\\t\\n\\t- Then, from previous requests, we know u & v will be part of some components.\\n\\t- Let say u\\'s component contains: [u1,u2,u3,..., ux] and v\\'s component contains: [v1,v2,v3,...,vy]\\n\\t\\t- Now, after processing the current request, every pair (u_i, v_j) will be friends, for all i<=x and j<=y\\n\\t\\t- Thus, if any of such pairs is restricted, i.e. (u_i, v_j) can\\'t be friends \\n\\t\\t\\t- => We can\\'t process the current request i.\\n\\t- Hence, we iterate over the Restrictions array for every request and check if any of the restriction is violated.\\n\\t\\t- If no restriction is violated, we can process the current request.\\n\\t\\t- Otherwise, we can\\'t process the current request.\\n\\n\\n**Time Complexity**\\n- Let N = requests.size(), M = restrictions.size(), n = # people\\n- O(N*M)\\n\\n**Code**\\n```\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\n\\nbool Union(vector<int> &ds, int i, int j){\\n\\t i = find(ds, i), j = find(ds, j);\\n\\t if(i==j) return false;\\n\\t if(abs(ds[i]) < abs(ds[j])) swap(i,j); \\n\\t ds[i]+=ds[j]; \\n\\t ds[j]=i;\\n\\t return true;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> res;\\n        vector<int> ds(n, -1);\\n        for(auto &r : requests){\\n            int u = find(ds,r[0]), v = find(ds,r[1]), can = 1;\\n\\t\\t\\t\\n            for(auto &rt : restrictions){\\n                int u1 = find(ds,rt[0]), v1 = find(ds, rt[1]);\\n                if((u1==u && v1 == v) || (u1==v && v1==u)){ \\n                    //restricted pair will be connected!! => Do not process the request\\n                    can = 0;\\n                    break;\\n                }\\n            }\\n            if(can) Union(ds,u,v);\\n            res.push_back(can);   \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\n\\nbool Union(vector<int> &ds, int i, int j){\\n\\t i = find(ds, i), j = find(ds, j);\\n\\t if(i==j) return false;\\n\\t if(abs(ds[i]) < abs(ds[j])) swap(i,j); \\n\\t ds[i]+=ds[j]; \\n\\t ds[j]=i;\\n\\t return true;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> res;\\n        vector<int> ds(n, -1);\\n        for(auto &r : requests){\\n            int u = find(ds,r[0]), v = find(ds,r[1]), can = 1;\\n\\t\\t\\t\\n            for(auto &rt : restrictions){\\n                int u1 = find(ds,rt[0]), v1 = find(ds, rt[1]);\\n                if((u1==u && v1 == v) || (u1==v && v1==u)){ \\n                    //restricted pair will be connected!! => Do not process the request\\n                    can = 0;\\n                    break;\\n                }\\n            }\\n            if(can) Union(ds,u,v);\\n            res.push_back(can);   \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852910,
                "title": "easy-to-follow-java-code-12-ms-time-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe runtime of the code is O(n * m). where n is the number of restrictions (restrictions.length) and m is the number of queries (requests.length).\\n\\nThe first loop in the DisjoinSet class takes O(n) time to initialize the parent and rank arrays. The second loop takes O(n) time to add each restriction to the appropriate set. The notRestricted() method takes O(1) time to check if two roots are restricted from being in the same set.\\n\\nThe union() method takes O(1) time to find the roots of the two nodes being unioned. If the two roots are not restricted from being in the same set, then the union() method takes O(1) time to union the two sets. If the two roots are restricted from being in the same set, then the union() method takes O(n) time to update the restrictions of the two sets.\\n\\nThe friendRequests() method takes O(m) time to iterate through the queries and call the union() method for each query.\\n\\nTherefore, the overall runtime of the code is O(n * m).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Idea and code from \\n// https://leetcode.com/problems/process-restricted-friend-requests/solutions/3814592/union-find-disjoint-sets-solution-faster-than-90-java/\\n\\nclass DisjoinSet {\\n    private final int [] parent;\\n    private final int [] rank;\\n    private final List<Set<Integer>> restrictions;\\n\\n    DisjoinSet(int size, int[][] restrictions){\\n        this.parent = new int [size];\\n        this.rank = new int [size];     \\n        this.restrictions = new ArrayList<>(size);\\n\\n        for(int i =0; i <size; i++) {\\n            this.parent[i] = i;\\n            this.rank[i] = 1;\\n            this.restrictions.add(new HashSet<>());\\n        }\\n\\n        for (int [] restriction: restrictions){\\n            this.restrictions.get(restriction[0]).add(restriction[1]);\\n            this.restrictions.get(restriction[1]).add(restriction[0]);\\n        }\\n    }\\n\\n    private int find(int node){\\n        int root=node;\\n        while(parent[root]!=root){\\n            root=parent[root];\\n        }\\n\\n        while (parent[node]!=root){\\n            int next = parent[node];\\n            parent[node]=root;\\n            node = next;\\n        }\\n        return root;\\n    }\\n\\n    public boolean union (int n1, int n2){\\n        int p1 = find(n1);\\n        int p2 = find(n2);\\n\\n        if (p1==p2){\\n            return true;\\n        }\\n            \\n        if (notRestricted(p1,p2)){\\n            if (rank[p1]>rank[p2]){\\n                rank[p1]+=rank[p2];\\n                parent[p2]=p1;\\n                // Combine the restrictions list\\n                //Add all parent Nodes from other list \\n                for (int node: restrictions.get(p2)){\\n                    restrictions.get(p1).add(find(node) );\\n                }\\n            } else{\\n                rank[p2]+=rank[p1];\\n                parent[p1]= p2;\\n                // Combine the restrictions list\\n                //Add all parent Nodes from other list \\n                for (int node: restrictions.get(p1)){\\n                    restrictions.get(p2).add(find(node) );\\n                }\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n        private boolean notRestricted(int root1, int root2) {\\n            if (restrictions.get(root1).contains(root2))\\n                return false;\\n            if (restrictions.get(root2).contains(root1))\\n                return false;\\n        return true;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        if (restrictions.length==0){\\n            boolean [] queries = new boolean [requests.length];\\n            Arrays.fill(queries,true);\\n            return queries;\\n        }\\n         DisjoinSet set = new DisjoinSet(n,restrictions);\\n         boolean [] queries = new boolean [requests.length];\\n         for (int i =0; i<requests.length ;i++){\\n            queries[i] = set.union(requests[i][0],requests[i][1] );\\n         }\\n        return queries;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Idea and code from \\n// https://leetcode.com/problems/process-restricted-friend-requests/solutions/3814592/union-find-disjoint-sets-solution-faster-than-90-java/\\n\\nclass DisjoinSet {\\n    private final int [] parent;\\n    private final int [] rank;\\n    private final List<Set<Integer>> restrictions;\\n\\n    DisjoinSet(int size, int[][] restrictions){\\n        this.parent = new int [size];\\n        this.rank = new int [size];     \\n        this.restrictions = new ArrayList<>(size);\\n\\n        for(int i =0; i <size; i++) {\\n            this.parent[i] = i;\\n            this.rank[i] = 1;\\n            this.restrictions.add(new HashSet<>());\\n        }\\n\\n        for (int [] restriction: restrictions){\\n            this.restrictions.get(restriction[0]).add(restriction[1]);\\n            this.restrictions.get(restriction[1]).add(restriction[0]);\\n        }\\n    }\\n\\n    private int find(int node){\\n        int root=node;\\n        while(parent[root]!=root){\\n            root=parent[root];\\n        }\\n\\n        while (parent[node]!=root){\\n            int next = parent[node];\\n            parent[node]=root;\\n            node = next;\\n        }\\n        return root;\\n    }\\n\\n    public boolean union (int n1, int n2){\\n        int p1 = find(n1);\\n        int p2 = find(n2);\\n\\n        if (p1==p2){\\n            return true;\\n        }\\n            \\n        if (notRestricted(p1,p2)){\\n            if (rank[p1]>rank[p2]){\\n                rank[p1]+=rank[p2];\\n                parent[p2]=p1;\\n                // Combine the restrictions list\\n                //Add all parent Nodes from other list \\n                for (int node: restrictions.get(p2)){\\n                    restrictions.get(p1).add(find(node) );\\n                }\\n            } else{\\n                rank[p2]+=rank[p1];\\n                parent[p1]= p2;\\n                // Combine the restrictions list\\n                //Add all parent Nodes from other list \\n                for (int node: restrictions.get(p1)){\\n                    restrictions.get(p2).add(find(node) );\\n                }\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n        private boolean notRestricted(int root1, int root2) {\\n            if (restrictions.get(root1).contains(root2))\\n                return false;\\n            if (restrictions.get(root2).contains(root1))\\n                return false;\\n        return true;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        if (restrictions.length==0){\\n            boolean [] queries = new boolean [requests.length];\\n            Arrays.fill(queries,true);\\n            return queries;\\n        }\\n         DisjoinSet set = new DisjoinSet(n,restrictions);\\n         boolean [] queries = new boolean [requests.length];\\n         for (int i =0; i<requests.length ;i++){\\n            queries[i] = set.union(requests[i][0],requests[i][1] );\\n         }\\n        return queries;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489402,
                "title": "java-solution-union-find-disjoint-sets-without-rank",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] arr=new int[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=i;\\n        }\\n        int j=0;\\n        boolean[] ret=new boolean[requests.length];\\n        for(int[] a:requests){\\n            int x=find(a[0],arr);\\n            int y=find(a[1],arr);\\n            boolean flag=true;\\n            for(int i=0;i<restrictions.length;i++){\\n                int l=find(restrictions[i][0],arr);\\n                int r=find(restrictions[i][1],arr);\\n                if(((l==x && r==y) || (l==y && r==x))){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            ret[j++]=flag;\\n            if(flag){\\n                union(x,y,arr);\\n            }\\n        }\\n        return ret;\\n    }\\n    private void union(int a,int b,int[] arr){\\n        int x=find(a,arr);\\n        int y=find(b,arr);\\n        if(x==y) return;\\n        arr[y]=x;\\n    }\\n    private int find(int x,int[] arr){\\n        if(arr[x]==x) return x;\\n        return find(arr[x],arr);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "class Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] arr=new int[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1941231,
                "title": "javascript-union-find",
                "content": "This solution uses a boilerplate for DSU that can be reused for other problems. Approach is based on other solutions posted on the discussion section. Please let me know if you have improvements or comments on time complexity.\\n\\n**Friend request function:**\\n\\t1. Add nodes 0 to n - 1 to DSU instance\\n\\t2. For each friend request [f1, f2], check each restriction pair [e1, e2]. \\n\\t3. Perform find on each of the four persons (f1, f2, e1, e2). \\n\\t4. If unionFind(f1) = unionFind(e1) and unionFind(f2) = unionFind(e2) OR viceversa, request is not valid.\\n\\n**Time complexity** \\nI believe is O(N + MK). Step 1 takes O(N) where N is number of friends. Steps 2 - 4 take O(MK) where M are number of requests and K are number of restrictions.\\nDSU finds and unions take an amortized time of O(1) because we are using path compression and union by rank.\\n\\n\\n```\\n/*\\nDSU Class Template\\n*/\\nclass DSU {\\n    constructor() {\\n        this.parents = new Map();\\n        this.rank = new Map();\\n    }\\n    \\n    add(x) {\\n        this.parents.set(x, x);\\n        this.rank.set(x, 0);\\n    }\\n    \\n    find(x) {\\n        const parent = this.parents.get(x);\\n        if (parent === x) return x;\\n        const setParent = this.find(parent);\\n        this.parents.set(x, setParent);\\n        return setParent;\\n    }\\n    \\n    union(x, y) {\\n        const xParent = this.find(x), yParent = this.find(y);\\n        const xRank = this.rank.get(xParent), yRank = this.rank.get(yParent);\\n        if (xParent === yParent) return;\\n        if (xRank > yRank) {\\n            this.parents.set(yParent, xParent);\\n        } else if (yRank > xRank) {\\n            this.parents.set(xParent, yParent);\\n        } else {\\n            this.parents.set(xParent, yParent);\\n            this.rank.set(yParent, yRank + 1);\\n        }   \\n    }\\n}\\n\\n/*\\nFriend Requests\\n*/\\nvar friendRequests = function(n, restrictions, requests) {\\n    const dsu = new DSU(), result = [];\\n    for (let i = 0; i < n; i++) dsu.add(i);\\n    \\n    for (let [friend1, friend2] of requests) {\\n        const parent1 = dsu.find(friend1), parent2 = dsu.find(friend2);\\n        let friendshipPossible = true;\\n        for (let [enemy1, enemy2] of restrictions) {\\n            const enemyParent1 = dsu.find(enemy1), enemyParent2 = dsu.find(enemy2);\\n            const condition1 = (enemyParent1 === parent1 && enemyParent2 === parent2);\\n            const condition2 = (enemyParent1 === parent2 && enemyParent2 === parent1);\\n            if (condition1 || condition2) {\\n                friendshipPossible = false;\\n                break;\\n            }\\n        }\\n        if (friendshipPossible) dsu.union(friend1, friend2);\\n        result.push(friendshipPossible);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\n/*\\nDSU Class Template\\n*/\\nclass DSU {\\n    constructor() {\\n        this.parents = new Map();\\n        this.rank = new Map();\\n    }\\n    \\n    add(x) {\\n        this.parents.set(x, x);\\n        this.rank.set(x, 0);\\n    }\\n    \\n    find(x) {\\n        const parent = this.parents.get(x);\\n        if (parent === x) return x;\\n        const setParent = this.find(parent);\\n        this.parents.set(x, setParent);\\n        return setParent;\\n    }\\n    \\n    union(x, y) {\\n        const xParent = this.find(x), yParent = this.find(y);\\n        const xRank = this.rank.get(xParent), yRank = this.rank.get(yParent);\\n        if (xParent === yParent) return;\\n        if (xRank > yRank) {\\n            this.parents.set(yParent, xParent);\\n        } else if (yRank > xRank) {\\n            this.parents.set(xParent, yParent);\\n        } else {\\n            this.parents.set(xParent, yParent);\\n            this.rank.set(yParent, yRank + 1);\\n        }   \\n    }\\n}\\n\\n/*\\nFriend Requests\\n*/\\nvar friendRequests = function(n, restrictions, requests) {\\n    const dsu = new DSU(), result = [];\\n    for (let i = 0; i < n; i++) dsu.add(i);\\n    \\n    for (let [friend1, friend2] of requests) {\\n        const parent1 = dsu.find(friend1), parent2 = dsu.find(friend2);\\n        let friendshipPossible = true;\\n        for (let [enemy1, enemy2] of restrictions) {\\n            const enemyParent1 = dsu.find(enemy1), enemyParent2 = dsu.find(enemy2);\\n            const condition1 = (enemyParent1 === parent1 && enemyParent2 === parent2);\\n            const condition2 = (enemyParent1 === parent2 && enemyParent2 === parent1);\\n            if (condition1 || condition2) {\\n                friendshipPossible = false;\\n                break;\\n            }\\n        }\\n        if (friendshipPossible) dsu.union(friend1, friend2);\\n        result.push(friendshipPossible);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878809,
                "title": "python-union-find-bitmask-o-m-n",
                "content": "*uni.rep* means friends in one group, *uni.cnf* means this group cannot make friends with these people.\\n```\\nclass UniSet:\\n    def __init__(self, n):\\n        self.uni = list(range(n))\\n        self.rep = [1 << i for i in range(n)]\\n        self.cnf = [0] * n\\n    \\n    def find(self, x):\\n        if self.uni[x] != x: self.uni[x] = self.find(self.uni[x])\\n        return self.uni[x]\\n    \\n    def same(self, x, y):\\n        return self.find(x) == self.find(y)\\n\\n    def check_merge(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        if self.cnf[x] & self.rep[y] | self.rep[x] & self.cnf[y]: return False\\n        x, y = min(x, y), max(x, y)\\n        self.uni[y] = x\\n        self.rep[x] |= self.rep[y]\\n        self.cnf[x] |= self.cnf[y]\\n        return True\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        uni = UniSet(n)\\n        for x, y in restrictions:\\n            uni.cnf[x] |= 1 << y\\n            uni.cnf[y] |= 1 << x\\n        return [uni.check_merge(x, y) for x, y in requests]\\n```",
                "solutionTags": [],
                "code": "```\\nclass UniSet:\\n    def __init__(self, n):\\n        self.uni = list(range(n))\\n        self.rep = [1 << i for i in range(n)]\\n        self.cnf = [0] * n\\n    \\n    def find(self, x):\\n        if self.uni[x] != x: self.uni[x] = self.find(self.uni[x])\\n        return self.uni[x]\\n    \\n    def same(self, x, y):\\n        return self.find(x) == self.find(y)\\n\\n    def check_merge(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        if self.cnf[x] & self.rep[y] | self.rep[x] & self.cnf[y]: return False\\n        x, y = min(x, y), max(x, y)\\n        self.uni[y] = x\\n        self.rep[x] |= self.rep[y]\\n        self.cnf[x] |= self.cnf[y]\\n        return True\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        uni = UniSet(n)\\n        for x, y in restrictions:\\n            uni.cnf[x] |= 1 << y\\n            uni.cnf[y] |= 1 << x\\n        return [uni.check_merge(x, y) for x, y in requests]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645066,
                "title": "simple-union-find-in-java",
                "content": "Before using union, go through all restrictions, and make sure they are not in the same group as the two nodes currently being connnected. \\nSay, current request is n1 - n2. \\nAnd there is a restriction s1 - s2 \\nIf s1 is connected to n1 and s2 is connected to n2. \\nWhen n1 and n2 are connected, s1 and s2 get connected indirectly too. \\nTherefore we make sure that there is no pair of restriction that gets connected on accepting the request. \\nIf there is no pair of restriction for the same, then we do union. \\n\\n```\\n\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] parent = new int[n];\\n        boolean[] ans = new boolean[requests.length];\\n        int[] rank = new int[requests.length];\\n        for (int i = 0; i < n; i++){parent[i] = i;} \\n        \\n        for (int i = 0; i < requests.length; i++){\\n           int t1 = find(parent, requests[i][0]);\\n           int t2 = find(parent, requests[i][1]);\\n           boolean vis = true;\\n            for (int j = 0; j < restrictions.length; j++){\\n               int a1 = find(parent, restrictions[j][0]);\\n               int a2 = find(parent, restrictions[j][1]);\\n               if (a1 == t1 && a2 == t2){\\n                   vis = false; break;\\n               }\\n               else if (a1 == t2 && a2 == t1){\\n                   vis = false; break;\\n               }\\n                else if (a1 == t1 && a2 == t1){\\n                    vis = false; break;\\n                }\\n                else if (a1 == t2 && a2 == t2){vis = false; break;}\\n               \\n           }\\n            if (vis == true){ans[i] = true; union(parent, requests[i][0], requests[i][1]);}\\n            \\n        }\\n        \\n        return ans; \\n        \\n    }\\n    public int find(int[] parents, int i){\\n        if (parents[i] == i) return i; \\n        return find(parents, parents[i]);\\n    }\\n    \\n    public void union(int[] parent, int a1, int a2){\\n        if (find(parent, a1) == find(parent, a2)) return; \\n        int s1 = find(parent, a1); int s2 = find(parent, a2);\\n        parent[s2] = s1; \\n        \\n    }\\n    \\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\n\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] parent = new int[n];\\n        boolean[] ans = new boolean[requests.length];\\n        int[] rank = new int[requests.length];\\n        for (int i = 0; i < n; i++){parent[i] = i;} \\n        \\n        for (int i = 0; i < requests.length; i++){\\n           int t1 = find(parent, requests[i][0]);\\n           int t2 = find(parent, requests[i][1]);\\n           boolean vis = true;\\n            for (int j = 0; j < restrictions.length; j++){\\n               int a1 = find(parent, restrictions[j][0]);\\n               int a2 = find(parent, restrictions[j][1]);\\n               if (a1 == t1 && a2 == t2){\\n                   vis = false; break;\\n               }\\n               else if (a1 == t2 && a2 == t1){\\n                   vis = false; break;\\n               }\\n                else if (a1 == t1 && a2 == t1){\\n                    vis = false; break;\\n                }\\n                else if (a1 == t2 && a2 == t2){vis = false; break;}\\n               \\n           }\\n            if (vis == true){ans[i] = true; union(parent, requests[i][0], requests[i][1]);}\\n            \\n        }\\n        \\n        return ans; \\n        \\n    }\\n    public int find(int[] parents, int i){\\n        if (parents[i] == i) return i; \\n        return find(parents, parents[i]);\\n    }\\n    \\n    public void union(int[] parent, int a1, int a2){\\n        if (find(parent, a1) == find(parent, a2)) return; \\n        int s1 = find(parent, a1); int s2 = find(parent, a2);\\n        parent[s2] = s1; \\n        \\n    }\\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629225,
                "title": "java-union-find-solution-with-comment",
                "content": "```\\nclass Solution {\\n    int[] parent;\\n    boolean[] result;\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n        result = new boolean[requests.length];\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            // personA and personB can become friends if for all restrictions\\n            // person x_i and person y_i are not in the same set as personA and personB\\n            // and vice versa\\n            int personA = requests[i][0];\\n            int personB = requests[i][1];\\n            int personASetRepresentative = find(personA);\\n            int personBSetRepresentative = find(personB);\\n            boolean flag = true;\\n            for (int[] restriction : restrictions) {\\n                int blackListPersonARepresentative = find(restriction[0]);\\n                int blackListPersonBRepresentative = find(restriction[1]);\\n                if (personASetRepresentative == blackListPersonARepresentative && personBSetRepresentative == blackListPersonBRepresentative) {\\n                    flag = false;\\n                }\\n                if (personASetRepresentative == blackListPersonBRepresentative && personBSetRepresentative == blackListPersonARepresentative) {\\n                    flag = false;\\n                }\\n            }\\n            if (flag) {\\n                union(personA, personB);\\n            }\\n            result[i] = flag;\\n        }\\n        return result;\\n    }\\n    \\n    private int find(int node) {\\n        int root = node;\\n        while (parent[root] != root) {\\n            root = parent[root];\\n        }\\n        \\n        //path compression\\n        int curr = node;\\n        while (parent[curr] != root) {\\n            int next = parent[curr];\\n            parent[curr] = root;\\n            curr = next;\\n        }\\n        return root;\\n    }\\n    \\n    private boolean union(int node1, int node2) {\\n        int root1 = find(node1);\\n        int root2 = find(node2);\\n        if (root1 == root2) {\\n            return false;\\n        }\\n        parent[root2] = root1;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int[] parent;\\n    boolean[] result;\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n        result = new boolean[requests.length];\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            // personA and personB can become friends if for all restrictions\\n            // person x_i and person y_i are not in the same set as personA and personB\\n            // and vice versa\\n            int personA = requests[i][0];\\n            int personB = requests[i][1];\\n            int personASetRepresentative = find(personA);\\n            int personBSetRepresentative = find(personB);\\n            boolean flag = true;\\n            for (int[] restriction : restrictions) {\\n                int blackListPersonARepresentative = find(restriction[0]);\\n                int blackListPersonBRepresentative = find(restriction[1]);\\n                if (personASetRepresentative == blackListPersonARepresentative && personBSetRepresentative == blackListPersonBRepresentative) {\\n                    flag = false;\\n                }\\n                if (personASetRepresentative == blackListPersonBRepresentative && personBSetRepresentative == blackListPersonARepresentative) {\\n                    flag = false;\\n                }\\n            }\\n            if (flag) {\\n                union(personA, personB);\\n            }\\n            result[i] = flag;\\n        }\\n        return result;\\n    }\\n    \\n    private int find(int node) {\\n        int root = node;\\n        while (parent[root] != root) {\\n            root = parent[root];\\n        }\\n        \\n        //path compression\\n        int curr = node;\\n        while (parent[curr] != root) {\\n            int next = parent[curr];\\n            parent[curr] = root;\\n            curr = next;\\n        }\\n        return root;\\n    }\\n    \\n    private boolean union(int node1, int node2) {\\n        int root1 = find(node1);\\n        int root2 = find(node2);\\n        if (root1 == root2) {\\n            return false;\\n        }\\n        parent[root2] = root1;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581108,
                "title": "java-dsu-direct-application",
                "content": "\\n```\\nclass Solution {\\n    int[] parent, rank;\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        \\n        for(int i = 0; i < n; i++)\\n            parent[i] = i;\\n        \\n        boolean[] ans = new boolean[requests.length]; \\n        \\n        for(int i = 0; i < requests.length; i++) {\\n            int u = requests[i][0];\\n            int v = requests[i][1];\\n            \\n            u = find(u);\\n            v = find(v);\\n            \\n            boolean flag = true;\\n            \\n            for(int j = 0; j < restrictions.length; j++) {\\n                int u_ = restrictions[j][0];\\n                int v_ = restrictions[j][1];\\n                \\n                u_ = find(u_);\\n                v_ = find(v_);\\n                \\n                if((u_ == u && v_ == v) || (u_ == v && v_ == u)) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag == true)\\n                union(u, v);\\n            \\n            ans[i] = flag;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    // Time complexity = O(n^2)\\n    // Space complexity = O(n)\\n    \\n    private int find(int x) {\\n        if(parent[x] == x)\\n            return x;\\n        \\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    private void union(int u, int v) {\\n        u = find(u);\\n        v = find(v);\\n        \\n        if(rank[u] > rank[v])\\n            parent[v] = u;\\n\\n        else if(rank[u] < rank[v])\\n            parent[u] = v;\\n\\n        else {\\n            parent[u] = v;\\n            rank[v]++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] parent, rank;\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        \\n        for(int i = 0; i < n; i++)\\n            parent[i] = i;\\n        \\n        boolean[] ans = new boolean[requests.length]; \\n        \\n        for(int i = 0; i < requests.length; i++) {\\n            int u = requests[i][0];\\n            int v = requests[i][1];\\n            \\n            u = find(u);\\n            v = find(v);\\n            \\n            boolean flag = true;\\n            \\n            for(int j = 0; j < restrictions.length; j++) {\\n                int u_ = restrictions[j][0];\\n                int v_ = restrictions[j][1];\\n                \\n                u_ = find(u_);\\n                v_ = find(v_);\\n                \\n                if((u_ == u && v_ == v) || (u_ == v && v_ == u)) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag == true)\\n                union(u, v);\\n            \\n            ans[i] = flag;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    // Time complexity = O(n^2)\\n    // Space complexity = O(n)\\n    \\n    private int find(int x) {\\n        if(parent[x] == x)\\n            return x;\\n        \\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    private void union(int u, int v) {\\n        u = find(u);\\n        v = find(v);\\n        \\n        if(rank[u] > rank[v])\\n            parent[v] = u;\\n\\n        else if(rank[u] < rank[v])\\n            parent[u] = v;\\n\\n        else {\\n            parent[u] = v;\\n            rank[v]++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577153,
                "title": "python-272-ms-36-mb-maintain-connected-components-of-the-graph",
                "content": "Maintain two lists of sets ```connected_components``` and ```banned_by_comps``` to store the connected components the restrictions of nodes in each connected component. Maintain a dictionary ```connected_comp_dict``` to map each node to its connected compoent. Update them when a new edge is added.\\n```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:        \\n        result = [False for _ in requests]\\n        \\n        connected_components = [{i} for i in range(n)]\\n        \\n        connected_comp_dict = {}\\n        for i in range(n):\\n            connected_comp_dict[i] = i\\n        \\n        banned_by_comps = [set() for i in range(n)]\\n        for res in restrictions:\\n            banned_by_comps[res[0]].add(res[1])\\n            banned_by_comps[res[1]].add(res[0])\\n        for i,r in enumerate(requests):\\n            n1, n2 = r[0], r[1]\\n            c1, c2 = connected_comp_dict[n1], connected_comp_dict[n2]\\n            if c1 == c2:\\n                result[i] = True\\n            else:\\n                if not (connected_components[c1].intersection(banned_by_comps[c2]) or connected_components[c2].intersection(banned_by_comps[c1])):\\n                    connected_components[c1].update(connected_components[c2])\\n                    banned_by_comps[c1].update(banned_by_comps[c2])\\n                    for node in connected_components[c2]:\\n                        connected_comp_dict[node] = c1\\n                    result[i] = True\\n                \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph",
                    "Ordered Set"
                ],
                "code": "```connected_components```\n```banned_by_comps```\n```connected_comp_dict```\n```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:        \\n        result = [False for _ in requests]\\n        \\n        connected_components = [{i} for i in range(n)]\\n        \\n        connected_comp_dict = {}\\n        for i in range(n):\\n            connected_comp_dict[i] = i\\n        \\n        banned_by_comps = [set() for i in range(n)]\\n        for res in restrictions:\\n            banned_by_comps[res[0]].add(res[1])\\n            banned_by_comps[res[1]].add(res[0])\\n        for i,r in enumerate(requests):\\n            n1, n2 = r[0], r[1]\\n            c1, c2 = connected_comp_dict[n1], connected_comp_dict[n2]\\n            if c1 == c2:\\n                result[i] = True\\n            else:\\n                if not (connected_components[c1].intersection(banned_by_comps[c2]) or connected_components[c2].intersection(banned_by_comps[c1])):\\n                    connected_components[c1].update(connected_components[c2])\\n                    banned_by_comps[c1].update(banned_by_comps[c2])\\n                    for node in connected_components[c2]:\\n                        connected_comp_dict[node] = c1\\n                    result[i] = True\\n                \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577131,
                "title": "c-union-find-easy-to-understand",
                "content": "#### Algorithm  ( Union Find with modification ) \\n\\n* Process the request first \\n* Store Parent Array in some other temporary data structure.\\n* Merge the vertices/nodes \\n* Check in the requests array if we have violated the conditions\\n* If conditions are violated rollback the requests by updating parent array to the one stored in temporary data structure.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n    int find(int node)\\n    {\\n        \\n        if(node==parent[node])\\n            return node;\\n        \\n        return parent[node]=find(parent[node]);\\n    }\\n    void merge(int u,int v)\\n    {\\n        int pu=find(u);\\n        int pv=find(v);\\n        parent[pu]=pv;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        \\n        \\n        int i;\\n        \\n        parent.resize(n);\\n        for(i=0;i<n;i++)\\n            parent[i]=i;\\n        \\n        vector<bool>ans(requests.size());\\n        \\n       for(i=0;i<requests.size();i++)\\n       {\\n           int u=requests[i][0];\\n           int v=requests[i][1];\\n           \\n           \\n           auto temp_copy=parent;\\n           ans[i]=true;\\n           merge(u,v);\\n           for(auto &it:restrictions)\\n           {\\n               \\n               int p=it[0];\\n               int q=it[1];\\n               \\n               if(find(p)==find(q))\\n               {\\n                   ans[i]=false;\\n                   break;\\n                }\\n            }\\n           if(!ans[i])\\n               parent=temp_copy;\\n               \\n       }\\n       \\n        return ans;\\n        \\n    }\\n};\\n\\n```\\n \\n### Pls upvote if you found helpful",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n    int find(int node)\\n    {\\n        \\n        if(node==parent[node])\\n            return node;\\n        \\n        return parent[node]=find(parent[node]);\\n    }\\n    void merge(int u,int v)\\n    {\\n        int pu=find(u);\\n        int pv=find(v);\\n        parent[pu]=pv;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        \\n        \\n        int i;\\n        \\n        parent.resize(n);\\n        for(i=0;i<n;i++)\\n            parent[i]=i;\\n        \\n        vector<bool>ans(requests.size());\\n        \\n       for(i=0;i<requests.size();i++)\\n       {\\n           int u=requests[i][0];\\n           int v=requests[i][1];\\n           \\n           \\n           auto temp_copy=parent;\\n           ans[i]=true;\\n           merge(u,v);\\n           for(auto &it:restrictions)\\n           {\\n               \\n               int p=it[0];\\n               int q=it[1];\\n               \\n               if(find(p)==find(q))\\n               {\\n                   ans[i]=false;\\n                   break;\\n                }\\n            }\\n           if(!ans[i])\\n               parent=temp_copy;\\n               \\n       }\\n       \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576985,
                "title": "c-2076-process-restricted-friend-requests",
                "content": "\\n```\\nclass UnionFind {\\npublic: \\n    vector<int> parent, rank; \\n    UnionFind(int n) {\\n        parent.resize(n); \\n        iota(begin(parent), end(parent), 0); \\n        rank.resize(n); \\n        fill(rank.begin(), rank.end(), 1); \\n    } \\n    \\n    int find(int p) {\\n        /* find with path compression */\\n        if (parent[p] != p) \\n            parent[p] = find(parent[p]); \\n        return parent[p]; \\n    }\\n    \\n    bool connect(int p, int q) {\\n        /* union with rank */\\n        int prt = find(p), qrt = find(q); \\n        if (prt == qrt) return false; \\n        if (rank[prt] > rank[qrt]) swap(prt, qrt);\\n        parent[prt] = qrt; \\n        rank[qrt] += rank[prt]; \\n        return true; \\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> ans; \\n        UnionFind *uf = new UnionFind(n); \\n        for (auto& request : requests) {\\n            int u = uf->find(request[0]), v = uf->find(request[1]); \\n            bool found = false; \\n            for (auto& restriction : restrictions) {\\n                int x = uf->find(restriction[0]), y = uf->find(restriction[1]); \\n                if ((u == x && v == y) || (u == y && v == x)) {\\n                    found = true; \\n                    break; \\n                }\\n            }\\n            ans.push_back(!found); \\n            if (!found) uf->connect(u, v); \\n        }\\n        delete uf; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass UnionFind {\\npublic: \\n    vector<int> parent, rank; \\n    UnionFind(int n) {\\n        parent.resize(n); \\n        iota(begin(parent), end(parent), 0); \\n        rank.resize(n); \\n        fill(rank.begin(), rank.end(), 1); \\n    } \\n    \\n    int find(int p) {\\n        /* find with path compression */\\n        if (parent[p] != p) \\n            parent[p] = find(parent[p]); \\n        return parent[p]; \\n    }\\n    \\n    bool connect(int p, int q) {\\n        /* union with rank */\\n        int prt = find(p), qrt = find(q); \\n        if (prt == qrt) return false; \\n        if (rank[prt] > rank[qrt]) swap(prt, qrt);\\n        parent[prt] = qrt; \\n        rank[qrt] += rank[prt]; \\n        return true; \\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> ans; \\n        UnionFind *uf = new UnionFind(n); \\n        for (auto& request : requests) {\\n            int u = uf->find(request[0]), v = uf->find(request[1]); \\n            bool found = false; \\n            for (auto& restriction : restrictions) {\\n                int x = uf->find(restriction[0]), y = uf->find(restriction[1]); \\n                if ((u == x && v == y) || (u == y && v == x)) {\\n                    found = true; \\n                    break; \\n                }\\n            }\\n            ans.push_back(!found); \\n            if (!found) uf->connect(u, v); \\n        }\\n        delete uf; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576965,
                "title": "python3-union-find",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/8d693371fa97ea3b0717d02448c77201b15e5d12) for solutions of weekly 267.\\n```\\nclass UnionFind:\\n\\n\\tdef __init__(self, n: int):\\n\\t\\tself.parent = list(range(n))\\n\\t\\tself.rank = [1] * n\\n\\n\\tdef find(self, p: int, halving: bool=True) -> int:\\n\\t\\tif p != self.parent[p]:\\n\\t\\t\\tself.parent[p] = self.find(self.parent[p]) \\n\\t\\treturn self.parent[p]\\n\\n\\tdef union(self, p: int, q: int) -> bool:\\n\\t\\tprt, qrt = self.find(p), self.find(q)\\n\\t\\tif prt == qrt: return False \\n\\t\\tif self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt \\n\\t\\tself.parent[prt] = qrt\\n\\t\\tself.rank[qrt] += self.rank[prt]\\n\\t\\treturn True\\n\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        ans = []\\n        uf = UnionFind(n)\\n        for u, v in requests: \\n            uu = uf.find(u)\\n            vv = uf.find(v)\\n            for x, y in restrictions: \\n                xx = uf.find(x)\\n                yy = uf.find(y)\\n                if uu == xx and vv == yy or uu == yy and vv == xx: \\n                    ans.append(False)\\n                    break \\n            else: \\n                ans.append(True)\\n                uf.union(u, v)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind:\\n\\n\\tdef __init__(self, n: int):\\n\\t\\tself.parent = list(range(n))\\n\\t\\tself.rank = [1] * n\\n\\n\\tdef find(self, p: int, halving: bool=True) -> int:\\n\\t\\tif p != self.parent[p]:\\n\\t\\t\\tself.parent[p] = self.find(self.parent[p]) \\n\\t\\treturn self.parent[p]\\n\\n\\tdef union(self, p: int, q: int) -> bool:\\n\\t\\tprt, qrt = self.find(p), self.find(q)\\n\\t\\tif prt == qrt: return False \\n\\t\\tif self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt \\n\\t\\tself.parent[prt] = qrt\\n\\t\\tself.rank[qrt] += self.rank[prt]\\n\\t\\treturn True\\n\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        ans = []\\n        uf = UnionFind(n)\\n        for u, v in requests: \\n            uu = uf.find(u)\\n            vv = uf.find(v)\\n            for x, y in restrictions: \\n                xx = uf.find(x)\\n                yy = uf.find(y)\\n                if uu == xx and vv == yy or uu == yy and vv == xx: \\n                    ans.append(False)\\n                    break \\n            else: \\n                ans.append(True)\\n                uf.union(u, v)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576953,
                "title": "java-sets-with-communities-easy-to-understand",
                "content": "**Idea**: Create a list of sets of communities (`List<Set<Integer>> communities`) and check whether can be they joined or not based on restrictions.\\n\\n**Algorithm**: Let\\'s take example from the problem. `n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]]`. You will firstly create such communities` [ {0}, {1}, {2} ]`. Furthermore, we will maintain restrictions in hashmap for quick access.\\nThen, in each request we check whether we are able to merge these communities together or not. After first iteration (`[0,2]`), we will get `[ {0,2}, {1} ]`. In the second request, we see that `{1}` cannot be inside the set with `0` and `2`, becase `2` has `0` in its community. Please, check the code for additional conditions of comparing the sets with each other.\\n\\n\\n```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        List<Integer>[] restricted = new List[n];\\n        for (int i = 0; i < n; i++)\\n            restricted[i] = new ArrayList<Integer>();\\n        \\n        for (int[] r : restrictions) {\\n            restricted[r[0]].add(r[1]);\\n            restricted[r[1]].add(r[0]);\\n        }\\n        \\n        List<HashSet<Integer>> communities = new ArrayList();\\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> s = new HashSet<Integer>();\\n            s.add(i);\\n            communities.add(s);\\n        }\\n        \\n        int k = 0;\\n        for (int[] req : requests) {\\n            int x = req[0];\\n            int y = req[1];\\n            int xi = 0, yi = 0; // Indices of sets in which there people belong to\\n            \\n            for (int i = 0; i < communities.size(); i++) {\\n                if (communities.get(i).contains(x)) {\\n                    xi = i;\\n                }\\n                if (communities.get(i).contains(y)) {\\n                    yi = i;\\n                }\\n            }\\n            \\n            if (xi == yi) {  // they are both already in one community\\n                res[k++] = true;\\n                continue;\\n            }\\n            \\n            int flag = -1;\\n            for (int node : communities.get(xi)) {\\n                if (flag >= 0) break;\\n                for (int other : communities.get(yi)) {\\n                    if (restricted[node].contains(other)) {\\n                        flag = 0;\\n                        break;\\n                    } else if (communities.get(xi).contains(other)) {\\n                        flag = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (flag == 0) {\\n                res[k++] = false;\\n            } else {\\n                mergeSets(communities, xi, yi);\\n                res[k++] = true;\\n            }\\n        } \\n        \\n        return res;\\n    }\\n    \\n    public void mergeSets(List<HashSet<Integer>> communities, int xi, int yi) {\\n        HashSet<Integer> a = communities.get(xi);\\n        HashSet<Integer> b = communities.get(yi);\\n        if (xi > yi) {\\n            communities.remove(xi);\\n            communities.remove(yi);\\n        } else {\\n            communities.remove(yi);\\n            communities.remove(xi);\\n        }\\n        for (int val : b) {\\n            a.add(val);\\n        }\\n        communities.add(a);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        List<Integer>[] restricted = new List[n];\\n        for (int i = 0; i < n; i++)\\n            restricted[i] = new ArrayList<Integer>();\\n        \\n        for (int[] r : restrictions) {\\n            restricted[r[0]].add(r[1]);\\n            restricted[r[1]].add(r[0]);\\n        }\\n        \\n        List<HashSet<Integer>> communities = new ArrayList();\\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> s = new HashSet<Integer>();\\n            s.add(i);\\n            communities.add(s);\\n        }\\n        \\n        int k = 0;\\n        for (int[] req : requests) {\\n            int x = req[0];\\n            int y = req[1];\\n            int xi = 0, yi = 0; // Indices of sets in which there people belong to\\n            \\n            for (int i = 0; i < communities.size(); i++) {\\n                if (communities.get(i).contains(x)) {\\n                    xi = i;\\n                }\\n                if (communities.get(i).contains(y)) {\\n                    yi = i;\\n                }\\n            }\\n            \\n            if (xi == yi) {  // they are both already in one community\\n                res[k++] = true;\\n                continue;\\n            }\\n            \\n            int flag = -1;\\n            for (int node : communities.get(xi)) {\\n                if (flag >= 0) break;\\n                for (int other : communities.get(yi)) {\\n                    if (restricted[node].contains(other)) {\\n                        flag = 0;\\n                        break;\\n                    } else if (communities.get(xi).contains(other)) {\\n                        flag = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (flag == 0) {\\n                res[k++] = false;\\n            } else {\\n                mergeSets(communities, xi, yi);\\n                res[k++] = true;\\n            }\\n        } \\n        \\n        return res;\\n    }\\n    \\n    public void mergeSets(List<HashSet<Integer>> communities, int xi, int yi) {\\n        HashSet<Integer> a = communities.get(xi);\\n        HashSet<Integer> b = communities.get(yi);\\n        if (xi > yi) {\\n            communities.remove(xi);\\n            communities.remove(yi);\\n        } else {\\n            communities.remove(yi);\\n            communities.remove(xi);\\n        }\\n        for (int val : b) {\\n            a.add(val);\\n        }\\n        communities.add(a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576937,
                "title": "javascript-union-find-2-solutions",
                "content": "```javascript\\nvar friendRequests = function(numPeople, restrictions, requests) {\\n    // base union find data structure\\n    const friendships = [...new Array(numPeople).keys()];\\n    // this is equivalent to find in union find\\n    const findRootFriend = (x) => friendships[x] = friendships[x] === x ? x : findRootFriend(friendships[x]);\\n    // this is equivalent to union in union find\\n    const createFriendship = (x, y) => friendships[findRootFriend(x)] = findRootFriend(y);\\n    \\n    const isInSameFriendshipGroup = (person1, person2) => findRootFriend(person1) === findRootFriend(person2);\\n    const findFriendsInGroup = (friend) => {\\n        const friendsInGroup = [];\\n        for (let person = 0; person < numPeople; person++) {\\n            if (isInSameFriendshipGroup(person, friend)) {\\n                friendsInGroup.push(person);\\n            }\\n        }\\n        return friendsInGroup;\\n    }\\n    \\n    const mappedRestrictions = mapRestrictions(numPeople, restrictions);\\n    \\n    return requests.map(([friend1, friend2], i) => {\\n        const friendsOfFriend1 = findFriendsInGroup(friend1);\\n        \\n        for (let person = 0; person < numPeople; person++) {\\n            if (isInSameFriendshipGroup(person, friend2)) {\\n\\n                // check all the friends in friend1\\'s group to see if\\n                // person can be friends with friend of friend1\\n                for (let friendOfFriend1 of friendsOfFriend1) {\\n                    if (mappedRestrictions[person].has(friendOfFriend1)) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        // create the friendship\\n        createFriendship(friend1, friend2);\\n        return true;\\n    })\\n};\\n\\nfunction mapRestrictions(numPeople, restrictions) {\\n    const mappedRestrictions = new Array(numPeople).fill(0).map(() => new Set());\\n    for (const [person1, person2] of restrictions) {\\n        mappedRestrictions[person1].add(person2);\\n        mappedRestrictions[person2].add(person1);\\n    }\\n    return mappedRestrictions;\\n}\\n\\n\\n\\n//////////////////////////////////////////////////////////\\n//////////////////////////////////////////////////////////\\n//////////////////////////////////////////////////////////\\n// Credit to: lee215\\n\\n\\nvar friendRequests = function(numPeople, restrictions, requests) {\\n    // base union find data structure\\n    const friendships = [...new Array(numPeople).keys()];\\n    // this is equivalent to find in union find\\n    const findRootFriend = (x) => friendships[x] = friendships[x] === x ? x : findRootFriend(friendships[x]);\\n    // this is equivalent to union in union find\\n    const createFriendship = (x, y) => friendships[findRootFriend(x)] = findRootFriend(y);\\n    const isInSameFriendshipGroup = (person1, person2) => findRootFriend(person1) === findRootFriend(person2);\\n    \\n    return requests.map(([friend1, friend2], i) => {\\n        if (isInSameFriendshipGroup(friend1, friend2)) return true;\\n        \\n        for (const [person1, person2] of restrictions) {\\n            if ((isInSameFriendshipGroup(person1, friend1) && isInSameFriendshipGroup(person2, friend2)) ||\\n                (isInSameFriendshipGroup(person1, friend2) && isInSameFriendshipGroup(person2, friend1))) {\\n                return false;\\n            }\\n        }\\n        createFriendship(friend1, friend2);\\n        return true;\\n    })\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```javascript\\nvar friendRequests = function(numPeople, restrictions, requests) {\\n    // base union find data structure\\n    const friendships = [...new Array(numPeople).keys()];\\n    // this is equivalent to find in union find\\n    const findRootFriend = (x) => friendships[x] = friendships[x] === x ? x : findRootFriend(friendships[x]);\\n    // this is equivalent to union in union find\\n    const createFriendship = (x, y) => friendships[findRootFriend(x)] = findRootFriend(y);\\n    \\n    const isInSameFriendshipGroup = (person1, person2) => findRootFriend(person1) === findRootFriend(person2);\\n    const findFriendsInGroup = (friend) => {\\n        const friendsInGroup = [];\\n        for (let person = 0; person < numPeople; person++) {\\n            if (isInSameFriendshipGroup(person, friend)) {\\n                friendsInGroup.push(person);\\n            }\\n        }\\n        return friendsInGroup;\\n    }\\n    \\n    const mappedRestrictions = mapRestrictions(numPeople, restrictions);\\n    \\n    return requests.map(([friend1, friend2], i) => {\\n        const friendsOfFriend1 = findFriendsInGroup(friend1);\\n        \\n        for (let person = 0; person < numPeople; person++) {\\n            if (isInSameFriendshipGroup(person, friend2)) {\\n\\n                // check all the friends in friend1\\'s group to see if\\n                // person can be friends with friend of friend1\\n                for (let friendOfFriend1 of friendsOfFriend1) {\\n                    if (mappedRestrictions[person].has(friendOfFriend1)) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        // create the friendship\\n        createFriendship(friend1, friend2);\\n        return true;\\n    })\\n};\\n\\nfunction mapRestrictions(numPeople, restrictions) {\\n    const mappedRestrictions = new Array(numPeople).fill(0).map(() => new Set());\\n    for (const [person1, person2] of restrictions) {\\n        mappedRestrictions[person1].add(person2);\\n        mappedRestrictions[person2].add(person1);\\n    }\\n    return mappedRestrictions;\\n}\\n\\n\\n\\n//////////////////////////////////////////////////////////\\n//////////////////////////////////////////////////////////\\n//////////////////////////////////////////////////////////\\n// Credit to: lee215\\n\\n\\nvar friendRequests = function(numPeople, restrictions, requests) {\\n    // base union find data structure\\n    const friendships = [...new Array(numPeople).keys()];\\n    // this is equivalent to find in union find\\n    const findRootFriend = (x) => friendships[x] = friendships[x] === x ? x : findRootFriend(friendships[x]);\\n    // this is equivalent to union in union find\\n    const createFriendship = (x, y) => friendships[findRootFriend(x)] = findRootFriend(y);\\n    const isInSameFriendshipGroup = (person1, person2) => findRootFriend(person1) === findRootFriend(person2);\\n    \\n    return requests.map(([friend1, friend2], i) => {\\n        if (isInSameFriendshipGroup(friend1, friend2)) return true;\\n        \\n        for (const [person1, person2] of restrictions) {\\n            if ((isInSameFriendshipGroup(person1, friend1) && isInSameFriendshipGroup(person2, friend2)) ||\\n                (isInSameFriendshipGroup(person1, friend2) && isInSameFriendshipGroup(person2, friend1))) {\\n                return false;\\n            }\\n        }\\n        createFriendship(friend1, friend2);\\n        return true;\\n    })\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1576934,
                "title": "c-solution-union-find-and-brute-force",
                "content": "\\n\\n### Idea\\n- Try to make a connection for each request, after making this connection and if one of the restrictions is violated, then the answer is false and recover the union-find array to the previous status.\\n  \\n```\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    vector<int> vis;\\n    int find(int x) {\\n        if(arr[x] == 0) return arr[x] = x;\\n        if(arr[x] == x) return x;\\n        return arr[x] = find(arr[x]);\\n    }\\n    void combine(int a, int b) {\\n        a = find(a);\\n        b = find(b);\\n        arr[a] = b;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        arr.resize(n + 2);\\n        vector<bool> ans(requests.size());\\n        for(int i = 0; i < requests.size(); i++) {\\n            int a = requests[i][0] + 1, b = requests[i][1] + 1;\\n            auto src = arr;\\n            combine(a, b);\\n            ans[i] = true;\\n            for(auto &r : restrictions) {\\n                int a = r[0] + 1, b = r[1] + 1;\\n                if(find(a) == find(b)) {\\n                    ans[i] = false;\\n                    break;\\n                }\\n            }\\n            if(!ans[i]) arr = src;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    vector<int> vis;\\n    int find(int x) {\\n        if(arr[x] == 0) return arr[x] = x;\\n        if(arr[x] == x) return x;\\n        return arr[x] = find(arr[x]);\\n    }\\n    void combine(int a, int b) {\\n        a = find(a);\\n        b = find(b);\\n        arr[a] = b;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        arr.resize(n + 2);\\n        vector<bool> ans(requests.size());\\n        for(int i = 0; i < requests.size(); i++) {\\n            int a = requests[i][0] + 1, b = requests[i][1] + 1;\\n            auto src = arr;\\n            combine(a, b);\\n            ans[i] = true;\\n            for(auto &r : restrictions) {\\n                int a = r[0] + 1, b = r[1] + 1;\\n                if(find(a) == find(b)) {\\n                    ans[i] = false;\\n                    break;\\n                }\\n            }\\n            if(!ans[i]) arr = src;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814592,
                "title": "union-find-disjoint-sets-solution-faster-than-90-java",
                "content": "# Code\\n```\\nclass DisjointSet {\\n    private final int[] root;\\n    private final int[] rank;\\n    private final List<Set<Integer>> restrictions;\\n\\n    DisjointSet(int size, int[][] restrictions) {\\n        root = new int[size];\\n        rank = new int[size];\\n        this.restrictions = new ArrayList<>();\\n        for (int i = 0; i < size; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n            this.restrictions.add(new HashSet<>());\\n        }\\n        for (int[] restriction: restrictions) {\\n            this.restrictions.get(restriction[0]).add(restriction[1]);\\n            this.restrictions.get(restriction[1]).add(restriction[0]);\\n        }\\n    }\\n\\n    private int find(int vertex) {\\n        if(root[vertex] == vertex) return vertex;\\n        return root[vertex] = find(root[vertex]);\\n    }\\n\\n    public boolean union(int vertex1, int vertex2) {\\n        int root1 = find(vertex1);\\n        int root2 = find(vertex2);\\n        if(root1 == root2) return true;\\n        if(notRestricted(root1, root2)) {\\n            if(rank[root1] > rank[root2]) {\\n                root[root2] = root1;\\n                restrictions.get(root1).addAll(restrictions.get(root2));\\n                addRoots(root1);\\n            } else if(rank[root2] > rank[root1]) {\\n                root[root1] = root2;\\n                restrictions.get(root2).addAll(restrictions.get(root1));\\n                addRoots(root2);\\n            } else {\\n                root[root2] = root1;\\n                rank[root1]++;\\n                restrictions.get(root1).addAll(restrictions.get(root2));\\n                addRoots(root1);\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    private void addRoots(int index) {\\n        Set<Integer> added = new HashSet<>();\\n        for (int node: restrictions.get(index)) \\n            added.add(find(node));\\n        restrictions.get(index).addAll(added);    \\n    }\\n\\n    private boolean notRestricted(int root1, int root2) {\\n        for (int node: restrictions.get(root1)) if(node == root2) return false;\\n        for (int node: restrictions.get(root2)) if(node == root1) return false;\\n        return true;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        DisjointSet set = new DisjointSet(n, restrictions);\\n        boolean[] queries = new boolean[requests.length];\\n        for (int i = 0; i < requests.length; i++) \\n            queries[i] = set.union(requests[i][0], requests[i][1]);\\n        return queries;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DisjointSet {\\n    private final int[] root;\\n    private final int[] rank;\\n    private final List<Set<Integer>> restrictions;\\n\\n    DisjointSet(int size, int[][] restrictions) {\\n        root = new int[size];\\n        rank = new int[size];\\n        this.restrictions = new ArrayList<>();\\n        for (int i = 0; i < size; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n            this.restrictions.add(new HashSet<>());\\n        }\\n        for (int[] restriction: restrictions) {\\n            this.restrictions.get(restriction[0]).add(restriction[1]);\\n            this.restrictions.get(restriction[1]).add(restriction[0]);\\n        }\\n    }\\n\\n    private int find(int vertex) {\\n        if(root[vertex] == vertex) return vertex;\\n        return root[vertex] = find(root[vertex]);\\n    }\\n\\n    public boolean union(int vertex1, int vertex2) {\\n        int root1 = find(vertex1);\\n        int root2 = find(vertex2);\\n        if(root1 == root2) return true;\\n        if(notRestricted(root1, root2)) {\\n            if(rank[root1] > rank[root2]) {\\n                root[root2] = root1;\\n                restrictions.get(root1).addAll(restrictions.get(root2));\\n                addRoots(root1);\\n            } else if(rank[root2] > rank[root1]) {\\n                root[root1] = root2;\\n                restrictions.get(root2).addAll(restrictions.get(root1));\\n                addRoots(root2);\\n            } else {\\n                root[root2] = root1;\\n                rank[root1]++;\\n                restrictions.get(root1).addAll(restrictions.get(root2));\\n                addRoots(root1);\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    private void addRoots(int index) {\\n        Set<Integer> added = new HashSet<>();\\n        for (int node: restrictions.get(index)) \\n            added.add(find(node));\\n        restrictions.get(index).addAll(added);    \\n    }\\n\\n    private boolean notRestricted(int root1, int root2) {\\n        for (int node: restrictions.get(root1)) if(node == root2) return false;\\n        for (int node: restrictions.get(root2)) if(node == root1) return false;\\n        return true;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        DisjointSet set = new DisjointSet(n, restrictions);\\n        boolean[] queries = new boolean[requests.length];\\n        for (int i = 0; i < requests.length; i++) \\n            queries[i] = set.union(requests[i][0], requests[i][1]);\\n        return queries;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724215,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\n  vector<int> parents;\\n    int find_set(int v)\\n    {\\n        if(v == parents[v])\\n            return v;\\n        return parents[v] = find_set(parents[v]);\\n    }\\n    void union_set(int a, int b)\\n    {\\n        a = find_set(a);\\n        b = find_set(b);\\n        if(a == b)\\n            return;\\n        if(a != b)\\n            parents[b] = a;\\n        return;\\n    }\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        for(int i = 0; i < n; i++)\\n            parents.push_back(i);\\n        vector<bool> ans;\\n        for(vector<int> &req : requests)\\n        {\\n            int v = 1;\\n            int a = find_set(req[0]);\\n            int b = find_set(req[1]);\\n            for(vector<int> &res : restrictions)\\n            {\\n                int r1 = find_set(res[0]);\\n                int r2 = find_set(res[1]);\\n                if((a == r1 && b == r2) || (b == r1 && a == r2))\\n                {\\n                    v = 0;\\n                    break;\\n                }\\n            }\\n            ans.push_back(v);\\n            if(v)\\n            {\\n                union_set(a,b);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n  vector<int> parents;\\n    int find_set(int v)\\n    {\\n        if(v == parents[v])\\n            return v;\\n        return parents[v] = find_set(parents[v]);\\n    }\\n    void union_set(int a, int b)\\n    {\\n        a = find_set(a);\\n        b = find_set(b);\\n        if(a == b)\\n            return;\\n        if(a != b)\\n            parents[b] = a;\\n        return;\\n    }\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        for(int i = 0; i < n; i++)\\n            parents.push_back(i);\\n        vector<bool> ans;\\n        for(vector<int> &req : requests)\\n        {\\n            int v = 1;\\n            int a = find_set(req[0]);\\n            int b = find_set(req[1]);\\n            for(vector<int> &res : restrictions)\\n            {\\n                int r1 = find_set(res[0]);\\n                int r2 = find_set(res[1]);\\n                if((a == r1 && b == r2) || (b == r1 && a == r2))\\n                {\\n                    v = 0;\\n                    break;\\n                }\\n            }\\n            ans.push_back(v);\\n            if(v)\\n            {\\n                union_set(a,b);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214730,
                "title": "c-easy-to-understand-dsu-implementation",
                "content": "```\\nclass dsu {\\n    int *rank, *parent, n;\\n \\npublic:\\n    dsu(int n)\\n    {\\n        rank = new int[n];\\n        parent = new int[n];\\n        this->n = n;\\n        makeSet();\\n    }\\n    void makeSet()\\n    {\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n \\n    int par(int x)\\n    {\\n        if (parent[x] != x) {\\n            parent[x] = par(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n    void unions(int x, int y)\\n    {\\n        int xset = par(x);\\n        int yset = par(y);\\n        if (xset == yset)\\n            return;\\n        if (rank[xset] < rank[yset]) {\\n            parent[xset] = yset;\\n        }\\n        else if (rank[xset] > rank[yset]) {\\n            parent[yset] = xset;\\n        }\\n        else {\\n            parent[yset] = xset;\\n            rank[xset] = rank[xset] + 1;\\n        }\\n    }\\n};\\n \\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& req) {\\n        dsu obj(n);\\n        obj.makeSet();\\n        vector<bool> ans;\\n        for(int i = 0; i < req.size();i++){\\n   int x= obj.par(req[i][0]);\\n                int y = obj.par(req[i][1]);\\n            bool b = true;\\n            for(int j = 0; j < res.size();j++){\\n                int x1 = obj.par(res[j][0]);\\n                int y1 = obj.par(res[j][1]);\\n                if((x==x1&&y==y1)||(x==y1&&y==x1)){\\n                    b = false;\\n                    break;\\n                }\\n            }\\n            if(b){\\n                ans.push_back(true);\\n                obj.unions(req[i][0],req[i][1]);\\n            }\\n            else{\\n                ans.push_back(false);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass dsu {\\n    int *rank, *parent, n;\\n \\npublic:\\n    dsu(int n)\\n    {\\n        rank = new int[n];\\n        parent = new int[n];\\n        this->n = n;\\n        makeSet();\\n    }\\n    void makeSet()\\n    {\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n \\n    int par(int x)\\n    {\\n        if (parent[x] != x) {\\n            parent[x] = par(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n    void unions(int x, int y)\\n    {\\n        int xset = par(x);\\n        int yset = par(y);\\n        if (xset == yset)\\n            return;\\n        if (rank[xset] < rank[yset]) {\\n            parent[xset] = yset;\\n        }\\n        else if (rank[xset] > rank[yset]) {\\n            parent[yset] = xset;\\n        }\\n        else {\\n            parent[yset] = xset;\\n            rank[xset] = rank[xset] + 1;\\n        }\\n    }\\n};\\n \\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& req) {\\n        dsu obj(n);\\n        obj.makeSet();\\n        vector<bool> ans;\\n        for(int i = 0; i < req.size();i++){\\n   int x= obj.par(req[i][0]);\\n                int y = obj.par(req[i][1]);\\n            bool b = true;\\n            for(int j = 0; j < res.size();j++){\\n                int x1 = obj.par(res[j][0]);\\n                int y1 = obj.par(res[j][1]);\\n                if((x==x1&&y==y1)||(x==y1&&y==x1)){\\n                    b = false;\\n                    break;\\n                }\\n            }\\n            if(b){\\n                ans.push_back(true);\\n                obj.unions(req[i][0],req[i][1]);\\n            }\\n            else{\\n                ans.push_back(false);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184069,
                "title": "better-than-100-of-solns",
                "content": "Plain union find - `323 ms`\\n```\\nclass Solution(object):\\n    def friendRequests(self, n, restrictions, requests):\\n        \"\"\"\\n        :type n: int\\n        :type restrictions: List[List[int]]\\n        :type requests: List[List[int]]\\n        :rtype: List[bool]\\n        \"\"\"\\n        p = {i:i for i in range(n)}\\n        \\n        def find(x):\\n            ox = x\\n            while p[x] != x:\\n                x = p[x]\\n            p[ox] = x\\n            return x\\n        \\n        bl = defaultdict(set)\\n        ans = []\\n        for ri, rj in restrictions:\\n            bl[ri].add(rj)\\n            bl[rj].add(ri)\\n        for ri, rj in requests:\\n            rpi, rpj = find(ri), find(rj)\\n            if rpi == rpj:\\n                ans.append(True)\\n            else:\\n                cc = rpj not in bl[rpi]\\n                if cc:\\n                    p[rpj] = rpi\\n                    bl[rpi] = bl[rpi].union(bl[rpj])\\n                    for i in bl[rpj]:\\n                        bl[i].add(rpi)\\n                ans.append(cc)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution(object):\\n    def friendRequests(self, n, restrictions, requests):\\n        \"\"\"\\n        :type n: int\\n        :type restrictions: List[List[int]]\\n        :type requests: List[List[int]]\\n        :rtype: List[bool]\\n        \"\"\"\\n        p = {i:i for i in range(n)}\\n        \\n        def find(x):\\n            ox = x\\n            while p[x] != x:\\n                x = p[x]\\n            p[ox] = x\\n            return x\\n        \\n        bl = defaultdict(set)\\n        ans = []\\n        for ri, rj in restrictions:\\n            bl[ri].add(rj)\\n            bl[rj].add(ri)\\n        for ri, rj in requests:\\n            rpi, rpj = find(ri), find(rj)\\n            if rpi == rpj:\\n                ans.append(True)\\n            else:\\n                cc = rpj not in bl[rpi]\\n                if cc:\\n                    p[rpj] = rpi\\n                    bl[rpi] = bl[rpi].union(bl[rpj])\\n                    for i in bl[rpj]:\\n                        bl[i].add(rpi)\\n                ans.append(cc)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065134,
                "title": "java-solution-with-union-find",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        UnionFind uf = new UnionFind(n);\\n        \\n        boolean[] result = new boolean[requests.length];\\n        Arrays.fill(result, false);\\n        \\n        int i = 0;\\n        for (int[] request: requests) {\\n            int x = request[0];\\n            int y = request[1];\\n            \\n            result[i] = uf.union(x, y, restrictions);\\n            \\n            i += 1;\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] parents;\\n    int[] ranks;\\n\\n    public UnionFind(int n) {\\n        this.parents = new int[n];\\n        this.ranks = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            this.parents[i] = i;\\n            this.ranks[i] = 1;\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (parents[x] != x) parents[x] = find(parents[x]);\\n\\n        return parents[x];\\n    }\\n\\n    public boolean union(int x, int y, int[][] restrictions) {\\n        int xRoot = find(x);\\n        int yRoot = find(y);\\n\\n        // Skip union if they already in the same group.\\n        if (xRoot == yRoot) return true;\\n        \\n        for (int[] restriction: restrictions) {\\n            int u = restriction[0];\\n            int v = restriction[1];\\n            int uRoot = find(u);\\n            int vRoot = find(v);\\n            \\n            if ((uRoot == yRoot && vRoot == xRoot) || (uRoot == xRoot && vRoot == yRoot)) {\\n                return false;\\n            }\\n        }\\n\\n        if (ranks[xRoot] < ranks[yRoot]) {\\n            parents[xRoot] = yRoot;\\n        } else {\\n            parents[yRoot] = xRoot;\\n        }\\n\\n        if (ranks[xRoot] == ranks[yRoot]) {\\n            ranks[xRoot]++;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        UnionFind uf = new UnionFind(n);\\n        \\n        boolean[] result = new boolean[requests.length];\\n        Arrays.fill(result, false);\\n        \\n        int i = 0;\\n        for (int[] request: requests) {\\n            int x = request[0];\\n            int y = request[1];\\n            \\n            result[i] = uf.union(x, y, restrictions);\\n            \\n            i += 1;\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] parents;\\n    int[] ranks;\\n\\n    public UnionFind(int n) {\\n        this.parents = new int[n];\\n        this.ranks = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            this.parents[i] = i;\\n            this.ranks[i] = 1;\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (parents[x] != x) parents[x] = find(parents[x]);\\n\\n        return parents[x];\\n    }\\n\\n    public boolean union(int x, int y, int[][] restrictions) {\\n        int xRoot = find(x);\\n        int yRoot = find(y);\\n\\n        // Skip union if they already in the same group.\\n        if (xRoot == yRoot) return true;\\n        \\n        for (int[] restriction: restrictions) {\\n            int u = restriction[0];\\n            int v = restriction[1];\\n            int uRoot = find(u);\\n            int vRoot = find(v);\\n            \\n            if ((uRoot == yRoot && vRoot == xRoot) || (uRoot == xRoot && vRoot == yRoot)) {\\n                return false;\\n            }\\n        }\\n\\n        if (ranks[xRoot] < ranks[yRoot]) {\\n            parents[xRoot] = yRoot;\\n        } else {\\n            parents[yRoot] = xRoot;\\n        }\\n\\n        if (ranks[xRoot] == ranks[yRoot]) {\\n            ranks[xRoot]++;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044472,
                "title": "c-union-find-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int> &par,int u)\\n    {\\n        if(u==par[u])\\n            return u;\\n        return par[u]=find(par,par[u]);\\n    }\\n    void merge(vector<int> &par,int u,int v)\\n    {\\n        int pu=find(par,u);\\n        int pv=find(par,v);\\n        \\n        par[pv]=pu;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests)\\n    {\\n        int m=requests.size();\\n        vector<bool> ans(m,true);\\n        vector<int> par(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            par[i]=i;\\n        }\\n        for(int i=0;i<requests.size();i++)\\n        {\\n            int p=find(par,requests[i][0]);\\n            int q=find(par,requests[i][1]);\\n            if(!(find(par,p)==find(par,q)))\\n            {\\n                for(auto &rs:restrictions )\\n                {\\n                    int x=find(par,rs[0]),y=find(par,rs[1]);\\n                    {\\n                        if((x==p&&y==q)||(x==q&&y==p))\\n                        {\\n                            ans[i]=false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(ans[i])\\n                {\\n                    merge(par ,p,q);\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "class Solution {\\npublic:\\n    int find(vector<int> &par,int u)\\n    {\\n        if(u==par[u])\\n            return u;\\n        return par[u]=find(par,par[u]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1931426,
                "title": "python-union-find-best-solution",
                "content": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        uf = {i:i for i in range(n)}\\n        ans = [None] * len(requests)\\n        \\n        def find(i):\\n            if uf[i] != i:\\n                uf[i] = find(uf[i])\\n            return uf[i]\\n        \\n        def union(i, j):\\n            uf[find(i)] = uf[find(j)]\\n        \\n        for i, (p1, p2) in enumerate(requests):\\n            foundSet = set([find(p1), find(p2)])\\n            ans[i] = not any(find(r1) in foundSet and find(r2) in foundSet \\\\\\n                        for (r1, r2) in restrictions)\\n            \\n            if ans[i] == True:\\n                union(p1, p2)\\n    \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        uf = {i:i for i in range(n)}\\n        ans = [None] * len(requests)\\n        \\n        def find(i):\\n            if uf[i] != i:\\n                uf[i] = find(uf[i])\\n            return uf[i]\\n        \\n        def union(i, j):\\n            uf[find(i)] = uf[find(j)]\\n        \\n        for i, (p1, p2) in enumerate(requests):\\n            foundSet = set([find(p1), find(p2)])\\n            ans[i] = not any(find(r1) in foundSet and find(r2) in foundSet \\\\\\n                        for (r1, r2) in restrictions)\\n            \\n            if ans[i] == True:\\n                union(p1, p2)\\n    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722288,
                "title": "python-union-find-with-detailed-explanation",
                "content": "Use the union find algorithm. The critical part is all about the restrictions. When there are too many people and too many restrictions, it will be time-consuming to check each restriction, before answering a request. We know that union is kind of a hierarchy system, where everyone has a supervisor (better than the usually known \"parent\").\\n\\nIt would good to let the supervisors to handle the restrictions. If A dislike B, let A\\'s supervisor dislike B\\'s supervisor. Since initially everyone supervises oneself, the given restrictions are a good start. We build a Hash map to handle the restrictions. \\n\\nFor a coming request, we only check the two supervisors. If they do not dislike each other, the relation can be built\\nand call union()! During the union process, one supervisor SA retires and the other supervisor SB remains, and also supervises SA. In addition to the union itself, there are two important things to do:\\n1) Go through everyone that SA dislikes, let each dislike SB (, who now supervises SA), instead of SA.\\n2) SB should take all the restrictions that SA are involved in. One can pop SA from the map, since he  does not bother this kind of nonsense any more. \\n\\n```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        rst = defaultdict(set)\\n        for a, b in restrictions:\\n            rst[a].add(b)\\n            rst[b].add(a)\\n        del restrictions\\n        ans = []\\n        supervisor = [i for i in range(n)]\\n        def find(x):\\n            if supervisor[x] == x:\\n                return x\\n            else:\\n                supervisor[x] = find(supervisor[x])\\n                return supervisor[x]\\n\\n        def union(x, y):                # the method is more than the conventional union() method\\n            x, y = find(x), find(y)\\n            if x > y:\\n                x, y = y, x\\n            supervisor[y] = x           # \"y\", who was a supervisor, retires. \"x\" becomes his supervisor.\\n            rst[y] = rst.get(y, set())  # persons who \"y\", as well as his group, does not like\\n            for z in rst[y]:            # for each of those persons\\n                rst[z].remove(y)        # stop hating \"y\"\\n                rst[z].add(x)           # hate his supervisor instead\\n            if x not in rst:            # \"x\" consider everyone who \"y\" and his group do not like\\n                rst[x] = set()\\n            rst[x] |= rst.pop(y)\\n            return\\n\\t\\t\\t\\n        for a, b in requests:               # process each request\\n            sa, sb = find(a), find(b)       # approach the two supervisors\\n            if sa == sb:                    # they are the same, meaning that a and b are already friends\\n                ans.append(True)\\n            elif sb in rst.get(sa, set()):  # if the supervisors do not permit\\n                ans.append(False)\\n            else:                           # if the supervisors permit\\n                ans.append(True)\\n                union(a, b)                 # build the relation\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        rst = defaultdict(set)\\n        for a, b in restrictions:\\n            rst[a].add(b)\\n            rst[b].add(a)\\n        del restrictions\\n        ans = []\\n        supervisor = [i for i in range(n)]\\n        def find(x):\\n            if supervisor[x] == x:\\n                return x\\n            else:\\n                supervisor[x] = find(supervisor[x])\\n                return supervisor[x]\\n\\n        def union(x, y):                # the method is more than the conventional union() method\\n            x, y = find(x), find(y)\\n            if x > y:\\n                x, y = y, x\\n            supervisor[y] = x           # \"y\", who was a supervisor, retires. \"x\" becomes his supervisor.\\n            rst[y] = rst.get(y, set())  # persons who \"y\", as well as his group, does not like\\n            for z in rst[y]:            # for each of those persons\\n                rst[z].remove(y)        # stop hating \"y\"\\n                rst[z].add(x)           # hate his supervisor instead\\n            if x not in rst:            # \"x\" consider everyone who \"y\" and his group do not like\\n                rst[x] = set()\\n            rst[x] |= rst.pop(y)\\n            return\\n\\t\\t\\t\\n        for a, b in requests:               # process each request\\n            sa, sb = find(a), find(b)       # approach the two supervisors\\n            if sa == sb:                    # they are the same, meaning that a and b are already friends\\n                ans.append(True)\\n            elif sb in rst.get(sa, set()):  # if the supervisors do not permit\\n                ans.append(False)\\n            else:                           # if the supervisors permit\\n                ans.append(True)\\n                union(a, b)                 # build the relation\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688368,
                "title": "python-unionfind-87-faster-avg-o-e-r-with-explaination",
                "content": "Correct me if I am wrong but the time complexity I think would be O(N + ER) on worst case and O(N+E+R) on average case where E is number of requests and R is number of restrictions. And the space complexity is O(N+R). Basically we will keep track of all the root of restrictions from in each root node in union find. \\n\\nWhen we are adding (x, y) the request we will check if there is restriction between root_of_x and root_of_y. If there are restrictions we will return False.\\n\\nIf nodes can be friends, we will add those nodes by union by rank and keep track of root and child between those root_of_x and root_of_y.\\n\\nSuppose when we did the union root = root_of_x and child = root_of_y, then, we will loop through all the restrictions in root_of_y and try to find their root in the graph and add that root to the restriction of root_of_x. Then we will delete the restriction of root_of_y.\\n\\nThis way when we are doing union, the restrictions will be merged. \\n```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        \\n        union_find = UnionFind(n, restrictions)\\n        result = []\\n        for u, v in requests:\\n            if union_find.union(u, v):\\n                result.append(True)\\n            else:\\n                result.append(False)\\n        return result\\n            \\nclass UnionFind:\\n    def __init__(self, n, restricts):\\n        self.root = [i for i in range(n)]\\n        self.rank = [1 for i in range(n)]\\n        self.restrictions = {}\\n        for u, v in restricts:\\n            if u not in self.restrictions:\\n                self.restrictions[u] = set()\\n            if v not in self.restrictions:\\n                self.restrictions[v] = set()\\n            self.restrictions[u].add(v)\\n            self.restrictions[v].add(u)\\n        \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n        if (root_x in self.restrictions and root_y in self.restrictions[root_x]) or (root_y in self.restrictions and root_x in self.restrictions[root_y]):\\n            return False\\n        \\n        if root_x != root_y:\\n            root, child = root_y, root_x\\n            if self.rank[root_x] < self.rank[root_y]:\\n                self.root[root_x] = root_y\\n            elif self.rank[root_y] < self.rank[root_x]:\\n                self.root[root_y] = root_x\\n                root, child = root_x, root_y\\n            else:\\n                self.root[root_x] = root_y\\n                self.rank[root_y] += 1\\n            if child in self.restrictions:\\n                for rest in self.restrictions[child]:\\n                    if root not in self.restrictions:\\n                        self.restrictions[root] = set()\\n                    self.restrictions[root].add(self.find(rest))\\n                del self.restrictions[child]\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        \\n        union_find = UnionFind(n, restrictions)\\n        result = []\\n        for u, v in requests:\\n            if union_find.union(u, v):\\n                result.append(True)\\n            else:\\n                result.append(False)\\n        return result\\n            \\nclass UnionFind:\\n    def __init__(self, n, restricts):\\n        self.root = [i for i in range(n)]\\n        self.rank = [1 for i in range(n)]\\n        self.restrictions = {}\\n        for u, v in restricts:\\n            if u not in self.restrictions:\\n                self.restrictions[u] = set()\\n            if v not in self.restrictions:\\n                self.restrictions[v] = set()\\n            self.restrictions[u].add(v)\\n            self.restrictions[v].add(u)\\n        \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n        if (root_x in self.restrictions and root_y in self.restrictions[root_x]) or (root_y in self.restrictions and root_x in self.restrictions[root_y]):\\n            return False\\n        \\n        if root_x != root_y:\\n            root, child = root_y, root_x\\n            if self.rank[root_x] < self.rank[root_y]:\\n                self.root[root_x] = root_y\\n            elif self.rank[root_y] < self.rank[root_x]:\\n                self.root[root_y] = root_x\\n                root, child = root_x, root_y\\n            else:\\n                self.root[root_x] = root_y\\n                self.rank[root_y] += 1\\n            if child in self.restrictions:\\n                for rest in self.restrictions[child]:\\n                    if root not in self.restrictions:\\n                        self.restrictions[root] = set()\\n                    self.restrictions[root].add(self.find(rest))\\n                del self.restrictions[child]\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654430,
                "title": "c-dsu-check-in-restriction-before-allowing-them-to-be-friends",
                "content": "```cpp\\nclass DSU {\\npublic:\\n    vector<int> parent, rank;\\n    DSU(int N) {\\n        for (int i = 0; i < N + 5; ++i) {\\n            parent.push_back(i);\\n            rank.push_back(1);\\n        }\\n    }\\n    \\n    int find(int u) {\\n        if (parent[u] == u) return u;\\n        return parent[u] = find(parent[u]);\\n    }\\n    \\n    void merge(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX == rootY) return ;\\n        if (rank[rootX] >= rank[rootY]) {\\n            parent[rootY] = rootX;\\n            rank[rootX] += rank[rootY];\\n        } else {\\n            parent[rootX] = rootY;\\n            rank[rootY] += rank[rootX];\\n        }\\n    }\\n    \\n    bool isConnected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU dsu(n);\\n        vector<bool> res;\\n        for (const auto &req: requests) {\\n            int p1 = dsu.find(req[0]);\\n            int p2 = dsu.find(req[1]);\\n            //If they are friends, then they will always be friends\\n            if(p1 == p2) {\\n                res.push_back(true);\\n                continue;\\n            }\\n            bool flag = true;\\n            for(const auto &rest : restrictions) {\\n                int x1 = dsu.find(rest[0]);\\n                int x2 = dsu.find(rest[1]);\\n\\t\\t\\t\\t//Since in DSU, parents can also be reversed\\n\\t\\t\\t\\t//hence we check for the reverse as well\\n                if(p1 == x1 && p2 == x2 || p1 == x2 && p2 == x1) {\\n                    flag = false;\\n                    break;\\n                } \\n            }\\n            if(flag) {\\n                dsu.merge(req[0], req[1]);\\n            }\\n            res.push_back(flag);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass DSU {\\npublic:\\n    vector<int> parent, rank;\\n    DSU(int N) {\\n        for (int i = 0; i < N + 5; ++i) {\\n            parent.push_back(i);\\n            rank.push_back(1);\\n        }\\n    }\\n    \\n    int find(int u) {\\n        if (parent[u] == u) return u;\\n        return parent[u] = find(parent[u]);\\n    }\\n    \\n    void merge(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX == rootY) return ;\\n        if (rank[rootX] >= rank[rootY]) {\\n            parent[rootY] = rootX;\\n            rank[rootX] += rank[rootY];\\n        } else {\\n            parent[rootX] = rootY;\\n            rank[rootY] += rank[rootX];\\n        }\\n    }\\n    \\n    bool isConnected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU dsu(n);\\n        vector<bool> res;\\n        for (const auto &req: requests) {\\n            int p1 = dsu.find(req[0]);\\n            int p2 = dsu.find(req[1]);\\n            //If they are friends, then they will always be friends\\n            if(p1 == p2) {\\n                res.push_back(true);\\n                continue;\\n            }\\n            bool flag = true;\\n            for(const auto &rest : restrictions) {\\n                int x1 = dsu.find(rest[0]);\\n                int x2 = dsu.find(rest[1]);\\n\\t\\t\\t\\t//Since in DSU, parents can also be reversed\\n\\t\\t\\t\\t//hence we check for the reverse as well\\n                if(p1 == x1 && p2 == x2 || p1 == x2 && p2 == x1) {\\n                    flag = false;\\n                    break;\\n                } \\n            }\\n            if(flag) {\\n                dsu.merge(req[0], req[1]);\\n            }\\n            res.push_back(flag);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587911,
                "title": "python-unionfind-concise-solution",
                "content": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        size = [1] * (n + 1)\\n        uf = [i for i in range(n+1)]\\n        \\n        def union(f, s):\\n            root_f, root_s = find(f), find(s)\\n            \\n\\t\\t\\t# loop over restrictions and return False if find any.\\n            for item in restrictions:\\n                cur_root = (find(item[0]), find(item[1]))\\n                if cur_root == (root_f, root_s) or cur_root == (root_s, root_f):\\n                    return False\\n\\t\\t\\t\\t\\t\\n            # does not find any rstriction, union input and return True.\\n            if size[root_f] >= size[root_s]:\\n                uf[root_s] = root_f\\n                size[root_f] += size[root_s]\\n            else:\\n                uf[root_f] = root_s\\n                size[root_s] += size[root_f]\\n            \\n            return True\\n        \\n        def find(node):\\n            while uf[node] != node:\\n                node = uf[node]\\n            \\n            return node\\n        \\n        res = []\\n        for s, t  in requests:\\n            res.append(union(s, t))\\n        \\n        return res\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        size = [1] * (n + 1)\\n        uf = [i for i in range(n+1)]\\n        \\n        def union(f, s):\\n            root_f, root_s = find(f), find(s)\\n            \\n\\t\\t\\t# loop over restrictions and return False if find any.\\n            for item in restrictions:\\n                cur_root = (find(item[0]), find(item[1]))\\n                if cur_root == (root_f, root_s) or cur_root == (root_s, root_f):\\n                    return False\\n\\t\\t\\t\\t\\t\\n            # does not find any rstriction, union input and return True.\\n            if size[root_f] >= size[root_s]:\\n                uf[root_s] = root_f\\n                size[root_f] += size[root_s]\\n            else:\\n                uf[root_f] = root_s\\n                size[root_s] += size[root_f]\\n            \\n            return True\\n        \\n        def find(node):\\n            while uf[node] != node:\\n                node = uf[node]\\n            \\n            return node\\n        \\n        res = []\\n        for s, t  in requests:\\n            res.append(union(s, t))\\n        \\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581175,
                "title": "dsu-union-by-size-java",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        Dsu dsu = new Dsu(n);\\n        \\n        boolean[] ans = new boolean[requests.length];\\n        int i=0;\\n        \\n        for(int[]x : requests){\\n            int pu = dsu.findpar(x[0]);\\n            int pv= dsu.findpar(x[1]);\\n            boolean fl = true;\\n            if(pu!=pv){\\n                for(int[] x2:restrictions){\\n                    int pu1 = dsu.findpar(x2[0]);\\n                    int pv1 = dsu.findpar(x2[1]);\\n                    \\n                    if((pu == pu1 && pv == pv1) || (pu == pv1 && pv ==pu1)){\\n                        fl = false;\\n                        break;\\n                    }\\n                }\\n                if(fl){\\n                    dsu.union(pu,pv);\\n                }\\n               \\n            }\\n            ans[i++] = fl;\\n        }\\n        return ans;\\n    }\\n}\\nclass Dsu{\\n    int[] parent = new int[1000];\\n    int[]size = new int[1000];\\n    \\n    Dsu(int n){\\n        \\n        for(int i=0;i<n;i++){\\n            parent[i] = i;\\n            size[i] = 0;\\n        }\\n    }\\n    \\n    public int findpar(int n){\\n        if(parent[n] == n)return n;\\n        return parent[n] = findpar(parent[n]);\\n    }\\n    \\n    public void union(int u ,int v){\\n        int pu = findpar(u);\\n        int pv = findpar(v);\\n        \\n        if(pu==pv)return;\\n        \\n        if(size[pu]<size[pv]){\\n            parent[pu]=pv;\\n            size[pv] += size[pu];\\n        }else{\\n            parent[pv] = pu;\\n            size[pu] += size[pv];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        Dsu dsu = new Dsu(n);\\n        \\n        boolean[] ans = new boolean[requests.length];\\n        int i=0;\\n        \\n        for(int[]x : requests){\\n            int pu = dsu.findpar(x[0]);\\n            int pv= dsu.findpar(x[1]);\\n            boolean fl = true;\\n            if(pu!=pv){\\n                for(int[] x2:restrictions){\\n                    int pu1 = dsu.findpar(x2[0]);\\n                    int pv1 = dsu.findpar(x2[1]);\\n                    \\n                    if((pu == pu1 && pv == pv1) || (pu == pv1 && pv ==pu1)){\\n                        fl = false;\\n                        break;\\n                    }\\n                }\\n                if(fl){\\n                    dsu.union(pu,pv);\\n                }\\n               \\n            }\\n            ans[i++] = fl;\\n        }\\n        return ans;\\n    }\\n}\\nclass Dsu{\\n    int[] parent = new int[1000];\\n    int[]size = new int[1000];\\n    \\n    Dsu(int n){\\n        \\n        for(int i=0;i<n;i++){\\n            parent[i] = i;\\n            size[i] = 0;\\n        }\\n    }\\n    \\n    public int findpar(int n){\\n        if(parent[n] == n)return n;\\n        return parent[n] = findpar(parent[n]);\\n    }\\n    \\n    public void union(int u ,int v){\\n        int pu = findpar(u);\\n        int pv = findpar(v);\\n        \\n        if(pu==pv)return;\\n        \\n        if(size[pu]<size[pv]){\\n            parent[pu]=pv;\\n            size[pv] += size[pu];\\n        }else{\\n            parent[pv] = pu;\\n            size[pu] += size[pv];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580287,
                "title": "java-unin-find-try-to-connect-then-find-violation",
                "content": "This is a regular `union find set` approach, try to connect two persons in each request, then check if the new connection violates the `restrictions` array.\\n```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        \\n        int[] friends = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            friends[i] = i;\\n        }\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            int rootA = friends[requests[i][0]];\\n            int rootB = friends[requests[i][1]];\\n            \\n            if (rootA == rootB) {\\n                res[i] = true;\\n                continue;\\n            }\\n            \\n            int[] friendsCopy = tryConnect(friends, rootA, rootB);\\n            \\n            if (isValid(friendsCopy, restrictions)) {\\n                res[i] = true;\\n                friends = friendsCopy;\\n            } else {\\n                res[i] = false;\\n            }\\n        } \\n        \\n        return res;\\n    }\\n    \\n    private int[] tryConnect(int[] friends, int rootA, int rootB) {\\n        // try on a cloned array rather than in place\\n\\t\\tint n = friends.length;\\n        int[] friendsCopy = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            if(friends[i] == rootA) {\\n                friendsCopy[i] = rootB;\\n            } else {\\n                friendsCopy[i] = friends[i];\\n            }\\n        }\\n        \\n        return friendsCopy;\\n    }\\n    \\n    private boolean isValid(int[] friends, int[][] restrictions) {\\n        for (int[] restriction: restrictions) {\\n            int personA = restriction[0];\\n            int personB = restriction[1];\\n            if (friends[personA] == friends[personB]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        \\n        int[] friends = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            friends[i] = i;\\n        }\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            int rootA = friends[requests[i][0]];\\n            int rootB = friends[requests[i][1]];\\n            \\n            if (rootA == rootB) {\\n                res[i] = true;\\n                continue;\\n            }\\n            \\n            int[] friendsCopy = tryConnect(friends, rootA, rootB);\\n            \\n            if (isValid(friendsCopy, restrictions)) {\\n                res[i] = true;\\n                friends = friendsCopy;\\n            } else {\\n                res[i] = false;\\n            }\\n        } \\n        \\n        return res;\\n    }\\n    \\n    private int[] tryConnect(int[] friends, int rootA, int rootB) {\\n        // try on a cloned array rather than in place\\n\\t\\tint n = friends.length;\\n        int[] friendsCopy = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            if(friends[i] == rootA) {\\n                friendsCopy[i] = rootB;\\n            } else {\\n                friendsCopy[i] = friends[i];\\n            }\\n        }\\n        \\n        return friendsCopy;\\n    }\\n    \\n    private boolean isValid(int[] friends, int[][] restrictions) {\\n        for (int[] restriction: restrictions) {\\n            int personA = restriction[0];\\n            int personB = restriction[1];\\n            if (friends[personA] == friends[personB]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580232,
                "title": "c-dsu-with-comments-easy-to-understand",
                "content": "```\\nclass DSU{\\nprivate:\\n    vector<int> parent,rank;\\n\\npublic:\\n    DSU(int n){\\n        for(int i=0; i<n; i++){\\n            parent.push_back(-1); //can show seg fault if written like this parent[i] = -1;\\n            rank.push_back(0);    // same goes for this\\n        }\\n    }\\n\\n    int find(int i){\\n        if(parent[i]==-1){\\n            return i;\\n        }\\n        return parent[i] = find(parent[i]);\\n    }\\n\\n    void Union(int a, int b){\\n        int s1 = find(a);\\n        int s2 = find(b);\\n\\n        if(s1!=s2){\\n            if(rank[s1] >= rank[s2]){\\n                parent[s2] = s1;\\n                rank[s1] += rank[s2];\\n            }\\n            else{\\n                parent[s1] = s2;\\n                rank[s2] += rank[s1];\\n            }\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU d(n);\\n        vector<bool> ans;\\n        \\n        //CONCEPT:- My enemy\\'s enemy is my friend\\n        for(int i=0; i<requests.size(); i++){\\n            DSU t = d;  //copy the previous dsu to check that the current request will be accepted or not\\n            t.Union(requests[i][0],requests[i][1]);\\n            bool flag = false;\\n            \\n            for(auto &it: restrictions){\\n                if(t.find(it[0]) == t.find(it[1])){ //check that would there be any restriction which we had \\n                    flag = true;                    //accepted but not supposed to be accepted\\n                    break;\\n                }\\n            }\\n            \\n            if(flag==false){\\n                d.Union(requests[i][0],requests[i][1]); //request approved -> true/ change in main dsu\\n                ans.push_back(true);\\n            }\\n            else{\\n                ans.push_back(false); //request rejected -> false/ no need to change main dsu\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass DSU{\\nprivate:\\n    vector<int> parent,rank;\\n\\npublic:\\n    DSU(int n){\\n        for(int i=0; i<n; i++){\\n            parent.push_back(-1); //can show seg fault if written like this parent[i] = -1;\\n            rank.push_back(0);    // same goes for this\\n        }\\n    }\\n\\n    int find(int i){\\n        if(parent[i]==-1){\\n            return i;\\n        }\\n        return parent[i] = find(parent[i]);\\n    }\\n\\n    void Union(int a, int b){\\n        int s1 = find(a);\\n        int s2 = find(b);\\n\\n        if(s1!=s2){\\n            if(rank[s1] >= rank[s2]){\\n                parent[s2] = s1;\\n                rank[s1] += rank[s2];\\n            }\\n            else{\\n                parent[s1] = s2;\\n                rank[s2] += rank[s1];\\n            }\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU d(n);\\n        vector<bool> ans;\\n        \\n        //CONCEPT:- My enemy\\'s enemy is my friend\\n        for(int i=0; i<requests.size(); i++){\\n            DSU t = d;  //copy the previous dsu to check that the current request will be accepted or not\\n            t.Union(requests[i][0],requests[i][1]);\\n            bool flag = false;\\n            \\n            for(auto &it: restrictions){\\n                if(t.find(it[0]) == t.find(it[1])){ //check that would there be any restriction which we had \\n                    flag = true;                    //accepted but not supposed to be accepted\\n                    break;\\n                }\\n            }\\n            \\n            if(flag==false){\\n                d.Union(requests[i][0],requests[i][1]); //request approved -> true/ change in main dsu\\n                ans.push_back(true);\\n            }\\n            else{\\n                ans.push_back(false); //request rejected -> false/ no need to change main dsu\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579739,
                "title": "if-anyone-gets-tle-make-sure-to-do-this-optimization",
                "content": "If someone is getting tle ,make sure to iterate using refrence in for each loop.\\n```\\nclass union_find\\n{\\n\\tvector<int>par;\\n\\tvector<int>sz;\\npublic:\\n\\tunion_find(int n){\\n        par.resize(n);\\n        sz.resize(n);\\n        for(int i=0;i<n;i++){\\n        \\tpar[i]=i;\\n        \\tsz[i]=1;\\n        }\\n\\t}\\n\\tint find(int x){\\n\\t\\tif(par[x]==x)\\n\\t\\t\\treturn x;\\n\\t\\treturn par[x]=find(par[x]);\\n\\t}\\n\\tvoid unite(int u,int v){\\n\\t\\tint a=find(u);\\n\\t\\tint b=find(v);\\n\\t\\tif(not (a==b)){\\n\\t\\t\\tif(sz[a]<sz[b]){\\n\\t\\t\\t\\tpar[a]=b;\\n\\t\\t\\t\\tsz[b]+=sz[a];\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tpar[b]=a;\\n\\t\\t\\t\\tsz[a]+=sz[b];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        union_find un(n);\\n        vector<bool>res;\\n        for(auto &i:requests){  // & (refrence) is making the code faster, without using this i was getting tle on the same code.\\n            int u=un.find(i[0]);\\n            int v=un.find(i[1]);\\n            bool val=true;\\n            if(not (u==v)){\\n                for(auto &j:restrictions){    // & (refrence) is making the code faster\\n                    int x=un.find(j[0]),y=un.find(j[1]);\\n                    if((u==x&&v==y)||(u==y&&v==x)){\\n                        val=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(val){\\n                un.unite(u,v);\\n            }\\n            res.push_back(val);\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass union_find\\n{\\n\\tvector<int>par;\\n\\tvector<int>sz;\\npublic:\\n\\tunion_find(int n){\\n        par.resize(n);\\n        sz.resize(n);\\n        for(int i=0;i<n;i++){\\n        \\tpar[i]=i;\\n        \\tsz[i]=1;\\n        }\\n\\t}\\n\\tint find(int x){\\n\\t\\tif(par[x]==x)\\n\\t\\t\\treturn x;\\n\\t\\treturn par[x]=find(par[x]);\\n\\t}\\n\\tvoid unite(int u,int v){\\n\\t\\tint a=find(u);\\n\\t\\tint b=find(v);\\n\\t\\tif(not (a==b)){\\n\\t\\t\\tif(sz[a]<sz[b]){\\n\\t\\t\\t\\tpar[a]=b;\\n\\t\\t\\t\\tsz[b]+=sz[a];\\n\\t\\t\\t}else {\\n\\t\\t\\t\\tpar[b]=a;\\n\\t\\t\\t\\tsz[a]+=sz[b];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        union_find un(n);\\n        vector<bool>res;\\n        for(auto &i:requests){  // & (refrence) is making the code faster, without using this i was getting tle on the same code.\\n            int u=un.find(i[0]);\\n            int v=un.find(i[1]);\\n            bool val=true;\\n            if(not (u==v)){\\n                for(auto &j:restrictions){    // & (refrence) is making the code faster\\n                    int x=un.find(j[0]),y=un.find(j[1]);\\n                    if((u==x&&v==y)||(u==y&&v==x)){\\n                        val=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(val){\\n                un.unite(u,v);\\n            }\\n            res.push_back(val);\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577084,
                "title": "python3-concise-union-find",
                "content": "Time - O(len(requests) * len(restrictions) * (log len(requests))\\nSpace - O(len(n)\\n```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        parent = [i for i in range(n)] # create parent array\\n        \\n        def findParent(i):\\n            p = parent[i] # iteratively groing through parent table until cell is a parent of itself\\n            while p!=parent[p]: p = parent[p]\\n            return p\\n        \\n        res = []\\n        for l, r in requests:\\n            lParent, rParent = findParent(l), findParent(r) # searching parent for both cells\\n            \\n            parent[lParent] = parent[rParent] = min(lParent, rParent) # applying change request\\n            \\n            blocked = False\\n            for rl, rr in restrictions:\\n                pl, pr = findParent(rl), findParent(rr) # searching the parent for both parts of restriction\\n                \\n                if pl == pr:  # if for any restriction parent is the same, rollback the request and mark as False\\n                    blocked = True\\n                    parent[lParent], parent[rParent] = lParent, rParent\\n                    break\\n            res.append(not blocked)\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        parent = [i for i in range(n)] # create parent array\\n        \\n        def findParent(i):\\n            p = parent[i] # iteratively groing through parent table until cell is a parent of itself\\n            while p!=parent[p]: p = parent[p]\\n            return p\\n        \\n        res = []\\n        for l, r in requests:\\n            lParent, rParent = findParent(l), findParent(r) # searching parent for both cells\\n            \\n            parent[lParent] = parent[rParent] = min(lParent, rParent) # applying change request\\n            \\n            blocked = False\\n            for rl, rr in restrictions:\\n                pl, pr = findParent(rl), findParent(rr) # searching the parent for both parts of restriction\\n                \\n                if pl == pr:  # if for any restriction parent is the same, rollback the request and mark as False\\n                    blocked = True\\n                    parent[lParent], parent[rParent] = lParent, rParent\\n                    break\\n            res.append(not blocked)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577012,
                "title": "why-did-my-c-union-find-solution-get-tle",
                "content": "My solution during the contest is similar to several solutions which got accepted. Is my Union find implementation slow?\\n```\\n//------DSU---------------------//\\n#define ll int\\nclass DSU\\n{\\n    public:\\n    vector <ll> parent,rnk;\\n    DSU(ll n)\\n    {\\n        parent.resize(n+5,0);\\n        rnk.resize(n+5,0);\\n        for(ll i=0;i<n+5;i++)\\n         parent[i]=i;\\n    }\\n    ll find_set(ll v)\\n    {\\n        if(parent[v]==v)\\n         return v;\\n        return parent[v]=find_set(parent[v]); \\n    }\\n    void union_sets(ll a,ll b)\\n    {\\n        a=find_set(a);\\n        b=find_set(b);\\n        if(a!=b)\\n        {\\n            if(rnk[a]<rnk[b])\\n            swap(a,b);\\n            parent[b]=a; \\n            if(rnk[a]==rnk[b])\\n             rnk[a]++; \\n        }\\n    }\\n};\\n//------DSU---------------------//\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU ds(n);\\n        vector <bool> ans;\\n        for(auto u:requests){\\n            int x=u[0],y=u[1];\\n            x=ds.find_set(x);\\n            y=ds.find_set(y);\\n            if(x==y){\\n                ans.push_back(true);\\n                continue;\\n            }\\n            bool flag=true;\\n            for(auto uu:restrictions){\\n                int p=ds.find_set(uu[0]);\\n                int q=ds.find_set(uu[1]);\\n                if((p==x and q==y) or (p==y and q==x)){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            ans.push_back(flag);\\n            if(flag){\\n                ds.union_sets(x,y);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\nEdit: I found why I am getting TLE. I was creating copies of the vectors in restrictions everytime, because I was not iterating by reference.",
                "solutionTags": [],
                "code": "```\\n//------DSU---------------------//\\n#define ll int\\nclass DSU\\n{\\n    public:\\n    vector <ll> parent,rnk;\\n    DSU(ll n)\\n    {\\n        parent.resize(n+5,0);\\n        rnk.resize(n+5,0);\\n        for(ll i=0;i<n+5;i++)\\n         parent[i]=i;\\n    }\\n    ll find_set(ll v)\\n    {\\n        if(parent[v]==v)\\n         return v;\\n        return parent[v]=find_set(parent[v]); \\n    }\\n    void union_sets(ll a,ll b)\\n    {\\n        a=find_set(a);\\n        b=find_set(b);\\n        if(a!=b)\\n        {\\n            if(rnk[a]<rnk[b])\\n            swap(a,b);\\n            parent[b]=a; \\n            if(rnk[a]==rnk[b])\\n             rnk[a]++; \\n        }\\n    }\\n};\\n//------DSU---------------------//\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU ds(n);\\n        vector <bool> ans;\\n        for(auto u:requests){\\n            int x=u[0],y=u[1];\\n            x=ds.find_set(x);\\n            y=ds.find_set(y);\\n            if(x==y){\\n                ans.push_back(true);\\n                continue;\\n            }\\n            bool flag=true;\\n            for(auto uu:restrictions){\\n                int p=ds.find_set(uu[0]);\\n                int q=ds.find_set(uu[1]);\\n                if((p==x and q==y) or (p==y and q==x)){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            ans.push_back(flag);\\n            if(flag){\\n                ds.union_sets(x,y);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1576923,
                "title": "java-clean-union-find",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        DSU dsu = new DSU(n, restrictions);\\n        int r = requests.length;\\n        boolean res[] = new boolean[r];\\n        for(int i = 0; i < r; i++) {\\n            int req[] = requests[i];\\n            res[i] = dsu.union(req[0], req[1]);\\n        }\\n        return res;\\n    }\\n    \\n    static class DSU {\\n        \\n        Map<Integer, Set<Integer>> cmpToNodes = new HashMap<>();\\n        int parent[];\\n        int[][] restrictions;\\n        DSU(int n, int[][] restrictions) {\\n            parent = new int[n];\\n            for(int i = 0; i < n; i++) {\\n                Set s = new HashSet<>();\\n                s.add(i);\\n                cmpToNodes.put(i, s);\\n                parent[i] = i;\\n            }\\n            this.restrictions = restrictions;\\n        }\\n        \\n        int find(int u) {\\n            if(u == parent[u]) return u;\\n            return parent[u] = find(parent[u]);\\n        }\\n        \\n        boolean union(int u, int v) {\\n            int pu = find(u);\\n            int pv = find(v);\\n            \\n            if(pu != pv) {\\n                Set<Integer> setU = cmpToNodes.get(pu);\\n                Set<Integer> setV = cmpToNodes.get(pv);\\n                for(int restrict[] : restrictions) {\\n                    int x = restrict[0];\\n                    int y = restrict[1];\\n                    boolean foundX = setU.contains(x) || setV.contains(x);\\n                    boolean foundY = setU.contains(y) || setV.contains(y);\\n                    if(foundX && foundY) return false;\\n                }\\n                setV.addAll(setU);\\n                parent[pu] = parent[pv];\\n            }\\n            return true;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        DSU dsu = new DSU(n, restrictions);\\n        int r = requests.length;\\n        boolean res[] = new boolean[r];\\n        for(int i = 0; i < r; i++) {\\n            int req[] = requests[i];\\n            res[i] = dsu.union(req[0], req[1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4024208,
                "title": "96-best-reusable-disjointset-template-bonus-tip-inside",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is pretty straightforwad. Basically they are saying that two people can be friends if they have no restrictions or any of their mutual friends have no restriction.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe simplest way to solve this would be to use the union-find technique to link all the persons with mutual friends to one common ancestor. Now for every request we simply check that whether those ancestors have any restrictions or not. If they do they can\\'t be friends or else they can be.\\n\\nPLEASE UPVOTE IF YOU FIND THIS BLOG ANY DIFF THAN OTHERS!!\\n# Complexity\\n- Time complexity: $$O(n*m)$$ -> n = restrictions.length, m = requests.length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n            \\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int node, vector<int> &par){\\n        if(par[node] == node){\\n            return node;\\n        }\\n        return par[node] = find(par[node], par);\\n    }\\n    int join(int u, int v, vector<int> &par, vector<int> &si){\\n        int pu = find(u, par);\\n        int pv = find(v, par);\\n\\n        if(pu!=pv){\\n            if(si[pu]>=si[pv]){\\n                par[pv] = pu;\\n                si[pu] += si[pv];\\n            }\\n            else{\\n                par[pu] = pv;\\n                si[pv] += si[pu];\\n            }\\n            return 0;\\n        }\\n        return 1;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> ans;\\n        vector<int> par(n,-1), si(n,1);\\n        for(int i=0; i<n; ++i){\\n            par[i] = i;\\n        }\\n\\n        for(auto &edge:requests){ // putting & changes 1800ms code \\n            int u = edge[0], v = edge[1]; // to 200 ms!!!\\n            int pu = find(u, par), pv = find(v, par);\\n\\n            bool flag = true;\\n\\n            for(auto &ed:restrictions){ // same by putting & here\\n                int uu = ed[0], vv = ed[1];\\n                int puu = find(uu, par), pvv = find(vv, par);\\n                if((puu==pu && pvv==pv) || (puu==pv && pvv==pu)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if(flag) join(u,v,par,si);\\n            ans.push_back(flag);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int node, vector<int> &par){\\n        if(par[node] == node){\\n            return node;\\n        }\\n        return par[node] = find(par[node], par);\\n    }\\n    int join(int u, int v, vector<int> &par, vector<int> &si){\\n        int pu = find(u, par);\\n        int pv = find(v, par);\\n\\n        if(pu!=pv){\\n            if(si[pu]>=si[pv]){\\n                par[pv] = pu;\\n                si[pu] += si[pv];\\n            }\\n            else{\\n                par[pu] = pv;\\n                si[pv] += si[pu];\\n            }\\n            return 0;\\n        }\\n        return 1;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> ans;\\n        vector<int> par(n,-1), si(n,1);\\n        for(int i=0; i<n; ++i){\\n            par[i] = i;\\n        }\\n\\n        for(auto &edge:requests){ // putting & changes 1800ms code \\n            int u = edge[0], v = edge[1]; // to 200 ms!!!\\n            int pu = find(u, par), pv = find(v, par);\\n\\n            bool flag = true;\\n\\n            for(auto &ed:restrictions){ // same by putting & here\\n                int uu = ed[0], vv = ed[1];\\n                int puu = find(uu, par), pvv = find(vv, par);\\n                if((puu==pu && pvv==pv) || (puu==pv && pvv==pu)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if(flag) join(u,v,par,si);\\n            ans.push_back(flag);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969894,
                "title": "simple-dfs-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to take care that the restriction edge\\'s node should not belong from the same node \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we will assign different components to each node \\nas we get a request we will check that do they belong to same component or not, if they belong to different component then we will check that no nodes between these components shoudl lie in restriction edges\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$ \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$ \\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool dfs(int val, int node,int par, vector<vector<int>>&g,set<pair<int,int>>&st){\\n        if(st.find({val,node})!=st.end() || st.find({node,val})!=st.end()) return 0;\\n        int ans=1;\\n        for(auto i: g[node]) if(i!=par) ans&=dfs(val,i,node,g,st);\\n        return ans;\\n    }\\n\\n    bool check(int u,int v,int a,int b,vector<vector<int>>&g,set<pair<int,int>>&st){\\n        int ans=dfs(u,v,v,g,st);\\n        for(auto i: g[u]){\\n            if(i==a) continue;\\n            ans&=check(i,v,u,v,g,st);\\n        }\\n        return ans;\\n    }\\n\\n    void assign(int node,int par,int col,vector<vector<int>>&g,vector<int>&comp){\\n        comp[node]=col;\\n        for(auto child: g[node]){\\n            if(child!=par) assign(child,node,col,g,comp);\\n        }\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        set<pair<int,int>>st;\\n        for(auto i : restrictions) st.insert({i[0],i[1]});\\n        vector<int>comp(n);\\n        for(int i=0;i<n;i++) comp[i]=i;\\n        vector<vector<int>>g(n);\\n        vector<bool>ans;\\n        for(auto i: requests){\\n            int u=i[0],v=i[1];\\n            if(st.find({u,v})!=st.end() || st.find({v,u})!=st.end()){\\n                ans.push_back(false);\\n                continue;\\n            }\\n            if(comp[u]==comp[v]){\\n                ans.push_back(true);\\n                continue;\\n            }\\n\\n            if(check(u,v,u,v,g,st)){\\n                g[u].push_back(v);\\n                g[v].push_back(u);\\n                assign(u,v,comp[v],g,comp);\\n                ans.push_back(true);\\n            }\\n            else ans.push_back(false);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool dfs(int val, int node,int par, vector<vector<int>>&g,set<pair<int,int>>&st){\\n        if(st.find({val,node})!=st.end() || st.find({node,val})!=st.end()) return 0;\\n        int ans=1;\\n        for(auto i: g[node]) if(i!=par) ans&=dfs(val,i,node,g,st);\\n        return ans;\\n    }\\n\\n    bool check(int u,int v,int a,int b,vector<vector<int>>&g,set<pair<int,int>>&st){\\n        int ans=dfs(u,v,v,g,st);\\n        for(auto i: g[u]){\\n            if(i==a) continue;\\n            ans&=check(i,v,u,v,g,st);\\n        }\\n        return ans;\\n    }\\n\\n    void assign(int node,int par,int col,vector<vector<int>>&g,vector<int>&comp){\\n        comp[node]=col;\\n        for(auto child: g[node]){\\n            if(child!=par) assign(child,node,col,g,comp);\\n        }\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        set<pair<int,int>>st;\\n        for(auto i : restrictions) st.insert({i[0],i[1]});\\n        vector<int>comp(n);\\n        for(int i=0;i<n;i++) comp[i]=i;\\n        vector<vector<int>>g(n);\\n        vector<bool>ans;\\n        for(auto i: requests){\\n            int u=i[0],v=i[1];\\n            if(st.find({u,v})!=st.end() || st.find({v,u})!=st.end()){\\n                ans.push_back(false);\\n                continue;\\n            }\\n            if(comp[u]==comp[v]){\\n                ans.push_back(true);\\n                continue;\\n            }\\n\\n            if(check(u,v,u,v,g,st)){\\n                g[u].push_back(v);\\n                g[v].push_back(u);\\n                assign(u,v,comp[v],g,comp);\\n                ans.push_back(true);\\n            }\\n            else ans.push_back(false);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875779,
                "title": "easy-c-solution-using-disjoint-set",
                "content": "Use Disjoint Set and apply brute force .\\n\\n# Code\\n```\\n\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n    bool is_valid(DisjointSet ds,int n,int u,int v,map<pair<int,int>,bool> &not_join){\\n        ds.unionByRank(u,v);\\n\\n        for(auto it:not_join){\\n            int u1=it.first.first;\\n            int v1=it.first.second;\\n            if(ds.findUPar(u1)==ds.findUPar(v1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        DisjointSet ds(n);\\n        vector<bool> ans;\\n        map<pair<int,int>,bool> not_join;\\n\\n        for(auto it:restrictions){\\n            not_join[{it[0],it[1]}]=true;\\n            not_join[{it[1],it[0]}]=true;\\n        }\\n\\n        for(auto it:requests){\\n\\n            int u=it[0];\\n            int v=it[1];\\n\\n            if(ds.findUPar(u)==ds.findUPar(v)){\\n                ans.push_back(true);\\n                continue;\\n            }\\n            else{\\n\\n                if(is_valid(ds,n,u,v,not_join)){\\n                    ds.unionByRank(u,v);\\n                    ans.push_back(true);\\n                }\\n                else{\\n                    ans.push_back(false);\\n                }\\n\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n    bool is_valid(DisjointSet ds,int n,int u,int v,map<pair<int,int>,bool> &not_join){\\n        ds.unionByRank(u,v);\\n\\n        for(auto it:not_join){\\n            int u1=it.first.first;\\n            int v1=it.first.second;\\n            if(ds.findUPar(u1)==ds.findUPar(v1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        DisjointSet ds(n);\\n        vector<bool> ans;\\n        map<pair<int,int>,bool> not_join;\\n\\n        for(auto it:restrictions){\\n            not_join[{it[0],it[1]}]=true;\\n            not_join[{it[1],it[0]}]=true;\\n        }\\n\\n        for(auto it:requests){\\n\\n            int u=it[0];\\n            int v=it[1];\\n\\n            if(ds.findUPar(u)==ds.findUPar(v)){\\n                ans.push_back(true);\\n                continue;\\n            }\\n            else{\\n\\n                if(is_valid(ds,n,u,v,not_join)){\\n                    ds.unionByRank(u,v);\\n                    ans.push_back(true);\\n                }\\n                else{\\n                    ans.push_back(false);\\n                }\\n\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855862,
                "title": "union-find",
                "content": "```\\nclass UnionFind{\\n        int n;\\n        vector<int> parent;\\n        vector<int> rank;\\n        vector<unordered_set<int>> rest;\\n       \\n        vector<set<int>>& adj;\\n        public:\\n        UnionFind(int _n, vector<set<int>>& _adj) : n(_n), adj(_adj), parent(vector<int>(n, 0)), rank(vector<int>(n, 1)), rest(vector<unordered_set<int>>(_n))\\n        {\\n            for(int i=0; i<_n; i++)\\n            {\\n                parent[i]=i;\\n                if(!adj[i].empty())\\n                {\\n                    rest[i].emplace(i);\\n                }\\n            }\\n       }\\n        \\n        int find(int v)\\n        {\\n            if(v != parent[v])\\n            {\\n                parent[v] = find(parent[v]);\\n            }\\n            return parent[v];\\n        }\\n        \\n        bool add(int v, int u)\\n        {\\n            \\n            int pv = find(v);\\n            int pu = find(u);\\n            \\n            \\n            if(pv == pu)\\n                return true;\\n            \\n            for(auto itr : rest[pv])\\n            {\\n                for(auto itr1 : rest[pu])\\n                if(adj[itr1].count(itr))\\n                    return false;\\n            }\\n            \\n            auto& rpv = rank[pv];\\n            auto& rpu = rank[pu];\\n            \\n            if(rpv >= rpu)\\n            {\\n                if(rpv == rpu)\\n                    rpv++;\\n                parent[pu] = pv;\\n                rest[pv].insert(rest[pu].begin(), rest[pu].end());\\n            }\\n            else{\\n                parent[pv] = pu;\\n                rest[pu].insert(rest[pv].begin(), rest[pv].end());\\n            }\\n            find(v);find(u);\\n            return true;\\n        }\\n    };\\n\\nclass Solution {\\n    public:\\n    vector<set<int>> adj;\\n    \\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        adj = vector<set<int>>(n);\\n        for(auto r : restrictions)\\n        {\\n            adj[r[0]].emplace(r[1]);\\n            adj[r[1]].emplace(r[0]);\\n        }\\n        UnionFind uf(n, adj);\\n        vector<bool> ans(requests.size(), false);\\n        for(int i=0; i<requests.size(); i++)\\n        {\\n            auto ret = uf.add(requests[i][0], requests[i][1]);\\n            ans[i] = ret;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind{\\n        int n;\\n        vector<int> parent;\\n        vector<int> rank;\\n        vector<unordered_set<int>> rest;\\n       \\n        vector<set<int>>& adj;\\n        public:\\n        UnionFind(int _n, vector<set<int>>& _adj) : n(_n), adj(_adj), parent(vector<int>(n, 0)), rank(vector<int>(n, 1)), rest(vector<unordered_set<int>>(_n))\\n        {\\n            for(int i=0; i<_n; i++)\\n            {\\n                parent[i]=i;\\n                if(!adj[i].empty())\\n                {\\n                    rest[i].emplace(i);\\n                }\\n            }\\n       }\\n        \\n        int find(int v)\\n        {\\n            if(v != parent[v])\\n            {\\n                parent[v] = find(parent[v]);\\n            }\\n            return parent[v];\\n        }\\n        \\n        bool add(int v, int u)\\n        {\\n            \\n            int pv = find(v);\\n            int pu = find(u);\\n            \\n            \\n            if(pv == pu)\\n                return true;\\n            \\n            for(auto itr : rest[pv])\\n            {\\n                for(auto itr1 : rest[pu])\\n                if(adj[itr1].count(itr))\\n                    return false;\\n            }\\n            \\n            auto& rpv = rank[pv];\\n            auto& rpu = rank[pu];\\n            \\n            if(rpv >= rpu)\\n            {\\n                if(rpv == rpu)\\n                    rpv++;\\n                parent[pu] = pv;\\n                rest[pv].insert(rest[pu].begin(), rest[pu].end());\\n            }\\n            else{\\n                parent[pv] = pu;\\n                rest[pu].insert(rest[pv].begin(), rest[pv].end());\\n            }\\n            find(v);find(u);\\n            return true;\\n        }\\n    };\\n\\nclass Solution {\\n    public:\\n    vector<set<int>> adj;\\n    \\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        adj = vector<set<int>>(n);\\n        for(auto r : restrictions)\\n        {\\n            adj[r[0]].emplace(r[1]);\\n            adj[r[1]].emplace(r[0]);\\n        }\\n        UnionFind uf(n, adj);\\n        vector<bool> ans(requests.size(), false);\\n        for(int i=0; i<requests.size(); i++)\\n        {\\n            auto ret = uf.add(requests[i][0], requests[i][1]);\\n            ans[i] = ret;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847389,
                "title": "dsu-with-rollback",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDSU with rollback\\nbrute force according to me\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndo union\\ncheck if it violates conditions or not\\nif it is then rollback\\notherwise move on\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*n*logn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass DisjointSet {\\npublic :\\n    vector<int> size, parent;\\n    stack<pair<int, int>> parentHistory, sizeHistory; // {element, currentValue of element}\\n    DisjointSet(int n) {\\n        parent.resize(n + 1);\\n        size.resize(n + 1, 1);\\n        \\n        for(int i = 0 ; i <= n ; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n    // T.C = O(logN) as no path compression is there\\n    int findUltimateParent(int node) {\\n        if(node == parent[node]) {\\n            return node;\\n        }\\n        return findUltimateParent(parent[node]);\\n    }\\n    // T.C = O(logN)\\n    void unionBySize(int node1, int node2) {\\n        int ultimateParent1 = findUltimateParent(node1);\\n        int ultimateParent2 = findUltimateParent(node2);\\n        \\n        if(ultimateParent1 == ultimateParent2) return;\\n        \\n        if(size[ultimateParent1] > size[ultimateParent2]) {\\n            parentHistory.push({ultimateParent2, ultimateParent2});\\n            sizeHistory.push({ultimateParent1, size[ultimateParent1]});\\n            \\n            parent[ultimateParent2] = ultimateParent1;\\n            size[ultimateParent1] += size[ultimateParent2];\\n        }\\n        else{\\n            parentHistory.push({ultimateParent1, ultimateParent1});\\n            sizeHistory.push({ultimateParent2, size[ultimateParent2]});\\n            \\n            parent[ultimateParent1] = ultimateParent2;\\n            size[ultimateParent2] += size[ultimateParent1];\\n        }\\n    }\\n    // T.C = O(1)\\n    void rollback() {\\n        // restore the previous state of size and parent\\n        // if(sizeHistory.size() == 0 || parentHistory.size() == 0) return ;\\n\\n        int node = sizeHistory.top().first;\\n        int previousSize = sizeHistory.top().second;\\n        sizeHistory.pop();\\n        \\n        size[node] = previousSize;\\n        \\n        int targetNode = parentHistory.top().first;\\n        int previousParent = parentHistory.top().second;\\n        parentHistory.pop();\\n        \\n        parent[targetNode] = previousParent;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DisjointSet ds(n);\\n        vector<bool> ans(requests.size(), false);\\n\\n        // Traversing requests vector\\n        for(int i = 0 ; i < requests.size() ; i++) {\\n            int node1 = requests[i][0];\\n            int node2 = requests[i][1];\\n\\n            ds.unionBySize(node1, node2);\\n            ans[i] = true;\\n\\n            // Traversing restrictions vector\\n            for(auto it : restrictions) {\\n                if(ds.findUltimateParent(it[0]) == ds.findUltimateParent(it[1])) {\\n                    ds.rollback();\\n                    ans[i] = false;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet {\\npublic :\\n    vector<int> size, parent;\\n    stack<pair<int, int>> parentHistory, sizeHistory; // {element, currentValue of element}\\n    DisjointSet(int n) {\\n        parent.resize(n + 1);\\n        size.resize(n + 1, 1);\\n        \\n        for(int i = 0 ; i <= n ; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n    // T.C = O(logN) as no path compression is there\\n    int findUltimateParent(int node) {\\n        if(node == parent[node]) {\\n            return node;\\n        }\\n        return findUltimateParent(parent[node]);\\n    }\\n    // T.C = O(logN)\\n    void unionBySize(int node1, int node2) {\\n        int ultimateParent1 = findUltimateParent(node1);\\n        int ultimateParent2 = findUltimateParent(node2);\\n        \\n        if(ultimateParent1 == ultimateParent2) return;\\n        \\n        if(size[ultimateParent1] > size[ultimateParent2]) {\\n            parentHistory.push({ultimateParent2, ultimateParent2});\\n            sizeHistory.push({ultimateParent1, size[ultimateParent1]});\\n            \\n            parent[ultimateParent2] = ultimateParent1;\\n            size[ultimateParent1] += size[ultimateParent2];\\n        }\\n        else{\\n            parentHistory.push({ultimateParent1, ultimateParent1});\\n            sizeHistory.push({ultimateParent2, size[ultimateParent2]});\\n            \\n            parent[ultimateParent1] = ultimateParent2;\\n            size[ultimateParent2] += size[ultimateParent1];\\n        }\\n    }\\n    // T.C = O(1)\\n    void rollback() {\\n        // restore the previous state of size and parent\\n        // if(sizeHistory.size() == 0 || parentHistory.size() == 0) return ;\\n\\n        int node = sizeHistory.top().first;\\n        int previousSize = sizeHistory.top().second;\\n        sizeHistory.pop();\\n        \\n        size[node] = previousSize;\\n        \\n        int targetNode = parentHistory.top().first;\\n        int previousParent = parentHistory.top().second;\\n        parentHistory.pop();\\n        \\n        parent[targetNode] = previousParent;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DisjointSet ds(n);\\n        vector<bool> ans(requests.size(), false);\\n\\n        // Traversing requests vector\\n        for(int i = 0 ; i < requests.size() ; i++) {\\n            int node1 = requests[i][0];\\n            int node2 = requests[i][1];\\n\\n            ds.unionBySize(node1, node2);\\n            ans[i] = true;\\n\\n            // Traversing restrictions vector\\n            for(auto it : restrictions) {\\n                if(ds.findUltimateParent(it[0]) == ds.findUltimateParent(it[1])) {\\n                    ds.rollback();\\n                    ans[i] = false;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839807,
                "title": "java-comments-clean-code-simple-explanation",
                "content": "# Intuition\\nMake them friend first, and then check if parent of restriction node belongs to same component or not \\nIf they belong to same component then revert back your ans\\nIf not then mark your answer as true and continue for others.\\n\\n# Code\\n```\\nclass Solution {\\n    class Disjoint{ //basic disjoint class tempelate\\n        int V;\\n        int[] parent,size;\\n\\n        Disjoint(int V){\\n            this.V=V;\\n            parent=new int[V];\\n            size=new int[V];\\n            for(int i=0; i<V; i++){\\n                parent[i]=i;\\n                size[i]=1;\\n            }\\n        }\\n\\n    int findParent(int x){\\n        if(parent[x]==x)\\n        return x;\\n        return findParent(parent[x]);\\n    }\\n\\n    void unionBySize(int x,int y){\\n        int px=findParent(x);\\n        int py=findParent(y);\\n\\n        if(px==py)return ;\\n        if(size[px]<size[py]){\\n            size[py]+=size[px];\\n            parent[px]=py;\\n        }else{\\n             size[px]+=size[py];\\n            parent[py]=px;\\n        }\\n    }\\n\\n\\n    }\\n    public boolean[] friendRequests(int n, int[][] rest , int[][] requests) {\\n        Disjoint ds=new Disjoint(n);\\n        boolean[] ans=new boolean[requests.length];\\n        Arrays.fill(ans,true);\\n\\n        for(int i=0; i<requests.length; i++){\\n            int x=requests[i][0];\\n            int y=requests[i][1];\\n\\n            int opx=ds.findParent(x);// old parent of x\\n            int opy=ds.findParent(y);// old parent of y\\n\\n                 ds.unionBySize(x,y);   // make them friend irrespective of restrictions\\n\\n             if( isRuleVoilated(rest,ds)){// now check if any restriction rule is voilated.\\n                   ds.parent[opx]=opx;  // if rule is violated then restore.\\n                 ds.parent[opy]=opy;    // parent of x and y should point them self showing they were not friend.\\n                 ans[i]=false; // mark ans as false\\n             }\\n\\n          // remember ans is filled with true. So no need to add ans[i]=true;\\n        }\\n        return ans;\\n    }\\n\\n\\n    boolean isRuleVoilated(int[][] res,Disjoint ds){\\n        for(int i=0; i<res.length; i++){\\n            int p1=ds.findParent(res[i][0]);\\n            int p2=ds.findParent(res[i][1]);    // if  parent of both restriction node belongs to same component then notify rule is voilated \\n\\n            if(p1==p2){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n# Upvote button is below, don\\'t mind hitting it \\uD83E\\uDD24\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Disjoint{ //basic disjoint class tempelate\\n        int V;\\n        int[] parent,size;\\n\\n        Disjoint(int V){\\n            this.V=V;\\n            parent=new int[V];\\n            size=new int[V];\\n            for(int i=0; i<V; i++){\\n                parent[i]=i;\\n                size[i]=1;\\n            }\\n        }\\n\\n    int findParent(int x){\\n        if(parent[x]==x)\\n        return x;\\n        return findParent(parent[x]);\\n    }\\n\\n    void unionBySize(int x,int y){\\n        int px=findParent(x);\\n        int py=findParent(y);\\n\\n        if(px==py)return ;\\n        if(size[px]<size[py]){\\n            size[py]+=size[px];\\n            parent[px]=py;\\n        }else{\\n             size[px]+=size[py];\\n            parent[py]=px;\\n        }\\n    }\\n\\n\\n    }\\n    public boolean[] friendRequests(int n, int[][] rest , int[][] requests) {\\n        Disjoint ds=new Disjoint(n);\\n        boolean[] ans=new boolean[requests.length];\\n        Arrays.fill(ans,true);\\n\\n        for(int i=0; i<requests.length; i++){\\n            int x=requests[i][0];\\n            int y=requests[i][1];\\n\\n            int opx=ds.findParent(x);// old parent of x\\n            int opy=ds.findParent(y);// old parent of y\\n\\n                 ds.unionBySize(x,y);   // make them friend irrespective of restrictions\\n\\n             if( isRuleVoilated(rest,ds)){// now check if any restriction rule is voilated.\\n                   ds.parent[opx]=opx;  // if rule is violated then restore.\\n                 ds.parent[opy]=opy;    // parent of x and y should point them self showing they were not friend.\\n                 ans[i]=false; // mark ans as false\\n             }\\n\\n          // remember ans is filled with true. So no need to add ans[i]=true;\\n        }\\n        return ans;\\n    }\\n\\n\\n    boolean isRuleVoilated(int[][] res,Disjoint ds){\\n        for(int i=0; i<res.length; i++){\\n            int p1=ds.findParent(res[i][0]);\\n            int p2=ds.findParent(res[i][1]);    // if  parent of both restriction node belongs to same component then notify rule is voilated \\n\\n            if(p1==p2){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768877,
                "title": "clean-code-dsu-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse DSU to check if u and v are friend already.If they are friend simply put 1 at that index.If they are not friends then check if by their friendship there will be any contradictions.If it lead to any restriced pair then answer would be false else answer will be true.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sz[1001];\\n    int par[1001];\\n    void makeset()\\n    {\\n        for(int i=0;i<1001;i++)\\n        {\\n            sz[i]=1;\\n            par[i]=i;\\n        }\\n    }\\n    int find(int node)\\n    {\\n        if(par[node]==node)\\n        {\\n            return node;\\n        }\\n        return par[node]=find(par[node]);\\n    }\\n    void merge(int u,int v)\\n    {\\n        u=find(u);\\n        v=find(v);\\n        if(u!=v)\\n        {\\n            if(sz[v]>sz[u])\\n            {\\n                swap(u,v);\\n            }\\n            sz[u]+=sz[v];\\n            par[v]=u;\\n        }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& req) {\\n        int rn=res.size();\\n        int rqn=req.size();\\n        makeset();\\n        vector<bool> ans(rqn,0);\\n        for(int i=0;i<rqn;i++)\\n        {\\n            int u=req[i][0];\\n            int v=req[i][1];\\n            int p1=find(u);\\n            int p2=find(v);\\n            if(find(u)==find(v))\\n            {\\n                ans[i]=1;\\n            }\\n            else//need to check for contradictions \\n            {\\n                bool check=1;\\n                for(int j=0;j<rn;j++)\\n                {\\n                    int x=res[j][0];\\n                    int y=res[j][1];\\n                    if((find(x)==p1&&find(y)==p2)||(find(x)==p2&&find(y)==p1))\\n                    {\\n                        check=0;\\n                    }\\n\\n                }\\n                if(check)\\n                {\\n                    merge(u,v);\\n                    ans[i]=1;\\n                }\\n                else\\n                {\\n                    ans[i]=0;\\n                }\\n            }\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sz[1001];\\n    int par[1001];\\n    void makeset()\\n    {\\n        for(int i=0;i<1001;i++)\\n        {\\n            sz[i]=1;\\n            par[i]=i;\\n        }\\n    }\\n    int find(int node)\\n    {\\n        if(par[node]==node)\\n        {\\n            return node;\\n        }\\n        return par[node]=find(par[node]);\\n    }\\n    void merge(int u,int v)\\n    {\\n        u=find(u);\\n        v=find(v);\\n        if(u!=v)\\n        {\\n            if(sz[v]>sz[u])\\n            {\\n                swap(u,v);\\n            }\\n            sz[u]+=sz[v];\\n            par[v]=u;\\n        }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& req) {\\n        int rn=res.size();\\n        int rqn=req.size();\\n        makeset();\\n        vector<bool> ans(rqn,0);\\n        for(int i=0;i<rqn;i++)\\n        {\\n            int u=req[i][0];\\n            int v=req[i][1];\\n            int p1=find(u);\\n            int p2=find(v);\\n            if(find(u)==find(v))\\n            {\\n                ans[i]=1;\\n            }\\n            else//need to check for contradictions \\n            {\\n                bool check=1;\\n                for(int j=0;j<rn;j++)\\n                {\\n                    int x=res[j][0];\\n                    int y=res[j][1];\\n                    if((find(x)==p1&&find(y)==p2)||(find(x)==p2&&find(y)==p1))\\n                    {\\n                        check=0;\\n                    }\\n\\n                }\\n                if(check)\\n                {\\n                    merge(u,v);\\n                    ans[i]=1;\\n                }\\n                else\\n                {\\n                    ans[i]=0;\\n                }\\n            }\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759687,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n_requests * n_restrictions)\\n * Space Complexity: O(n)\\n * where `n_requests` is the length of the vector `requests`\\n *       `n_restrictions` is the length of the vector `restrictions`\\n */\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), ranks_(n) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (parents_[i] == i) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      if (ranks_[parent_i] < ranks_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n      } else if (ranks_[parent_i] > ranks_[parent_j]) {\\n        parents_[parent_j] = parent_i;\\n      } else {\\n        parents_[parent_i] = parent_j;\\n        ++ranks_[parent_j];\\n      }\\n      return true;\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> ranks_;\\n  };\\n  \\n public:\\n  vector<bool> friendRequests(const int n,\\n                              const vector<vector<int>> &restrictions,\\n                              const vector<vector<int>> &requests) {\\n    const int n_requests = static_cast<int>(requests.size());\\n    vector<bool> ret(n_requests);\\n    DisjointSet ds(n);\\n    for (int i_request = 0; i_request < n_requests; ++i_request) {\\n      const vector<int> &request = requests[i_request];\\n      const int request_parent1 = ds.find(request.front());\\n      const int request_parent2 = ds.find(request.back());\\n      if (request_parent1 == request_parent2) {\\n        ret[i_request] = true;\\n        continue;\\n      }\\n      \\n      bool successful = true;\\n      for (const vector<int> &restriction : restrictions) {\\n        const int restrict_parent1 = ds.find(restriction.front());\\n        const int restrict_parent2 = ds.find(restriction.back());\\n        if ((restrict_parent1 == request_parent1 || restrict_parent1 == request_parent2) &&\\n            (restrict_parent2 == request_parent1 || restrict_parent2 == request_parent2)) {\\n          successful = false;\\n          break;\\n        }\\n      }\\n      ret[i_request] = successful;\\n      if (successful) {\\n        ds.do_union(request_parent1, request_parent2);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n_requests * n_restrictions)\\n * Space Complexity: O(n)\\n * where `n_requests` is the length of the vector `requests`\\n *       `n_restrictions` is the length of the vector `restrictions`\\n */\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const int n) : parents_(n), ranks_(n) {\\n      iota(parents_.begin(), parents_.end(), 0);\\n    }\\n    \\n    int find(const int i) {\\n      if (parents_[i] == i) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    bool do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return false;\\n      }\\n      \\n      if (ranks_[parent_i] < ranks_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n      } else if (ranks_[parent_i] > ranks_[parent_j]) {\\n        parents_[parent_j] = parent_i;\\n      } else {\\n        parents_[parent_i] = parent_j;\\n        ++ranks_[parent_j];\\n      }\\n      return true;\\n    }\\n    \\n   private:\\n    vector<int> parents_;\\n    vector<int> ranks_;\\n  };\\n  \\n public:\\n  vector<bool> friendRequests(const int n,\\n                              const vector<vector<int>> &restrictions,\\n                              const vector<vector<int>> &requests) {\\n    const int n_requests = static_cast<int>(requests.size());\\n    vector<bool> ret(n_requests);\\n    DisjointSet ds(n);\\n    for (int i_request = 0; i_request < n_requests; ++i_request) {\\n      const vector<int> &request = requests[i_request];\\n      const int request_parent1 = ds.find(request.front());\\n      const int request_parent2 = ds.find(request.back());\\n      if (request_parent1 == request_parent2) {\\n        ret[i_request] = true;\\n        continue;\\n      }\\n      \\n      bool successful = true;\\n      for (const vector<int> &restriction : restrictions) {\\n        const int restrict_parent1 = ds.find(restriction.front());\\n        const int restrict_parent2 = ds.find(restriction.back());\\n        if ((restrict_parent1 == request_parent1 || restrict_parent1 == request_parent2) &&\\n            (restrict_parent2 == request_parent1 || restrict_parent2 == request_parent2)) {\\n          successful = false;\\n          break;\\n        }\\n      }\\n      ret[i_request] = successful;\\n      if (successful) {\\n        ds.do_union(request_parent1, request_parent2);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747564,
                "title": "not-the-best-solution-but-still-something",
                "content": "The key idea is that for every request i process, i will check all the restriction and find the first one that isn\\'t allowed.\\nif i find one, i will restore the disjoint set back to where it was before i united by doing some new object assignment.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    struct union_find{\\n      int n;\\n      vector<int>parent, rank;\\n      vector<int>_parent, _rank;\\n        \\n      union_find (int n) : n(n) {\\n          parent.resize(n);\\n          iota(parent.begin(), parent.end(), 0);\\n          rank.resize(n,1);\\n          _parent = parent;\\n          _rank = rank;\\n      }\\n        \\n      int find(int a){\\n           if(parent[a] == a)return a;\\n           return parent[a] = find(parent[a]);\\n      }\\n        \\n      void unite(int a, int b){\\n           a = find(a), b = find(b);\\n          \\n           if(a == b)return;\\n          \\n           \\n           if(rank[a] < rank[b]){\\n                parent[a] = b;\\n                rank[b] += rank[a];\\n           }\\n           else{\\n                parent[b] = a;\\n                rank[a] += rank[b];\\n           }\\n      }\\n    \\n      void restore(int a, int b, int c, int d, bool check){\\n          \\n          if(!check){\\n              // reject the pull request.\\n              parent[a] = _parent[a]; rank[a] = _rank[a]; parent[b] = _parent[b]; rank[b] = _rank[b];\\n              parent[c] = _parent[c]; rank[c] = _rank[c]; parent[d] = _parent[d]; rank[d] = _rank[d];\\n          }\\n          else{\\n              // accept it if everything looks fine. \\n              _parent[a] = parent[a]; _rank[a] = rank[a]; _parent[b] = parent[b]; _rank[b] = rank[b];\\n              _parent[c] = parent[c]; _rank[c] = rank[c]; _parent[d] = parent[d]; _rank[d] = rank[d];\\n          }\\n          \\n      }\\n        \\n      \\n   };\\n    \\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        // so if each request we process.\\n        // we need to go and check our whole restrictions to go and check all restrictions to make sure everything is still fine else we revert what we did and put false\\n        \\n        union_find solve(n), solve1(n);\\n        vector<bool>answer;\\n        int p_x, p_y, r_x, r_y;\\n        int counter = 0;\\n        bool check;\\n        \\n        for(auto& request : requests) {\\n            check  = true;\\n            solve1 = solve;\\n            p_x = solve.find(request[0]);\\n            p_y = solve.find(request[1]);\\n            \\n            solve.unite(request[0], request[1]);\\n            \\n            for(auto& restriction : restrictions) {\\n                \\n                if(solve.find(restriction[0]) == solve.find(restriction[1])) {\\n                   answer.push_back(false); check = false; break;\\n                }\\n                \\n            }\\n            \\n            if(check){ answer.push_back(true);}\\n            else solve = solve1;    // main code\\n            counter +=1;\\n        }\\n        \\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct union_find{\\n      int n;\\n      vector<int>parent, rank;\\n      vector<int>_parent, _rank;\\n        \\n      union_find (int n) : n(n) {\\n          parent.resize(n);\\n          iota(parent.begin(), parent.end(), 0);\\n          rank.resize(n,1);\\n          _parent = parent;\\n          _rank = rank;\\n      }\\n        \\n      int find(int a){\\n           if(parent[a] == a)return a;\\n           return parent[a] = find(parent[a]);\\n      }\\n        \\n      void unite(int a, int b){\\n           a = find(a), b = find(b);\\n          \\n           if(a == b)return;\\n          \\n           \\n           if(rank[a] < rank[b]){\\n                parent[a] = b;\\n                rank[b] += rank[a];\\n           }\\n           else{\\n                parent[b] = a;\\n                rank[a] += rank[b];\\n           }\\n      }\\n    \\n      void restore(int a, int b, int c, int d, bool check){\\n          \\n          if(!check){\\n              // reject the pull request.\\n              parent[a] = _parent[a]; rank[a] = _rank[a]; parent[b] = _parent[b]; rank[b] = _rank[b];\\n              parent[c] = _parent[c]; rank[c] = _rank[c]; parent[d] = _parent[d]; rank[d] = _rank[d];\\n          }\\n          else{\\n              // accept it if everything looks fine. \\n              _parent[a] = parent[a]; _rank[a] = rank[a]; _parent[b] = parent[b]; _rank[b] = rank[b];\\n              _parent[c] = parent[c]; _rank[c] = rank[c]; _parent[d] = parent[d]; _rank[d] = rank[d];\\n          }\\n          \\n      }\\n        \\n      \\n   };\\n    \\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        // so if each request we process.\\n        // we need to go and check our whole restrictions to go and check all restrictions to make sure everything is still fine else we revert what we did and put false\\n        \\n        union_find solve(n), solve1(n);\\n        vector<bool>answer;\\n        int p_x, p_y, r_x, r_y;\\n        int counter = 0;\\n        bool check;\\n        \\n        for(auto& request : requests) {\\n            check  = true;\\n            solve1 = solve;\\n            p_x = solve.find(request[0]);\\n            p_y = solve.find(request[1]);\\n            \\n            solve.unite(request[0], request[1]);\\n            \\n            for(auto& restriction : restrictions) {\\n                \\n                if(solve.find(restriction[0]) == solve.find(restriction[1])) {\\n                   answer.push_back(false); check = false; break;\\n                }\\n                \\n            }\\n            \\n            if(check){ answer.push_back(true);}\\n            else solve = solve1;    // main code\\n            counter +=1;\\n        }\\n        \\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647122,
                "title": "c-union-find-easy-solution",
                "content": "# Approach\\n- Connect those friends whose parents are not in the restricted array where parent represents the leader of a group as we do in Union find.\\n- To check if parents of two nodes are in restricted array, we can simply iterate in the restricted array due to smaller constraints.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> parent,rank;\\n    int findPar(int x)\\n    {\\n        if(parent[x]==x)\\n            return x;\\n        return parent[x] = findPar(parent[x]);\\n    }\\n    void Union(int x,int y)\\n    {\\n        int u = findPar(x);\\n        int v = findPar(y);\\n        if(u==v)\\n            return;\\n        if(rank[u]>=rank[v])\\n        {\\n            rank[u]++;\\n            parent[v] = u;\\n        }\\n        else\\n        {\\n            rank[v]++;\\n            parent[u] = v;\\n        }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& rest, vector<vector<int>>& req) {\\n        parent.resize(n);\\n        rank.resize(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i] = i;\\n            rank[i] = 1;\\n        }\\n        vector<bool> ans;\\n        for(int i=0;i<req.size();i++)\\n        {\\n            int x = req[i][0];\\n            int y = req[i][1];\\n            int u = findPar(x);\\n            int v = findPar(y);\\n            bool flg = true;\\n            if(u!=v)\\n            {\\n                for(auto &j:rest)\\n                {\\n                    int a = findPar(j[0]);\\n                    int b = findPar(j[1]);\\n                    if((u==a && v==b)||(u==b && v==a))\\n                    {\\n                        flg = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            ans.push_back(flg);\\n            if(flg)\\n            {\\n                Union(u,v);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent,rank;\\n    int findPar(int x)\\n    {\\n        if(parent[x]==x)\\n            return x;\\n        return parent[x] = findPar(parent[x]);\\n    }\\n    void Union(int x,int y)\\n    {\\n        int u = findPar(x);\\n        int v = findPar(y);\\n        if(u==v)\\n            return;\\n        if(rank[u]>=rank[v])\\n        {\\n            rank[u]++;\\n            parent[v] = u;\\n        }\\n        else\\n        {\\n            rank[v]++;\\n            parent[u] = v;\\n        }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& rest, vector<vector<int>>& req) {\\n        parent.resize(n);\\n        rank.resize(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i] = i;\\n            rank[i] = 1;\\n        }\\n        vector<bool> ans;\\n        for(int i=0;i<req.size();i++)\\n        {\\n            int x = req[i][0];\\n            int y = req[i][1];\\n            int u = findPar(x);\\n            int v = findPar(y);\\n            bool flg = true;\\n            if(u!=v)\\n            {\\n                for(auto &j:rest)\\n                {\\n                    int a = findPar(j[0]);\\n                    int b = findPar(j[1]);\\n                    if((u==a && v==b)||(u==b && v==a))\\n                    {\\n                        flg = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            ans.push_back(flg);\\n            if(flg)\\n            {\\n                Union(u,v);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629616,
                "title": "c-memory-94-35-union-find",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int>&parent,int node){\\n        if(parent[node]==node){\\n            return node;\\n        }\\n        return parent[node]=find(parent,parent[node]);\\n    }\\n    void _union(vector<int>&parent,int u,int v){\\n        u=find(parent,u);\\n        v=find(parent,v);\\n        if(u!=v){\\n            parent[v]=u;\\n        }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool>ans;\\n        vector<int>parent(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<requests.size();i++){\\n            int u=find(parent,requests[i][0]);\\n            int v=find(parent,requests[i][1]);\\n            bool is_valid=true;\\n            if(u!=v){\\n                for(int j=0;j<restrictions.size();j++){\\n                    int x=find(parent,restrictions[j][0]);\\n                    int y=find(parent,restrictions[j][1]);\\n                        if(u==x and v==y or u==y and v==x){\\n                        is_valid=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(is_valid){\\n                _union(parent,u,v);\\n            }\\n            ans.push_back(is_valid);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>&parent,int node){\\n        if(parent[node]==node){\\n            return node;\\n        }\\n        return parent[node]=find(parent,parent[node]);\\n    }\\n    void _union(vector<int>&parent,int u,int v){\\n        u=find(parent,u);\\n        v=find(parent,v);\\n        if(u!=v){\\n            parent[v]=u;\\n        }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool>ans;\\n        vector<int>parent(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<requests.size();i++){\\n            int u=find(parent,requests[i][0]);\\n            int v=find(parent,requests[i][1]);\\n            bool is_valid=true;\\n            if(u!=v){\\n                for(int j=0;j<restrictions.size();j++){\\n                    int x=find(parent,restrictions[j][0]);\\n                    int y=find(parent,restrictions[j][1]);\\n                        if(u==x and v==y or u==y and v==x){\\n                        is_valid=false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(is_valid){\\n                _union(parent,u,v);\\n            }\\n            ans.push_back(is_valid);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515407,
                "title": "c-concise-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> res;\\n        vroot.resize(n);\\n        for(int i=0;i<n;i++) vroot[i] = i;\\n        for(auto& req:requests){\\n            int i = req[0], j = req[1], ri = root(i), rj = root(j);\\n            bool isGood = true;\\n            for(auto& v : restrictions){\\n                int x = root(v[0]), y = root(v[1]);\\n                if((x == ri && y == rj) || (x == rj && y==ri)){\\n                    isGood = false;\\n                    break;\\n                }\\n            }\\n            if(isGood) join(ri, rj);\\n            res.push_back(isGood);\\n        }\\n        return res;\\n    }\\n\\n    int root(int i){\\n        if(vroot[i] == i) return i;\\n        return vroot[i] = root(vroot[i]);\\n    }\\n\\n    void join(int i, int j){\\n        vroot[root(i)] = root(j);\\n    }\\n\\n    vector<int> vroot;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> res;\\n        vroot.resize(n);\\n        for(int i=0;i<n;i++) vroot[i] = i;\\n        for(auto& req:requests){\\n            int i = req[0], j = req[1], ri = root(i), rj = root(j);\\n            bool isGood = true;\\n            for(auto& v : restrictions){\\n                int x = root(v[0]), y = root(v[1]);\\n                if((x == ri && y == rj) || (x == rj && y==ri)){\\n                    isGood = false;\\n                    break;\\n                }\\n            }\\n            if(isGood) join(ri, rj);\\n            res.push_back(isGood);\\n        }\\n        return res;\\n    }\\n\\n    int root(int i){\\n        if(vroot[i] == i) return i;\\n        return vroot[i] = root(vroot[i]);\\n    }\\n\\n    void join(int i, int j){\\n        vroot[root(i)] = root(j);\\n    }\\n\\n    vector<int> vroot;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502743,
                "title": "union-find-small-trick",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic union find data structure to be used. The part to tell if the a restriction would be violated before a connection can be made needs some thinking, which is the hardest part of this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter figuring out how to resolve the above problem in the intuition by comparing the bosses/heads of the 2 sets requested to be joint and bosses/heads in every restrictions, it\\'s just a union find problem.\\n\\nUse `for/else` probably for the first time in python\\n\\n# Complexity\\n- Time complexity:\\nAs unionfind\\n\\n- Space complexity:\\nUsed a recursive function so probably not very good\\n\\n# Code\\n```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.head = [i for i in range(n)]\\n\\n    def connect(self, a, b):\\n        head_a, head_b = self.find(a), self.find(b)\\n\\n        if head_a == head_b:\\n            return\\n\\n        self.head[head_a] = self.find(head_b)\\n        \\n    def find(self, a):\\n        if self.head[a] == a:\\n            return a\\n\\n        self.head[a] = self.find(self.head[a])\\n        return self.head[a]\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        groups = UnionFind(n)\\n        res = []\\n\\n        for a, b in requests:\\n            boss_a, boss_b = groups.find(a), groups.find(b)\\n\\n            if boss_a == boss_b:\\n                res.append(True)\\n                continue\\n\\n            for c, d in restrictions:\\n                boss_c, boss_d = groups.find(c), groups.find(d)\\n\\n                if (boss_a == boss_c and boss_b == boss_d) or (boss_a == boss_d and boss_b == boss_c):\\n                    res.append(False)\\n                    break\\n            else:\\n                res.append(True)\\n                groups.connect(a, b)\\n        \\n        return res\\n\\n\\n\\n\\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.head = [i for i in range(n)]\\n\\n    def connect(self, a, b):\\n        head_a, head_b = self.find(a), self.find(b)\\n\\n        if head_a == head_b:\\n            return\\n\\n        self.head[head_a] = self.find(head_b)\\n        \\n    def find(self, a):\\n        if self.head[a] == a:\\n            return a\\n\\n        self.head[a] = self.find(self.head[a])\\n        return self.head[a]\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        groups = UnionFind(n)\\n        res = []\\n\\n        for a, b in requests:\\n            boss_a, boss_b = groups.find(a), groups.find(b)\\n\\n            if boss_a == boss_b:\\n                res.append(True)\\n                continue\\n\\n            for c, d in restrictions:\\n                boss_c, boss_d = groups.find(c), groups.find(d)\\n\\n                if (boss_a == boss_c and boss_b == boss_d) or (boss_a == boss_d and boss_b == boss_c):\\n                    res.append(False)\\n                    break\\n            else:\\n                res.append(True)\\n                groups.connect(a, b)\\n        \\n        return res\\n\\n\\n\\n\\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485591,
                "title": "c-easy-solution-disjoint-set-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int size=requests.size();\\n        DisjointSet ds(n);\\n        vector<bool> ans(size,false);\\n        for(int i=0;i<size;i++){\\n            int u=ds.findUPar(requests[i][0]);\\n            int v=ds.findUPar(requests[i][1]);\\n            bool flag=true;\\n            for(int j=0;j<restrictions.size();j++){\\n                int new_u=ds.findUPar(restrictions[j][0]);\\n                int new_v=ds.findUPar(restrictions[j][1]);\\n                if((new_u==u && new_v==v) || (new_u==v && new_v==u)){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                ds.unionByRank(requests[i][0],requests[i][1]);\\n                ans[i]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int size=requests.size();\\n        DisjointSet ds(n);\\n        vector<bool> ans(size,false);\\n        for(int i=0;i<size;i++){\\n            int u=ds.findUPar(requests[i][0]);\\n            int v=ds.findUPar(requests[i][1]);\\n            bool flag=true;\\n            for(int j=0;j<restrictions.size();j++){\\n                int new_u=ds.findUPar(restrictions[j][0]);\\n                int new_v=ds.findUPar(restrictions[j][1]);\\n                if((new_u==u && new_v==v) || (new_u==v && new_v==u)){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                ds.unionByRank(requests[i][0],requests[i][1]);\\n                ans[i]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485588,
                "title": "c-easy-solution-disjoint-set-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int size=requests.size();\\n        DisjointSet ds(n);\\n        vector<bool> ans(size,false);\\n        for(int i=0;i<size;i++){\\n            int u=ds.findUPar(requests[i][0]);\\n            int v=ds.findUPar(requests[i][1]);\\n            bool flag=true;\\n            for(int j=0;j<restrictions.size();j++){\\n                int new_u=ds.findUPar(restrictions[j][0]);\\n                int new_v=ds.findUPar(restrictions[j][1]);\\n                if((new_u==u && new_v==v) || (new_u==v && new_v==u)){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                ds.unionByRank(requests[i][0],requests[i][1]);\\n                ans[i]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int size=requests.size();\\n        DisjointSet ds(n);\\n        vector<bool> ans(size,false);\\n        for(int i=0;i<size;i++){\\n            int u=ds.findUPar(requests[i][0]);\\n            int v=ds.findUPar(requests[i][1]);\\n            bool flag=true;\\n            for(int j=0;j<restrictions.size();j++){\\n                int new_u=ds.findUPar(restrictions[j][0]);\\n                int new_v=ds.findUPar(restrictions[j][1]);\\n                if((new_u==u && new_v==v) || (new_u==v && new_v==u)){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                ds.unionByRank(requests[i][0],requests[i][1]);\\n                ans[i]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485587,
                "title": "c-easy-solution-disjoint-set-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int size=requests.size();\\n        DisjointSet ds(n);\\n        vector<bool> ans(size,false);\\n        for(int i=0;i<size;i++){\\n            int u=ds.findUPar(requests[i][0]);\\n            int v=ds.findUPar(requests[i][1]);\\n            bool flag=true;\\n            for(int j=0;j<restrictions.size();j++){\\n                int new_u=ds.findUPar(restrictions[j][0]);\\n                int new_v=ds.findUPar(restrictions[j][1]);\\n                if((new_u==u && new_v==v) || (new_u==v && new_v==u)){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                ds.unionByRank(requests[i][0],requests[i][1]);\\n                ans[i]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int size=requests.size();\\n        DisjointSet ds(n);\\n        vector<bool> ans(size,false);\\n        for(int i=0;i<size;i++){\\n            int u=ds.findUPar(requests[i][0]);\\n            int v=ds.findUPar(requests[i][1]);\\n            bool flag=true;\\n            for(int j=0;j<restrictions.size();j++){\\n                int new_u=ds.findUPar(restrictions[j][0]);\\n                int new_v=ds.findUPar(restrictions[j][1]);\\n                if((new_u==u && new_v==v) || (new_u==v && new_v==u)){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                ds.unionByRank(requests[i][0],requests[i][1]);\\n                ans[i]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476063,
                "title": "clean-code-union-find-with-explanation",
                "content": "# Approach\\nWe can use disjoin set union to keep track of friendships.\\nWe maintain a map of restritions which is updated whenever we do union of two elements.\\nFor every friend request(a,b) we check the following:-\\n- If both persons belong to same group then the request is accepted\\n- If a is in blockList of b **OR** b is in blockList of a then friend request is not accepted\\n- Else, we perform union operation and update the blockedList as well\\n\\n# Complexity\\n- Time complexity: \\nIf we use UF with rank then, worst case would be O(requests * restrictions)\\n\\n- Space complexity:\\nO(requests+restrictions)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        DSU dsu = new DSU(n, restrictions);\\n        boolean[] ans = new boolean[requests.length];\\n        int i = 0;\\n        for(int req[]: requests) {\\n            if(!dsu.union(req[0], req[1])) {\\n                ans[i] = false;\\n            } else {\\n                ans[i] = true;\\n            }\\n            i++;\\n        } \\n        \\n        return ans;\\n    }\\n}\\n\\nclass DSU {\\n    int parent[];\\n    HashSet<Integer> noMap[];\\n    DSU(int n, int[][] restrictions) {\\n        parent = new int[n];\\n        noMap = new HashSet[n];\\n        for(int i=0;i<n;i++) {\\n            noMap[i] = new HashSet<>();\\n            parent[i] = i;\\n        }\\n\\n        for(int[] res: restrictions) {\\n            noMap[res[0]].add(res[1]);\\n            noMap[res[1]].add(res[0]);\\n        }\\n    }\\n    \\n    int findParent(int x) {\\n        while(x!=parent[x]) {\\n            x = parent[x];\\n            parent[x] = parent[parent[x]];\\n        }\\n        \\n        return x;\\n    }\\n    \\n    boolean union(int x, int y) {\\n        int px = findParent(x);\\n        int py = findParent(y);\\n        \\n        if(px==py) {\\n            return true;\\n        }\\n        if (noMap[px].contains(py) || noMap[py].contains(px)) {\\n            return false;\\n        }\\n\\n        parent[py] = px;\\n        \\n        // update no map => all py\\'s restrictions will be added to px as well\\n        for(int child: noMap[py]) {\\n            noMap[px].add(findParent(child));\\n        }\\n\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        DSU dsu = new DSU(n, restrictions);\\n        boolean[] ans = new boolean[requests.length];\\n        int i = 0;\\n        for(int req[]: requests) {\\n            if(!dsu.union(req[0], req[1])) {\\n                ans[i] = false;\\n            } else {\\n                ans[i] = true;\\n            }\\n            i++;\\n        } \\n        \\n        return ans;\\n    }\\n}\\n\\nclass DSU {\\n    int parent[];\\n    HashSet<Integer> noMap[];\\n    DSU(int n, int[][] restrictions) {\\n        parent = new int[n];\\n        noMap = new HashSet[n];\\n        for(int i=0;i<n;i++) {\\n            noMap[i] = new HashSet<>();\\n            parent[i] = i;\\n        }\\n\\n        for(int[] res: restrictions) {\\n            noMap[res[0]].add(res[1]);\\n            noMap[res[1]].add(res[0]);\\n        }\\n    }\\n    \\n    int findParent(int x) {\\n        while(x!=parent[x]) {\\n            x = parent[x];\\n            parent[x] = parent[parent[x]];\\n        }\\n        \\n        return x;\\n    }\\n    \\n    boolean union(int x, int y) {\\n        int px = findParent(x);\\n        int py = findParent(y);\\n        \\n        if(px==py) {\\n            return true;\\n        }\\n        if (noMap[px].contains(py) || noMap[py].contains(px)) {\\n            return false;\\n        }\\n\\n        parent[py] = px;\\n        \\n        // update no map => all py\\'s restrictions will be added to px as well\\n        for(int child: noMap[py]) {\\n            noMap[px].add(findParent(child));\\n        }\\n\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469869,
                "title": "intuitive-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find_set(int v , vector<int> &parent) {\\n        if (v == parent[v])\\n            return v;\\n        return parent[v] = find_set(parent[v] , parent);\\n    }\\n    void make_set(int v , vector<int> &parent  , vector<int> &rank) {\\n        parent[v] = v;\\n        rank[v] = 0;\\n    }\\n\\n    void union_sets(int a, int b , vector<int> &parent , vector<int> &rank) {\\n        a = find_set(a , parent);\\n        b = find_set(b , parent);\\n        if (a != b) {\\n            if (rank[a] < rank[b]){\\n                parent[b] = a;\\n            }\\n            else if(rank[a] > rank[b]){\\n                parent[a] = b;\\n            }\\n            if (rank[a] == rank[b]){\\n                parent[b] = a;\\n                rank[a]++;\\n            }\\n        }\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& req) {\\n        vector<int> par(n+2);\\n        vector<int> rank(n+2);\\n        vector<bool> ans(req.size() , 0);\\n\\n\\n        for(int i = 1 ; i <= n ; i++){\\n            make_set(i , par , rank);\\n        }\\n\\n        for(int it = 0 ; it < req.size() ; it++){\\n            \\n            vector<int> copypar = par;\\n            vector<int> copyrank = rank;\\n\\n            union_sets(req[it][0] , req[it][1] , par , rank);\\n            bool ok = true;\\n            for(auto i : res){\\n\\n                int a = find_set(i[0], par);\\n                int b = find_set(i[1] , par);\\n\\n                if(a == b){\\n                    ok = false;\\n                    break;\\n                }\\n\\n            }\\n\\n            if(!ok){\\n                par = copypar;\\n                rank = copyrank;\\n            }\\n            else{\\n                ans[it] = 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_set(int v , vector<int> &parent) {\\n        if (v == parent[v])\\n            return v;\\n        return parent[v] = find_set(parent[v] , parent);\\n    }\\n    void make_set(int v , vector<int> &parent  , vector<int> &rank) {\\n        parent[v] = v;\\n        rank[v] = 0;\\n    }\\n\\n    void union_sets(int a, int b , vector<int> &parent , vector<int> &rank) {\\n        a = find_set(a , parent);\\n        b = find_set(b , parent);\\n        if (a != b) {\\n            if (rank[a] < rank[b]){\\n                parent[b] = a;\\n            }\\n            else if(rank[a] > rank[b]){\\n                parent[a] = b;\\n            }\\n            if (rank[a] == rank[b]){\\n                parent[b] = a;\\n                rank[a]++;\\n            }\\n        }\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& req) {\\n        vector<int> par(n+2);\\n        vector<int> rank(n+2);\\n        vector<bool> ans(req.size() , 0);\\n\\n\\n        for(int i = 1 ; i <= n ; i++){\\n            make_set(i , par , rank);\\n        }\\n\\n        for(int it = 0 ; it < req.size() ; it++){\\n            \\n            vector<int> copypar = par;\\n            vector<int> copyrank = rank;\\n\\n            union_sets(req[it][0] , req[it][1] , par , rank);\\n            bool ok = true;\\n            for(auto i : res){\\n\\n                int a = find_set(i[0], par);\\n                int b = find_set(i[1] , par);\\n\\n                if(a == b){\\n                    ok = false;\\n                    break;\\n                }\\n\\n            }\\n\\n            if(!ok){\\n                par = copypar;\\n                rank = copyrank;\\n            }\\n            else{\\n                ans[it] = 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396322,
                "title": "easy-c-dsu-solution",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    class DSU{\\n        public:\\n            vector<int> parent,size;\\n            DSU(int n){\\n                parent.resize(n);\\n                size.resize(n);\\n                for(int i=0;i<n;i++){\\n                    parent[i]=i;\\n                    size[i]=1;\\n                }\\n            }\\n\\n            int findParent(int u){\\n                if(u==parent[u]) return u;\\n                else return parent[u]=findParent(parent[u]);\\n            }\\n\\n            void Union(int u, int v){\\n                int par_u = findParent(u);\\n                int par_v = findParent(v);\\n                if(par_u==par_v) return;\\n                if(size[par_u]<size[par_v]){\\n                    size[par_v]+=size[par_u];\\n                    parent[par_u]=par_v;\\n                }else{\\n                    size[par_u]+=size[par_v];\\n                    parent[par_v]=par_u;\\n                }\\n            }\\n            \\n            bool check(int &u, int &v, vector<vector<int>>& restrictions){\\n                int par_u = findParent(u);\\n                int par_v = findParent(v);\\n                for(auto &res:restrictions){\\n                    int res_par_u = findParent(res[0]);\\n                    int res_par_v = findParent(res[1]);\\n                    if(par_u==res_par_u and par_v==res_par_v) return false;\\n                    else if(par_u==res_par_v and par_v==res_par_u) return false;\\n                }\\n                Union(u,v);\\n                return true;\\n            }\\n    };\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU dsu(n);\\n        int m = requests.size();\\n        vector<bool> ans(m);\\n        for(int i=0;i<m;i++){\\n            int u = requests[i][0];\\n            int v = requests[i][1];\\n            ans[i] = dsu.check(u,v,restrictions);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    class DSU{\\n        public:\\n            vector<int> parent,size;\\n            DSU(int n){\\n                parent.resize(n);\\n                size.resize(n);\\n                for(int i=0;i<n;i++){\\n                    parent[i]=i;\\n                    size[i]=1;\\n                }\\n            }\\n\\n            int findParent(int u){\\n                if(u==parent[u]) return u;\\n                else return parent[u]=findParent(parent[u]);\\n            }\\n\\n            void Union(int u, int v){\\n                int par_u = findParent(u);\\n                int par_v = findParent(v);\\n                if(par_u==par_v) return;\\n                if(size[par_u]<size[par_v]){\\n                    size[par_v]+=size[par_u];\\n                    parent[par_u]=par_v;\\n                }else{\\n                    size[par_u]+=size[par_v];\\n                    parent[par_v]=par_u;\\n                }\\n            }\\n            \\n            bool check(int &u, int &v, vector<vector<int>>& restrictions){\\n                int par_u = findParent(u);\\n                int par_v = findParent(v);\\n                for(auto &res:restrictions){\\n                    int res_par_u = findParent(res[0]);\\n                    int res_par_v = findParent(res[1]);\\n                    if(par_u==res_par_u and par_v==res_par_v) return false;\\n                    else if(par_u==res_par_v and par_v==res_par_u) return false;\\n                }\\n                Union(u,v);\\n                return true;\\n            }\\n    };\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU dsu(n);\\n        int m = requests.size();\\n        vector<bool> ans(m);\\n        for(int i=0;i<m;i++){\\n            int u = requests[i][0];\\n            int v = requests[i][1];\\n            ans[i] = dsu.check(u,v,restrictions);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337242,
                "title": "c-union-find",
                "content": "```\\n\\nclass DisjointSet \\n{\\n    vector<int> rank, parent, size; \\npublic: \\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n}; \\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DisjointSet ds(n);\\n        vector<bool>ans;\\n        for(auto it:requests)\\n        {\\n            int u=ds.findUPar(it[0]);\\n            int v=ds.findUPar(it[1]);\\n            int flag=0;\\n            for(auto itr:restrictions)\\n            {\\n                int u1=ds.findUPar(itr[0]);\\n                int v1=ds.findUPar(itr[1]);\\n                if((u==u1 and v==v1) or(u==v1 and v==u1)){\\n                    flag=1;\\n                    ans.push_back(false);\\n                    break;\\n                }\\n                \\n            }\\n            if(flag==0){\\n                ans.push_back(true);\\n                ds.unionBySize(u,v);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\n\\nclass DisjointSet \\n{\\n    vector<int> rank, parent, size; \\npublic: \\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n}; \\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DisjointSet ds(n);\\n        vector<bool>ans;\\n        for(auto it:requests)\\n        {\\n            int u=ds.findUPar(it[0]);\\n            int v=ds.findUPar(it[1]);\\n            int flag=0;\\n            for(auto itr:restrictions)\\n            {\\n                int u1=ds.findUPar(itr[0]);\\n                int v1=ds.findUPar(itr[1]);\\n                if((u==u1 and v==v1) or(u==v1 and v==u1)){\\n                    flag=1;\\n                    ans.push_back(false);\\n                    break;\\n                }\\n                \\n            }\\n            if(flag==0){\\n                ans.push_back(true);\\n                ds.unionBySize(u,v);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335578,
                "title": "c-unionfind",
                "content": "```\\npublic class Solution {\\n    \\n    \\n    public bool[] FriendRequests(int n, int[][] restrictions, int[][] requests) {\\n        UF uf=new UF(n);\\n        bool[] res=new bool[requests.Length];\\n        \\n        foreach(int[] r in restrictions)\\n            uf.addRestriction(r[0],r[1]);\\n        \\n        for(int i=0;i<requests.Length;i++)\\n        {\\n            res[i]=uf.union(requests[i][0],requests[i][1]);\\n            \\n        }\\n            \\n            \\n        return res;\\n    }\\n}\\n\\n\\n\\npublic class UF{\\n    int[] parent ;\\n    HashSet<int>[] ds;\\n    HashSet<int>[] members;\\n\\n    public UF(int size){\\n        parent=Enumerable.Range(0,size).ToArray();\\n        ds=Enumerable.Range(0,size).Select(x=>new HashSet<int>()).ToArray();\\n        members=Enumerable.Range(0,size).Select(x=>new HashSet<int>(new int[1]{x})).ToArray();\\n        \\n    }\\n    \\n    public int find(int node){\\n        if(parent[node]!=node)\\n            parent[node]=find(parent[node]);\\n        \\n        return parent[node];\\n    }\\n    \\n    \\n    public bool union(int i,int j){\\n        int pi=find(i);\\n        int pj=find(j);\\n        \\n        if(pi==pj)\\n            return true;\\n        \\n        if(ds[pi].Overlaps(members[pj]))\\n            return false;\\n        \\n        if(ds[pj].Overlaps(members[pi]))\\n            return false;\\n\\n        \\n        //Print(pi,ds[pi]);\\n        //Print(pj,ds[pj]);\\n        \\n        parent[pj]=pi;\\n        ds[pi].UnionWith(ds[pj]);\\n        members[pi].UnionWith(members[pj]);\\n        return true;\\n        \\n    }\\n    \\n    public void addRestriction(int i,int j)\\n    {\\n        ds[i].Add(j);\\n        ds[j].Add(i);\\n    }\\n    \\n    public void Print(int pi, HashSet<int> hs)\\n    {\\n        Console.WriteLine($\"pi={pi}  \");\\n        \\n        foreach(int i in hs)\\n            Console.WriteLine($\"{i}  \");\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    \\n    \\n    public bool[] FriendRequests(int n, int[][] restrictions, int[][] requests) {\\n        UF uf=new UF(n);\\n        bool[] res=new bool[requests.Length];\\n        \\n        foreach(int[] r in restrictions)\\n            uf.addRestriction(r[0],r[1]);\\n        \\n        for(int i=0;i<requests.Length;i++)\\n        {\\n            res[i]=uf.union(requests[i][0],requests[i][1]);\\n            \\n        }\\n            \\n            \\n        return res;\\n    }\\n}\\n\\n\\n\\npublic class UF{\\n    int[] parent ;\\n    HashSet<int>[] ds;\\n    HashSet<int>[] members;\\n\\n    public UF(int size){\\n        parent=Enumerable.Range(0,size).ToArray();\\n        ds=Enumerable.Range(0,size).Select(x=>new HashSet<int>()).ToArray();\\n        members=Enumerable.Range(0,size).Select(x=>new HashSet<int>(new int[1]{x})).ToArray();\\n        \\n    }\\n    \\n    public int find(int node){\\n        if(parent[node]!=node)\\n            parent[node]=find(parent[node]);\\n        \\n        return parent[node];\\n    }\\n    \\n    \\n    public bool union(int i,int j){\\n        int pi=find(i);\\n        int pj=find(j);\\n        \\n        if(pi==pj)\\n            return true;\\n        \\n        if(ds[pi].Overlaps(members[pj]))\\n            return false;\\n        \\n        if(ds[pj].Overlaps(members[pi]))\\n            return false;\\n\\n        \\n        //Print(pi,ds[pi]);\\n        //Print(pj,ds[pj]);\\n        \\n        parent[pj]=pi;\\n        ds[pi].UnionWith(ds[pj]);\\n        members[pi].UnionWith(members[pj]);\\n        return true;\\n        \\n    }\\n    \\n    public void addRestriction(int i,int j)\\n    {\\n        ds[i].Add(j);\\n        ds[j].Add(i);\\n    }\\n    \\n    public void Print(int pi, HashSet<int> hs)\\n    {\\n        Console.WriteLine($\"pi={pi}  \");\\n        \\n        foreach(int i in hs)\\n            Console.WriteLine($\"{i}  \");\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287788,
                "title": "through-dsu-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first idea is to make a list of restricted friends and then to make friends we will make the graph. Now as the graph has to change in each iterations of the friend requests we have to apply the DSU so that we can easily find which can we make friends and which we cannot.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have used the concept of DSU, so there will be one main friend to which all other will connected and while making the main node/friend we will add all the restricted friend of main node in child node and all of child node to main node so that we can easily check which people can become friends and which cannot.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ultimateparent(vector<int>& parent,int n){\\n        if(parent[n]==n){\\n            return n;\\n        }\\n        return parent[n]=ultimateparent(parent,parent[n]);\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n\\n        map<int,set<int>> mymap;\\n        for(int i=0;i<restrictions.size();i++){\\n            mymap[restrictions[i][0]].insert(restrictions[i][1]);\\n            mymap[restrictions[i][1]].insert(restrictions[i][0]);\\n        }\\n\\n        vector<int> parent(n);\\n        vector<long long>size(n,1);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n\\n        vector<bool> ans(requests.size(),false);\\n        for(int i=0;i<requests.size();i++){\\n            set<int> temp = mymap[ultimateparent(parent,requests[i][0])];\\n            if(temp.find(ultimateparent(parent,requests[i][1]))!=temp.end()){\\n                continue;\\n            }\\n            else{\\n                int par1 = ultimateparent(parent,requests[i][0]);\\n                int par2 = ultimateparent(parent,requests[i][1]);\\n                if(size[par1]>size[par2]){\\n                    for(auto it=mymap[par2].begin();it!=mymap[par2].end();it++){\\n                        mymap[par1].insert(*it);\\n                        mymap[*it].insert(par1);\\n                    }\\n                    size[par1]+=size[par2];\\n                    parent[par2]=par1;\\n                }\\n                else{\\n                    for(auto it=mymap[par1].begin();it!=mymap[par1].end();it++){\\n                        mymap[par2].insert(*it);\\n                        mymap[*it].insert(par2);\\n                    }\\n                    size[par2]+=size[par1];\\n                    parent[par1]=par2;\\n                }\\n                ans[i]=true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ultimateparent(vector<int>& parent,int n){\\n        if(parent[n]==n){\\n            return n;\\n        }\\n        return parent[n]=ultimateparent(parent,parent[n]);\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n\\n        map<int,set<int>> mymap;\\n        for(int i=0;i<restrictions.size();i++){\\n            mymap[restrictions[i][0]].insert(restrictions[i][1]);\\n            mymap[restrictions[i][1]].insert(restrictions[i][0]);\\n        }\\n\\n        vector<int> parent(n);\\n        vector<long long>size(n,1);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n\\n        vector<bool> ans(requests.size(),false);\\n        for(int i=0;i<requests.size();i++){\\n            set<int> temp = mymap[ultimateparent(parent,requests[i][0])];\\n            if(temp.find(ultimateparent(parent,requests[i][1]))!=temp.end()){\\n                continue;\\n            }\\n            else{\\n                int par1 = ultimateparent(parent,requests[i][0]);\\n                int par2 = ultimateparent(parent,requests[i][1]);\\n                if(size[par1]>size[par2]){\\n                    for(auto it=mymap[par2].begin();it!=mymap[par2].end();it++){\\n                        mymap[par1].insert(*it);\\n                        mymap[*it].insert(par1);\\n                    }\\n                    size[par1]+=size[par2];\\n                    parent[par2]=par1;\\n                }\\n                else{\\n                    for(auto it=mymap[par1].begin();it!=mymap[par1].end();it++){\\n                        mymap[par2].insert(*it);\\n                        mymap[*it].insert(par2);\\n                    }\\n                    size[par2]+=size[par1];\\n                    parent[par1]=par2;\\n                }\\n                ans[i]=true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192846,
                "title": "easy-java-code-union-and-find",
                "content": "class Solution {\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n                boolean[] result = new boolean[requests.length];\\n\\n        if(restrictions==null || requests == null || requests[0].length==0)\\n        return result;\\n        DisjointSet ds = new DisjointSet(n);\\n        int index=0;\\n        boolean friends=false;\\n        for(int[] request : requests)\\n        {   friends=true;\\n            //find the representative of the friend 0\\n            int rep_0 = ds.find(request[0]);\\n              //find the representative of the friend 1\\n            int rep_1 = ds.find(request[1]);\\n\\n            //Now check if these representatives are enimies or not\\n\\n            for(int[] restriction : restrictions)\\n            {   int up1 = ds.find(restriction[0]);\\n                int up2 = ds.find(restriction[1]);\\n                if((rep_0 == up1 && rep_1 == up2) || (rep_0 == up2 &&rep_1 == up1) )\\n                {\\n                    friends=false;\\n                    //If they are inirect or direct enimies ,break\\n                    break;\\n                }\\n                \\n               \\n            }\\n            if(!friends)\\n            {\\n                 \\n                result[index++]=false;\\n\\n            }\\n            else\\n            {\\n                \\n                    result[index++]=true;\\n                    ds.union(request[0],request[1]);\\n            }\\n\\n\\n\\n        }\\n        return result;\\n    }\\n}\\n\\nclass DisjointSet\\n    {\\n         int length;\\n         int[] parent;\\n         int[] size;\\n\\n        public DisjointSet(int length)\\n        {\\n                this.length = length;\\n                parent = new int[length];\\n                size  = new int[length];\\n                for(int i =0 ; i < length;i++)\\n                {\\n                    parent[i]=i;\\n                    size[i]=1;\\n                }\\n        }\\n    \\n\\n    public int find(int cell)\\n    {\\n          if(parent[cell]==cell)\\n          return cell;\\n          parent[cell]=find(parent[cell]);\\n          return parent[cell];\\n    }\\n\\n    public void union(int cell1,int cell2)\\n    {\\n         int repa = find(cell1);\\n         int repb = find(cell2);\\n\\n         if(repa ==  repb)\\n         return ;\\n         if(size[repa] < size[repb])\\n         {\\n                parent[repa] = repb;\\n                size[repb] =+ size[repa];\\n         }\\n         else\\n         {\\n                parent[repb] = repa;\\n                size[repa] =+ size[repb];\\n         }\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n                boolean[] result = new boolean[requests.length];\\n\\n        if(restrictions==null || requests == null || requests[0].length==0)\\n        return result;\\n        DisjointSet ds = new DisjointSet(n);\\n        int index=0;\\n        boolean friends=false;\\n        for(int[] request : requests)\\n        {   friends=true;\\n            //find the representative of the friend 0\\n            int rep_0 = ds.find(request[0]);\\n              //find the representative of the friend 1\\n            int rep_1 = ds.find(request[1]);\\n\\n            //Now check if these representatives are enimies or not\\n\\n            for(int[] restriction : restrictions)\\n            {   int up1 = ds.find(restriction[0]);\\n                int up2 = ds.find(restriction[1]);\\n                if((rep_0 == up1 && rep_1 == up2) || (rep_0 == up2 &&rep_1 == up1) )\\n                {\\n                    friends=false;\\n                    //If they are inirect or direct enimies ,break\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3179045,
                "title": "c-soln-using-dsu",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rank[1001];\\n    int parent[1001];\\n\\n    void dsu(int n){\\n        for(int i=0;i<n;i++){\\n            rank[i] = 0;\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findParent(int x){\\n        if(parent[x] == x)\\n            return x;\\n        return parent[x] = findParent(parent[x]);\\n    }\\n\\n    void Union(int u, int v){\\n        int paru = findParent(u);\\n        int parv = findParent(v);\\n\\n        if(paru == parv)\\n            return;\\n        \\n        int ranku = rank[paru];\\n        int rankv = rank[parv];\\n\\n        if(ranku > rankv){\\n            parent[parv] = paru;\\n        }\\n        else if (rankv > ranku){\\n            parent[paru] = parv;\\n        }\\n        else{\\n            parent[paru] = parv;\\n            rank[parv]++;\\n        }\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        dsu(n);\\n        vector<bool>res(requests.size());\\n        for(int i=0;i<requests.size();i++){\\n            int a = requests[i][0];\\n            int b = requests[i][1];\\n\\n            int para = findParent(a);\\n            int parb = findParent(b);\\n            int flag = 0;\\n\\n            for(int j=0;j<restrictions.size();j++){\\n                int tmp1 = findParent(restrictions[j][0]);\\n                int tmp2 = findParent(restrictions[j][1]);\\n\\n                if((para == tmp1 && parb == tmp2) || (para == tmp2 && parb == tmp1)){\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n\\n            if(flag == 0){\\n                res[i] = true;\\n                Union(a, b);    \\n            }\\n            else\\n                res[i] = false;\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rank[1001];\\n    int parent[1001];\\n\\n    void dsu(int n){\\n        for(int i=0;i<n;i++){\\n            rank[i] = 0;\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findParent(int x){\\n        if(parent[x] == x)\\n            return x;\\n        return parent[x] = findParent(parent[x]);\\n    }\\n\\n    void Union(int u, int v){\\n        int paru = findParent(u);\\n        int parv = findParent(v);\\n\\n        if(paru == parv)\\n            return;\\n        \\n        int ranku = rank[paru];\\n        int rankv = rank[parv];\\n\\n        if(ranku > rankv){\\n            parent[parv] = paru;\\n        }\\n        else if (rankv > ranku){\\n            parent[paru] = parv;\\n        }\\n        else{\\n            parent[paru] = parv;\\n            rank[parv]++;\\n        }\\n    }\\n\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        dsu(n);\\n        vector<bool>res(requests.size());\\n        for(int i=0;i<requests.size();i++){\\n            int a = requests[i][0];\\n            int b = requests[i][1];\\n\\n            int para = findParent(a);\\n            int parb = findParent(b);\\n            int flag = 0;\\n\\n            for(int j=0;j<restrictions.size();j++){\\n                int tmp1 = findParent(restrictions[j][0]);\\n                int tmp2 = findParent(restrictions[j][1]);\\n\\n                if((para == tmp1 && parb == tmp2) || (para == tmp2 && parb == tmp1)){\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n\\n            if(flag == 0){\\n                res[i] = true;\\n                Union(a, b);    \\n            }\\n            else\\n                res[i] = false;\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163172,
                "title": "c-fast-solution-union-find",
                "content": "# Intuition\\nUNION FIND:\\nFor every requests make an edge between the nodes. Then check for each restrictions(by checking the parent of both nodes). If parent of both nodes are same for any restriction, then it is not possible for this request to happen.\\n\\n# Approach\\nFor every requests make an edge between the nodes. Then check for each restrictions(by checking the parent of both nodes). If parent of both nodes are same for any restriction, then it is not possible for this request to happen.\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int>parent;\\nvector<int>rank;\\n\\nint find(int a) {\\n\\tif (parent[a] == -1) return a;\\n\\treturn parent[a] = find(parent[a]);\\n}\\n\\nvoid union_set(int a, int b) {\\n\\tint s1 = find(a), s2 = find(b);\\n\\tif (s1 != s2) {\\n\\t\\tif (rank[s1] > rank[s2]) {\\n\\t\\t\\tparent[s2] = s1;\\n\\t\\t\\trank[s1] += rank[s2];\\n\\t\\t} else {\\n\\t\\t\\tparent[s1] = s2;\\n\\t\\t\\trank[s2] += rank[s1];\\n\\t\\t}\\n\\t}\\n}\\n\\nvector<bool> friendRequests(int n, vector<vector<int>>& restrictions,\\n                            vector<vector<int>>& requests) {\\n\\tvector<bool>res;\\n\\tint len1 = restrictions.size(), len2 = requests.size();\\n\\tparent.resize(n, -1); rank.resize(n, 1);\\n\\tfor (int i = 0; i < len2; ++i)\\n\\t{\\n\\t\\tvector<int>dummy = parent;\\n\\t\\tunion_set(requests[i][0], requests[i][1]);\\n\\t\\tbool ans = true;\\n\\t\\tfor (int j = 0; j < len1; ++j)\\n\\t\\t{\\n\\t\\t\\tint s1 = find(restrictions[j][0]), s2 = find(restrictions[j][1]);\\n\\t\\t\\tif (s1 == s2) {\\n\\t\\t\\t\\tans = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (ans) res.push_back(true);\\n\\t\\telse {\\n\\t\\t\\tres.push_back(false);\\n\\t\\t\\tparent = dummy;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int>parent;\\nvector<int>rank;\\n\\nint find(int a) {\\n\\tif (parent[a] == -1) return a;\\n\\treturn parent[a] = find(parent[a]);\\n}\\n\\nvoid union_set(int a, int b) {\\n\\tint s1 = find(a), s2 = find(b);\\n\\tif (s1 != s2) {\\n\\t\\tif (rank[s1] > rank[s2]) {\\n\\t\\t\\tparent[s2] = s1;\\n\\t\\t\\trank[s1] += rank[s2];\\n\\t\\t} else {\\n\\t\\t\\tparent[s1] = s2;\\n\\t\\t\\trank[s2] += rank[s1];\\n\\t\\t}\\n\\t}\\n}\\n\\nvector<bool> friendRequests(int n, vector<vector<int>>& restrictions,\\n                            vector<vector<int>>& requests) {\\n\\tvector<bool>res;\\n\\tint len1 = restrictions.size(), len2 = requests.size();\\n\\tparent.resize(n, -1); rank.resize(n, 1);\\n\\tfor (int i = 0; i < len2; ++i)\\n\\t{\\n\\t\\tvector<int>dummy = parent;\\n\\t\\tunion_set(requests[i][0], requests[i][1]);\\n\\t\\tbool ans = true;\\n\\t\\tfor (int j = 0; j < len1; ++j)\\n\\t\\t{\\n\\t\\t\\tint s1 = find(restrictions[j][0]), s2 = find(restrictions[j][1]);\\n\\t\\t\\tif (s1 == s2) {\\n\\t\\t\\t\\tans = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (ans) res.push_back(true);\\n\\t\\telse {\\n\\t\\t\\tres.push_back(false);\\n\\t\\t\\tparent = dummy;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137911,
                "title": "c-dsu",
                "content": "```\\nclass Solution {\\npublic:\\n     int par[10000] ; \\n    int size[10000] ;\\n    void make(int v )\\n    {\\n    par[v]=v ;  \\n        size[v]=1  ;\\n    }\\n    \\n    int find(int v )\\n    {\\n        if(par[v]==v)\\n            return v ; \\n        return par[v]  = find(par[v]) ; \\n    }\\n    \\n    void Union(int u , int w )\\n    {\\n       int a  = find(u) ; \\n        int b = find(w)  ; \\n         if(a!=b)\\n         {\\n             \\n             if(size[a]<size[b])\\n             {\\n                 swap(a, b) ; \\n             }\\n             par[b] =a ; \\n             size[a]+=size[b]  ;\\n         }\\n \\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& req) {\\n       vector<bool> ans ;\\n        \\n        for(int i = 0; i<n; i++ )\\n        {\\n            make(i) ; \\n        }\\n        for(auto it : req )\\n        {\\n            int a = find(it[0]); \\n            int b = find(it[1]) ;\\n            int f=1 ;\\n            for(auto itr : res)\\n            {\\n                int ap = find(itr[0]) ;\\n                int bp = find(itr[1]) ;\\n                \\n                if(ap==a && bp==b || ap==b && bp==a)\\n                {\\n                    f=0;\\n                    break ;\\n                }\\n            }\\n            if(f)\\n                Union(a, b ) ;\\n            ans.push_back(f) ;\\n            \\n        }\\n        return ans; \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int par[10000] ; \\n    int size[10000] ;\\n    void make(int v )\\n    {\\n    par[v]=v ;  \\n        size[v]=1  ;\\n    }\\n    \\n    int find(int v )\\n    {\\n        if(par[v]==v)\\n            return v ; \\n        return par[v]  = find(par[v]) ; \\n    }\\n    \\n    void Union(int u , int w )\\n    {\\n       int a  = find(u) ; \\n        int b = find(w)  ; \\n         if(a!=b)\\n         {\\n             \\n             if(size[a]<size[b])\\n             {\\n                 swap(a, b) ; \\n             }\\n             par[b] =a ; \\n             size[a]+=size[b]  ;\\n         }\\n \\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& req) {\\n       vector<bool> ans ;\\n        \\n        for(int i = 0; i<n; i++ )\\n        {\\n            make(i) ; \\n        }\\n        for(auto it : req )\\n        {\\n            int a = find(it[0]); \\n            int b = find(it[1]) ;\\n            int f=1 ;\\n            for(auto itr : res)\\n            {\\n                int ap = find(itr[0]) ;\\n                int bp = find(itr[1]) ;\\n                \\n                if(ap==a && bp==b || ap==b && bp==a)\\n                {\\n                    f=0;\\n                    break ;\\n                }\\n            }\\n            if(f)\\n                Union(a, b ) ;\\n            ans.push_back(f) ;\\n            \\n        }\\n        return ans; \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070582,
                "title": "java-solution-beats-100-beginner-friendly-explanation",
                "content": "Intuition:  \\n (First Thought): \\n Let\\'s create a graph of the restricitons and use either bfs or dfs for each possible friend request to validate said request. \\n This would be slow, we would have to create the graph and then traverse it k (number of edges in graph) * n (number of requests) times. \\n Second Approach: \\n Have each individual represet their own set. Maintain a set of there restrictions and a set of their friends. Initially create the set of restrictions, they will be two way so if 0,1 is a restriction then zero should be in 1\\'s restricted set and vice versa. Next we can essentially create a graph of friends by using a union operation. If the union is possible (meaning the one individuals current set of friends does not contain individuals in the requested person\\'s restricted list), then the request is possible. \\n Process: \\n To achieve the union process, we use a find function which returns the head of the set the input individual belongs to. We could use a map for this or we can use an array where the index of the array represents a person (their integer value) and the value at the index represents the location of that individuals head. \\n Once we have the head of both sets we are trying to combine, we loop through the smaller of the two, checking if any of its members are restricted from the larger set. If they are, the union is impossible. If they are not, we union the smaller to the larger and change the location of the smaller set to the larger one. We do this for each request. \\n \\nTakeaway: \\nWe can use union-find algorithim to create a graph based on a given parameter, or ensure to sets can be combined based on that parameter\\n  \\n  Code Below:\\n ``` \\n class Solution { \\n    Set<Integer>[] rSet;  \\n    Set<Integer>[] fSet; \\n    int[] location;\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        rSet = new Set[n];  \\n        fSet = new Set[n];\\n        location = new int[n]; \\n        boolean[] ans = new boolean[requests.length]; \\n        \\n        for(int i = 0; i<n; i++) { \\n            location[i] = i; \\n            rSet[i] = new HashSet<>();  \\n            fSet[i] = new HashSet<>(); \\n            fSet[i].add(i); \\n            \\n        }   \\n        \\n        for(int[] restriction: restrictions) { \\n            int a = restriction[0];\\n            int b = restriction[1]; \\n            rSet[a].add(b); \\n            rSet[b].add(a);\\n        }  \\n         \\n        for(int i = 0; i<requests.length; i++) {  \\n            int a = requests[i][0] ;\\n            int b = requests[i][1];\\n            ans[i] = union(a,b);\\n        } \\n        \\n        return ans;\\n    } \\n    public boolean union(Integer f1, Integer f2) { \\n        int f1Head = find(f1); \\n        int f2Head = find(f2); \\n        if(f1Head == f2Head) return true; \\n         \\n        int u1, u2; \\n        Set<Integer> f1Friends = fSet[f1Head]; \\n        Set<Integer> f2Friends = fSet[f2Head];\\n        if(f1Friends.size()>f2Friends.size()) { \\n            u1 = f1Head; \\n            u2 = f2Head;\\n        } \\n        else { \\n            u1 = f2Head; \\n            u2 = f1Head;\\n        } \\n        for(Integer friend : fSet[u2]) { \\n            if(rSet[u1].contains(friend)) return false;\\n        } \\n        \\n        fSet[u1].addAll(fSet[u2]); \\n        rSet[u1].addAll(rSet[u2]);  \\n        location[u2] = u1;\\n        \\n        fSet[u2] = null; \\n        rSet[u2] = null; \\n        return true;\\n    } \\n    public int find(int head) { \\n        return location[head] == head ? head : (location[head] = find(location[head]));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "class Solution { \\n    Set<Integer>[] rSet;  \\n    Set<Integer>[] fSet; \\n    int[] location;\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        rSet = new Set[n];  \\n        fSet = new Set[n];\\n        location = new int[n]; \\n        boolean[] ans = new boolean[requests.length]; \\n        \\n        for(int i = 0; i<n; i++) { \\n            location[i] = i; \\n            rSet[i] = new HashSet<>();  \\n            fSet[i] = new HashSet<>(); \\n            fSet[i].add(i); \\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3055173,
                "title": "golang-union-find",
                "content": "# Code\\n```\\nfunc unionSet(u, v int, parent []int) {\\n    var parentU int = find(u, parent)\\n    var parentV int = find(v, parent)\\n    if parentU <= parentV {\\n        parent[parentV] = parent[u]\\n    } else {\\n        parent[parentU] = parent[v]\\n    }  \\n}\\nfunc find(u int, parent []int) int {\\n    if parent[u] == u {\\n        return u\\n    }\\n    parent[u] = find(parent[u], parent)\\n    return parent[u]\\n}\\n\\nfunc friendRequests(n int, restrictions [][]int, requests [][]int) []bool {\\n    parent := make([]int, n)\\n    for i:= 0; i < len(parent); i++ {\\n        parent[i] = i\\n    }\\n    ans := []bool{}\\n    for _, request := range requests {\\n        var valid bool = true\\n        var x int = find(request[0], parent)\\n        var y int = find(request[1], parent)\\n        if x != y {\\n            for _, banned := range restrictions {\\n                var u int = find(banned[0], parent)\\n                var v int = find(banned[1], parent)\\n                if (u == x && v == y) || (u == y && v == x) {\\n                    valid = false\\n                    break\\n                } \\n            }\\n        }\\n        ans = append(ans, valid)\\n        if valid {\\n            unionSet(request[0],request[1], parent)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nfunc unionSet(u, v int, parent []int) {\\n    var parentU int = find(u, parent)\\n    var parentV int = find(v, parent)\\n    if parentU <= parentV {\\n        parent[parentV] = parent[u]\\n    } else {\\n        parent[parentU] = parent[v]\\n    }  \\n}\\nfunc find(u int, parent []int) int {\\n    if parent[u] == u {\\n        return u\\n    }\\n    parent[u] = find(parent[u], parent)\\n    return parent[u]\\n}\\n\\nfunc friendRequests(n int, restrictions [][]int, requests [][]int) []bool {\\n    parent := make([]int, n)\\n    for i:= 0; i < len(parent); i++ {\\n        parent[i] = i\\n    }\\n    ans := []bool{}\\n    for _, request := range requests {\\n        var valid bool = true\\n        var x int = find(request[0], parent)\\n        var y int = find(request[1], parent)\\n        if x != y {\\n            for _, banned := range restrictions {\\n                var u int = find(banned[0], parent)\\n                var v int = find(banned[1], parent)\\n                if (u == x && v == y) || (u == y && v == x) {\\n                    valid = false\\n                    break\\n                } \\n            }\\n        }\\n        ans = append(ans, valid)\\n        if valid {\\n            unionSet(request[0],request[1], parent)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055140,
                "title": "c-union-find",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    void unionSet(int u, int v, vector<int> &parent) {\\n        int parentU = find(u, parent);\\n        int parentV = find(v, parent);\\n        if(parentU == parentV) return;\\n        if(parentU <= parentV)\\n            parent[parentV] = parent[u];\\n        else\\n            parent[parentU] = parent[v];\\n    }\\n    int find(int u, vector<int> &parent) {\\n        if(parent[u] == u) return u;\\n        return parent[u] = find(parent[u], parent);\\n    }\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<int> parent(n);\\n        iota(parent.begin(), parent.end(), 0);\\n        vector<bool> ans;\\n        for(vector<int> request: requests) {\\n            bool valid = true;\\n            int x = find(request[0], parent);\\n            int y = find(request[1], parent);\\n            if(x != y) {\\n                for(vector<int> banned: restrictions) {\\n                    int u = find(banned[0], parent);\\n                    int v = find(banned[1], parent);\\n                    if((u == x && v == y) || (u == y && v == x)) {\\n                        valid = false;\\n                        break;\\n                    } \\n                }\\n            }\\n            ans.push_back(valid);\\n            if(valid)\\n                unionSet(request[0],request[1], parent);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void unionSet(int u, int v, vector<int> &parent) {\\n        int parentU = find(u, parent);\\n        int parentV = find(v, parent);\\n        if(parentU == parentV) return;\\n        if(parentU <= parentV)\\n            parent[parentV] = parent[u];\\n        else\\n            parent[parentU] = parent[v];\\n    }\\n    int find(int u, vector<int> &parent) {\\n        if(parent[u] == u) return u;\\n        return parent[u] = find(parent[u], parent);\\n    }\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<int> parent(n);\\n        iota(parent.begin(), parent.end(), 0);\\n        vector<bool> ans;\\n        for(vector<int> request: requests) {\\n            bool valid = true;\\n            int x = find(request[0], parent);\\n            int y = find(request[1], parent);\\n            if(x != y) {\\n                for(vector<int> banned: restrictions) {\\n                    int u = find(banned[0], parent);\\n                    int v = find(banned[1], parent);\\n                    if((u == x && v == y) || (u == y && v == x)) {\\n                        valid = false;\\n                        break;\\n                    } \\n                }\\n            }\\n            ans.push_back(valid);\\n            if(valid)\\n                unionSet(request[0],request[1], parent);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038936,
                "title": "python-union-find-solution",
                "content": "```\\ndef friendRequests(self, n: int, rs: List[List[int]], qs: List[List[int]]) -> List[bool]:\\n\\tuf, ans = list(range(n)), []\\n\\n\\tdef find(i):\\n\\t\\tif uf[i]!=i:\\n\\t\\t\\tuf[i] = find(uf[i])\\n\\t\\treturn uf[i]\\n\\n\\tfor i, j in qs:\\n\\t\\ti, j, good = find(i), find(j), True\\n\\t\\tfor x, y in rs:\\n\\t\\t\\tx, y = find(x), find(y)\\n\\t\\t\\tif sorted([i, j])==sorted([x, y]):\\n\\t\\t\\t\\tgood = False\\n\\t\\t\\t\\tbreak\\n\\t\\tif good:\\n\\t\\t\\tuf[j]=i\\n\\t\\tans.append(good)\\n\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef friendRequests(self, n: int, rs: List[List[int]], qs: List[List[int]]) -> List[bool]:\\n\\tuf, ans = list(range(n)), []\\n\\n\\tdef find(i):\\n\\t\\tif uf[i]!=i:\\n\\t\\t\\tuf[i] = find(uf[i])\\n\\t\\treturn uf[i]\\n\\n\\tfor i, j in qs:\\n\\t\\ti, j, good = find(i), find(j), True\\n\\t\\tfor x, y in rs:\\n\\t\\t\\tx, y = find(x), find(y)\\n\\t\\t\\tif sorted([i, j])==sorted([x, y]):\\n\\t\\t\\t\\tgood = False\\n\\t\\t\\t\\tbreak\\n\\t\\tif good:\\n\\t\\t\\tuf[j]=i\\n\\t\\tans.append(good)\\n\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3025801,
                "title": "java-o-requests-n-beats-100-of-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe friend network is an undirected graph, thus in a connected component all people are friends with each others as every node is reachable from every other node. \\n\\nWhen a request is accepted a new edge is added to the graph. If the request is within a connected component, it is immediately accepted as the two people are already friends. \\n\\nNote that the new edge creates a loop in the connected component, thus if we always discard these redundant edges we obtain a tree. This is useful for complexity as the number of edges is then n - 1, which means that we can optimally scan a connected component.\\n\\nThe only interesting case is then a new edge across connected component. This is equivalent to taking the union of the two trees. Thus, a union find datastructure can optimally merge connected components (the union of two trees is a tree).\\n\\nTo take into account for restrictions, we can just DFS either of the two connected components and check that each forbidden node is not in the other tree.\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo simplify, we don\\'t even need to store the edges of the trees resulting from the requests but just which friends belong to which group. We can also replace the DFS entirely by merging lists at the parent node and as a consequence there is no need for using find() directly but we can just compare parent nodes\\' lists.\\nThe algorithm boils down to union-find where we add a linear scan of the restrictions in the union function\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ncomplexity of union is $$O(n)$$ for restriction checks plus the complexity of find.\\nComplexity of find is amortized $$O(1)$$.\\n\\nIn total: $$O(requests * n)$$\\n \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe only operation performed is merging lists or reassigning pointers. Thus it does not grow from the initial $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    int[] parent;\\n    List<Integer>[] friends;\\n    Set<Integer>[] enemies;\\n\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        parent = new int[n];\\n        friends = new List[n];\\n        enemies = new Set[n];\\n        // init network\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n            friends[i] = new ArrayList<>();\\n            friends[i].add(i);\\n            enemies[i] = new HashSet<>();\\n        }\\n        for (int[] r : restrictions) {\\n            enemies[r[0]].add(r[1]);\\n            enemies[r[1]].add(r[0]);\\n        }\\n        // solve\\n        boolean[] ans = new boolean[requests.length];\\n        for (int i = 0; i < ans.length; ++i) {\\n            ans[i] = union(requests[i][0], requests[i][1]);\\n        }\\n        return ans;\\n    }\\n\\n    private boolean union(int a, int b) {\\n        int pa = find(a), pb = find(b);\\n        if (pa == pb) { //discard direct friendships as they are redundant\\n            return true;\\n        }\\n        int p1, p2;\\n        if (friends[pa].size() < friends[pb].size()) {\\n            p1 = pa;\\n            p2 = pb;\\n        } else {\\n            p2 = pa;\\n            p1 = pb;\\n        }\\n        for (int p1Friend : friends[p1]) {\\n            if (enemies[p2].contains(p1Friend)) {\\n                return false;\\n            }\\n        }\\n        friends[p2].addAll(friends[p1]);\\n        enemies[p2].addAll(enemies[p1]);\\n        parent[p1] = p2;   \\n        // release memory as we don\\'t need to store subtrees\\n        friends[p1] = null;\\n        enemies[p1] = null;\\n        return true;\\n    }\\n\\n    private int find(int x) {\\n        return parent[x] == x ? x : (parent[x] = find(parent[x]));\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] parent;\\n    List<Integer>[] friends;\\n    Set<Integer>[] enemies;\\n\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        parent = new int[n];\\n        friends = new List[n];\\n        enemies = new Set[n];\\n        // init network\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n            friends[i] = new ArrayList<>();\\n            friends[i].add(i);\\n            enemies[i] = new HashSet<>();\\n        }\\n        for (int[] r : restrictions) {\\n            enemies[r[0]].add(r[1]);\\n            enemies[r[1]].add(r[0]);\\n        }\\n        // solve\\n        boolean[] ans = new boolean[requests.length];\\n        for (int i = 0; i < ans.length; ++i) {\\n            ans[i] = union(requests[i][0], requests[i][1]);\\n        }\\n        return ans;\\n    }\\n\\n    private boolean union(int a, int b) {\\n        int pa = find(a), pb = find(b);\\n        if (pa == pb) { //discard direct friendships as they are redundant\\n            return true;\\n        }\\n        int p1, p2;\\n        if (friends[pa].size() < friends[pb].size()) {\\n            p1 = pa;\\n            p2 = pb;\\n        } else {\\n            p2 = pa;\\n            p1 = pb;\\n        }\\n        for (int p1Friend : friends[p1]) {\\n            if (enemies[p2].contains(p1Friend)) {\\n                return false;\\n            }\\n        }\\n        friends[p2].addAll(friends[p1]);\\n        enemies[p2].addAll(enemies[p1]);\\n        parent[p1] = p2;   \\n        // release memory as we don\\'t need to store subtrees\\n        friends[p1] = null;\\n        enemies[p1] = null;\\n        return true;\\n    }\\n\\n    private int find(int x) {\\n        return parent[x] == x ? x : (parent[x] = find(parent[x]));\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999938,
                "title": "python-simple-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def friendRequests(self, n, restrictions, requests):\\n        dict1, result = collections.defaultdict(int), [None]*len(requests)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a, b = find(x), find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n\\n        for i in range(len(requests)):\\n            found_set = set([find(requests[i][0]),find(requests[i][1])])\\n            result[i] = not any(find(a) in found_set and find(b) in found_set for (a,b) in restrictions)\\n\\n            if result[i] == True:\\n                union(requests[i][0],requests[i][1])\\n\\n        return result\\n\\n            \\n\\n                \\n\\n\\n\\n\\n\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n, restrictions, requests):\\n        dict1, result = collections.defaultdict(int), [None]*len(requests)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a, b = find(x), find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n\\n        for i in range(len(requests)):\\n            found_set = set([find(requests[i][0]),find(requests[i][1])])\\n            result[i] = not any(find(a) in found_set and find(b) in found_set for (a,b) in restrictions)\\n\\n            if result[i] == True:\\n                union(requests[i][0],requests[i][1])\\n\\n        return result\\n\\n            \\n\\n                \\n\\n\\n\\n\\n\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942191,
                "title": "rust-solution",
                "content": "# Intuition\\nApparently we can use union set to solve this problem. \\n\\nThe union set indicates whether a group of people are friends. For each of the requests let\\'s try to join two people into a union. After that, we go through the restrictions and check if any conflict occurs. If so, this request can not be done, otherwise can be.\\n\\n# Algorithm\\n1. initate `p`vector, the ancestor of elements. `for i in n: p[i] = i`\\u3002\\n2. for each request, let\\'s say a and b. \\n    1. If a and b is already in same union set, set the answer `true` and continue.\\n    2. If not, firstly use `pc = p.clone()`to back up `p`.\\n    3. then call function `join(a, b)` to join them into one set.\\n    4. for each restriction, let\\'s say x and y.\\n        1. find `px` and `py` as the ancestors of `x` and `y`.\\n        2. if `px == py`, conflict occurs (because they can not make friends), then we set the corresponding answer to `false`, set `p = pc` and move to next request.\\n    5. If after checking all restrictions, no conflict occurs, and set the answer to `true`.\\n# Complexity\\n- Time complexity:\\n$O(mn)$, where $m$=`restrictions.len()`and $n$=`requests.len()`.\\nWe can get this from two for loops above.\\n\\n- Space complexity:\\n$O(n)$, where  $n$=`requests.len()`.\\nWe only use extra memory to build a vector `p`.\\n# Code\\n```\\nimpl Solution {\\n    fn find(x: usize, p:&mut Vec<usize>) -> usize {\\n        return if p[x] == x {\\n            x\\n        } else {\\n            p[x] = Self::find(p[x], p);\\n            p[x]\\n        }\\n    }\\n\\n    pub fn friend_requests(n: i32, restrictions: Vec<Vec<i32>>, requests: Vec<Vec<i32>>) -> Vec<bool> {\\n        let mut p = vec![0; (n + 1) as usize];\\n        for i  in 1..=n {\\n            p[i as usize] = i as usize;\\n        }\\n        let mut ans = vec![false; requests.len()];\\n        for i in 0..requests.len() {\\n            let (a, b) = (requests[i][0] as usize, requests[i][1] as usize);\\n            // \\u5982\\u679C\\u5DF2\\u7ECF\\u662F\\u670B\\u53CB\\n            let pa = Self::find(a, &mut p);\\n            let pb = Self::find(b, &mut p);\\n            if pa == pb {\\n                ans[i] = true;\\n            } else {\\n                // pc \\u4F5C\\u4E3A\\u5907\\u4EFD\\uFF0C\\u5982\\u679C\\u5931\\u8D25\\u5219\\u56DE\\u9000\\n                let pc = p.clone();\\n                // flag \\u8868\\u793A\\u662F\\u5426\\u53EF\\u884C\\n                let mut flag = true;\\n                p[pa] = pb;\\n                for j in 0..restrictions.len() {\\n                    let (x, y) = (restrictions[j][0] as usize, restrictions[j][1] as usize);\\n                    let px = Self::find(x, &mut p);\\n                    let py = Self::find(y, &mut p);\\n                    if px == py {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if flag {\\n                    ans[i] = true;\\n                } else {\\n                    p = pc;\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Union Find"
                ],
                "code": "```\\nimpl Solution {\\n    fn find(x: usize, p:&mut Vec<usize>) -> usize {\\n        return if p[x] == x {\\n            x\\n        } else {\\n            p[x] = Self::find(p[x], p);\\n            p[x]\\n        }\\n    }\\n\\n    pub fn friend_requests(n: i32, restrictions: Vec<Vec<i32>>, requests: Vec<Vec<i32>>) -> Vec<bool> {\\n        let mut p = vec![0; (n + 1) as usize];\\n        for i  in 1..=n {\\n            p[i as usize] = i as usize;\\n        }\\n        let mut ans = vec![false; requests.len()];\\n        for i in 0..requests.len() {\\n            let (a, b) = (requests[i][0] as usize, requests[i][1] as usize);\\n            // \\u5982\\u679C\\u5DF2\\u7ECF\\u662F\\u670B\\u53CB\\n            let pa = Self::find(a, &mut p);\\n            let pb = Self::find(b, &mut p);\\n            if pa == pb {\\n                ans[i] = true;\\n            } else {\\n                // pc \\u4F5C\\u4E3A\\u5907\\u4EFD\\uFF0C\\u5982\\u679C\\u5931\\u8D25\\u5219\\u56DE\\u9000\\n                let pc = p.clone();\\n                // flag \\u8868\\u793A\\u662F\\u5426\\u53EF\\u884C\\n                let mut flag = true;\\n                p[pa] = pb;\\n                for j in 0..restrictions.len() {\\n                    let (x, y) = (restrictions[j][0] as usize, restrictions[j][1] as usize);\\n                    let px = Self::find(x, &mut p);\\n                    let py = Self::find(y, &mut p);\\n                    if px == py {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if flag {\\n                    ans[i] = true;\\n                } else {\\n                    p = pc;\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2930977,
                "title": "golang-union-find",
                "content": "```\\nfunc friendRequests(n int, restrictions [][]int, requests [][]int) []bool {\\n\\tuff := new(UF)\\n\\tuff.r = make([]int, n)\\n\\tuff.p = make([]int, n)\\n\\tfor i := 0; i < n; i++ { uff.p[i] = i }\\n\\n\\tres := make([]bool, len(requests))\\n\\tfor ri := range requests {\\n\\t\\tuffc := new(UF)\\n\\t\\tuffc.r = make([]int, n)\\n\\t\\tuffc.p = make([]int, n)\\n\\t\\tcopy(uffc.p, uff.p)\\n\\t\\tcopy(uffc.r, uff.r)\\n\\n\\t\\tuff.Union(requests[ri][0], requests[ri][1])\\n\\t\\tf := true\\n\\t\\tfor rri := range restrictions {\\n\\t\\t\\tif uff.Find(restrictions[rri][0]) == uff.Find(restrictions[rri][1]) {\\n\\t\\t\\t\\tf = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif !f { uff = uffc }\\n\\t\\tres[ri] = f\\n\\t}\\n\\treturn res\\n}\\n\\ntype UF struct {\\n\\tp, r []int\\n}\\n\\nfunc (uf *UF) Find(e int) int {\\n\\tif uf.p[e] == e { return e }\\n\\tuf.p[e] = uf.Find(uf.p[e])\\n\\treturn uf.p[e]\\n}\\n\\nfunc (uf *UF) Union(e1, e2 int) {\\n\\tr1 := uf.Find(e1)\\n\\tr2 := uf.Find(e2)\\n\\tif r1 == r2 { return }\\n\\n\\tswitch {\\n\\tcase uf.r[r1] < uf.r[r2]: uf.p[r1] = r2\\n\\tcase uf.r[r1] > uf.r[r2]: uf.p[r2] = r1\\n\\tdefault: uf.p[r2] = r1; uf.r[r1]++\\n\\t}\\n\\treturn\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc friendRequests(n int, restrictions [][]int, requests [][]int) []bool {\\n\\tuff := new(UF)\\n\\tuff.r = make([]int, n)\\n\\tuff.p = make([]int, n)\\n\\tfor i := 0; i < n; i++ { uff.p[i] = i }\\n\\n\\tres := make([]bool, len(requests))\\n\\tfor ri := range requests {\\n\\t\\tuffc := new(UF)\\n\\t\\tuffc.r = make([]int, n)\\n\\t\\tuffc.p = make([]int, n)\\n\\t\\tcopy(uffc.p, uff.p)\\n\\t\\tcopy(uffc.r, uff.r)\\n\\n\\t\\tuff.Union(requests[ri][0], requests[ri][1])\\n\\t\\tf := true\\n\\t\\tfor rri := range restrictions {\\n\\t\\t\\tif uff.Find(restrictions[rri][0]) == uff.Find(restrictions[rri][1]) {\\n\\t\\t\\t\\tf = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif !f { uff = uffc }\\n\\t\\tres[ri] = f\\n\\t}\\n\\treturn res\\n}\\n\\ntype UF struct {\\n\\tp, r []int\\n}\\n\\nfunc (uf *UF) Find(e int) int {\\n\\tif uf.p[e] == e { return e }\\n\\tuf.p[e] = uf.Find(uf.p[e])\\n\\treturn uf.p[e]\\n}\\n\\nfunc (uf *UF) Union(e1, e2 int) {\\n\\tr1 := uf.Find(e1)\\n\\tr2 := uf.Find(e2)\\n\\tif r1 == r2 { return }\\n\\n\\tswitch {\\n\\tcase uf.r[r1] < uf.r[r2]: uf.p[r1] = r2\\n\\tcase uf.r[r1] > uf.r[r2]: uf.p[r2] = r1\\n\\tdefault: uf.p[r2] = r1; uf.r[r1]++\\n\\t}\\n\\treturn\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2905694,
                "title": "java-extended-dsu-100-faster",
                "content": "Disclaimer: This code works, but the explanation is a work in progress because I don\\'t know the exact run-time complexity, and I\\'m sure the explanation can be more clear. Just putting it out there in case someone finds it useful, and also, I would love it if someone could help me with completing this explanation!\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis solution takes the basic theory behind a general DSU solution and makes it much much faster. I won\\'t explain the general DSU solution, which can be found here: https://leetcode.com/problems/process-restricted-friend-requests/solutions/1578306/java-clean-and-commented-code-with-explanation-union-find-algorithm/. \\n\\nThe main optimization over the original solution is to avoid iterating over all of the restrictions. Instead, you can check a map that contains restrictions, where \\'noMap[i]\\' = (all the people \\'i\\' cannot be friends with). \\n\\nFor simplicity, let\\'s call:\\n1. Node: a person\\n2. Node set: a set of nodes where every node inside the set is a direct or indirect friend of every other node in the set\\n3. Parent: the parent of all the nodes in a node set, or the root of the tree represented by the DSU array.\\n\\nTo understand noMap, let\\'s create a hypothetical map, called noMap\\' with the following properties:\\n1. For node set S with parent A, noMap\\'[A] contains all the parents of all the nodes that cannot join set S without violating a restriction. \\n2. Then for any C and D who want to be friends, if noMap\\'[parentC] contains parentD, we know they cannot be friends. If noMap\\'[parentC] does not contain parentD, we know they can become friends. \\n\\nThis would be nice to have, but would be difficult to keep updated. For example, let\\'s say we have the following parent to child structure:\\nA: [A] // A\\'s parent is A\\nB: [B]\\nC: [C]\\nY: [Y, X] // Y and X\\'s parent is Y\\nH: [H]\\nThen if have a restriction that Y cannot map to A, B, or C noMap\\' would be:\\nA = [Y] // Any node with parent A cannot map to any node with parent Y.\\nB = [Y]\\nC = [Y]\\nY = [A, B, C]\\nH = []\\n\\nIf we have Y become friends with H, and take H as its parent, then our new children structure is \\nA: [A]\\nB: [B]\\nC: [C]\\nH: [H, Y, X]\\nand our new noMap\\':\\nA = [H]\\nB = [H]\\nC = [H]\\nH = [A, B, C]\\nTo do this update on noMap\\', we\\'ll have to:\\n1. Add all restrictions in noMap\\'[Y] to noMap\\'[H].\\n2. Remove Y from noMap\\' (in practice, we we can skip this step because we only ever call noMap\\' with parents of nodes, so moving forward, Y will never be called)\\n3. Update all \\'Y\\' instances in the map to \\'H\\'. In this case, we\\'ll have to update A, B, and C\\'s entries. This is the bottleneck, and is why we want to change noMap\\' to noMap.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo how do we make noMap provide the same value as noMap\\' without the bottleneck of step 3? We simply modify step 1 to make the steps:\\n1. Add all restrictions in noMap[Y] to noMap[H] as their parents.\\n2. Remove Y from noMap (in practice, we we can skip this step because we only ever call noMap with parents of nodes, so moving forward, Y will never be called)\\nour new noMap: \\nA = [Y]\\nB = [Y]\\nC = [Y]\\nH = [A, B, C]\\nNotice that  noMap[A], noMap[B], and noMap[C] don\\'t have any useful results anymore because Y is no longer a parent (and we only ever compare with parents). However, H does contain the parents because in step 1, we added noMap[Y]\\'s restricted node\\'s parents. \\n\\nFrom before, noMap\\' has the following property: \\nFor any C and D who want to be friends, if noMap\\'[parentC] contains parentD, we know they cannot be friends. If noMap\\'[parentC] does not contain parentD, we know they can become friends. \\n\\nnoMap has the following property:\\nFor any C and D who want to be friends, if noMap[parentC] contians parentD OR noMap[parentD] contains parentC, we know they cannot be friends. If noMap[parentC] does not contain parentD AND noMap[parentD] does not contain parentA, we know C and D can become friends.\\n\\nIf C and D cannot be friends and noMap[parentC] has parentD, then we\\'re done. If noMap[parentC] does not have parentD, then at some point, parentD had found a new parent (let\\'s call it parentE). However, when we joined parentD with parentE, we updated parentE to contain all the restrictions that came with joining with parentD, and we added them in the form of their parents. So noMap[parentE] MUST contain parentC. \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        Set<Integer>[] noMap = new Set[n];\\n        int[] parents = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            noMap[i] = new HashSet<>();\\n            parents[i] = i;\\n        }\\n        for (int[] r : restrictions) {\\n            noMap[r[0]].add(r[1]);\\n            noMap[r[1]].add(r[0]);\\n        }\\n        boolean[] sol = new boolean[requests.length];\\n        for (int i = 0; i < sol.length; i++) {\\n            int[] request = requests[i];\\n            int parentA = parent(parents, request[0]), parentB = parent(parents, request[1]);\\n            if (parentA == parentB) sol[i] = true;\\n            else if (noMap[parentA].contains(parentB) || noMap[parentB].contains(parentA)) \\n                sol[i] = false;\\n            else {\\n                parents[parentB] = parentA;\\n                for (Integer child : noMap[parentB]) \\n                    noMap[parentA].add(parent(parents, child));\\n                sol[i] = true;\\n            } \\n        }\\n        return sol;\\n    }\\n\\n    private int parent(int[] parents, int a) {\\n        if (parents[a] == a) return a;\\n        else return parents[a] = parent(parents, parents[a]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        Set<Integer>[] noMap = new Set[n];\\n        int[] parents = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            noMap[i] = new HashSet<>();\\n            parents[i] = i;\\n        }\\n        for (int[] r : restrictions) {\\n            noMap[r[0]].add(r[1]);\\n            noMap[r[1]].add(r[0]);\\n        }\\n        boolean[] sol = new boolean[requests.length];\\n        for (int i = 0; i < sol.length; i++) {\\n            int[] request = requests[i];\\n            int parentA = parent(parents, request[0]), parentB = parent(parents, request[1]);\\n            if (parentA == parentB) sol[i] = true;\\n            else if (noMap[parentA].contains(parentB) || noMap[parentB].contains(parentA)) \\n                sol[i] = false;\\n            else {\\n                parents[parentB] = parentA;\\n                for (Integer child : noMap[parentB]) \\n                    noMap[parentA].add(parent(parents, child));\\n                sol[i] = true;\\n            } \\n        }\\n        return sol;\\n    }\\n\\n    private int parent(int[] parents, int a) {\\n        if (parents[a] == a) return a;\\n        else return parents[a] = parent(parents, parents[a]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808174,
                "title": "python-union-find",
                "content": "```\\nclass UF:\\n    def __init__(self, n):\\n        self.parents = list(range(n))\\n        \\n    def find(self, u):\\n        if u != self.parents[u]:\\n            self.parents[u] = self.find(self.parents[u])\\n        return self.parents[u]\\n    \\n    def union(self, u, v):\\n        x, y = self.find(u), self.find(v)\\n        if x != y:\\n            self.parents[y] = x\\n            return x\\n        return -1\\n\\t\\t\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        uf, ban, group, ans = UF(n), defaultdict(set), {i: {i} for i in range(n)}, []\\n        for u, v in restrictions:\\n            ban[u].add(v)\\n            ban[v].add(u)\\n        for u, v in requests:\\n            p, q = uf.find(u), uf.find(v)\\n            if p == q:\\n                ans.append(True)\\n                continue\\n            if group[p] & ban[q] or group[q] & ban[p]:\\n                ans.append(False)\\n                continue\\n            p = uf.union(u, v)\\n            group[p] |= group[q]\\n            ban[p] |= ban[q]\\n            ans.append(True)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UF:\\n    def __init__(self, n):\\n        self.parents = list(range(n))\\n        \\n    def find(self, u):\\n        if u != self.parents[u]:\\n            self.parents[u] = self.find(self.parents[u])\\n        return self.parents[u]\\n    \\n    def union(self, u, v):\\n        x, y = self.find(u), self.find(v)\\n        if x != y:\\n            self.parents[y] = x\\n            return x\\n        return -1\\n\\t\\t\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        uf, ban, group, ans = UF(n), defaultdict(set), {i: {i} for i in range(n)}, []\\n        for u, v in restrictions:\\n            ban[u].add(v)\\n            ban[v].add(u)\\n        for u, v in requests:\\n            p, q = uf.find(u), uf.find(v)\\n            if p == q:\\n                ans.append(True)\\n                continue\\n            if group[p] & ban[q] or group[q] & ban[p]:\\n                ans.append(False)\\n                continue\\n            p = uf.union(u, v)\\n            group[p] |= group[q]\\n            ban[p] |= ban[q]\\n            ans.append(True)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729180,
                "title": "c-union-find",
                "content": "\\tclass Solution {\\n\\t\\tprivate:\\n\\t\\tint findPar(vector<int>&parent,int node)\\n\\t\\t{\\n\\t\\t\\tif(node==parent[node])return node;\\n\\t\\t\\treturn parent[node] = findPar(parent,parent[node]);\\n\\t\\t}\\n\\t\\tvoid unite(vector<int>&rank,vector<int>&parent,int u,int v)\\n\\t\\t{\\n\\t\\t\\tu = findPar(parent,u);\\n\\t\\t\\tv = findPar(parent,v);\\n\\t\\t\\tif(rank[u]<rank[v])parent[u] = v;\\n\\t\\t\\telse if(rank[u]>rank[v])parent[v] = u;\\n\\t\\t\\telse \\n\\t\\t\\t{\\n\\t\\t\\t\\tparent[v] = u;\\n\\t\\t\\t\\trank[u]++;\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tvector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n\\t\\t\\tvector<bool>ans;\\n\\t\\t\\tvector<int>parent(n,0),rank(n,0);\\n\\t\\t\\tfor(int i=0;i<n;i++)parent[i] = i;\\n\\t\\t\\tset<pair<int,int>>s;\\n\\t\\t\\tfor(auto i:restrictions)\\n\\t\\t\\t{\\n\\t\\t\\t\\ts.insert({i[0],i[1]});\\n\\t\\t\\t\\ts.insert({i[1],i[0]});\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto i:requests)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint u = i[0];\\n\\t\\t\\t\\tint v = i[1];\\n\\t\\t\\t\\tint x = findPar(parent,u);\\n\\t\\t\\t\\tint y = findPar(parent,v);\\n\\t\\t\\t\\tbool f = true;\\n\\t\\t\\t\\tfor(auto i:s)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint a = findPar(parent,i.first);\\n\\t\\t\\t\\t\\tint b = findPar(parent,i.second);\\n\\t\\t\\t\\t\\tif(a==x && b==y)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tf = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(f)unite(rank,parent,u,v);\\n\\t\\t\\t\\tans.push_back(f);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "class Solution {\\n\\t\\tprivate:\\n\\t\\tint findPar(vector<int>&parent,int node)\\n\\t\\t{\\n\\t\\t\\tif(node==parent[node])return node;\\n\\t\\t\\treturn parent[node] = findPar(parent,parent[node]);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2728066,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    class dsu{\\n    public:\\n        vi(ll)par, size;\\n        dsu(ll n){\\n            par.assign(n, 0), size.assign(n, 1);\\n            iota(begin(par), end(par), 0);\\n        }\\n        ll find(ll n){\\n            if(par[n]==n){\\n                return n;\\n            }\\n            return (par[n]=find(par[n]));\\n        }\\n        void merge(ll a, ll b){\\n            a=find(a), b=find(b);\\n            if(a==b){\\n                return;\\n            }\\n            if(size[a]<size[b]){\\n                a+=b, b=a-b, a-=b;\\n            }\\n            par[b]=a;\\n            size[a]+=size[b];\\n        }\\n    };\\n    vector<bool> friendRequests(int n, vector<vector<int>>&r, vector<vector<int>>&q){\\n        dsu f(n);\\n        vi(bool)ans(q.size(), 1);\\n        for(ll i=0;i<q.size();++i){\\n            if(f.find(q[i][0])==f.find(q[i][1])){\\n                continue;\\n            }\\n            for(const auto&e:r){\\n                if((f.find(e[0])==f.find(q[i][0]) && f.find(e[1])==f.find(q[i][1])) || (f.find(e[1])==f.find(q[i][0]) && f.find(e[0])==f.find(q[i][1]))){\\n                    ans[i]=0;\\n                    break;\\n                }\\n            }\\n            if(ans[i]){\\n                f.merge(q[i][0], q[i][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    class dsu{\\n    public:\\n        vi(ll)par, size;\\n        dsu(ll n){\\n            par.assign(n, 0), size.assign(n, 1);\\n            iota(begin(par), end(par), 0);\\n        }\\n        ll find(ll n){\\n            if(par[n]==n){\\n                return n;\\n            }\\n            return (par[n]=find(par[n]));\\n        }\\n        void merge(ll a, ll b){\\n            a=find(a), b=find(b);\\n            if(a==b){\\n                return;\\n            }\\n            if(size[a]<size[b]){\\n                a+=b, b=a-b, a-=b;\\n            }\\n            par[b]=a;\\n            size[a]+=size[b];\\n        }\\n    };\\n    vector<bool> friendRequests(int n, vector<vector<int>>&r, vector<vector<int>>&q){\\n        dsu f(n);\\n        vi(bool)ans(q.size(), 1);\\n        for(ll i=0;i<q.size();++i){\\n            if(f.find(q[i][0])==f.find(q[i][1])){\\n                continue;\\n            }\\n            for(const auto&e:r){\\n                if((f.find(e[0])==f.find(q[i][0]) && f.find(e[1])==f.find(q[i][1])) || (f.find(e[1])==f.find(q[i][0]) && f.find(e[0])==f.find(q[i][1]))){\\n                    ans[i]=0;\\n                    break;\\n                }\\n            }\\n            if(ans[i]){\\n                f.merge(q[i][0], q[i][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640565,
                "title": "c-simple-fast-comprehensible",
                "content": "Link to the submissions stats:\\nhttps://leetcode.com/submissions/detail/811706085/\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> rep;\\n    vector<int> sz;\\n    \\n    int root(int x){\\n        if(x==rep[x]){return x;}\\n        return rep[x]=root(rep[x]);\\n    }\\n    \\n    vector<bool> friendRequests(int n, vector<vector<int>>& ar, vector<vector<int>>& req) {\\n        set<int> s[n];\\n        set<int> ss[n];\\n        for(auto it:ar){\\n            s[it[0]].insert(it[1]);\\n            s[it[1]].insert(it[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            s[i].insert(i);\\n            ss[i].insert(i);\\n        }\\n        rep.resize(n);\\n        sz.resize(n);\\n        for(int i=0;i<n;i++){\\n            rep[i]=i;\\n            sz[i]=1;\\n        }\\n        vector<bool> ans;\\n        for(auto it:req){\\n            int a=it[0],b=it[1];\\n            a=root(a);\\n            b=root(b);\\n            if(a==b){\\n                ans.push_back(true);\\n            }\\n            else{\\n                bool ok=1;\\n                for(auto itt:s[b]){\\n                    if(s[a].count(itt) && (ss[a].count(itt) || ss[b].count(itt))){\\n                        ok=0;break;\\n                    }\\n                }\\n                if(sz[a]<sz[b]){\\n                    swap(a,b);\\n                }\\n                if(ok){\\n                    ans.push_back(true);\\n                    rep[b]=a;\\n                    sz[a]+=sz[b];\\n                    for(auto itt:s[b]){\\n                        s[a].insert(itt);\\n                    }\\n                    for(auto itt:ss[b]){\\n                        ss[a].insert(itt);\\n                    }\\n                }\\n                else{\\n                    ans.push_back(false);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rep;\\n    vector<int> sz;\\n    \\n    int root(int x){\\n        if(x==rep[x]){return x;}\\n        return rep[x]=root(rep[x]);\\n    }\\n    \\n    vector<bool> friendRequests(int n, vector<vector<int>>& ar, vector<vector<int>>& req) {\\n        set<int> s[n];\\n        set<int> ss[n];\\n        for(auto it:ar){\\n            s[it[0]].insert(it[1]);\\n            s[it[1]].insert(it[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            s[i].insert(i);\\n            ss[i].insert(i);\\n        }\\n        rep.resize(n);\\n        sz.resize(n);\\n        for(int i=0;i<n;i++){\\n            rep[i]=i;\\n            sz[i]=1;\\n        }\\n        vector<bool> ans;\\n        for(auto it:req){\\n            int a=it[0],b=it[1];\\n            a=root(a);\\n            b=root(b);\\n            if(a==b){\\n                ans.push_back(true);\\n            }\\n            else{\\n                bool ok=1;\\n                for(auto itt:s[b]){\\n                    if(s[a].count(itt) && (ss[a].count(itt) || ss[b].count(itt))){\\n                        ok=0;break;\\n                    }\\n                }\\n                if(sz[a]<sz[b]){\\n                    swap(a,b);\\n                }\\n                if(ok){\\n                    ans.push_back(true);\\n                    rep[b]=a;\\n                    sz[a]+=sz[b];\\n                    for(auto itt:s[b]){\\n                        s[a].insert(itt);\\n                    }\\n                    for(auto itt:ss[b]){\\n                        ss[a].insert(itt);\\n                    }\\n                }\\n                else{\\n                    ans.push_back(false);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634438,
                "title": "c-disjoint-union-set-accepted",
                "content": "**IF Helpful Please Like Or Upvoke**\\n```\\nclass DSU{\\n    vector<int> par,rank;\\n    int n;\\n    public:\\n    DSU(int n)\\n    {\\n        this->par.resize(n);\\n        this->rank.resize(n);\\n        this->n=n;\\n        for(int i=0;i<n;i++)\\n            par[i]=i;\\n    }\\n    int find(int x)\\n    {\\n        if(x==par[x])return x;\\n        return par[x]=find(par[x]);\\n    }\\n    void Union(int a, int b)\\n    {\\n        int a_par=find(a);\\n        int b_par=find(b);\\n        if(a_par==b_par)\\n            return;\\n        if(rank[a_par]<rank[b_par])\\n        {\\n            par[a_par]=b_par;\\n        }\\n        else if(rank[b_par]<rank[a_par]){\\n            par[b_par]=a_par;\\n        }\\n        else\\n        {\\n            par[a_par]=b_par;\\n            rank[b_par]+=1;\\n        }\\n    }                       \\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n          DSU dsu(n+1);     \\n        vector<bool> ans;\\n        \\n        for(auto &it: requests){\\n            int x = it[0];\\n            int y = it[1];\\n            \\n            DSU temp = dsu;     // nice updating\\n            \\n            temp.Union(x, y);\\n            \\n            bool flag = true;\\n            for(auto &itr: restrictions){\\n                int x1 = itr[0];\\n                int y1 = itr[1];\\n                \\n                if(temp.find(x1)==temp.find(y1)){\\n                    flag=false; \\n                    break;\\n                }\\n            }\\n            \\n              if(flag){ \\n                dsu.Union(x, y);  // successful accepted\\n                ans.push_back(true);\\n            }\\n            else\\n                ans.push_back(false);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU{\\n    vector<int> par,rank;\\n    int n;\\n    public:\\n    DSU(int n)\\n    {\\n        this->par.resize(n);\\n        this->rank.resize(n);\\n        this->n=n;\\n        for(int i=0;i<n;i++)\\n            par[i]=i;\\n    }\\n    int find(int x)\\n    {\\n        if(x==par[x])return x;\\n        return par[x]=find(par[x]);\\n    }\\n    void Union(int a, int b)\\n    {\\n        int a_par=find(a);\\n        int b_par=find(b);\\n        if(a_par==b_par)\\n            return;\\n        if(rank[a_par]<rank[b_par])\\n        {\\n            par[a_par]=b_par;\\n        }\\n        else if(rank[b_par]<rank[a_par]){\\n            par[b_par]=a_par;\\n        }\\n        else\\n        {\\n            par[a_par]=b_par;\\n            rank[b_par]+=1;\\n        }\\n    }                       \\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n          DSU dsu(n+1);     \\n        vector<bool> ans;\\n        \\n        for(auto &it: requests){\\n            int x = it[0];\\n            int y = it[1];\\n            \\n            DSU temp = dsu;     // nice updating\\n            \\n            temp.Union(x, y);\\n            \\n            bool flag = true;\\n            for(auto &itr: restrictions){\\n                int x1 = itr[0];\\n                int y1 = itr[1];\\n                \\n                if(temp.find(x1)==temp.find(y1)){\\n                    flag=false; \\n                    break;\\n                }\\n            }\\n            \\n              if(flag){ \\n                dsu.Union(x, y);  // successful accepted\\n                ans.push_back(true);\\n            }\\n            else\\n                ans.push_back(false);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598995,
                "title": "c-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>par;\\n    vector<int>rk;\\n    int findpar(int node){\\n        if(node == par[node])\\n            return node;\\n        return par[node] = findpar(par[node]);\\n    }\\n    void unionfun(int u,int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n        if(rk[u] < rk[v])\\n            par[u]=v;\\n        else if(rk[v] < rk[u])\\n            par[v]=u;\\n        else{\\n            rk[u]++;\\n            par[v]=u;\\n        }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& a, vector<vector<int>>&b) {\\n        int m = b.size();\\n        rk.resize(n,0);\\n        par.resize(n);\\n        for(int i=0;i<n;i++){\\n            par[i]=i;\\n        }\\n        vector<bool>ans(m,0);\\n        for(int i=0;i<m;i++){\\n            int u = b[i][0];\\n            int v = b[i][1];\\n            vector<int>trk=rk;\\n            vector<int>tpar=par;\\n            unionfun(u,v);\\n            int ok=0;\\n            for(int j=0;j<a.size();j++){\\n                int f = a[j][0];\\n                int s = a[j][1];\\n                int par1=findpar(f);\\n                int par2=findpar(s);\\n                if(par1 == par2){\\n                    ok=1;\\n                    break;\\n                }\\n            }\\n            if(ok == 1){\\n                ans[i]=0;\\n                par = tpar;\\n                rk = trk;\\n            }\\n            else{\\n                ans[i]=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>par;\\n    vector<int>rk;\\n    int findpar(int node){\\n        if(node == par[node])\\n            return node;\\n        return par[node] = findpar(par[node]);\\n    }\\n    void unionfun(int u,int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n        if(rk[u] < rk[v])\\n            par[u]=v;\\n        else if(rk[v] < rk[u])\\n            par[v]=u;\\n        else{\\n            rk[u]++;\\n            par[v]=u;\\n        }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& a, vector<vector<int>>&b) {\\n        int m = b.size();\\n        rk.resize(n,0);\\n        par.resize(n);\\n        for(int i=0;i<n;i++){\\n            par[i]=i;\\n        }\\n        vector<bool>ans(m,0);\\n        for(int i=0;i<m;i++){\\n            int u = b[i][0];\\n            int v = b[i][1];\\n            vector<int>trk=rk;\\n            vector<int>tpar=par;\\n            unionfun(u,v);\\n            int ok=0;\\n            for(int j=0;j<a.size();j++){\\n                int f = a[j][0];\\n                int s = a[j][1];\\n                int par1=findpar(f);\\n                int par2=findpar(s);\\n                if(par1 == par2){\\n                    ok=1;\\n                    break;\\n                }\\n            }\\n            if(ok == 1){\\n                ans[i]=0;\\n                par = tpar;\\n                rk = trk;\\n            }\\n            else{\\n                ans[i]=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545532,
                "title": "java-solution-with-explanation",
                "content": "Runtime: O(n*m*l )  n=number of requests, \\n                    m=number of restrictions to search through,\\n                    l=lookup time for Find of a given friend --> Initially, this lookup is constant, but depending on size of friend group can grow to size of log(n) \\nStorage: O(n*p)     n=number of requests,\\n                    p=number of people in network\\nGeneral Explanation: \\n\\nFor this problem, we need to use Union Find. This algorithm works by identifying all nodes within a tree point to a head and then comparing if two nodes have the same head\\nyou can find out if they are part of the same tree. You can then Union the trees by making one root point to the other.\\nMore information on this process can be found here: https://www.youtube.com/watch?v=ayW5B2W9hfo\\n\\nThis algorithm begins by creating an array arr to represent all of the people in the network. These values begin as the their own index indicating that \\neach individual is their own friend. As the algorithm progresses, we perform union Find and point one individual from a friend pair to point to the other\\'s\\nindex. When arr[i]=i you know that you found the head for that friend group.\\n\\nThe alforithm progresses by initializing an empty boolean array for us to fill if we have a successful or failed request. We then iterate through each request \\nto determine if the request is successful.\\n\\nWe take the two individuals we are trying to make a friend request with and find the heads of their respective friend groups using the find method as described\\nabove. We then run throughall of the restrictions and check whether or not the heads of our two groups are restricted from becoming friends. If the heads of the \\ntwo groups we have a request to join are equal to the heads of the two groups restricted from joining, then we add false to our array to return and break from \\nthe current iteration.\\n\\nIf the heads of the groups we have a request to join don\\'t have a restriction preventing them from being merged, then we add true to our array to return and \\nthen merge the two groups using the method described above by moving one index to point to the heads of the other.\\n\\nWe continue with this process through all requests and return the final boolean array produced :)\\n\\n\\nCode: \\n\\n```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] arr=new int[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=i;\\n        }\\n        int j=0;\\n        boolean[] ret=new boolean[requests.length];\\n        for(int[] a:requests){\\n            int x=find(a[0],arr);\\n            int y=find(a[1],arr);\\n            boolean flag=true;\\n            for(int i=0;i<restrictions.length;i++){\\n                int l=find(restrictions[i][0],arr);\\n                int r=find(restrictions[i][1],arr);\\n                if(((l==x && r==y) || (l==y && r==x))){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            ret[j++]=flag;\\n            if(flag){\\n                union(x,y,arr);\\n            }\\n        }\\n        return ret;\\n    }\\n    private void union(int a,int b,int[] arr){\\n        int x=find(a,arr);\\n        int y=find(b,arr);\\n        if(x==y) return;\\n        arr[y]=x;\\n    }\\n    private int find(int x,int[] arr){\\n        if(arr[x]==x) return x;\\n        return find(arr[x],arr);\\n    }\\n}\\n\\n\\n\\n//Additional Resoureces\\n//https://leetcode.com/problems/process-restricted-friend-requests/discuss/2489402/Java-Solution-or-Union-Find-or-Disjoint-Sets-or-Without-rank\\n//https://www.youtube.com/watch?v=EVnIVVF-Jfs\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] arr=new int[n];\\n        for(int i=0;i<n;i++){\\n            arr[i]=i;\\n        }\\n        int j=0;\\n        boolean[] ret=new boolean[requests.length];\\n        for(int[] a:requests){\\n            int x=find(a[0],arr);\\n            int y=find(a[1],arr);\\n            boolean flag=true;\\n            for(int i=0;i<restrictions.length;i++){\\n                int l=find(restrictions[i][0],arr);\\n                int r=find(restrictions[i][1],arr);\\n                if(((l==x && r==y) || (l==y && r==x))){\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            ret[j++]=flag;\\n            if(flag){\\n                union(x,y,arr);\\n            }\\n        }\\n        return ret;\\n    }\\n    private void union(int a,int b,int[] arr){\\n        int x=find(a,arr);\\n        int y=find(b,arr);\\n        if(x==y) return;\\n        arr[y]=x;\\n    }\\n    private int find(int x,int[] arr){\\n        if(arr[x]==x) return x;\\n        return find(arr[x],arr);\\n    }\\n}\\n\\n\\n\\n//Additional Resoureces\\n//https://leetcode.com/problems/process-restricted-friend-requests/discuss/2489402/Java-Solution-or-Union-Find-or-Disjoint-Sets-or-Without-rank\\n//https://www.youtube.com/watch?v=EVnIVVF-Jfs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533585,
                "title": "python-solution-no-union-find-beats-70",
                "content": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        personToGroup, groupToPeople = [0 for _ in range(n)], [set() for _ in range(n)]\\n        for i in range(n):\\n            personToGroup[i] = i\\n            groupToPeople[i].add(i)\\n        personToRestricted = [[] for _ in range(n)]\\n        for restriction in restrictions:\\n            personToRestricted[restriction[0]].append(restriction[1])\\n            personToRestricted[restriction[1]].append(restriction[0])\\n        res, w = [False for _ in range(len(requests))], 0\\n        for request in requests:\\n            grp1, grp2 = personToGroup[request[0]], personToGroup[request[1]]\\n            if grp1 == grp2:\\n                res[w] = True\\n                w += 1\\n                continue\\n            if len(groupToPeople[grp1]) > len(groupToPeople[grp2]):\\n                grp1, grp2 = grp2, grp1\\n            forbidden, group2 = False, groupToPeople[grp2]\\n            for p1 in groupToPeople[grp1]:\\n                for restricted in personToRestricted[p1]:\\n                    if restricted in group2:\\n                        forbidden = True\\n                        break\\n                if forbidden:\\n                    break\\n            res[w] = not forbidden\\n            w += 1\\n            if not forbidden:\\n                for p1 in groupToPeople[grp1]:\\n                    personToGroup[p1] = grp2\\n                    group2.add(p1)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        personToGroup, groupToPeople = [0 for _ in range(n)], [set() for _ in range(n)]\\n        for i in range(n):\\n            personToGroup[i] = i\\n            groupToPeople[i].add(i)\\n        personToRestricted = [[] for _ in range(n)]\\n        for restriction in restrictions:\\n            personToRestricted[restriction[0]].append(restriction[1])\\n            personToRestricted[restriction[1]].append(restriction[0])\\n        res, w = [False for _ in range(len(requests))], 0\\n        for request in requests:\\n            grp1, grp2 = personToGroup[request[0]], personToGroup[request[1]]\\n            if grp1 == grp2:\\n                res[w] = True\\n                w += 1\\n                continue\\n            if len(groupToPeople[grp1]) > len(groupToPeople[grp2]):\\n                grp1, grp2 = grp2, grp1\\n            forbidden, group2 = False, groupToPeople[grp2]\\n            for p1 in groupToPeople[grp1]:\\n                for restricted in personToRestricted[p1]:\\n                    if restricted in group2:\\n                        forbidden = True\\n                        break\\n                if forbidden:\\n                    break\\n            res[w] = not forbidden\\n            w += 1\\n            if not forbidden:\\n                for p1 in groupToPeople[grp1]:\\n                    personToGroup[p1] = grp2\\n                    group2.add(p1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513417,
                "title": "proper-union-find",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] ans = new boolean[requests.length];\\n        DSU dsu = new DSU(n);\\n        \\n        for(int i=0; i<requests.length; i++) {\\n            int u = requests[i][0], v = requests[i][1];\\n            int up = dsu.find(u), vp = dsu.find(v);\\n            ans[i] = true;\\n            \\n            for(int[] restriction : restrictions) {\\n                int x = restriction[0], y = restriction[1];\\n                int xp = dsu.find(x), yp = dsu.find(y);\\n                \\n                if( (xp == up && yp == vp) || (yp == up && xp == vp) ) {\\n                    ans[i] = false;\\n                    break;\\n                } \\n            }\\n            if( ans[i] )\\n                dsu.union(up, vp);\\n        }\\n        return ans;\\n    }\\n}\\nclass DSU {\\n    private int[] parent, rank;\\n    \\n    public DSU(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        \\n        for(int i=0; i<n; i++)\\n            parent[i] = i;\\n    }\\n    \\n    public int find(int x) {\\n        if( parent[x] != x )\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    public boolean union(int x, int y) {\\n        int px = find(x), py = find(y);\\n        \\n        if( px == py ) return false;\\n        \\n        if( rank[py] > rank[px] ) \\n            parent[px] = py;\\n        else if( rank[px] > rank[py] )\\n            parent[py] = px;\\n        else {\\n            parent[py] = px;\\n            rank[px] += 1;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] ans = new boolean[requests.length];\\n        DSU dsu = new DSU(n);\\n        \\n        for(int i=0; i<requests.length; i++) {\\n            int u = requests[i][0], v = requests[i][1];\\n            int up = dsu.find(u), vp = dsu.find(v);\\n            ans[i] = true;\\n            \\n            for(int[] restriction : restrictions) {\\n                int x = restriction[0], y = restriction[1];\\n                int xp = dsu.find(x), yp = dsu.find(y);\\n                \\n                if( (xp == up && yp == vp) || (yp == up && xp == vp) ) {\\n                    ans[i] = false;\\n                    break;\\n                } \\n            }\\n            if( ans[i] )\\n                dsu.union(up, vp);\\n        }\\n        return ans;\\n    }\\n}\\nclass DSU {\\n    private int[] parent, rank;\\n    \\n    public DSU(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        \\n        for(int i=0; i<n; i++)\\n            parent[i] = i;\\n    }\\n    \\n    public int find(int x) {\\n        if( parent[x] != x )\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    public boolean union(int x, int y) {\\n        int px = find(x), py = find(y);\\n        \\n        if( px == py ) return false;\\n        \\n        if( rank[py] > rank[px] ) \\n            parent[px] = py;\\n        else if( rank[px] > rank[py] )\\n            parent[py] = px;\\n        else {\\n            parent[py] = px;\\n            rank[px] += 1;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2509686,
                "title": "c-elementary-solution-beats-99-8-no-union-find",
                "content": "Given n = number of people = number of restrictions = number of requests, this solution is O(n\\xB2), better than the typical O(n\\xB2log(n)) union-find solution that uses path compression without union by size/rank.\\n\\nhttps://leetcode.com/submissions/detail/788040081/\\nRuntime: 70 ms, faster than 99.79% of C++ online submissions for Process Restricted Friend Requests.\\nMemory Usage: 28.8 MB, less than 29.07% of C++ online submissions for Process Restricted Friend Requests.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<int> p2g(n);\\n        for (int i = 0; i < n; ++i) p2g[i] = i;\\n        \\n        vector<unordered_set<int>> g2p(n);\\n        for (int i = 0; i < n; ++i) g2p[i].insert(i);\\n        \\n        vector<vector<int>> p2r(n);\\n        for (auto &v: restrictions) {\\n            p2r[v[0]].push_back(v[1]);\\n            p2r[v[1]].push_back(v[0]);\\n        }\\n        \\n        vector<bool> result(requests.size());\\n        int w = 0;\\n        for (auto &v: requests) {\\n            int g1 = p2g[v[0]];\\n            int g2 = p2g[v[1]];\\n            if (g1 == g2) {\\n                result[w++] = true;\\n                continue;\\n            }\\n            if (g2p[g1].size() > g2p[g2].size()) {\\n                swap(g1, g2);\\n            }\\n            \\n            bool forbidden = false;\\n            auto &group2 = g2p[g2];\\n            for (int p1: g2p[g1]) {\\n                for (int r: p2r[p1]) {\\n                    if (group2.count(r)) {\\n                        forbidden = true;\\n                        break;\\n                    }\\n                }\\n                if (forbidden) break;\\n            }\\n            result[w++] = !forbidden;\\n            \\n            if (!forbidden) {\\n                for (int p1: g2p[g1]) {\\n                    p2g[p1] = g2;\\n                    group2.insert(p1);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<int> p2g(n);\\n        for (int i = 0; i < n; ++i) p2g[i] = i;\\n        \\n        vector<unordered_set<int>> g2p(n);\\n        for (int i = 0; i < n; ++i) g2p[i].insert(i);\\n        \\n        vector<vector<int>> p2r(n);\\n        for (auto &v: restrictions) {\\n            p2r[v[0]].push_back(v[1]);\\n            p2r[v[1]].push_back(v[0]);\\n        }\\n        \\n        vector<bool> result(requests.size());\\n        int w = 0;\\n        for (auto &v: requests) {\\n            int g1 = p2g[v[0]];\\n            int g2 = p2g[v[1]];\\n            if (g1 == g2) {\\n                result[w++] = true;\\n                continue;\\n            }\\n            if (g2p[g1].size() > g2p[g2].size()) {\\n                swap(g1, g2);\\n            }\\n            \\n            bool forbidden = false;\\n            auto &group2 = g2p[g2];\\n            for (int p1: g2p[g1]) {\\n                for (int r: p2r[p1]) {\\n                    if (group2.count(r)) {\\n                        forbidden = true;\\n                        break;\\n                    }\\n                }\\n                if (forbidden) break;\\n            }\\n            result[w++] = !forbidden;\\n            \\n            if (!forbidden) {\\n                for (int p1: g2p[g1]) {\\n                    p2g[p1] = g2;\\n                    group2.insert(p1);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503463,
                "title": "c-solution-using-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    class UnionFind {\\n        vector<int> st;\\n        public:\\n        UnionFind(int n) {\\n            st = vector<int> (n);\\n            for (int i = 0; i < n; i++) {\\n                st[i] = i;\\n            }\\n        }\\n        int find(int v) {\\n            if (v == st[v]) return v;\\n            return st[v] = find(st[v]);\\n        }\\n        void merge(int u, int v) {\\n            int x = find(u);\\n            int y = find(v);\\n            if (x != y) {\\n                st[x] = y;\\n            }\\n        }\\n    };\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int len = requests.size();\\n        UnionFind uf(n);\\n        vector<bool> sol(len);\\n        for (int i = 0; i < len; i++) {\\n            int u = requests[i][0];\\n            int v = requests[i][1];\\n            int x = uf.find(u);\\n            int y = uf.find(v);\\n            if (x == y) {\\n                sol[i] = true;\\n                continue;\\n            }\\n            bool fri = true;\\n            for (vector<int>& res : restrictions) {\\n                int rep1 = uf.find(res[0]);\\n                int rep2 = uf.find(res[1]);\\n                if (rep1 == x && rep2 == y || rep1 == y && rep2 == x) {\\n                    fri = false;\\n                    break;\\n                }\\n            }\\n            if (fri) {\\n                sol[i] = true;\\n                uf.merge(u, v);\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    class UnionFind {\\n        vector<int> st;\\n        public:\\n        UnionFind(int n) {\\n            st = vector<int> (n);\\n            for (int i = 0; i < n; i++) {\\n                st[i] = i;\\n            }\\n        }\\n        int find(int v) {\\n            if (v == st[v]) return v;\\n            return st[v] = find(st[v]);\\n        }\\n        void merge(int u, int v) {\\n            int x = find(u);\\n            int y = find(v);\\n            if (x != y) {\\n                st[x] = y;\\n            }\\n        }\\n    };\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int len = requests.size();\\n        UnionFind uf(n);\\n        vector<bool> sol(len);\\n        for (int i = 0; i < len; i++) {\\n            int u = requests[i][0];\\n            int v = requests[i][1];\\n            int x = uf.find(u);\\n            int y = uf.find(v);\\n            if (x == y) {\\n                sol[i] = true;\\n                continue;\\n            }\\n            bool fri = true;\\n            for (vector<int>& res : restrictions) {\\n                int rep1 = uf.find(res[0]);\\n                int rep2 = uf.find(res[1]);\\n                if (rep1 == x && rep2 == y || rep1 == y && rep2 == x) {\\n                    fri = false;\\n                    break;\\n                }\\n            }\\n            if (fri) {\\n                sol[i] = true;\\n                uf.merge(u, v);\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2348990,
                "title": "java-beats-98-with-comments-and-complexity-analysis",
                "content": "```\\nclass Solution {\\n    \\n    int findParent(int parent[], int id) {\\n        if(parent[id]!=id){\\n            parent[id]=findParent(parent,parent[id]);\\n        }\\n        return parent[id];\\n    }\\n    \\n    void union(int parent[], int rank[], int x, int y) {\\n        if(rank[x]<rank[y]){\\n            parent[x]=y;\\n        } else if(rank[y]<rank[x]){\\n            parent[y]=x;\\n        } else {\\n            parent[y]=x;\\n            rank[x]++;\\n        }\\n    }\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n\\n        int[] parent=new int[n];\\n        int[] rank=new int[n];\\n        boolean[] result=new boolean[requests.length];\\n        \\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            rank[i]=0;\\n        }\\n        \\n        for(int i=0;i<requests.length;i++){\\n            int firstParent=findParent(parent,requests[i][0]);\\n            int secondParent=findParent(parent,requests[i][1]);\\n            if(firstParent==secondParent){\\n                result[i]=true;\\n                continue;\\n            }\\n            \\n            boolean flag=true;\\n            \\n            for(int j=0;j<restrictions.length;j++){\\n                int firstRest=findParent(parent,restrictions[j][0]);\\n                int secondRest=findParent(parent,restrictions[j][1]);\\n                if((firstRest==firstParent && secondRest==secondParent)||(firstParent==secondRest && secondParent==firstRest)) {\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            \\n            result[i]=flag;\\n            if(flag){\\n                union(parent,rank,firstParent,secondParent);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int findParent(int parent[], int id) {\\n        if(parent[id]!=id){\\n            parent[id]=findParent(parent,parent[id]);\\n        }\\n        return parent[id];\\n    }\\n    \\n    void union(int parent[], int rank[], int x, int y) {\\n        if(rank[x]<rank[y]){\\n            parent[x]=y;\\n        } else if(rank[y]<rank[x]){\\n            parent[y]=x;\\n        } else {\\n            parent[y]=x;\\n            rank[x]++;\\n        }\\n    }\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n\\n        int[] parent=new int[n];\\n        int[] rank=new int[n];\\n        boolean[] result=new boolean[requests.length];\\n        \\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            rank[i]=0;\\n        }\\n        \\n        for(int i=0;i<requests.length;i++){\\n            int firstParent=findParent(parent,requests[i][0]);\\n            int secondParent=findParent(parent,requests[i][1]);\\n            if(firstParent==secondParent){\\n                result[i]=true;\\n                continue;\\n            }\\n            \\n            boolean flag=true;\\n            \\n            for(int j=0;j<restrictions.length;j++){\\n                int firstRest=findParent(parent,restrictions[j][0]);\\n                int secondRest=findParent(parent,restrictions[j][1]);\\n                if((firstRest==firstParent && secondRest==secondParent)||(firstParent==secondRest && secondParent==firstRest)) {\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            \\n            result[i]=flag;\\n            if(flag){\\n                union(parent,rank,firstParent,secondParent);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313865,
                "title": "python-o-n-requests-restrictions-union-find",
                "content": "We keep a union-find data structure with history, which contains all the successful friend requests. Then, for each request, we try it by adding it to the union-find, and if there is a restriction conflict, we undo. The modification for history is to store the previous union information, as well as which nodes were processed last (dirty), in order to not compress their paths.\\n\\n\\n```python\\nclass UF:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.heights = [0] * n\\n        self.history = []\\n        self.dirty = [False] * n\\n    \\n    def find(self, x):\\n        y = x\\n        while self.parent[y] != y:\\n            y = self.parent[y]\\n            if not self.dirty[y]:\\n                self.parent[x] = y\\n        return y\\n    \\n    def union(self, x, y):\\n        x = self.find(x)\\n        y = self.find(y)\\n        self.history.append((x, y, self.heights[x], self.heights[y]))\\n        self.dirty[x] = True\\n        self.dirty[y] = True\\n        if x == y:\\n            pass\\n        elif self.heights[x] < self.heights[y]:\\n            self.parent[x] = y    \\n        elif self.heights[y] < self.heights[x]:\\n            self.parent[y] = x\\n        else:\\n            self.parent[y] = x\\n            self.heights[x] += 1\\n    \\n    def undo(self):\\n        x, y, h_x, h_y = self.history.pop()\\n        self.parent[x] = x\\n        self.parent[y] = y\\n        self.heights[x] = h_x\\n        self.heights[y] = h_y\\n        self.dirty[x] = False\\n        self.dirty[y] = False\\n        \\n    def clean(self):\\n        x, y, _, _ = self.history.pop()\\n        self.dirty[x] = False\\n        self.dirty[y] = False\\n\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        uf = UF(n)\\n        ans = [True] * len(requests)\\n        for i, (x, y) in enumerate(requests):\\n            uf.union(x, y)\\n            if any(uf.find(u) == uf.find(v) for u, v in restrictions):\\n                uf.undo()\\n                ans[i] = False\\n            else:\\n                uf.clean()\\n        return ans\\n\\t\\t```",
                "solutionTags": [],
                "code": "```python\\nclass UF:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.heights = [0] * n\\n        self.history = []\\n        self.dirty = [False] * n\\n    \\n    def find(self, x):\\n        y = x\\n        while self.parent[y] != y:\\n            y = self.parent[y]\\n            if not self.dirty[y]:\\n                self.parent[x] = y\\n        return y\\n    \\n    def union(self, x, y):\\n        x = self.find(x)\\n        y = self.find(y)\\n        self.history.append((x, y, self.heights[x], self.heights[y]))\\n        self.dirty[x] = True\\n        self.dirty[y] = True\\n        if x == y:\\n            pass\\n        elif self.heights[x] < self.heights[y]:\\n            self.parent[x] = y    \\n        elif self.heights[y] < self.heights[x]:\\n            self.parent[y] = x\\n        else:\\n            self.parent[y] = x\\n            self.heights[x] += 1\\n    \\n    def undo(self):\\n        x, y, h_x, h_y = self.history.pop()\\n        self.parent[x] = x\\n        self.parent[y] = y\\n        self.heights[x] = h_x\\n        self.heights[y] = h_y\\n        self.dirty[x] = False\\n        self.dirty[y] = False\\n        \\n    def clean(self):\\n        x, y, _, _ = self.history.pop()\\n        self.dirty[x] = False\\n        self.dirty[y] = False\\n\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        uf = UF(n)\\n        ans = [True] * len(requests)\\n        for i, (x, y) in enumerate(requests):\\n            uf.union(x, y)\\n            if any(uf.find(u) == uf.find(v) for u, v in restrictions):\\n                uf.undo()\\n                ans[i] = False\\n            else:\\n                uf.clean()\\n        return ans\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2262107,
                "title": "python-unionfind-beats-100",
                "content": "```\\nclass UnionFind2076:\\n    def __init__(self, size, restrictions):\\n        self.parent = [i for i in range(size)]\\n        self.restrictions = [0] * size\\n        self.all = [(1<<i) for i in range(size)]\\n        for a, b in restrictions:\\n            self.restrictions[a] |= (1<<b)\\n            self.restrictions[b] |= (1<<a)\\n\\n    def find(self, n):\\n        m = n\\n        while self.parent[m] != m:\\n            m = self.parent[m]\\n        while self.parent[n] != m:\\n            old_parent = self.parent[n]\\n            self.parent[n] = m\\n            n = old_parent\\n        return m\\n\\n    def union(self, m, n):\\n        root_m, root_n = self.find(m), self.find(n)\\n        if root_m == root_n:\\n            return True\\n        if self.restrictions[root_m] & self.all[root_n]:\\n            return False\\n        self.parent[root_m] = root_n\\n        self.all[root_n] |= self.all[root_m]\\n        self.restrictions[root_n] |= self.restrictions[root_m]\\n        return True\\n\\nclass Solution:\\n    #2076\\n    def friendRequests(self, n: int, restrictions, requests):\\n        uf = UnionFind2076(n, restrictions)\\n        res = []\\n        for a,b in requests:\\n            res.append(uf.union(a,b))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind2076:\\n    def __init__(self, size, restrictions):\\n        self.parent = [i for i in range(size)]\\n        self.restrictions = [0] * size\\n        self.all = [(1<<i) for i in range(size)]\\n        for a, b in restrictions:\\n            self.restrictions[a] |= (1<<b)\\n            self.restrictions[b] |= (1<<a)\\n\\n    def find(self, n):\\n        m = n\\n        while self.parent[m] != m:\\n            m = self.parent[m]\\n        while self.parent[n] != m:\\n            old_parent = self.parent[n]\\n            self.parent[n] = m\\n            n = old_parent\\n        return m\\n\\n    def union(self, m, n):\\n        root_m, root_n = self.find(m), self.find(n)\\n        if root_m == root_n:\\n            return True\\n        if self.restrictions[root_m] & self.all[root_n]:\\n            return False\\n        self.parent[root_m] = root_n\\n        self.all[root_n] |= self.all[root_m]\\n        self.restrictions[root_n] |= self.restrictions[root_m]\\n        return True\\n\\nclass Solution:\\n    #2076\\n    def friendRequests(self, n: int, restrictions, requests):\\n        uf = UnionFind2076(n, restrictions)\\n        res = []\\n        for a,b in requests:\\n            res.append(uf.union(a,b))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239844,
                "title": "dsu",
                "content": "```\\nclass disjoint_set{\\n    vector<int> parent, rank;\\n    public:\\n    disjoint_set(int N){\\n        parent.resize(N);\\n        iota(parent.begin(),parent.end(),0);\\n        rank.assign(N,1);\\n    }\\n    \\n    int findParent(int u){\\n        if(parent[u]==u) return u;\\n        return parent[u]=findParent(parent[u]);\\n    }\\n    \\n    void _union(int u , int v){\\n         u = findParent(u);\\n         v = findParent(v);\\n        \\n        if(rank[u] < rank[v]) parent[u]=v;   \\n        else if(rank[v] < rank[u]) parent[v]=u;\\n        else{\\n            parent[v]=u;\\n            rank[u]++;\\n        }\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        disjoint_set s(n);\\n        vector<bool> ans;\\n        \\n        for(auto &req:requests){\\n            int u = s.findParent(req[0]) , v = s.findParent(req[1]);\\n            //already connected indirectly, can also connext directly\\n             \\n            if(u==v){\\n                ans.push_back(true);\\n            }else{\\n                bool flag=true;\\n                for(auto &restriction : restrictions){\\n                    int x = s.findParent(restriction[0]), y = s.findParent(restriction[1]);\\n                    if((x==u and y==v) or (x==v and y==u)){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n                ans.push_back(flag);\\n                if(flag) s._union(u,v);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass disjoint_set{\\n    vector<int> parent, rank;\\n    public:\\n    disjoint_set(int N){\\n        parent.resize(N);\\n        iota(parent.begin(),parent.end(),0);\\n        rank.assign(N,1);\\n    }\\n    \\n    int findParent(int u){\\n        if(parent[u]==u) return u;\\n        return parent[u]=findParent(parent[u]);\\n    }\\n    \\n    void _union(int u , int v){\\n         u = findParent(u);\\n         v = findParent(v);\\n        \\n        if(rank[u] < rank[v]) parent[u]=v;   \\n        else if(rank[v] < rank[u]) parent[v]=u;\\n        else{\\n            parent[v]=u;\\n            rank[u]++;\\n        }\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        disjoint_set s(n);\\n        vector<bool> ans;\\n        \\n        for(auto &req:requests){\\n            int u = s.findParent(req[0]) , v = s.findParent(req[1]);\\n            //already connected indirectly, can also connext directly\\n             \\n            if(u==v){\\n                ans.push_back(true);\\n            }else{\\n                bool flag=true;\\n                for(auto &restriction : restrictions){\\n                    int x = s.findParent(restriction[0]), y = s.findParent(restriction[1]);\\n                    if((x==u and y==v) or (x==v and y==u)){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n                ans.push_back(flag);\\n                if(flag) s._union(u,v);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210913,
                "title": "python-union-find",
                "content": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        def par(i):\\n            while i!=p[i]:\\n                i=p[i]\\n            return i\\n        def union(i,j):\\n            i=par(i)\\n            j=par(j)\\n            p[i]=j\\n        res=[]\\n        p=[i for i in range(n)]\\n        for a,b in requests:\\n            if par(a)==par(b):\\n                res.append(True)\\n                continue\\n            flag=True\\n            for i,j in restrictions:\\n                if (par(i)==par(a) and par(j)==par(b)) or (par(i)==par(b) and par(j)==par(a)):\\n                    flag=False\\n                    break\\n            if flag:\\n                res.append(True)\\n                union(a,b)\\n            else:\\n                res.append(False)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        def par(i):\\n            while i!=p[i]:\\n                i=p[i]\\n            return i\\n        def union(i,j):\\n            i=par(i)\\n            j=par(j)\\n            p[i]=j\\n        res=[]\\n        p=[i for i in range(n)]\\n        for a,b in requests:\\n            if par(a)==par(b):\\n                res.append(True)\\n                continue\\n            flag=True\\n            for i,j in restrictions:\\n                if (par(i)==par(a) and par(j)==par(b)) or (par(i)==par(b) and par(j)==par(a)):\\n                    flag=False\\n                    break\\n            if flag:\\n                res.append(True)\\n                union(a,b)\\n            else:\\n                res.append(False)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176317,
                "title": "java-17ms-with-bitset-100-modular-readable",
                "content": "This bitset solution should work even if the constraint is a bit higher because bitset and/or methods time complexity is O(n/32) or O(n/64). \\n\\n- Starting out, each person has their own group with their own banlist.\\n\\n- Whenever a friend request is successful, we merge these two groups, so that the leader of the group has a full list of members and ban list.\\n\\n- To check if group `A` and `B` can be merged, we `bitset.and()` group A member list with the group B banlist and vice versa.\\nThe resulting numbers must **both** be 0 otherwise we can\\'t merge them.\\n\\n- To merge group `A` and `B`, we use `bitset.or()` to set all the bits.\\n\\nI only submitted it once and scored 17ms at 100% Speed, which is so fast that there is no nearby yellow bars.\\n```Java\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        Group[] groups = new Group[n];\\n        Arrays.setAll(groups, o -> new Group(o)); // populate member list (themselves)\\n        for (int[] r : restrictions){ // populate banlist\\n            groups[r[0]].ban(r[1]);\\n            groups[r[1]].ban(r[0]);\\n        }\\n\\n        UF uf = new UF(n);\\n        boolean[] ans = new boolean[requests.length];\\n        for (int i = 0; i < requests.length; i++){ // union them.\\n            ans[i] = uf.union(requests[i][0], requests[i][1], groups);\\n        }\\n        return ans;\\n    }\\n\\n    private class Group {\\n        BitSet member = new BitSet();\\n        BitSet blacklist = new BitSet();\\n        Group(int n){\\n            member.set(n);\\n        }\\n\\n        void ban(int n){\\n            blacklist.set(n);\\n        }\\n\\n        void merge(Group other){\\n            member.or(other.member);\\n            blacklist.or(other.blacklist);\\n        }\\n\\n        boolean canFit(Group other){\\n            BitSet oMember = (BitSet)other.member.clone();\\n            oMember.and(blacklist);\\n            return oMember.cardinality()==0; // must be 0\\n        }\\n    }\\n\\n    private class UF {\\n        int[] parent;\\n        int[] rank;\\n        UF (int n){\\n            parent = IntStream.range(0, n).toArray();\\n            rank = new int[n];\\n        }\\n\\n        int find(int x){\\n            return x == parent[x]? x : (parent[x]=find(parent[x]));\\n        }\\n\\n        boolean union(int x, int y, Group[] groups){\\n            int xRoot = find(x);\\n            int yRoot = find(y);\\n            if (xRoot==yRoot)\\n                return true;\\n            if (!groups[xRoot].canFit(groups[yRoot]) || !groups[yRoot].canFit(groups[xRoot]))\\n                return false;\\n            if (rank[xRoot]>rank[yRoot]){\\n                parent[yRoot]=xRoot;\\n                groups[xRoot].merge(groups[yRoot]);\\n            }else{\\n                parent[xRoot]=yRoot;\\n                groups[yRoot].merge(groups[xRoot]);\\n                if (rank[xRoot]==rank[yRoot]){\\n                    rank[yRoot]++;\\n                }\\n            }\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        Group[] groups = new Group[n];\\n        Arrays.setAll(groups, o -> new Group(o)); // populate member list (themselves)\\n        for (int[] r : restrictions){ // populate banlist\\n            groups[r[0]].ban(r[1]);\\n            groups[r[1]].ban(r[0]);\\n        }\\n\\n        UF uf = new UF(n);\\n        boolean[] ans = new boolean[requests.length];\\n        for (int i = 0; i < requests.length; i++){ // union them.\\n            ans[i] = uf.union(requests[i][0], requests[i][1], groups);\\n        }\\n        return ans;\\n    }\\n\\n    private class Group {\\n        BitSet member = new BitSet();\\n        BitSet blacklist = new BitSet();\\n        Group(int n){\\n            member.set(n);\\n        }\\n\\n        void ban(int n){\\n            blacklist.set(n);\\n        }\\n\\n        void merge(Group other){\\n            member.or(other.member);\\n            blacklist.or(other.blacklist);\\n        }\\n\\n        boolean canFit(Group other){\\n            BitSet oMember = (BitSet)other.member.clone();\\n            oMember.and(blacklist);\\n            return oMember.cardinality()==0; // must be 0\\n        }\\n    }\\n\\n    private class UF {\\n        int[] parent;\\n        int[] rank;\\n        UF (int n){\\n            parent = IntStream.range(0, n).toArray();\\n            rank = new int[n];\\n        }\\n\\n        int find(int x){\\n            return x == parent[x]? x : (parent[x]=find(parent[x]));\\n        }\\n\\n        boolean union(int x, int y, Group[] groups){\\n            int xRoot = find(x);\\n            int yRoot = find(y);\\n            if (xRoot==yRoot)\\n                return true;\\n            if (!groups[xRoot].canFit(groups[yRoot]) || !groups[yRoot].canFit(groups[xRoot]))\\n                return false;\\n            if (rank[xRoot]>rank[yRoot]){\\n                parent[yRoot]=xRoot;\\n                groups[xRoot].merge(groups[yRoot]);\\n            }else{\\n                parent[xRoot]=yRoot;\\n                groups[yRoot].merge(groups[xRoot]);\\n                if (rank[xRoot]==rank[yRoot]){\\n                    rank[yRoot]++;\\n                }\\n            }\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176072,
                "title": "c-easy-to-understand-dsu-implementation",
                "content": "```\\nclass DSU\\n{\\n    public:\\n    int findParent(int node,vector<int>& par)\\n    {\\n        if(par[node]==node)return node;\\n        return par[node]=findParent(par[node],par);\\n    }\\n    void Union(int u,int v,vector<int> &size,vector<int> &par)\\n    {\\n        int pu=findParent(u,par);\\n        int pv=findParent(v,par);\\n        if(pu==pv)return;\\n        if(size[pu]<=size[pv])\\n        {\\n            par[pu]=pv;\\n            size[pv]++;\\n        }\\n        else\\n        {\\n            par[pv]=pu;\\n            size[pu]++;\\n        }\\n    }\\n    bool isConnected(int u,int v,vector<int> &par)\\n    {\\n        int pu=findParent(u,par);\\n        int pv=findParent(v,par);\\n        if(pu==pv)return 1;\\n        return 0;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& re, vector<vector<int>>& r) {\\n        DSU dsu;\\n        vector<int> parent(n,0),size(n,1);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n        }\\n        vector<bool> ans;\\n        for(int i=0;i<r.size();i++)\\n        {\\n            int x,y;\\n            x=dsu.findParent(r[i][0],parent);\\n            y=dsu.findParent(r[i][1],parent);\\n            bool ok=true;\\n            for(int j=0;j<re.size();j++)\\n            {\\n                int x1,y1;\\n                x1=dsu.findParent(re[j][0],parent);\\n                y1=dsu.findParent(re[j][1],parent);\\n                if((x==x1&&y==y1)||(x==y1&&y==x1))\\n                {\\n                    ok=false;\\n                    break;\\n                }\\n            }\\n            if(ok)\\n            {\\n                dsu.Union(x,y,size,parent);\\n            }\\n            ans.push_back(ok);\\n        }   \\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass DSU\\n{\\n    public:\\n    int findParent(int node,vector<int>& par)\\n    {\\n        if(par[node]==node)return node;\\n        return par[node]=findParent(par[node],par);\\n    }\\n    void Union(int u,int v,vector<int> &size,vector<int> &par)\\n    {\\n        int pu=findParent(u,par);\\n        int pv=findParent(v,par);\\n        if(pu==pv)return;\\n        if(size[pu]<=size[pv])\\n        {\\n            par[pu]=pv;\\n            size[pv]++;\\n        }\\n        else\\n        {\\n            par[pv]=pu;\\n            size[pu]++;\\n        }\\n    }\\n    bool isConnected(int u,int v,vector<int> &par)\\n    {\\n        int pu=findParent(u,par);\\n        int pv=findParent(v,par);\\n        if(pu==pv)return 1;\\n        return 0;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& re, vector<vector<int>>& r) {\\n        DSU dsu;\\n        vector<int> parent(n,0),size(n,1);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n        }\\n        vector<bool> ans;\\n        for(int i=0;i<r.size();i++)\\n        {\\n            int x,y;\\n            x=dsu.findParent(r[i][0],parent);\\n            y=dsu.findParent(r[i][1],parent);\\n            bool ok=true;\\n            for(int j=0;j<re.size();j++)\\n            {\\n                int x1,y1;\\n                x1=dsu.findParent(re[j][0],parent);\\n                y1=dsu.findParent(re[j][1],parent);\\n                if((x==x1&&y==y1)||(x==y1&&y==x1))\\n                {\\n                    ok=false;\\n                    break;\\n                }\\n            }\\n            if(ok)\\n            {\\n                dsu.Union(x,y,size,parent);\\n            }\\n            ans.push_back(ok);\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133522,
                "title": "c-disjoint-set-union-find-solution-graph",
                "content": "```\\nvector<int> parent,sz;\\n    int find(int x){\\n       if(x==parent[x]) return x;\\n       return find(parent[x]);\\n    }\\n    void make_union(int x,int y){\\n       int a=find(x);\\n       int b=find(y);\\n       if(a!=b){\\n         if(sz[a]<sz[b]){\\n            parent[a]=b;\\n            sz[b]+=sz[a];\\n         }\\n         else{\\n             parent[b]=a;\\n             sz[a]+=sz[b];\\n         }\\n       }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests){\\n       parent.resize(n+1);\\n       sz.resize(n+1);\\n       for(int i=0;i<n;i++) parent[i]=i,sz[i]+=1;\\n       vector<bool> ans(requests.size(),true);\\n       for(int i=0;i<requests.size();i++){\\n          int a=find(requests[i][0]),b=find(requests[i][1]);\\n          make_union(requests[i][0],requests[i][1]);\\n          bool flag=true;\\n          for(int j=0;j<restrictions.size();j++){\\n            if(find(restrictions[j][0])==find(restrictions[j][1])){\\n              flag=false;\\n              break;\\n            }\\n          }\\n          if(!flag){\\n             parent[a]=a,parent[b]=b;\\n             ans[i]=false;\\n          }\\n       }\\n       return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nvector<int> parent,sz;\\n    int find(int x){\\n       if(x==parent[x]) return x;\\n       return find(parent[x]);\\n    }\\n    void make_union(int x,int y){\\n       int a=find(x);\\n       int b=find(y);\\n       if(a!=b){\\n         if(sz[a]<sz[b]){\\n            parent[a]=b;\\n            sz[b]+=sz[a];\\n         }\\n         else{\\n             parent[b]=a;\\n             sz[a]+=sz[b];\\n         }\\n       }\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests){\\n       parent.resize(n+1);\\n       sz.resize(n+1);\\n       for(int i=0;i<n;i++) parent[i]=i,sz[i]+=1;\\n       vector<bool> ans(requests.size(),true);\\n       for(int i=0;i<requests.size();i++){\\n          int a=find(requests[i][0]),b=find(requests[i][1]);\\n          make_union(requests[i][0],requests[i][1]);\\n          bool flag=true;\\n          for(int j=0;j<restrictions.size();j++){\\n            if(find(restrictions[j][0])==find(restrictions[j][1])){\\n              flag=false;\\n              break;\\n            }\\n          }\\n          if(!flag){\\n             parent[a]=a,parent[b]=b;\\n             ans[i]=false;\\n          }\\n       }\\n       return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2128275,
                "title": "simple-c-union-find-bitmask-beat-99",
                "content": "Use Union Find to group friends among 0..n-1 based on \"requests\".\\n\\nSuppose a request (x, y), think about group(x) and group(y) -- the criteria to allow x to be y\\'s friend (or vice versa) is, \\n     group(x) == group(y) ***OR*** \\n\\t everyone in group(x) is not in group(y)\\'s restriction list ***AND*** everyone in group(y) is not in group(x)\\'s restriction list.\\n\\nAll members of group(x) or group(y) can be collected during Union Find, as well as all members of restriction list (exclusive list). Use Bitmask (bitset) to simplify the operations.\\n\\n\\n```\\nclass Solution {\\n        // union find\\n        vector<int> dsu;\\n        void Init(int n) {\\n            dsu.resize(n);\\n            iota(dsu.begin(), dsu.end(), 0);\\n        }\\n\\n        int Find(int i) {\\n            while(dsu[i]!=i) i=dsu[i];\\n            return i;\\n        };\\n        \\n        void Union(int i, int j) {\\n            dsu[i]=dsu[j]=dsu[Find(i)]=Find(j);\\n        };\\n        \\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        Init(n);\\n        \\n        // inclusive list and exclusive list of a group\\n        vector<bitset<2000>> incl(n, 0), excl(n, 0);\\n        for (int i=0; i<n; i++) incl[i][i]=true;\\n        for (auto& e: restrictions) \\n            excl[e[0]][e[1]]= excl[e[1]][e[0]]=true;\\n        \\n        vector<bool> res;\\n        for (auto& e: requests) {\\n            int x=e[0], y=e[1], x_=Find(x), y_=Find(y);\\n            //the matching criteria on group x_ and y_\\n            bool pass = (x_==y_) || (incl[x_] & excl[y_]).none() && (incl[y_] & excl[x_]).none();\\n            res.push_back(pass);\\n            \\n            if (pass && x_!=y_ ) {\\n                Union(x_, y_);\\n                incl[Find(y_)] = incl[x_] | incl[y_];\\n                excl[Find(y_)] = excl[x_] | excl[y_];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n        // union find\\n        vector<int> dsu;\\n        void Init(int n) {\\n            dsu.resize(n);\\n            iota(dsu.begin(), dsu.end(), 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2115026,
                "title": "python3-set-union-based-solution",
                "content": "```\\n\"\"\"https://leetcode.com/problems/process-restricted-friend-requests/\"\"\"\\n\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        def safe_to_process(x, y):\\n            for c1 in connected[x]:\\n                for c2 in connected[y]:\\n                    if (c1 in banned[c2]) or (c2 in banned[c1]):\\n                        return False\\n            return True\\n\\n        def update(x, y):\\n            new_connection, new_banned = connected[x].union(connected[y]), banned[x].union(banned[y])\\n            for c in new_connection:\\n                connected[c], banned[c] = new_connection, new_banned\\n\\n        connected = [{i} for i in range(n)]\\n        banned = [set() for _ in range(n)]\\n        for u, v in restrictions:\\n            banned[u].add(v)\\n            banned[v].add(u)\\n\\n        ans = []\\n        for (u, v) in requests:\\n            if safe_to_process(u, v):\\n                ans.append(True)\\n                update(u, v)\\n            else:\\n                ans.append(False)\\n\\n        return ans",
                "solutionTags": [],
                "code": "class Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        def safe_to_process(x, y):\\n            for c1 in connected[x]:\\n                for c2 in connected[y]:\\n                    if (c1 in banned[c2]) or (c2 in banned[c1]):\\n                        return False\\n            return True\\n\\n        def update(x, y):\\n            new_connection, new_banned = connected[x].union(connected[y]), banned[x].union(banned[y])\\n            for c in new_connection:\\n                connected[c], banned[c] = new_connection, new_banned\\n\\n        connected = [{i}",
                "codeTag": "Java"
            },
            {
                "id": 2102915,
                "title": "c-disjoint-set-union-find",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int> prnt, rnk;\\n\\n    int find(int u) {\\n        if(prnt[u] == -1) return u;\\n        return prnt[u] = find(prnt[u]);\\n    }\\n\\n    void merge(int u, int v) {\\n        u = find(u);\\n        v = find(v);\\n        \\n        if(u == v)\\n            return;\\n\\n        if(rnk[u] < rnk[v]) swap(u, v);\\n\\n        rnk[u] += rnk[v];\\n        prnt[v] = u;\\n    }\\n\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        rnk = vector<int>(n, 1);\\n        prnt = vector<int>(n, -1);\\n        \\n        vector<bool> ans(requests.size());\\n        for(int i = 0; i < requests.size(); i++) {\\n            int u = find(requests[i][0]);\\n            int v = find(requests[i][1]);\\n            bool flag = true;\\n            for(auto& it: restrictions) {\\n                int a = find(it[0]);\\n                int b = find(it[1]);\\n                if((u == a && v == b) || (u == b && v == a)) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            ans[i] = flag;\\n            if(flag) \\n                merge(u, v);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> prnt, rnk;\\n\\n    int find(int u) {\\n        if(prnt[u] == -1) return u;\\n        return prnt[u] = find(prnt[u]);\\n    }\\n\\n    void merge(int u, int v) {\\n        u = find(u);\\n        v = find(v);\\n        \\n        if(u == v)\\n            return;\\n\\n        if(rnk[u] < rnk[v]) swap(u, v);\\n\\n        rnk[u] += rnk[v];\\n        prnt[v] = u;\\n    }\\n\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        rnk = vector<int>(n, 1);\\n        prnt = vector<int>(n, -1);\\n        \\n        vector<bool> ans(requests.size());\\n        for(int i = 0; i < requests.size(); i++) {\\n            int u = find(requests[i][0]);\\n            int v = find(requests[i][1]);\\n            bool flag = true;\\n            for(auto& it: restrictions) {\\n                int a = find(it[0]);\\n                int b = find(it[1]);\\n                if((u == a && v == b) || (u == b && v == a)) {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            ans[i] = flag;\\n            if(flag) \\n                merge(u, v);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084595,
                "title": "python-fast-uf-with-hashmap-no-tle-better-than-two-loops",
                "content": "In other posts using UF, two loops are used. it can actually optimzied.\\n\\nFor each request, to avoid the loop of restriction array, we only need to update the new root label\\'s forbidden elements. This avoids the n2 complexity in general cases, in the worst case same as n*n.\\nNote: the old forbidden elements should be updated with their updated new parents also.\\n\\n```\\n def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        p=[i for i in range(n)]\\n        def getp(x):\\n            if x!=p[x]:\\n                p[x]=getp(p[x])\\n            return p[x]\\n        def union(x,y):\\n            px=getp(x)\\n            py=getp(y)\\n            if px<py:\\n                p[py]=px\\n            else:\\n                p[px]=py\\n        def getrest():\\n            fbd=defaultdict(list)\\n            for a,b in restrictions:\\n                pa=getp(a)\\n                pb=getp(b)\\n                if pb not in fbd[pa]:\\n                    fbd[pa].append(pb)\\n                if pa not in fbd[pb]:\\n                    fbd[pb].append(pa)\\n            return fbd\\n        res=[]\\n        forbd=getrest()\\n        for a,b in requests:\\n            pa=getp(a)\\n            pb=getp(b)\\n            if pa in forbd[pb] or pb in forbd[pa]:\\n                res.append(False)\\n            else:\\n                res.append(True)\\n                union(a,b)\\n                ## also need update the forbidden relations\\n                npa=getp(a)\\n                npb=getp(b)\\n                for e in forbd[pa]:\\n                    pe=getp(e)\\n                    if pe not in forbd[npa]:\\n                        forbd[npa].append(pe)\\n                for f in forbd[pb]:\\n                    pf=getp(f)\\n                    if pf not in forbd[npb]:\\n                        forbd[npb].append(pf)\\n                \\n        return res",
                "solutionTags": [],
                "code": "In other posts using UF, two loops are used. it can actually optimzied.\\n\\nFor each request, to avoid the loop of restriction array, we only need to update the new root label\\'s forbidden elements. This avoids the n2 complexity in general cases, in the worst case same as n*n.\\nNote: the old forbidden elements should be updated with their updated new parents also.\\n\\n```\\n def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        p=[i for i in range(n)]\\n        def getp(x):\\n            if x!=p[x]:\\n                p[x]=getp(p[x])\\n            return p[x]\\n        def union(x,y):\\n            px=getp(x)\\n            py=getp(y)\\n            if px<py:\\n                p[py]=px\\n            else:\\n                p[px]=py\\n        def getrest():\\n            fbd=defaultdict(list)\\n            for a,b in restrictions:\\n                pa=getp(a)\\n                pb=getp(b)\\n                if pb not in fbd[pa]:\\n                    fbd[pa].append(pb)\\n                if pa not in fbd[pb]:\\n                    fbd[pb].append(pa)\\n            return fbd\\n        res=[]\\n        forbd=getrest()\\n        for a,b in requests:\\n            pa=getp(a)\\n            pb=getp(b)\\n            if pa in forbd[pb] or pb in forbd[pa]:\\n                res.append(False)\\n            else:\\n                res.append(True)\\n                union(a,b)\\n                ## also need update the forbidden relations\\n                npa=getp(a)\\n                npb=getp(b)\\n                for e in forbd[pa]:\\n                    pe=getp(e)\\n                    if pe not in forbd[npa]:\\n                        forbd[npa].append(pe)\\n                for f in forbd[pb]:\\n                    pf=getp(f)\\n                    if pf not in forbd[npb]:\\n                        forbd[npb].append(pf)\\n                \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2037434,
                "title": "c-union-find-solution-o-res-req",
                "content": "Runtime: 276 ms, faster than 82.46% of C++ online submissions for Process Restricted Friend Requests.\\nMemory Usage: 21.7 MB, less than 98.10% of C++ online submissions for Process Restricted Friend Requests.\\n\\n\\n```\\nWe can check if two person are in same friend group using union find by checking if their leaders are same.\\nIf they are not in same friend group already then we can check the leaders of the restricted connections\\nand if the leaders matches exactly with leader of both person then there will be a direct or indirect\\nconnection if we make them friend, and so we can not send friend request. \\nWhen friend request is valid, we unify both person or friends.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int parents[1001];\\n    \\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        for(int i=0;i<n;i++)parents[i]=i;\\n    \\n        vector<bool>res;\\n        \\n        int p,q,rp,rq;\\n        for(auto & req: requests)\\n        {\\n            bool valid = true;\\n            \\n            // get the leader of both person friend group\\n            p = find(req[0]);\\n            q = find(req[1]);\\n            \\n            // if the leaders are same then the request is valid\\n            // otherwise we have to check the leaders of the restricted connections\\n            if(p!=q)\\n            {\\n                for(auto & rest : restrictions)\\n                {\\n                    rp = find(rest[0]);\\n                    rq = find(rest[1]);\\n         \\n                    // restricted connection leaders matches exactly with the person leaders\\n                    // so their is a path from both person to the restricted connection nodes                    \\n                    if((p==rp && q==rq) || (p==rq && q==rp))\\n                    {\\n                        valid = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            // make persons friend by unify them when request is valid\\n            if(valid)parents[p]=q;\\n            \\n            res.push_back(valid);\\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    int find(int t)\\n    {\\n        if(parents[t]==t)return t;\\n        return parents[t] = find(parents[t]);\\n    }\\n        \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nWe can check if two person are in same friend group using union find by checking if their leaders are same.\\nIf they are not in same friend group already then we can check the leaders of the restricted connections\\nand if the leaders matches exactly with leader of both person then there will be a direct or indirect\\nconnection if we make them friend, and so we can not send friend request. \\nWhen friend request is valid, we unify both person or friends.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int parents[1001];\\n    \\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        for(int i=0;i<n;i++)parents[i]=i;\\n    \\n        vector<bool>res;\\n        \\n        int p,q,rp,rq;\\n        for(auto & req: requests)\\n        {\\n            bool valid = true;\\n            \\n            // get the leader of both person friend group\\n            p = find(req[0]);\\n            q = find(req[1]);\\n            \\n            // if the leaders are same then the request is valid\\n            // otherwise we have to check the leaders of the restricted connections\\n            if(p!=q)\\n            {\\n                for(auto & rest : restrictions)\\n                {\\n                    rp = find(rest[0]);\\n                    rq = find(rest[1]);\\n         \\n                    // restricted connection leaders matches exactly with the person leaders\\n                    // so their is a path from both person to the restricted connection nodes                    \\n                    if((p==rp && q==rq) || (p==rq && q==rp))\\n                    {\\n                        valid = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            // make persons friend by unify them when request is valid\\n            if(valid)parents[p]=q;\\n            \\n            res.push_back(valid);\\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    int find(int t)\\n    {\\n        if(parents[t]==t)return t;\\n        return parents[t] = find(parents[t]);\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036034,
                "title": "fully-explained-for-beginners-c",
                "content": "whenever there is a relation, hates, dont want to be in same class, frnds or whatsoever. it means a graph ques.\\nvalid for topo sort also.\\n\\ngiven:  in restricted relation, 2 people shouldnt be frnds {a,b} {b,c} \\na and b . frnddhip not allowed\\nb and c. not allowed\\na and c ( allowed) { check eg3. frndhip directly and indirectly gets confusing. even i got confused abt the transitive property}.\\n\\nalso\\na -e -b  this frndship is also not allowed.\\nhence \\nto check for a-e (allowed if  e-b isnt there) and vice versa. so here for request a -e we first had to check if  b  isnt connected to e . directly or through any chain. e--g-t-o-p-b( this should also not be thre). \\nand whts the best way to do it? either use dfs to go through every frndship chain from e.\\nor\\n**** just use union-find /DSU data structure ( 4 alpha complexity).****\\n\\n**acc to constraints accepts N square.\\n**\\n\\nso before every request check that it doesnt violate any restriction. \\nfor( evry f1 , f2 in request )\\n\\t// check for every restriction\\n\\tfor( people{x,y} in restrictions)\\n\\t\\t// parent of x  and parent of y shouldnt be  same by r1 request\\n\\t\\t//  i.e allowed if --> par[x]!= par[f1] and par[y] != par[f2]  or criss cross\\n\\t\\t// else they will be in same grp\\n\\tif all restrictions are held true then form frndship.\\n\\n\\n\\n\\n```\\nclass Solution {\\n     vector<int> parent;\\n     vector<int> rank;\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& b, vector<vector<int>>& r)\\n    {\\n        vector<bool> ans;\\n        //int n = g.size();\\n        parent.resize( n, -1);\\n        // all nodes are parent of themselves inititally, if parent[u] = -k thne u is leader of grp of k nodes\\n        rank.resize( n, 1); // initially no node is connected hence rank is 1 for all\\n        \\n        // edges\\n        for( int i =0 ; i < r.size() ; i ++)\\n           {\\n                int p1 = find(r[i][0]);\\n                int p2 = find(r[i][1]);\\n                // if this req doesnt violate any restriction, then this merger is valid\\n                int allowed =1;\\n                 for( int j =0 ; j < b.size() ; j ++)\\n                 {\\n                     int a = find(b[j][0]);\\n                     int b1 = find(b[j][1]);\\n                     // they shopuld be in diff grp that is theoir parents a/b shouldnt form pair {}\\n                    if( (a==p1 and b1 ==p2 ) or ( a==p2 and b1== p1) )\\n                       // not allowed\\n                       { allowed =0; break;}\\n                 }\\n                 if( allowed)\\n                       {\\n                        addedge(p1,p2);\\n                        ans.push_back( true);     \\n                       }   \\n                else\\n                    ans.push_back( false);     \\n            }\\n        return ans;\\n    }\\n    \\n    // start of template\\n    \\n     void addedge( int i , int j )\\n        {\\n            // add edge if their parents are diff\\n            if( find(i) == find(j))\\n                return; // same parents, also condition for cycle present\\n            else \\n                merge( i , j);\\n        }\\n    int find( int u) // return parent of u \\n    {\\n        if( parent[u] < 0 ) // it is its own parent\\n            return u;\\n        else \\n            return parent[u] = find(parent[u]);\\n    }\\n    void merge( int u , int v )\\n    {\\n        // merge by rank\\n        int a = find(u); // find parent of both of them\\n        int b = find(v);\\n        if( a == b) // both have same parents\\n            return;\\n        int ra= rank[u]; // rank of parent a\\n        int rb = rank[v];\\n        if( ra > rb) // a has more nodes chain in its grp, hence add b in a\\'s grp, to keep parent chain hierachy as sort as possible\\n        {\\n            parent[a] += parent[b]; //add nodes in b to nodes of a\\n            parent[b]=a;\\n        }\\n        else if( ra < rb) // a has more nodes chain in its grp, hence add b in a\\'s grp, to keep parent chain hierachy as sort as possible\\n        {\\n            parent[b] += parent[a]; //add nodes in b to nodes of a\\n            parent[a]=b;\\n        \\n        }\\n        else // both have same rank\\n        {\\n            parent[a] += parent[b]; //add nodes in b to nodes of a\\n            parent[b]=a;\\n            rank[a]++;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "class Solution {\\n     vector<int> parent;\\n     vector<int> rank;\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& b, vector<vector<int>>& r)\\n    {\\n        vector<bool> ans;\\n        //int n = g.size();\\n        parent.resize( n, -1);\\n        // all nodes are parent of themselves inititally, if parent[u] = -k thne u is leader of grp of k nodes\\n        rank.resize( n, 1); // initially no node is connected hence rank is 1 for all\\n        \\n        // edges\\n        for( int i =0 ; i < r.size() ; i ++)\\n           {\\n                int p1 = find(r[i][0]);\\n                int p2 = find(r[i][1]);\\n                // if this req doesnt violate any restriction, then this merger is valid\\n                int allowed =1;\\n                 for( int j =0 ; j < b.size() ; j ++)\\n                 {\\n                     int a = find(b[j][0]);\\n                     int b1 = find(b[j][1]);\\n                     // they shopuld be in diff grp that is theoir parents a/b shouldnt form pair {}",
                "codeTag": "Java"
            },
            {
                "id": 2016223,
                "title": "java-union-find-brute-force-on-restrictions",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        UnionFind uf = new UnionFind(n);\\n        boolean[] answer = new boolean[requests.length];\\n        int k = 0;\\n        for(int[] friends: requests)\\n        {\\n            int p1 = uf.Find(friends[0]);\\n            int p2 = uf.Find(friends[1]);\\n            boolean request = true;\\n            if(p1 != p2)\\n            {\\n                for(int[] block: restrictions)\\n                {\\n                    int x = uf.Find(block[0]), y = uf.Find(block[1]);\\n                    if(p1 == x && p2 == y || p1 == y && p2 == x)\\n                    {\\n                        request = false;\\n                        break;\\n                    }    \\n                }\\n            }\\n            \\n            if(request)\\n                uf.Union(p1, p2);\\n            answer[k++] = request;\\n        }\\n        return answer;\\n    }\\n    \\n    class UnionFind {\\n        int[] parent;\\n        \\n        public UnionFind(int len){\\n            parent = new int[len];\\n            for(int i = 0; i < len; i++)\\n                parent[i] = i;\\n        }\\n        \\n        private int Find(int node)\\n        {\\n            if(parent[node] != node)\\n                parent[node] = Find(parent[node]);\\n            \\n            return parent[node];\\n        }\\n        \\n        private void Union(int a, int b)\\n        {\\n            int parentA = Find(a);\\n            int parentB = Find(b);\\n            \\n            parent[parentA] = parentB;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        UnionFind uf = new UnionFind(n);\\n        boolean[] answer = new boolean[requests.length];\\n        int k = 0;\\n        for(int[] friends: requests)\\n        {\\n            int p1 = uf.Find(friends[0]);\\n            int p2 = uf.Find(friends[1]);\\n            boolean request = true;\\n            if(p1 != p2)\\n            {\\n                for(int[] block: restrictions)\\n                {\\n                    int x = uf.Find(block[0]), y = uf.Find(block[1]);\\n                    if(p1 == x && p2 == y || p1 == y && p2 == x)\\n                    {\\n                        request = false;\\n                        break;\\n                    }    \\n                }\\n            }\\n            \\n            if(request)\\n                uf.Union(p1, p2);\\n            answer[k++] = request;\\n        }\\n        return answer;\\n    }\\n    \\n    class UnionFind {\\n        int[] parent;\\n        \\n        public UnionFind(int len){\\n            parent = new int[len];\\n            for(int i = 0; i < len; i++)\\n                parent[i] = i;\\n        }\\n        \\n        private int Find(int node)\\n        {\\n            if(parent[node] != node)\\n                parent[node] = Find(parent[node]);\\n            \\n            return parent[node];\\n        }\\n        \\n        private void Union(int a, int b)\\n        {\\n            int parentA = Find(a);\\n            int parentB = Find(b);\\n            \\n            parent[parentA] = parentB;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002671,
                "title": "c-easy-to-understand-union-find-dsu",
                "content": "This solution uses Union-Find (DSU) optimized with union by rank and path compression, if you don\\'t know how to use DSU, i highly recommend to do this problem first to understand it: https://leetcode.com/problems/the-earliest-moment-when-everyone-become-friends/solution/\\n\\n```\\nclass Solution {\\n\\nstruct unionFind{\\n    vector<int> roots;\\n    vector<int> heights;\\n    \\n    unionFind(int sz):roots(sz),heights(sz){\\n        for(int i=0;i<sz;i++){//initializes all subtrees with their own node and height 1\\n            roots[i]=i;\\n            heights[i]=1;\\n        }\\n            \\n    }\\n    \\n    int find(int x){\\n        return (x==roots[x])?x:roots[x]=find(roots[x]); //DSU with path compression\\n    }\\n    \\n    void connect(int a,int b){\\n        int root1=find(a),root2=find(b);\\n        if(root1!=root2){\\n            if(heights[root1]>heights[root2])\\n                roots[root2]=root1;\\n            else if(heights[root1]<heights[root2]) //Union by rank\\n                roots[root1]=root2;\\n            else{\\n                roots[root2]=root1;\\n                heights[root1]++;\\n            }\\n        }\\n    }\\n    \\n    bool isConnected(int a,int b){\\n        return find(a)==find(b); //Function to know if two nodes are connected\\n    }\\n    \\n};\\n    \\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> result(requests.size(),true); //Result array supposing that all requests are valid\\n        unionFind dsu(n),temp(1);//friends graph and a temporary one to know if a request is valid\\n        \\n        for(int i=0;i<requests.size();i++){\\n            int x=requests[i][0],y=requests[i][1]; //person x and person y\\n            \\n            temp=dsu; //makes a temporary DSU to test if x and y can become friends\\n            temp.connect(x,y);//makes friends x and y\\n            \\n            for(vector<int> &a:restrictions){ //explore all restrictions NOTE: USE THE \"&\" SYMBOL TO PASS BY REFERENCE THE ARRAY AND SAVE A LOT OF TIME, OTHERWISE YOU\\'LL GET A TLE, OMG I RECEIVED A TLE FOR THAT TINY THING SO BE CAREFULL PLEASE\\n                if(temp.isConnected(a[0],a[1])){ //check if the not valid friends still disconnected\\n                    result[i]=false;//if they\\'re connected that means that the current request it\\'s invalid\\n                    break;\\n                }\\n            }\\n\\n            if(result[i])//if the request was valid, the temporary array takes place of the original one\\n                dsu=temp;\\n            \\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n\\nstruct unionFind{\\n    vector<int> roots;\\n    vector<int> heights;\\n    \\n    unionFind(int sz):roots(sz),heights(sz){\\n        for(int i=0;i<sz;i++){//initializes all subtrees with their own node and height 1\\n            roots[i]=i;\\n            heights[i]=1;\\n        }\\n            \\n    }\\n    \\n    int find(int x){\\n        return (x==roots[x])?x:roots[x]=find(roots[x]); //DSU with path compression\\n    }\\n    \\n    void connect(int a,int b){\\n        int root1=find(a),root2=find(b);\\n        if(root1!=root2){\\n            if(heights[root1]>heights[root2])\\n                roots[root2]=root1;\\n            else if(heights[root1]<heights[root2]) //Union by rank\\n                roots[root1]=root2;\\n            else{\\n                roots[root2]=root1;\\n                heights[root1]++;\\n            }\\n        }\\n    }\\n    \\n    bool isConnected(int a,int b){\\n        return find(a)==find(b); //Function to know if two nodes are connected\\n    }\\n    \\n};\\n    \\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<bool> result(requests.size(),true); //Result array supposing that all requests are valid\\n        unionFind dsu(n),temp(1);//friends graph and a temporary one to know if a request is valid\\n        \\n        for(int i=0;i<requests.size();i++){\\n            int x=requests[i][0],y=requests[i][1]; //person x and person y\\n            \\n            temp=dsu; //makes a temporary DSU to test if x and y can become friends\\n            temp.connect(x,y);//makes friends x and y\\n            \\n            for(vector<int> &a:restrictions){ //explore all restrictions NOTE: USE THE \"&\" SYMBOL TO PASS BY REFERENCE THE ARRAY AND SAVE A LOT OF TIME, OTHERWISE YOU\\'LL GET A TLE, OMG I RECEIVED A TLE FOR THAT TINY THING SO BE CAREFULL PLEASE\\n                if(temp.isConnected(a[0],a[1])){ //check if the not valid friends still disconnected\\n                    result[i]=false;//if they\\'re connected that means that the current request it\\'s invalid\\n                    break;\\n                }\\n            }\\n\\n            if(result[i])//if the request was valid, the temporary array takes place of the original one\\n                dsu=temp;\\n            \\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993811,
                "title": "clean-python-with-union",
                "content": "\\tdef friendRequests(self, n, restrictions, requests):\\n        connected = [set([i]) for i in range(n)]\\n        banned = [set() for _ in range(n)]\\n        \\n        for x, y in restrictions:\\n            banned[x].add(y)\\n            banned[y].add(x)\\n        \\n        def isSafe(x, y):\\n            for c1 in connected[x]:\\n                for c2 in connected[y]:\\n                    if (c1 in banned[c2]) or (c2 in banned[c1]):\\n                        return False\\n            return True\\n        \\n        def update(x, y):\\n            newConnection = connected[x].union(connected[y])\\n            newBanned = banned[x].union(banned[y])\\n            for c in newConnection:\\n                connected[c] = newConnection\\n                banned[c] = newBanned     \\n                           \\n        out = []\\n        for i, (x, y) in enumerate(requests):\\n            if isSafe(x, y):\\n                out.append(True)\\n                update(x, y)   \\n            else:\\n                out.append(False)",
                "solutionTags": [],
                "code": "\\tdef friendRequests(self, n, restrictions, requests):\\n        connected = [set([i]) for i in range(n)]\\n        banned = [set() for _ in range(n)]\\n        \\n        for x, y in restrictions:\\n            banned[x].add(y)\\n            banned[y].add(x)\\n        \\n        def isSafe(x, y):\\n            for c1 in connected[x]:\\n                for c2 in connected[y]:\\n                    if (c1 in banned[c2]) or (c2 in banned[c1]):\\n                        return False\\n            return True\\n        \\n        def update(x, y):\\n            newConnection = connected[x].union(connected[y])\\n            newBanned = banned[x].union(banned[y])\\n            for c in newConnection:\\n                connected[c] = newConnection\\n                banned[c] = newBanned     \\n                           \\n        out = []\\n        for i, (x, y) in enumerate(requests):\\n            if isSafe(x, y):\\n                out.append(True)\\n                update(x, y)   \\n            else:\\n                out.append(False)",
                "codeTag": "Python3"
            },
            {
                "id": 1987627,
                "title": "c-solution-with-explanation-union-find-path-compression",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> parent,rank;\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& reqs) {\\n         vector<bool> ans;\\n         parent.resize(n,0);\\n         rank.resize(n,0);\\n         for(int i=0; i<n; i++) parent[i]=i;\\n         for(auto req : reqs) {\\n              bool good = true;\\n              int friend1 = find(req[0]) , friend2 = find(req[1]);\\n              if(friend1 != friend2) {\\n                  for(int j=0; j<res.size(); j++) {\\n                       int blocked_user1 = find(res[j][0]) , blocked_user2 = find(res[j][1]);\\n                       // if parent of friends are same as the parent of blocked user then it is restricted\\n                       if((friend1==blocked_user1 && friend2==blocked_user2) || (friend1==blocked_user2 && friend2==blocked_user1)) {\\n                             good = false;\\n                             break;\\n                       }\\n                  }\\n              }\\n              if(good) union_(req[0],req[1]); // if the people\\'s request are restricted already , dont make them friends !\\n              ans.push_back(good);\\n         }\\n        return ans;\\n}\\n    int find(int a) {\\n        if(parent[a]==a) return a;\\n        else return parent[a]=find(parent[a]);\\n    }\\n    void union_(int a,int b) {\\n        if(a==b) return;\\n        a=find(a),b=find(b);\\n        // path compression\\n        if(rank[a]<rank[b]) {\\n             parent[a]=b;\\n        }else if(rank[b]<rank[a]) {\\n             parent[b]=a;\\n        }else {\\n             rank[a]++;\\n             parent[a]=b;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent,rank;\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& reqs) {\\n         vector<bool> ans;\\n         parent.resize(n,0);\\n         rank.resize(n,0);\\n         for(int i=0; i<n; i++) parent[i]=i;\\n         for(auto req : reqs) {\\n              bool good = true;\\n              int friend1 = find(req[0]) , friend2 = find(req[1]);\\n              if(friend1 != friend2) {\\n                  for(int j=0; j<res.size(); j++) {\\n                       int blocked_user1 = find(res[j][0]) , blocked_user2 = find(res[j][1]);\\n                       // if parent of friends are same as the parent of blocked user then it is restricted\\n                       if((friend1==blocked_user1 && friend2==blocked_user2) || (friend1==blocked_user2 && friend2==blocked_user1)) {\\n                             good = false;\\n                             break;\\n                       }\\n                  }\\n              }\\n              if(good) union_(req[0],req[1]); // if the people\\'s request are restricted already , dont make them friends !\\n              ans.push_back(good);\\n         }\\n        return ans;\\n}\\n    int find(int a) {\\n        if(parent[a]==a) return a;\\n        else return parent[a]=find(parent[a]);\\n    }\\n    void union_(int a,int b) {\\n        if(a==b) return;\\n        a=find(a),b=find(b);\\n        // path compression\\n        if(rank[a]<rank[b]) {\\n             parent[a]=b;\\n        }else if(rank[b]<rank[a]) {\\n             parent[b]=a;\\n        }else {\\n             rank[a]++;\\n             parent[a]=b;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987362,
                "title": "easy-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n  \\n    int find(int node)\\n    {\\n        \\n        if(node==parent[node])\\n            return node;\\n        \\n        return parent[node]=find(parent[node]);\\n    }\\n    void Union(int u,int v)\\n    {\\n        int pu=find(u);\\n        int pv=find(v);\\n        parent[pu]=pv;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        int i;\\n        \\n        parent.resize(n);\\n        for(i=0;i<n;i++)\\n            parent[i]=i;\\n        \\n        vector<bool>ans(requests.size());\\n        \\n       for(i=0;i<requests.size();i++)\\n       {\\n           int u=requests[i][0];\\n           int v=requests[i][1];\\n           \\n           auto temp_copy = parent;\\n         \\n           ans[i]=true;\\n         \\n           Union(u,v);\\n         \\n           for(auto &it:restrictions)\\n           {\\n               int p=it[0];\\n               int q=it[1];\\n               \\n               if(find(p)==find(q))\\n*                {\\n                   ans[i]=false;\\n                   break;\\n                }\\n            }\\n           if(!ans[i])\\n               parent = temp_copy; \\n       }\\n        return ans; \\n    }\\n};``\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n  \\n    int find(int node)\\n    {\\n        \\n        if(node==parent[node])\\n            return node;\\n        \\n        return parent[node]=find(parent[node]);\\n    }\\n    void Union(int u,int v)\\n    {\\n        int pu=find(u);\\n        int pv=find(v);\\n        parent[pu]=pv;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        \\n        int i;\\n        \\n        parent.resize(n);\\n        for(i=0;i<n;i++)\\n            parent[i]=i;\\n        \\n        vector<bool>ans(requests.size());\\n        \\n       for(i=0;i<requests.size();i++)\\n       {\\n           int u=requests[i][0];\\n           int v=requests[i][1];\\n           \\n           auto temp_copy = parent;\\n         \\n           ans[i]=true;\\n         \\n           Union(u,v);\\n         \\n           for(auto &it:restrictions)\\n           {\\n               int p=it[0];\\n               int q=it[1];\\n               \\n               if(find(p)==find(q))\\n*                {\\n                   ans[i]=false;\\n                   break;\\n                }\\n            }\\n           if(!ans[i])\\n               parent = temp_copy; \\n       }\\n        return ans; \\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949905,
                "title": "easy-c-code-using-dsu",
                "content": "\\n\\n\\n```\\nclass Solution {\\n   vector<int>par,rank;\\n    int find(int u)\\n    {\\n        if(par[u] == u)\\n            return u;\\n        return par[u] = find(par[u]);\\n    }\\n    void union_(int u,int v)\\n    {\\n        int par_u = find(u);\\n        int par_v = find(v);\\n        int rank_u = rank[par_u];\\n        int rank_v = rank[par_v];\\n        if(rank_u < rank_v)\\n        {\\n            par[par_u] = par_v;\\n        }\\n        else if(rank_v < rank_u)\\n        {\\n            par[par_v] = par_u;\\n        }\\n        else\\n        {\\n            par[par_v] = par_u;\\n            rank[u]++;\\n        }\\n    }\\n    bool connect(int u,int v)\\n    {\\n        int par_u = find(u);\\n        int par_v = find(v);\\n        if(par_u == par_v)\\n            return true;\\n        \\n        return false;\\n    }\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<int>graph[n];\\n        par.resize(n);\\n        for(int i=0;i<n;i++)\\n            par[i] = i;\\n        \\n        rank.resize(n,0);\\n        int m = requests.size();\\n        vector<bool>ans(m,false);\\n        for(int i=0;i<m;i++)\\n        {\\n            int uj = requests[i][0];\\n            int vj = requests[i][1];\\n            vector<int>temp_par = par;\\n            vector<int>temp_rank = rank;\\n            bool ok = true;\\n            union_(uj,vj);\\n            for(auto x: restrictions)\\n            {\\n                \\n                int u = x[0];\\n                int v = x[1];\\n               \\n                if(connect(u,v))\\n                {\\n                    ok = false;\\n                    break;\\n                }\\n            }\\n            if(ok)\\n            {\\n                ans[i] = true;\\n            }\\n            else if(ok == false)\\n            {\\n                par = temp_par;\\n                rank = temp_rank;\\n            }\\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n   vector<int>par,rank;\\n    int find(int u)\\n    {\\n        if(par[u] == u)\\n            return u;\\n        return par[u] = find(par[u]);\\n    }\\n    void union_(int u,int v)\\n    {\\n        int par_u = find(u);\\n        int par_v = find(v);\\n        int rank_u = rank[par_u];\\n        int rank_v = rank[par_v];\\n        if(rank_u < rank_v)\\n        {\\n            par[par_u] = par_v;\\n        }\\n        else if(rank_v < rank_u)\\n        {\\n            par[par_v] = par_u;\\n        }\\n        else\\n        {\\n            par[par_v] = par_u;\\n            rank[u]++;\\n        }\\n    }\\n    bool connect(int u,int v)\\n    {\\n        int par_u = find(u);\\n        int par_v = find(v);\\n        if(par_u == par_v)\\n            return true;\\n        \\n        return false;\\n    }\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<int>graph[n];\\n        par.resize(n);\\n        for(int i=0;i<n;i++)\\n            par[i] = i;\\n        \\n        rank.resize(n,0);\\n        int m = requests.size();\\n        vector<bool>ans(m,false);\\n        for(int i=0;i<m;i++)\\n        {\\n            int uj = requests[i][0];\\n            int vj = requests[i][1];\\n            vector<int>temp_par = par;\\n            vector<int>temp_rank = rank;\\n            bool ok = true;\\n            union_(uj,vj);\\n            for(auto x: restrictions)\\n            {\\n                \\n                int u = x[0];\\n                int v = x[1];\\n               \\n                if(connect(u,v))\\n                {\\n                    ok = false;\\n                    break;\\n                }\\n            }\\n            if(ok)\\n            {\\n                ans[i] = true;\\n            }\\n            else if(ok == false)\\n            {\\n                par = temp_par;\\n                rank = temp_rank;\\n            }\\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946123,
                "title": "c-dsu",
                "content": "```\\nclass Solution {\\npublic:\\n     int parent[1000+10],size[1000+10];\\n    void make(int i)\\n    {\\n        parent[i]=i;\\n        size[i]=1;\\n    }\\n    \\n    int find(int i)\\n    {\\n        if(parent[i]==i)\\n            return i;\\n        return parent[i]=find(parent[i]);\\n    }\\n    \\n    void Union(int a,int b)\\n    {\\n        \\n        a=find(a);\\n        b=find(b);\\n        if(a!=b)\\n        {\\n           \\n            if(size[a]<size[b])\\n            {\\n                swap(a,b);\\n            }\\n            parent[b]=a;\\n            size[a]+=size[b];\\n        }\\n        return;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& requests) {\\n      \\n        for(int i=0;i<=n;i++)\\n        {\\n            make(i);\\n        }\\n       \\n        vector<bool>ans;\\n        for(auto i : requests)\\n        {\\n            int x=i[1];\\n            int y=i[0];\\n            int xx=find(x);\\n            int yy=find(y);\\n            if(xx!=yy){\\n            int c=0;\\n            for(auto f:res)\\n            {\\n                int a=f[0];\\n                int b=f[1];\\n                a=find(a);\\n                b=find(b);\\n                if((xx==a && yy==b) || (xx==b && yy==a))\\n                {\\n                    c++;\\n                    break;\\n                }\\n                \\n            }\\n            if(c>0)\\n            {\\n                ans.push_back(false);\\n                \\n            }\\n            else{\\n                Union(x,y);\\n                ans.push_back(true);\\n            }\\n            }\\n            else{\\n                ans.push_back(true);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     int parent[1000+10],size[1000+10];\\n    void make(int i)\\n    {\\n        parent[i]=i;\\n        size[i]=1;\\n    }\\n    \\n    int find(int i)\\n    {\\n        if(parent[i]==i)\\n            return i;\\n        return parent[i]=find(parent[i]);\\n    }\\n    \\n    void Union(int a,int b)\\n    {\\n        \\n        a=find(a);\\n        b=find(b);\\n        if(a!=b)\\n        {\\n           \\n            if(size[a]<size[b])\\n            {\\n                swap(a,b);\\n            }\\n            parent[b]=a;\\n            size[a]+=size[b];\\n        }\\n        return;\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& res, vector<vector<int>>& requests) {\\n      \\n        for(int i=0;i<=n;i++)\\n        {\\n            make(i);\\n        }\\n       \\n        vector<bool>ans;\\n        for(auto i : requests)\\n        {\\n            int x=i[1];\\n            int y=i[0];\\n            int xx=find(x);\\n            int yy=find(y);\\n            if(xx!=yy){\\n            int c=0;\\n            for(auto f:res)\\n            {\\n                int a=f[0];\\n                int b=f[1];\\n                a=find(a);\\n                b=find(b);\\n                if((xx==a && yy==b) || (xx==b && yy==a))\\n                {\\n                    c++;\\n                    break;\\n                }\\n                \\n            }\\n            if(c>0)\\n            {\\n                ans.push_back(false);\\n                \\n            }\\n            else{\\n                Union(x,y);\\n                ans.push_back(true);\\n            }\\n            }\\n            else{\\n                ans.push_back(true);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930051,
                "title": "simple-solution-in-java-elegant-and-concise-using-union-find",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        // Check for each request whether it can cause conflict or not\\n        UnionFind uf = new UnionFind(n);\\n        \\n        boolean[] res = new boolean[requests.length];\\n        for(int i=0; i<requests.length; i++){\\n            int p1 = uf.findParent(requests[i][0]);\\n            int p2 = uf.findParent(requests[i][1]);\\n            \\n            if(p1 == p2){ res[i] = true; continue; }\\n            \\n            // Check whether the current request will violate any restriction or not\\n            boolean flag = true;\\n            for(int[] restrict : restrictions){\\n                int r1 = uf.findParent(restrict[0]);\\n                int r2 = uf.findParent(restrict[1]);\\n                \\n                if((r1 == p1 && r2 == p2) || (r1 == p2 && r2 == p1)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag){\\n                res[i] = true;\\n                uf.parent[p1] = p2; // Union\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private class UnionFind{\\n        public int n;\\n        public int[] parent;\\n        \\n        public UnionFind(int n){\\n            this.n = n;\\n            this.parent = new int[n];\\n            for(int i=0; i<n; i++){\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public int findParent(int user){\\n            while(parent[user] != user){\\n                parent[user] = parent[parent[user]];\\n                user = parent[user];\\n            }\\n            \\n            return user;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        // Check for each request whether it can cause conflict or not\\n        UnionFind uf = new UnionFind(n);\\n        \\n        boolean[] res = new boolean[requests.length];\\n        for(int i=0; i<requests.length; i++){\\n            int p1 = uf.findParent(requests[i][0]);\\n            int p2 = uf.findParent(requests[i][1]);\\n            \\n            if(p1 == p2){ res[i] = true; continue; }\\n            \\n            // Check whether the current request will violate any restriction or not\\n            boolean flag = true;\\n            for(int[] restrict : restrictions){\\n                int r1 = uf.findParent(restrict[0]);\\n                int r2 = uf.findParent(restrict[1]);\\n                \\n                if((r1 == p1 && r2 == p2) || (r1 == p2 && r2 == p1)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag){\\n                res[i] = true;\\n                uf.parent[p1] = p2; // Union\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private class UnionFind{\\n        public int n;\\n        public int[] parent;\\n        \\n        public UnionFind(int n){\\n            this.n = n;\\n            this.parent = new int[n];\\n            for(int i=0; i<n; i++){\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public int findParent(int user){\\n            while(parent[user] != user){\\n                parent[user] = parent[parent[user]];\\n                user = parent[user];\\n            }\\n            \\n            return user;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925760,
                "title": "c-union-find-time-o-restrictions-requests-space-o-n-restrictions",
                "content": "\\n```\\nclass Solution \\n{  \\n    int FindGroup(const int& person, const vector<int>& parent)\\n    {\\n        if(parent[person] == person)\\n        {\\n            return person;\\n        }\\n        return FindGroup(parent[person], parent);\\n    }\\n    \\n    void TransferEnemies(const int& from, const int& to, vector<unordered_set<int>>& enemies)\\n    {\\n        for(const int& enemy : enemies[from])\\n        {\\n            enemies[to].insert(enemy);\\n            enemies[enemy].erase(from);\\n            enemies[enemy].insert(to);\\n        }\\n        enemies[from].clear();\\n    }\\n    \\n    bool ProcessFriendRequest(const int& p1, const int& p2, vector<int>& parent, vector<int>& size, vector<unordered_set<int>>& enemies)\\n    {\\n        int root1 = FindGroup(p1, parent);\\n        int root2 = FindGroup(p2, parent);\\n        if(root1 == root2)\\n            return true;\\n        \\n        if(enemies[root1].find(root2) != enemies[root1].end())\\n        {\\n            //assert(enemies[root2].find(root1) != enemies[root2].end());\\n            return false;\\n        }\\n        \\n        if(size[root1] > size[root2])\\n        {\\n            TransferEnemies(root2, root1, enemies);\\n            parent[root2] = root1;\\n            size[root1] += size[root2];\\n        }\\n        else\\n        {\\n            TransferEnemies(root1, root2, enemies);\\n            parent[root1] = root2;\\n            size[root2] += size[root1];\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) \\n    {\\n        vector<unordered_set<int>> enemies(n);\\n        vector<int> parent(n);\\n        vector<int> size(n, 1);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            parent[i] = i;\\n        }\\n        \\n        for(auto& r : restrictions)\\n        {\\n            enemies[r[0]].insert(r[1]);\\n            enemies[r[1]].insert(r[0]);\\n        }\\n        \\n        vector<bool> result(requests.size());\\n        int i = 0;\\n        for(auto& f : requests)\\n        {\\n            result[i] = ProcessFriendRequest(f[0], f[1], parent, size, enemies);\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{  \\n    int FindGroup(const int& person, const vector<int>& parent)\\n    {\\n        if(parent[person] == person)\\n        {\\n            return person;\\n        }\\n        return FindGroup(parent[person], parent);\\n    }\\n    \\n    void TransferEnemies(const int& from, const int& to, vector<unordered_set<int>>& enemies)\\n    {\\n        for(const int& enemy : enemies[from])\\n        {\\n            enemies[to].insert(enemy);\\n            enemies[enemy].erase(from);\\n            enemies[enemy].insert(to);\\n        }\\n        enemies[from].clear();\\n    }\\n    \\n    bool ProcessFriendRequest(const int& p1, const int& p2, vector<int>& parent, vector<int>& size, vector<unordered_set<int>>& enemies)\\n    {\\n        int root1 = FindGroup(p1, parent);\\n        int root2 = FindGroup(p2, parent);\\n        if(root1 == root2)\\n            return true;\\n        \\n        if(enemies[root1].find(root2) != enemies[root1].end())\\n        {\\n            //assert(enemies[root2].find(root1) != enemies[root2].end());\\n            return false;\\n        }\\n        \\n        if(size[root1] > size[root2])\\n        {\\n            TransferEnemies(root2, root1, enemies);\\n            parent[root2] = root1;\\n            size[root1] += size[root2];\\n        }\\n        else\\n        {\\n            TransferEnemies(root1, root2, enemies);\\n            parent[root1] = root2;\\n            size[root2] += size[root1];\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) \\n    {\\n        vector<unordered_set<int>> enemies(n);\\n        vector<int> parent(n);\\n        vector<int> size(n, 1);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            parent[i] = i;\\n        }\\n        \\n        for(auto& r : restrictions)\\n        {\\n            enemies[r[0]].insert(r[1]);\\n            enemies[r[1]].insert(r[0]);\\n        }\\n        \\n        vector<bool> result(requests.size());\\n        int i = 0;\\n        for(auto& f : requests)\\n        {\\n            result[i] = ProcessFriendRequest(f[0], f[1], parent, size, enemies);\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922419,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution \\n{\\n    public bool[] FriendRequests(int n, int[][] restrictions, int[][] requests) \\n    {\\n        List<bool> result = new();\\n        UF uf = new UF(n);\\n        \\n        foreach(var req in requests)\\n        {\\n            int parX = uf.Find(req[0]);\\n            int parY = uf.Find(req[1]);\\n            \\n            bool isRestricted = false;\\n            \\n            foreach(var rest in restrictions)\\n            {\\n                int rX = uf.Find(rest[0]);\\n                int rY = uf.Find(rest[1]);\\n                \\n                if((parX == rX && parY == rY) || (parX==rY && parY == rX))\\n                {\\n                    isRestricted = true;\\n                    break;\\n                }\\n            }\\n            \\n            result.Add(!isRestricted);\\n            \\n            if(!isRestricted)\\n                uf.Union(parX,parY);\\n        }\\n        \\n        return result.ToArray();\\n    }\\n}\\n\\nclass UF\\n{\\n    private int[] rank;\\n    public int[] parent;\\n    \\n    public UF(int n)\\n    {\\n        rank = new int[n];\\n        parent = new int[n];\\n        \\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n    }\\n    \\n    public void Union(int x, int y)\\n    {\\n        int px = Find(x);\\n        int py = Find(y);\\n        \\n        if(px==py)\\n            return;\\n        \\n        if(rank[px] < rank[py])\\n        {\\n            parent[px] = py;\\n        }\\n        else if(rank[py] < rank[px])\\n        {\\n            parent[py] = px;\\n        }\\n        else\\n        {\\n            parent[px] = py;\\n            rank[py]++;\\n        }\\n    }\\n    \\n    public int Find(int x)\\n    {\\n        if(parent[x]==x)\\n            return x;\\n        \\n        return Find(parent[x]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public bool[] FriendRequests(int n, int[][] restrictions, int[][] requests) \\n    {\\n        List<bool> result = new();\\n        UF uf = new UF(n);\\n        \\n        foreach(var req in requests)\\n        {\\n            int parX = uf.Find(req[0]);\\n            int parY = uf.Find(req[1]);\\n            \\n            bool isRestricted = false;\\n            \\n            foreach(var rest in restrictions)\\n            {\\n                int rX = uf.Find(rest[0]);\\n                int rY = uf.Find(rest[1]);\\n                \\n                if((parX == rX && parY == rY) || (parX==rY && parY == rX))\\n                {\\n                    isRestricted = true;\\n                    break;\\n                }\\n            }\\n            \\n            result.Add(!isRestricted);\\n            \\n            if(!isRestricted)\\n                uf.Union(parX,parY);\\n        }\\n        \\n        return result.ToArray();\\n    }\\n}\\n\\nclass UF\\n{\\n    private int[] rank;\\n    public int[] parent;\\n    \\n    public UF(int n)\\n    {\\n        rank = new int[n];\\n        parent = new int[n];\\n        \\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n    }\\n    \\n    public void Union(int x, int y)\\n    {\\n        int px = Find(x);\\n        int py = Find(y);\\n        \\n        if(px==py)\\n            return;\\n        \\n        if(rank[px] < rank[py])\\n        {\\n            parent[px] = py;\\n        }\\n        else if(rank[py] < rank[px])\\n        {\\n            parent[py] = px;\\n        }\\n        else\\n        {\\n            parent[px] = py;\\n            rank[py]++;\\n        }\\n    }\\n    \\n    public int Find(int x)\\n    {\\n        if(parent[x]==x)\\n            return x;\\n        \\n        return Find(parent[x]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911931,
                "title": "java",
                "content": "```\\nclass Solution {\\n    \\n    static Set<Integer> EMPTY = Collections.emptySet();\\n    /**            Union Find             **/\\n    class Node {\\n        int parent;\\n    }\\n    \\n    int parent(Node[] nodes, int idx) {\\n        if(nodes[idx].parent != idx) {\\n            nodes[idx].parent = parent(nodes, nodes[idx].parent);\\n        }\\n        return nodes[idx].parent;\\n    }\\n    \\n    void merge(Node[] nodes, int u, int v) {\\n        int uRoot = parent(nodes, u), vRoot = parent(nodes, v);\\n        nodes[uRoot].parent = vRoot;\\n    }\\n    \\n    boolean tryMerge(Map<Integer, Set<Integer>> blacklist, Node[] nodes, int u, int v) {\\n        int uRoot = parent(nodes, u), vRoot = parent(nodes, v);\\n        if(uRoot == vRoot) return true;\\n        if(blacklist.getOrDefault(uRoot, EMPTY).contains(vRoot) || \\n          blacklist.getOrDefault(vRoot, EMPTY).contains(uRoot)) return false;\\n        // merge u and v node, new root is vRoot based on above algo\\n        if(!blacklist.containsKey(vRoot)) blacklist.put(vRoot, new HashSet<>());\\n        for(Integer b: blacklist.getOrDefault(uRoot, EMPTY)) {\\n            blacklist.get(vRoot).add(parent(nodes, b));\\n        }\\n        merge(nodes, u, v);\\n        return true;\\n    }\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int rLen = requests.length;\\n        boolean[] res = new boolean[rLen];\\n        Node[] nodes = new Node[n];\\n        Map<Integer, Set<Integer>> blacklist = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            nodes[i] = new Node();\\n            nodes[i].parent = i;\\n        }\\n        for(int[] restrict: restrictions) {\\n            int u = restrict[0], v = restrict[1];\\n            if(!blacklist.containsKey(u)) blacklist.put(u, new HashSet<>());\\n            if(!blacklist.containsKey(v)) blacklist.put(v, new HashSet<>());\\n            blacklist.get(u).add(v); blacklist.get(v).add(u);\\n        }\\n        for(int i = 0; i < rLen; i++) {\\n            res[i] = tryMerge(blacklist, nodes, requests[i][0], requests[i][1]);\\n        }\\n        return res;\\n    }\\n}\\n\\n// 0: 1\\n// 1: 0, 2\\n// 2: 1, 3\\n// 3: 2\\n// 4: 1\\n\\n// 4 <- 0, 1 <- 3,  \\n// true, false, true, false",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    static Set<Integer> EMPTY = Collections.emptySet();\\n    /**            Union Find             **/\\n    class Node {\\n        int parent;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1885620,
                "title": "java-simple-union-find",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        UnionFind uf = new UnionFind(n);\\n        int index = 0;\\n        for(int[] r: requests){\\n            int a = uf.find(r[0]);\\n            int b = uf.find(r[1]);\\n            \\n            boolean canConnect = true;\\n            for(int[] restriction: restrictions){\\n                int ra = uf.find(restriction[0]);\\n                int rb = uf.find(restriction[1]);\\n                if(a == ra && b == rb || a == rb && b == ra){\\n                    canConnect = false;\\n                    break;\\n                }\\n            }\\n            res[index++] = canConnect;\\n            if(canConnect){\\n                uf.connect(a, b);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    class UnionFind{\\n        int[] parent;\\n        public UnionFind(int n){\\n            parent = new int[n];\\n            for(int i = 0; i < n; i++){\\n                parent[i] = i;\\n            }\\n        } \\n        public void connect(int xp, int yp){\\n            parent[xp] = yp;\\n        }        \\n        public int find(int x){\\n            while(x != parent[x]){\\n                parent[x] = parent[parent[x]];\\n                x = parent[x];\\n            }\\n            return x;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        UnionFind uf = new UnionFind(n);\\n        int index = 0;\\n        for(int[] r: requests){\\n            int a = uf.find(r[0]);\\n            int b = uf.find(r[1]);\\n            \\n            boolean canConnect = true;\\n            for(int[] restriction: restrictions){\\n                int ra = uf.find(restriction[0]);\\n                int rb = uf.find(restriction[1]);\\n                if(a == ra && b == rb || a == rb && b == ra){\\n                    canConnect = false;\\n                    break;\\n                }\\n            }\\n            res[index++] = canConnect;\\n            if(canConnect){\\n                uf.connect(a, b);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    class UnionFind{\\n        int[] parent;\\n        public UnionFind(int n){\\n            parent = new int[n];\\n            for(int i = 0; i < n; i++){\\n                parent[i] = i;\\n            }\\n        } \\n        public void connect(int xp, int yp){\\n            parent[xp] = yp;\\n        }        \\n        public int find(int x){\\n            while(x != parent[x]){\\n                parent[x] = parent[parent[x]];\\n                x = parent[x];\\n            }\\n            return x;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877365,
                "title": "java-quick-find-of-union-find",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        \\n        Map<Integer,Set<Integer>> cant = new HashMap<>();//map of restrictions\\n        int[] union = new int[n];\\n        for(int i=0; i<n; i++){\\n            union[i]=i;\\n            cant.put(i,new HashSet<>());\\n        }\\n        for(int[] res: restrictions){\\n            cant.get(res[0]).add(res[1]);\\n            cant.get(res[1]).add(res[0]);\\n        }\\n    \\n        boolean[] result = new boolean[requests.length];\\n        top:\\n        for(int i=0; i<requests.length; i++){\\n            int x = union[requests[i][0]], y = union[requests[i][1]];\\n\\t\\t\\t//check if this union would cause som direct or indirection restricted connections\\n            Set<Integer> common = new HashSet<>();\\n            for(int j=0; j<n; j++){\\n                if(union[j] == x || union[j] == y){\\n                    if(common.contains(j))continue top;//ignore request if indirectly restricted\\n                    if(!cant.get(j).isEmpty())common.addAll(cant.get(j));\\n                }\\n            }\\n            //union current request\\n            for(int j=0; j<n; j++)\\n                if(union[j] == x || union[j] == y)union[j]=x;\\n            result[i] = true;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        \\n        Map<Integer,Set<Integer>> cant = new HashMap<>();//map of restrictions\\n        int[] union = new int[n];\\n        for(int i=0; i<n; i++){\\n            union[i]=i;\\n            cant.put(i,new HashSet<>());\\n        }\\n        for(int[] res: restrictions){\\n            cant.get(res[0]).add(res[1]);\\n            cant.get(res[1]).add(res[0]);\\n        }\\n    \\n        boolean[] result = new boolean[requests.length];\\n        top:\\n        for(int i=0; i<requests.length; i++){\\n            int x = union[requests[i][0]], y = union[requests[i][1]];\\n\\t\\t\\t//check if this union would cause som direct or indirection restricted connections\\n            Set<Integer> common = new HashSet<>();\\n            for(int j=0; j<n; j++){\\n                if(union[j] == x || union[j] == y){\\n                    if(common.contains(j))continue top;//ignore request if indirectly restricted\\n                    if(!cant.get(j).isEmpty())common.addAll(cant.get(j));\\n                }\\n            }\\n            //union current request\\n            for(int j=0; j<n; j++)\\n                if(union[j] == x || union[j] == y)union[j]=x;\\n            result[i] = true;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870677,
                "title": "c-solution-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    class DSU{\\n    private:\\n        vector<int> parent, size, rank;\\n    \\n    public:\\n        DSU(int n)\\n        {\\n            for(int i=0; i<n; i++)\\n            {\\n                parent.push_back(i);\\n                size.push_back(1);                \\n                rank.push_back(1);                \\n            }\\n        }\\n    public:\\n        int findParent(int node)\\n        {\\n            if(node == parent[node]) return node;\\n            return findParent(parent[node]);\\n        }\\n    public:\\n        void Union_by_size(int u, int v)\\n        {\\n            int parent_of_u = findParent(u);\\n            int parent_of_v = findParent(v);\\n\\n            if(parent_of_u == parent_of_v)\\n            {\\n                return;\\n            }\\n\\n            if(size[parent_of_u] < size[parent_of_v])\\n            {\\n                parent[parent_of_u] = parent_of_v;\\n                size[parent_of_v] += size[parent_of_u];\\n                \\n            }\\n            else\\n            {\\n                parent[parent_of_v] = parent_of_u;\\n                size[parent_of_u] += size[parent_of_v];\\n            }\\n        }\\n    public:\\n        void Union_by_rank(int u, int v)\\n        {\\n            int parent_of_u = findParent(u);\\n            int parent_of_v = findParent(v);\\n\\n            if(parent_of_u == parent_of_v)\\n            {\\n                return;\\n            }\\n            if(rank[parent_of_u]==rank[parent_of_v])\\n            {\\n                parent[parent_of_u] = parent_of_v;\\n                rank[parent_of_v]++;\\n            }\\n            else if(rank[parent_of_u] < rank[parent_of_v])\\n            {\\n                parent[parent_of_u] = parent_of_v;\\n            }\\n            else{\\n                parent[parent_of_v] = parent_of_u;\\n            }\\n        }\\n    public:\\n        bool is_connected(int u, int v)\\n        {\\n            return findParent(u)==findParent(v);\\n        }\\n};\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU fr(n);\\n        vector<bool> ans;\\n        for(auto &i : requests)\\n        {\\n            int u = i[0];\\n            int v = i[1];\\n            bool aa = true;\\n            for(auto &j : restrictions)\\n            {\\n                if(fr.is_connected(u,j[0]) && fr.is_connected(v,j[1]))\\n                {\\n                    aa = false;\\n                    break;\\n                }\\n                else if(fr.is_connected(u,j[1]) && fr.is_connected(v,j[0]))\\n                {\\n                    aa = false;\\n                    break;\\n                }\\n            }\\n            \\n            ans.push_back(aa);\\n            if(aa==true)\\n            {\\n                fr.Union_by_size(u,v);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    class DSU{\\n    private:\\n        vector<int> parent, size, rank;\\n    \\n    public:\\n        DSU(int n)\\n        {\\n            for(int i=0; i<n; i++)\\n            {\\n                parent.push_back(i);\\n                size.push_back(1);                \\n                rank.push_back(1);                \\n            }\\n        }\\n    public:\\n        int findParent(int node)\\n        {\\n            if(node == parent[node]) return node;\\n            return findParent(parent[node]);\\n        }\\n    public:\\n        void Union_by_size(int u, int v)\\n        {\\n            int parent_of_u = findParent(u);\\n            int parent_of_v = findParent(v);\\n\\n            if(parent_of_u == parent_of_v)\\n            {\\n                return;\\n            }\\n\\n            if(size[parent_of_u] < size[parent_of_v])\\n            {\\n                parent[parent_of_u] = parent_of_v;\\n                size[parent_of_v] += size[parent_of_u];\\n                \\n            }\\n            else\\n            {\\n                parent[parent_of_v] = parent_of_u;\\n                size[parent_of_u] += size[parent_of_v];\\n            }\\n        }\\n    public:\\n        void Union_by_rank(int u, int v)\\n        {\\n            int parent_of_u = findParent(u);\\n            int parent_of_v = findParent(v);\\n\\n            if(parent_of_u == parent_of_v)\\n            {\\n                return;\\n            }\\n            if(rank[parent_of_u]==rank[parent_of_v])\\n            {\\n                parent[parent_of_u] = parent_of_v;\\n                rank[parent_of_v]++;\\n            }\\n            else if(rank[parent_of_u] < rank[parent_of_v])\\n            {\\n                parent[parent_of_u] = parent_of_v;\\n            }\\n            else{\\n                parent[parent_of_v] = parent_of_u;\\n            }\\n        }\\n    public:\\n        bool is_connected(int u, int v)\\n        {\\n            return findParent(u)==findParent(v);\\n        }\\n};\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        DSU fr(n);\\n        vector<bool> ans;\\n        for(auto &i : requests)\\n        {\\n            int u = i[0];\\n            int v = i[1];\\n            bool aa = true;\\n            for(auto &j : restrictions)\\n            {\\n                if(fr.is_connected(u,j[0]) && fr.is_connected(v,j[1]))\\n                {\\n                    aa = false;\\n                    break;\\n                }\\n                else if(fr.is_connected(u,j[1]) && fr.is_connected(v,j[0]))\\n                {\\n                    aa = false;\\n                    break;\\n                }\\n            }\\n            \\n            ans.push_back(aa);\\n            if(aa==true)\\n            {\\n                fr.Union_by_size(u,v);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864662,
                "title": "python-union-find",
                "content": "```\\nclass UnionFind:\\n    def __init__(self,n,restrictions):\\n        self.arr=[i for i in range(n)]\\n        self.restrictions=restrictions\\n    def union (self,a,b):\\n        node1=self.find(a)\\n        node2=self.find(b)\\n        for item in self.restrictions:\\n            x=self.find(item[0])\\n            y=self.find(item[1])\\n            if x==node1 and  y==node2 :\\n                return 0\\n            if y==node1 and  x==node2 :\\n                return 0\\n        self.arr[node1]=self.arr[node2]\\n        return 1\\n    def find(self,a):\\n        temp=a\\n        while(a!=self.arr[a]):\\n            a=self.arr[a]\\n        while(temp!=a):\\n            b=self.arr[temp]\\n            self.arr[temp]=a\\n            temp=b\\n        return a\\nclass Solution(object):\\n    def friendRequests(self, n, restrictions, requests):\\n        uf=UnionFind(n,restrictions)\\n        ans=[]\\n        for item in requests:\\n            ans.append(uf.union(item[0],item[1]))\\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self,n,restrictions):\\n        self.arr=[i for i in range(n)]\\n        self.restrictions=restrictions\\n    def union (self,a,b):\\n        node1=self.find(a)\\n        node2=self.find(b)\\n        for item in self.restrictions:\\n            x=self.find(item[0])\\n            y=self.find(item[1])\\n            if x==node1 and  y==node2 :\\n                return 0\\n            if y==node1 and  x==node2 :\\n                return 0\\n        self.arr[node1]=self.arr[node2]\\n        return 1\\n    def find(self,a):\\n        temp=a\\n        while(a!=self.arr[a]):\\n            a=self.arr[a]\\n        while(temp!=a):\\n            b=self.arr[temp]\\n            self.arr[temp]=a\\n            temp=b\\n        return a\\nclass Solution(object):\\n    def friendRequests(self, n, restrictions, requests):\\n        uf=UnionFind(n,restrictions)\\n        ans=[]\\n        for item in requests:\\n            ans.append(uf.union(item[0],item[1]))\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1860277,
                "title": "c-union-find",
                "content": "```\\nclass dsu {\\npublic:\\n\\tvector<int> parent;\\n\\tunordered_map<int, int> size;\\n\\tdsu(int n) {\\n\\t\\tparent.resize(n);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i]++;\\n\\t\\t}\\n\\t}\\n\\n\\n\\tint findParent(int u) {\\n\\t\\tif (parent[u] == u) return u;\\n\\t\\treturn parent[u] = findParent(parent[u]);\\n\\t}\\n\\n\\tvoid _union(int u, int v) {\\n\\t\\tu = findParent(u);\\n\\t\\tv = findParent(v);\\n\\t\\tif (u != v) {\\n\\t\\t\\tif (size[u] < size[v]) swap(u, v);\\n\\t\\t\\tparent[v] = u;\\n\\t\\t\\tsize[u] += size[v];\\n\\t\\t}\\n\\t}\\n\\n\\tbool areConnected(int u, int v) {\\n\\t\\treturn findParent(u) == findParent(v);\\n\\t}\\n};\\n\\n\\nclass Solution {\\npublic:\\n\\tvector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n\\n\\t\\tvector<bool> ans;\\n\\t\\tdsu uf(n);\\n\\n\\t\\tfor (auto &request : requests)  {\\n\\t\\t\\tint ui = request[0]; int vi = request[1];\\n\\t\\t\\tbool curAns = true;\\n\\t\\t\\tfor (auto &restriction : restrictions) {\\n\\t\\t\\t\\t\\n\\n\\t\\t\\t\\tif (uf.areConnected(ui, restriction[0]) && uf.areConnected(vi, restriction[1])) {\\n\\t\\t\\t\\t\\tcurAns = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse if (uf.areConnected(ui, restriction[1]) && uf.areConnected(vi, restriction[0])) {\\n\\t\\t\\t\\t\\tcurAns = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tans.push_back(curAns);\\n\\t\\t\\tif (curAns) {\\n\\t\\t\\t\\tuf._union(ui, vi);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass dsu {\\npublic:\\n\\tvector<int> parent;\\n\\tunordered_map<int, int> size;\\n\\tdsu(int n) {\\n\\t\\tparent.resize(n);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i]++;\\n\\t\\t}\\n\\t}\\n\\n\\n\\tint findParent(int u) {\\n\\t\\tif (parent[u] == u) return u;\\n\\t\\treturn parent[u] = findParent(parent[u]);\\n\\t}\\n\\n\\tvoid _union(int u, int v) {\\n\\t\\tu = findParent(u);\\n\\t\\tv = findParent(v);\\n\\t\\tif (u != v) {\\n\\t\\t\\tif (size[u] < size[v]) swap(u, v);\\n\\t\\t\\tparent[v] = u;\\n\\t\\t\\tsize[u] += size[v];\\n\\t\\t}\\n\\t}\\n\\n\\tbool areConnected(int u, int v) {\\n\\t\\treturn findParent(u) == findParent(v);\\n\\t}\\n};\\n\\n\\nclass Solution {\\npublic:\\n\\tvector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n\\n\\t\\tvector<bool> ans;\\n\\t\\tdsu uf(n);\\n\\n\\t\\tfor (auto &request : requests)  {\\n\\t\\t\\tint ui = request[0]; int vi = request[1];\\n\\t\\t\\tbool curAns = true;\\n\\t\\t\\tfor (auto &restriction : restrictions) {\\n\\t\\t\\t\\t\\n\\n\\t\\t\\t\\tif (uf.areConnected(ui, restriction[0]) && uf.areConnected(vi, restriction[1])) {\\n\\t\\t\\t\\t\\tcurAns = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse if (uf.areConnected(ui, restriction[1]) && uf.areConnected(vi, restriction[0])) {\\n\\t\\t\\t\\t\\tcurAns = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tans.push_back(curAns);\\n\\t\\t\\tif (curAns) {\\n\\t\\t\\t\\tuf._union(ui, vi);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857058,
                "title": "java-union-find-with-looping-through-restrictions",
                "content": "\\n\\n```\\n\\n\\nclass Solution {\\n    // union find, \\n    // if 2 are directly in restriction, we cannot union them\\n    // then we check if after union these 2, 2 restricted would be unioned\\n    // do we need to check all restrictions for each union?\\n    \\n    int[] parents;\\n    int[] sizes;\\n    int[][] restrictions;\\n    \\n    // find with path compression\\n    private int find(int x) {\\n        while(parents[x] != x) {\\n            parents[x] = parents[parents[x]];\\n            x = parents[x];\\n        }\\n        \\n        return x;\\n    }\\n    \\n    // union with tree balance by size and restrictions\\n    private boolean union(int x, int y) {\\n        int parentX = find(x);\\n        int parentY = find(y);\\n        \\n        if(parentX == parentY) return true;\\n        \\n        for(int[] restrict: restrictions) {\\n            int r1 = restrict[0];\\n            int r2 = restrict[1];\\n            int parentR1 = find(r1);\\n            int parentR2 = find(r2);\\n            if(parentR1 == parentX && parentR2 == parentY) return false;    \\n            if(parentR2 == parentX && parentR1 == parentY) return false;\\n        }\\n        \\n        if(sizes[parentX] < sizes[parentY]) {\\n            parents[parentX] = parentY;\\n            sizes[parentY] += sizes[parentX];\\n        } else {\\n            parents[parentY] = parentX;\\n            sizes[parentX] += parentY;\\n        }\\n        \\n        return true;\\n    }\\n\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        parents = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            parents[i] = i;\\n        }\\n        sizes = new int[n];\\n        Arrays.fill(sizes, 1);\\n        this.restrictions = restrictions;\\n        \\n\\n        for(int i = 0; i < requests.length; i++) {\\n            int[] cur = requests[i];\\n            res[i] = union(cur[0], cur[1]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\n    // union find, \\n    // if 2 are directly in restriction, we cannot union them\\n    // then we check if after union these 2, 2 restricted would be unioned\\n    // do we need to check all restrictions for each union?\\n    \\n    int[] parents;\\n    int[] sizes;\\n    int[][] restrictions;\\n    \\n    // find with path compression\\n    private int find(int x) {\\n        while(parents[x] != x) {\\n            parents[x] = parents[parents[x]];\\n            x = parents[x];\\n        }\\n        \\n        return x;\\n    }\\n    \\n    // union with tree balance by size and restrictions\\n    private boolean union(int x, int y) {\\n        int parentX = find(x);\\n        int parentY = find(y);\\n        \\n        if(parentX == parentY) return true;\\n        \\n        for(int[] restrict: restrictions) {\\n            int r1 = restrict[0];\\n            int r2 = restrict[1];\\n            int parentR1 = find(r1);\\n            int parentR2 = find(r2);\\n            if(parentR1 == parentX && parentR2 == parentY) return false;    \\n            if(parentR2 == parentX && parentR1 == parentY) return false;\\n        }\\n        \\n        if(sizes[parentX] < sizes[parentY]) {\\n            parents[parentX] = parentY;\\n            sizes[parentY] += sizes[parentX];\\n        } else {\\n            parents[parentY] = parentX;\\n            sizes[parentX] += parentY;\\n        }\\n        \\n        return true;\\n    }\\n\\n    \\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        parents = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            parents[i] = i;\\n        }\\n        sizes = new int[n];\\n        Arrays.fill(sizes, 1);\\n        this.restrictions = restrictions;\\n        \\n\\n        for(int i = 0; i < requests.length; i++) {\\n            int[] cur = requests[i];\\n            res[i] = union(cur[0], cur[1]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815506,
                "title": "python3-union-find-with-nodes-set",
                "content": "```\\nclass UF:\\n    def __init__(self,n,withSize = False):\\n        self.p = [i for i in range(n)]\\n        self.withSize = withSize\\n        if withSize:\\n            self.size = [set([i]) for i in range(n)]\\n        else:\\n            self.size = []\\n    def find(self,x):\\n        if x!=self.p[x]:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n    def union(self,x,y):\\n        p1,p2 = self.find(x), self.find(y)\\n        if p1 != p2 :\\n            self.p[p2] = p1\\n            if self.withSize:\\n                self.size[p1] = self.size[p1].union(self.size[p2])\\n        \\nclass Solution:\\n    def friendRequests(self, n: int, rest: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        eq = UF(n,True)\\n        iq = set()\\n        ans = []\\n        for u,v in requests:\\n            p1,p2 = eq.find(u), eq.find(v)\\n            nodes1 = eq.size[p1]\\n            nodes2 = eq.size[p2]\\n            for x,y in rest:\\n                if (x in nodes1 and y in nodes2) or (x in nodes2 and y in nodes1):\\n                    ans.append(False)\\n                    break\\n            else:\\n                ans.append(True)\\n                eq.union(u,v)\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass UF:\\n    def __init__(self,n,withSize = False):\\n        self.p = [i for i in range(n)]\\n        self.withSize = withSize\\n        if withSize:\\n            self.size = [set([i]) for i in range(n)]\\n        else:\\n            self.size = []\\n    def find(self,x):\\n        if x!=self.p[x]:\\n            self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n    def union(self,x,y):\\n        p1,p2 = self.find(x), self.find(y)\\n        if p1 != p2 :\\n            self.p[p2] = p1\\n            if self.withSize:\\n                self.size[p1] = self.size[p1].union(self.size[p2])\\n        \\nclass Solution:\\n    def friendRequests(self, n: int, rest: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        eq = UF(n,True)\\n        iq = set()\\n        ans = []\\n        for u,v in requests:\\n            p1,p2 = eq.find(u), eq.find(v)\\n            nodes1 = eq.size[p1]\\n            nodes2 = eq.size[p2]\\n            for x,y in rest:\\n                if (x in nodes1 and y in nodes2) or (x in nodes2 and y in nodes1):\\n                    ans.append(False)\\n                    break\\n            else:\\n                ans.append(True)\\n                eq.union(u,v)\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809912,
                "title": "c-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int find(vector<int>& root,int i){\\n        if(root[i] == i){\\n            return i;\\n        }\\n        return root[i]=find(root,root[i]);\\n    }\\n    void Union(vector<int>& root,vector<int>& rank,int p1,int p2){\\n        int root1=find(root,p1);\\n        int root2=find(root,p2);\\n        if(root1 != root2){\\n            if(rank[root1]>=rank[root2]){\\n                root[root2]=root1;\\n                if(rank[root1] == rank[root2]){\\n                    rank[root1]++;\\n                }\\n            }\\n            else{\\n                root[root1]=root2;\\n            }\\n        }\\n    }\\n    void putAndDelete(unordered_set<int> sets[],vector<int>& root,int p1,int p2,int n){\\n        //cout<<\"hereee\"<<endl;\\n        while(sets[p2].size()>0){\\n            //cout<<p1<<\" \"<<*sets[p2].begin()<<endl;\\n            sets[p1].insert(find(root,*sets[p2].begin()));\\n            sets[p2].erase(sets[p2].begin());\\n        }\\n        /*\\n        for(int j=0;j<n;j++){\\n                cout<<\"set \"<<j<<endl;\\n                for(auto itr : sets[j]){\\n                    cout<<itr<<\" \";\\n                }\\n                cout<<endl;\\n            }\\n            */\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        vector<int> root(n,0);\\n        vector<int> rank(n,0);\\n        for(int i=0;i<n;i++){\\n            root[i]=i;\\n            rank[i]=1;\\n        }\\n        unordered_set<int> sets[n];\\n        for(auto restriction : restrictions){\\n            sets[restriction[0]].insert(restriction[1]);\\n            sets[restriction[1]].insert(restriction[0]);\\n        }\\n        vector<bool> result(requests.size(),false);\\n        for(int i=0;i<requests.size();i++){\\n            int possibleFriend1=requests[i][0];\\n            int possibleFriend2=requests[i][1];\\n            int find1=find(root,possibleFriend1);\\n            int find2=find(root,possibleFriend2);\\n            //cout<<find1<<\" \"<<find2<<\" \"<<possibleFriend1<<\" \"<<possibleFriend2<<\" \"<<i<<\" once\"<<endl;\\n            if(sets[find1].find(find2) == sets[find1].end() && sets[find2].find(find1) == sets[find2].end()){\\n                result[i]=true;\\n                Union(root,rank,possibleFriend1,possibleFriend2);\\n                int newfind=find(root,possibleFriend1);\\n                //cout<<\" \"<<newfind<<endl;\\n                if(newfind != find1){\\n                    putAndDelete(sets,root,newfind,find1,n);\\n                }\\n                if(newfind != find2){\\n                    putAndDelete(sets,root,newfind,find2,n);\\n                }\\n            }\\n            /*for(int j=0;j<n;j++){\\n                cout<<\"set \"<<j<<endl;\\n                for(auto itr : sets[j]){\\n                    cout<<itr<<\" \";\\n                }\\n                cout<<endl;\\n            }*/\\n        }\\n        return result;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int find(vector<int>& root,int i){\\n        if(root[i] == i){\\n            return i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1795662,
                "title": "java-union-find",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] parents = new int[n];\\n        boolean[] res = new boolean[requests.length];\\n        Arrays.fill(parents, -1);\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            int[] req = requests[i];\\n            int p1 = find(parents, req[0]);\\n            int p2 = find(parents, req[1]);\\n            if (p1 == p2) {\\n                res[i] = true;\\n                continue;\\n            }\\n            \\n            boolean canBeFriends = true;\\n            for (int[] rest: restrictions) {\\n                int r1 = find(parents, rest[0]);\\n                int r2 = find(parents, rest[1]);\\n                if ((r1 == p1 && r2 == p2) || (r1 == p2 && r2 == p1)) {\\n                    canBeFriends = false;\\n                    break;\\n                }\\n            }\\n            if (canBeFriends) {\\n                res[i] = true;\\n                parents[p1] = p2;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int find(int[] parents, int index) {\\n        if (parents[index] == -1)\\n            return index;\\n        return parents[index] = find(parents, parents[index]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] parents = new int[n];\\n        boolean[] res = new boolean[requests.length];\\n        Arrays.fill(parents, -1);\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            int[] req = requests[i];\\n            int p1 = find(parents, req[0]);\\n            int p2 = find(parents, req[1]);\\n            if (p1 == p2) {\\n                res[i] = true;\\n                continue;\\n            }\\n            \\n            boolean canBeFriends = true;\\n            for (int[] rest: restrictions) {\\n                int r1 = find(parents, rest[0]);\\n                int r2 = find(parents, rest[1]);\\n                if ((r1 == p1 && r2 == p2) || (r1 == p2 && r2 == p1)) {\\n                    canBeFriends = false;\\n                    break;\\n                }\\n            }\\n            if (canBeFriends) {\\n                res[i] = true;\\n                parents[p1] = p2;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int find(int[] parents, int index) {\\n        if (parents[index] == -1)\\n            return index;\\n        return parents[index] = find(parents, parents[index]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787856,
                "title": "java-straightforward-unionfind-with-path-compression-and-union-by-rank",
                "content": "Implement path compression and union by rank to achieve O(\\u03B1(n)) time complexity for the find operation, which is practically constant.\\n```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        UnionFind uf = new UnionFind(n);\\n        boolean[] result = new boolean[requests.length];\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            int[] request = requests[i];\\n            int a = request[0];\\n            int b = request[1];\\n            int aParent = uf.find(a);\\n            int bParent = uf.find(b);\\n            \\n            if (isValid(restrictions, uf, aParent, bParent)) {\\n                uf.union(a, b);\\n                result[i] = true;\\n                continue;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public boolean isValid(int[][] restrictions, UnionFind uf, int aParent, int bParent) {\\n        for (int[] restriction : restrictions) {\\n            int x = restriction[0];\\n            int y = restriction[1];\\n            int xParent = uf.find(x);\\n            int yParent = uf.find(y);\\n            if ((aParent == xParent && bParent == yParent) || \\n                (aParent == yParent && bParent == xParent)) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    class UnionFind {\\n        int[] parent;\\n        int[] rank;\\n        \\n        public UnionFind(int n) {\\n            this.parent = new int[n];\\n            this.rank = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public void union(int a, int b) {\\n            int aParent = find(a);\\n            int bParent = find(b);\\n            \\n            if (aParent == bParent) return;\\n            \\n            if (rank[aParent] > rank[bParent]) {\\n                parent[bParent] = aParent;\\n            } else if (rank[bParent] > rank[aParent]) {\\n                parent[aParent] = bParent;\\n            } else {\\n                parent[aParent] = bParent;\\n                rank[aParent] += 1;\\n            }\\n        }\\n        \\n        public int find(int a) {\\n            if (parent[a] == a) return a;\\n            parent[a] = find(parent[a]);\\n            return parent[a];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        UnionFind uf = new UnionFind(n);\\n        boolean[] result = new boolean[requests.length];\\n        \\n        for (int i = 0; i < requests.length; i++) {\\n            int[] request = requests[i];\\n            int a = request[0];\\n            int b = request[1];\\n            int aParent = uf.find(a);\\n            int bParent = uf.find(b);\\n            \\n            if (isValid(restrictions, uf, aParent, bParent)) {\\n                uf.union(a, b);\\n                result[i] = true;\\n                continue;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public boolean isValid(int[][] restrictions, UnionFind uf, int aParent, int bParent) {\\n        for (int[] restriction : restrictions) {\\n            int x = restriction[0];\\n            int y = restriction[1];\\n            int xParent = uf.find(x);\\n            int yParent = uf.find(y);\\n            if ((aParent == xParent && bParent == yParent) || \\n                (aParent == yParent && bParent == xParent)) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    class UnionFind {\\n        int[] parent;\\n        int[] rank;\\n        \\n        public UnionFind(int n) {\\n            this.parent = new int[n];\\n            this.rank = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public void union(int a, int b) {\\n            int aParent = find(a);\\n            int bParent = find(b);\\n            \\n            if (aParent == bParent) return;\\n            \\n            if (rank[aParent] > rank[bParent]) {\\n                parent[bParent] = aParent;\\n            } else if (rank[bParent] > rank[aParent]) {\\n                parent[aParent] = bParent;\\n            } else {\\n                parent[aParent] = bParent;\\n                rank[aParent] += 1;\\n            }\\n        }\\n        \\n        public int find(int a) {\\n            if (parent[a] == a) return a;\\n            parent[a] = find(parent[a]);\\n            return parent[a];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778948,
                "title": "c-optimised-union-find-w-explanation",
                "content": "The idea is so simple, for each friend request, go through all restrictions and verify we don\\'t allow any enemies to become friends directly or indirectly. The code is slow going around 1000ms runtime, but accepted.\\nThe optimisation in usual union find is memoizing parent, which here cannot be done completely since I use the same find function to check the restricitons, so partial memoization is done. As in memoized only when the call is not for checking any restrictions.\\n\\n```\\nvector<int> parent;\\nint find(int x,bool flag)\\n{\\n\\tif(parent[x]==-1)\\n\\t\\treturn x;\\n\\telse if(flag)\\n\\t\\treturn parent[x]=find(parent[x],flag);\\n\\telse return find(parent[x],flag);\\n}\\n\\nbool uni(int x,int y,vector<vector<int>>& restrictions)\\n{\\n\\tint xp=find(x,true),yp=find(y,true);\\n\\tif(xp==yp)\\n\\t\\treturn true;\\n\\telse\\n\\t{\\n\\t\\tparent[yp]=xp;\\n\\t\\tbool ret=true;\\n\\t\\tfor(auto& x:restrictions)\\n\\t\\t\\tif(find(x[0],false)==find(x[1],false))\\n\\t\\t\\t{\\n\\t\\t\\t\\tret=false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\tif(!ret)\\n\\t\\t\\tparent[yp]=-1;\\n\\t\\treturn ret;                \\n\\t}\\n}\\nvector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests)\\n{\\n\\tvector<bool> ret;\\n\\tparent.resize(n,-1);\\n\\tfor(auto& x:requests)\\n\\t\\tret.push_back(uni(x[0],x[1],restrictions));\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nvector<int> parent;\\nint find(int x,bool flag)\\n{\\n\\tif(parent[x]==-1)\\n\\t\\treturn x;\\n\\telse if(flag)\\n\\t\\treturn parent[x]=find(parent[x],flag);\\n\\telse return find(parent[x],flag);\\n}\\n\\nbool uni(int x,int y,vector<vector<int>>& restrictions)\\n{\\n\\tint xp=find(x,true),yp=find(y,true);\\n\\tif(xp==yp)\\n\\t\\treturn true;\\n\\telse\\n\\t{\\n\\t\\tparent[yp]=xp;\\n\\t\\tbool ret=true;\\n\\t\\tfor(auto& x:restrictions)\\n\\t\\t\\tif(find(x[0],false)==find(x[1],false))\\n\\t\\t\\t{\\n\\t\\t\\t\\tret=false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\tif(!ret)\\n\\t\\t\\tparent[yp]=-1;\\n\\t\\treturn ret;                \\n\\t}\\n}\\nvector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests)\\n{\\n\\tvector<bool> ret;\\n\\tparent.resize(n,-1);\\n\\tfor(auto& x:requests)\\n\\t\\tret.push_back(uni(x[0],x[1],restrictions));\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1714115,
                "title": "java-union-find-with-path-compression-solution",
                "content": "\\tclass Solution {\\n\\t\\tclass UnionFind {\\n\\t\\t\\tint[] size;\\n\\t\\t\\tint[] representative;\\n\\t\\t\\tpublic UnionFind(int n) {\\n\\t\\t\\t\\tsize = new int[n];\\n\\t\\t\\t\\trepresentative = new int[n];\\n\\t\\t\\t\\tfor(int i = 0; i < n; ++i) {\\n\\t\\t\\t\\t\\tsize[i] = 1;\\n\\t\\t\\t\\t\\trepresentative[i] = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic int find(int x) {\\n\\t\\t\\t\\tif(representative[x] != x) {\\n\\t\\t\\t\\t\\trepresentative[x] = find(representative[x]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn representative[x];\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic void union(int x, int y) {\\n\\t\\t\\t\\tint pX = find(x);\\n\\t\\t\\t\\tint pY = find(y);\\n\\n\\t\\t\\t\\tif(pX == pY) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (size[pX] >= size[pY]) {\\n\\t\\t\\t\\t\\t\\tsize[pX] += size[pY];\\n\\t\\t\\t\\t\\t\\trepresentative[pY] = pX;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tsize[pY] += size[pX];\\n\\t\\t\\t\\t\\t\\trepresentative[pX] = pY;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpublic boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n\\t\\t\\tUnionFind uF = new UnionFind(n);\\n\\t\\t\\tboolean[] results = new boolean[requests.length];\\n\\t\\t\\tint index = 0;\\n\\t\\t\\tboolean canConnect = false;\\n\\t\\t\\tfor(int[] request: requests) {\\n\\t\\t\\t\\tint x = uF.find(request[0]);\\n\\t\\t\\t\\tint y = uF.find(request[1]);\\n\\t\\t\\t\\tif(x != y) {\\n\\t\\t\\t\\t\\tfor(int[] res: restrictions) {\\n\\t\\t\\t\\t\\t\\tint pX = uF.find(res[0]);\\n\\t\\t\\t\\t\\t\\tint pY = uF.find(res[1]);\\n\\t\\t\\t\\t\\t\\tif(pX == x && pY == y || pY == x && pX == y) {\\n\\t\\t\\t\\t\\t\\t\\tcanConnect = true;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (!canConnect) {\\n\\t\\t\\t\\t\\t\\tuF.union(x, y);\\n\\t\\t\\t\\t\\t\\tresults[index++] = true;      \\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tresults[index++] = false;\\n\\t\\t\\t\\t\\t\\tcanConnect = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresults[index++] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn results;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "class Solution {\\n\\t\\tclass UnionFind {\\n\\t\\t\\tint[] size;\\n\\t\\t\\tint[] representative;\\n\\t\\t\\tpublic UnionFind(int n) {\\n\\t\\t\\t\\tsize = new int[n];\\n\\t\\t\\t\\trepresentative = new int[n];\\n\\t\\t\\t\\tfor(int i = 0; i < n; ++i) {\\n\\t\\t\\t\\t\\tsize[i] = 1;\\n\\t\\t\\t\\t\\trepresentative[i] = i;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1677608,
                "title": "python-union-find-to-union-friends-hashset-to-check-restriction",
                "content": "```python\\n    def friendRequests(self, n: int, restrs: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        def find(x):\\n            if parent[x] != x:\\n                return find(parent[x])\\n            return x\\n        \\n        def union(x, y):\\n            rx, ry = find(x), find(y)\\n            if rx == ry:\\n                return True\\n            \\n            if len(constr[rx].intersection(unions[ry])) > 0:\\n                return False\\n            \\n            if rank[rx] >= rank[ry]:\\n                parent[ry] = rx\\n                unions[rx] |= unions[ry]\\n                unions[ry] = set()\\n                constr[rx] |= constr[ry]\\n                constr[ry] = set()\\n            else:\\n                parent[rx] = ry\\n                unions[ry] |= unions[rx]\\n                unions[rx] = set()\\n                constr[ry] |= constr[rx]\\n                constr[rx] = set()\\n            \\n            if rank[rx] == rank[ry]:\\n                rank[rx] += 1\\n                \\n            return True\\n        \\n        parent = list(range(n))\\n        rank = [0] * n\\n        unions = [{i} for i in range(n)]\\n        constr = [{i} for i in range(n)]\\n        for i, j in restrs:\\n            constr[i].add(j)\\n            constr[j].add(i)\\n        \\n        return [union(i, j) for i, j in requests]\\n```",
                "solutionTags": [],
                "code": "```python\\n    def friendRequests(self, n: int, restrs: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        def find(x):\\n            if parent[x] != x:\\n                return find(parent[x])\\n            return x\\n        \\n        def union(x, y):\\n            rx, ry = find(x), find(y)\\n            if rx == ry:\\n                return True\\n            \\n            if len(constr[rx].intersection(unions[ry])) > 0:\\n                return False\\n            \\n            if rank[rx] >= rank[ry]:\\n                parent[ry] = rx\\n                unions[rx] |= unions[ry]\\n                unions[ry] = set()\\n                constr[rx] |= constr[ry]\\n                constr[ry] = set()\\n            else:\\n                parent[rx] = ry\\n                unions[ry] |= unions[rx]\\n                unions[rx] = set()\\n                constr[ry] |= constr[rx]\\n                constr[rx] = set()\\n            \\n            if rank[rx] == rank[ry]:\\n                rank[rx] += 1\\n                \\n            return True\\n        \\n        parent = list(range(n))\\n        rank = [0] * n\\n        unions = [{i} for i in range(n)]\\n        constr = [{i} for i in range(n)]\\n        for i, j in restrs:\\n            constr[i].add(j)\\n            constr[j].add(i)\\n        \\n        return [union(i, j) for i, j in requests]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1665055,
                "title": "clean-union-find-solution-in-python3",
                "content": "This is a clean Union-Find solution in Python3.\\n\\n```python\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1] * size\\n    \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        \\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        root_x, root_y = self.find(x), self.find(y)\\n        \\n        if root_x == root_y:\\n            return\\n        \\n        if self.rank[root_x] > self.rank[root_y]:\\n            self.root[root_y] = root_x\\n        elif self.rank[root_x] < self.rank[root_y]:\\n            self.root[root_x] = root_y\\n        else:\\n            self.root[root_y] = root_x\\n            self.rank[root_x] += 1\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        res = []\\n        uf = UnionFind(n)\\n        \\n        for u, v in requests:\\n            root_u, root_v = uf.find(u), uf.find(v)\\n            approved = True\\n            \\n            if root_u == root_v:\\n                res.append(approved)\\n                uf.union(u, v)\\n                continue\\n\\n            for x, y in restrictions:\\n                root_x, root_y = uf.find(x), uf.find(y)\\n\\n                if (root_u, root_v) == (root_x, root_y) or \\\\\\n                    (root_u, root_v) == (root_y, root_x):\\n                    approved = False\\n                    break\\n            \\n            res.append(approved)\\n            \\n            if approved:\\n                uf.union(u, v)\\n                \\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1] * size\\n    \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        \\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        root_x, root_y = self.find(x), self.find(y)\\n        \\n        if root_x == root_y:\\n            return\\n        \\n        if self.rank[root_x] > self.rank[root_y]:\\n            self.root[root_y] = root_x\\n        elif self.rank[root_x] < self.rank[root_y]:\\n            self.root[root_x] = root_y\\n        else:\\n            self.root[root_y] = root_x\\n            self.rank[root_x] += 1\\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        res = []\\n        uf = UnionFind(n)\\n        \\n        for u, v in requests:\\n            root_u, root_v = uf.find(u), uf.find(v)\\n            approved = True\\n            \\n            if root_u == root_v:\\n                res.append(approved)\\n                uf.union(u, v)\\n                continue\\n\\n            for x, y in restrictions:\\n                root_x, root_y = uf.find(x), uf.find(y)\\n\\n                if (root_u, root_v) == (root_x, root_y) or \\\\\\n                    (root_u, root_v) == (root_y, root_x):\\n                    approved = False\\n                    break\\n            \\n            res.append(approved)\\n            \\n            if approved:\\n                uf.union(u, v)\\n                \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663531,
                "title": "java-union-find-with-possible-optimizations-path-compression-union-by-rank",
                "content": "\\n    public int[] root;\\n    public int[] rank;\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) \\n    {\\n        boolean[] ans=new boolean[requests.length];\\n        \\n        root=new int[n];\\n        rank=new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            root[i]=i;\\n            rank[i]=1;\\n        }\\n        \\n        for(int i=0; i<requests.length; i++)\\n        {\\n            int x=requests[i][0];\\n            int y=requests[i][1];\\n            int rootX=find(x);\\n            int rootY=find(y);\\n            \\n            if(rootX==rootY) //if they are already indirectly connected\\n            {\\n                ans[i]=true;\\n                continue;\\n            }\\n            \\n            boolean can_connect=true;\\n            for(int[] res: restrictions)\\n            {\\n                int resX=find(res[0]);\\n                int resY=find(res[1]);\\n                \\n                //check roots and compare\\n                if((resX==rootX && resY==rootY) || (resX==rootY && resY==rootX))\\n                {\\n                    can_connect=false;\\n                    break;\\n                }  \\n            }\\n            \\n            if(can_connect)\\n            {\\n                ans[i]=true;\\n                if(rank[rootX]<rank[rootY])\\n                {\\n                    root[rootX]=rootY;\\n                    rank[rootY] += rank[rootX];\\n                }\\n                else\\n                {\\n                    root[rootY]=rootX;\\n                    rank[rootX] += rank[rootY];\\n                }\\n            }\\n            else\\n                ans[i]=false;\\n            \\n        }\\n        return ans;\\n    }\\n    \\n    public int find(int x)\\n    {\\n        while(x!=root[x])\\n        {\\n            root[x]=root[root[x]];\\n            x=root[x];\\n        }\\n        return x;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int[] root;\\n    public int[] rank;\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) \\n    {\\n        boolean[] ans=new boolean[requests.length];\\n        \\n        root=new int[n];\\n        rank=new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            root[i]=i;\\n            rank[i]=1;\\n        }\\n        \\n        for(int i=0; i<requests.length; i++)\\n        {\\n            int x=requests[i][0];\\n            int y=requests[i][1];\\n            int rootX=find(x);\\n            int rootY=find(y);\\n            \\n            if(rootX==rootY) //if they are already indirectly connected\\n            {\\n                ans[i]=true;\\n                continue;\\n            }\\n            \\n            boolean can_connect=true;\\n            for(int[] res: restrictions)\\n            {\\n                int resX=find(res[0]);\\n                int resY=find(res[1]);\\n                \\n                //check roots and compare\\n                if((resX==rootX && resY==rootY) || (resX==rootY && resY==rootX))\\n                {\\n                    can_connect=false;\\n                    break;\\n                }  \\n            }\\n            \\n            if(can_connect)\\n            {\\n                ans[i]=true;\\n                if(rank[rootX]<rank[rootY])\\n                {\\n                    root[rootX]=rootY;\\n                    rank[rootY] += rank[rootX];\\n                }\\n                else\\n                {\\n                    root[rootY]=rootX;\\n                    rank[rootX] += rank[rootY];\\n                }\\n            }\\n            else\\n                ans[i]=false;\\n            \\n        }\\n        return ans;\\n    }\\n    \\n    public int find(int x)\\n    {\\n        while(x!=root[x])\\n        {\\n            root[x]=root[root[x]];\\n            x=root[x];\\n        }\\n        return x;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1656465,
                "title": "time-limit-exceeded-for-python-solution-with-optimized-union-find",
                "content": "\\nI used both path compression and wighted union, but still the code is failing with TLE. Any idea why this is happening ?\\n\\n```\\nclass UnionFind:\\n    def __init__(self,n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [1] * n\\n    # with path compression\\n    def find(self,a):\\n        if a != self.parent[a]:\\n            self.parent[a] = self.find(self.parent[a])\\n        return self.parent[a]\\n    \\n    #weighted union\\n    def union(self,a,b):\\n        root_a = self.find(a)\\n        root_b = self.find(b)\\n        if self.size[a] < self.size[b]:\\n            self.parent[root_a] = root_b\\n            self.size[root_b] += self.size[root_a]\\n        else:\\n            self.parent[root_b] = root_a\\n            self.size[root_a] += self.size[root_b]\\n        \\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        res = []\\n        union_find = UnionFind(n)\\n        #iterate over requests\\n        for request in requests:\\n            a = request[0]\\n            b = request[1]\\n            root_a = union_find.find(a)\\n            root_b = union_find.find(b)\\n            has_conflict = False\\n            for restriction in restrictions:\\n                root_1 = union_find.find(restriction[0])\\n                root_2 = union_find.find(restriction[1])\\n                if set([root_a,root_b]) == set([root_1,root_2]):\\n                    res.append(False)\\n                    has_conflict = True\\n                    break\\n            if not has_conflict:\\n                union_find.union(a,b)\\n                res.append(True)\\n        return res\\n                    \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind:\\n    def __init__(self,n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [1] * n\\n    # with path compression\\n    def find(self,a):\\n        if a != self.parent[a]:\\n            self.parent[a] = self.find(self.parent[a])\\n        return self.parent[a]\\n    \\n    #weighted union\\n    def union(self,a,b):\\n        root_a = self.find(a)\\n        root_b = self.find(b)\\n        if self.size[a] < self.size[b]:\\n            self.parent[root_a] = root_b\\n            self.size[root_b] += self.size[root_a]\\n        else:\\n            self.parent[root_b] = root_a\\n            self.size[root_a] += self.size[root_b]\\n        \\n\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        res = []\\n        union_find = UnionFind(n)\\n        #iterate over requests\\n        for request in requests:\\n            a = request[0]\\n            b = request[1]\\n            root_a = union_find.find(a)\\n            root_b = union_find.find(b)\\n            has_conflict = False\\n            for restriction in restrictions:\\n                root_1 = union_find.find(restriction[0])\\n                root_2 = union_find.find(restriction[1])\\n                if set([root_a,root_b]) == set([root_1,root_2]):\\n                    res.append(False)\\n                    has_conflict = True\\n                    break\\n            if not has_conflict:\\n                union_find.union(a,b)\\n                res.append(True)\\n        return res\\n                    \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645573,
                "title": "java-with-union-find-template-comments",
                "content": "```class Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] result = new boolean[requests.length];\\n        \\n        UnionFind myUnionFind = new UnionFind(n);\\n        \\n        for(int i = 0; i < requests.length; i++)\\n        {\\n            int firstRequestParent = myUnionFind.find(requests[i][0]);\\n            int secondRequestParent = myUnionFind.find(requests[i][1]);\\n            \\n            // if they have the same parent, they can be friends\\n            if(firstRequestParent == secondRequestParent)\\n            {\\n                result[i] = true;\\n            }\\n            else\\n            {\\n                boolean canBeFriend = true;\\n                \\n                // if they don\\'t have the same parent, then we need to check do those two candidicates have any restrictions to be friends.\\n                for(int j = 0; j < restrictions.length; j++)\\n                {\\n                    int firstRestrictionParent = myUnionFind.find(restrictions[j][0]);\\n                    int secondRestrictionParent = myUnionFind.find(restrictions[j][1]);\\n                    \\n                    // if both of them are in the same set of the restiction, then they cann\\'t be friends.\\n                    if((firstRestrictionParent == firstRequestParent && secondRestrictionParent == secondRequestParent) ||(firstRestrictionParent == secondRequestParent && secondRestrictionParent == firstRequestParent))\\n                    {\\n                        canBeFriend = false;\\n                        result[i] = false;\\n                        break;\\n                    }\\n                }\\n                \\n                // if we pass the restriction check, we can union those two candidates into the same set.\\n                if(canBeFriend)\\n                {\\n                    result[i] = true;\\n                    myUnionFind.union(firstRequestParent, secondRequestParent);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n\\nclass UnionFind\\n{\\n    private Map<Integer,Integer>curToParent;\\n    \\n    public UnionFind(int n)\\n    {\\n        curToParent = new HashMap<>();\\n        for(int i = 0; i < n; i++)\\n        {\\n            curToParent.put(i, null);\\n        }\\n    }\\n    \\n    public void union(int x, int y)\\n    {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        \\n        if (rootX != rootY)\\n        {\\n            curToParent.put(rootX, rootY);\\n        }\\n    }\\n    \\n    public int find(int x)\\n    {\\n        int root = x;\\n        \\n        while(curToParent.get(root) != null)\\n        {\\n            root = curToParent.get(root);\\n        }\\n        \\n        while(root != x)\\n        {\\n            int tempFather = curToParent.get(x);\\n            curToParent.put(x, root);\\n            x = tempFather;\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] result = new boolean[requests.length];\\n        \\n        UnionFind myUnionFind = new UnionFind(n);\\n        \\n        for(int i = 0; i < requests.length; i++)\\n        {\\n            int firstRequestParent = myUnionFind.find(requests[i][0]);\\n            int secondRequestParent = myUnionFind.find(requests[i][1]);\\n            \\n            // if they have the same parent, they can be friends\\n            if(firstRequestParent == secondRequestParent)\\n            {\\n                result[i] = true;\\n            }\\n            else\\n            {\\n                boolean canBeFriend = true;\\n                \\n                // if they don\\'t have the same parent, then we need to check do those two candidicates have any restrictions to be friends.\\n                for(int j = 0; j < restrictions.length; j++)\\n                {\\n                    int firstRestrictionParent = myUnionFind.find(restrictions[j][0]);\\n                    int secondRestrictionParent = myUnionFind.find(restrictions[j][1]);\\n                    \\n                    // if both of them are in the same set of the restiction, then they cann\\'t be friends.\\n                    if((firstRestrictionParent == firstRequestParent && secondRestrictionParent == secondRequestParent) ||(firstRestrictionParent == secondRequestParent && secondRestrictionParent == firstRequestParent))\\n                    {\\n                        canBeFriend = false;\\n                        result[i] = false;\\n                        break;\\n                    }\\n                }\\n                \\n                // if we pass the restriction check, we can union those two candidates into the same set.\\n                if(canBeFriend)\\n                {\\n                    result[i] = true;\\n                    myUnionFind.union(firstRequestParent, secondRequestParent);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n\\nclass UnionFind\\n{\\n    private Map<Integer,Integer>curToParent;\\n    \\n    public UnionFind(int n)\\n    {\\n        curToParent = new HashMap<>();\\n        for(int i = 0; i < n; i++)\\n        {\\n            curToParent.put(i, null);\\n        }\\n    }\\n    \\n    public void union(int x, int y)\\n    {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        \\n        if (rootX != rootY)\\n        {\\n            curToParent.put(rootX, rootY);\\n        }\\n    }\\n    \\n    public int find(int x)\\n    {\\n        int root = x;\\n        \\n        while(curToParent.get(root) != null)\\n        {\\n            root = curToParent.get(root);\\n        }\\n        \\n        while(root != x)\\n        {\\n            int tempFather = curToParent.get(x);\\n            curToParent.put(x, root);\\n            x = tempFather;\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642096,
                "title": "python-adjacent-list-bfs-solution",
                "content": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        \\'\\'\\'\\n\\t\\tEX:\\n        restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]\\n        ban_map:\\n        {\\n        0: 1\\n        1: 0, 2\\n        2: 1, 3\\n        3: 2\\n        }\\n        friends_map\\n        {\\n        0: 4\\n        4: 0\\n        3: 1\\n        1: 3\\n        }\\n        \\'\\'\\'\\n        \\n        def bfs(_id):\\n            peri = deque([_id])\\n            visited = set([_id])\\n            relations = set()\\n            while peri:\\n                curr_id = peri.popleft()\\n                relations.add(curr_id)\\n                for edge in friends_map[curr_id]:\\n                    if edge not in visited:\\n                        visited.add(edge)\\n                        peri.append(edge)\\n            return relations\\n                        \\n        #O 4Rest\\n        ban_map = defaultdict(lambda: set())\\n        for ban in restrictions:\\n            ban_map[ban[0]].add(ban[1])\\n            ban_map[ban[1]].add(ban[0])\\n        \\n        ans = [False] * len(requests)\\n        \\n        #O 4Req\\n        friends_map = defaultdict(lambda: [])\\n        \\n        #O Req\\n        for i, req in enumerate(requests):\\n            if req[1] in ban_map[req[0]]:\\n                ans[i] = False\\n            else:\\n                set_1 = bfs(req[0])\\n                set_2 = bfs(req[1])\\n                banned = False\\n                for key in set_1:\\n                    for banned_id in ban_map[key]:\\n                        if banned_id in set_2:\\n                            ans[i] = False\\n                            banned = True\\n                if not banned:\\n                    ans[i] = True\\n                    friends_map[req[0]].append(req[1]) \\n                    friends_map[req[1]].append(req[0]) \\n        return ans\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        \\'\\'\\'\\n\\t\\tEX:\\n        restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]\\n        ban_map:\\n        {\\n        0: 1\\n        1: 0, 2\\n        2: 1, 3\\n        3: 2\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1629043,
                "title": "c-dsu",
                "content": "```\\nclass Solution {\\npublic:\\n    struct dsu\\n    {\\n        vector<int>parent;\\n        dsu(int n)\\n        {\\n            parent.resize(n);\\n            for(int i=0;i<n;i++)\\n                parent[i]=i;\\n        }\\n        int find(int x)\\n        {\\n            if(parent[x]!=x)\\n                parent[x]=find(parent[x]);\\n            return parent[x];\\n        }\\n        void Union(int x,int y)\\n        {\\n            parent[y]=x;\\n        }\\n    };\\n    vector<bool> friendRequests(int n, vector<vector<int>>& rest,vector<vector<int>>& req) \\n    {\\n        dsu graph=dsu(n);\\n        vector<vector<bool>>mat(n,vector<bool>(n,false));\\n        for(auto v:rest)\\n        {\\n            mat[v[0]][v[1]]=mat[v[1]][v[0]]=true;\\n        }\\n        vector<bool>res;\\n        for(auto v:req)\\n        {\\n            int pa=graph.find(v[0]);\\n            int pb=graph.find(v[1]);\\n            if(!mat[pa][pb])\\n            {\\n                res.push_back(true);\\n                graph.Union(pa,pb);\\n                for(int i=0;i<n;i++)\\n                {\\n                    if(mat[pb][i])\\n                    {\\n                        mat[pa][i]=mat[i][pa]=true;\\n                    }\\n                }\\n            }\\n            else\\n                res.push_back(false);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct dsu\\n    {\\n        vector<int>parent;\\n        dsu(int n)\\n        {\\n            parent.resize(n);\\n            for(int i=0;i<n;i++)\\n                parent[i]=i;\\n        }\\n        int find(int x)\\n        {\\n            if(parent[x]!=x)\\n                parent[x]=find(parent[x]);\\n            return parent[x];\\n        }\\n        void Union(int x,int y)\\n        {\\n            parent[y]=x;\\n        }\\n    };\\n    vector<bool> friendRequests(int n, vector<vector<int>>& rest,vector<vector<int>>& req) \\n    {\\n        dsu graph=dsu(n);\\n        vector<vector<bool>>mat(n,vector<bool>(n,false));\\n        for(auto v:rest)\\n        {\\n            mat[v[0]][v[1]]=mat[v[1]][v[0]]=true;\\n        }\\n        vector<bool>res;\\n        for(auto v:req)\\n        {\\n            int pa=graph.find(v[0]);\\n            int pb=graph.find(v[1]);\\n            if(!mat[pa][pb])\\n            {\\n                res.push_back(true);\\n                graph.Union(pa,pb);\\n                for(int i=0;i<n;i++)\\n                {\\n                    if(mat[pb][i])\\n                    {\\n                        mat[pa][i]=mat[i][pa]=true;\\n                    }\\n                }\\n            }\\n            else\\n                res.push_back(false);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622141,
                "title": "c-solution",
                "content": "Union Find Class\\n```\\npublic class Solution {\\n    public bool[] FriendRequests(int n, int[][] rests, int[][] reqs) {\\n        UnionFind uf = new UnionFind(n);\\n        \\n        bool[] r = new bool[reqs.Length];\\n        \\n        for (int i = 0; i < reqs.Length; ++i) {\\n            r[i] = true;\\n            int[] req = reqs[i];\\n            int pf = uf.Find(req[0]);\\n            int ps = uf.Find(req[1]);\\n            \\n            if (pf != ps) {\\n                foreach (int[] rest in rests) {\\n                    int px = uf.Find(rest[0]);\\n                    int py = uf.Find(rest[1]);\\n                    if ((pf == px && ps == py) || (pf == py && ps == px)) {\\n                        r[i] = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (r[i]) {\\n                uf.Union(req[0], req[1]);\\n            }\\n        }\\n        \\n        return r;\\n    }\\n}\\n\\npublic class UnionFind {\\n    int[] Parents;\\n    \\n    public UnionFind(int n) {\\n        Parents = new int[n];\\n        for (int i = 0; i < n; ++i) Parents[i] = i;\\n    }\\n    \\n    public void Union(int u, int v) {\\n        int pu = Find(u);\\n        int pv = Find(v);\\n        \\n        Parents[pu] = pv;\\n    }\\n    \\n    public int Find(int u) {\\n        while (u != Parents[u]) {\\n            Parents[u] = Parents[Parents[u]];\\n            u = Parents[u];\\n        }\\n        \\n        return u;\\n    }\\n    \\n    public bool IsConnected(int u, int v) {\\n        return Find(u) == Find(v);\\n    }\\n    \\n    public void ResetParent(int u) {\\n        Parents[u] = u;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool[] FriendRequests(int n, int[][] rests, int[][] reqs) {\\n        UnionFind uf = new UnionFind(n);\\n        \\n        bool[] r = new bool[reqs.Length];\\n        \\n        for (int i = 0; i < reqs.Length; ++i) {\\n            r[i] = true;\\n            int[] req = reqs[i];\\n            int pf = uf.Find(req[0]);\\n            int ps = uf.Find(req[1]);\\n            \\n            if (pf != ps) {\\n                foreach (int[] rest in rests) {\\n                    int px = uf.Find(rest[0]);\\n                    int py = uf.Find(rest[1]);\\n                    if ((pf == px && ps == py) || (pf == py && ps == px)) {\\n                        r[i] = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (r[i]) {\\n                uf.Union(req[0], req[1]);\\n            }\\n        }\\n        \\n        return r;\\n    }\\n}\\n\\npublic class UnionFind {\\n    int[] Parents;\\n    \\n    public UnionFind(int n) {\\n        Parents = new int[n];\\n        for (int i = 0; i < n; ++i) Parents[i] = i;\\n    }\\n    \\n    public void Union(int u, int v) {\\n        int pu = Find(u);\\n        int pv = Find(v);\\n        \\n        Parents[pu] = pv;\\n    }\\n    \\n    public int Find(int u) {\\n        while (u != Parents[u]) {\\n            Parents[u] = Parents[Parents[u]];\\n            u = Parents[u];\\n        }\\n        \\n        return u;\\n    }\\n    \\n    public bool IsConnected(int u, int v) {\\n        return Find(u) == Find(v);\\n    }\\n    \\n    public void ResetParent(int u) {\\n        Parents[u] = u;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617498,
                "title": "java-union-find-solution",
                "content": "```\\nclass Solution {\\n    int[] roots;\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        roots = new int[n+1];\\n        for(int i = 0; i <= n; i++)\\n        {\\n            roots[i] = i;\\n        }\\n        \\n        int i = 0;\\n        for(int[] request : requests)\\n        {\\n            int rx = findRoot(request[0]), ry = findRoot(request[1]);\\n            boolean canAdd = true;\\n            for(int[] restriction : restrictions)\\n            {\\n                int ra = findRoot(restriction[0]), rb = findRoot(restriction[1]);\\n                if((ra == rx && ry == rb) || (ra == ry && rb== rx))\\n                {\\n                    canAdd = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(canAdd)\\n            {\\n                res[i++] = true;\\n                union(rx, ry);\\n            }\\n            else\\n            {\\n                res[i++] = false;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int findRoot(int i)\\n    {\\n        int cur = i;\\n        while(roots[cur]!=cur)\\n        {\\n            cur = roots[roots[cur]];\\n        }\\n        \\n        roots[i] = cur;\\n        return cur;\\n    }\\n    \\n    public void union(int i, int j)\\n    {\\n        int r1 = findRoot(i), r2 = findRoot(j);\\n        roots[r1] = r2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] roots;\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        boolean[] res = new boolean[requests.length];\\n        roots = new int[n+1];\\n        for(int i = 0; i <= n; i++)\\n        {\\n            roots[i] = i;\\n        }\\n        \\n        int i = 0;\\n        for(int[] request : requests)\\n        {\\n            int rx = findRoot(request[0]), ry = findRoot(request[1]);\\n            boolean canAdd = true;\\n            for(int[] restriction : restrictions)\\n            {\\n                int ra = findRoot(restriction[0]), rb = findRoot(restriction[1]);\\n                if((ra == rx && ry == rb) || (ra == ry && rb== rx))\\n                {\\n                    canAdd = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(canAdd)\\n            {\\n                res[i++] = true;\\n                union(rx, ry);\\n            }\\n            else\\n            {\\n                res[i++] = false;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int findRoot(int i)\\n    {\\n        int cur = i;\\n        while(roots[cur]!=cur)\\n        {\\n            cur = roots[roots[cur]];\\n        }\\n        \\n        roots[i] = cur;\\n        return cur;\\n    }\\n    \\n    public void union(int i, int j)\\n    {\\n        int r1 = findRoot(i), r2 = findRoot(j);\\n        roots[r1] = r2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617178,
                "title": "typical-unionfind-except-we-make-it-faster-by-remember-what-we-checked",
                "content": "For each group of friends, we keep track of who they can\\'t be friends with by assigning a blacklisted set to their root. When we try to union two groups, we check if the other group contains anything from the current group\\'s blacklist. \\n\\nBut this takes constant time and we want to minimize this. As a result, if it turns out we can\\'t union two groups, we add each group\\'s head to the other group\\'s head\\'s blacklist. This way, if we got another request from the childs of two groups, we can instantly check that their heads had blacklisted one another, and quickly return False.\\n\\nAnyways here\\'s the code:\\n```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], req: List[List[int]]) -> List[bool]:\\n        \\n        parent = {}\\n        child = collections.defaultdict(set)\\n        for i in range(n):\\n            parent[i] = i\\n            child[i].add(i)\\n        \\n        \\n        banned = collections.defaultdict(set)\\n        for a, b in restrictions:\\n            banned[a].add(b)\\n            banned[b].add(a)\\n            \\n        \\n        res = []\\n        for a, b in req:\\n            \\n            \\n            # if any part of a has restriction with any part of b: False.\\n            p1 = parent[a]\\n            p2 = parent[b]\\n            \\n            \\n            #check if we can union them.\\n            \\n            if p1 in banned[p2] or p2 in banned[p1]:\\n                #fast check to see if we have tried to union them already and it no work.\\n                res.append(False)\\n                continue\\n            \\n            if p1 == p2: \\n                res.append(True)\\n                continue\\n            \\n            doable = True\\n\\n            \\n            for e in banned[p1]:\\n                if e in child[p2]:\\n                    doable = False\\n                    break\\n            \\n            if doable != False:\\n                for e in banned[p2]:\\n                    if e in child[p1]:\\n                        doable = False\\n                        break\\n            \\n            \\n            if doable: #we union them\\n                res.append(True)\\n                \\n                #put smaller p2 into bigger p1\\n                if len(child[p2]) > len(child[p1]):\\n                    tmp = p1\\n                    p1 = p2\\n                    p2 = tmp\\n                \\n                for e in banned[p2]:\\n                    banned[p1].add(e)\\n                \\n                for e in child[p2]:\\n                    child[p1].add(e)\\n                    parent[e] = p1\\n                \\n                del child[p2]\\n                del banned[p2]\\n                \\n            else:\\n                banned[p1].add(p2) #next time we try to union these two groups, we know that they\\'re already not possible\\n                banned[p2].add(p1)\\n                \\n                res.append(False)\\n            \\n#             print(\"after unioning\", a, b)\\n#             print(child)\\n        \\n        \\n        \\n        \\n        return res\\n     \\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], req: List[List[int]]) -> List[bool]:\\n        \\n        parent = {}\\n        child = collections.defaultdict(set)\\n        for i in range(n):\\n            parent[i] = i\\n            child[i].add(i)\\n        \\n        \\n        banned = collections.defaultdict(set)\\n        for a, b in restrictions:\\n            banned[a].add(b)\\n            banned[b].add(a)\\n            \\n        \\n        res = []\\n        for a, b in req:\\n            \\n            \\n            # if any part of a has restriction with any part of b: False.\\n            p1 = parent[a]\\n            p2 = parent[b]\\n            \\n            \\n            #check if we can union them.\\n            \\n            if p1 in banned[p2] or p2 in banned[p1]:\\n                #fast check to see if we have tried to union them already and it no work.\\n                res.append(False)\\n                continue\\n            \\n            if p1 == p2: \\n                res.append(True)\\n                continue\\n            \\n            doable = True\\n\\n            \\n            for e in banned[p1]:\\n                if e in child[p2]:\\n                    doable = False\\n                    break\\n            \\n            if doable != False:\\n                for e in banned[p2]:\\n                    if e in child[p1]:\\n                        doable = False\\n                        break\\n            \\n            \\n            if doable: #we union them\\n                res.append(True)\\n                \\n                #put smaller p2 into bigger p1\\n                if len(child[p2]) > len(child[p1]):\\n                    tmp = p1\\n                    p1 = p2\\n                    p2 = tmp\\n                \\n                for e in banned[p2]:\\n                    banned[p1].add(e)\\n                \\n                for e in child[p2]:\\n                    child[p1].add(e)\\n                    parent[e] = p1\\n                \\n                del child[p2]\\n                del banned[p2]\\n                \\n            else:\\n                banned[p1].add(p2) #next time we try to union these two groups, we know that they\\'re already not possible\\n                banned[p2].add(p1)\\n                \\n                res.append(False)\\n            \\n#             print(\"after unioning\", a, b)\\n#             print(child)\\n        \\n        \\n        \\n        \\n        return res\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613336,
                "title": "brute-force-via-union-find",
                "content": "**Idea**: For every request, see if it results in a violation. If yes, then mark request as not processable. Else, unify the request and mark it as processable.\\n\\n**Violation**: A request is said to be a violation, if processing the request makes any of restrictions fall inside a same component. i.e., if roots of a request == roots of a restriction, then its a violation\\n\\nRuntime: O(requests*restrictions)\\n\\n```\\nclass Solution:\\n    \\n    def find(self, x, parent):\\n        y = x\\n        while(parent[x] != x):\\n            x = parent[x]\\n        parent[y] = x\\n        return x\\n    \\n    def union(self, x, y, parent):\\n        r1 = self.find(x, parent)\\n        r2 = self.find(y, parent)\\n        parent[r2] = r1\\n        return r2\\n    \\n    def violation(self, req, restrictions, parent):\\n        req_r1 = self.find(req[0], parent)\\n        req_r2 = self.find(req[1], parent)\\n        \\n        for restr in restrictions:\\n            restr_r1 = self.find(restr[0], parent)\\n            restr_r2 = self.find(restr[1], parent)\\n            \\n            if (restr_r1 == req_r1 and restr_r2 == req_r2) or (restr_r1 == req_r2 and restr_r2 == req_r1):\\n                return True\\n        \\n        return False\\n            \\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        \\n        parent = {i:i for i in range(n)}\\n        res = []\\n        for req in requests:\\n            if self.violation(req, restrictions, parent):\\n                res.append(False)\\n            else:\\n                self.union(req[0], req[1], parent)\\n                res.append(True)\\n        return res\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def find(self, x, parent):\\n        y = x\\n        while(parent[x] != x):\\n            x = parent[x]\\n        parent[y] = x\\n        return x\\n    \\n    def union(self, x, y, parent):\\n        r1 = self.find(x, parent)\\n        r2 = self.find(y, parent)\\n        parent[r2] = r1\\n        return r2\\n    \\n    def violation(self, req, restrictions, parent):\\n        req_r1 = self.find(req[0], parent)\\n        req_r2 = self.find(req[1], parent)\\n        \\n        for restr in restrictions:\\n            restr_r1 = self.find(restr[0], parent)\\n            restr_r2 = self.find(restr[1], parent)\\n            \\n            if (restr_r1 == req_r1 and restr_r2 == req_r2) or (restr_r1 == req_r2 and restr_r2 == req_r1):\\n                return True\\n        \\n        return False\\n            \\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        \\n        parent = {i:i for i in range(n)}\\n        res = []\\n        for req in requests:\\n            if self.violation(req, restrictions, parent):\\n                res.append(False)\\n            else:\\n                self.union(req[0], req[1], parent)\\n                res.append(True)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607322,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] djs = new int[n];\\n        boolean[] res = new boolean[requests.length];\\n        \\n        Arrays.fill(djs, -1);\\n        \\n        int index = 0;\\n        for (int i = 0; i < requests.length; i++) {\\n            int parent = getParent(djs, requests[i][0]);\\n            int parent1 = getParent(djs, requests[i][1]);\\n            \\n            if (parent == parent1) {\\n                res[index++] = true;\\n                continue;                \\n            } \\n            \\n            djs[parent] = parent1;\\n            \\n            boolean remove = false;\\n            for (int j = 0; j < restrictions.length; j++) {\\n                \\n                int p = getParent(djs, restrictions[j][0]);\\n                int p1 = getParent(djs, restrictions[j][1]);\\n                \\n                if (p == p1) {\\n                    remove = true;\\n                    break;\\n                }\\n            }\\n            if (remove) {\\n                djs[parent] = -1;\\n                res[index++] = false;\\n            } else {\\n                res[index++] = true;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int getParent(int[] djs, int node) {\\n        while (djs[node] != -1) {\\n            node = djs[node];\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        int[] djs = new int[n];\\n        boolean[] res = new boolean[requests.length];\\n        \\n        Arrays.fill(djs, -1);\\n        \\n        int index = 0;\\n        for (int i = 0; i < requests.length; i++) {\\n            int parent = getParent(djs, requests[i][0]);\\n            int parent1 = getParent(djs, requests[i][1]);\\n            \\n            if (parent == parent1) {\\n                res[index++] = true;\\n                continue;                \\n            } \\n            \\n            djs[parent] = parent1;\\n            \\n            boolean remove = false;\\n            for (int j = 0; j < restrictions.length; j++) {\\n                \\n                int p = getParent(djs, restrictions[j][0]);\\n                int p1 = getParent(djs, restrictions[j][1]);\\n                \\n                if (p == p1) {\\n                    remove = true;\\n                    break;\\n                }\\n            }\\n            if (remove) {\\n                djs[parent] = -1;\\n                res[index++] = false;\\n            } else {\\n                res[index++] = true;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int getParent(int[] djs, int node) {\\n        while (djs[node] != -1) {\\n            node = djs[node];\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601582,
                "title": "cheating-question",
                "content": "Basically you only need to notice the length of restrictions and requests are both below or equal to 1000, then for each iteration of requests you can go through restrictions to check if it\\'s forbidden or not, so it\\'s boring.\\n\\n```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        // also a union find question life sucks\\n        UF uf = new UF(n);\\n        boolean[] res = new boolean[requests.length];\\n        \\n        for (int i = 0; i < requests.length; i++){\\n            int a = requests[i][0], b = requests[i][1];\\n            boolean flag = false;\\n            int pa = uf.find(a), pb = uf.find(b);\\n            for (int j = 0; j < restrictions.length; j++){\\n                int ra = uf.find(restrictions[j][0]), rb = uf.find(restrictions[j][1]);\\n                if ((ra == pa && rb == pb) || (ra == pb && rb == pa)){\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) continue;\\n            uf.union(pa,pb);\\n            res[i] = true;\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\nclass UF {\\n    int[] parents;\\n    int[] rank;\\n    public UF(int n){\\n        parents = new int[n];\\n        rank = new int[n];\\n        for (int i = 0; i < n; i++){\\n            parents[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n    \\n    public int find(int node){\\n        if (parents[node] == node) return node;\\n        return parents[node] = find(parents[node]);\\n    }\\n    \\n    public void union(int x, int y){\\n        int px = find(x), py = find(y);\\n        if (px != py){\\n            if (rank[px] >= rank[py]){\\n                parents[py] = px;\\n                rank[px] += rank[py];\\n            }else{\\n                parents[px] = py;\\n                rank[py] += rank[px];\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] friendRequests(int n, int[][] restrictions, int[][] requests) {\\n        // also a union find question life sucks\\n        UF uf = new UF(n);\\n        boolean[] res = new boolean[requests.length];\\n        \\n        for (int i = 0; i < requests.length; i++){\\n            int a = requests[i][0], b = requests[i][1];\\n            boolean flag = false;\\n            int pa = uf.find(a), pb = uf.find(b);\\n            for (int j = 0; j < restrictions.length; j++){\\n                int ra = uf.find(restrictions[j][0]), rb = uf.find(restrictions[j][1]);\\n                if ((ra == pa && rb == pb) || (ra == pb && rb == pa)){\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) continue;\\n            uf.union(pa,pb);\\n            res[i] = true;\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\nclass UF {\\n    int[] parents;\\n    int[] rank;\\n    public UF(int n){\\n        parents = new int[n];\\n        rank = new int[n];\\n        for (int i = 0; i < n; i++){\\n            parents[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n    \\n    public int find(int node){\\n        if (parents[node] == node) return node;\\n        return parents[node] = find(parents[node]);\\n    }\\n    \\n    public void union(int x, int y){\\n        int px = find(x), py = find(y);\\n        if (px != py){\\n            if (rank[px] >= rank[py]){\\n                parents[py] = px;\\n                rank[px] += rank[py];\\n            }else{\\n                parents[px] = py;\\n                rank[py] += rank[px];\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594415,
                "title": "go-union-find-set",
                "content": "```go\\nfunc friendRequests(n int, restrictions [][]int, requests [][]int) []bool {\\n\\tans := make([]bool, 0)\\n\\tufs := initUFS(n)\\n\\tfor _, request := range requests {\\n\\t\\tpx := ufs.find(request[0])\\n\\t\\tpy := ufs.find(request[1])\\n\\t\\tif px == py {\\n\\t\\t\\tans = append(ans, true)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tmerge := true\\n\\t\\tfor _, restriction := range restrictions {\\n\\t\\t\\tp0 := ufs.find(restriction[0])\\n\\t\\t\\tp1 := ufs.find(restriction[1])\\n\\t\\t\\tif (p0 == px && p1 == py) || (p1 == px && p0 == py) {\\n\\t\\t\\t\\tmerge = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif merge {\\n\\t\\t\\tufs.merge(request[0], request[1])\\n\\t\\t\\tans = append(ans, true)\\n\\t\\t} else {\\n\\t\\t\\tans = append(ans, false)\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n\\ntype UnionFindSet struct {\\n\\tparent []int\\n\\trank   []int\\n}\\n\\nfunc initUFS(n int) *UnionFindSet {\\n\\tufs := &UnionFindSet{\\n\\t\\tparent: make([]int, n),\\n\\t\\trank:   make([]int, n),\\n\\t}\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tufs.parent[i] = i\\n\\t\\tufs.rank[i] = 1\\n\\t}\\n\\treturn ufs\\n}\\n\\nfunc (ufs *UnionFindSet) find(x int) int {\\n\\tif x == ufs.parent[x] {\\n\\t\\treturn x\\n\\t} else {\\n\\t\\tufs.parent[x] = ufs.find(ufs.parent[x])\\n\\t\\treturn ufs.parent[x]\\n\\t}\\n}\\n\\nfunc (ufs *UnionFindSet) merge(x, y int) {\\n\\tpx := ufs.find(x)\\n\\tpy := ufs.find(y)\\n\\tif ufs.rank[px] <= ufs.rank[py] {\\n\\t\\tufs.parent[px] = py\\n\\t} else {\\n\\t\\tufs.parent[py] = px\\n\\t}\\n\\tif ufs.rank[px] == ufs.rank[py] && px != py {\\n\\t\\tufs.rank[py]++\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc friendRequests(n int, restrictions [][]int, requests [][]int) []bool {\\n\\tans := make([]bool, 0)\\n\\tufs := initUFS(n)\\n\\tfor _, request := range requests {\\n\\t\\tpx := ufs.find(request[0])\\n\\t\\tpy := ufs.find(request[1])\\n\\t\\tif px == py {\\n\\t\\t\\tans = append(ans, true)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tmerge := true\\n\\t\\tfor _, restriction := range restrictions {\\n\\t\\t\\tp0 := ufs.find(restriction[0])\\n\\t\\t\\tp1 := ufs.find(restriction[1])\\n\\t\\t\\tif (p0 == px && p1 == py) || (p1 == px && p0 == py) {\\n\\t\\t\\t\\tmerge = false\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif merge {\\n\\t\\t\\tufs.merge(request[0], request[1])\\n\\t\\t\\tans = append(ans, true)\\n\\t\\t} else {\\n\\t\\t\\tans = append(ans, false)\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n\\ntype UnionFindSet struct {\\n\\tparent []int\\n\\trank   []int\\n}\\n\\nfunc initUFS(n int) *UnionFindSet {\\n\\tufs := &UnionFindSet{\\n\\t\\tparent: make([]int, n),\\n\\t\\trank:   make([]int, n),\\n\\t}\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tufs.parent[i] = i\\n\\t\\tufs.rank[i] = 1\\n\\t}\\n\\treturn ufs\\n}\\n\\nfunc (ufs *UnionFindSet) find(x int) int {\\n\\tif x == ufs.parent[x] {\\n\\t\\treturn x\\n\\t} else {\\n\\t\\tufs.parent[x] = ufs.find(ufs.parent[x])\\n\\t\\treturn ufs.parent[x]\\n\\t}\\n}\\n\\nfunc (ufs *UnionFindSet) merge(x, y int) {\\n\\tpx := ufs.find(x)\\n\\tpy := ufs.find(y)\\n\\tif ufs.rank[px] <= ufs.rank[py] {\\n\\t\\tufs.parent[px] = py\\n\\t} else {\\n\\t\\tufs.parent[py] = px\\n\\t}\\n\\tif ufs.rank[px] == ufs.rank[py] && px != py {\\n\\t\\tufs.rank[py]++\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592653,
                "title": "c-union-find-by-rank",
                "content": "```\\nclass DisjointSetElement{\\n    public:\\n    int parent;\\n    int rank;\\n};\\nclass UnionFind{\\n    private:\\n    void merge(int fin,int init){\\n        this->parents[init].parent=fin;\\n        this->parents[fin].rank+=this->parents[init].rank;\\n    }\\n    public:\\n    vector<DisjointSetElement>parents;\\n    UnionFind(int n){\\n        for(int i=0;i<n;i++){\\n            DisjointSetElement element;\\n            element.parent=i;\\n            element.rank=1;\\n            this->parents.push_back(element);\\n        }\\n    }\\n    int findParent(int x){\\n        while(x!=this->parents[x].parent){\\n            x=this->parents[x].parent;\\n        }\\n        return x;\\n    }\\n    bool findUnion(int x,int y){\\n        int parx=this->findParent(x);\\n        int pary=this->findParent(y);\\n        if(parx!=pary){\\n            if(this->parents[parx].rank>=this->parents[pary].rank){\\n                this->merge(parx,pary);\\n            } else {\\n                this->merge(pary,parx);\\n            }\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n    bool isConnected(int x,int y){\\n        return this->findParent(x)==this->findParent(y);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        UnionFind uf(n);\\n        vector<bool>ans;\\n        for(int i=0;i<requests.size();i++){\\n            int u=requests[i][0];\\n            int v=requests[i][1];\\n            vector<DisjointSetElement>tmp=uf.parents;\\n            uf.findUnion(u,v);\\n            bool canAdd=true;\\n            for(int j=0;j<restrictions.size();j++){\\n                if(uf.isConnected(restrictions[j][0],restrictions[j][1])){\\n                    canAdd=false;\\n                    break;\\n                }\\n            }\\n            if(!canAdd){\\n                uf.parents=tmp;\\n            }\\n            ans.push_back(canAdd);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "class Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        UnionFind uf(n);\\n        vector<bool>ans;\\n        for(int i=0;i<requests.size();i++){\\n            int u=requests[i][0];\\n            int v=requests[i][1];\\n            vector<DisjointSetElement>tmp=uf.parents;\\n            uf.findUnion(u,v);\\n            bool canAdd=true;\\n            for(int j=0;j<restrictions.size();j++){\\n                if(uf.isConnected(restrictions[j][0],restrictions[j][1])){\\n                    canAdd=false;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1592088,
                "title": "c-verbose-and-lengthy-solution",
                "content": "Have seen very clean solutions from others whereas my solutions are very lengthy, cumbersome and hard to debug. Any tips for shorter and cleaner solutions would be highly appreciated\\n```\\nclass Solution {\\npublic:\\n  int getCliqueForClique(int clique,\\n                       unordered_map<int, int>& cliqueToClique,\\n                       unordered_map<int, unordered_set<int>>& personToEnemyCliques,\\n                       unordered_map<int, unordered_set<int>>& cliqueToEnemies,\\n                       unordered_map<int, unordered_set<int>>& cliqueToEnemyCliques) {\\n    if (cliqueToClique.find(clique) == cliqueToClique.end() ||\\n        cliqueToClique[clique] == clique) {\\n      return clique;\\n    }\\n    int parent = getCliqueForClique(cliqueToClique[clique], cliqueToClique,\\n                                    personToEnemyCliques,\\n                                    cliqueToEnemies, cliqueToEnemyCliques);\\n    cliqueToClique[clique] = parent;\\n    \\n    auto& enemies = cliqueToEnemies[clique];\\n    for (auto it = enemies.begin(); it != enemies.end(); ++it) {\\n      cliqueToEnemies[parent].insert(*it);\\n      personToEnemyCliques[*it].insert(parent);\\n    }\\n    enemies.clear();\\n    \\n    auto& enemyCliques = cliqueToEnemyCliques[clique];\\n    for (auto it = enemyCliques.begin(); it != enemyCliques.end(); ++it) {\\n      cliqueToEnemyCliques[parent].insert(*it);\\n      cliqueToEnemyCliques[*it].insert(parent);\\n    }\\n    enemyCliques.clear();\\n    return parent;\\n  }\\n  \\n  int getCliqueForPerson(int person,\\n                       unordered_map<int, int>& personToClique,\\n                       unordered_map<int, int>& cliqueToClique,\\n                       unordered_map<int, unordered_set<int>>& personToEnemies,\\n                       unordered_map<int, unordered_set<int>>& personToEnemyCliques,\\n                       unordered_map<int, unordered_set<int>>& cliqueToEnemies,\\n                       unordered_map<int, unordered_set<int>>& cliqueToEnemyCliques) {\\n    if (personToClique.find(person) == personToClique.end()) {\\n      return -1;\\n    }\\n    int clique = getCliqueForClique(personToClique[person], cliqueToClique,\\n                                    personToEnemyCliques,\\n                                    cliqueToEnemies, cliqueToEnemyCliques);\\n    \\n    personToClique[person] = clique;\\n    auto& enemies = personToEnemies[person];\\n    for (auto it = enemies.begin(); it != enemies.end(); ++it) {\\n      cliqueToEnemies[clique].insert(*it);\\n      personToEnemyCliques[*it].insert(clique);\\n    }\\n    enemies.clear();\\n    \\n    auto& enemyCliques = personToEnemyCliques[person];\\n    for (auto it = enemyCliques.begin(); it != enemyCliques.end(); ++it) {\\n      cliqueToEnemyCliques[clique].insert(*it);\\n      cliqueToEnemyCliques[*it].insert(clique);\\n    }\\n    enemyCliques.clear();\\n    return clique;\\n  }\\n  \\n  vector<bool> friendRequests(int n, vector<vector<int>>& restrictions,\\n                              vector<vector<int>>& requests) {\\n    vector<bool> result(requests.size(), false);\\n    unordered_map<int, int> personToClique;\\n    unordered_map<int, int> cliqueToClique;\\n    \\n    unordered_map<int, unordered_set<int>> personToEnemies;\\n    unordered_map<int, unordered_set<int>> cliqueToEnemies;\\n    unordered_map<int, unordered_set<int>> personToEnemyCliques;\\n    unordered_map<int, unordered_set<int>> cliqueToEnemyCliques;\\n    \\n    for (auto& vc: restrictions) {\\n      int p1 = vc[0], p2 = vc[1];\\n      personToEnemies[p1].insert(p2);\\n      personToEnemies[p2].insert(p1);\\n    }\\n    \\n    int numCliques = 0;\\n    for (int i = 0; i < requests.size(); ++i) {\\n      auto& vc = requests[i];\\n      int p1 = vc[0], p2 = vc[1];\\n      \\n      int c1 = getCliqueForPerson(p1, personToClique, cliqueToClique,\\n                                  personToEnemies,\\n                                  personToEnemyCliques,\\n                                  cliqueToEnemies,\\n                                  cliqueToEnemyCliques);\\n      int c2 = getCliqueForPerson(p2, personToClique, cliqueToClique,\\n                                  personToEnemies,\\n                                  personToEnemyCliques,\\n                                  cliqueToEnemies,\\n                                  cliqueToEnemyCliques);\\n      \\n      bool outcome = true;\\n      \\n      if (personToEnemies[p1].find(p2) != personToEnemies[p1].end()) {\\n        outcome = false;\\n      } else if (c1 != -1 && c2 != -1) {\\n        if (c1 == c2) {\\n          outcome = true;\\n        } else if (cliqueToEnemyCliques[c1].find(c2) !=\\n                   cliqueToEnemyCliques[c1].end()) {\\n          outcome = false;\\n        } else if (cliqueToEnemies[c1].find(p2) != cliqueToEnemies[c1].end()) {\\n          outcome = false;\\n        }\\n      } else if (c1 != -1) {\\n        if (cliqueToEnemies[c1].find(p2) != cliqueToEnemies[c1].end()) {\\n          outcome = false;\\n        }\\n      } else if (c2 != -1) {\\n        if (cliqueToEnemies[c2].find(p1) != cliqueToEnemies[c2].end()) {\\n          outcome = false;\\n        }\\n      }\\n      \\n      if (outcome) {\\n        if (c1 != -1 && c2 != -1) {\\n          cliqueToClique[c1] = c2;\\n        } else if (c1 != -1) {\\n          personToClique[p2] = c1;\\n        } else if (c2 != -1) {\\n          personToClique[p1] = c2;\\n        } else {\\n          personToClique[p1] = numCliques;\\n          personToClique[p2] = numCliques;\\n          numCliques++;\\n        }\\n      } else {\\n        personToEnemies[p1].insert(p2);\\n        personToEnemies[p2].insert(p1);\\n        if (c1 != -1 && c2 != -1) {\\n          cliqueToEnemyCliques[c1].insert(c2);\\n          cliqueToEnemyCliques[c2].insert(c1);\\n          personToEnemyCliques[p1].insert(c2);\\n          personToEnemyCliques[p2].insert(c1);\\n        } else if (c1 != -1) {\\n          personToClique[p2] = numCliques;\\n          numCliques++;\\n          \\n          cliqueToEnemies[c1].insert(p2);\\n          personToEnemyCliques[p2].insert(c1);\\n        } else if (c2 != -1) {\\n          personToClique[p1] = numCliques;\\n          numCliques++;\\n          \\n          cliqueToEnemies[c2].insert(p1);\\n          personToEnemyCliques[p1].insert(c2);\\n        } else {\\n          personToClique[p1] = numCliques;\\n          numCliques++;\\n          personToClique[p2] = numCliques;\\n          numCliques++;\\n        }\\n      }\\n\\n      c1 = getCliqueForPerson(p1, personToClique, cliqueToClique,\\n                              personToEnemies,\\n                              personToEnemyCliques,\\n                              cliqueToEnemies,\\n                              cliqueToEnemyCliques);\\n      c2 = getCliqueForPerson(p2, personToClique, cliqueToClique,\\n                              personToEnemies,\\n                              personToEnemyCliques,\\n                              cliqueToEnemies,\\n                              cliqueToEnemyCliques);\\n\\n      result[i] = outcome;\\n    }\\n    return result;\\n  }\\n\\n};\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int getCliqueForClique(int clique,\\n                       unordered_map<int, int>& cliqueToClique,\\n                       unordered_map<int, unordered_set<int>>& personToEnemyCliques,\\n                       unordered_map<int, unordered_set<int>>& cliqueToEnemies,\\n                       unordered_map<int, unordered_set<int>>& cliqueToEnemyCliques) {\\n    if (cliqueToClique.find(clique) == cliqueToClique.end() ||\\n        cliqueToClique[clique] == clique) {\\n      return clique;\\n    }\\n    int parent = getCliqueForClique(cliqueToClique[clique], cliqueToClique,\\n                                    personToEnemyCliques,\\n                                    cliqueToEnemies, cliqueToEnemyCliques);\\n    cliqueToClique[clique] = parent;\\n    \\n    auto& enemies = cliqueToEnemies[clique];\\n    for (auto it = enemies.begin(); it != enemies.end(); ++it) {\\n      cliqueToEnemies[parent].insert(*it);\\n      personToEnemyCliques[*it].insert(parent);\\n    }\\n    enemies.clear();\\n    \\n    auto& enemyCliques = cliqueToEnemyCliques[clique];\\n    for (auto it = enemyCliques.begin(); it != enemyCliques.end(); ++it) {\\n      cliqueToEnemyCliques[parent].insert(*it);\\n      cliqueToEnemyCliques[*it].insert(parent);\\n    }\\n    enemyCliques.clear();\\n    return parent;\\n  }\\n  \\n  int getCliqueForPerson(int person,\\n                       unordered_map<int, int>& personToClique,\\n                       unordered_map<int, int>& cliqueToClique,\\n                       unordered_map<int, unordered_set<int>>& personToEnemies,\\n                       unordered_map<int, unordered_set<int>>& personToEnemyCliques,\\n                       unordered_map<int, unordered_set<int>>& cliqueToEnemies,\\n                       unordered_map<int, unordered_set<int>>& cliqueToEnemyCliques) {\\n    if (personToClique.find(person) == personToClique.end()) {\\n      return -1;\\n    }\\n    int clique = getCliqueForClique(personToClique[person], cliqueToClique,\\n                                    personToEnemyCliques,\\n                                    cliqueToEnemies, cliqueToEnemyCliques);\\n    \\n    personToClique[person] = clique;\\n    auto& enemies = personToEnemies[person];\\n    for (auto it = enemies.begin(); it != enemies.end(); ++it) {\\n      cliqueToEnemies[clique].insert(*it);\\n      personToEnemyCliques[*it].insert(clique);\\n    }\\n    enemies.clear();\\n    \\n    auto& enemyCliques = personToEnemyCliques[person];\\n    for (auto it = enemyCliques.begin(); it != enemyCliques.end(); ++it) {\\n      cliqueToEnemyCliques[clique].insert(*it);\\n      cliqueToEnemyCliques[*it].insert(clique);\\n    }\\n    enemyCliques.clear();\\n    return clique;\\n  }\\n  \\n  vector<bool> friendRequests(int n, vector<vector<int>>& restrictions,\\n                              vector<vector<int>>& requests) {\\n    vector<bool> result(requests.size(), false);\\n    unordered_map<int, int> personToClique;\\n    unordered_map<int, int> cliqueToClique;\\n    \\n    unordered_map<int, unordered_set<int>> personToEnemies;\\n    unordered_map<int, unordered_set<int>> cliqueToEnemies;\\n    unordered_map<int, unordered_set<int>> personToEnemyCliques;\\n    unordered_map<int, unordered_set<int>> cliqueToEnemyCliques;\\n    \\n    for (auto& vc: restrictions) {\\n      int p1 = vc[0], p2 = vc[1];\\n      personToEnemies[p1].insert(p2);\\n      personToEnemies[p2].insert(p1);\\n    }\\n    \\n    int numCliques = 0;\\n    for (int i = 0; i < requests.size(); ++i) {\\n      auto& vc = requests[i];\\n      int p1 = vc[0], p2 = vc[1];\\n      \\n      int c1 = getCliqueForPerson(p1, personToClique, cliqueToClique,\\n                                  personToEnemies,\\n                                  personToEnemyCliques,\\n                                  cliqueToEnemies,\\n                                  cliqueToEnemyCliques);\\n      int c2 = getCliqueForPerson(p2, personToClique, cliqueToClique,\\n                                  personToEnemies,\\n                                  personToEnemyCliques,\\n                                  cliqueToEnemies,\\n                                  cliqueToEnemyCliques);\\n      \\n      bool outcome = true;\\n      \\n      if (personToEnemies[p1].find(p2) != personToEnemies[p1].end()) {\\n        outcome = false;\\n      } else if (c1 != -1 && c2 != -1) {\\n        if (c1 == c2) {\\n          outcome = true;\\n        } else if (cliqueToEnemyCliques[c1].find(c2) !=\\n                   cliqueToEnemyCliques[c1].end()) {\\n          outcome = false;\\n        } else if (cliqueToEnemies[c1].find(p2) != cliqueToEnemies[c1].end()) {\\n          outcome = false;\\n        }\\n      } else if (c1 != -1) {\\n        if (cliqueToEnemies[c1].find(p2) != cliqueToEnemies[c1].end()) {\\n          outcome = false;\\n        }\\n      } else if (c2 != -1) {\\n        if (cliqueToEnemies[c2].find(p1) != cliqueToEnemies[c2].end()) {\\n          outcome = false;\\n        }\\n      }\\n      \\n      if (outcome) {\\n        if (c1 != -1 && c2 != -1) {\\n          cliqueToClique[c1] = c2;\\n        } else if (c1 != -1) {\\n          personToClique[p2] = c1;\\n        } else if (c2 != -1) {\\n          personToClique[p1] = c2;\\n        } else {\\n          personToClique[p1] = numCliques;\\n          personToClique[p2] = numCliques;\\n          numCliques++;\\n        }\\n      } else {\\n        personToEnemies[p1].insert(p2);\\n        personToEnemies[p2].insert(p1);\\n        if (c1 != -1 && c2 != -1) {\\n          cliqueToEnemyCliques[c1].insert(c2);\\n          cliqueToEnemyCliques[c2].insert(c1);\\n          personToEnemyCliques[p1].insert(c2);\\n          personToEnemyCliques[p2].insert(c1);\\n        } else if (c1 != -1) {\\n          personToClique[p2] = numCliques;\\n          numCliques++;\\n          \\n          cliqueToEnemies[c1].insert(p2);\\n          personToEnemyCliques[p2].insert(c1);\\n        } else if (c2 != -1) {\\n          personToClique[p1] = numCliques;\\n          numCliques++;\\n          \\n          cliqueToEnemies[c2].insert(p1);\\n          personToEnemyCliques[p1].insert(c2);\\n        } else {\\n          personToClique[p1] = numCliques;\\n          numCliques++;\\n          personToClique[p2] = numCliques;\\n          numCliques++;\\n        }\\n      }\\n\\n      c1 = getCliqueForPerson(p1, personToClique, cliqueToClique,\\n                              personToEnemies,\\n                              personToEnemyCliques,\\n                              cliqueToEnemies,\\n                              cliqueToEnemyCliques);\\n      c2 = getCliqueForPerson(p2, personToClique, cliqueToClique,\\n                              personToEnemies,\\n                              personToEnemyCliques,\\n                              cliqueToEnemies,\\n                              cliqueToEnemyCliques);\\n\\n      result[i] = outcome;\\n    }\\n    return result;\\n  }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589411,
                "title": "python-explanation-faster-than-99",
                "content": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        \\n        solution = []\\n        \\n        node_node = {i:set() for i in range(n)} # mapping of node to the nodes it has restrictions with\\n        \\n        node_component = {i:-1 for i in range(n)} # mapping of node to the component ID it belongs to\\n        \\n        components = {} # mapping of the different components to their component ID\\n        \\n        for edge in restrictions:\\n            u,v = edge\\n            node_node[u].add(v)\\n            node_node[v].add(u)\\n            \\n        for request in requests:\\n            u,v = request\\n            \\n            # if neither are in a component, make new component with this edge\\n            if node_component[u] == -1 and node_component[v] == -1:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# check if direct restriction exists\\n                if u not in node_node[v] and v not in node_node[u]:\\n                    min_node = min(u,v)\\n                    node_component[u] = min_node\\n                    node_component[v] = min_node\\n                    components[min_node] = {u,v}\\n                    solution.append(True)\\n                else:\\n                    solution.append(False)\\n            \\n            # if both are in a component, check for indirect restrictions\\n            elif node_component[u] != -1 and node_component[v] != -1:\\n                component1 = components[node_component[u]]\\n                component2 = components[node_component[v]]\\n                flag = True\\n                \\n\\t\\t\\t\\t# check if both belong to the same component\\n                if node_component[u] == node_component[v]:\\n                    solution.append(True)\\n                    flag = False\\n                \\n\\t\\t\\t\\t\\n                # for every node in 1 component check every node in the other component for restrictions\\n                if flag:\\n                    for node in component1:\\n                        if len(node_node[node].intersection(component2)) != 0:\\n                            solution.append(False)\\n                            flag = False\\n                            break\\n                if flag:\\n                    for node in component2:\\n                        if len(node_node[node].intersection(component1)) != 0:\\n                            solution.append(False)\\n                            flag = False\\n                            break\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t# if no restriction, union their two components and delete one component\\n                if flag:\\n                    min_node = min(node_component[u],node_component[v])\\n                    max_node = max(node_component[u],node_component[v])\\n                    components[min_node].update(components[max_node])\\n                    for node in components[max_node]:\\n                        node_component[node] = min_node\\n                    del components[max_node]\\n                    solution.append(True)\\n            \\n            # if only one is in a component\\n            else:\\n                # check if the node without a component has an issue with the nodes in the other component\\n                if node_component[u] == -1:\\n                    res = (len(node_node[u].intersection(components[node_component[v]])) != 0)\\n                    if res:\\n                        solution.append(False)\\n                    else:\\n                        components[node_component[v]].add(u)\\n                        node_component[u] = node_component[v]\\n                        solution.append(True)\\n                else:\\n                    res = (len(node_node[v].intersection(components[node_component[u]])) != 0)\\n                    if res:\\n                        solution.append(False)\\n                    else:\\n                        components[node_component[u]].add(v)\\n                        node_component[v] = node_component[u]\\n                        solution.append(True)\\n\\n        return solution\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:\\n        \\n        solution = []\\n        \\n        node_node = {i:set() for i in range(n)} # mapping of node to the nodes it has restrictions with\\n        \\n        node_component = {i:-1 for i in range(n)} # mapping of node to the component ID it belongs to\\n        \\n        components = {} # mapping of the different components to their component ID\\n        \\n        for edge in restrictions:\\n            u,v = edge\\n            node_node[u].add(v)\\n            node_node[v].add(u)\\n            \\n        for request in requests:\\n            u,v = request\\n            \\n            # if neither are in a component, make new component with this edge\\n            if node_component[u] == -1 and node_component[v] == -1:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# check if direct restriction exists\\n                if u not in node_node[v] and v not in node_node[u]:\\n                    min_node = min(u,v)\\n                    node_component[u] = min_node\\n                    node_component[v] = min_node\\n                    components[min_node] = {u,v}\\n                    solution.append(True)\\n                else:\\n                    solution.append(False)\\n            \\n            # if both are in a component, check for indirect restrictions\\n            elif node_component[u] != -1 and node_component[v] != -1:\\n                component1 = components[node_component[u]]\\n                component2 = components[node_component[v]]\\n                flag = True\\n                \\n\\t\\t\\t\\t# check if both belong to the same component\\n                if node_component[u] == node_component[v]:\\n                    solution.append(True)\\n                    flag = False\\n                \\n\\t\\t\\t\\t\\n                # for every node in 1 component check every node in the other component for restrictions\\n                if flag:\\n                    for node in component1:\\n                        if len(node_node[node].intersection(component2)) != 0:\\n                            solution.append(False)\\n                            flag = False\\n                            break\\n                if flag:\\n                    for node in component2:\\n                        if len(node_node[node].intersection(component1)) != 0:\\n                            solution.append(False)\\n                            flag = False\\n                            break\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t# if no restriction, union their two components and delete one component\\n                if flag:\\n                    min_node = min(node_component[u],node_component[v])\\n                    max_node = max(node_component[u],node_component[v])\\n                    components[min_node].update(components[max_node])\\n                    for node in components[max_node]:\\n                        node_component[node] = min_node\\n                    del components[max_node]\\n                    solution.append(True)\\n            \\n            # if only one is in a component\\n            else:\\n                # check if the node without a component has an issue with the nodes in the other component\\n                if node_component[u] == -1:\\n                    res = (len(node_node[u].intersection(components[node_component[v]])) != 0)\\n                    if res:\\n                        solution.append(False)\\n                    else:\\n                        components[node_component[v]].add(u)\\n                        node_component[u] = node_component[v]\\n                        solution.append(True)\\n                else:\\n                    res = (len(node_node[v].intersection(components[node_component[u]])) != 0)\\n                    if res:\\n                        solution.append(False)\\n                    else:\\n                        components[node_component[u]].add(v)\\n                        node_component[v] = node_component[u]\\n                        solution.append(True)\\n\\n        return solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588082,
                "title": "c-union-find-soln",
                "content": "1. First step iterate  requests from 1 to n;\\n2. find the parent of u and v(requests[i][0],requests[i][1]),suppose parent a and b respectively.\\n3. if(a==b) ---> (u,v) requests valid=true , and push into the vector and continue for other requests.\\n4. else iterate restrictions from 1 to m;\\n5. find the parent of u1,v1(restrictions[i][0],restrictions[i][1]) ,suppose parents a1,b1 respectively\\n6.    if(a1==a && b1==b || a1==b && b1==a || (u==u1 && v==v1)|| (u==v1&& v==u1))--> valid=false and break the inner loop\\n7.    Now if valid==true --> then take union parent[b]=a and push the valid into vector\\n8.    final step return vector\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int>parent;\\n    int find_set(int u)\\n    {\\n        if(parent[u]==u)\\n            return u;\\n        return  find_set(parent[u]);\\n    }\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            parent.push_back(i);\\n        }\\n        vector<bool>res;\\n        \\n        for(int i=0;i<requests.size();i++)\\n        {\\n            int u=requests[i][0];\\n            int v=requests[i][1];\\n            int a=find_set(u);\\n            int b=find_set(v);\\n            bool valid=true;\\n            if(a==b)\\n            {\\n                valid=true;\\n                res.push_back(valid);\\n                continue;\\n            }\\n            for(int j=0;j<restrictions.size();j++)\\n            {\\n                int u1=restrictions[j][0];\\n                int v1=restrictions[j][1];\\n                int a1=find_set(u1);\\n                int b1=find_set(v1);\\n                if(a1==a && b1==b || a1==b && b1==a || (u==u1 && v==v1)|| (u==v1&& v==u1))\\n                {\\n                    res.push_back(false);\\n                    valid =false;\\n                    break;\\n                }\\n            }\\n            if(valid==true)\\n            {\\n                res.push_back(true);\\n                parent[b]=a;\\n            }\\n                \\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int>parent;\\n    int find_set(int u)\\n    {\\n        if(parent[u]==u)\\n            return u;\\n        return  find_set(parent[u]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1588016,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int r_i = 0;\\n        vector<bool> ans;\\n        for(auto& v : requests) {\\n            int a = v[0], b = v[1];\\n            bool is_possible = 1;\\n            for(auto& r : restrictions) {\\n                int x = r[0], y = r[1];\\n                if((a == x && b == y) || (a == y && b == x)) {\\n                    is_possible = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(is_possible) {\\n                for(int i = r_i+1; i < requests.size(); i++) {\\n                    if(requests[i][0] == a) requests[i][0] = b;\\n                    if(requests[i][1] == a) requests[i][1] = b;\\n                }\\n                \\n                for(int i = 0; i < restrictions.size(); i++) {\\n                    if(restrictions[i][0] == a) restrictions[i][0] = b;\\n                    if(restrictions[i][1] == a) restrictions[i][1] = b;\\n                }\\n            }\\n            \\n            ans.push_back(is_possible);\\n            r_i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> friendRequests(int n, vector<vector<int>>& restrictions, vector<vector<int>>& requests) {\\n        int r_i = 0;\\n        vector<bool> ans;\\n        for(auto& v : requests) {\\n            int a = v[0], b = v[1];\\n            bool is_possible = 1;\\n            for(auto& r : restrictions) {\\n                int x = r[0], y = r[1];\\n                if((a == x && b == y) || (a == y && b == x)) {\\n                    is_possible = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(is_possible) {\\n                for(int i = r_i+1; i < requests.size(); i++) {\\n                    if(requests[i][0] == a) requests[i][0] = b;\\n                    if(requests[i][1] == a) requests[i][1] = b;\\n                }\\n                \\n                for(int i = 0; i < restrictions.size(); i++) {\\n                    if(restrictions[i][0] == a) restrictions[i][0] = b;\\n                    if(restrictions[i][1] == a) restrictions[i][1] = b;\\n                }\\n            }\\n            \\n            ans.push_back(is_possible);\\n            r_i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1880136,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "in example 3 [3,1] should be false as 0 ,1,2,3 are connected through restrictions itself\\nwhat am i missing ? thanks"
                    },
                    {
                        "username": "czjnbb",
                        "content": "1 and 3 can be friend. Before the [3,1] friend request, friends groups are: (0,4), (1), (2), (3); and (0,4), (1,3), (2) won't violate any of the restrictions."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Google , Hard, lengthy .... \nfrom laid back to fully focused !!\n"
                    }
                ]
            },
            {
                "id": 1774271,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "in example 3 [3,1] should be false as 0 ,1,2,3 are connected through restrictions itself\\nwhat am i missing ? thanks"
                    },
                    {
                        "username": "czjnbb",
                        "content": "1 and 3 can be friend. Before the [3,1] friend request, friends groups are: (0,4), (1), (2), (3); and (0,4), (1,3), (2) won't violate any of the restrictions."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Google , Hard, lengthy .... \nfrom laid back to fully focused !!\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Paths in Maze That Lead to Same Room",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1722898,
                "content": [
                    {
                        "username": "RohitSgh",
                        "content": "**Question :** Let `n` be $V$, and `corridors.length` be $E$. What will be the best Time Complexity for this problem **?**"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": " `class Solution {\\npublic:\\n    void dfs(int node, vector<int>& vis, vector<vector<int>>& adjList, int connectedCorners, int connectedEdges){\\n        vis[node] = 1;\\n        connectedEdges += adjList[node].size();\\n        connectedCorners++;\\n        for(auto a : adjList[node]){\\n            if(!vis[a]) dfs(a, vis, adjList, connectedCorners, connectedEdges);\\n        }\\n    }\\npublic:\\n    int numberOfPaths(int n, vector<vector<int>>& corridors) {\\n        //so the corridors are basically the undirected edges in the graph\\n        //number of different cycles of lenght 3 is the number of complete components\\n        //that have the number of edges 3\\n        int k = corridors.size();\\n        vector<vector<int>> adjList(n);\\n        for(int i=0; i< k; i++){\\n            adjList[corridors[i][0] - 1].push_back(corridors[i][1] - 1);\\n            adjList[corridors[i][1] - 1].push_back(corridors[i][0] - 1);\\n        }\\n        vector<int> vis(n, 0);\\n        int confusionScore = 0;\\n        for(int i=0; i< n; i++){\\n            if(!vis[i]){\\n                int connectedCorners = 0;\\n                int connectedEdges = 0;\\n                dfs(i, vis, adjList, connectedCorners, connectedEdges);\\n                if((connectedCorners*(connectedCorners-1) == connectedEdges) && (connectedCorners == 3)) confusionScore++;\\n            }\\n        }\\n        return confusionScore;\\n    }\\n};\\nCan anyone tell me where I went wrong???\\n\\n"
                    }
                ]
            },
            {
                "id": 2015514,
                "content": [
                    {
                        "username": "RohitSgh",
                        "content": "**Question :** Let `n` be $V$, and `corridors.length` be $E$. What will be the best Time Complexity for this problem **?**"
                    },
                    {
                        "username": "Soumya_The_Legend",
                        "content": " `class Solution {\\npublic:\\n    void dfs(int node, vector<int>& vis, vector<vector<int>>& adjList, int connectedCorners, int connectedEdges){\\n        vis[node] = 1;\\n        connectedEdges += adjList[node].size();\\n        connectedCorners++;\\n        for(auto a : adjList[node]){\\n            if(!vis[a]) dfs(a, vis, adjList, connectedCorners, connectedEdges);\\n        }\\n    }\\npublic:\\n    int numberOfPaths(int n, vector<vector<int>>& corridors) {\\n        //so the corridors are basically the undirected edges in the graph\\n        //number of different cycles of lenght 3 is the number of complete components\\n        //that have the number of edges 3\\n        int k = corridors.size();\\n        vector<vector<int>> adjList(n);\\n        for(int i=0; i< k; i++){\\n            adjList[corridors[i][0] - 1].push_back(corridors[i][1] - 1);\\n            adjList[corridors[i][1] - 1].push_back(corridors[i][0] - 1);\\n        }\\n        vector<int> vis(n, 0);\\n        int confusionScore = 0;\\n        for(int i=0; i< n; i++){\\n            if(!vis[i]){\\n                int connectedCorners = 0;\\n                int connectedEdges = 0;\\n                dfs(i, vis, adjList, connectedCorners, connectedEdges);\\n                if((connectedCorners*(connectedCorners-1) == connectedEdges) && (connectedCorners == 3)) confusionScore++;\\n            }\\n        }\\n        return confusionScore;\\n    }\\n};\\nCan anyone tell me where I went wrong???\\n\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Two Furthest Houses With Different Colors",
        "question_content": "<p>There are <code>n</code> houses evenly lined up on the street, and each house is beautifully painted. You are given a <strong>0-indexed</strong> integer array <code>colors</code> of length <code>n</code>, where <code>colors[i]</code> represents the color of the <code>i<sup>th</sup></code> house.</p>\n\n<p>Return <em>the <strong>maximum</strong> distance between <strong>two</strong> houses with <strong>different</strong> colors</em>.</p>\n\n<p>The distance between the <code>i<sup>th</sup></code> and <code>j<sup>th</sup></code> houses is <code>abs(i - j)</code>, where <code>abs(x)</code> is the <strong>absolute value</strong> of <code>x</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/31/eg1.png\" style=\"width: 610px; height: 84px;\" />\n<pre>\n<strong>Input:</strong> colors = [<u><strong>1</strong></u>,1,1,<strong><u>6</u></strong>,1,1,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> In the above image, color 1 is blue, and color 6 is red.\nThe furthest two houses with different colors are house 0 and house 3.\nHouse 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3.\nNote that houses 3 and 6 can also produce the optimal answer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/31/eg2.png\" style=\"width: 426px; height: 84px;\" />\n<pre>\n<strong>Input:</strong> colors = [<u><strong>1</strong></u>,8,3,8,<u><strong>3</strong></u>]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> In the above image, color 1 is blue, color 8 is yellow, and color 3 is green.\nThe furthest two houses with different colors are house 0 and house 4.\nHouse 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> colors = [<u><strong>0</strong></u>,<strong><u>1</u></strong>]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The furthest two houses with different colors are house 0 and house 1.\nHouse 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n ==&nbsp;colors.length</code></li>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= colors[i] &lt;= 100</code></li>\n\t<li>Test data are generated such that <strong>at least</strong> two houses have different colors.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1589141,
                "title": "java-c-python-o-n-solution",
                "content": "# **Intuition**\\nThe first and the last house can be one of the furthest houses.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n# **Solution 1**\\nFind the last house with different color of the fisrt house.\\nFind the first house with different color of the last house.\\nReturn the max distance of these two options.\\n\\n**Java**\\n```java\\n    public int maxDistance(int[] A) {\\n        int n = A.length, i = 0, j = n - 1;\\n        while (A[0] == A[j]) j--;\\n        while (A[n - 1] == A[i]) i++;\\n        return Math.max(n - 1 - i, j);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int maxDistance(vector<int>& A) {\\n        int n = A.size(), i = 0, j = n - 1;\\n        while (A[0] == A[j]) j--;\\n        while (A[n - 1] == A[i]) i++;\\n        return max(n - 1 - i, j);\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maxDistance(self, A):\\n        i, j = 0, len(A) - 1\\n        while A[0] == A[j]: j -= 1\\n        while A[-1] == A[i]: i += 1\\n        return max(len(A) - 1 - i, j)\\n```\\n\\n# **Solution 2**\\nIdea from @ye15\\nIterate all element,\\nand check its color with the first and the last house.\\n\\n**Java**\\n```java\\n    public int maxDistance(int[] A) {\\n        int res = 0, n = A.length;\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] != A[0])\\n                res = Math.max(res, i);\\n            if (A[i] != A[n - 1])\\n                res = Math.max(res, n - 1 - i);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int maxDistance(vector<int>& A) {\\n        int res = 0, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] != A[0])\\n                res = max(res, i);\\n            if (A[i] != A[n - 1])\\n                res = max(res, n - 1 - i);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maxDistance(self, A):\\n        res = 0\\n        for i, x in enumerate(A):\\n            if x != A[0]:\\n                res = max(res, i)\\n            if x != A[-1]:\\n                res = max(res, len(A) - 1 - i)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int maxDistance(int[] A) {\\n        int n = A.length, i = 0, j = n - 1;\\n        while (A[0] == A[j]) j--;\\n        while (A[n - 1] == A[i]) i++;\\n        return Math.max(n - 1 - i, j);\\n    }\\n```\n```cpp\\n    int maxDistance(vector<int>& A) {\\n        int n = A.size(), i = 0, j = n - 1;\\n        while (A[0] == A[j]) j--;\\n        while (A[n - 1] == A[i]) i++;\\n        return max(n - 1 - i, j);\\n    }\\n```\n```py\\n    def maxDistance(self, A):\\n        i, j = 0, len(A) - 1\\n        while A[0] == A[j]: j -= 1\\n        while A[-1] == A[i]: i += 1\\n        return max(len(A) - 1 - i, j)\\n```\n```java\\n    public int maxDistance(int[] A) {\\n        int res = 0, n = A.length;\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] != A[0])\\n                res = Math.max(res, i);\\n            if (A[i] != A[n - 1])\\n                res = Math.max(res, n - 1 - i);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int maxDistance(vector<int>& A) {\\n        int res = 0, n = A.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (A[i] != A[0])\\n                res = max(res, i);\\n            if (A[i] != A[n - 1])\\n                res = max(res, n - 1 - i);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def maxDistance(self, A):\\n        res = 0\\n        for i, x in enumerate(A):\\n            if x != A[0]:\\n                res = max(res, i)\\n            if x != A[-1]:\\n                res = max(res, len(A) - 1 - i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1589029,
                "title": "constant-space",
                "content": "The maximum distance will always include either first or the last house. This can be proven by a contradiction.\\n\\nTherefore, we need to return the maximum of two cases: `max(j, n - i - 1)`, where\\n- `i` is the leftmost position of the color different from the last color.\\n- `j` is the rightmost position of the color different from the first one.\\n\\n![image](https://assets.leetcode.com/users/images/e6c7f77b-1f76-4ec8-9488-43a197994d62_1637524109.6583953.png)\\n\\n**C++**\\n```cpp\\nint maxDistance(vector<int>& cs) {\\n    int n = cs.size(), i = 0, j = n - 1;\\n    while (cs[0] == cs[j])\\n        --j;\\n    while (cs[n - 1] == cs[i])\\n        ++i;\\n    return max(j, n - i - 1);\\n}\\n```\\n**Java**\\n```java\\npublic int maxDistance(int[] cs) {\\n    int n = cs.length, i = 0, j = n - 1;\\n    while (cs[0] == cs[j])\\n        --j;\\n    while (cs[n - 1] == cs[i])\\n        ++i;\\n    return Math.max(j, n - i - 1);     \\n}\\n```\\n\\n#### Alternative Solution\\nWe only care about two positions: `0` for the first color, and the first position for some other color (`p`).\\n\\nIt works since we are looking for a maximum distance:\\n- If color `i` is different than the first one, the maximum distance is `i`.\\n- If color `i` is the same as the first one, the maximum distance is `i - p`.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        p, res = inf, 0\\n        for i, c in enumerate(colors):\\n            if (c != colors[0]):\\n                res = i\\n                p = min(p, i)\\n            else:\\n                res = max(res, i - p)\\n        return res\\n```\\n**C++**\\n```cpp\\nint maxDistance(vector<int>& cs) {\\n    int p = INT_MAX, res = 1;\\n    for (int i = 1; i < cs.size(); ++i) {\\n        if (cs[i] != cs[0])\\n            p = min(i, p);\\n        res = max({res, cs[i] == cs[0] ? 0 : i, i - p });\\n    }\\n    return res;\\n}\\n```\\n**Java**\\n```java\\npublic int maxDistance(int[] cs) {\\n    int p_col2 = Integer.MAX_VALUE, res = 1;\\n    for (int i = 1; i < cs.length; ++i) {\\n        if (cs[i] != cs[0]) {\\n            p_col2 = Math.min(i, p_col2);\\n            res = i;\\n        }\\n        else\\n            res = Math.max(res, i - p_col2);\\n    }\\n    return res;        \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```cpp\\nint maxDistance(vector<int>& cs) {\\n    int n = cs.size(), i = 0, j = n - 1;\\n    while (cs[0] == cs[j])\\n        --j;\\n    while (cs[n - 1] == cs[i])\\n        ++i;\\n    return max(j, n - i - 1);\\n}\\n```\n```java\\npublic int maxDistance(int[] cs) {\\n    int n = cs.length, i = 0, j = n - 1;\\n    while (cs[0] == cs[j])\\n        --j;\\n    while (cs[n - 1] == cs[i])\\n        ++i;\\n    return Math.max(j, n - i - 1);     \\n}\\n```\n```python\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        p, res = inf, 0\\n        for i, c in enumerate(colors):\\n            if (c != colors[0]):\\n                res = i\\n                p = min(p, i)\\n            else:\\n                res = max(res, i - p)\\n        return res\\n```\n```cpp\\nint maxDistance(vector<int>& cs) {\\n    int p = INT_MAX, res = 1;\\n    for (int i = 1; i < cs.size(); ++i) {\\n        if (cs[i] != cs[0])\\n            p = min(i, p);\\n        res = max({res, cs[i] == cs[0] ? 0 : i, i - p });\\n    }\\n    return res;\\n}\\n```\n```java\\npublic int maxDistance(int[] cs) {\\n    int p_col2 = Integer.MAX_VALUE, res = 1;\\n    for (int i = 1; i < cs.length; ++i) {\\n        if (cs[i] != cs[0]) {\\n            p_col2 = Math.min(i, p_col2);\\n            res = i;\\n        }\\n        else\\n            res = Math.max(res, i - p_col2);\\n    }\\n    return res;        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591355,
                "title": "c-simple-4-line-solution-o-n-tc-o-1-tc-explained",
                "content": "**Explanation:**\\nWe are guaranteed to have at least two houses with different colors.\\nThe biggest distance with probably be the first house or the last house, with some other one.\\nSo in the first loop we find the leftmost house that has a different color from the last house.\\nIn the second loop we find the rightmost house that has a different color from the first house.\\nWe return the maximum between both.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int from_left = 0, n = colors.size(), from_right = n - 1;\\n        while (colors[from_left] == colors[n-1]) from_left++;\\n        while (colors[from_right] == colors[0]) from_right--;\\n        return max(from_right, n-from_left-1);\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int from_left = 0, n = colors.size(), from_right = n - 1;\\n        while (colors[from_left] == colors[n-1]) from_left++;\\n        while (colors[from_right] == colors[0]) from_right--;\\n        return max(from_right, n-from_left-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589119,
                "title": "python3-one-of-end-points-will-be-used",
                "content": "Downvoters, lease a comment! \\n\\nIt is not difficult to find out that at least one of the end points will be used. \\n\\nPlease check out this [commit](https://github.com/gaosanyong/leetcode/commit/b5ca73e6f7d317e9f30f7e67a499b0bf489ec019) for the solutions of weekly 268. \\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ans = 0 \\n        for i, x in enumerate(colors): \\n            if x != colors[0]: ans = max(ans, i)\\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ans = 0 \\n        for i, x in enumerate(colors): \\n            if x != colors[0]: ans = max(ans, i)\\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589010,
                "title": "c-o-n-time-one-pass",
                "content": "\\n\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Map\\n\\nFor each `A[i]`:\\n* If this is the first occurrence of this value, store `A[i] -> i` in a map `m`.\\n* Loop through each `num, index` pair the map `m` and calculate the maximum `i - index` value if `num != A[i]`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/\\n// Author: github.com/lzl124631x\\n// Time: O(NM) where `N` is the length of `A` and `M` is the range of numbers in `A`.\\n// Space: O(M)\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& A) {\\n        unordered_map<int, int> m; // first occurrence index\\n        int ans = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (m.count(A[i]) == 0) m[A[i]] = i;\\n            for (auto &[c, j] : m) {\\n                if (c != A[i]) {\\n                    ans = max(ans, i - j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nOr use array.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/\\n// Author: github.com/lzl124631x\\n// Time: O(NM) where `N` is the length of `A` and `M` is the range of numbers in `A`.\\n// Space: O(M)\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& A) {\\n        int ans = 0, index[101] = {[0 ... 100] = -1};\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (index[A[i]] == -1) index[A[i]] = i;\\n            for (int j = 0; j <= 100; ++j) {\\n                if (index[j] != -1 && j != A[i]) {\\n                    ans = max(ans, i - index[j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. Mono-increasing Index Array\\n\\nFor each `A[i]`:\\n* If this is the first occurrence of this value, push `i` into a `vector<int> index`.\\n* Loop through each index value `j` in `index` array, and update answer with `i - j` for the first `A[j] != A[i]`. This step at most looks at two indices, so it\\'s `O(1)` time.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/\\n// Author: github.com/lzl124631x\\n// Time: O(N) where `N` is the length of `A` and `M` is the range of numbers in `A`.\\n// Space: O(M)\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& A) {\\n        vector<int> index; // first occurrence index\\n        int ans = 0, seen[101] = {};\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (!seen[i]) {\\n                seen[i] = 1;\\n                index.push_back(i);\\n            }\\n            for (int j : index) {\\n                if (A[j] != A[i]) {\\n                    ans = max(ans, i - j);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/\\n// Author: github.com/lzl124631x\\n// Time: O(NM) where `N` is the length of `A` and `M` is the range of numbers in `A`.\\n// Space: O(M)\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& A) {\\n        unordered_map<int, int> m; // first occurrence index\\n        int ans = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (m.count(A[i]) == 0) m[A[i]] = i;\\n            for (auto &[c, j] : m) {\\n                if (c != A[i]) {\\n                    ans = max(ans, i - j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/\\n// Author: github.com/lzl124631x\\n// Time: O(NM) where `N` is the length of `A` and `M` is the range of numbers in `A`.\\n// Space: O(M)\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& A) {\\n        int ans = 0, index[101] = {[0 ... 100] = -1};\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (index[A[i]] == -1) index[A[i]] = i;\\n            for (int j = 0; j <= 100; ++j) {\\n                if (index[j] != -1 && j != A[i]) {\\n                    ans = max(ans, i - index[j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-268/problems/two-furthest-houses-with-different-colors/\\n// Author: github.com/lzl124631x\\n// Time: O(N) where `N` is the length of `A` and `M` is the range of numbers in `A`.\\n// Space: O(M)\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& A) {\\n        vector<int> index; // first occurrence index\\n        int ans = 0, seen[101] = {};\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (!seen[i]) {\\n                seen[i] = 1;\\n                index.push_back(i);\\n            }\\n            for (int j : index) {\\n                if (A[j] != A[i]) {\\n                    ans = max(ans, i - j);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908014,
                "title": "90-o-n-fast-easy-2-pointer-greedy",
                "content": "Easiest way to do a scan like this is with two pointers. Fix a left pointer, and while they\\'re equal, move the right pointer from the end, inward until they arent. Then, take the distance by index. However, that will only solve the example cases. To correctly solve an edge case (where Greedy comes in to play), do the same thing but from the other end. Fix the right pointer at the end and move the left pointer by one every time. Since you\\'re making two separate passes, time complexity isn\\'t compounding so it is just O(n). No extra space, either O(1). \\n![image](https://assets.leetcode.com/users/images/00d1685d-6a91-4a26-b2c3-6e6d3f8d7593_1648929985.1841433.png)\\n\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n\\t\\t#first pass\\n        l, r = 0, len(colors)-1\\n        dist = 0\\n        \\n        while r > l:\\n            if colors[r] != colors[l]:\\n                dist = r-l\\n\\t\\t\\t\\t#slight performance increase, break out if you find it \\n\\t\\t\\t\\t#because it can\\'t get bigger than this\\n                break \\n            r -= 1\\n\\t\\t\\t\\n        #second pass, backwards\\n        l, r = 0, len(colors)-1\\n        while r > l:\\n            if colors[r] != colors[l]:\\n                dist = max(dist, r-l)\\n                break\\n            l += 1\\n        \\n        return dist\\n\\t\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "Easiest way to do a scan like this is with two pointers. Fix a left pointer, and while they\\'re equal, move the right pointer from the end, inward until they arent. Then, take the distance by index. However, that will only solve the example cases. To correctly solve an edge case (where Greedy comes in to play), do the same thing but from the other end. Fix the right pointer at the end and move the left pointer by one every time. Since you\\'re making two separate passes, time complexity isn\\'t compounding so it is just O(n). No extra space, either O(1). \\n![image](https://assets.leetcode.com/users/images/00d1685d-6a91-4a26-b2c3-6e6d3f8d7593_1648929985.1841433.png)\\n\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n\\t\\t#first pass\\n        l, r = 0, len(colors)-1\\n        dist = 0\\n        \\n        while r > l:\\n            if colors[r] != colors[l]:\\n                dist = r-l\\n\\t\\t\\t\\t#slight performance increase, break out if you find it \\n\\t\\t\\t\\t#because it can\\'t get bigger than this\\n                break \\n            r -= 1\\n\\t\\t\\t\\n        #second pass, backwards\\n        l, r = 0, len(colors)-1\\n        while r > l:\\n            if colors[r] != colors[l]:\\n                dist = max(dist, r-l)\\n                break\\n            l += 1\\n        \\n        return dist\\n\\t\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 1663289,
                "title": "easy-python-solution",
                "content": "```\\ndef maxDistance(self, colors: List[int]) -> int:\\n        m=0\\n        for i in range(0,len(colors)):\\n            for j in range(len(colors)-1,0,-1):\\n                if colors[i]!=colors[j] and j>i:\\n                    m=max(m,j-i)\\n        return m\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef maxDistance(self, colors: List[int]) -> int:\\n        m=0\\n        for i in range(0,len(colors)):\\n            for j in range(len(colors)-1,0,-1):\\n                if colors[i]!=colors[j] and j>i:\\n                    m=max(m,j-i)\\n        return m\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1725518,
                "title": "beginner-friendly-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int l = 0, r = colors.length-1;\\n        while(colors[colors.length-1] == colors[l]) l++;\\n        while(colors[0] == colors[r]) r--;\\n        return Math.max(r, colors.length - 1 - l);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int l = 0, r = colors.length-1;\\n        while(colors[colors.length-1] == colors[l]) l++;\\n        while(colors[0] == colors[r]) r--;\\n        return Math.max(r, colors.length - 1 - l);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596964,
                "title": "python-loop-from-both-sides",
                "content": "```\\n        l = 0\\n        r = len(colors) - 1\\n\\t\\tc_len = r\\n        while colors[l] == colors[r]:\\n            r -= 1\\n        while colors[c_len] == colors[l]:\\n            l += 1\\n        return max(r-0, c_len-l)\\n```",
                "solutionTags": [],
                "code": "```\\n        l = 0\\n        r = len(colors) - 1\\n\\t\\tc_len = r\\n        while colors[l] == colors[r]:\\n            r -= 1\\n        while colors[c_len] == colors[l]:\\n            l += 1\\n        return max(r-0, c_len-l)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589851,
                "title": "2078-two-furthest-houses-with-different-colors",
                "content": "---\\n\\n- Contest - https://leetcode.com/contest/weekly-contest-268/\\n  - Q1 Answer\\n    - below\\n\\t\\t- O(N ^ 2) solution\\n\\t\\t- O(N) solution\\n          - https://leetcode.com/problems/two-furthest-houses-with-different-colors/discuss/1589851/2078.-Two-Furthest-Houses-With-Different-Colors\\n  - Q2 Answer\\n    - https://leetcode.com/problems/watering-plants/discuss/1589904/2079.-Watering-Plants\\n  - Q3 Answer\\n    - https://leetcode.com/problems/range-frequency-queries/discuss/1589775/2080.-Range-Frequency-Queries\\n  - Q4 Answer\\n    - https://leetcode.com/problems/sum-of-k-mirror-numbers/discuss/1590172/2081.-Sum-of-k-Mirror-Numbers\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**O(N ^ 2) solution**\\n\\n```\\nvar maxDistance = function (colors) {\\n    let n = colors.length;\\n\\n    let max = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i + 1; j < n; j++) {\\n            if (colors[i] !== colors[j]) {\\n                max = Math.max(max, j - i);\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```\\n\\n---\\n\\n**O(N) solution**\\n\\n- Credit:\\n  - https://leetcode-cn.com/for-you-9\\n  - See (`for-you-9` row, `Q1` column) at https://leetcode.com/contest/weekly-contest-268/ranking\\n\\n```\\nvar maxDistance = function (colors) {\\n    let n = colors.length;\\n\\n    let max = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (colors[i] !== colors[0]) {\\n            max = Math.max(max, i);\\n        }\\n        if (colors[i] !== colors[n - 1]) {\\n            max = Math.max(max, n - 1 - i);\\n        }\\n    }\\n    return max;\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxDistance = function (colors) {\\n    let n = colors.length;\\n\\n    let max = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i + 1; j < n; j++) {\\n            if (colors[i] !== colors[j]) {\\n                max = Math.max(max, j - i);\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```\n```\\nvar maxDistance = function (colors) {\\n    let n = colors.length;\\n\\n    let max = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (colors[i] !== colors[0]) {\\n            max = Math.max(max, i);\\n        }\\n        if (colors[i] !== colors[n - 1]) {\\n            max = Math.max(max, n - 1 - i);\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3285318,
                "title": "3-liner-easy-to-understand-100-efficient-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n=colors.size(),i=0, j=n-1;\\n        while(colors[j]==colors[0]) j--;\\n        while(colors[i]==colors[n-1]) i++;\\n        return max(j,n-1-i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n=colors.size(),i=0, j=n-1;\\n        while(colors[j]==colors[0]) j--;\\n        while(colors[i]==colors[n-1]) i++;\\n        return max(j,n-1-i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596331,
                "title": "java-beats-100-simple",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int j=colors.length-1;\\n        int i=0;\\n        while(colors[j]==colors[0])j--;\\n        while(colors[i]==colors[colors.length-1])i++;\\n        return Math.max(colors.length-i-1,j);\\n    }\\n}\\nPlease upvote if you like the solution \\uD83D\\uDE4F",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxDistance(int[] colors) {\\n        int j=colors.length-1;\\n        int i=0;\\n        while(colors[j]==colors[0])j--;\\n        while(colors[i]==colors[colors.length-1])i++;\\n        return Math.max(colors.length-i-1,j);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2209588,
                "title": "c-solution-0ms-100-faster-time-o-n-space-o-1-explained",
                "content": "**Method:**\\n\\n```\\nAs we know that, there will be least two houses with different colors.\\n* The maximum distance will always include either first or the last house. \\n* So in the first loop we find the leftmost house that has a different color from the last house.\\n* In the second loop we find the rightmost house that has a different color from the first house.\\n* return the minimum of both distances.\\n\\n```\\n\\n**Time Complexity:O(n)**\\n**Space Complexity:O(1)**\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int maxDistance(vector<int> &colors)\\n    {\\n        int n = colors.size();\\n        int from_start = 0;    //first index from the start which is different from the last element\\n        int from_end = n - 1;   //first index from the last which is different from the first element\\n        while (colors[0] == colors[from_end])\\n            from_end--;\\n        while (colors[n - 1] == colors[from_start])\\n            from_start++;\\n        return max(from_end, n - from_start - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nAs we know that, there will be least two houses with different colors.\\n* The maximum distance will always include either first or the last house. \\n* So in the first loop we find the leftmost house that has a different color from the last house.\\n* In the second loop we find the rightmost house that has a different color from the first house.\\n* return the minimum of both distances.\\n\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int maxDistance(vector<int> &colors)\\n    {\\n        int n = colors.size();\\n        int from_start = 0;    //first index from the start which is different from the last element\\n        int from_end = n - 1;   //first index from the last which is different from the first element\\n        while (colors[0] == colors[from_end])\\n            from_end--;\\n        while (colors[n - 1] == colors[from_start])\\n            from_start++;\\n        return max(from_end, n - from_start - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779719,
                "title": "java-1ms-very-fast-and-easy-solution",
                "content": "In this Question it is required that we find out the maximum distance between two distinct numbers in an array.\\nFor this we can use the following approach which is an efficient way to find the required output.\\n\\n**Approach**\\n\\n*Step 1* :- First of all we run a loop from the *front* or the *left part of the Array.\\n\\n*Step 2* :- Then we run a nested loop from the *rear* side or the *right par* of the Array so that we can find the number which is not matching with the number we choosed in the front part.\\n\\n*Step 3* :- Then we check if the difference between there indices is gretear than the maximum difference or not.\\n\\n*Step 4* :- If yes then we store this difference in max\\n\\n```\\n\\n    public int maxDistance(int[] colors) {\\n        int m=0;\\n        for(int i=0;i<colors.length;i++)\\n        {\\n            for(int j=colors.length-1;j>=0;j--)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    if(Math.abs(j-i)>m)\\n                        m=Math.abs(j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        return m;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "In this Question it is required that we find out the maximum distance between two distinct numbers in an array.\\nFor this we can use the following approach which is an efficient way to find the required output.\\n\\n**Approach**\\n\\n*Step 1* :- First of all we run a loop from the *front* or the *left part of the Array.\\n\\n*Step 2* :- Then we run a nested loop from the *rear* side or the *right par* of the Array so that we can find the number which is not matching with the number we choosed in the front part.\\n\\n*Step 3* :- Then we check if the difference between there indices is gretear than the maximum difference or not.\\n\\n*Step 4* :- If yes then we store this difference in max\\n\\n```\\n\\n    public int maxDistance(int[] colors) {\\n        int m=0;\\n        for(int i=0;i<colors.length;i++)\\n        {\\n            for(int j=colors.length-1;j>=0;j--)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    if(Math.abs(j-i)>m)\\n                        m=Math.abs(j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        return m;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1775316,
                "title": "python3-both-side-checking-fastest",
                "content": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        clr1=colors[0]\\n        clr2=colors[-1]\\n        mx=0\\n        for i in range(len(colors)-1,-1,-1):\\n            if clr1!=colors[i]:\\n                mx=max(mx,i)\\n                break\\n        for i in range(len(colors)):\\n            if clr2!=colors[i]:\\n                mx=max(mx,len(colors)-i-1)\\n        return mx\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        clr1=colors[0]\\n        clr2=colors[-1]\\n        mx=0\\n        for i in range(len(colors)-1,-1,-1):\\n            if clr1!=colors[i]:\\n                mx=max(mx,i)\\n                break\\n        for i in range(len(colors)):\\n            if clr2!=colors[i]:\\n                mx=max(mx,len(colors)-i-1)\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590542,
                "title": "javascript-o-n-solution-100",
                "content": "```\\nvar maxDistance = function(colors) {\\n    // using two pointers from start and end\\n    // Time complexity O(n)\\n    // Space complexity O(1)\\n    \\n    const start = 0;\\n    const end = colors.length - 1;\\n\\n    // maximum distance possible is length of arr, so start with two pointer\\n\\t// one at the start and one at the end\\n    const startColor = colors[start];\\n    const endColor = colors[end];\\n    \\n\\t// base condition, to check if they are not already equal\\n    if (startColor !== endColor) {\\n        return end;\\n    }\\n    \\n\\t// move the forward pointer till we find the differend color\\n    let forwardPtr = start;\\n    while (startColor === colors[forwardPtr]) {\\n        ++forwardPtr;\\n    }\\n    \\n    // move the backward pointer till we find the differend color\\n    let backwardPtr = end;\\n    while(endColor === colors[backwardPtr]) {\\n        --backwardPtr;\\n    }\\n    \\n    // Till here, We already know that startColor === endColor\\n    // hence we did two things,\\n \\t// 1. we kept startColor fixed and moved backwardPtr till we find different color\\n    // 2. similarly, we kept endColor fixed and moved the forwardPtr till we find the different color.\\n   // we will return the max different out of two now.\\n    return Math.max(Math.abs(start - backwardPtr), Math.abs(end - forwardPtr));\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxDistance = function(colors) {\\n    // using two pointers from start and end\\n    // Time complexity O(n)\\n    // Space complexity O(1)\\n    \\n    const start = 0;\\n    const end = colors.length - 1;\\n\\n    // maximum distance possible is length of arr, so start with two pointer\\n\\t// one at the start and one at the end\\n    const startColor = colors[start];\\n    const endColor = colors[end];\\n    \\n\\t// base condition, to check if they are not already equal\\n    if (startColor !== endColor) {\\n        return end;\\n    }\\n    \\n\\t// move the forward pointer till we find the differend color\\n    let forwardPtr = start;\\n    while (startColor === colors[forwardPtr]) {\\n        ++forwardPtr;\\n    }\\n    \\n    // move the backward pointer till we find the differend color\\n    let backwardPtr = end;\\n    while(endColor === colors[backwardPtr]) {\\n        --backwardPtr;\\n    }\\n    \\n    // Till here, We already know that startColor === endColor\\n    // hence we did two things,\\n \\t// 1. we kept startColor fixed and moved backwardPtr till we find different color\\n    // 2. similarly, we kept endColor fixed and moved the forwardPtr till we find the different color.\\n   // we will return the max different out of two now.\\n    return Math.max(Math.abs(start - backwardPtr), Math.abs(end - forwardPtr));\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1590429,
                "title": "worst-case-o-n-time-complexity",
                "content": "The algorithm consists of two steps:\\n- find the first house from the end which does not match the color of the house at front\\n- find the first house from the front which does not match the color of the house at back\\n\\nWe can use while loop for both steps. It will give us an algorithm with worst case time complexity of O(n).\\n\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int Max = INT_MIN;\\n        int N = colors.size();\\n        \\n        // find the first house from the end which does not match the color of house at front\\n        int j=N;\\n        while(--j>=0 && colors[0]==colors[j]) { }   // worst-case O(n)\\n        Max = abs(j-0);\\n        \\n        // find the first house from the front which does not match the color of house at back\\n        j=-1;\\n        while(++j<N && colors[N-1]==colors[j]) { }  // worst-case O(n)\\n        Max = max(Max, abs(j-(N-1)));\\n        \\n        return Max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int Max = INT_MIN;\\n        int N = colors.size();\\n        \\n        // find the first house from the end which does not match the color of house at front\\n        int j=N;\\n        while(--j>=0 && colors[0]==colors[j]) { }   // worst-case O(n)\\n        Max = abs(j-0);\\n        \\n        // find the first house from the front which does not match the color of house at back\\n        j=-1;\\n        while(++j<N && colors[N-1]==colors[j]) { }  // worst-case O(n)\\n        Max = max(Max, abs(j-(N-1)));\\n        \\n        return Max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589540,
                "title": "python-solution-with-explanation",
                "content": "here we first fix the initial value as value of color at index 1st and in second case value at index last .\\nwe do so to find the  max value of x (which is the distance between 2 different colors ).\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        x=0\\n        first=0\\n        last=len(colors)-1\\n        while(first<last):\\n            if(colors[first]!=colors[last]):\\n                x=max(x,last-first)\\n            last=last-1\\n            \\n        first=0\\n        last=len(colors)-1\\n        while(first<last):\\n            if(colors[first]!=colors[last]):\\n                x=max(x,last-first)\\n            first+=1\\n            \\n        return(x)\\n```\\nIf u understood the code then plz...UPVOTE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        x=0\\n        first=0\\n        last=len(colors)-1\\n        while(first<last):\\n            if(colors[first]!=colors[last]):\\n                x=max(x,last-first)\\n            last=last-1\\n            \\n        first=0\\n        last=len(colors)-1\\n        while(first<last):\\n            if(colors[first]!=colors[last]):\\n                x=max(x,last-first)\\n            first+=1\\n            \\n        return(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228880,
                "title": "easy-java-solution-time-complexity-o-n",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int ans=-1;\\n        int left=0,right=colors.length-1;\\n        while(left<=right){\\n            if(colors[left]==colors[right]){\\n                right--;\\n            }\\n            else{\\n                ans=Math.max(ans,right-left);\\n                left++;\\n                right=colors.length-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int ans=-1;\\n        int left=0,right=colors.length-1;\\n        while(left<=right){\\n            if(colors[left]==colors[right]){\\n                right--;\\n            }\\n            else{\\n                ans=Math.max(ans,right-left);\\n                left++;\\n                right=colors.length-1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774236,
                "title": "java-easy-solution-4-liner",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n      int n = colors.length, i = 0, j = n - 1;\\n        while (colors[0] == colors[j]) j--;\\n        while (colors[n - 1] == colors[i]) i++;\\n        return Math.max(n - 1 - i, j);  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n      int n = colors.length, i = 0, j = n - 1;\\n        while (colors[0] == colors[j]) j--;\\n        while (colors[n - 1] == colors[i]) i++;\\n        return Math.max(n - 1 - i, j);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629656,
                "title": "c-2-pointer-approch-andd-grredy",
                "content": "class Solution {\\npublic:\\n    int maxDistance(vector<int>& c) \\n    {\\n        int n=c.size();\\n        int j=n-1;\\n        int i=0;\\n        while(c[0]==c[j])\\n            j--;\\n        while(c[i]==c[n-1])\\n            i++;\\n        return max(n-1-i,j);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxDistance(vector<int>& c) \\n    {\\n        int n=c.size();\\n        int j=n-1;\\n        int i=0;\\n        while(c[0]==c[j])\\n            j--;\\n        while(c[i]==c[n-1])\\n            i++;\\n        return max(n-1-i,j);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2608812,
                "title": "1ms-simple-fast-and-easy-java-solution-with-o-n-complexity",
                "content": "```\\nclass Solution \\n{\\n    public int maxDistance(int[] colors) \\n    {\\n        int j = colors.length-1;\\n        int k = 0;\\n        int dist1 = 0;\\n        int dist2 =0;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// distance from front index.\\n        for(int i=0;i<colors.length;i++){\\n              if(colors[i] != colors[j]){\\n                  dist1 = j-i;\\n                  break;\\n              }\\n          }\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // distance from last index\\n        for(int i = colors.length-1; i>-1;i--){\\n            if(colors[i] != colors[k]){\\n                dist2 = i-k;\\n                break;\\n            }\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t              \\t// whichever is having more distance.\\n        return Math.max(dist1,dist2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int maxDistance(int[] colors) \\n    {\\n        int j = colors.length-1;\\n        int k = 0;\\n        int dist1 = 0;\\n        int dist2 =0;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// distance from front index.\\n        for(int i=0;i<colors.length;i++){\\n              if(colors[i] != colors[j]){\\n                  dist1 = j-i;\\n                  break;\\n              }\\n          }\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // distance from last index\\n        for(int i = colors.length-1; i>-1;i--){\\n            if(colors[i] != colors[k]){\\n                dist2 = i-k;\\n                break;\\n            }\\n\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t              \\t// whichever is having more distance.\\n        return Math.max(dist1,dist2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459626,
                "title": "runtime-0-ms-faster-than-100-00-very-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& arr) \\n    {\\n        int start=0;\\n        int end=arr.size()-1;\\n        \\n        int ans=INT_MIN;\\n        \\n        while(arr[start]==arr[end])\\n        {\\n            end--;\\n        }\\n        ans=max(ans,end-start);\\n        \\n        start=0;\\n        end=arr.size()-1;\\n        \\n        while(arr[start]==arr[end])\\n        {\\n            start++;\\n        }\\n        \\n        ans=max(ans,end-start);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& arr) \\n    {\\n        int start=0;\\n        int end=arr.size()-1;\\n        \\n        int ans=INT_MIN;\\n        \\n        while(arr[start]==arr[end])\\n        {\\n            end--;\\n        }\\n        ans=max(ans,end-start);\\n        \\n        start=0;\\n        end=arr.size()-1;\\n        \\n        while(arr[start]==arr[end])\\n        {\\n            start++;\\n        }\\n        \\n        ans=max(ans,end-start);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324246,
                "title": "two-solutions-o-n-and-o-n-2",
                "content": "O(n)\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        i=0\\n        l=len(colors)\\n        j=l-1\\n        while colors[j] == colors[0]:\\n            j-=1\\n        \\n        while colors[-1] == colors[i]:\\n            i+=1\\n        return max(j,l-1-i)\\n```\\nO(n^2)\\n```\\n        max_dist=0\\n        l=len(colors)\\n        for i in range(l):\\n             for j in range(l):\\n                if colors[i]!=colors[j]:\\n                     max_dist = max(max_dist,abs(j-i))\\n        return max_dist\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        i=0\\n        l=len(colors)\\n        j=l-1\\n        while colors[j] == colors[0]:\\n            j-=1\\n        \\n        while colors[-1] == colors[i]:\\n            i+=1\\n        return max(j,l-1-i)\\n```\n```\\n        max_dist=0\\n        l=len(colors)\\n        for i in range(l):\\n             for j in range(l):\\n                if colors[i]!=colors[j]:\\n                     max_dist = max(max_dist,abs(j-i))\\n        return max_dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616071,
                "title": "simple-python-solution-o-n",
                "content": "## INTUITION:\\n\\n- __Target__: Compute the maximum distance between two houses of different colors\\n- __Assumption__: \\n\\t- The distance between any two houses is uniform and equal to one.\\n\\t- There has to be atleast two elements in the array/list to compute the distance.\\n- Maximum possible distance is observed  when the house on the two ends are of different color\\n    - In such a scenario, we can simply look up the first and last elements of the array/list and return the distance as `length_of _array - 1 `\\n- If the first and last houses are of the same color, \\n\\t- We need to traverse the array to find a house of different color\\n\\t- Compute the distance from the houses on either ends and take the maximum of it.\\n\\t- Update a Counter Variable that maintains the largest distance for any such house of different color\\n\\n## CODE:\\n```python\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        n = len(colors)\\n        if n < 2:\\n            return 0 \\n        if colors[0]!=colors[-1]:\\n            return n-1\\n        d = 0\\n        for i in range(n):\\n            if colors[i] != colors[0]:\\n                d = max(d,i)\\n            if colors[i] != colors[-1]:\\n                d = max(d,n-1-i)\\n        return d\\n```\\n\\n ## TIME COMPLEXITY:\\n-  O(n)\\n- In the worst case scenario, we have to iterate through the entire list/array of colors for n houses\\n\\n## SPACE COMPLEXITY:\\n- O(1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```python\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        n = len(colors)\\n        if n < 2:\\n            return 0 \\n        if colors[0]!=colors[-1]:\\n            return n-1\\n        d = 0\\n        for i in range(n):\\n            if colors[i] != colors[0]:\\n                d = max(d,i)\\n            if colors[i] != colors[-1]:\\n                d = max(d,n-1-i)\\n        return d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591546,
                "title": "c-1-line-solution-w-explanations-o-n-100-time-o-1-space",
                "content": "# Solution idea\\nWe only need to consider these two options and pick the best of two results:\\n- Distance between the first house and the rightmost house having a different color\\n- Distance between the last house and the leftmost house having a different color\\n\\n![image](https://assets.leetcode.com/users/images/8b213169-ee1d-4eec-9538-9cd84cac6f8c_1637591631.338769.png)\\n\\nFor a trivial case where the first and the last house have different colors, this logic will also work, even though these distance will be the same:\\n![image](https://assets.leetcode.com/users/images/18761997-f8e7-4da0-8c03-83a7614152f3_1637591667.0252492.png)\\n\\n# One-line solution\\n```csharp\\npublic int MaxDistance(int[] colors) \\n{\\n  return Math.Max(\\n    Array.FindLastIndex(colors, x => x != colors.First()), \\n    colors.Length - Array.FindIndex(colors, x => x != colors.Last()) - 1\\n  );\\n}\\n```\\n\\n# More verbose solution\\nThough, this is how I would solve it in production code or during a coding interview:\\n\\n```csharp\\n  public int MaxDistance(int[] colors) \\n  {\\n    if (colors == null)\\n      throw new ArgumentNullException(nameof(colors));\\n    \\n    if (colors.Length < 2)\\n      throw new ArgumentException(nameof(colors), \"Should contain at least two houses\");\\n    \\n\\t// Trivial case: 1st and last house are different, use them\\n    if (colors[0] != colors[colors.Length - 1]) \\n      return colors.Length - 1;\\n     \\n    // Non-trivial case: 1st and last houses are the same\\n\\t// Then try to match them separately against the furthest house on the opposide side\\n    int leftmostIndex = Array.FindIndex(colors, x => x != colors[0]);\\n      \\n    if (leftmostIndex == -1)\\n      throw new ArgumentException(nameof(colors), \"All houses have the same color, invalid input\");\\n      \\n    int rightmostIndex = Array.FindLastIndex(colors, x => x != colors[0]);      \\n\\n    return Math.Max(\\n      rightmostIndex,\\n      colors.Length - leftmostIndex - 1\\n    );\\n }\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MaxDistance(int[] colors) \\n{\\n  return Math.Max(\\n    Array.FindLastIndex(colors, x => x != colors.First()), \\n    colors.Length - Array.FindIndex(colors, x => x != colors.Last()) - 1\\n  );\\n}\\n```\n```csharp\\n  public int MaxDistance(int[] colors) \\n  {\\n    if (colors == null)\\n      throw new ArgumentNullException(nameof(colors));\\n    \\n    if (colors.Length < 2)\\n      throw new ArgumentException(nameof(colors), \"Should contain at least two houses\");\\n    \\n\\t// Trivial case: 1st and last house are different, use them\\n    if (colors[0] != colors[colors.Length - 1]) \\n      return colors.Length - 1;\\n     \\n    // Non-trivial case: 1st and last houses are the same\\n\\t// Then try to match them separately against the furthest house on the opposide side\\n    int leftmostIndex = Array.FindIndex(colors, x => x != colors[0]);\\n      \\n    if (leftmostIndex == -1)\\n      throw new ArgumentException(nameof(colors), \"All houses have the same color, invalid input\");\\n      \\n    int rightmostIndex = Array.FindLastIndex(colors, x => x != colors[0]);      \\n\\n    return Math.Max(\\n      rightmostIndex,\\n      colors.Length - leftmostIndex - 1\\n    );\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909874,
                "title": "c-solution-100-beats-easy-to-understand-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int i =0;\\n        int j =colors.size()-1;\\n        int ans1 = 0;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                 ans1 = max(ans1,abs(j-i));\\n            }\\n            j--;\\n        }\\n\\n        i =0;\\n        j =colors.size()-1;\\n        int ans2 = 0;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                 ans2 = max(ans2,abs(j-i));\\n            }\\n            i++;\\n        }\\n        return max(ans1,ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int i =0;\\n        int j =colors.size()-1;\\n        int ans1 = 0;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                 ans1 = max(ans1,abs(j-i));\\n            }\\n            j--;\\n        }\\n\\n        i =0;\\n        j =colors.size()-1;\\n        int ans2 = 0;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                 ans2 = max(ans2,abs(j-i));\\n            }\\n            i++;\\n        }\\n        return max(ans1,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453056,
                "title": "fastest-solution-with-java-0ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int first = colors[0];\\n        int index = 0;\\n        for(int a = 1; a < colors.length; a++){\\n            if(colors[a] != first) index = a;\\n        }\\n        int last = colors[colors.length-1];\\n        int index2 = colors.length-1;\\n        for(int a = colors.length-1; a > -1; a--){\\n            if(colors[a] != last) index2 = a;\\n        }\\n        int revindex = (colors.length-1)-index2;\\n        return Math.max(index, revindex);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int first = colors[0];\\n        int index = 0;\\n        for(int a = 1; a < colors.length; a++){\\n            if(colors[a] != first) index = a;\\n        }\\n        int last = colors[colors.length-1];\\n        int index2 = colors.length-1;\\n        for(int a = colors.length-1; a > -1; a--){\\n            if(colors[a] != last) index2 = a;\\n        }\\n        int revindex = (colors.length-1)-index2;\\n        return Math.max(index, revindex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413533,
                "title": "beats-100-cpp-sol",
                "content": "# **IF HELPFUL PLS UPVOTE\\uD83E\\uDD79, IT MOTIVATES !**\\n\\n# Approach\\nApproach is written in the code in the form of comments just go through them and dry run once code , you will get to know the appraoch...\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n![Screenshot 2023-04-13 at 9.52.01 PM.png](https://assets.leetcode.com/users/images/13673aed-0709-4006-ac1a-4e6733d9d716_1681403069.363195.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        // This problem is an example of simple two pointer appraoch \\n        // we want the maximum distance , and maximum distance will be the difference of beg and end\\n\\n        // putting a pointer at the begining \\n        int i = 0;\\n\\n        // putting a pointer at the end \\n        int j = colors.size()-1;\\n\\n        // creating answer variable to store the final ans\\n        int ans1 = 0;\\n\\n        while(i<j){\\n            if(colors[i] != colors[j]){\\n                ans1 = max(ans1, j-i);\\n            }\\n            j--;\\n        }\\n\\n        i = 0;\\n        j = colors.size()-1;\\n        int ans2 = 0;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                ans2 = max(ans2, abs(i-j));\\n            }\\n            i++;\\n        }\\n        return max(ans1, ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        // This problem is an example of simple two pointer appraoch \\n        // we want the maximum distance , and maximum distance will be the difference of beg and end\\n\\n        // putting a pointer at the begining \\n        int i = 0;\\n\\n        // putting a pointer at the end \\n        int j = colors.size()-1;\\n\\n        // creating answer variable to store the final ans\\n        int ans1 = 0;\\n\\n        while(i<j){\\n            if(colors[i] != colors[j]){\\n                ans1 = max(ans1, j-i);\\n            }\\n            j--;\\n        }\\n\\n        i = 0;\\n        j = colors.size()-1;\\n        int ans2 = 0;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                ans2 = max(ans2, abs(i-j));\\n            }\\n            i++;\\n        }\\n        return max(ans1, ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348692,
                "title": "4-line-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind max distance between two unique elements in an array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse 2 pointer approach where is color[i]!=color[j] get there address difference and maximize it.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& nums) {\\n        int ans =0;\\n        for(int i = 0;i<nums.size();i++){\\n            for(int j = i+1;j<nums.size();j++){\\n            if(nums[i]!=nums[j]){\\n                ans = max(ans,(j-i));\\n           }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& nums) {\\n        int ans =0;\\n        for(int i = 0;i<nums.size();i++){\\n            for(int j = i+1;j<nums.size();j++){\\n            if(nums[i]!=nums[j]){\\n                ans = max(ans,(j-i));\\n           }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311422,
                "title": "easy-python-solution-beats-89-95",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ind1, ind2 = 0, -1\\n        size = len(colors)\\n        while ind1 < size:\\n            front = colors[ind1]\\n            if front != colors[-1]:\\n                return size - ind1 - 1\\n            last = colors[ind2]\\n            if last != colors[0]:\\n                return size + ind2\\n            ind1 += 1\\n            ind2 -= 1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ind1, ind2 = 0, -1\\n        size = len(colors)\\n        while ind1 < size:\\n            front = colors[ind1]\\n            if front != colors[-1]:\\n                return size - ind1 - 1\\n            last = colors[ind2]\\n            if last != colors[0]:\\n                return size + ind2\\n            ind1 += 1\\n            ind2 -= 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046236,
                "title": "python3-beats-99-18-must-use-ends-explained",
                "content": "# Intuition\\nIf both ends are unequal, then we\\'ve already found our solution.\\nIf both ends are equal, it must be the case that the solution uses one of the end points. This is true by contradiction. \\n\\nSuppose that the solution exists and it does not use an end. Therefore it can **not** be the case that $$(endColor \\\\neq colors[i]$$ or $$endColor \\\\neq colors[j])$$ as that would provide a longer solution. Therefore $$endColor=colors[i]=colors[j]$$ as $$!(! p \\\\ or \\\\ !q)\\\\iff p \\\\ and \\\\ q$$. But since $$colors[i] \\\\neq colors[j]$$ by definition of being a solution, this is a contradiction, and therefore our supposition is wrong.\\n\\n# Approach\\nBy entering the loop, we know our end-colors are equal. We are looking for the first different color, as that would have the largest distance from the right house. We are also looking for the last different color, as that would have the largest distance from the left house. \\n\\nSuppose we found a different color, $$i$$ is the distance from the left end-color to the house while $$len(colors) - 1 - i$$ is the distance from the house to the right end-color. We take the max each time and return that.\\n\\n# Complexity\\n- $$n=len(colors)$$\\n\\n- Time complexity: $$O(n)$$ as we iterate over $$colors$$ once and perform $$O(1)$$ operations per iteration.\\n\\n- Space complexity: $$O(1)$$ as we only keep track of $$res$$.\\n\\n# Code\\n```Python\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        if colors[0] != colors[-1]:\\n            return len(colors) - 1\\n\\n        res: int = 0\\n        for i, color in enumerate(colors):\\n            if color != colors[0]:\\n                res = max(res, i, len(colors) - 1 - i)\\n            \\n        return res   \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```Python\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        if colors[0] != colors[-1]:\\n            return len(colors) - 1\\n\\n        res: int = 0\\n        for i, color in enumerate(colors):\\n            if color != colors[0]:\\n                res = max(res, i, len(colors) - 1 - i)\\n            \\n        return res   \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830195,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int i = 0,ans1 = 0,ans2 = 0;\\n        int j = colors.length-1;\\n        while(i <= j){\\n           if(colors[i]==colors[j]) j--;\\n           else {\\n               ans1 = j;\\n               break;\\n           }\\n\\n        }\\n        i = 0;j = colors.length-1;\\n        while(i <= j){\\n           if(colors[i]==colors[j]) i++;\\n           else {\\n               ans2 = i;\\n               break;\\n           }\\n\\n        }\\n        return Math.max(ans1,colors.length-ans2-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int i = 0,ans1 = 0,ans2 = 0;\\n        int j = colors.length-1;\\n        while(i <= j){\\n           if(colors[i]==colors[j]) j--;\\n           else {\\n               ans1 = j;\\n               break;\\n           }\\n\\n        }\\n        i = 0;j = colors.length-1;\\n        while(i <= j){\\n           if(colors[i]==colors[j]) i++;\\n           else {\\n               ans2 = i;\\n               break;\\n           }\\n\\n        }\\n        return Math.max(ans1,colors.length-ans2-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724221,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int> &colors)\\n    {\\n        int n = colors.size();\\n        int from_start = 0;   \\n        int from_end = n - 1; \\n        while (colors[0] == colors[from_end])\\n            from_end--;\\n        while (colors[n - 1] == colors[from_start])\\n            from_start++;\\n        return max(from_end, n - from_start - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int> &colors)\\n    {\\n        int n = colors.size();\\n        int from_start = 0;   \\n        int from_end = n - 1; \\n        while (colors[0] == colors[from_end])\\n            from_end--;\\n        while (colors[n - 1] == colors[from_start])\\n            from_start++;\\n        return max(from_end, n - from_start - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539094,
                "title": "c-c-simple-solution-in-o-n",
                "content": "In the following `C++` approach, the array is traversed both forward and backward. The best solution for the forward traversal and the backward traversal is stored in `int forward` and `int backward` respectively. Finally, the `forward` and `backward` is compared and the greater value is printed.\\n* In C Programming, you just need to replace *the size of the array* with the given variable `int colorsSize`  \\n```\\n    int maxDistance(vector<int>& colors) {\\n        int forward=0, backward=0;\\n        \\n        for(int i=0; i<colors.size(); i++) \\n            if( colors[0] != colors[i] ) \\n                forward = i;\\n        \\n        for(int i=colors.size()-1; i>=0; i--) \\n            if( colors[colors.size()-1] != colors[i] ) \\n                backward = (colors.size()-1) - i;\\n        \\n        return (forward > backward) ? forward : backward;\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "Array",
                    "Greedy"
                ],
                "code": "```\\n    int maxDistance(vector<int>& colors) {\\n        int forward=0, backward=0;\\n        \\n        for(int i=0; i<colors.size(); i++) \\n            if( colors[0] != colors[i] ) \\n                forward = i;\\n        \\n        for(int i=colors.size()-1; i>=0; i--) \\n            if( colors[colors.size()-1] != colors[i] ) \\n                backward = (colors.size()-1) - i;\\n        \\n        return (forward > backward) ? forward : backward;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2506689,
                "title": "100-faster-simple-java-code",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n       int i=0,j=colors.length-1;\\n        int d=0;\\n        while(colors[i]==colors[j])j--;\\n        d=j-i;\\n        j=colors.length-1;\\n        while(colors[i]==colors[j])i++;\\n        d=Math.max(d,j-i);\\n        return d;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n       int i=0,j=colors.length-1;\\n        int d=0;\\n        while(colors[i]==colors[j])j--;\\n        d=j-i;\\n        j=colors.length-1;\\n        while(colors[i]==colors[j])i++;\\n        d=Math.max(d,j-i);\\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090639,
                "title": "c-solution-o-n-solution",
                "content": "The maximum distance will be from either of the two ends of the array. If the ends of the arrays have different colors then return the length of the array. Otherwise find the maximum distance from either ends and return their maximum\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n=colors.size();\\n        if(colors[0]!=colors[n-1]){\\n            return n-1;\\n        } else {\\n            int back=0;\\n            int front=0;\\n            for(int i=0;i<n;i++){\\n                if(colors[i]!=colors[0]){\\n                    front=i;\\n                    back=max(back,n-front-1);\\n                } \\n            }\\n            return max(front,back);\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n=colors.size();\\n        if(colors[0]!=colors[n-1]){\\n            return n-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2013380,
                "title": "100-java-solution-with-constant-space",
                "content": "**Intitution**: Either of the first house or the last house will always be one of the furthest houses.\\n**Logic**: Iterate from start as well as last to find the different color houses. Return from the point you found one. \\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        if(colors.length==2 ){\\n            return colors[0]==colors[1]?0:1;\\n        }\\n        int i = 0, j = colors.length - 1;\\n        \\n        while (i < colors.length) {\\n            if (colors[0] == colors[j])\\n                j--;\\n            else\\n                return j;\\n            if (colors[colors.length - 1] == colors[i])\\n                i++;\\n            else\\n                return colors.length - i - 1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        if(colors.length==2 ){\\n            return colors[0]==colors[1]?0:1;\\n        }\\n        int i = 0, j = colors.length - 1;\\n        \\n        while (i < colors.length) {\\n            if (colors[0] == colors[j])\\n                j--;\\n            else\\n                return j;\\n            if (colors[colors.length - 1] == colors[i])\\n                i++;\\n            else\\n                return colors.length - i - 1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955608,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        x = []\\n        for i in range(len(colors)-1):\\n            for j in range(i+1,len(colors)):\\n                if colors[i] != colors[j]:\\n                    x.append(j-i)\\n        return max(x)\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        x = []\\n        for i in range(len(colors)-1):\\n            for j in range(i+1,len(colors)):\\n                if colors[i] != colors[j]:\\n                    x.append(j-i)\\n        return max(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724743,
                "title": "short-python-code-100-faster-time-o-n-space-o-1",
                "content": "Here l and r are left most and right most indices. Variable \\'dist\\' counts the distance between two Furthest Houses With Different Colors. Code is easy to understance once you give a try.\\n\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        l, r, prev = 0, len(colors)-1, colors[0]\\n        dist = 0\\n        while (l<=r): \\n            if colors[l] == colors[r] and prev == colors[l]:\\n                prev = colors[l]\\n                r -= 1\\n                l += 1\\n                dist += 1\\n            else:\\n                dist += r-l\\n                return dist\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        l, r, prev = 0, len(colors)-1, colors[0]\\n        dist = 0\\n        while (l<=r): \\n            if colors[l] == colors[r] and prev == colors[l]:\\n                prev = colors[l]\\n                r -= 1\\n                l += 1\\n                dist += 1\\n            else:\\n                dist += r-l\\n                return dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716702,
                "title": "python-94-42-faster-o-1-space-o-n-time-10-lines",
                "content": "```\\nmax_dist = 0\\nfirst_diff = 0\\nfor i in range(1,len(colors)):\\n\\tif colors[i] != colors[0]:\\n\\t\\tif not first_diff:\\n\\t\\t\\tfirst_diff = i\\n\\t\\tmax_dist = max(max_dist, i)\\n\\telse:\\n\\t\\tmax_dist = max(max_dist, i - first_diff)\\nreturn max_dist\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nmax_dist = 0\\nfirst_diff = 0\\nfor i in range(1,len(colors)):\\n\\tif colors[i] != colors[0]:\\n\\t\\tif not first_diff:\\n\\t\\t\\tfirst_diff = i\\n\\t\\tmax_dist = max(max_dist, i)\\n\\telse:\\n\\t\\tmax_dist = max(max_dist, i - first_diff)\\nreturn max_dist\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681845,
                "title": "python-o-n-solution-with-provement-of-the-greed-propery",
                "content": "The problem is straight forward if you know the greed property of the solution which is:\\n\\nThe maximum distance is the maximum of:\\n1. the distance between the first house and a house with a differen color in its right.\\n2. the distance between the last house and a house with a different color in its left.\\n\\nOk, but why this holds? Implementing greed is easy (that\\'s also one of the reason it\\'s called greed), but prove the greed property is essential for the solution. Do realise that during an interview, the interviwer may ask you why the greed property holds.\\n\\nLet\\'s try to prove this by induction:\\n1. `Guess`: the greed propery holds for any valid input array.\\n2. `Hypothesis`: assume it holds for a valid input array `A`, and the maximum distance is between `A[0]` and `A[i]` where `i > 0`.\\n3. Now we add one element to the end of `A` to form `A\\'` which is still a valid input. Then we have a few situations to discuss:\\n\\t3.1.  If the new element has the same color of `A[i]`. The maximum distance is now `A\\'[0]` and` A\\'[n]` where n is the last index of `A\\'`. The guess holds.\\n\\t3.2. If the new element has the same color of `A[0]`. The maximum distance is now either `A\\'[0]` and `A\\'[i]` or `A\\'[j]` and `A\\'[n]` where `j < n`. Because in `A\\'`, if any distance greater than `A\\'[0]` and `A\\'[i]` exists, it must ends with `A\\'[n]`. Otherwise this distance is already found in `A`. The guess holds.\\n\\t3.3. If the new element is different from `A[0]` and `A[i]`. The maximum distance is now `A\\'[0]` and `A\\'[n]`. The guess holds.\\n4. Similar duscissions in 3 can be applied to:\\n\\t4.1. If we pre-append an element to `A`.\\n\\t4.2. If the maximum distance in `A` is between `A[j]` and `A[n]`, where `n` is the last index of `A` and `j < n`.\\n5. The guess is proved.\\n\\n** IMO, this problem is medium if you count the process of find and prove the greed property. Usually, greedy solution is more difficult than dynamic programming since you have to make guess of the greed property and prove it while the later you just need to find the recurrence relationship.\\n\\nAnd below is an implmentation based on Python:\\n```python\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ret = 0\\n        left_c = colors[0]\\n        right_c = colors[-1]\\n        for i in range(1, len(colors)):\\n            if colors[i] != left_c:\\n                ret = i\\n                \\n        for i in range(len(colors) - 2, -1, -1):\\n            if colors[i] != right_c:\\n                ret = max(ret, len(colors) - 1 - i)\\n                \\n        return ret\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ret = 0\\n        left_c = colors[0]\\n        right_c = colors[-1]\\n        for i in range(1, len(colors)):\\n            if colors[i] != left_c:\\n                ret = i\\n                \\n        for i in range(len(colors) - 2, -1, -1):\\n            if colors[i] != right_c:\\n                ret = max(ret, len(colors) - 1 - i)\\n                \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622510,
                "title": "easy-c-solution-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int diff=0;\\n        for(int i=0; i<colors.size()-1; i++)\\n        {\\n            for(int j=colors.size()-1; j>i; j--)\\n            {\\n                if(colors[j]==colors[i])\\n                    continue;\\n                else\\n                {\\n                    diff=max(diff, abs(j-i));\\n                    break;\\n                }\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int diff=0;\\n        for(int i=0; i<colors.size()-1; i++)\\n        {\\n            for(int j=colors.size()-1; j>i; j--)\\n            {\\n                if(colors[j]==colors[i])\\n                    continue;\\n                else\\n                {\\n                    diff=max(diff, abs(j-i));\\n                    break;\\n                }\\n            }\\n        }\\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589264,
                "title": "c-solution-brute-force-two-loops",
                "content": "```\\n    int maxDistance(vector<int>& colors) \\n    {\\n        int n=colors.size(),res=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                    res=max(res,abs(i-j));\\n            }\\n                \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maxDistance(vector<int>& colors) \\n    {\\n        int n=colors.size(),res=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                    res=max(res,abs(i-j));\\n            }\\n                \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589059,
                "title": "java-o-n-solution",
                "content": "This is my first time writing the solution.\\nIf anything wrong please let me know!\\n\\n\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        //one side must contsains start point or end point\\n        \\n        //fix right point, find the farest left\\n        int left = 0;\\n        int right = colors.length - 1;\\n        while(colors[left] == colors[right]){\\n            left++;\\n        }\\n        int retval = right - left;\\n\\n        //fix left point, find the farest rigth\\n        left = 0;\\n        right = colors.length - 1;        \\n        while(colors[left] == colors[right]){\\n           right--;\\n        }\\n        \\n        return Math.max(retval, right - left);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        //one side must contsains start point or end point\\n        \\n        //fix right point, find the farest left\\n        int left = 0;\\n        int right = colors.length - 1;\\n        while(colors[left] == colors[right]){\\n            left++;\\n        }\\n        int retval = right - left;\\n\\n        //fix left point, find the farest rigth\\n        left = 0;\\n        right = colors.length - 1;        \\n        while(colors[left] == colors[right]){\\n           right--;\\n        }\\n        \\n        return Math.max(retval, right - left);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460791,
                "title": "simple-java-100-explained-a",
                "content": "# Approach\\n- for O(n\\xB2) set 2 for loops iterating through the entire array twice and only records the maximum value between current max and the new distance for different colored houses.\\n\\n# Complexity\\n- Time complexity: O(n\\xB2)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        \\n        int dist = 0;\\n        \\n        for(int i = 0;i<colors.length;i++){\\n            for(int j = colors.length-1;j>=0;j--){\\n                if(colors[i] != colors[j]){\\n                    dist = Math.max(j - i,dist);\\n                }\\n            }            \\n        }\\n\\n        return dist;\\n        \\n        \\n    }\\n}\\n```\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/d7b15911-1568-42ce-b5ee-6e374a1a6c23_1682603015.5590189.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        \\n        int dist = 0;\\n        \\n        for(int i = 0;i<colors.length;i++){\\n            for(int j = colors.length-1;j>=0;j--){\\n                if(colors[i] != colors[j]){\\n                    dist = Math.max(j - i,dist);\\n                }\\n            }            \\n        }\\n\\n        return dist;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349023,
                "title": "two-furthest-houses-with-different-colors-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int i, j, max=0;\\n        for(i=0 ; i<colors.size()-1 ; i++)\\n        {\\n            for(j=i+max ; j<colors.size() ; j++)\\n            {\\n                if(colors[i]!=colors[j] && (j-i)>max)\\n                {\\n                    max = j-i;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int i, j, max=0;\\n        for(i=0 ; i<colors.size()-1 ; i++)\\n        {\\n            for(j=i+max ; j<colors.size() ; j++)\\n            {\\n                if(colors[i]!=colors[j] && (j-i)>max)\\n                {\\n                    max = j-i;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304843,
                "title": "2-solution-c-easy-brute-force-two-pointer",
                "content": "# BRUTE FORCE\\n```\\nclass Solution {\\npublic:\\n   class Solution {\\npublic:\\n    int maxDistance(vector<int>& nums) {\\n        int i=0;\\n        int maxi=INT_MIN ;\\n       while(i<nums.size()){\\n        int j=0;\\n           while(j<nums.size()){\\n               if(nums[i] != nums[j]){\\n                   maxi=max(maxi,j-i);\\n               }\\n               j++;\\n           }\\n           i++;\\n       }\\n        return maxi;\\n    }\\n};\\n```\\n# TWO POINTERS\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& nums) {\\n        int i=0;\\n        int j=nums.size()-1;\\n        int maxi=INT_MIN ;\\n        while(j<nums.size()){\\n            if(nums[i] != nums[j])\\n                maxi=max(maxi,j-i); \\n             j--;\\n        }\\n        i=0;\\n        j=nums.size()-1;\\n      while(i<nums.size()){\\n          if(nums[i] != nums[j])\\n              maxi=max(maxi,j-i);\\n          i++;\\n      }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   class Solution {\\npublic:\\n    int maxDistance(vector<int>& nums) {\\n        int i=0;\\n        int maxi=INT_MIN ;\\n       while(i<nums.size()){\\n        int j=0;\\n           while(j<nums.size()){\\n               if(nums[i] != nums[j]){\\n                   maxi=max(maxi,j-i);\\n               }\\n               j++;\\n           }\\n           i++;\\n       }\\n        return maxi;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& nums) {\\n        int i=0;\\n        int j=nums.size()-1;\\n        int maxi=INT_MIN ;\\n        while(j<nums.size()){\\n            if(nums[i] != nums[j])\\n                maxi=max(maxi,j-i); \\n             j--;\\n        }\\n        i=0;\\n        j=nums.size()-1;\\n      while(i<nums.size()){\\n          if(nums[i] != nums[j])\\n              maxi=max(maxi,j-i);\\n          i++;\\n      }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187759,
                "title": "o-n-2-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans = 0;\\n        for(int i = 0; i  < colors.size(); i++){\\n            for(int j = i + 1; j < colors.size(); j++){\\n                if(colors[i] != colors[j])\\n                ans = max(ans,abs(j - i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans = 0;\\n        for(int i = 0; i  < colors.size(); i++){\\n            for(int j = i + 1; j < colors.size(); j++){\\n                if(colors[i] != colors[j])\\n                ans = max(ans,abs(j - i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973250,
                "title": "c-simple-and-easy-to-understand-solution-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfinding first and last occurence of each coloured house \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep maxm diff and return \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colours) {\\n        map<int,int>m1,m2;\\n        for(int i=0;i<colours.size();i++){\\n            m1.insert({colours[i],i});\\n        }\\n        for(int i=colours.size()-1;i>=0;i--){\\n            m2.insert({colours[i],i});\\n        }\\n        int mexi=INT_MIN;\\n        for(auto it1=m1.begin();it1!=m1.end();it1++){\\n      \\n        for(auto it2=m2.begin();it2!=m2.end();it2++){\\n         if(it1->first!=it2->first){\\n             mexi=max(abs(it1->second-it2->second),mexi);\\n         }\\n        }\\n        }\\n  \\n    return mexi;\\n        // return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colours) {\\n        map<int,int>m1,m2;\\n        for(int i=0;i<colours.size();i++){\\n            m1.insert({colours[i],i});\\n        }\\n        for(int i=colours.size()-1;i>=0;i--){\\n            m2.insert({colours[i],i});\\n        }\\n        int mexi=INT_MIN;\\n        for(auto it1=m1.begin();it1!=m1.end();it1++){\\n      \\n        for(auto it2=m2.begin();it2!=m2.end();it2++){\\n         if(it1->first!=it2->first){\\n             mexi=max(abs(it1->second-it2->second),mexi);\\n         }\\n        }\\n        }\\n  \\n    return mexi;\\n        // return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968965,
                "title": "go",
                "content": "```\\nfunc maxDistance(colors []int) int {\\n    max := 0\\n    for i := 0; i < len(colors) - 1; i++ {\\n        for j := i + 1; j < len(colors); j++ {\\n            if colors[i] != colors[j] && j - i > max {\\n                max = j - i\\n            }\\n        }\\n    }\\n    return max\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxDistance(colors []int) int {\\n    max := 0\\n    for i := 0; i < len(colors) - 1; i++ {\\n        for j := i + 1; j < len(colors); j++ {\\n            if colors[i] != colors[j] && j - i > max {\\n                max = j - i\\n            }\\n        }\\n    }\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2459634,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& arr) {\\n        int start=0;\\n        int end=arr.size()-1;\\n        int ans=0;\\n        while(start<end)\\n        {\\n            if(arr[start]==arr[end])\\n            {\\n                end--;\\n            }\\n            else\\n            {\\n                ans=max(ans,abs(end-start));\\n                start++;\\n            }\\n        }\\n        start=0;\\n        end=arr.size()-1;\\n        while(start<end)\\n        {\\n            if(arr[start]==arr[end])\\n            {\\n                start++;\\n            }\\n            else\\n            {\\n                ans=max(ans,abs(end-start));\\n                end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& arr) {\\n        int start=0;\\n        int end=arr.size()-1;\\n        int ans=0;\\n        while(start<end)\\n        {\\n            if(arr[start]==arr[end])\\n            {\\n                end--;\\n            }\\n            else\\n            {\\n                ans=max(ans,abs(end-start));\\n                start++;\\n            }\\n        }\\n        start=0;\\n        end=arr.size()-1;\\n        while(start<end)\\n        {\\n            if(arr[start]==arr[end])\\n            {\\n                start++;\\n            }\\n            else\\n            {\\n                ans=max(ans,abs(end-start));\\n                end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458960,
                "title": "fatstest-js-solution",
                "content": "```\\nvar maxDistance = function(colors) {\\n    let n = colors.length;\\n    let ans = 1;\\n    for(let i =0 ; i<colors.length; i++){\\n        if(colors[i] != colors[0])\\n            ans = Math.max(ans, i);\\n        if(colors[i] != colors[n-1])\\n            ans = Math.max(ans, n-1-i);\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxDistance = function(colors) {\\n    let n = colors.length;\\n    let ans = 1;\\n    for(let i =0 ; i<colors.length; i++){\\n        if(colors[i] != colors[0])\\n            ans = Math.max(ans, i);\\n        if(colors[i] != colors[n-1])\\n            ans = Math.max(ans, n-1-i);\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2451257,
                "title": "c-one-loop",
                "content": "```\\n\\tint maxDistance(vector<int>& c) {\\n        int n = c.size(), ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(c[0] != c[n - i - 1]) ans = max(n - i - 1, ans);\\n            if(c[i] != c[n - 1]) ans = max(n - i - 1, ans);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint maxDistance(vector<int>& c) {\\n        int n = c.size(), ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(c[0] != c[n - i - 1]) ans = max(n - i - 1, ans);\\n            if(c[i] != c[n - 1]) ans = max(n - i - 1, ans);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2450695,
                "title": "java-solution-o-n-2",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int max = Integer.MIN_VALUE;;\\n        int n = colors.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (colors[j] != colors[i]) {\\n                    int diff = Math.abs(j - i);\\n                    max = Math.max(max, diff);\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// TC: O(n^2), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int max = Integer.MIN_VALUE;;\\n        int n = colors.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (colors[j] != colors[i]) {\\n                    int diff = Math.abs(j - i);\\n                    max = Math.max(max, diff);\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// TC: O(n^2), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440124,
                "title": "python-super-easy-greedy-o-n",
                "content": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        \\n        ans = -1 \\n        for i in range(len(colors)):\\n                if colors[i] != colors[0]:\\n                    ans = max(ans, i)\\n                if colors[i] != colors[-1]:\\n                    ans = max(ans, len(colors)- i - 1)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        \\n        ans = -1 \\n        for i in range(len(colors)):\\n                if colors[i] != colors[0]:\\n                    ans = max(ans, i)\\n                if colors[i] != colors[-1]:\\n                    ans = max(ans, len(colors)- i - 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306251,
                "title": "java-greedy-explained",
                "content": "**Idea:** Max distance involves one of first or last houses\\n**Method 1:** Find the last house different from first and first house different from last. Return the max of two distances\\n>**T/S:** O(n)/O(1)\\n```\\npublic int maxDistance(int[] colors) {\\n\\tvar distance = 0;\\n\\t\\n\\tfor (int i = 0, n = colors.length; i < n; i++) {\\n\\t\\tif (colors[i] != colors[0])\\n\\t\\t\\tdistance = Math.max(distance, i);\\n\\t\\tif (colors[i] != colors[n - 1])\\n\\t\\t\\tdistance = Math.max(distance, n - 1 - i);\\n\\t}\\n\\treturn distance;\\n}\\n```\\n**Method 2:** Same idea, different code\\n>**T/S:** O(n)/O(1)\\n```\\npublic int maxDistance(int[] colors) {\\n\\tvar n = colors.length;\\n\\tvar right = n - 1;\\n\\tvar left = 0;\\n\\n\\tfor (; right >= 0 && colors[0] == colors[right]; right--);\\n\\tfor (; left < n && colors[left] == colors[n - 1]; left++);\\n\\treturn Math.max(n - 1 - left, right);\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxDistance(int[] colors) {\\n\\tvar distance = 0;\\n\\t\\n\\tfor (int i = 0, n = colors.length; i < n; i++) {\\n\\t\\tif (colors[i] != colors[0])\\n\\t\\t\\tdistance = Math.max(distance, i);\\n\\t\\tif (colors[i] != colors[n - 1])\\n\\t\\t\\tdistance = Math.max(distance, n - 1 - i);\\n\\t}\\n\\treturn distance;\\n}\\n```\n```\\npublic int maxDistance(int[] colors) {\\n\\tvar n = colors.length;\\n\\tvar right = n - 1;\\n\\tvar left = 0;\\n\\n\\tfor (; right >= 0 && colors[0] == colors[right]; right--);\\n\\tfor (; left < n && colors[left] == colors[n - 1]; left++);\\n\\treturn Math.max(n - 1 - left, right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2304419,
                "title": "super-easy-0ms-100",
                "content": "```\\npublic int maxDistance(int[] A) {\\n        int n = A.length, i = 0, j = n-1;\\n        while (A[0] == A[j]) j--;\\n        while (A[n - 1] == A[i]) i++;\\n        return Math.max(n - 1 - i, j);\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxDistance(int[] A) {\\n        int n = A.length, i = 0, j = n-1;\\n        while (A[0] == A[j]) j--;\\n        while (A[n - 1] == A[i]) i++;\\n        return Math.max(n - 1 - i, j);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2234855,
                "title": "c-solution",
                "content": "int maxDistance(vector<int>& colors) {\\n        int n=colors.size();\\n        if(colors[0]!=colors[n-1]){\\n            return n-1;\\n        }\\n        int i=0;\\n        int j=n-1;\\n        int res1;\\n        int res2;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                res1=j-i;\\n                break;\\n            }\\n            else{\\n                j--;\\n            }\\n        }\\n        i=0,j=n-1;\\n         while(i<j){\\n            if(colors[i]!=colors[j]){\\n                res2=j-i;\\n                break;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        int res=max(res1,res2);\\n        return res;\\n    }",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "int maxDistance(vector<int>& colors) {\\n        int n=colors.size();\\n        if(colors[0]!=colors[n-1]){\\n            return n-1;\\n        }\\n        int i=0;\\n        int j=n-1;\\n        int res1;\\n        int res2;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                res1=j-i;\\n                break;\\n            }\\n            else{\\n                j--;\\n            }\\n        }\\n        i=0,j=n-1;\\n         while(i<j){\\n            if(colors[i]!=colors[j]){\\n                res2=j-i;\\n                break;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        int res=max(res1,res2);\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2126746,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maxDistance(self, colors):\\n        \\n        max_distance = 0\\n        \\n        for i in range(1, len(colors)):\\n            if colors[0] != colors[i]:\\n                max_distance = max(max_distance, i)\\n            if colors[i] != colors[-1]:\\n                max_distance = max(max_distance, len(colors) - i - 1)\\n            \\n        return max_distance\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors):\\n        \\n        max_distance = 0\\n        \\n        for i in range(1, len(colors)):\\n            if colors[0] != colors[i]:\\n                max_distance = max(max_distance, i)\\n            if colors[i] != colors[-1]:\\n                max_distance = max(max_distance, len(colors) - i - 1)\\n            \\n        return max_distance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115394,
                "title": "python-o-n-time-o-1-space-easy-to-understand",
                "content": "* The premise is that the first house will always have some other house with a different color, and the last one will always have some other house with a different color (if confused about this fact, read the description carefully).\\n* Using the above premise, we conclude that the max distance is either between the first house and the last differently colored house, or the last house and the first differently colored house.\\n\\nSo we go through the loop, and we update the max using the above rule. Then finally we return it.\\n\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        res = 0\\n        for i in range(len(colors)):\\n            if colors[i] != colors[0]:\\n                res = max(res, i)\\n            if colors[i] != colors[-1]:\\n                res = max(res, len(colors)-1-i)\\n                \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        res = 0\\n        for i in range(len(colors)):\\n            if colors[i] != colors[0]:\\n                res = max(res, i)\\n            if colors[i] != colors[-1]:\\n                res = max(res, len(colors)-1-i)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100626,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int distance = 0;\\n        \\n        for(int i = 0;i<colors.size();i++)\\n        {\\n            int j = colors.size()-1;\\n            \\n            while(i < j){\\n                if(colors[i] != colors[j]){\\n                    distance = max(distance,abs(i - j));\\n            }\\n            j--;\\n            }\\n            \\n            \\n        }\\n        return distance;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int distance = 0;\\n        \\n        for(int i = 0;i<colors.size();i++)\\n        {\\n            int j = colors.size()-1;\\n            \\n            while(i < j){\\n                if(colors[i] != colors[j]){\\n                    distance = max(distance,abs(i - j));\\n            }\\n            j--;\\n            }\\n            \\n            \\n        }\\n        return distance;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094592,
                "title": "easiest-and-fastest-solution-1ms-runtime-java",
                "content": "\\t\\tint n = colors.length;\\n        \\n        int maxDiff = Integer.MIN_VALUE;\\n        \\n        for(int i=0; i<n-1; i++){\\n            \\n            int diff = 0;\\n            \\n            for(int j=i+1; j<n; j++){\\n                \\n                if(colors[i] != colors[j]){\\n                    diff = Math.abs(i-j);\\n                }\\n            }\\n            maxDiff = Math.max(maxDiff, diff);\\n        }\\n        return maxDiff;",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "\\t\\tint n = colors.length;\\n        \\n        int maxDiff = Integer.MIN_VALUE;\\n        \\n        for(int i=0; i<n-1; i++){\\n            \\n            int diff = 0;\\n            \\n            for(int j=i+1; j<n; j++){\\n                \\n                if(colors[i] != colors[j]){\\n                    diff = Math.abs(i-j);\\n                }\\n            }\\n            maxDiff = Math.max(maxDiff, diff);\\n        }\\n        return maxDiff;",
                "codeTag": "Unknown"
            },
            {
                "id": 2051117,
                "title": "java-2ms-solution-easy-explanation",
                "content": "class Solution {\\n    public int maxDistance(int[] colors) {  \\n        int i,j,max=0,k;\\n        for(i=0;i<colors.length-1;i++)\\n        {\\n            for(j=i+1;j<colors.length;j++)\\n            {\\n            if(colors[i]!=colors[j]){\\n                k=Math.abs(i-j);\\n                if(max<k)\\n                {\\n                    max=k;\\n                }\\n            }\\n        }\\n    }\\n        return max;\\n  }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxDistance(int[] colors) {  \\n        int i,j,max=0,k;\\n        for(i=0;i<colors.length-1;i++)\\n        {\\n            for(j=i+1;j<colors.length;j++)\\n            {\\n            if(colors[i]!=colors[j]){\\n                k=Math.abs(i-j);\\n                if(max<k)\\n                {\\n                    max=k;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2027579,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int md = 0, n = colors.size();\\n        \\n        for(int i = 0; i < n ; i++){\\n            int left = 0, right = n-1;\\n            \\n            \\n            //look from the left \\n            while(left < i){\\n                if(colors[left] != colors[i]) {\\n                    md = max(md,abs(left-i));\\n                    break;\\n                }\\n                left++;\\n            }\\n            \\n            //look from right\\n            while(right > i){\\n                \\n                if(colors[right] != colors[i]) {\\n                    md = max(md,abs(right-i));\\n                    break;\\n                }\\n                right--;\\n            }\\n            \\n            \\n        }\\n        \\n        \\n        return md;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int md = 0, n = colors.size();\\n        \\n        for(int i = 0; i < n ; i++){\\n            int left = 0, right = n-1;\\n            \\n            \\n            //look from the left \\n            while(left < i){\\n                if(colors[left] != colors[i]) {\\n                    md = max(md,abs(left-i));\\n                    break;\\n                }\\n                left++;\\n            }\\n            \\n            //look from right\\n            while(right > i){\\n                \\n                if(colors[right] != colors[i]) {\\n                    md = max(md,abs(right-i));\\n                    break;\\n                }\\n                right--;\\n            }\\n            \\n            \\n        }\\n        \\n        \\n        return md;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007484,
                "title": "two-pointer-easy-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& arr) {\\n        int l=0;\\n        int h=arr.size()-1;\\n        int first=0;\\n        int second=0;\\n        while(l<h)\\n        {\\n            if(arr[l]!=arr[h])\\n            {\\n                first=h-l;\\n                break;\\n            }\\n            else\\n                h--;\\n        }\\n        l=0;\\n        h=arr.size()-1;\\n        while(l<h)\\n        {\\n            if(arr[l]!=arr[h])\\n            {\\n                second=h-l;\\n                break;\\n            }\\n            else\\n                l++;\\n        }\\n         return max(second,first);\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& arr) {\\n        int l=0;\\n        int h=arr.size()-1;\\n        int first=0;\\n        int second=0;\\n        while(l<h)\\n        {\\n            if(arr[l]!=arr[h])\\n            {\\n                first=h-l;\\n                break;\\n            }\\n            else\\n                h--;\\n        }\\n        l=0;\\n        h=arr.size()-1;\\n        while(l<h)\\n        {\\n            if(arr[l]!=arr[h])\\n            {\\n                second=h-l;\\n                break;\\n            }\\n            else\\n                l++;\\n        }\\n         return max(second,first);\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898886,
                "title": "explained-o-n-easy-to-understand-javascript",
                "content": "Find **two** distance between between first element (a) & last element (b). (when a !=b) \\n\\n**first distance:** from index 0 to last different element;\\nindex 0 is fixed change another.\\n \\n**second distance:** from last index to first different element; \\nlast index is fixed change another.\\n\\n\\n**EXAMPLE:** \\n```arr=[1,1,1,6,7,5,4,3,2,8,1,1,1,1];``` \\n\\n```first distance= arr[0]~arr[9] ----> 1~8 ----> 9;``` \\n\\n```second distance=arr[arr.length-1]~arr[3] ----> 1~6 ---->10;``` \\n\\nas 10 is max return 10;\\n**note:** in the first case index 0 is fixed, in second index last is fixed. \\n\\n\\n```\\nvar maxDistance = function(c) {\\n    let n=c.length;\\n     \\n    let indx1=0;\\n    while(true){ \\n      if(c[n-1]!==c[indx1]){break;}\\n      indx1++;\\n    }\\n    \\n    let indx2=c.length-1;\\n    while(true){\\n        if(c[0]!==c[indx2]){break;}\\n        indx2--;\\n    }\\n    return Math.max(n-indx1-1,indx2);  \\n}; \\n```\\n",
                "solutionTags": [],
                "code": "```arr=[1,1,1,6,7,5,4,3,2,8,1,1,1,1];```\n```first distance= arr[0]~arr[9] ----> 1~8 ----> 9;```\n```second distance=arr[arr.length-1]~arr[3] ----> 1~6 ---->10;```\n```\\nvar maxDistance = function(c) {\\n    let n=c.length;\\n     \\n    let indx1=0;\\n    while(true){ \\n      if(c[n-1]!==c[indx1]){break;}\\n      indx1++;\\n    }\\n    \\n    let indx2=c.length-1;\\n    while(true){\\n        if(c[0]!==c[indx2]){break;}\\n        indx2--;\\n    }\\n    return Math.max(n-indx1-1,indx2);  \\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1878208,
                "title": "python-easy-solution-by-swiping-from-left-and-right",
                "content": "\"\"\"\\n\\n    def maxDistance(self, colors: List[int]) -> int:\\n        leftmax, rightmax = 0,0\\n        \\n        i, j = 0, len(colors) -1\\n        \\n        # Swiping from right to left\\n        while(i<j):\\n            if colors[i] != colors[j]:\\n                leftmax = j - i\\n                break\\n            else:\\n                j -= 1\\n        \\n        i, j = 0, len(colors) -1\\n        # Swiping from left to right\\n        while(i<j):\\n            if colors[i] != colors[j]:\\n                rightmax = j - i\\n                break\\n            else:\\n                i += 1\\n                \\n        return max(leftmax, rightmax)\\n\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\n\\n    def maxDistance(self, colors: List[int]) -> int:\\n        leftmax, rightmax = 0,0\\n        \\n        i, j = 0, len(colors) -1\\n        \\n        # Swiping from right to left\\n        while(i<j):\\n            if colors[i] != colors[j]:\\n                leftmax = j - i\\n                break\\n            else:\\n                j -= 1\\n        \\n        i, j = 0, len(colors) -1\\n        # Swiping from left to right\\n        while(i<j):\\n            if colors[i] != colors[j]:\\n                rightmax = j - i\\n                break\\n            else:\\n                i += 1\\n                \\n        return max(leftmax, rightmax)\\n\"\"\"",
                "codeTag": "Python3"
            },
            {
                "id": 1849660,
                "title": "c-easy-to-understand-o-n-solution-beginners-friendly",
                "content": "// Plaese Upvote If It helps........\\n\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) \\n    {\\n        int n = colors.size();         // extracting the size of the vector\\n        int mx = INT_MIN;              // for storing the ans\\n        \\n        // finding the max distance from left side\\n        // just finding out the different color house for the index 0 at max possible\\n        for(int left=1;left<n;left++)\\n        {\\n            if(colors[left] != colors[0])\\n            {\\n                mx = left;\\n            }\\n        }\\n        \\n        // finding the max distance from right side\\n        // just finding out the different color house for the index n-1 at max possible\\n        for(int right=0;right<n-1;right++)\\n        {\\n            if(colors[right] != colors[n-1] && (n-1-right)>mx)\\n            {\\n                mx = n-1-right;         // storing the max distance value\\n            }\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```\\n\\n// Plaese Upvote If It helps........",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) \\n    {\\n        int n = colors.size();         // extracting the size of the vector\\n        int mx = INT_MIN;              // for storing the ans\\n        \\n        // finding the max distance from left side\\n        // just finding out the different color house for the index 0 at max possible\\n        for(int left=1;left<n;left++)\\n        {\\n            if(colors[left] != colors[0])\\n            {\\n                mx = left;\\n            }\\n        }\\n        \\n        // finding the max distance from right side\\n        // just finding out the different color house for the index n-1 at max possible\\n        for(int right=0;right<n-1;right++)\\n        {\\n            if(colors[right] != colors[n-1] && (n-1-right)>mx)\\n            {\\n                mx = n-1-right;         // storing the max distance value\\n            }\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797377,
                "title": "java-iterate-from-both-end-using-two-sets-of-start-and-end",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int start1 = 0;\\n        int end1 = colors.length - 1;\\n\\n        int start = 0;\\n        int end = colors.length - 1;\\n\\n        while (start < end) {\\n            if (colors[start] != colors[end]) {\\n                return Math.abs(end - start);\\n            }\\n            end--;\\n            if (colors[start1] != colors[end1]) {\\n                return Math.abs(end1 - start1);\\n            }\\n            start1++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int start1 = 0;\\n        int end1 = colors.length - 1;\\n\\n        int start = 0;\\n        int end = colors.length - 1;\\n\\n        while (start < end) {\\n            if (colors[start] != colors[end]) {\\n                return Math.abs(end - start);\\n            }\\n            end--;\\n            if (colors[start1] != colors[end1]) {\\n                return Math.abs(end1 - start1);\\n            }\\n            start1++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776517,
                "title": "java-easy-easy-to-understand",
                "content": "The problem is quite interesting can be solve in O(n2) and also in O(n) also \\nLets discuss optimal approach\\n\\nmax distance will be either end of the array so we are first finding first color that is not equals to the end of the array and so on \\n\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) \\n    {\\n        int n = colors.length;\\n        int i =0;\\n        int j = n-1;\\n        int ans = Integer.MIN_VALUE;\\n        while(colors[i]==colors[n-1])\\n        {\\n            i++;\\n        }\\n        ans = Math.max(ans,(n-1-i));\\n        while(colors[j]==colors[0])\\n        {\\n            j--;\\n        }\\n        ans = Math.max(ans,(j-0));\\n        return ans;\\n        \\n        \\n    }\\n}\\n```\\n\\nTC - O(n)\\nSC - O(1)\\n\\n100%",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) \\n    {\\n        int n = colors.length;\\n        int i =0;\\n        int j = n-1;\\n        int ans = Integer.MIN_VALUE;\\n        while(colors[i]==colors[n-1])\\n        {\\n            i++;\\n        }\\n        ans = Math.max(ans,(n-1-i));\\n        while(colors[j]==colors[0])\\n        {\\n            j--;\\n        }\\n        ans = Math.max(ans,(j-0));\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768830,
                "title": "python-easy-and-understandable-solution-92-faster",
                "content": "We need to find the maximum distance, therefore one of the houses should be at one of the ends only, then only the difference is maximum.\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        clr=colors[0]\\n        clr2=colors[-1]\\n        maxi=0\\n        for i in range(len(colors)-1,-1,-1):\\n            if clr!=colors[i]:\\n                maxi=max(maxi,i)\\n                break\\n        for i in range(len(colors)):\\n            if clr2!=colors[i]:\\n                maxi=max(maxi,len(colors)-i-1)\\n        return maxi\\n```\\n1. Here we take the first and last colours of house as `clr` and `clr2`\\n1. First traverising from the last if the colour of the house is not same as `clr` we save the index ( which is the distance between the houses) in maxi then break\\n1. Then traversing from the beginning of the list if the color of the house is not same, subtract the index from `len(colors)-1`, which we will compare with maxi and save the maximum\\n1. Maximum distance is returned\\n\\n#thanks for viewing the solution",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        clr=colors[0]\\n        clr2=colors[-1]\\n        maxi=0\\n        for i in range(len(colors)-1,-1,-1):\\n            if clr!=colors[i]:\\n                maxi=max(maxi,i)\\n                break\\n        for i in range(len(colors)):\\n            if clr2!=colors[i]:\\n                maxi=max(maxi,len(colors)-i-1)\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725520,
                "title": "beginner-friendly-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} colors\\n * @return {number}\\n */\\nvar maxDistance = function(colors) {\\n    let l = 0, r = colors.length-1;\\n    while(colors[colors.length-1] == colors[l]) l++;\\n    while(colors[0] == colors[r]) r--;\\n    return Math.max(r, colors.length - 1 - l);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} colors\\n * @return {number}\\n */\\nvar maxDistance = function(colors) {\\n    let l = 0, r = colors.length-1;\\n    while(colors[colors.length-1] == colors[l]) l++;\\n    while(colors[0] == colors[r]) r--;\\n    return Math.max(r, colors.length - 1 - l);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1690903,
                "title": "c-time-complexity-o-n-space-complexity-o-1-two-pointers-and-one-end-at-a-time-traversal",
                "content": "```\\n#define deb(x) cout << #x << \" = \" << x << endl;\\n#define min(a, b) a < b ? a : b\\n#define max(a, b) a > b ? a : b\\n\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n = colors.size();\\n        int res = 0, start = 0, finish = n - 1, startCopy = 0, finishCopy = n - 1;;\\n        \\n        while (colors[start] == colors[finishCopy])\\n            start++;\\n        while (colors[startCopy] == colors[finish])\\n            finish--;\\n        \\n        res = max((finishCopy - start), (finish - startCopy));\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define deb(x) cout << #x << \" = \" << x << endl;\\n#define min(a, b) a < b ? a : b\\n#define max(a, b) a > b ? a : b\\n\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n = colors.size();\\n        int res = 0, start = 0, finish = n - 1, startCopy = 0, finishCopy = n - 1;;\\n        \\n        while (colors[start] == colors[finishCopy])\\n            start++;\\n        while (colors[startCopy] == colors[finish])\\n            finish--;\\n        \\n        res = max((finishCopy - start), (finish - startCopy));\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1684415,
                "title": "c-runtime-0-ms-faster-than-100-00-memory-usage-9-1-mb-less-than-20-34",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int i, first = colors[0], sz = colors.size();\\n        int j, last = colors[sz - 1];\\n        for(i = sz - 1 ; i >= 0 ; i--) if(colors[i] != first) break;\\n        for(j = 0 ; j < sz ; j++) if(colors[j] != last) break;\\n        return max(i, sz-1-j);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int i, first = colors[0], sz = colors.size();\\n        int j, last = colors[sz - 1];\\n        for(i = sz - 1 ; i >= 0 ; i--) if(colors[i] != first) break;\\n        for(j = 0 ; j < sz ; j++) if(colors[j] != last) break;\\n        return max(i, sz-1-j);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663999,
                "title": "faster-than-100-00-of-go-online-submissions-for-two-furthest-houses-with-different-colors",
                "content": "```\\nfunc maxDistance(colors []int) int {\\n    a := colors[0]\\n    b := colors[len(colors)-1]\\n    left := -1\\n    right := -1\\n    var i int\\n    for j := len(colors)-1; j >= 1; j-- {\\n        if left == -1 && a != colors[j] {\\n            left = j\\n        }\\n        if right == -1 && b != colors[i] {\\n            right = j\\n        }\\n        i++\\n    }\\n    \\n    if left > right {\\n        return left\\n    }\\n    \\n    return right\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maxDistance(colors []int) int {\\n    a := colors[0]\\n    b := colors[len(colors)-1]\\n    left := -1\\n    right := -1\\n    var i int\\n    for j := len(colors)-1; j >= 1; j-- {\\n        if left == -1 && a != colors[j] {\\n            left = j\\n        }\\n        if right == -1 && b != colors[i] {\\n            right = j\\n        }\\n        i++\\n    }\\n    \\n    if left > right {\\n        return left\\n    }\\n    \\n    return right\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661792,
                "title": "brute-force-solution-simple",
                "content": "public int maxDistance(int[] colors) {\\nint maxdis = 0;\\nfor (int i = 0;i<colors.length;i++){\\n for (int j = 0; j<colors.length;j++) {\\n\\n     if (colors[i] != colors[j] ){\\n       if (Math.abs(i-j)>maxdis ){\\n           maxdis = Math.abs(i-j);\\n       }\\n\\n\\n\\n     }\\n }\\n}\\n\\nreturn maxdis;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int maxDistance(int[] colors) {\\nint maxdis = 0;\\nfor (int i = 0;i<colors.length;i++){\\n for (int j = 0; j<colors.length;j++) {\\n\\n     if (colors[i] != colors[j] ){\\n       if (Math.abs(i-j)>maxdis ){\\n           maxdis = Math.abs(i-j);\\n       }\\n\\n\\n\\n     }\\n }\\n}\\n\\nreturn maxdis;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1656662,
                "title": "python-one-liner-using-list-comprehensions",
                "content": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n \\xA0 \\xA0 \\xA0 \\xA0return max([abs(i-j) for i in range(len(colors)) for j in range (len(colors)) if colors[i]!=colors[j]]) \\n```\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n \\xA0 \\xA0 \\xA0 \\xA0return max([abs(i-j) for i in range(len(colors)) for j in range (len(colors)) if colors[i]!=colors[j]]) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646085,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        for i in range(len(colors) - 1):\\n            if colors[i] != colors[-1] or colors[-(i + 1)] != colors[0]:\\n                return len(colors) - i - 1\\n\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        for i in range(len(colors) - 1):\\n            if colors[i] != colors[-1] or colors[-(i + 1)] != colors[0]:\\n                return len(colors) - i - 1\\n\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623156,
                "title": "c-0ms-100-faster-than-c-2-lines-solutions-easy-clean-explained",
                "content": "**C++ solutions :**\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& a,int maxl=1) {\\n        for(int i=0;i<a.size();i++)\\n        for(int j=i+1;j<a.size();j++) if(abs(j-i)>maxl && a[i]!=a[j]) maxl=abs(j-i);\\n        return maxl;\\n    }\\n};\\n```\\n**if you like this solutions , please upvote for my motivations \\nany doubt ---> comment\\nThank you.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& a,int maxl=1) {\\n        for(int i=0;i<a.size();i++)\\n        for(int j=i+1;j<a.size();j++) if(abs(j-i)>maxl && a[i]!=a[j]) maxl=abs(j-i);\\n        return maxl;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611799,
                "title": "java-0ms-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. The max distance must be between two possibilies:\\n            - one house [0] and one house between [n..1] OR\\n            - one from from [N] and one house from [0...n-1].\\n        2. Traverse the array twice, once from left and once from right and measure the max from both sides. \\n        3. Return the max of both traversals.   \\n    */\\n    public int maxDistance(int[] colors) {\\n        int max = 1;\\n        // select house[0] and look for houses from n,n-1, n-2 .. 1. Break at the first found as this is the max\\n        for (int i = colors.length -1; i >= 1; i--) {\\n           if (colors[0] != colors[i]) {\\n               max = Math.max(max, i);\\n               break;\\n           } \\n        }\\n        // select house[n] and look for houses from 0,1...n-1. Break at the first found as this is the max\\n        for(int i = 0; i < colors.length -1; i++) {\\n            if (colors[i] != colors[colors.length -1]) {\\n                max = Math.max(max, colors.length -1 - i);\\n                break;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. The max distance must be between two possibilies:\\n            - one house [0] and one house between [n..1] OR\\n            - one from from [N] and one house from [0...n-1].\\n        2. Traverse the array twice, once from left and once from right and measure the max from both sides. \\n        3. Return the max of both traversals.   \\n    */\\n    public int maxDistance(int[] colors) {\\n        int max = 1;\\n        // select house[0] and look for houses from n,n-1, n-2 .. 1. Break at the first found as this is the max\\n        for (int i = colors.length -1; i >= 1; i--) {\\n           if (colors[0] != colors[i]) {\\n               max = Math.max(max, i);\\n               break;\\n           } \\n        }\\n        // select house[n] and look for houses from 0,1...n-1. Break at the first found as this is the max\\n        for(int i = 0; i < colors.length -1; i++) {\\n            if (colors[i] != colors[colors.length -1]) {\\n                max = Math.max(max, colors.length -1 - i);\\n                break;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602995,
                "title": "100-fast-o-n",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int len=-1;\\n        int start = 0,end=colors.length-1;\\n        //Left->Right scan\\n        while(start<end){\\n            if(colors[start]==colors[end]){\\n                start++;\\n            }else{\\n                if(len< end-start)\\n                    len=end-start;\\n                end--;\\n            }\\n        }\\n        start = 0;\\n        end=colors.length-1;\\n        //Right->Left scan\\n         while(start<end){\\n            if(colors[start]==colors[end]){\\n                end--;\\n            }else{\\n                if(len< end-start)\\n                    len=end-start;\\n                start++;\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int len=-1;\\n        int start = 0,end=colors.length-1;\\n        //Left->Right scan\\n        while(start<end){\\n            if(colors[start]==colors[end]){\\n                start++;\\n            }else{\\n                if(len< end-start)\\n                    len=end-start;\\n                end--;\\n            }\\n        }\\n        start = 0;\\n        end=colors.length-1;\\n        //Right->Left scan\\n         while(start<end){\\n            if(colors[start]==colors[end]){\\n                end--;\\n            }else{\\n                if(len< end-start)\\n                    len=end-start;\\n                start++;\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600345,
                "title": "java-dp",
                "content": "class Solution {\\n    public int maxDistance(int[] colors) {\\n        int[] DP = new int[colors.length];\\n        for(int i=0; i<colors.length; i++){\\n            int j = 0;\\n            while(colors[j] == colors[i] && j < i){\\n                j++;\\n            }\\n            DP[i] = i-j;\\n        }\\n        \\n        int furthestDistance = 0;\\n         for(int i=0; i<colors.length; i++){\\n             System.out.print(DP[i]+\" \");\\n            furthestDistance = Math.max(furthestDistance, DP[i]);\\n         }\\n        \\n        return furthestDistance;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxDistance(int[] colors) {\\n        int[] DP = new int[colors.length];\\n        for(int i=0; i<colors.length; i++){\\n            int j = 0;\\n            while(colors[j] == colors[i] && j < i){\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1595237,
                "title": "swift-clean-solution",
                "content": "```\\nclass Solution {\\n    func maxDistance(_ colors: [Int]) -> Int {\\n        var l = 0\\n        var r = colors.count - 1\\n        var n = colors.count - 1\\n        \\n        // find max distance from index 0\\n        while colors[0] == colors[r] {\\n            r -= 1\\n        }\\n        // find max distance from last index\\n        while colors[l] == colors[n] {\\n            l += 1\\n        }\\n        // return max\\n        return max(r-0, n-l)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxDistance(_ colors: [Int]) -> Int {\\n        var l = 0\\n        var r = colors.count - 1\\n        var n = colors.count - 1\\n        \\n        // find max distance from index 0\\n        while colors[0] == colors[r] {\\n            r -= 1\\n        }\\n        // find max distance from last index\\n        while colors[l] == colors[n] {\\n            l += 1\\n        }\\n        // return max\\n        return max(r-0, n-l)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594332,
                "title": "java-100-one-pass",
                "content": "```\\npublic int maxDistance(int[] colors) {\\n        int size = colors.length - 1;\\n        int half = colors.length / 2;\\n        for(int i = 0; i <= half; i++) {\\n            if((colors[size] != colors[i]) || colors[0] != colors[size - i]) {\\n                return size - i;\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxDistance(int[] colors) {\\n        int size = colors.length - 1;\\n        int half = colors.length / 2;\\n        for(int i = 0; i <= half; i++) {\\n            if((colors[size] != colors[i]) || colors[0] != colors[size - i]) {\\n                return size - i;\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592777,
                "title": "python-one-liner-o-n",
                "content": "An ugly one-liner for fun:\\n```\\n    def maxDistance(self, A):\\n        return max(max(0 if x == A[0] else i, 0 if x == A[-1] else len(A) - i - 1) for i, x in enumerate(A))\\n```\\n\\nHere it is in expanded form:\\n```\\n    def maxDistance(self, A):\\n        res = 0\\n        for i, x in enumerate(A):\\n            if x != A[0]:\\n                res = max(res, i)\\n            if x != A[-1]:\\n                res = max(res, len(A) - 1 - i)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def maxDistance(self, A):\\n        return max(max(0 if x == A[0] else i, 0 if x == A[-1] else len(A) - i - 1) for i, x in enumerate(A))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1591593,
                "title": "c-worst-case-o-n-time-complexity-and-o-1-space-complexity",
                "content": "The basic approach is that result can be obtained using end points only:\\n1. find the max(i - 0) by fixing the first element and comparing other element from opposite end if its equal then move to next value other wise (i - 0) is the max value in that case and break the loop.\\n2. Repeat the above case and find max (n - 1 - i) fixing the last element and starting from 0 index.\\n3. Maximum of both values will be desired result.\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n = colors.size();\\n        int max_value_1 = n - 1;\\n        int max_value_2 = n - 1;\\n        while(colors[0] == colors[max_value_1])\\n            max_value_1--;\\n        while((colors[n - 1] == colors[n - 1 - max_value_2]) && (max_value_2 > max_value_1))\\n            max_value_2--;\\n        return max(max_value_1, max_value_2);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n = colors.size();\\n        int max_value_1 = n - 1;\\n        int max_value_2 = n - 1;\\n        while(colors[0] == colors[max_value_1])\\n            max_value_1--;\\n        while((colors[n - 1] == colors[n - 1 - max_value_2]) && (max_value_2 > max_value_1))\\n            max_value_2--;\\n        return max(max_value_1, max_value_2);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1591108,
                "title": "c-solution",
                "content": "Solution 1:\\n```\\npublic class Solution {\\n    public int MaxDistance(int[] colors) {\\n        int max = 0, length = colors.Length;\\n        for(int i = 0; i < length; i++){\\n            if(colors[0] != colors[i])\\n                max = Math.Max(max, i);\\n            if(colors[length-1] != colors[i])\\n                max = Math.Max(max, length-i-1);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nSolution 2:\\n```\\npublic class Solution {\\n    public int MaxDistance(int[] colors) {\\n        int i = 0, j = colors.Length-1, n = colors.Length-1;\\n        while(colors[i] == colors[n])\\n            i++;\\n        while(colors[j] == colors[0])\\n            j--;\\n        return Math.Max(j, n-i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxDistance(int[] colors) {\\n        int max = 0, length = colors.Length;\\n        for(int i = 0; i < length; i++){\\n            if(colors[0] != colors[i])\\n                max = Math.Max(max, i);\\n            if(colors[length-1] != colors[i])\\n                max = Math.Max(max, length-i-1);\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxDistance(int[] colors) {\\n        int i = 0, j = colors.Length-1, n = colors.Length-1;\\n        while(colors[i] == colors[n])\\n            i++;\\n        while(colors[j] == colors[0])\\n            j--;\\n        return Math.Max(j, n-i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590840,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int maxDistance(int[] c) {\\n        int k=c.length,m=0,n=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(c[k-1]!=c[i])\\n            {\\n                m=Math.max(m,k-1-i);\\n            }\\n        }\\n        for(int i=k-1;i>=0;i--)\\n        {\\n            if(c[i]!=c[0])\\n            {\\n                n=Math.max(n,i-0);\\n            }\\n        }\\n        return Math.max(m,n);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int maxDistance(int[] c) {\\n        int k=c.length,m=0,n=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(c[k-1]!=c[i])\\n            {\\n                m=Math.max(m,k-1-i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1590836,
                "title": "c-two-pointers-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans=INT_MIN;\\n        int i=0;\\n        int j=colors.size()-1;\\n        while(j!=i){\\n            if(colors[i]!=colors[j]) ans=max(ans,abs(j-i));\\n            j--;\\n        }\\n          j = colors.size()-1;\\n         while(i!=j){\\n            if(colors[i]!=colors[j]) ans=max(ans,abs(j-i));\\n            i++;\\n        }\\n           return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans=INT_MIN;\\n        int i=0;\\n        int j=colors.size()-1;\\n        while(j!=i){\\n            if(colors[i]!=colors[j]) ans=max(ans,abs(j-i));\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1590625,
                "title": "c-2078-two-furthest-houses-with-different-colors",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans = 0, n = colors.size(); \\n        for (int i = 0; i < n; ++i) {\\n            if (colors.front() != colors[i]) ans = max(ans, i); \\n            if (colors[i] != colors.back()) ans = max(ans, n-1-i); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans = 0, n = colors.size(); \\n        for (int i = 0; i < n; ++i) {\\n            if (colors.front() != colors[i]) ans = max(ans, i); \\n            if (colors[i] != colors.back()) ans = max(ans, n-1-i); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590506,
                "title": "c-brute-force-and-optimal-solution-o-n-2-and-o-n-time-complexity",
                "content": "**Brute Force solution :**\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int mxDist = 0;\\n        int size = colors.size();\\n        for(int i = 0; i < size; i++){\\n            for(int j = 0; j < size; j++){\\n                if(colors[i] != colors[j])\\n                    mxDist = max(mxDist, (j - i));\\n            }\\n        }\\n        return mxDist;\\n    }\\n};\\n```\\n\\n** **\\n**Optimal Solution :**\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int mxDist = 0;\\n        int size = colors.size();\\n        int first = colors[0];\\n        for(int i = size-1; i >= 0; i--){\\n            if(first != colors[i]){\\n                mxDist = max(mxDist, i);\\n                break;\\n            }\\n        }\\n        int last = colors[size-1];\\n        for(int i = 0; i < size; i++){\\n            if(colors[i] != last){\\n                mxDist = max(mxDist, size-1-i);\\n            }\\n        }\\n        return mxDist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int mxDist = 0;\\n        int size = colors.size();\\n        for(int i = 0; i < size; i++){\\n            for(int j = 0; j < size; j++){\\n                if(colors[i] != colors[j])\\n                    mxDist = max(mxDist, (j - i));\\n            }\\n        }\\n        return mxDist;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int mxDist = 0;\\n        int size = colors.size();\\n        int first = colors[0];\\n        for(int i = size-1; i >= 0; i--){\\n            if(first != colors[i]){\\n                mxDist = max(mxDist, i);\\n                break;\\n            }\\n        }\\n        int last = colors[size-1];\\n        for(int i = 0; i < size; i++){\\n            if(colors[i] != last){\\n                mxDist = max(mxDist, size-1-i);\\n            }\\n        }\\n        return mxDist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590166,
                "title": "two-pass-0ms",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int l=0;\\n        int r=colors.length-1;\\n        int dis=0;\\n        while(l<r){\\n            if(colors[l]!=colors[r--]){\\n                dis=r-l + 1;\\n                break;\\n            }\\n        }\\n        l=0;\\n        r=colors.length-1;\\n        while(l<r){\\n            if(colors[l++]!=colors[r]){\\n                dis=Math.max(dis,r-l + 1);\\n                break;\\n            } \\n        }\\n        return dis;\\n    }\\n}",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int maxDistance(int[] colors) {\\n        int l=0;\\n        int r=colors.length-1;\\n        int dis=0;\\n        while(l<r){\\n            if(colors[l]!=colors[r--]){\\n                dis=r-l + 1;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1590139,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {number[]} colors\\n * @return {number}\\n */\\nvar maxDistance = function (colors) {\\n  let a = 0;\\n\\n  for (let i = 0; i < colors.length - 1; i++) {\\n    for (let j = i + 1; j < colors.length; j++) {\\n      if (colors[i] !== colors[j]) {\\n        a = Math.max(a, Math.abs(i - j));\\n      }\\n    }\\n  }\\n\\n  return a;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} colors\\n * @return {number}\\n */\\nvar maxDistance = function (colors) {\\n  let a = 0;\\n\\n  for (let i = 0; i < colors.length - 1; i++) {\\n    for (let j = i + 1; j < colors.length; j++) {\\n      if (colors[i] !== colors[j]) {\\n        a = Math.max(a, Math.abs(i - j));\\n      }\\n    }\\n  }\\n\\n  return a;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589987,
                "title": "c-simple-approach",
                "content": "Logic - We store all the distances between two houses of different colours  in the variable x and we find the maximum of all the distances because we want maximum distance between two houses of different colours.\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int x=0;\\n        int maxx=0;\\n        for(int i=0;i<colors.size()-1;i++){\\n            for(int j=i+1;j<colors.size();j++){\\n                if(colors[i]!=colors[j]) \\n                    x=abs(i-j);\\n                    \\n            }\\n            maxx=max(maxx,x);\\n        }\\n        \\n        return maxx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int x=0;\\n        int maxx=0;\\n        for(int i=0;i<colors.size()-1;i++){\\n            for(int j=i+1;j<colors.size();j++){\\n                if(colors[i]!=colors[j]) \\n                    x=abs(i-j);\\n                    \\n            }\\n            maxx=max(maxx,x);\\n        }\\n        \\n        return maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589307,
                "title": "java-single-pass-solution",
                "content": "Check whether 1st and n-1th numbers are different if it is so then this will be our answer(n-1)\\nelse\\ncheck the first index from front such that colors[0] !=colors[i]\\n check the last index nearest index from last such that colors[n-1]!=colors[j]\\nthen return maximum of farthest house considering the first index , farthest house considering the last index\\n.Here\\'s the code .\\n\\n\\n\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n     int n=colors.length;\\n        if(colors[0]!=colors[n-1])\\n        {\\n            return n-1;\\n        }\\n        int i=n-1;\\n           while(colors[0]==colors[i])\\n           { \\n              i--;\\n           }\\n          int j=0;\\n        while(colors[n-1]==colors[j])\\n        {\\n          j++;\\n        }\\n        return Math.max(n-1-j,i);\\n           \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n     int n=colors.length;\\n        if(colors[0]!=colors[n-1])\\n        {\\n            return n-1;\\n        }\\n        int i=n-1;\\n           while(colors[0]==colors[i])\\n           { \\n              i--;\\n           }\\n          int j=0;\\n        while(colors[n-1]==colors[j])\\n        {\\n          j++;\\n        }\\n        return Math.max(n-1-j,i);\\n           \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589130,
                "title": "simple-o-n-time-one-pass-solution-java",
                "content": "```class Solution {\\n    public int maxDistance(int[] colors) {\\n        for(int i=0, j=colors.length-1; i<=j;)\\n        {\\n            if(colors[j]!=colors[i])\\n                return j-i;\\n            if(colors[i]!=colors[i+1])\\n            {\\n                i++;\\n            }\\n            else if(colors[j]!=colors[j-1])\\n            {\\n                j--;\\n            }\\n            else\\n            {\\n                int count1=0;\\n                int count2=0;\\n                int temp1 = i;\\n                int temp2 = j;\\n                while(colors[temp1]==colors[temp1+1])\\n                {\\n                    temp1++;\\n                    count1++;\\n                }\\n                while(colors[temp2]==colors[temp2-1])\\n                {\\n                    temp2--;\\n                    count2++;\\n                }\\n                if(count1<=count2)\\n                {\\n                    i=temp1;\\n                }\\n                else\\n                {\\n                    j=temp2;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```class Solution {\\n    public int maxDistance(int[] colors) {\\n        for(int i=0, j=colors.length-1; i<=j;)\\n        {\\n            if(colors[j]!=colors[i])\\n                return j-i;\\n            if(colors[i]!=colors[i+1])\\n            {\\n                i++;\\n            }\\n            else if(colors[j]!=colors[j-1])\\n            {\\n                j--;\\n            }\\n            else\\n            {\\n                int count1=0;\\n                int count2=0;\\n                int temp1 = i;\\n                int temp2 = j;\\n                while(colors[temp1]==colors[temp1+1])\\n                {\\n                    temp1++;\\n                    count1++;\\n                }\\n                while(colors[temp2]==colors[temp2-1])\\n                {\\n                    temp2--;\\n                    count2++;\\n                }\\n                if(count1<=count2)\\n                {\\n                    i=temp1;\\n                }\\n                else\\n                {\\n                    j=temp2;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1589122,
                "title": "python-brute-force-to-optimal",
                "content": "```\\n#brute force\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        n = len(colors)\\n        res = 0\\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                if colors[i] != colors[j]:\\n                    res = max(res, abs(i-j))\\n                    \\n        return res\\n```\\n\\n```\\n#using first and last elements\\nclass Solution:\\n    def maxDistance(self, arr: List[int]) -> int:\\n        res = 0 \\n\\t\\tn = len(arr)\\n\\t\\t\\n        for i in range(n): \\n            if arr[i] != arr[0]:  #first\\n\\t\\t\\t\\tres = max(res, i)\\n            if arr[i] != arr[-1]:  #last \\n\\t\\t\\t\\tres = max(res, n-i-1)\\n\\t\\t\\t\\n        return res \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n#brute force\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        n = len(colors)\\n        res = 0\\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                if colors[i] != colors[j]:\\n                    res = max(res, abs(i-j))\\n                    \\n        return res\\n```\n```\\n#using first and last elements\\nclass Solution:\\n    def maxDistance(self, arr: List[int]) -> int:\\n        res = 0 \\n\\t\\tn = len(arr)\\n\\t\\t\\n        for i in range(n): \\n            if arr[i] != arr[0]:  #first\\n\\t\\t\\t\\tres = max(res, i)\\n            if arr[i] != arr[-1]:  #last \\n\\t\\t\\t\\tres = max(res, n-i-1)\\n\\t\\t\\t\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589083,
                "title": "simple-c-solution",
                "content": "class Solution {\\npublic:\\n    int maxDistance(vector<int>& nums) {\\n        int maxi=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                if(nums[i]!=nums[j])\\n                    maxi=max(j-i,maxi);\\n            }\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxDistance(vector<int>& nums) {\\n        int maxi=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                if(nums[i]!=nums[j])\\n                    maxi=max(j-i,maxi);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4077562,
                "title": "c-easy-worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans=0;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n          for(int j=i+1;j<colors.size();j++)\\n          {\\n            if(colors[i]!=colors[j])\\n            {\\n              ans=max(ans,abs(i-j));\\n            }\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans=0;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n          for(int j=i+1;j<colors.size();j++)\\n          {\\n            if(colors[i]!=colors[j])\\n            {\\n              ans=max(ans,abs(i-j));\\n            }\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075107,
                "title": "2078",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int f = 0, r = colors.length-1;\\n        while(f != r){\\n            if(colors[f] != colors[r]){\\n                return r-f;\\n            }else{\\n                if(colors[f] != colors[f+1]){\\n                    f++;\\n                    return Math.max(r-f,r-1);\\n                }else if(colors[r] != colors[r-1]){\\n                    r--;\\n                    return Math.max(r-f,r-0);\\n                }else{\\n                    r--;\\n                    f++;\\n                }\\n            }\\n        }\\n        return r-f;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int f = 0, r = colors.length-1;\\n        while(f != r){\\n            if(colors[f] != colors[r]){\\n                return r-f;\\n            }else{\\n                if(colors[f] != colors[f+1]){\\n                    f++;\\n                    return Math.max(r-f,r-1);\\n                }else if(colors[r] != colors[r-1]){\\n                    r--;\\n                    return Math.max(r-f,r-0);\\n                }else{\\n                    r--;\\n                    f++;\\n                }\\n            }\\n        }\\n        return r-f;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062161,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        return max(len(colors)-1-reduce(lambda s, _: s+1, takewhile(lambda i: colors[i] == colors[-1], count(0)), 0), reduce(lambda s, _: s-1, takewhile(lambda i: colors[i] == colors[-1], count(len(colors)-1, -1)), len(colors)-1))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        return max(len(colors)-1-reduce(lambda s, _: s+1, takewhile(lambda i: colors[i] == colors[-1], count(0)), 0), reduce(lambda s, _: s-1, takewhile(lambda i: colors[i] == colors[-1], count(len(colors)-1, -1)), len(colors)-1))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047237,
                "title": "solution-in-java-100ms-runtime",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int ans = 0;\\n        int s =0;\\n        int e = colors.length-1;\\n        while(s<e){\\n            while(colors[s]==colors[e]){\\n                e--;\\n            }\\n            ans = Math.max(ans,Math.abs(e-s));\\n            s++;\\n            if(s>0 && colors[s-1]!=colors[s]){\\n               e=colors.length-1;   \\n            }\\n             \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int ans = 0;\\n        int s =0;\\n        int e = colors.length-1;\\n        while(s<e){\\n            while(colors[s]==colors[e]){\\n                e--;\\n            }\\n            ans = Math.max(ans,Math.abs(e-s));\\n            s++;\\n            if(s>0 && colors[s-1]!=colors[s]){\\n               e=colors.length-1;   \\n            }\\n             \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042148,
                "title": "c-stl-beats-100",
                "content": "# Intuition\\none of color of **max diffrent color pair** must be location at index 0 or index n-1 \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int first = colors[0];\\n        auto iter = std::find_if(colors.rbegin(), colors.rend(), [&](int x){\\n            return x!=first;\\n        });\\n        int end = colors.back();\\n        auto iter2 = std::find_if(colors.begin(), colors.end(), [&](int x){\\n            return x!=end;\\n        });\\n        int dis1 = std::distance(iter,colors.rend())-1;\\n        int dis2 = std::distance(iter2,colors.end())-1;\\n        return max(dis1,dis2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int first = colors[0];\\n        auto iter = std::find_if(colors.rbegin(), colors.rend(), [&](int x){\\n            return x!=first;\\n        });\\n        int end = colors.back();\\n        auto iter2 = std::find_if(colors.begin(), colors.end(), [&](int x){\\n            return x!=end;\\n        });\\n        int dis1 = std::distance(iter,colors.rend())-1;\\n        int dis2 = std::distance(iter2,colors.end())-1;\\n        return max(dis1,dis2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039026,
                "title": "c-two-pointers",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int MaxDistance(int[] colors)\\n    {\\n        var n = colors.Length;\\n        var i = 0;\\n        var j = n - 1;\\n\\n        while (colors[0] == colors[j])\\n        {\\n            j--;\\n        }\\n\\n        while (colors[n - 1] == colors[i])\\n        {\\n            i++;\\n        }\\n\\n        return Math.Max(n - 1 - i, j);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MaxDistance(int[] colors)\\n    {\\n        var n = colors.Length;\\n        var i = 0;\\n        var j = n - 1;\\n\\n        while (colors[0] == colors[j])\\n        {\\n            j--;\\n        }\\n\\n        while (colors[n - 1] == colors[i])\\n        {\\n            i++;\\n        }\\n\\n        return Math.Max(n - 1 - i, j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032939,
                "title": "beats-100-fastest-and-smallest-solution",
                "content": "# Intuition\\nif a[i]!=a[j], then a[0] will be farther than a[i], doesnt matter a[0] == a[i] or not. Same intuition from the end.\\n\\n# Approach\\ntwo pointers\\n# Complexity\\n- Time complexity:\\nO(n) + O(n)  = O(2n) = O(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans = 0;\\n        for(int j = 1;j < colors.size();j++){\\n            if(colors[0] != colors[j]){\\n                ans = max(ans, j);\\n            }\\n        }\\n        int n = colors.size();\\n        for(int i = n-2;i >=0;i--){\\n            if(colors[i]!=colors[colors.size()-1]){\\n                ans = max(ans, n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans = 0;\\n        for(int j = 1;j < colors.size();j++){\\n            if(colors[0] != colors[j]){\\n                ans = max(ans, j);\\n            }\\n        }\\n        int n = colors.size();\\n        for(int i = n-2;i >=0;i--){\\n            if(colors[i]!=colors[colors.size()-1]){\\n                ans = max(ans, n-i-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031274,
                "title": "easy-understandable-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int n = colors.length;\\n        int i = 0;\\n        int j = n-1;\\n        int dist1 = 0;\\n        int dist2 = 0;\\n        while(i < j) {\\n            if(colors[i] == colors[j]) {\\n                j--;\\n            } else {\\n                dist1 = Math.abs(j - i);\\n                break;\\n            }\\n\\n        }\\n        i = 0; j = n-1;\\n        while(i < j) {\\n            if(colors[i] == colors[j]) {\\n                i++;\\n            } else {\\n                dist2 = Math.abs(j - i);\\n                break;\\n            }\\n        }\\n        return Math.max(dist1, dist2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int n = colors.length;\\n        int i = 0;\\n        int j = n-1;\\n        int dist1 = 0;\\n        int dist2 = 0;\\n        while(i < j) {\\n            if(colors[i] == colors[j]) {\\n                j--;\\n            } else {\\n                dist1 = Math.abs(j - i);\\n                break;\\n            }\\n\\n        }\\n        i = 0; j = n-1;\\n        while(i < j) {\\n            if(colors[i] == colors[j]) {\\n                i++;\\n            } else {\\n                dist2 = Math.abs(j - i);\\n                break;\\n            }\\n        }\\n        return Math.max(dist1, dist2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027932,
                "title": "harshi-s-simple-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& c) {\\n       int max=0;\\n       for(int i=0;i<c.size();i++){\\n           for(int j=i+1;j<c.size();j++){\\n                if(c[i]!=c[j])\\n                {\\n                    if(max<j-i)\\n                    max=j-i;\\n                }\\n           }\\n       } \\n       return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& c) {\\n       int max=0;\\n       for(int i=0;i<c.size();i++){\\n           for(int j=i+1;j<c.size();j++){\\n                if(c[i]!=c[j])\\n                {\\n                    if(max<j-i)\\n                    max=j-i;\\n                }\\n           }\\n       } \\n       return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024877,
                "title": "simple-c-solution-o-n-runtime-beats-100-memory-beats-93",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int l=0;\\n        int r=colors.size()-1;\\n        int m1=0;\\n        int m2=0;\\n        while(l<=r){\\n            if(colors[l]!=colors[r]){\\n                m1=abs(l-r);\\n                break;\\n            }\\n            l++;\\n        }\\n        l=0;\\n        r=colors.size()-1;\\n        while(l<=r){\\n            if(colors[l]!=colors[r]){\\n                m2=abs(l-r);\\n                break;\\n            }\\n            r--;\\n        }\\n        return max(m1,m2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int l=0;\\n        int r=colors.size()-1;\\n        int m1=0;\\n        int m2=0;\\n        while(l<=r){\\n            if(colors[l]!=colors[r]){\\n                m1=abs(l-r);\\n                break;\\n            }\\n            l++;\\n        }\\n        l=0;\\n        r=colors.size()-1;\\n        while(l<=r){\\n            if(colors[l]!=colors[r]){\\n                m2=abs(l-r);\\n                break;\\n            }\\n            r--;\\n        }\\n        return max(m1,m2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024360,
                "title": "time-complexity-o-n-space-complexity-o-1-solution-for-beginner",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        \\n        int len = colors.size();\\n        int ans = 0;\\n\\n        for(int i = 1 ; i < len ; i++)\\n        {\\n            if( colors[i] != colors[0])\\n                ans = max(ans,i);\\n            if( colors[i] != colors[len - 1])\\n                ans = max(ans,(len - 1 - i));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        \\n        int len = colors.size();\\n        int ans = 0;\\n\\n        for(int i = 1 ; i < len ; i++)\\n        {\\n            if( colors[i] != colors[0])\\n                ans = max(ans,i);\\n            if( colors[i] != colors[len - 1])\\n                ans = max(ans,(len - 1 - i));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024346,
                "title": "o-n-solution-for-beginner",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        vector <int > distances;\\n        int len = colors.size();\\n\\n        for(int i = 1 ; i < len ; i++)\\n        {\\n            if( colors[i] != colors[0])\\n                distances.push_back(i);\\n            if( colors[i] != colors[len - 1])\\n                distances.push_back(len - 1 - i);\\n        }\\n\\n        return *max_element(distances.begin(),distances.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        vector <int > distances;\\n        int len = colors.size();\\n\\n        for(int i = 1 ; i < len ; i++)\\n        {\\n            if( colors[i] != colors[0])\\n                distances.push_back(i);\\n            if( colors[i] != colors[len - 1])\\n                distances.push_back(len - 1 - i);\\n        }\\n\\n        return *max_element(distances.begin(),distances.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005945,
                "title": "for-beginners-beatzz-97",
                "content": "## Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        res = 0\\n        l = 0 \\n        limit = r = len(colors) - 1\\n        while l != limit:\\n            if res >= r - l:\\n                 l += 1\\n                 r = limit\\n                 continue\\n            elif colors[l] != colors[r]:\\n                res = max(res , r-l )\\n                l += 1\\n                r = limit\\n            else:\\n                r -= 1\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        res = 0\\n        l = 0 \\n        limit = r = len(colors) - 1\\n        while l != limit:\\n            if res >= r - l:\\n                 l += 1\\n                 r = limit\\n                 continue\\n            elif colors[l] != colors[r]:\\n                res = max(res , r-l )\\n                l += 1\\n                r = limit\\n            else:\\n                r -= 1\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000744,
                "title": "python-best-o-n-with-simple-logic-explained",
                "content": "# Intuition\\nCase - I : Ends are Different, so value will be length -1\\n\\nCase - II : Ends are same, Check, first distinct element from left side and right side \\n\\nLet\\'s say this : **A(0)..... L....R.....A(n-1)**\\n\\n**ANSWER** -  maximum of |R-0| or |n-1-L|\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        n=len(colors)\\n        # Case -1 : End Different\\n        # Case -2 : End Same - Look for first different\\n\\n        if colors[0]!=colors[n-1]:\\n            return abs(n-1)\\n        else:\\n            val=colors[0]\\n            diff_left=0\\n            diff_right=n-1\\n            for i in range(1,n-1):\\n                if colors[i]!=val:\\n                    if diff_left==0:\\n                        diff_left=i\\n                        diff_right=i\\n                    else:\\n                        diff_right=i\\n        return max(abs(diff_right),(n-1-diff_left))\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        n=len(colors)\\n        # Case -1 : End Different\\n        # Case -2 : End Same - Look for first different\\n\\n        if colors[0]!=colors[n-1]:\\n            return abs(n-1)\\n        else:\\n            val=colors[0]\\n            diff_left=0\\n            diff_right=n-1\\n            for i in range(1,n-1):\\n                if colors[i]!=val:\\n                    if diff_left==0:\\n                        diff_left=i\\n                        diff_right=i\\n                    else:\\n                        diff_right=i\\n        return max(abs(diff_right),(n-1-diff_left))\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999747,
                "title": "easiest-two-pointer-java-solution-100-beast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Two Pointer\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int maxDist1 = 0;  // Initialize the maximum distance to 0.\\n        int i = 0;         // Initialize the left pointer to the start of the array.\\n        int j = colors.length - 1;  // Initialize the right pointer to the end of the array.\\n\\n        // Loop from both ends of the array until the pointers meet or cross.\\n        while (i <= j) {\\n            int diff = j - i;  // Calculate the difference between the current positions of pointers.\\n\\n            // Check if the colors at the current positions are different and if the current diff is greater than the maxDist1.\\n            if (colors[i] != colors[j] && maxDist1 < diff) {\\n                maxDist1 = diff;  // Update maxDist1 with the new maximum distance.\\n                break;  // Exit the loop since we\\'ve found a maximum distance.\\n            } else {\\n                j--;  // Move the right pointer one step to the left.\\n            }\\n        }\\n\\n        // Reset pointers and repeat the process, but this time start from the left and move the right pointer.\\n        i = 0;\\n        j = colors.length - 1;\\n\\n        while (i <= j) {\\n            int diff = j - i;\\n\\n            if (colors[i] != colors[j] && maxDist1 < diff) {\\n                maxDist1 = diff;\\n                break;\\n            } else {\\n                i++;  // Move the left pointer one step to the right.\\n            }\\n        }\\n\\n        return maxDist1;  // Return the maximum distance found in both directions.\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int maxDist1 = 0;  // Initialize the maximum distance to 0.\\n        int i = 0;         // Initialize the left pointer to the start of the array.\\n        int j = colors.length - 1;  // Initialize the right pointer to the end of the array.\\n\\n        // Loop from both ends of the array until the pointers meet or cross.\\n        while (i <= j) {\\n            int diff = j - i;  // Calculate the difference between the current positions of pointers.\\n\\n            // Check if the colors at the current positions are different and if the current diff is greater than the maxDist1.\\n            if (colors[i] != colors[j] && maxDist1 < diff) {\\n                maxDist1 = diff;  // Update maxDist1 with the new maximum distance.\\n                break;  // Exit the loop since we\\'ve found a maximum distance.\\n            } else {\\n                j--;  // Move the right pointer one step to the left.\\n            }\\n        }\\n\\n        // Reset pointers and repeat the process, but this time start from the left and move the right pointer.\\n        i = 0;\\n        j = colors.length - 1;\\n\\n        while (i <= j) {\\n            int diff = j - i;\\n\\n            if (colors[i] != colors[j] && maxDist1 < diff) {\\n                maxDist1 = diff;\\n                break;\\n            } else {\\n                i++;  // Move the left pointer one step to the right.\\n            }\\n        }\\n\\n        return maxDist1;  // Return the maximum distance found in both directions.\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999581,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:(O(N^2)):\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1):\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans=INT_MIN;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n            for(int j=0;j<colors.size();j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    ans=max(ans,abs(i-j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int ans=INT_MIN;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n            for(int j=0;j<colors.size();j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    ans=max(ans,abs(i-j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999239,
                "title": "greedy-algorithm-with-2-pointers-beats-100-on-time-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach- Two pointers with two loops, return the maxium output comparing both the loops\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int left = 0;\\n        int len = colors.length;\\n        int right = len-1;\\n        while(left<right){\\n            if(colors[left] != colors[right]){\\n                break;\\n            } else {\\n                right--;\\n            }\\n        }\\n        int left2=0;\\n        int right2=len-1;\\n        while(left2<right2){\\n            if(colors[left2] != colors[right2]){\\n                break;\\n            } else {\\n                left2++;\\n            }\\n        }\\n        return Math.max(Math.abs(left - right),Math.abs(left2-right2));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int left = 0;\\n        int len = colors.length;\\n        int right = len-1;\\n        while(left<right){\\n            if(colors[left] != colors[right]){\\n                break;\\n            } else {\\n                right--;\\n            }\\n        }\\n        int left2=0;\\n        int right2=len-1;\\n        while(left2<right2){\\n            if(colors[left2] != colors[right2]){\\n                break;\\n            } else {\\n                left2++;\\n            }\\n        }\\n        return Math.max(Math.abs(left - right),Math.abs(left2-right2));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987402,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int sum = 0;\\n        int diff = 0;\\n        int x = sum;\\n        for(int i=0;i<colors.length;i++){\\n            for(int j=i+1;j<colors.length;j++){\\n                if(colors[i]!=colors[j]){\\n                    sum = Math.abs(i-j);\\n                }\\n            }\\n            if(sum>diff){\\n             x = sum;\\n             diff = sum;\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int sum = 0;\\n        int diff = 0;\\n        int x = sum;\\n        for(int i=0;i<colors.length;i++){\\n            for(int j=i+1;j<colors.length;j++){\\n                if(colors[i]!=colors[j]){\\n                    sum = Math.abs(i-j);\\n                }\\n            }\\n            if(sum>diff){\\n             x = sum;\\n             diff = sum;\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982373,
                "title": "2-solutions",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    // TC: O(n)\\n    // SC: O(1)\\n    public int maxDistance(int[] colors) {\\n        int n = colors.length;\\n        int l = 0;\\n        int r = n-1;\\n\\n        while(colors[0]==colors[r]){\\n            r--;\\n        }\\n        while(colors[l]==colors[n-1]){\\n            l++;\\n        }\\n        return Math.max(n-1-l,r);\\n    }\\n\\n    // TC: O(n^2)\\n    // SC: O(1)\\n    public int maxDistance2(int[] colors) {\\n        int ans = 0;\\n        for(int i=0;i<colors.length;i++){\\n            int curr = 0;\\n            for(int j=i;j<colors.length;j++){\\n                if(colors[i]!=colors[j] && j-i>curr){\\n                    curr=j-i;\\n                }\\n            }\\n            ans = Math.max(ans,curr);\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n\\n    // TC: O(n)\\n    // SC: O(1)\\n    public int maxDistance(int[] colors) {\\n        int n = colors.length;\\n        int l = 0;\\n        int r = n-1;\\n\\n        while(colors[0]==colors[r]){\\n            r--;\\n        }\\n        while(colors[l]==colors[n-1]){\\n            l++;\\n        }\\n        return Math.max(n-1-l,r);\\n    }\\n\\n    // TC: O(n^2)\\n    // SC: O(1)\\n    public int maxDistance2(int[] colors) {\\n        int ans = 0;\\n        for(int i=0;i<colors.length;i++){\\n            int curr = 0;\\n            for(int j=i;j<colors.length;j++){\\n                if(colors[i]!=colors[j] && j-i>curr){\\n                    curr=j-i;\\n                }\\n            }\\n            ans = Math.max(ans,curr);\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981990,
                "title": "easy-approach-in-c",
                "content": "# Code\\n```\\nclass Solution\\n{\\n    public:\\n        int maxDistance(vector<int> &colors)\\n        {\\n            int l = colors.size();\\n            int res = 0;\\n\\n            for (int i = 0; i < l; i++)\\n            {\\n                for (int j = i + 1; j < l; j++)\\n                {\\n                    if (colors[i] != colors[j])\\n                    {\\n                        res = max(res, abs(i - j));\\n\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n        };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int maxDistance(vector<int> &colors)\\n        {\\n            int l = colors.size();\\n            int res = 0;\\n\\n            for (int i = 0; i < l; i++)\\n            {\\n                for (int j = i + 1; j < l; j++)\\n                {\\n                    if (colors[i] != colors[j])\\n                    {\\n                        res = max(res, abs(i - j));\\n\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n        };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981428,
                "title": "easy-javascript-solution-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} colors\\n * @return {number}\\n */\\nvar maxDistance = function (colors) {\\n\\n    // initialize distance and k to zero\\n    let distance = 0, k = 0;\\n\\n    // loop through 0 to less than 1\\n    for (let i = 0; i < 1; i++) {\\n\\n        // loop through i+1 to length of colors\\n        for (let j = i + 1; j < colors.length; j++) {\\n\\n            // if colors[i] not equal to colros[j] then distance is equal to subtraction of j and i\\n            if (colors[i] !== colors[j]) {\\n\\n                // if distance is equal to zero then k becomes j\\n                if (distance === 0) {\\n                    k = j;\\n                }\\n\\n                // distance is equal to subtraction of j and i\\n                distance = j - i;\\n            } else {\\n\\n                // else if k is greater than zero\\n                if (k > 0) {\\n\\n                    // max is equal to subtraction of j and k\\n                    let max = j - k;\\n                    \\n                    // if max is greater than distance then assgin max to distnace\\n                    if (max > distance) {\\n                        distance = max;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    // return distance\\n    return distance;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} colors\\n * @return {number}\\n */\\nvar maxDistance = function (colors) {\\n\\n    // initialize distance and k to zero\\n    let distance = 0, k = 0;\\n\\n    // loop through 0 to less than 1\\n    for (let i = 0; i < 1; i++) {\\n\\n        // loop through i+1 to length of colors\\n        for (let j = i + 1; j < colors.length; j++) {\\n\\n            // if colors[i] not equal to colros[j] then distance is equal to subtraction of j and i\\n            if (colors[i] !== colors[j]) {\\n\\n                // if distance is equal to zero then k becomes j\\n                if (distance === 0) {\\n                    k = j;\\n                }\\n\\n                // distance is equal to subtraction of j and i\\n                distance = j - i;\\n            } else {\\n\\n                // else if k is greater than zero\\n                if (k > 0) {\\n\\n                    // max is equal to subtraction of j and k\\n                    let max = j - k;\\n                    \\n                    // if max is greater than distance then assgin max to distnace\\n                    if (max > distance) {\\n                        distance = max;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    // return distance\\n    return distance;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976119,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        b=[]\\n        for i in range(0,len(colors)-1) :\\n            a=0\\n            for j in range(i+1,len(colors)) :\\n                if colors[i]==colors[j] :\\n                    a+=1\\n                elif colors[i]!=colors[j] :\\n                    a+=1\\n                    b.append(a)\\n        return max(b)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        b=[]\\n        for i in range(0,len(colors)-1) :\\n            a=0\\n            for j in range(i+1,len(colors)) :\\n                if colors[i]==colors[j] :\\n                    a+=1\\n                elif colors[i]!=colors[j] :\\n                    a+=1\\n                    b.append(a)\\n        return max(b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970946,
                "title": "beats-100-00-of-users-with-ruby",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {Integer[]} colors\\n# @return {Integer}\\ndef max_distance(colors)\\n  p colors\\n  max = 0\\n  (0..colors.length/2 + 1).each do |i|\\n    (i + 1..colors.length - 1).each do |j|\\n      if colors[i] != colors[j] && (j - i) > max\\n        p \"i: #{i}, j: #{j}\"\\n        max = j - i\\n      end\\n    end\\n  end\\n  max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} colors\\n# @return {Integer}\\ndef max_distance(colors)\\n  p colors\\n  max = 0\\n  (0..colors.length/2 + 1).each do |i|\\n    (i + 1..colors.length - 1).each do |j|\\n      if colors[i] != colors[j] && (j - i) > max\\n        p \"i: #{i}, j: #{j}\"\\n        max = j - i\\n      end\\n    end\\n  end\\n  max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3958023,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int diff = 0;\\n        int output = 0;\\n        for (int i = 0; i < colors.length - 1; i++) {\\n            int shift = 0;\\n            int index = i + 1;\\n            boolean shouldSkip = true;\\n            for (int j = colors.length - 1; j >= i + 1; j--) {\\n                if (shouldSkip && colors[i] == colors[index++]) {\\n                    shift++;\\n                } else {\\n                    shouldSkip = false;\\n                }\\n                if (colors[i] != colors[j]) {\\n                    diff = Math.abs(i - j);\\n                    break;\\n                }\\n            }\\n            output = Math.max(output, diff);\\n            if (output == colors.length) {\\n                return output;\\n            }\\n            i += shift;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int diff = 0;\\n        int output = 0;\\n        for (int i = 0; i < colors.length - 1; i++) {\\n            int shift = 0;\\n            int index = i + 1;\\n            boolean shouldSkip = true;\\n            for (int j = colors.length - 1; j >= i + 1; j--) {\\n                if (shouldSkip && colors[i] == colors[index++]) {\\n                    shift++;\\n                } else {\\n                    shouldSkip = false;\\n                }\\n                if (colors[i] != colors[j]) {\\n                    diff = Math.abs(i - j);\\n                    break;\\n                }\\n            }\\n            output = Math.max(output, diff);\\n            if (output == colors.length) {\\n                return output;\\n            }\\n            i += shift;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953917,
                "title": "java-solution-time-complexity-o-n-2-space-complexity-o-1",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int result = 0;\\n\\n        for (int i = 0; i < colors.length; i++) {\\n            for (int j = 0; j < colors.length; j++) {\\n                if (colors[i] != colors[j]) {\\n                    int min = Math.abs(j - i);\\n\\n                    if (result < min) {\\n                        result = min;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int result = 0;\\n\\n        for (int i = 0; i < colors.length; i++) {\\n            for (int j = 0; j < colors.length; j++) {\\n                if (colors[i] != colors[j]) {\\n                    int min = Math.abs(j - i);\\n\\n                    if (result < min) {\\n                        result = min;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951743,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        houses = list(set(colors))\\n        maxval = 0\\n\\n        print(houses)\\n\\n        for h in houses:\\n            l = 0\\n\\n            while l < len(colors):\\n                if colors[l] == h:\\n                    break\\n                l += 1\\n            \\n            r = len(colors) - 1\\n\\n            while r >= 0:\\n                if colors[r] != h:\\n                    break\\n                r -= 1\\n            \\n            maxval = max(maxval, r-l)\\n        \\n        print(maxval)\\n        return maxval\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        houses = list(set(colors))\\n        maxval = 0\\n\\n        print(houses)\\n\\n        for h in houses:\\n            l = 0\\n\\n            while l < len(colors):\\n                if colors[l] == h:\\n                    break\\n                l += 1\\n            \\n            r = len(colors) - 1\\n\\n            while r >= 0:\\n                if colors[r] != h:\\n                    break\\n                r -= 1\\n            \\n            maxval = max(maxval, r-l)\\n        \\n        print(maxval)\\n        return maxval\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938040,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] c) {\\n        int n=c.length;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(c[i]!=c[j]){\\n                    ans=Math.max(ans,(j-i));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] c) {\\n        int n=c.length;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(c[i]!=c[j]){\\n                    ans=Math.max(ans,(j-i));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938039,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] c) {\\n        int n=c.length;\\n        int f=0;\\n        for(int i=1;i<n;i++){\\n            if(c[0]!=c[i]){\\n                f=i;\\n            }\\n        }\\n        int l=n-1;\\n        for(int i=n-1;i>=0;i--){\\n            if(c[n-1]!=c[i]){\\n                l=i;\\n            }\\n        }\\n        l=n-l-1;\\n        return Math.max(l,f);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] c) {\\n        int n=c.length;\\n        int f=0;\\n        for(int i=1;i<n;i++){\\n            if(c[0]!=c[i]){\\n                f=i;\\n            }\\n        }\\n        int l=n-1;\\n        for(int i=n-1;i>=0;i--){\\n            if(c[n-1]!=c[i]){\\n                l=i;\\n            }\\n        }\\n        l=n-l-1;\\n        return Math.max(l,f);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925818,
                "title": "enhance-your-dp-python",
                "content": "# Intuition\\nThis problem can be solved using normal loops and pointers but in case you want to practice your dp you can try this method. \\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        # either choose the front color\\n        # or choose the back color\\n        @cache\\n        def recur(i, j):\\n            if colors[i] != colors[j]:\\n                return j - i\\n            \\n            if i >= j:\\n                return 0\\n            r1 = 0\\n            r2 = 0\\n            if colors[i] == colors[j]:\\n                r1 = recur(i+1, j)\\n                r2 = recur(i, j-1)\\n            return max(r1, r2)\\n        length = recur(0, len(colors)-1)\\n        return length\\n\\n        \\n        # maxLen = 0\\n        # for i in range(len(colors)-1):\\n        #     for j in range(i+1, len(colors)):\\n        #         if colors[i] != colors[j]:\\n        #             maxLen = max(maxLen, j-i)\\n        # return maxLen\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        # either choose the front color\\n        # or choose the back color\\n        @cache\\n        def recur(i, j):\\n            if colors[i] != colors[j]:\\n                return j - i\\n            \\n            if i >= j:\\n                return 0\\n            r1 = 0\\n            r2 = 0\\n            if colors[i] == colors[j]:\\n                r1 = recur(i+1, j)\\n                r2 = recur(i, j-1)\\n            return max(r1, r2)\\n        length = recur(0, len(colors)-1)\\n        return length\\n\\n        \\n        # maxLen = 0\\n        # for i in range(len(colors)-1):\\n        #     for j in range(i+1, len(colors)):\\n        #         if colors[i] != colors[j]:\\n        #             maxLen = max(maxLen, j-i)\\n        # return maxLen\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924521,
                "title": "typescript-javascript-elegant-solution-in-o-n",
                "content": "\\n\\n# Code\\n```\\nfunction maxDistance(colors: number[]): number {\\n  let color = colors.at(0) \\n  let result = 0\\n\\n  for(let i = 1, j = colors.length - 2; i < colors.length; i++, j--) {\\n    if(colors[i] !== color || colors[j] !== color) {\\n      result = Math.max(result, Math.abs(Math.max(i, j)))\\n    } \\n  }\\n\\n  return result\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction maxDistance(colors: number[]): number {\\n  let color = colors.at(0) \\n  let result = 0\\n\\n  for(let i = 1, j = colors.length - 2; i < colors.length; i++, j--) {\\n    if(colors[i] !== color || colors[j] !== color) {\\n      result = Math.max(result, Math.abs(Math.max(i, j)))\\n    } \\n  }\\n\\n  return result\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3922169,
                "title": "python-single-line-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        return next(len(colors)-1-i for i in range(len(colors)) if (colors[0] != colors [-i-1]) or (colors[i] != colors [-1]))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        return next(len(colors)-1-i for i in range(len(colors)) if (colors[0] != colors [-i-1]) or (colors[i] != colors [-1]))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904793,
                "title": "easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int i,j,max=0,length=0;\\n        for(i=0;i<colors.length;i++)\\n        {\\n            for(j=i+1;j<colors.length;j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                    length=Math.abs(i-j);\\n\\n                 if(length>max)\\n                    max=length;   \\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int i,j,max=0,length=0;\\n        for(i=0;i<colors.length;i++)\\n        {\\n            for(j=i+1;j<colors.length;j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                    length=Math.abs(i-j);\\n\\n                 if(length>max)\\n                    max=length;   \\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902485,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int m=-1111111;\\n        \\n        for(int i=0;i<colors.size();i++){\\n            int a=colors[i];\\n            for(int j=i+1;j<colors.size();j++){\\n                if(a!=colors[j]){\\n                m=max(m,abs(i-j));\\n                 }\\n            }\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int m=-1111111;\\n        \\n        for(int i=0;i<colors.size();i++){\\n            int a=colors[i];\\n            for(int j=i+1;j<colors.size();j++){\\n                if(a!=colors[j]){\\n                m=max(m,abs(i-j));\\n                 }\\n            }\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899560,
                "title": "python-easy-clean-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        start = 0 \\n        end = len(colors) - 1\\n\\n        while start <= end:\\n            if colors[start] != colors[0]:\\n                return abs(len(colors) - 1 - start)\\n            elif colors[end] != colors[len(colors) - 1]:\\n                return end\\n            elif colors[start] != colors[end]:\\n                return abs(end - start)\\n            start += 1\\n            end -= 1\\n```\\n![catty.png](https://assets.leetcode.com/users/images/ed5994f8-ac2e-4268-9055-e74b48aa6d84_1691848736.10279.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        start = 0 \\n        end = len(colors) - 1\\n\\n        while start <= end:\\n            if colors[start] != colors[0]:\\n                return abs(len(colors) - 1 - start)\\n            elif colors[end] != colors[len(colors) - 1]:\\n                return end\\n            elif colors[start] != colors[end]:\\n                return abs(end - start)\\n            start += 1\\n            end -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884115,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int start = 0;\\n        int end = colors.length - 1;\\n\\n        while (start < end) {\\n            if (colors[start] != colors[end]) {\\n                break;\\n            }\\n            else {\\n                --end;\\n            }\\n        }\\n\\n        int start1 = 0;\\n        int end1 = colors.length - 1;\\n\\n        while (start1 < end1) {\\n            if (colors[start1] != colors[end1]) {\\n                break;\\n            }\\n            else {\\n                ++start1;\\n            }\\n        }\\n\\n        return Math.max(end - start, end1 - start1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int start = 0;\\n        int end = colors.length - 1;\\n\\n        while (start < end) {\\n            if (colors[start] != colors[end]) {\\n                break;\\n            }\\n            else {\\n                --end;\\n            }\\n        }\\n\\n        int start1 = 0;\\n        int end1 = colors.length - 1;\\n\\n        while (start1 < end1) {\\n            if (colors[start1] != colors[end1]) {\\n                break;\\n            }\\n            else {\\n                ++start1;\\n            }\\n        }\\n\\n        return Math.max(end - start, end1 - start1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873964,
                "title": "a-rigorous-proof-for-lee215-solution-and-a-painfully-long-explanation-of-how-you-could-have-found-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI don\\'t pretend to know how he thought about this magnificent solution but here how i understood it, and I hope it helps you.\\n\\nThe key idea here is two-pointer. And it turns out the first pointer is useless. We will see why.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n## The looooong explanation (You can skip this if you just want the proof)\\n\\n\\nHere is my initial approach(two-pointer):\\n\\nInitialize two pointers, left and right, at the beginning and end of the colors array, respectively.\\nIterate through the colors array using a loop.\\nCheck if the colors at the left and right pointers are different.\\nIf they are different, return the absolute difference between their positions, representing the distance between two different-colored houses.\\nIf the colors at the left and right pointers are the same:\\nCheck if the color at left+1 is different from the color at left.\\nIf they are different, increment the left pointer to move one step to the right.\\nPrint the updated left and right pointers (optional, for understanding).\\nIf the color at left+1 is the same as the color at left, move the right pointer one step to the left.\\nRepeat the process until finding two different-colored houses.\\n\\nThis works for the testcases. But they happend to be symetric. It won\\'t always work if the colors list is asymetric.\\n\\n\\nThis testcase here illustrate it:\\n[4,4,4,11,4,4,11,4,4,4,4,4]\\nAt the end of our program, left=0, right=6 =>[4,4,4,11,4,4,11]\\nBut there is a bigger interval actually: [11,4,4,11,4,4,4,4,4]\\nOur algorithm is perfectly capable of finding it, just reverse the string. And everything will work fine.\\nThe problem lies here:\\n\"Check if the color at left+1 is different from the color at left.\\nIf they are different, increment the left pointer to move one step to the right.\"\\nYou may not have the exact same condition, but most two-pointers approach incorporate this sense of direction because usually you have to move one pointer first. Lee215\\'solution fix this problem by running a two-pointer approach in both direction.\\n\\n## Why is the first-pointer immobile(a proof by contradiction)\\n\\nHis solution suggest that the maxDistance is always achieved with a house on the border of the array.\\nWhy? \\nLet\\'s suppose that it\\'s not the case. Therefore, the two houses with different colors at the maximun distance are at best at distance n-3\\n[start,best-position-first-color,........,best-position-second-color,end].\\n(best config we could hope for)\\nWe have a contradiction here. Because, if \"start\" and best-position-first-color don\\'t have the same color, than we didn\\'t reach the maximun distance since we could have got n-2.\\nBut if they are of the same color, than we can still get n-2 by picking \"start\" and \"best-postion-second-color\". And you can do the same reasoning starting with best-position-second-color.\\n\\nSo we know for sure, that the maximum distance is reach on a border. We just don\\'t know which one. And from this you get his solution by implementing a baby two-pointer.\\nVICTORY!!!\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n2*O(n) ==> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        #Credit to lee215, i saw this approach in his post.\\n        i, j = 0, len(colors) - 1\\n        while colors[0] == colors[j]: j -= 1\\n        while colors[-1] == colors[i]: i += 1\\n        return max(len(colors) - 1 - i, j)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        #Credit to lee215, i saw this approach in his post.\\n        i, j = 0, len(colors) - 1\\n        while colors[0] == colors[j]: j -= 1\\n        while colors[-1] == colors[i]: i += 1\\n        return max(len(colors) - 1 - i, j)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868884,
                "title": "o-n-n-approach-beats-100-on-time",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nChecking every pair of the array for inequality.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        if(colors[0]!=colors[colors.size()-1])\\n            return colors.size()-1;\\n        int c=0;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n            for(int j=i;j<colors.size();j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {    \\n                    if(colors[i] != colors[j])\\n                        c = max(c,abs(j - i));\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        if(colors[0]!=colors[colors.size()-1])\\n            return colors.size()-1;\\n        int c=0;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n            for(int j=i;j<colors.size();j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {    \\n                    if(colors[i] != colors[j])\\n                        c = max(c,abs(j - i));\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867205,
                "title": "easy-and-100-efficiant-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n=colors.size();\\n        int ans=0;\\n        for(int i=0; i<n-1; i++)\\n        {\\n            for(int j=i+1; j<n; j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    ans=max(ans,abs(i-j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n=colors.size();\\n        int ans=0;\\n        for(int i=0; i<n-1; i++)\\n        {\\n            for(int j=i+1; j<n; j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    ans=max(ans,abs(i-j));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867120,
                "title": "java-simple-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n * log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int max = 0, n = colors.length;\\n\\n        if(colors[0] != colors[n-1]) return n-1;\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                if(colors[j] != colors[i]){\\n                   max = Math.max(max, i - j);\\n                   break;\\n                }\\n            }\\n\\n            for(int j = i + 1; j < n; j++){\\n                if(colors[j] != colors[i]){\\n                   max = Math.max(max, j - i);\\n                   break;\\n                }\\n            }\\n        }\\n            \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int max = 0, n = colors.length;\\n\\n        if(colors[0] != colors[n-1]) return n-1;\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < i; j++){\\n                if(colors[j] != colors[i]){\\n                   max = Math.max(max, i - j);\\n                   break;\\n                }\\n            }\\n\\n            for(int j = i + 1; j < n; j++){\\n                if(colors[j] != colors[i]){\\n                   max = Math.max(max, j - i);\\n                   break;\\n                }\\n            }\\n        }\\n            \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847108,
                "title": "beat-100-java-solution-using-double-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int n=colors.length;\\n        int i=0;\\n        int j=n-1;\\n        int ans=0;\\n        int max=Integer.MIN_VALUE;\\n      while(i<j)\\n      {\\n          if(colors[i]!=colors[j])\\n          {\\n              ans=Math.abs(j-i);\\n              max=Math.max(ans,max);\\n              \\n              j--;\\n          }\\n          else{\\n              \\n              j--;\\n          }\\n\\n              \\n      }\\ni=0;\\nj=n-1;\\n      while(i<j)\\n      {\\n         if(colors[i]!=colors[j])\\n          {\\n              ans=Math.abs(j-i);\\n              max=Math.max(ans,max);\\n              \\n              i++;\\n          }\\n          else{\\n              \\n              i++;\\n          }\\n\\n\\n\\n\\n\\n      }\\n       return max;\\n\\n    }\\n\\n \\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int n=colors.length;\\n        int i=0;\\n        int j=n-1;\\n        int ans=0;\\n        int max=Integer.MIN_VALUE;\\n      while(i<j)\\n      {\\n          if(colors[i]!=colors[j])\\n          {\\n              ans=Math.abs(j-i);\\n              max=Math.max(ans,max);\\n              \\n              j--;\\n          }\\n          else{\\n              \\n              j--;\\n          }\\n\\n              \\n      }\\ni=0;\\nj=n-1;\\n      while(i<j)\\n      {\\n         if(colors[i]!=colors[j])\\n          {\\n              ans=Math.abs(j-i);\\n              max=Math.max(ans,max);\\n              \\n              i++;\\n          }\\n          else{\\n              \\n              i++;\\n          }\\n\\n\\n\\n\\n\\n      }\\n       return max;\\n\\n    }\\n\\n \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844739,
                "title": "beats-57-use-for-comparing-with-code-simple-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDistance(self, colors):\\n        d=0\\n        c=0\\n        i=0\\n        j=len(colors)-1\\n        while j>0:\\n            \\n            if colors[j]==colors[i]:\\n                j-=1\\n            else:\\n                d=j\\n                break\\n        k=0\\n        l=len(colors)-1\\n        while k<len(colors):\\n            if colors[l]==colors[k]:\\n                k+=1\\n            else:\\n                c=l-k\\n                break\\n\\n                    \\n        \\n                \\n        return max(d,c)\\n                \\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDistance(self, colors):\\n        d=0\\n        c=0\\n        i=0\\n        j=len(colors)-1\\n        while j>0:\\n            \\n            if colors[j]==colors[i]:\\n                j-=1\\n            else:\\n                d=j\\n                break\\n        k=0\\n        l=len(colors)-1\\n        while k<len(colors):\\n            if colors[l]==colors[k]:\\n                k+=1\\n            else:\\n                c=l-k\\n                break\\n\\n                    \\n        \\n                \\n        return max(d,c)\\n                \\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844180,
                "title": "maximum-distance-between-different-colors",
                "content": "# Intuition\\nThe problem asks us to find the maximum distance between two indices in the given vector colors such that the colors at those indices are different. We want to find the maximum distance between such indices.\\n# Approach\\nThe given solution uses a nested loop to compare all pairs of indices i and j in the vector colors (where i < j). For each pair, it checks if the colors at these indices are different. If they are different, it updates the maxi variable to store the maximum distance between such indices found so far.\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int maxi = INT_MIN;\\n        for(int i =0;i<colors.size();i++)\\n        {\\n            for(int j =i+1;j<colors.size();j++)\\n            {\\n                if(colors[i] != colors[j])\\n                maxi = max(maxi, abs(i-j));\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int maxi = INT_MIN;\\n        for(int i =0;i<colors.size();i++)\\n        {\\n            for(int j =i+1;j<colors.size();j++)\\n            {\\n                if(colors[i] != colors[j])\\n                maxi = max(maxi, abs(i-j));\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829296,
                "title": "recursion-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int p1, int p2, vector<int>& colors, vector<vector<int>>& dp){\\n        if(p1>=p2){\\n            return 0;\\n        }\\n        if(dp[p1][p2]!=-1){\\n            return dp[p1][p2];\\n        }\\n        if(colors[p1]!=colors[p2]){\\n            return p2-p1;\\n        }\\n        int a = f(p1, p2-1, colors, dp);\\n        int b = f(p1+1, p2, colors, dp);\\n        return dp[p1][p2] = max(a,b);\\n    }\\n    int maxDistance(vector<int>& colors) {\\n        int p1 = 0;\\n        int p2 = colors.size()-1;\\n        vector<vector<int>> dp(1001, vector<int>(1001,-1));\\n        return f(p1, p2, colors,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int p1, int p2, vector<int>& colors, vector<vector<int>>& dp){\\n        if(p1>=p2){\\n            return 0;\\n        }\\n        if(dp[p1][p2]!=-1){\\n            return dp[p1][p2];\\n        }\\n        if(colors[p1]!=colors[p2]){\\n            return p2-p1;\\n        }\\n        int a = f(p1, p2-1, colors, dp);\\n        int b = f(p1+1, p2, colors, dp);\\n        return dp[p1][p2] = max(a,b);\\n    }\\n    int maxDistance(vector<int>& colors) {\\n        int p1 = 0;\\n        int p2 = colors.size()-1;\\n        vector<vector<int>> dp(1001, vector<int>(1001,-1));\\n        return f(p1, p2, colors,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796193,
                "title": "two-furthest-houses-with-different-colors",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int max=0;\\n        int i=0;\\n        int j=1;\\n        while(i<colors.length-1)\\n        {\\n            if(colors[i]!=colors[j])\\n            max = Math.max(max,Math.abs(i-j));\\n            j++;\\n            if(j==colors.length)\\n            {\\n                i=i+1;\\n                j=i+1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int max=0;\\n        int i=0;\\n        int j=1;\\n        while(i<colors.length-1)\\n        {\\n            if(colors[i]!=colors[j])\\n            max = Math.max(max,Math.abs(i-j));\\n            j++;\\n            if(j==colors.length)\\n            {\\n                i=i+1;\\n                j=i+1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791429,
                "title": "python-beats-97-3-and-94-59",
                "content": "![\\u672A\\u547D\\u540D.png](https://assets.leetcode.com/users/images/8ae26379-fea0-4e3c-bd99-096089ab9809_1689841394.1180787.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ln = len(colors) - 1\\n        i = 0\\n        j = ln\\n        d = j - i\\n        while True:\\n            if colors[i] != colors[j]:\\n                return j - i\\n            else:\\n                if j == ln:\\n                    i = 0\\n                    d = d - 1\\n                    j = i + d\\n                else:\\n                    i = i + 1\\n                    j = j + 1\\n        \\n        # 20230720\\n\\n        # \\u9577\\u5EA6\\u8D8A\\u4F86\\u8D8A\\u77ED\\u7684\\u6BDB\\u6BDB\\u87F2\\u5F9E\\u982D\\u958B\\u59CB\\u5F80\\u524D\\u722C\\u884C\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ln = len(colors) - 1\\n        i = 0\\n        j = ln\\n        d = j - i\\n        while True:\\n            if colors[i] != colors[j]:\\n                return j - i\\n            else:\\n                if j == ln:\\n                    i = 0\\n                    d = d - 1\\n                    j = i + d\\n                else:\\n                    i = i + 1\\n                    j = j + 1\\n        \\n        # 20230720\\n\\n        # \\u9577\\u5EA6\\u8D8A\\u4F86\\u8D8A\\u77ED\\u7684\\u6BDB\\u6BDB\\u87F2\\u5F9E\\u982D\\u958B\\u59CB\\u5F80\\u524D\\u722C\\u884C\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769720,
                "title": "c-runtime-beats-100",
                "content": "![image.png](https://assets.leetcode.com/users/images/00b6ada3-de52-4ce1-b5ea-1d9d63d23f0c_1689440456.590977.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int dist=INT_MIN;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n            for(int j=i+1;j<colors.size();j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    dist=max(dist,abs(i-j));\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int dist=INT_MIN;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n            for(int j=i+1;j<colors.size();j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    dist=max(dist,abs(i-j));\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763196,
                "title": "c-smartest-approach-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBegin with pointers i which points at beginning, and j which points at the end.\\nIf houses have the same color then You have to set one of these pointers to the first color that is different, but You have to choose the closest one. If colors are different then You can simply return the distance. Consider:\\n\\n[1, 8, ..., 8, 1, 1]\\n-i-------------j \\n\\n[1, 8, ..., 8, 1, 1] To set j there is worse - Shorter distance\\n-i--------j\\n\\n[1, 8, ..., 8, 1, 1] Better - Longer distance\\n----i----------j \\n\\nIf You think about this, one of the pointers will always be either at beginning or at the end of the array!\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n = colors.size(), i = 0, j = n - 1;\\n\\n        if(colors[i] == colors[j]){\\n            int iCopy = i, jCopy = j;\\n\\n            while(iCopy <= jCopy){\\n\\n                if(colors[iCopy] != colors[i]){\\n                    i = iCopy;\\n                    break;\\n                }\\n                if(colors[jCopy] != colors[j]){\\n                    j = jCopy;\\n                    break;\\n                }\\n\\n                if(iCopy == jCopy) return 0;\\n\\n                iCopy++;\\n                jCopy--;\\n            }\\n\\n        }\\n\\n        return j - i;\\n    }                  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int n = colors.size(), i = 0, j = n - 1;\\n\\n        if(colors[i] == colors[j]){\\n            int iCopy = i, jCopy = j;\\n\\n            while(iCopy <= jCopy){\\n\\n                if(colors[iCopy] != colors[i]){\\n                    i = iCopy;\\n                    break;\\n                }\\n                if(colors[jCopy] != colors[j]){\\n                    j = jCopy;\\n                    break;\\n                }\\n\\n                if(iCopy == jCopy) return 0;\\n\\n                iCopy++;\\n                jCopy--;\\n            }\\n\\n        }\\n\\n        return j - i;\\n    }                  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756025,
                "title": "masum-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int maxx=0;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n            for(int j=i+1;j<colors.size();j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    maxx=max(maxx,(j-i));\\n                }\\n            }\\n        }\\n        return maxx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>& colors) {\\n        int maxx=0;\\n        for(int i=0;i<colors.size();i++)\\n        {\\n            for(int j=i+1;j<colors.size();j++)\\n            {\\n                if(colors[i]!=colors[j])\\n                {\\n                    maxx=max(maxx,(j-i));\\n                }\\n            }\\n        }\\n        return maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753096,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, arr: List[int]) -> int:\\n        n=len(arr)\\n        i=0\\n        j=len(arr)-1\\n        while arr[0]==arr[j]:\\n            j-=1\\n        \\n        while arr[n-1]==arr[i]:\\n            i+=1\\n        \\n        return max(n-1-i,j)\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDistance(self, arr: List[int]) -> int:\\n        n=len(arr)\\n        i=0\\n        j=len(arr)-1\\n        while arr[0]==arr[j]:\\n            j-=1\\n        \\n        while arr[n-1]==arr[i]:\\n            i+=1\\n        \\n        return max(n-1-i,j)\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748118,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>c){\\n        int i=0 , j=c.size()-1 , mx1=0 , mx2=0;\\n        while(i<j){\\n            if(c[i]==c[j]){\\n                j--;\\n            }\\n            else{\\n                mx1 = abs(i-j);\\n                break;\\n            }\\n        }\\n        int k=0 , l=c.size()-1;\\n        while(k<l){\\n            if(c[k]==c[l]){\\n                k++;\\n            }\\n            else{\\n                mx2 = abs(k-l);\\n                break;\\n            }\\n        }\\n        return max(mx1,mx2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDistance(vector<int>c){\\n        int i=0 , j=c.size()-1 , mx1=0 , mx2=0;\\n        while(i<j){\\n            if(c[i]==c[j]){\\n                j--;\\n            }\\n            else{\\n                mx1 = abs(i-j);\\n                break;\\n            }\\n        }\\n        int k=0 , l=c.size()-1;\\n        while(k<l){\\n            if(c[k]==c[l]){\\n                k++;\\n            }\\n            else{\\n                mx2 = abs(k-l);\\n                break;\\n            }\\n        }\\n        return max(mx1,mx2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736503,
                "title": "simple-java-100-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int i=0;\\n        int j=colors.length-1;\\n        int max1=0;\\n        int max2=0;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                max1=j-i;\\n                break;\\n            }\\n            j--;\\n        }\\n        i=0;\\n        j=colors.length-1;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                max2=j-i;\\n                break;\\n            }\\n            i++;\\n        }\\n        if(max1>max2){\\n            return max1;\\n        }\\n        return max2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDistance(int[] colors) {\\n        int i=0;\\n        int j=colors.length-1;\\n        int max1=0;\\n        int max2=0;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                max1=j-i;\\n                break;\\n            }\\n            j--;\\n        }\\n        i=0;\\n        j=colors.length-1;\\n        while(i<j){\\n            if(colors[i]!=colors[j]){\\n                max2=j-i;\\n                break;\\n            }\\n            i++;\\n        }\\n        if(max1>max2){\\n            return max1;\\n        }\\n        return max2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1844748,
                "content": [
                    {
                        "username": "Msey",
                        "content": "take max from (differentHouseIndex - firstHouseIndex) (lastHouseIndex  - differentHouseIndex)"
                    },
                    {
                        "username": "dpwang",
                        "content": "assigin the  hourses index are \\na1 a2 a.. an\\n\\nif the firts or the  last hourse eighter in the first or in the last, \\nassume the index of first house is ai, and the last house is  aj (i < j)\\nso colors[ai] != colors[aj]\\n\\nbecause [a1, aj] is not the best answer, so  colors[a1] = colors[aj]\\nThe same , colors[aj] = colors[an],\\nas a reuslt,  colors[a1] =  colors[ai] = colors[aj] =  colors[an],  the hypothesis does not hold\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "can probably add a two pointer tag here"
                    },
                    {
                        "username": "Shanmugamayan",
                        "content": "  int color = colors[0];\\n        int ans =0;\\n        for(int i=1;i<colors.size();i++)\\n        {\\n            if(colors[i]!=color)\\n            {\\n                ans= max(ans,i-0);\\n                \\n              \\n            }\\n            else if(colors[i]==color)\\n            {\\n                color = colors[i];\\n                \\n            }\\n        }\\n        return ans;  \\n\\npassed 81 test cases.. what went wrong?? please correct the code and give explanation"
                    },
                    {
                        "username": "laichbr",
                        "content": "The issue is that you need to consider this from both points of view. Let\\'s stake two points, the first and last index of colors. These indices obviously have the largest distance from any other distance within the list for having different colors. With this in mind, \\n\\nSet current index to 0, answer_1 to 0, and color to colors at current index. Loop from 1 to length of colors over index i. answer_1 is max of self and i - current index if colors at i != color else answer_1. \\n\\nSet current index to length of colors - 1. Set answer_2 to 0. Set color to colors at current index. Loop from current_index - 1 to -1 in steps of -1, where answer_2 is max of self and current index - i if colors[i] != color, else answer_2 \\n\\nSet answer to max of answer_1 and answer_2. Return answer. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice beginner friendly question"
                    },
                    {
                        "username": "Abhishek_WX7",
                        "content": "Two pointer should be tagged in this problem related topics."
                    },
                    {
                        "username": "swseverance",
                        "content": "It\\'s a good problem. They should\\'ve set proper constraints and made it a medium"
                    }
                ]
            },
            {
                "id": 1576012,
                "content": [
                    {
                        "username": "Msey",
                        "content": "take max from (differentHouseIndex - firstHouseIndex) (lastHouseIndex  - differentHouseIndex)"
                    },
                    {
                        "username": "dpwang",
                        "content": "assigin the  hourses index are \\na1 a2 a.. an\\n\\nif the firts or the  last hourse eighter in the first or in the last, \\nassume the index of first house is ai, and the last house is  aj (i < j)\\nso colors[ai] != colors[aj]\\n\\nbecause [a1, aj] is not the best answer, so  colors[a1] = colors[aj]\\nThe same , colors[aj] = colors[an],\\nas a reuslt,  colors[a1] =  colors[ai] = colors[aj] =  colors[an],  the hypothesis does not hold\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "can probably add a two pointer tag here"
                    },
                    {
                        "username": "Shanmugamayan",
                        "content": "  int color = colors[0];\\n        int ans =0;\\n        for(int i=1;i<colors.size();i++)\\n        {\\n            if(colors[i]!=color)\\n            {\\n                ans= max(ans,i-0);\\n                \\n              \\n            }\\n            else if(colors[i]==color)\\n            {\\n                color = colors[i];\\n                \\n            }\\n        }\\n        return ans;  \\n\\npassed 81 test cases.. what went wrong?? please correct the code and give explanation"
                    },
                    {
                        "username": "laichbr",
                        "content": "The issue is that you need to consider this from both points of view. Let\\'s stake two points, the first and last index of colors. These indices obviously have the largest distance from any other distance within the list for having different colors. With this in mind, \\n\\nSet current index to 0, answer_1 to 0, and color to colors at current index. Loop from 1 to length of colors over index i. answer_1 is max of self and i - current index if colors at i != color else answer_1. \\n\\nSet current index to length of colors - 1. Set answer_2 to 0. Set color to colors at current index. Loop from current_index - 1 to -1 in steps of -1, where answer_2 is max of self and current index - i if colors[i] != color, else answer_2 \\n\\nSet answer to max of answer_1 and answer_2. Return answer. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice beginner friendly question"
                    },
                    {
                        "username": "Abhishek_WX7",
                        "content": "Two pointer should be tagged in this problem related topics."
                    },
                    {
                        "username": "swseverance",
                        "content": "It\\'s a good problem. They should\\'ve set proper constraints and made it a medium"
                    }
                ]
            },
            {
                "id": 2060267,
                "content": [
                    {
                        "username": "Msey",
                        "content": "take max from (differentHouseIndex - firstHouseIndex) (lastHouseIndex  - differentHouseIndex)"
                    },
                    {
                        "username": "dpwang",
                        "content": "assigin the  hourses index are \\na1 a2 a.. an\\n\\nif the firts or the  last hourse eighter in the first or in the last, \\nassume the index of first house is ai, and the last house is  aj (i < j)\\nso colors[ai] != colors[aj]\\n\\nbecause [a1, aj] is not the best answer, so  colors[a1] = colors[aj]\\nThe same , colors[aj] = colors[an],\\nas a reuslt,  colors[a1] =  colors[ai] = colors[aj] =  colors[an],  the hypothesis does not hold\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "can probably add a two pointer tag here"
                    },
                    {
                        "username": "Shanmugamayan",
                        "content": "  int color = colors[0];\\n        int ans =0;\\n        for(int i=1;i<colors.size();i++)\\n        {\\n            if(colors[i]!=color)\\n            {\\n                ans= max(ans,i-0);\\n                \\n              \\n            }\\n            else if(colors[i]==color)\\n            {\\n                color = colors[i];\\n                \\n            }\\n        }\\n        return ans;  \\n\\npassed 81 test cases.. what went wrong?? please correct the code and give explanation"
                    },
                    {
                        "username": "laichbr",
                        "content": "The issue is that you need to consider this from both points of view. Let\\'s stake two points, the first and last index of colors. These indices obviously have the largest distance from any other distance within the list for having different colors. With this in mind, \\n\\nSet current index to 0, answer_1 to 0, and color to colors at current index. Loop from 1 to length of colors over index i. answer_1 is max of self and i - current index if colors at i != color else answer_1. \\n\\nSet current index to length of colors - 1. Set answer_2 to 0. Set color to colors at current index. Loop from current_index - 1 to -1 in steps of -1, where answer_2 is max of self and current index - i if colors[i] != color, else answer_2 \\n\\nSet answer to max of answer_1 and answer_2. Return answer. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice beginner friendly question"
                    },
                    {
                        "username": "Abhishek_WX7",
                        "content": "Two pointer should be tagged in this problem related topics."
                    },
                    {
                        "username": "swseverance",
                        "content": "It\\'s a good problem. They should\\'ve set proper constraints and made it a medium"
                    }
                ]
            },
            {
                "id": 2036031,
                "content": [
                    {
                        "username": "Msey",
                        "content": "take max from (differentHouseIndex - firstHouseIndex) (lastHouseIndex  - differentHouseIndex)"
                    },
                    {
                        "username": "dpwang",
                        "content": "assigin the  hourses index are \\na1 a2 a.. an\\n\\nif the firts or the  last hourse eighter in the first or in the last, \\nassume the index of first house is ai, and the last house is  aj (i < j)\\nso colors[ai] != colors[aj]\\n\\nbecause [a1, aj] is not the best answer, so  colors[a1] = colors[aj]\\nThe same , colors[aj] = colors[an],\\nas a reuslt,  colors[a1] =  colors[ai] = colors[aj] =  colors[an],  the hypothesis does not hold\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "can probably add a two pointer tag here"
                    },
                    {
                        "username": "Shanmugamayan",
                        "content": "  int color = colors[0];\\n        int ans =0;\\n        for(int i=1;i<colors.size();i++)\\n        {\\n            if(colors[i]!=color)\\n            {\\n                ans= max(ans,i-0);\\n                \\n              \\n            }\\n            else if(colors[i]==color)\\n            {\\n                color = colors[i];\\n                \\n            }\\n        }\\n        return ans;  \\n\\npassed 81 test cases.. what went wrong?? please correct the code and give explanation"
                    },
                    {
                        "username": "laichbr",
                        "content": "The issue is that you need to consider this from both points of view. Let\\'s stake two points, the first and last index of colors. These indices obviously have the largest distance from any other distance within the list for having different colors. With this in mind, \\n\\nSet current index to 0, answer_1 to 0, and color to colors at current index. Loop from 1 to length of colors over index i. answer_1 is max of self and i - current index if colors at i != color else answer_1. \\n\\nSet current index to length of colors - 1. Set answer_2 to 0. Set color to colors at current index. Loop from current_index - 1 to -1 in steps of -1, where answer_2 is max of self and current index - i if colors[i] != color, else answer_2 \\n\\nSet answer to max of answer_1 and answer_2. Return answer. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice beginner friendly question"
                    },
                    {
                        "username": "Abhishek_WX7",
                        "content": "Two pointer should be tagged in this problem related topics."
                    },
                    {
                        "username": "swseverance",
                        "content": "It\\'s a good problem. They should\\'ve set proper constraints and made it a medium"
                    }
                ]
            },
            {
                "id": 1829496,
                "content": [
                    {
                        "username": "Msey",
                        "content": "take max from (differentHouseIndex - firstHouseIndex) (lastHouseIndex  - differentHouseIndex)"
                    },
                    {
                        "username": "dpwang",
                        "content": "assigin the  hourses index are \\na1 a2 a.. an\\n\\nif the firts or the  last hourse eighter in the first or in the last, \\nassume the index of first house is ai, and the last house is  aj (i < j)\\nso colors[ai] != colors[aj]\\n\\nbecause [a1, aj] is not the best answer, so  colors[a1] = colors[aj]\\nThe same , colors[aj] = colors[an],\\nas a reuslt,  colors[a1] =  colors[ai] = colors[aj] =  colors[an],  the hypothesis does not hold\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "can probably add a two pointer tag here"
                    },
                    {
                        "username": "Shanmugamayan",
                        "content": "  int color = colors[0];\\n        int ans =0;\\n        for(int i=1;i<colors.size();i++)\\n        {\\n            if(colors[i]!=color)\\n            {\\n                ans= max(ans,i-0);\\n                \\n              \\n            }\\n            else if(colors[i]==color)\\n            {\\n                color = colors[i];\\n                \\n            }\\n        }\\n        return ans;  \\n\\npassed 81 test cases.. what went wrong?? please correct the code and give explanation"
                    },
                    {
                        "username": "laichbr",
                        "content": "The issue is that you need to consider this from both points of view. Let\\'s stake two points, the first and last index of colors. These indices obviously have the largest distance from any other distance within the list for having different colors. With this in mind, \\n\\nSet current index to 0, answer_1 to 0, and color to colors at current index. Loop from 1 to length of colors over index i. answer_1 is max of self and i - current index if colors at i != color else answer_1. \\n\\nSet current index to length of colors - 1. Set answer_2 to 0. Set color to colors at current index. Loop from current_index - 1 to -1 in steps of -1, where answer_2 is max of self and current index - i if colors[i] != color, else answer_2 \\n\\nSet answer to max of answer_1 and answer_2. Return answer. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice beginner friendly question"
                    },
                    {
                        "username": "Abhishek_WX7",
                        "content": "Two pointer should be tagged in this problem related topics."
                    },
                    {
                        "username": "swseverance",
                        "content": "It\\'s a good problem. They should\\'ve set proper constraints and made it a medium"
                    }
                ]
            },
            {
                "id": 1806031,
                "content": [
                    {
                        "username": "Msey",
                        "content": "take max from (differentHouseIndex - firstHouseIndex) (lastHouseIndex  - differentHouseIndex)"
                    },
                    {
                        "username": "dpwang",
                        "content": "assigin the  hourses index are \\na1 a2 a.. an\\n\\nif the firts or the  last hourse eighter in the first or in the last, \\nassume the index of first house is ai, and the last house is  aj (i < j)\\nso colors[ai] != colors[aj]\\n\\nbecause [a1, aj] is not the best answer, so  colors[a1] = colors[aj]\\nThe same , colors[aj] = colors[an],\\nas a reuslt,  colors[a1] =  colors[ai] = colors[aj] =  colors[an],  the hypothesis does not hold\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "can probably add a two pointer tag here"
                    },
                    {
                        "username": "Shanmugamayan",
                        "content": "  int color = colors[0];\\n        int ans =0;\\n        for(int i=1;i<colors.size();i++)\\n        {\\n            if(colors[i]!=color)\\n            {\\n                ans= max(ans,i-0);\\n                \\n              \\n            }\\n            else if(colors[i]==color)\\n            {\\n                color = colors[i];\\n                \\n            }\\n        }\\n        return ans;  \\n\\npassed 81 test cases.. what went wrong?? please correct the code and give explanation"
                    },
                    {
                        "username": "laichbr",
                        "content": "The issue is that you need to consider this from both points of view. Let\\'s stake two points, the first and last index of colors. These indices obviously have the largest distance from any other distance within the list for having different colors. With this in mind, \\n\\nSet current index to 0, answer_1 to 0, and color to colors at current index. Loop from 1 to length of colors over index i. answer_1 is max of self and i - current index if colors at i != color else answer_1. \\n\\nSet current index to length of colors - 1. Set answer_2 to 0. Set color to colors at current index. Loop from current_index - 1 to -1 in steps of -1, where answer_2 is max of self and current index - i if colors[i] != color, else answer_2 \\n\\nSet answer to max of answer_1 and answer_2. Return answer. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice beginner friendly question"
                    },
                    {
                        "username": "Abhishek_WX7",
                        "content": "Two pointer should be tagged in this problem related topics."
                    },
                    {
                        "username": "swseverance",
                        "content": "It\\'s a good problem. They should\\'ve set proper constraints and made it a medium"
                    }
                ]
            },
            {
                "id": 1765447,
                "content": [
                    {
                        "username": "Msey",
                        "content": "take max from (differentHouseIndex - firstHouseIndex) (lastHouseIndex  - differentHouseIndex)"
                    },
                    {
                        "username": "dpwang",
                        "content": "assigin the  hourses index are \\na1 a2 a.. an\\n\\nif the firts or the  last hourse eighter in the first or in the last, \\nassume the index of first house is ai, and the last house is  aj (i < j)\\nso colors[ai] != colors[aj]\\n\\nbecause [a1, aj] is not the best answer, so  colors[a1] = colors[aj]\\nThe same , colors[aj] = colors[an],\\nas a reuslt,  colors[a1] =  colors[ai] = colors[aj] =  colors[an],  the hypothesis does not hold\\n"
                    },
                    {
                        "username": "potatopie",
                        "content": "can probably add a two pointer tag here"
                    },
                    {
                        "username": "Shanmugamayan",
                        "content": "  int color = colors[0];\\n        int ans =0;\\n        for(int i=1;i<colors.size();i++)\\n        {\\n            if(colors[i]!=color)\\n            {\\n                ans= max(ans,i-0);\\n                \\n              \\n            }\\n            else if(colors[i]==color)\\n            {\\n                color = colors[i];\\n                \\n            }\\n        }\\n        return ans;  \\n\\npassed 81 test cases.. what went wrong?? please correct the code and give explanation"
                    },
                    {
                        "username": "laichbr",
                        "content": "The issue is that you need to consider this from both points of view. Let\\'s stake two points, the first and last index of colors. These indices obviously have the largest distance from any other distance within the list for having different colors. With this in mind, \\n\\nSet current index to 0, answer_1 to 0, and color to colors at current index. Loop from 1 to length of colors over index i. answer_1 is max of self and i - current index if colors at i != color else answer_1. \\n\\nSet current index to length of colors - 1. Set answer_2 to 0. Set color to colors at current index. Loop from current_index - 1 to -1 in steps of -1, where answer_2 is max of self and current index - i if colors[i] != color, else answer_2 \\n\\nSet answer to max of answer_1 and answer_2. Return answer. "
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice beginner friendly question"
                    },
                    {
                        "username": "Abhishek_WX7",
                        "content": "Two pointer should be tagged in this problem related topics."
                    },
                    {
                        "username": "swseverance",
                        "content": "It\\'s a good problem. They should\\'ve set proper constraints and made it a medium"
                    }
                ]
            }
        ]
    }
]