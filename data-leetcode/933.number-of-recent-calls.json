[
    {
        "title": "Number of Recent Calls",
        "question_content": "You have a RecentCounter class which counts the number of recent requests within a certain time frame.\nImplement the RecentCounter class:\n\n\tRecentCounter() Initializes the counter with zero recent requests.\n\tint ping(int t) Adds a new request at time t, where t represents some time in milliseconds, and returns the number of requests that has happened in the past 3000 milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range [t - 3000, t].\n\nIt is guaranteed that every call to ping uses a strictly larger value of t than the previous call.\n&nbsp;\nExample 1:\n\nInput\n[\"RecentCounter\", \"ping\", \"ping\", \"ping\", \"ping\"]\n[[], [1], [100], [3001], [3002]]\nOutput\n[null, 1, 2, 3, 3]\nExplanation\nRecentCounter recentCounter = new RecentCounter();\nrecentCounter.ping(1);     // requests = [1], range is [-2999,1], return 1\nrecentCounter.ping(100);   // requests = [1, 100], range is [-2900,100], return 2\nrecentCounter.ping(3001);  // requests = [1, 100, 3001], range is [1,3001], return 3\nrecentCounter.ping(3002);  // requests = [1, 100, 3001, 3002], range is [2,3002], return 3\n\n&nbsp;\nConstraints:\n\n\t1 <= t <= 109\n\tEach test case will call ping with strictly increasing values of t.\n\tAt most 104 calls will be made to ping.",
        "solutions": [
            {
                "id": 189239,
                "title": "java-python-3-five-solutions-treemap-treeset-arraylist-queue-circular-list",
                "content": "**Update 2**: Added 2 implementations of Python 3.\\n**Update 1**: Method 4 added for those who are interested in space optimization.\\n\\n**Mehod 1:** `TreeMap`.\\n\\nUse current time and total number of calls as the key and value of `TreeMap`, respectively.\\n\\n**Analysis**\\nTime: O(logN), space: O(N), where N is the number of ping calls from first one till now.\\n\\n```TreeMap.tailMap()``` and `put()` both cost time O(logN).\\n```\\n    TreeMap<Integer, Integer> tm;\\n\\n    public RecentCounter() {\\n        tm = new TreeMap<>();\\n    }\\n    \\n    public int ping(int t) {\\n        tm.put(t, 1 + tm.size());\\n        return tm.tailMap(t - 3000).size();\\n    }\\n```\\n**Mehod 2:** `TreeSet`.\\n\\nOr similarly use ```TreeSet``` instead.\\n\\n```TreeSet.tailSet()``` and `add()` both cost time O(logN).\\n\\n```\\n    TreeSet<Integer> ts;\\n\\n    public RecentCounter() {\\n        ts = new TreeSet<>();\\n    }\\n    \\n    public int ping(int t) {\\n        ts.add(t);\\n        return ts.tailSet(t - 3000).size();\\n    }\\n```\\nSince some complain that the above two methods cause `TLE`, I guess that besides `tailMap` and `tailSet, TreeMap.put()` and `TreeSet.add()` also cost `O(logN)`, therefore the total time cost is high.\\n\\nThe following method will use less time.\\n\\n**Mehod 3:** \\n**Java: Binary Search `ArrayList`**.\\n\\nUse binary search to find the index of the ceiling of `t - 3000`, then `list.size() - index` is the answer.\\n\\n`binarySearch()` cost `O(logN)`.\\n```\\n\\n    List<Integer> list;\\n\\n    public RecentCounter() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        list.add(t);\\n        int index = Collections.binarySearch(list, t - 3000); // search the index of t - 3000.\\n        if (index < 0) { index = ~index; } // if t - 3000 is not in list, use the index of the ceiling of t - 3000.\\n        return list.size() - index;\\n    }\\n```\\n**Python 3: bisect**\\n```\\n    def __init__(self):\\n        self.ls = []\\n\\n    def ping(self, t: int) -> int:\\n        self.ls.append(t)\\n        return len(self.ls) - bisect.bisect_left(self.ls, t - 3000)\\n```\\n**Mehod 4:** `Queue`.\\n\\nTime & space: `O(Math.min(N, 3000))`.\\n**Java**\\n```\\n    Queue<Integer> q;\\n\\n    public RecentCounter() {\\n        q = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.offer(t);\\n        while (q.peek() < t - 3000) { q.poll(); }\\n        return q.size();\\n    }\\n```\\n**Python 3: deque**\\n```\\n    def __init__(self):\\n        self.dq = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.dq.append(t)\\n        while self.dq[0] < t - 3000:\\n            self.dq.popleft()\\n        return len(self.dq)\\n```\\n**Method 5: Fixed size array to implement Circular List**\\nBy **@wushangzhen**\\n\\n```\\n    int[] time;\\n    public RecentCounter() {\\n        time = new int[3001];\\n    }\\n    \\n    public int ping(int t) {\\n        int res = 0;\\n        time[t % 3001] = t;\\n        for (int i = 0; i < 3001; i++) {\\n            if (time[i] != 0 && time[i] >= t - 3000) {\\n                res += 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Note:** the following Python 3 implementation of the method get **TLE**:\\nLet me know if you have any idea to make it faster.\\n```\\n    def __init__(self):\\n        self.time = [0] * 3001\\n\\n    def ping(self, t: int) -> int:\\n        self.time[t % 3001] = t\\n        return sum([self.time[i] and self.time[i] >= t - 3000 for i in range(3001)])\\n```",
                "solutionTags": [],
                "code": "```TreeMap.tailMap()```\n```\\n    TreeMap<Integer, Integer> tm;\\n\\n    public RecentCounter() {\\n        tm = new TreeMap<>();\\n    }\\n    \\n    public int ping(int t) {\\n        tm.put(t, 1 + tm.size());\\n        return tm.tailMap(t - 3000).size();\\n    }\\n```\n```TreeSet```\n```TreeSet.tailSet()```\n```\\n    TreeSet<Integer> ts;\\n\\n    public RecentCounter() {\\n        ts = new TreeSet<>();\\n    }\\n    \\n    public int ping(int t) {\\n        ts.add(t);\\n        return ts.tailSet(t - 3000).size();\\n    }\\n```\n```\\n\\n    List<Integer> list;\\n\\n    public RecentCounter() {\\n        list = new ArrayList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        list.add(t);\\n        int index = Collections.binarySearch(list, t - 3000); // search the index of t - 3000.\\n        if (index < 0) { index = ~index; } // if t - 3000 is not in list, use the index of the ceiling of t - 3000.\\n        return list.size() - index;\\n    }\\n```\n```\\n    def __init__(self):\\n        self.ls = []\\n\\n    def ping(self, t: int) -> int:\\n        self.ls.append(t)\\n        return len(self.ls) - bisect.bisect_left(self.ls, t - 3000)\\n```\n```\\n    Queue<Integer> q;\\n\\n    public RecentCounter() {\\n        q = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.offer(t);\\n        while (q.peek() < t - 3000) { q.poll(); }\\n        return q.size();\\n    }\\n```\n```\\n    def __init__(self):\\n        self.dq = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.dq.append(t)\\n        while self.dq[0] < t - 3000:\\n            self.dq.popleft()\\n        return len(self.dq)\\n```\n```\\n    int[] time;\\n    public RecentCounter() {\\n        time = new int[3001];\\n    }\\n    \\n    public int ping(int t) {\\n        int res = 0;\\n        time[t % 3001] = t;\\n        for (int i = 0; i < 3001; i++) {\\n            if (time[i] != 0 && time[i] >= t - 3000) {\\n                res += 1;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    def __init__(self):\\n        self.time = [0] * 3001\\n\\n    def ping(self, t: int) -> int:\\n        self.time[t % 3001] = t\\n        return sum([self.time[i] and self.time[i] >= t - 3000 for i in range(3001)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 189334,
                "title": "c-easy-and-clean-solution-using-queue",
                "content": "if the queue is not empty , pop the elements which are lesser than t-3000  \\nPush the current element into the queue\\nReturn queue size\\n \\n    queue<int> q;\\n    \\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        \\n\\t\\tq.push(t);\\n\\t\\t   \\n        while(q.front() < t-3000)\\n            q.pop();\\n        \\n        return q.size();\\n    }\\n",
                "solutionTags": [],
                "code": "if the queue is not empty , pop the elements which are lesser than t-3000  \\nPush the current element into the queue\\nReturn queue size\\n \\n    queue<int> q;\\n    \\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        \\n\\t\\tq.push(t);\\n\\t\\t   \\n        while(q.front() < t-3000)\\n            q.pop();\\n        \\n        return q.size();\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 189425,
                "title": "python-straightforward-solution",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.p = collections.deque()        \\n\\n    def ping(self, t):\\n        self.p.append(t)\\n        while self.p[0] < t - 3000:\\n            self.p.popleft()\\n        return len(self.p)\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.p = collections.deque()        \\n\\n    def ping(self, t):\\n        self.p.append(t)\\n        while self.p[0] < t - 3000:\\n            self.p.popleft()\\n        return len(self.p)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873333,
                "title": "python-easy-solution-using-queue-explained",
                "content": "What we need to keep in this problem is sliding window of recent calls. So, we need to remove old calls, if they are too old and append new ones. Ideal data structure is queue, and in python we usualy use `deque`. So, there are 3 simple steps to succes:\\n\\n1. Add new call time to the end of our queue.\\n2. Remove old times: we pop from the beginning of our queue until time is not older than `last - 3000`.\\n3. Return length of our queue: it will be exaclty what we need.\\n\\n**Complexity**: even though for each call of `ping` function we can potentially call a lot of `popleft()`, if we run `ping` `n` times we will have `O(n)` complexity: each element go to queue and from queue only once, so we can say amortised time complexity is `O(1)`. Space complexity can be potentially `O(3000)`. \\n\\n```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.calls = deque()\\n\\n    def ping(self, t):\\n        self.calls.append(t)\\n        while self.calls[0] < self.calls[-1] - 3000:\\n            self.calls.popleft()\\n        return len(self.calls)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.calls = deque()\\n\\n    def ping(self, t):\\n        self.calls.append(t)\\n        while self.calls[0] < self.calls[-1] - 3000:\\n            self.calls.popleft()\\n        return len(self.calls)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322357,
                "title": "javascript-detailed-explanation-beats-99-76-o-n-time-o-n-space",
                "content": "Similar to the rate limiter question. Represent the calls at time T as a streaming array of integers using a queue.\\n1. For each call, add t to the end of the queue.\\n2. Maintain the queue so that the front is always within the time frame of t - 3000 (we trim the values that dont appear in this interval)\\n```\\nPing(1)\\nstream = [ 1 ] \\nPing(100)\\nstream = [ 1, 100 ] \\nping(3001)\\nstream = [ 1, 100, 3001 ]\\nping(3002)\\nstream = [ 100, 3001, 3002 ] \\nReturn the stream\\'s count after each call\\n```\\n```\\nvar RecentCounter = function() {\\n    this.stream = []\\n};\\nRecentCounter.prototype.ping = function(t) {\\n    this.stream.push(t) // Everytime we recieve a ping, add the time to the stream of integers\\n  /*\\n  To exclude the times that are not included within the range of t - 3000,\\n  we remove the first element from the stream while it is less than the calculated range \\n  */\\n    while(this.stream[0] < t - 3000){ \\n      this.stream.shift()\\n  } \\n    // When the loop ends the length of calls will be the length of the array\\n    return this.stream.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Queue"
                ],
                "code": "```\\nPing(1)\\nstream = [ 1 ] \\nPing(100)\\nstream = [ 1, 100 ] \\nping(3001)\\nstream = [ 1, 100, 3001 ]\\nping(3002)\\nstream = [ 100, 3001, 3002 ] \\nReturn the stream\\'s count after each call\\n```\n```\\nvar RecentCounter = function() {\\n    this.stream = []\\n};\\nRecentCounter.prototype.ping = function(t) {\\n    this.stream.push(t) // Everytime we recieve a ping, add the time to the stream of integers\\n  /*\\n  To exclude the times that are not included within the range of t - 3000,\\n  we remove the first element from the stream while it is less than the calculated range \\n  */\\n    while(this.stream[0] < t - 3000){ \\n      this.stream.shift()\\n  } \\n    // When the loop ends the length of calls will be the length of the array\\n    return this.stream.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594800,
                "title": "question-and-solution-both-clearly-explained",
                "content": "ok!\\nlets do this!\\nso this is one of the worst explained questions and solutions of leetcode!\\nlet me try and make it easy for you guys!!\\n\\nso what the basic idea of the question is that several ping times will be given and we have to return the number of \" valid \" pings!\\n\\ni describe \"valid\"  as follows:\\nsuppose i ping at t=3000 \\nlet t1=3000\\nthen i again ping at t=3001\\nlet t2=3001;\\n\\n**the constraint for a ping to be a \"valid\" ping is that \"t2-t1<=3000\"\\n\"i.e the difference of two ping times should not exceed 3000\"**\\n\\nso lets try the example in the question:\\nping times are[1,100,3001,30002]\\n\\nso lets say t1=0;(because t2==1 is the first ping,no pings are made befre t==1)\\nt2=1\\nsp t2-t1<=3000(validity condition met)\\nso for t==1 we output 1;\\n\\nthen t2=100\\nt1=1\\nsame thing\\nwe return the total number of valid pings ==2;\\n\\nfor t2=3001\\nwe have :\\nt1=100;\\nt2-t1<=3000(valid)\\nalso\\nt1=1\\nt2-t1<=3000(valid)\\nso both the pings before t=3001 are valid hence output =3;\\nNOW:\\nt2=3002;\\nwe have t1=3001;\\nt2-t1<=3000\\nso valid\\nt1=100\\nt2-t1<=3000\\nso valid\\nbut t1=1;\\nt2-t1=3001\\nwhich is not less than or equal to 3000!\\nso we dont count t==1;\\ntherefore valid pings for t=3002 are t1=100,3001,3002!\\n\\nhope i was able to explain!\\n\\ncode for reference:\\n```\\n\\nhope it helps\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    public RecentCounter() {\\n        q = new LinkedList();\\n    }\\n\\n    public int ping(int t) {\\n        q.add(t);\\n        while (q.peek() < t - 3000)\\n            q.poll();\\n        return q.size();\\n    }\\n}\\n```\\n\\nhope it helps!\\nthank you!\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nhope it helps\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    public RecentCounter() {\\n        q = new LinkedList();\\n    }\\n\\n    public int ping(int t) {\\n        q.add(t);\\n        while (q.peek() < t - 3000)\\n            q.poll();\\n        return q.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430731,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass RecentCounter {\\n\\tpublic:\\n\\t\\tRecentCounter() {\\n\\n\\t\\t}\\n\\n\\t\\tqueue<int> q;\\n\\n\\t\\tint ping(int t) {\\n\\n\\t\\t\\tq.push(t);\\n\\n\\t\\t\\twhile(q.front() < t - 3000){\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn q.size();\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "\\tclass RecentCounter {\\n\\tpublic:\\n\\t\\tRecentCounter() {\\n\\n\\t\\t}\\n\\n\\t\\tqueue<int> q;\\n\\n\\t\\tint ping(int t) {\\n\\n\\t\\t\\tq.push(t);\\n\\n\\t\\t\\twhile(q.front() < t - 3000){\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn q.size();\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "codeTag": "Java"
            },
            {
                "id": 873418,
                "title": "python-and-c-multiple-approaches-binary-search-dequeue",
                "content": "Python \\n```\\n# USING DEQUE\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        queue = self.queue\\n        start = t - 3000\\n        queue.append(t)\\n        while(queue and queue[0] < start):\\n            queue.popleft()\\n        return len(queue)\\n```\\n\\nC++\\n```\\n//USING DEQUE\\nclass RecentCounter {\\npublic:\\n    deque<int> dq;\\n    RecentCounter() {\\n        return ;\\n    }\\n    \\n    int ping(int t) {\\n        dq.push_back(t);\\n        while(!dq.empty() && dq.front()<t-3000)\\n            dq.pop_front();\\n        return dq.size();\\n    }\\n};\\n```\\n\\n\\nBINARY SEARCH APPROACH IN PYTHON\\n```\\n# USING BINARY SEARCH\\nclass RecentCounter:\\n    def __init__(self):\\n        self.arr = []\\n\\n    def ping(self, t: int) -> int:\\n        self.arr.append(t)\\n        start = t - 3000\\n        if(t<=0):\\n            return len(self.arr)\\n      # find t which is >= start in arr\\n        def binSearch(start,arr):\\n            i = 0\\n            j = len(arr)\\n            while(i<=j):\\n                mid = (i+j)//2\\n                if(arr[mid] > start):\\n                    j = mid - 1\\n                elif(arr[mid] < start):\\n                    i = mid + 1\\n                else:\\n                    return mid\\n            return i\\n        \\n        indx = binSearch(start,self.arr)\\n        return len(self.arr) - indx\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "C",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n# USING DEQUE\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        queue = self.queue\\n        start = t - 3000\\n        queue.append(t)\\n        while(queue and queue[0] < start):\\n            queue.popleft()\\n        return len(queue)\\n```\n```\\n//USING DEQUE\\nclass RecentCounter {\\npublic:\\n    deque<int> dq;\\n    RecentCounter() {\\n        return ;\\n    }\\n    \\n    int ping(int t) {\\n        dq.push_back(t);\\n        while(!dq.empty() && dq.front()<t-3000)\\n            dq.pop_front();\\n        return dq.size();\\n    }\\n};\\n```\n```\\n# USING BINARY SEARCH\\nclass RecentCounter:\\n    def __init__(self):\\n        self.arr = []\\n\\n    def ping(self, t: int) -> int:\\n        self.arr.append(t)\\n        start = t - 3000\\n        if(t<=0):\\n            return len(self.arr)\\n      # find t which is >= start in arr\\n        def binSearch(start,arr):\\n            i = 0\\n            j = len(arr)\\n            while(i<=j):\\n                mid = (i+j)//2\\n                if(arr[mid] > start):\\n                    j = mid - 1\\n                elif(arr[mid] < start):\\n                    i = mid + 1\\n                else:\\n                    return mid\\n            return i\\n        \\n        indx = binSearch(start,self.arr)\\n        return len(self.arr) - indx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189277,
                "title": "java-super-short-deque-solution",
                "content": "```\\n    Deque<Integer> dq;\\n\\n    public RecentCounter() {\\n        dq = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!dq.isEmpty() && t - dq.getFirst() > 3000) dq.removeFirst();\\n        dq.addLast(t);\\n        return dq.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    Deque<Integer> dq;\\n\\n    public RecentCounter() {\\n        dq = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!dq.isEmpty() && t - dq.getFirst() > 3000) dq.removeFirst();\\n        dq.addLast(t);\\n        return dq.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582485,
                "title": "c-code-most-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() { }\\n    \\n    int ping(int t) {\\n        int st=t-3000,c=0;\\n        q.push(t);\\n\\n        while(!q.empty() ){\\n            if(q.front() <st )\\n            q.pop();\\n            else\\n            break;\\n        }\\n\\n        return q.size();\\n\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Design",
                    "Queue",
                    "Data Stream"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() { }\\n    \\n    int ping(int t) {\\n        int st=t-3000,c=0;\\n        q.push(t);\\n\\n        while(!q.empty() ){\\n            if(q.front() <st )\\n            q.pop();\\n            else\\n            break;\\n        }\\n\\n        return q.size();\\n\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984449,
                "title": "java-queue",
                "content": "\\n\\n# Code\\n```\\nclass RecentCounter {\\n      Queue<Integer> q;\\n    public RecentCounter() {\\n        q= new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n        while(q.peek()<t-3000){\\n            q.poll();\\n        }\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n      Queue<Integer> q;\\n    public RecentCounter() {\\n        q= new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n        while(q.peek()<t-3000){\\n            q.poll();\\n        }\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873209,
                "title": "python-super-simple-and-short-solution-o-1-time-o-1-space",
                "content": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.recent = []\\n\\n    def ping(self, t: int) -> int:\\n        self.recent.append(t)\\n        while self.recent[0] < t-3000:\\n            self.recent.pop(0)\\n        return len(self.recent)\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.recent = []\\n\\n    def ping(self, t: int) -> int:\\n        self.recent.append(t)\\n        while self.recent[0] < t-3000:\\n            self.recent.pop(0)\\n        return len(self.recent)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826041,
                "title": "python-3-88-08-faster-used-list-as-queue",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nWe can use list as a queue or use collections.deque.\\ncollections.deque has a function popleft() to remove first element. Since it\\'s not available in list, we can pass index 0 to pop()\\n\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and self.queue[0] + 3000 < t:\\n            self.queue.pop(0)\\n        self.queue.append(t)\\n        return len(self.queue)\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and self.queue[0] + 3000 < t:\\n            self.queue.pop(0)\\n        self.queue.append(t)\\n        return len(self.queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506905,
                "title": "c-simple-solution-using-queue",
                "content": "```\\npublic class RecentCounter {\\n    private Queue<int> _queue;\\n    private const int Interval = 3000;\\n\\n    public RecentCounter() {\\n        _queue = new Queue<int>();\\n    }\\n    \\n    public int Ping(int t) {\\n        _queue.Enqueue(t);\\n        while (t - _queue.Peek() > Interval)\\n            _queue.Dequeue();\\n        return _queue.Count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Queue"
                ],
                "code": "```\\npublic class RecentCounter {\\n    private Queue<int> _queue;\\n    private const int Interval = 3000;\\n\\n    public RecentCounter() {\\n        _queue = new Queue<int>();\\n    }\\n    \\n    public int Ping(int t) {\\n        _queue.Enqueue(t);\\n        while (t - _queue.Peek() > Interval)\\n            _queue.Dequeue();\\n        return _queue.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269419,
                "title": "python",
                "content": "class RecentCounter(object):\\n\\n    def __init__(self):\\n        \\n        # \\u7528\\u961F\\u5217\\u601D\\u60F3\\uFF0C\\u5DE6\\u8FB9\\u51FA\\uFF0C\\u53F3\\u8FB9\\u8FDB\\n        self.queue = collections.deque()\\n        \\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        \\n        # given a time t, time t-3000 \\u4E3A 3000 \\u6BEB\\u79D2\\u4E4B\\u524D\\u7684\\u65F6\\u95F4\\u70B9\\uFF0C\\u4EFB\\u4F55\\u5C0F\\u4E8E\\u90A3\\u4E2A\\u65F6\\u95F4\\u70B9\\u7684\\u65F6\\u95F4\\u7684\\u90FD\\u4F1A\\u88AB\\u820D\\u5F03\\uFF0C \\u4ECE\\u5DE6\\u8FB9\\u51FA\\u961F\\u5217\\n        while self.queue and self.queue[0] < t-3000:\\n            self.queue.popleft()\\n            \\n        # \\u628A t \\u52A0\\u5165\\u961F\\u5217\\n        self.queue.append(t)\\n        \\n        # \\u8FD4\\u56DE\\u961F\\u5217\\u7684\\u957F\\u5EA6\\uFF0C\\u5C31\\u662F\\u961F\\u5217\\u4E2Dt\\u4EE5\\u53CAt3000\\u79D2\\u4E4B\\u524D\\u65F6\\u95F4\\u7684\\u603B\\u4E2A\\u6570\\n        return len(self.queue)\\n        \\n\\n",
                "solutionTags": [],
                "code": "class RecentCounter(object):\\n\\n    def __init__(self):\\n        \\n        # \\u7528\\u961F\\u5217\\u601D\\u60F3\\uFF0C\\u5DE6\\u8FB9\\u51FA\\uFF0C\\u53F3\\u8FB9\\u8FDB\\n        self.queue = collections.deque()\\n        \\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        \\n        # given a time t, time t-3000 \\u4E3A 3000 \\u6BEB\\u79D2\\u4E4B\\u524D\\u7684\\u65F6\\u95F4\\u70B9\\uFF0C\\u4EFB\\u4F55\\u5C0F\\u4E8E\\u90A3\\u4E2A\\u65F6\\u95F4\\u70B9\\u7684\\u65F6\\u95F4\\u7684\\u90FD\\u4F1A\\u88AB\\u820D\\u5F03\\uFF0C \\u4ECE\\u5DE6\\u8FB9\\u51FA\\u961F\\u5217\\n        while self.queue and self.queue[0] < t-3000:\\n            self.queue.popleft()\\n            \\n        # \\u628A t \\u52A0\\u5165\\u961F\\u5217\\n        self.queue.append(t)\\n        \\n        # \\u8FD4\\u56DE\\u961F\\u5217\\u7684\\u957F\\u5EA6\\uFF0C\\u5C31\\u662F\\u961F\\u5217\\u4E2Dt\\u4EE5\\u53CAt3000\\u79D2\\u4E4B\\u524D\\u65F6\\u95F4\\u7684\\u603B\\u4E2A\\u6570\\n        return len(self.queue)\\n        \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3834769,
                "title": "easy-3000-milliseconds",
                "content": "# Intuition\\nThe task requires us to count the number of recent requests within a certain time frame. The first intuition is to keep track of the requests as they come in. However, we only care about the requests that happened in the last 3000 milliseconds. This suggests that we should remove old requests that are no longer within this time frame. A queue data structure is ideal for this because it allows us to easily add new requests at the end and remove old requests from the front.\\n\\n# Approach\\nOur approach is to use a deque (double-ended queue) data structure to store the times of the requests. Each time the \\'ping\\' method is called, we add the new time at the end of the deque. We then remove all times at the front of the deque that are less than \\'t - 3000\\'. The remaining times in the deque are the requests that happened within the last 3000 milliseconds. To get the number of these requests, we simply return the length of the deque.\\n\\n# Complexity\\n- Time complexity: The time complexity of the \\'ping\\' operation is \\\\( O(1) \\\\). Each \\'ping\\' call results in a constant number of operations, which does not depend on the size of \\'t\\' or the number of requests.\\n\\n- Space complexity: The space complexity is \\\\( O(N) \\\\), where \\\\( N \\\\) is the maximum number of \\'pings\\' within a 3000 millisecond time frame. This is because all these \\'pings\\' could potentially be stored in the deque at the same time.\\n\\n# Code\\n```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = deque() \\n    def ping(self, t: int) -> int:\\n        self.queue.append(t) \\n        while self.queue[0] < t - 3000: \\n            self.queue.popleft() \\n        return len(self.queue)                           \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = deque() \\n    def ping(self, t: int) -> int:\\n        self.queue.append(t) \\n        while self.queue[0] < t - 3000: \\n            self.queue.popleft() \\n        return len(self.queue)                           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568692,
                "title": "beating-99-34-python-easiest-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/0fcc35b3-81ce-40f3-9246-62cf557178cd_1685203647.425843.png)\\n\\n\\n# Code\\n```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = deque()\\n        \\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while t - self.q[0] > 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n        \\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = deque()\\n        \\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while t - self.q[0] > 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n        \\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873862,
                "title": "number-of-recent-calls-java",
                "content": "```\\nclass RecentCounter \\n{\\n    /* This is a really straight foreword implementation.  Instantiate a queue.  On each call to ping \\n     * add the new value to the tail of the queue and then eat the values which have timed out (i.e. \\n     * values below t - 3000) from the head of the queue.  Once the queue holds the right data set \\n     * just return it\\'s size.  My guess is most people will do something similar.\\n     *\\n\\t * n.b.  By adding t to the queue first you\\'ll always be assured of having an item which will \\n\\t * cause the while loop to terminate and won\\'t need to do a null check.\\n     */\\n    \\n    private Queue<Integer>      q = new LinkedList<Integer>();\\n\\n    public RecentCounter() {}\\n    \\n    public int ping(int t) \\n    {\\n        q.add( t );\\n        \\n        while( q.peek() < t - 3000 )\\n        {\\n            q.poll();\\n        }\\n        \\n        return q.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter \\n{\\n    /* This is a really straight foreword implementation.  Instantiate a queue.  On each call to ping \\n     * add the new value to the tail of the queue and then eat the values which have timed out (i.e. \\n     * values below t - 3000) from the head of the queue.  Once the queue holds the right data set \\n     * just return it\\'s size.  My guess is most people will do something similar.\\n     *\\n\\t * n.b.  By adding t to the queue first you\\'ll always be assured of having an item which will \\n\\t * cause the while loop to terminate and won\\'t need to do a null check.\\n     */\\n    \\n    private Queue<Integer>      q = new LinkedList<Integer>();\\n\\n    public RecentCounter() {}\\n    \\n    public int ping(int t) \\n    {\\n        q.add( t );\\n        \\n        while( q.peek() < t - 3000 )\\n        {\\n            q.poll();\\n        }\\n        \\n        return q.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405318,
                "title": "python-solution-using-deque-queue",
                "content": "This is a good example of using deque (double-ended queue) data structure. deque is implemented in Python using doubly-linked list. As a result, it has much better performance compared to Python list for push/pop in both ends, and much worse when it comes to indexing. A few obvious differences between deque and list:\\n1) deque doesn\\'t support slicing;\\n2) deque has a few extra methods on the left side including appendleft(), extendleft() and popleft();\\n3) deque doesn\\'t have a sort() method. \\n\\n```\\nfrom collections import deque \\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n\\t\\t#append first, no need to check empty deque\\n        self.queue.append(t) \\n        while self.queue[0] < t - 3000: self.queue.popleft()\\n        return len(self.queue)\\n```\\nUsing Python list is also possible, but it takes longer to run. \\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while self.queue[0] < t - 3000:\\n            self.queue.pop(0)\\n        return len(self.queue)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque \\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n\\t\\t#append first, no need to check empty deque\\n        self.queue.append(t) \\n        while self.queue[0] < t - 3000: self.queue.popleft()\\n        return len(self.queue)\\n```\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while self.queue[0] < t - 3000:\\n            self.queue.pop(0)\\n        return len(self.queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675606,
                "title": "python-99-5-solution-queue-4-lines",
                "content": "Basically, we don\\'t care about the ping that last for more than 3000 seconds. So just pop it out of the queue.\\n```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while t - self.q[0] > 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n        \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "Basically, we don\\'t care about the ping that last for more than 3000 seconds. So just pop it out of the queue.\\n```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while t - self.q[0] > 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n        \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)",
                "codeTag": "Java"
            },
            {
                "id": 1654544,
                "title": "java-solution-number-of-recent-calls-using-queue",
                "content": "Java Solution:\\n```\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    int min;\\n    public RecentCounter() {\\n        q = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {        \\n        q.offer(t);\\n        min = t-3000;       \\n        while(min>q.peek()){\\n            q.poll();\\n        }\\n        return q.size();        \\n    }\\n}\\n```\\nFeel free to upvote if you like this Solution.\\nHappy Coding!!!\\n[Twitter](https://twitter.com/rohit_mittal17)\\n[GitHub](https://github.com/rohitm17)\\n[Medium](https://medium.com/@rohitm17)",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    int min;\\n    public RecentCounter() {\\n        q = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {        \\n        q.offer(t);\\n        min = t-3000;       \\n        while(min>q.peek()){\\n            q.poll();\\n        }\\n        return q.size();        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873283,
                "title": "number-of-recent-calls-python-98-using-queue",
                "content": "```\\ncompare least recent calls to t-3000, if less then pop calls\\ndeque over list because popleft() is O(1) time over list pop(0) O(n) time\\n```\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        while self.q[0] < t - 3000:\\n            self.q.popleft()\\n        return len(self.q)\\n```",
                "solutionTags": [],
                "code": "```\\ncompare least recent calls to t-3000, if less then pop calls\\ndeque over list because popleft() is O(1) time over list pop(0) O(n) time\\n```\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        while self.q[0] < t - 3000:\\n            self.q.popleft()\\n        return len(self.q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873253,
                "title": "number-of-recent-calls-c-using-queue-98",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        \\n        q.push(t);\\n        int start=t-3000;\\n        int end=t;\\n        while(q.front()<start){\\n            q.pop();\\n        }\\n        return q.size(); \\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        \\n        q.push(t);\\n        int start=t-3000;\\n        int end=t;\\n        while(q.front()<start){\\n            q.pop();\\n        }\\n        return q.size(); \\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492668,
                "title": "intuitive-javascript-solution",
                "content": "```\\n\\nvar RecentCounter = function() {\\n    this.queue = [];\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n    this.queue.push(t);\\n    // keep pings within 3000 from the latest ping \\n    while(this.queue[0] < t - 3000) {\\n        this.queue.shift();\\n    }\\n    return this.queue.length;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Queue"
                ],
                "code": "```\\n\\nvar RecentCounter = function() {\\n    this.queue = [];\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n    this.queue.push(t);\\n    // keep pings within 3000 from the latest ping \\n    while(this.queue[0] < t - 3000) {\\n        this.queue.shift();\\n    }\\n    return this.queue.length;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3118441,
                "title": "python-simple-queue-solution-beats-97",
                "content": "# Code\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.s = []\\n\\n    def ping(self, t: int) -> int:\\n        while self.s and t - self.s[0] > 3000:\\n            self.s.pop(0)  # remove 1st el if it\\'s 3000+ away from t\\n        self.s.append(t)\\n        return len(self.s) \\n\\n```\\n\\nupdate:\\n![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-04-03 \\u0432 13.55.16.png](https://assets.leetcode.com/users/images/5d6980a6-d23c-483e-8ce1-b6ab49b2860a_1680519361.3573725.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.s = []\\n\\n    def ping(self, t: int) -> int:\\n        while self.s and t - self.s[0] > 3000:\\n            self.s.pop(0)  # remove 1st el if it\\'s 3000+ away from t\\n        self.s.append(t)\\n        return len(self.s) \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178137,
                "title": "java-smaller-queue-solution",
                "content": "# Please Upvote If You Find This Helpful\\n```\\nclass RecentCounter {\\n    private Queue<Integer> queue;\\n    public RecentCounter() {\\n        this.queue = new ArrayDeque<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.peek() < t - 3000) queue.remove();\\n        return queue.size();\\n    }\\n}\\n```\\n# Please Upvote If You Find This Helpful",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    private Queue<Integer> queue;\\n    public RecentCounter() {\\n        this.queue = new ArrayDeque<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.peek() < t - 3000) queue.remove();\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880478,
                "title": "python-binary-search-solution",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self): \\n        self.requests = []\\n\\n    def ping(self, t: int) -> int:\\n        self.requests.append(t)\\n        left = 0\\n        right = len(self.requests)\\n        \\n        while left < right:\\n            mid = int((left + right) / 2)\\n            if self.requests[mid] >= (self.requests[-1] - 3000):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return len(self.requests) - left\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self): \\n        self.requests = []\\n\\n    def ping(self, t: int) -> int:\\n        self.requests.append(t)\\n        left = 0\\n        right = len(self.requests)\\n        \\n        while left < right:\\n            mid = int((left + right) / 2)\\n            if self.requests[mid] >= (self.requests[-1] - 3000):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return len(self.requests) - left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875210,
                "title": "easiest-possible-explanation-using-min-heap",
                "content": "```\\nclass RecentCounter {\\n    PriorityQueue<Integer> pq;\\n    public RecentCounter() {\\n        pq = new PriorityQueue<>((a,b)-> a-b);\\n    }\\n    \\n    public int ping(int t) {\\n        if(!pq.isEmpty()){\\n            int min = t-3000;\\n\\t\\t\\t//recursively pop elements from top of MinHeap till top element is greater than t-3000\\n            while(!pq.isEmpty() && pq.peek() < min){\\n                pq.poll();\\n            }\\n        }\\n        pq.offer(t);\\n        return pq.size();\\n    }\\n}\\n```\\n\\nThe idea above is to somehow store t values, from current_time to current_time - 3000.\\nHow can we achieve that, one of the easiset ways is to use Min Heap, so that the mimimum element is stored at top/root.\\nEach time we get a ping, we check the current top/root, if its lesser than remove elements from Min Heap recursively till top/root is greater than current_time-3000.\\nThis way at any point of time we just have the required elements in the min-heap.\\n\\nTime complexity: O(n * log(n)) Each insert, and reordering after poll takes O(log(n)) time, but while trying to empty the minheap recursively we might have to do it for n elements, hence n * log(n)\\nSpace Complexity: O(n)",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass RecentCounter {\\n    PriorityQueue<Integer> pq;\\n    public RecentCounter() {\\n        pq = new PriorityQueue<>((a,b)-> a-b);\\n    }\\n    \\n    public int ping(int t) {\\n        if(!pq.isEmpty()){\\n            int min = t-3000;\\n\\t\\t\\t//recursively pop elements from top of MinHeap till top element is greater than t-3000\\n            while(!pq.isEmpty() && pq.peek() < min){\\n                pq.poll();\\n            }\\n        }\\n        pq.offer(t);\\n        return pq.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874696,
                "title": "just-another-c-solution-using-bitset-no-queues",
                "content": "I assume everyone understand the queue solution. With this post I just want to show that `there are always other possibilities`\\n\\nSo we want to record all the time points in the past 3001 ms. Instead of using a vector, which is very inefficient when moving its elements, we use a bitset.\\nWhen a new call comes in, all we need to do is shift all the bits to the left by `this time - previous time`, and mark the right most bit `1`, then return the number of 1 bits.\\n\\nFurther thoughts: if the time range goes very huge, the shift operation may become slow. However, it still beats the queue method on memory usage, and runs within reasonable time frame.\\n(I tried to set the time range to 1,000,000,000 instead of 3000, it still runs. The queue method may be faster _some times_, but it is just unrealistic for the queue to hold that many of nodes)\\n\\n```cpp\\nclass RecentCounter {\\npublic:\\n    RecentCounter() : m_calls(0), m_last(0) {\\n    }\\n    \\n    int ping(int t) {\\n        m_calls <<= t - m_last;\\n        m_calls.set(0);\\n        m_last = t;\\n        return m_calls.count();\\n    }\\n    \\nprivate:\\n    bitset<3001> m_calls;\\n    int m_last; // time of previous ping()\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass RecentCounter {\\npublic:\\n    RecentCounter() : m_calls(0), m_last(0) {\\n    }\\n    \\n    int ping(int t) {\\n        m_calls <<= t - m_last;\\n        m_calls.set(0);\\n        m_last = t;\\n        return m_calls.count();\\n    }\\n    \\nprivate:\\n    bitset<3001> m_calls;\\n    int m_last; // time of previous ping()\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873222,
                "title": "c-super-simple-easy-and-short-solution-o-1-time-space",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        calls.push_back(t);\\n        while (calls[0] < t - 3000)\\n            calls.erase(calls.begin());\\n        return calls.size();\\n    }\\n    \\nprivate:\\n    vector<int> calls;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        calls.push_back(t);\\n        while (calls[0] < t - 3000)\\n            calls.erase(calls.begin());\\n        return calls.size();\\n    }\\n    \\nprivate:\\n    vector<int> calls;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726473,
                "title": "go",
                "content": "Slice (as queue) implementation: (Ping() is O(N))\\n```\\ntype RecentCounter struct {\\n    q []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{[]int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.q = append(this.q, t)\\n    for i, val := range this.q {\\n        if val >= t - 3000 {\\n            this.q = this.q[i:]\\n            break\\n        }\\n    }\\n    return len(this.q)\\n}\\n```\\n\\nBinary Search: (Ping() is O(logN))\\n```\\ntype RecentCounter struct {\\n    a []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{[]int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.a = append(this.a, t)\\n    \\n    idx := binarySearch(this.a, t - 3000)\\n    \\n    return len(this.a) - idx\\n}\\n\\nfunc binarySearch(arr []int, target int) int {\\n    lo, hi := 0, len(arr)-1\\n    \\n    for lo <= hi {\\n        mid := (lo + hi) / 2\\n        if arr[mid] > target {\\n            hi = mid - 1\\n        } else if arr[mid] < target {\\n            lo = mid + 1\\n        } else {\\n            return mid\\n        }\\n    }\\n    \\n    return lo\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype RecentCounter struct {\\n    q []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{[]int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.q = append(this.q, t)\\n    for i, val := range this.q {\\n        if val >= t - 3000 {\\n            this.q = this.q[i:]\\n            break\\n        }\\n    }\\n    return len(this.q)\\n}\\n```\n```\\ntype RecentCounter struct {\\n    a []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{[]int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.a = append(this.a, t)\\n    \\n    idx := binarySearch(this.a, t - 3000)\\n    \\n    return len(this.a) - idx\\n}\\n\\nfunc binarySearch(arr []int, target int) int {\\n    lo, hi := 0, len(arr)-1\\n    \\n    for lo <= hi {\\n        mid := (lo + hi) / 2\\n        if arr[mid] > target {\\n            hi = mid - 1\\n        } else if arr[mid] < target {\\n            lo = mid + 1\\n        } else {\\n            return mid\\n        }\\n    }\\n    \\n    return lo\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 490723,
                "title": "rust-24-ms",
                "content": "```\\nuse std::borrow::BorrowMut;\\nuse std::collections::VecDeque;\\n\\nstruct RecentCounter {\\n    queue: VecDeque<i32>,\\n}\\n\\nimpl RecentCounter {\\n    fn new() -> Self {\\n        RecentCounter {\\n            queue: VecDeque::new(),\\n        }\\n    }\\n\\n    fn ping(&mut self, t: i32) -> i32 {\\n        let q = self.queue.borrow_mut();\\n        q.push_back(t);\\n        while let Some(value) = q.front() {\\n            if *value < t - 3000 {\\n                q.pop_front();\\n            } else {\\n                break;\\n            }\\n        }\\n        q.len() as i32\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nuse std::borrow::BorrowMut;\\nuse std::collections::VecDeque;\\n\\nstruct RecentCounter {\\n    queue: VecDeque<i32>,\\n}\\n\\nimpl RecentCounter {\\n    fn new() -> Self {\\n        RecentCounter {\\n            queue: VecDeque::new(),\\n        }\\n    }\\n\\n    fn ping(&mut self, t: i32) -> i32 {\\n        let q = self.queue.borrow_mut();\\n        q.push_back(t);\\n        while let Some(value) = q.front() {\\n            if *value < t - 3000 {\\n                q.pop_front();\\n            } else {\\n                break;\\n            }\\n        }\\n        q.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419958,
                "title": "simple-java-solution-w-queue-comments",
                "content": "```java\\nclass RecentCounter {\\n    \\n    //primary data structure\\n    Queue<Integer> queue;\\n\\n    public RecentCounter() {\\n        //initialize our queue\\n        queue = new LinkedList();\\n    }\\n    \\n    public int ping(int t) {\\n        //add current ping to queue\\n        queue.offer(t);\\n        \\n        //keep removing from queue while more than 3000ms ago\\n        while (!queue.isEmpty() && t - queue.peek() > 3000) {\\n            //pop first in queue\\n            queue.poll();\\n        }\\n        \\n        //just return size of our queue (every ping here is within 3000 ms)\\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```java\\nclass RecentCounter {\\n    \\n    //primary data structure\\n    Queue<Integer> queue;\\n\\n    public RecentCounter() {\\n        //initialize our queue\\n        queue = new LinkedList();\\n    }\\n    \\n    public int ping(int t) {\\n        //add current ping to queue\\n        queue.offer(t);\\n        \\n        //keep removing from queue while more than 3000ms ago\\n        while (!queue.isEmpty() && t - queue.peek() > 3000) {\\n            //pop first in queue\\n            queue.poll();\\n        }\\n        \\n        //just return size of our queue (every ping here is within 3000 ms)\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189291,
                "title": "simple-javascript-solution-3-lines",
                "content": "```\\n\\nvar RecentCounter = function() {\\n    this.queue = [];\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n   this.queue.push(t);\\n    while(this.queue.length && this.queue[0] < t-3000) {\\n        this.queue.shift();\\n    }\\n    return this.queue.length;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = Object.create(RecentCounter).createNew()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvar RecentCounter = function() {\\n    this.queue = [];\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n   this.queue.push(t);\\n    while(this.queue.length && this.queue[0] < t-3000) {\\n        this.queue.shift();\\n    }\\n    return this.queue.length;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = Object.create(RecentCounter).createNew()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749681,
                "title": "c-very-simple-queue",
                "content": "# Code\\n```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        int limit = t - 3000;\\n        Q.push(t);\\n        while (Q.front() < limit) Q.pop();\\n        return Q.size();\\n    }\\n\\nprivate:\\n    queue<int> Q;\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        int limit = t - 3000;\\n        Q.push(t);\\n        while (Q.front() < limit) Q.pop();\\n        return Q.size();\\n    }\\n\\nprivate:\\n    queue<int> Q;\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2432422,
                "title": "kotlin-style-short-solution",
                "content": "```\\nclass RecentCounter() {\\n\\n    val list = mutableListOf<Int>()\\n\\n    fun ping(t: Int): Int {\\n        list.add(t)\\n        return list.count { it in t - 3000..t }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass RecentCounter() {\\n\\n    val list = mutableListOf<Int>()\\n\\n    fun ping(t: Int): Int {\\n        list.add(t)\\n        return list.count { it in t - 3000..t }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126484,
                "title": "c-solution-using-only-one-queue-short-simple",
                "content": "**Code:**\\n\\n```\\nclass RecentCounter\\n{\\npublic:\\n    queue<int> q;\\n\\n    RecentCounter()\\n    {\\n    }\\n\\n    int ping(int t)\\n    {\\n        q.push(t);\\n        while (q.front() < t - 3000)\\n        {\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter\\n{\\npublic:\\n    queue<int> q;\\n\\n    RecentCounter()\\n    {\\n    }\\n\\n    int ping(int t)\\n    {\\n        q.push(t);\\n        while (q.front() < t - 3000)\\n        {\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1316432,
                "title": "smallest-solution-in-c-ever-with-funny-explaination-3-line-code",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    priority_queue<int, vector<int>,greater<int>> res;\\n    RecentCounter() {}    //vella Constructor \\n    int ping(int t) {\\n        res.push(t);\\n        while(t-res.top() >3000)   res.pop();    //Coz difference cant be greater than 3000  \\n        return res.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    priority_queue<int, vector<int>,greater<int>> res;\\n    RecentCounter() {}    //vella Constructor \\n    int ping(int t) {\\n        res.push(t);\\n        while(t-res.top() >3000)   res.pop();    //Coz difference cant be greater than 3000  \\n        return res.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013108,
                "title": "c-simple-4-line-solution-faster-than-100-with-queue",
                "content": "Just four lines are needed for `ping`, and the constructor is not needed at all: On every call, add the current time `t` and remove all times greater smaller than `t-3000` from the back of the queue.\\n\\n```\\nclass RecentCounter {\\n    queue<int> recents;\\npublic:\\n    int ping(int t) {\\n        recents.push(t);\\n        while(recents.front() < (t - 3000))\\n            recents.pop();\\n        return recents.size();\\n    }\\n};\\n```\\n\\nFast and low memory:\\n![image](https://assets.leetcode.com/users/images/bd1c96b7-c355-4c96-a0f5-4d4395efdc3c_1610455821.3957345.png)\\n",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    queue<int> recents;\\npublic:\\n    int ping(int t) {\\n        recents.push(t);\\n        while(recents.front() < (t - 3000))\\n            recents.pop();\\n        return recents.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874262,
                "title": "c-2-pointers-binary-search-solution-explained-100-time-new-record-10-memory",
                "content": "As usual, I decided to sacrifice as much as possible in order to gain top speed.\\n\\nTo do so, I eschewed having any constructor and instead just set 3 class variables:\\n* `store`, an array of `10000` ints;\\n* `last` and `first`, to keep track of how extended is our window of elements, both initialised to `0`.\\n\\ni then put all the logic just in `ping`:\\n* every new element `t` is added to `store` in the `last` position, increasing `last` with the postfix operator;\\n* `first` is updated doing a binary search on the `first - last` range for any value smaller than `t - 3000`, as per specs;\\n* we return `last - first` and we are done :)\\n\\nThe code:\\n\\n```cpp\\nclass RecentCounter {\\npublic:\\n    int store[10000], last = 0, first = 0;    \\n    int ping(int t) {\\n        store[last++] = t;\\n        first = lower_bound(store + first, store + last, t - 3000) - store;\\n        return last - first;\\n    }\\n};\\n```\\n\\nThe brag:\\n![image](https://assets.leetcode.com/users/images/176d0720-7a6b-482d-bf9e-e731b730dd4a_1601588934.2631395.png)\\n\\nThe further brag:\\n![image](https://assets.leetcode.com/users/images/558b0b42-9992-49f3-ae42-1481013f6dfa_1601589054.0014238.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass RecentCounter {\\npublic:\\n    int store[10000], last = 0, first = 0;    \\n    int ping(int t) {\\n        store[last++] = t;\\n        first = lower_bound(store + first, store + last, t - 3000) - store;\\n        return last - first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873463,
                "title": "easy-python-3-solution-beginner-friendly",
                "content": "class RecentCounter:\\n\\n    def __init__(self):\\n\\t\\t#a list to store the request calls\\n        self.req=[]\\n    def ping(self, t: int) -> int:\\n        self.req.append(t)\\n\\t\\t#loop to pop out the requests which are out of time range of 300 milisecond\\n        while self.req[0]<t-3000:\\n            self.req.pop(0)\\n        return len(self.req)\\n        \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)``",
                "solutionTags": [],
                "code": "class RecentCounter:\\n\\n    def __init__(self):\\n\\t\\t#a list to store the request calls\\n        self.req=[]\\n    def ping(self, t: int) -> int:\\n        self.req.append(t)\\n\\t\\t#loop to pop out the requests which are out of time range of 300 milisecond\\n        while self.req[0]<t-3000:\\n            self.req.pop(0)\\n        return len(self.req)\\n        \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)``",
                "codeTag": "Java"
            },
            {
                "id": 743058,
                "title": "in-rust",
                "content": "```\\nstruct RecentCounter {\\n    pings: Vec<i32>\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl RecentCounter {\\n\\n    fn new() -> Self {\\n        RecentCounter { pings: vec!() }\\n    }\\n    \\n    fn ping(&mut self, t: i32) -> i32 {\\n        self.pings.push(t);\\n        return match self.pings.binary_search(&(t - 3000)) {\\n            Ok(i) => (self.pings.len() - i) as i32,\\n            Err(i) => (self.pings.len() - i) as i32,\\n        };\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * let obj = RecentCounter::new();\\n * let ret_1: i32 = obj.ping(t);\\n */\\n ```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct RecentCounter {\\n    pings: Vec<i32>\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl RecentCounter {\\n\\n    fn new() -> Self {\\n        RecentCounter { pings: vec!() }\\n    }\\n    \\n    fn ping(&mut self, t: i32) -> i32 {\\n        self.pings.push(t);\\n        return match self.pings.binary_search(&(t - 3000)) {\\n            Ok(i) => (self.pings.len() - i) as i32,\\n            Err(i) => (self.pings.len() - i) as i32,\\n        };\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * let obj = RecentCounter::new();\\n * let ret_1: i32 = obj.ping(t);\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 636175,
                "title": "python-simple-solution-quick-explanation",
                "content": "**Quick Explanation of the Question:**\\n\\nThis question could probably be written a little more clearly so I will leave a few lines here for those who may find it helpful.  The question is saying that it will do the following:\\n\\n    In [1]: temp = RecentCounter()\\n\\tIn [2]: temp.ping(1)\\n\\tIn [3]: temp.ping(100)\\n\\tIn [4]: temp.ping(3001)\\n\\tIn [5]: temp.ping(3002)\\n\\nEverytime it calls ping, you get an input value t (the time that has elapsed since temp was created).  Your job is to return how many ping times there are between the given t and t - 3000 ms inclusive.  \\n\\t\\n\\n**Solution:**\\n\\nStore all times in a doubly ended queue (deque) so that new times can be appended to the end of the queue and removed from the beginning of the queue in constant time.  \\n\\nThe former to append the current time (t) every time ping is called.  \\n\\nThe latter to remove times less than t-3000 ms before calculating the result.\\n\\n```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.count=0\\n        self.times = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.times.append(t)\\n        while self.times[0] < t-3000:\\n            self.times.popleft()\\n        return len(self.times)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.count=0\\n        self.times = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.times.append(t)\\n        while self.times[0] < t-3000:\\n            self.times.popleft()\\n        return len(self.times)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239143,
                "title": "c-solution",
                "content": "```\\n#define MAX_SIZE 10000\\n\\ntypedef struct {\\n    int* pingHistory;\\n    int head;\\n    int tail; \\n} RecentCounter;\\n\\nRecentCounter* recentCounterCreate() {\\n    RecentCounter* obj = malloc(sizeof(RecentCounter));\\n    obj -> pingHistory = calloc(10000, sizeof(int));\\n    obj -> head = 0;\\n    obj -> tail = 0;\\n    return obj;\\n}\\n\\nint recentCounterPing(RecentCounter* obj, int t) {\\n    obj -> pingHistory[obj->head++] = t;\\n    \\n    for(; obj->tail < obj -> head; obj->tail++)\\n    {\\n        if((t-3000) <= obj -> pingHistory[obj->tail])\\n        {\\n            break;\\n        }\\n    }\\n    return obj->head-obj->tail;\\n}\\n\\nvoid recentCounterFree(RecentCounter* obj) {\\n    free(obj->pingHistory);\\n    free(obj);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define MAX_SIZE 10000\\n\\ntypedef struct {\\n    int* pingHistory;\\n    int head;\\n    int tail; \\n} RecentCounter;\\n\\nRecentCounter* recentCounterCreate() {\\n    RecentCounter* obj = malloc(sizeof(RecentCounter));\\n    obj -> pingHistory = calloc(10000, sizeof(int));\\n    obj -> head = 0;\\n    obj -> tail = 0;\\n    return obj;\\n}\\n\\nint recentCounterPing(RecentCounter* obj, int t) {\\n    obj -> pingHistory[obj->head++] = t;\\n    \\n    for(; obj->tail < obj -> head; obj->tail++)\\n    {\\n        if((t-3000) <= obj -> pingHistory[obj->tail])\\n        {\\n            break;\\n        }\\n    }\\n    return obj->head-obj->tail;\\n}\\n\\nvoid recentCounterFree(RecentCounter* obj) {\\n    free(obj->pingHistory);\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4038917,
                "title": "go-solution-easy-explanation-o-n-time-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe maintain a queue of timestamps for incoming requests. When a new request comes in, we add its timestamp to the queue. We then remove timestamps from the front of the queue that are outside the 3000 milliseconds window. The length of the queue at any point represents the number of requests within the window.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We use a queue (implemented as a slice) to store timestamps.\\n2. In the Ping method, we append the current timestamp to the queue.\\n3. We iterate through the front of the queue and remove timestamps that are older than t - 3000.\\n4. The length of the queue represents the number of requests within the window.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    - The Constructor method has a time complexity of O(1).\\n    - The Ping method has a time complexity of O(N), where N is the number of requests within the 3000 milliseconds window. In practice, N is bounded by the number of calls to Ping.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    - The space complexity is O(N), where N is the number of requests within the 3000 milliseconds window.\\n\\n# Code\\n```\\ntype RecentCounter struct {\\n    requests []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    // Add the current timestamp to the queue\\n    this.requests = append(this.requests, t)\\n    \\n    // Remove timestamps that are outside the 3000 milliseconds window\\n    for this.requests[0] < t-3000 {\\n        this.requests = this.requests[1:]\\n    }\\n    \\n    // Return the number of requests within the window\\n    return len(this.requests)\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * obj := Constructor();\\n * param_1 := obj.Ping(t);\\n */\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype RecentCounter struct {\\n    requests []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    // Add the current timestamp to the queue\\n    this.requests = append(this.requests, t)\\n    \\n    // Remove timestamps that are outside the 3000 milliseconds window\\n    for this.requests[0] < t-3000 {\\n        this.requests = this.requests[1:]\\n    }\\n    \\n    // Return the number of requests within the window\\n    return len(this.requests)\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * obj := Constructor();\\n * param_1 := obj.Ping(t);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3965562,
                "title": "19ms-beats-81-34-of-users-with-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNo Need to use array or arraylist.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe just have to add new entry and check from start if any out of range element is there ? then pop it until whole queue is in range . then return queue size. It\\'s simple , In ArrayList we have to traverse it in every function call but here we are just traversing only that much which is needed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\n\\n    Queue<Integer> q = new LinkedList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n\\n        int s = t-3000;\\n\\n        while(q.peek() < s)\\n        {\\n            q.poll();\\n        }\\n\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n\\n    Queue<Integer> q = new LinkedList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n\\n        int s = t-3000;\\n\\n        while(q.peek() < s)\\n        {\\n            q.poll();\\n        }\\n\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666594,
                "title": "python-solution-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n)\\n\\n# Code\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.all = []\\n\\n    def ping(self, t: int) -> int:\\n        self.all.append(t)\\n        min_time = t-3000\\n        while self.all[0] < min_time:\\n            self.all.pop(0)\\n        return len(self.all)    \\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.all = []\\n\\n    def ping(self, t: int) -> int:\\n        self.all.append(t)\\n        min_time = t-3000\\n        while self.all[0] < min_time:\\n            self.all.pop(0)\\n        return len(self.all)    \\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647168,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    public RecentCounter() {\\n        q=new LinkedList<>();\\n    }\\n    public int ping(int t) {\\n        q.add(t);\\n        int min=t-3000;\\n        while(q.peek()<min){\\n            q.remove();\\n        }\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> q;\\n    public RecentCounter() {\\n        q=new LinkedList<>();\\n    }\\n    public int ping(int t) {\\n        q.add(t);\\n        int min=t-3000;\\n        while(q.peek()<min){\\n            q.remove();\\n        }\\n        return q.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548121,
                "title": "easy-java-solution-with-deque-26ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\n    private LinkedList<Integer> pingList;\\n\\n    public RecentCounter() {\\n        this.pingList = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        pingList.addLast(t);\\n        while (t - 3000 > pingList.getFirst()) {\\n            pingList.removeFirst();\\n        }\\n        return pingList.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    private LinkedList<Integer> pingList;\\n\\n    public RecentCounter() {\\n        this.pingList = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        pingList.addLast(t);\\n        while (t - 3000 > pingList.getFirst()) {\\n            pingList.removeFirst();\\n        }\\n        return pingList.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521765,
                "title": "solution",
                "content": "```C++ []\\nclass RecentCounter {\\npublic:\\nqueue<int>q;\\n    RecentCounter() {   \\n    }\\n    int ping(int t) {\\n       q.push(t);\\n       while(q.front()<t-3000){\\n           q.pop();\\n       }\\n       return q.size(); \\n    }\\n};\\n```\\n\\n```Python3 []\\nfrom collections import deque\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while t - 3000 > self.queue[0]:\\n            self.queue.popleft()\\n        return len(self.queue)\\n```\\n\\n```Java []\\nclass RecentCounter {\\n    LinkedList<Integer> swin;\\n    public RecentCounter() {\\n        swin = new LinkedList<>();\\n    }\\n    public int ping(int t) {\\n        swin.addLast(t);\\n        while (swin.getFirst() < t - 3000) swin.removeFirst();\\n        return swin.size();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass RecentCounter {\\npublic:\\nqueue<int>q;\\n    RecentCounter() {   \\n    }\\n    int ping(int t) {\\n       q.push(t);\\n       while(q.front()<t-3000){\\n           q.pop();\\n       }\\n       return q.size(); \\n    }\\n};\\n```\n```Python3 []\\nfrom collections import deque\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while t - 3000 > self.queue[0]:\\n            self.queue.popleft()\\n        return len(self.queue)\\n```\n```Java []\\nclass RecentCounter {\\n    LinkedList<Integer> swin;\\n    public RecentCounter() {\\n        swin = new LinkedList<>();\\n    }\\n    public int ping(int t) {\\n        swin.addLast(t);\\n        while (swin.getFirst() < t - 3000) swin.removeFirst();\\n        return swin.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513494,
                "title": "python-solution-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and t - self.queue[0] > 3000:\\n            self.queue.popleft()\\n        self.queue.append(t)\\n        \\n        return len(self.queue)\\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and t - self.queue[0] > 3000:\\n            self.queue.popleft()\\n        self.queue.append(t)\\n        \\n        return len(self.queue)\\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388299,
                "title": "go-solution-using-binary-search",
                "content": "```\\ntype RecentCounter struct {\\n        requests []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n        return RecentCounter{requests: make([]int, 0)}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n        this.requests = append(this.requests, t)\\n        min := t - 3000\\n        i := binarySearch(this.requests, min)\\n        return len(this.requests) - i\\n}\\n\\nfunc binarySearch(nums []int, target int) int {\\n        l, r := 0, len(nums)-1\\n        for l <= r {\\n                mid := (l + r) / 2\\n                if num := nums[mid]; num == target {\\n                        return mid\\n                } else if num < target {\\n                        l = mid + 1\\n                } else {\\n                        r = mid - 1\\n                }\\n        }\\n\\n        return l\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "```\\ntype RecentCounter struct {\\n        requests []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n        return RecentCounter{requests: make([]int, 0)}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n        this.requests = append(this.requests, t)\\n        min := t - 3000\\n        i := binarySearch(this.requests, min)\\n        return len(this.requests) - i\\n}\\n\\nfunc binarySearch(nums []int, target int) int {\\n        l, r := 0, len(nums)-1\\n        for l <= r {\\n                mid := (l + r) / 2\\n                if num := nums[mid]; num == target {\\n                        return mid\\n                } else if num < target {\\n                        l = mid + 1\\n                } else {\\n                        r = mid - 1\\n                }\\n        }\\n\\n        return l\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3382418,
                "title": "100-runtime-typescript-javascript-solution",
                "content": "\\n# TypeScript Code\\n```\\nclass RecentCounter {\\n    queue = [];\\n\\n    ping(t: number): number {\\n        this.queue.push(t);\\n\\n        while (this.queue[0] < t - 3000) {\\n            this.queue.shift();\\n        }\\n        \\n        return this.queue.length;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```\\n\\n\\n# JavaScript Code\\n```\\nclass RecentCounter {\\n    queue = [];\\n\\n    ping(t) {\\n        this.queue.push(t);\\n\\n        while (this.queue[0] < t - 3000) {\\n            this.queue.shift();\\n        }\\n        \\n        return this.queue.length;\\n    }\\n}",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    queue = [];\\n\\n    ping(t: number): number {\\n        this.queue.push(t);\\n\\n        while (this.queue[0] < t - 3000) {\\n            this.queue.shift();\\n        }\\n        \\n        return this.queue.length;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857815,
                "title": "smallest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front() < t - 3000){\\n            q.pop();\\n        }\\n        \\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front() < t - 3000){\\n            q.pop();\\n        }\\n        \\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267307,
                "title": "python-deque-o-1-99-faster",
                "content": "```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.que = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.que.append(t)\\n        while self.que and self.que[0] < t - 3000:\\n            self.que.popleft()\\n        return len(self.que)",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.que = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.que.append(t)\\n        while self.que and self.que[0] < t - 3000:\\n            self.que.popleft()\\n        return len(self.que)",
                "codeTag": "Java"
            },
            {
                "id": 2231165,
                "title": "c-simplest-with-queue",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue <int> qu;\\n  \\n    RecentCounter() { \\n    }\\n\\t\\n    int ping(int t) {\\n        qu.push(t); //insert ping time in queue\\n        while(qu.front() < t-3000) qu.pop(); //remove all pings before 3000ms of current time\\n        return qu.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue <int> qu;\\n  \\n    RecentCounter() { \\n    }\\n\\t\\n    int ping(int t) {\\n        qu.push(t); //insert ping time in queue\\n        while(qu.front() < t-3000) qu.pop(); //remove all pings before 3000ms of current time\\n        return qu.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238452,
                "title": "c-5-lines-of-code",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    int ping(int t) {\\n        q.push(t);\\n        while ( q.front() < t - 3000 )      q.pop();\\n        return q.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    int ping(int t) {\\n        q.push(t);\\n        while ( q.front() < t - 3000 )      q.pop();\\n        return q.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158707,
                "title": "easy-clear-100-00-of-javascript-online-submissions",
                "content": "```\\nvar RecentCounter = function() {\\n    this.oldCalls = [];    \\n};\\n\\nRecentCounter.prototype.ping = function(t) {\\n    this.oldCalls.push(t);    \\n    \\n    while(this.oldCalls[0] < (t-3000))            \\n        this.oldCalls.shift();            \\n    \\n    return this.oldCalls.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar RecentCounter = function() {\\n    this.oldCalls = [];    \\n};\\n\\nRecentCounter.prototype.ping = function(t) {\\n    this.oldCalls.push(t);    \\n    \\n    while(this.oldCalls[0] < (t-3000))            \\n        this.oldCalls.shift();            \\n    \\n    return this.oldCalls.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 979754,
                "title": "simple-java-solution-queue-o-n",
                "content": "```\\nclass RecentCounter {\\nprivate Queue<Integer> queue;\\n    public RecentCounter() {\\n       queue = new LinkedList<>(); \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(t-queue.peek()>3000){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\nprivate Queue<Integer> queue;\\n    public RecentCounter() {\\n       queue = new LinkedList<>(); \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(t-queue.peek()>3000){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 949129,
                "title": "python-deque-o-1-time-o-1-space",
                "content": "1.  Consider the worst case in which t is extremely large i.e >10^6,  it takes O(3000) to iterate over the past 3000 elements, which is still a constant.\\n2.  Since we only return the size of deque, it takes O(1) space.\\n```\\nfrom collections import deque\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q=deque()\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        low_limit=self.q[-1]-3000\\n        while self.q and self.q[0]<low_limit:\\n              self.q.popleft()\\n        return len(self.q)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q=deque()\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        low_limit=self.q[-1]-3000\\n        while self.q and self.q[0]<low_limit:\\n              self.q.popleft()\\n        return len(self.q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914416,
                "title": "easy-python-using-queue",
                "content": "class RecentCounter:\\n\\n    def __init__(self):\\n        self.queue=list()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        \\n        while (self.queue[0] < t-3000):\\n            self.queue.pop(0)\\n        return len(self.queue)",
                "solutionTags": [],
                "code": "class RecentCounter:\\n\\n    def __init__(self):\\n        self.queue=list()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        \\n        while (self.queue[0] < t-3000):\\n            self.queue.pop(0)\\n        return len(self.queue)",
                "codeTag": "Java"
            },
            {
                "id": 874190,
                "title": "kotlin-with-an-optimised-binary-search",
                "content": "I started out pretty much with a fold operation, then realised the solution could be done with a binary search, as will follow shortly.\\nHowever, there is a further time optimisation that can be made: I know that my next boundary will never be any further to the left than my last left pointer in BS, so after each search I can cache the position of the left pointer so that I don\\'t have to start from zero every time:\\n\\n```\\nclass RecentCounter(\\n  var recentRequests: Int = 0,\\n  var leftCache: Int = 0\\n) {\\n    private var allRequests = mutableListOf<Int>()\\n    fun ping(t: Int): Int {\\n        allRequests.add(t)\\n        var l = leftCache; var r = allRequests.size - 1\\n        while (l < r) {\\n          val mid = l + (r - l) / 2\\n          if (allRequests[mid] < t - 3000) l = mid + 1\\n          else r = mid\\n        }\\n        leftCache = l\\n        return allRequests.size - l\\n    }\\n}\\n```\\n\\nNot sure why it\\'s necessary to keep a `recentRequests` count though. A bit pointless I think...",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter(\\n  var recentRequests: Int = 0,\\n  var leftCache: Int = 0\\n) {\\n    private var allRequests = mutableListOf<Int>()\\n    fun ping(t: Int): Int {\\n        allRequests.add(t)\\n        var l = leftCache; var r = allRequests.size - 1\\n        while (l < r) {\\n          val mid = l + (r - l) / 2\\n          if (allRequests[mid] < t - 3000) l = mid + 1\\n          else r = mid\\n        }\\n        leftCache = l\\n        return allRequests.size - l\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873740,
                "title": "java-solution-with-a-circular-array-that-beats-100-submissions",
                "content": "The official solution recommends a dynamic data structure, which in situations like this, is a bit of an overkill, due to many unnecessary additions and removals of objects on the heap. A faster and more memory friendly approach is to leverage a static circular buffer of a fixed size, as shown below. You might consider this technique whenever you need to track some fixed number of records.\\n```\\nclass RecentCounter {\\n    // The extra padding is added for easier calculation of actual window size.\\n    private static final int WINDOW_SIZE = 3002;\\n    \\n    private final int[] timestamps = new int[WINDOW_SIZE];\\n    private int start, end;\\n\\n    public int ping(int t) {\\n        timestamps[end] = t;\\n        end = (end + 1) % WINDOW_SIZE;        \\n        // Prune away old entries from the window.\\n        while (t - timestamps[start] >= WINDOW_SIZE - 1) start = (start + 1) % WINDOW_SIZE;\\n        return start < end ? end - start : WINDOW_SIZE - start + end;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass RecentCounter {\\n    // The extra padding is added for easier calculation of actual window size.\\n    private static final int WINDOW_SIZE = 3002;\\n    \\n    private final int[] timestamps = new int[WINDOW_SIZE];\\n    private int start, end;\\n\\n    public int ping(int t) {\\n        timestamps[end] = t;\\n        end = (end + 1) % WINDOW_SIZE;        \\n        // Prune away old entries from the window.\\n        while (t - timestamps[start] >= WINDOW_SIZE - 1) start = (start + 1) % WINDOW_SIZE;\\n        return start < end ? end - start : WINDOW_SIZE - start + end;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873449,
                "title": "cpp-solution-using-queue",
                "content": "```\\nclass RecentCounter {\\npublic:\\n      queue<int> q;\\n      RecentCounter() {\\n      }\\n      int ping(int t) {\\n         q.push(t);\\n\\t     while(q.front() < t-3000)\\n             q.pop();\\n         return q.size();\\n      }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n      queue<int> q;\\n      RecentCounter() {\\n      }\\n      int ping(int t) {\\n         q.push(t);\\n\\t     while(q.front() < t-3000)\\n             q.pop();\\n         return q.size();\\n      }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873291,
                "title": "c-solution-with-lower-bound-easy-to-understand",
                "content": "Do <b>Upvote</b> this solution, if you like it. :)\\nIf you have any suggestions on how to improve this solution further, then feel free to comment down below.\\n\\n```\\nclass RecentCounter {\\npublic:\\n    vector<int> requests;\\n    RecentCounter() {\\n        requests.clear();\\n    }\\n    \\n    int ping(int t) {\\n        requests.push_back(t);\\n        int num = 0;\\n        \\n        if(requests.size() == 1)\\n            return 1;\\n        else {\\n            int first = lower_bound(requests.begin(), requests.end(), t - 3000) - requests.begin();\\n            int second = lower_bound(requests.begin(), requests.end(), t) - requests.begin();\\n            cout<<second<<\" \"<<first<<endl;\\n            return second - first + 1;\\n        }\\n    }\\n};\\n\\n```\\n<b> Happy Coding :) </b>",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> requests;\\n    RecentCounter() {\\n        requests.clear();\\n    }\\n    \\n    int ping(int t) {\\n        requests.push_back(t);\\n        int num = 0;\\n        \\n        if(requests.size() == 1)\\n            return 1;\\n        else {\\n            int first = lower_bound(requests.begin(), requests.end(), t - 3000) - requests.begin();\\n            int second = lower_bound(requests.begin(), requests.end(), t) - requests.begin();\\n            cout<<second<<\" \"<<first<<endl;\\n            return second - first + 1;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 873273,
                "title": "in-java",
                "content": "```\\nclass RecentCounter {\\n    ArrayList<Integer> requests = new ArrayList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        this.requests.add(t);\\n        int leftRange = t-3000;\\n        int rightRange = t;\\n        int count=0;\\n        for(Integer num:this.requests){\\n            if(num>=leftRange && num<=rightRange){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    ArrayList<Integer> requests = new ArrayList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        this.requests.add(t);\\n        int leftRange = t-3000;\\n        int rightRange = t;\\n        int count=0;\\n        for(Integer num:this.requests){\\n            if(num>=leftRange && num<=rightRange){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873207,
                "title": "number-of-recent-calls-c-10-lines",
                "content": "Keep a window for most recent pings that are at most 3000 ms apart\\n```\\nclass RecentCounter {\\n    queue<int> pings_;\\npublic:    \\n    int ping(int t) {\\n        pings_.push(t);\\n        while (t - pings_.front() > 3000)\\n            pings_.pop();        \\n        return pings_.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RecentCounter {\\n    queue<int> pings_;\\npublic:    \\n    int ping(int t) {\\n        pings_.push(t);\\n        while (t - pings_.front() > 3000)\\n            pings_.pop();        \\n        return pings_.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515296,
                "title": "python-queue",
                "content": "```python\\nfrom collections import deque\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n\\n        while(self.queue and self.queue[0] < t - 3000):\\n            self.queue.popleft()\\n            \\n        return len(self.queue)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```python\\nfrom collections import deque\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = deque()\\n        \\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n\\n        while(self.queue and self.queue[0] < t - 3000):\\n            self.queue.popleft()\\n            \\n        return len(self.queue)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490516,
                "title": "binary-search-solution-using-ruby",
                "content": "```\\nclass RecentCounter\\n    def initialize()\\n        @pings = []\\n    end\\n\\n    def ping(t)\\n        @pings << t\\n        @pings.slice!(0 ... @pings.bsearch_index {|x| x >= t-3000})\\n        @pings.size\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```\\nclass RecentCounter\\n    def initialize()\\n        @pings = []\\n    end\\n\\n    def ping(t)\\n        @pings << t\\n        @pings.slice!(0 ... @pings.bsearch_index {|x| x >= t-3000})\\n        @pings.size\\n    end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479320,
                "title": "java-simple-solution-by-using-queue-queue-is-acted-as-a-sliding-window-for-maintaing-the-interval",
                "content": "```\\nclass RecentCounter {\\n    //inclusive [t-3000,3000]\\n    Queue<Integer>queue;\\n    public RecentCounter() {\\n        queue=new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.size()>0&&queue.peek()<(t-3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    //inclusive [t-3000,3000]\\n    Queue<Integer>queue;\\n    public RecentCounter() {\\n        queue=new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.size()>0&&queue.peek()<(t-3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453924,
                "title": "python-3-beats-98",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self): self.H = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.H.append(t)\\n        while self.H[0] < t - 3000: self.H.popleft()\\n        return len(self.H)\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self): self.H = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.H.append(t)\\n        while self.H[0] < t - 3000: self.H.popleft()\\n        return len(self.H)\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 389431,
                "title": "easy-to-understand-c-solution",
                "content": "Runtime: 204 ms, faster than 73.58% of C++ online submissions for Number of Recent Calls.\\nMemory Usage: 49.8 MB, less than 100.00% of C++ online submissions for Number of Recent Calls.\\n\\n```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        \\n        q.push(t);\\n        while(t - q.front() > 3000)\\n            q.pop();\\n        return q.size();\\n    }\\n    \\n    private:\\n        queue<int> q;\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */",
                "solutionTags": [
                    "Queue"
                ],
                "code": "Runtime: 204 ms, faster than 73.58% of C++ online submissions for Number of Recent Calls.\\nMemory Usage: 49.8 MB, less than 100.00% of C++ online submissions for Number of Recent Calls.\\n\\n```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        \\n        q.push(t);\\n        while(t - q.front() > 3000)\\n            q.pop();\\n        return q.size();\\n    }\\n    \\n    private:\\n        queue<int> q;\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 355572,
                "title": "a-simple-java-solution-explained",
                "content": "So, tbf, this question can be worded much, much better. For example\\n<p>\\nWrite a class RecentCounter to count \"recent\" requests.\\nIt has only one method: ping(int t), where <strong>t</strong> represents some timestamp, in milliseconds.\\nReturn the number of pings that have occurred from 3000 milliseconds ago until timestamp <strong>t</strong> parameter.\\nTherefore, any ping occurred in the \"last 3000ms\", i.e. a range [t - 3000, t] will count, including the current ping.\\nIt is guaranteed that every call to ping uses a strictly larger value of t than before.\\n</p>\\n\\n```\\nclass RecentCounter {\\n    private final Queue<Integer> requestQueue = new LinkedList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    /*\\n        The question does not explain clearly that t (in their example)\\n        is timeNow. They do say, that [timeNow - 3000, timeNow] (inclusive) counts.\\n        Therefore, when 3002 comes in, 3001 falls outside the range, since it was before.\\n    */\\n    public int ping(int timeNow) {\\n\\n        requestQueue.add(timeNow);\\n        \\n        while (requestQueue.peek() < (timeNow - 3000)) {\\n            requestQueue.poll();\\n        }\\n        \\n        return requestQueue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    private final Queue<Integer> requestQueue = new LinkedList<>();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    /*\\n        The question does not explain clearly that t (in their example)\\n        is timeNow. They do say, that [timeNow - 3000, timeNow] (inclusive) counts.\\n        Therefore, when 3002 comes in, 3001 falls outside the range, since it was before.\\n    */\\n    public int ping(int timeNow) {\\n\\n        requestQueue.add(timeNow);\\n        \\n        while (requestQueue.peek() < (timeNow - 3000)) {\\n            requestQueue.poll();\\n        }\\n        \\n        return requestQueue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282480,
                "title": "java-queue",
                "content": "```java\\nclass RecentCounter {\\n\\n    private Deque<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue = new ArrayDeque<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.size() > 0 && queue.peek() < t - 3000)\\n            queue.remove();\\n        \\n        return queue.size();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```java\\nclass RecentCounter {\\n\\n    private Deque<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue = new ArrayDeque<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.size() > 0 && queue.peek() < t - 3000)\\n            queue.remove();\\n        \\n        return queue.size();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257833,
                "title": "java-solution-using-queue-beats-94-44",
                "content": "```\\nclass RecentCounter {\\n    Queue<Integer> queue;\\n    public RecentCounter() {\\n        queue = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.size() > 0) {\\n            int first = queue.peek();\\n            if(t - first > 3000)\\n                queue.poll();\\n            else\\n                break;\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> queue;\\n    public RecentCounter() {\\n        queue = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.size() > 0) {\\n            int first = queue.peek();\\n            if(t - first > 3000)\\n                queue.poll();\\n            else\\n                break;\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192324,
                "title": "java-array-binary-search-111-ms-o-log-3000-time-o-logn-space",
                "content": "Keep track of the rising watermark after each call to limit the search space for the next call to no more than 3000 elements.\\n\\n```\\nclass RecentCounter {\\n\\n    private int[] times;\\n    private int watermark;\\n    private int size;\\n    \\n    public RecentCounter() {\\n        times = new int[10000];\\n        watermark = 0;\\n        size = 0;\\n    }\\n    \\n    public int ping(int t) {\\n        times[size] = t;\\n        size ++;\\n        watermark = binarySearch(t-3000, watermark, size);\\n        return size - watermark;\\n    }\\n    \\n    private int binarySearch(int t, int start, int end) {\\n        int lo = start, hi = end;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if (times[mid] < t) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n\\n    private int[] times;\\n    private int watermark;\\n    private int size;\\n    \\n    public RecentCounter() {\\n        times = new int[10000];\\n        watermark = 0;\\n        size = 0;\\n    }\\n    \\n    public int ping(int t) {\\n        times[size] = t;\\n        size ++;\\n        watermark = binarySearch(t-3000, watermark, size);\\n        return size - watermark;\\n    }\\n    \\n    private int binarySearch(int t, int start, int end) {\\n        int lo = start, hi = end;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if (times[mid] < t) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189261,
                "title": "java-binary-search-o-1",
                "content": "The timestamp input is a increasing sequence \\nTherefore, in each ping, we can use binary search to search for the `target just >= t - 3000`\\nAnd return the result calculated from the index of the target\\n\\n**Optimization:**\\nMaintain a `lowerBound` index to shrink the binary search range to `[lowerBound, list.size()-1]`\\nUpdate `lowerBound` in each ping\\nThis speed up about `30ms`\\n```\\nclass RecentCounter {\\n    List<Integer> list = new ArrayList<>();\\n    int lowerBound = 0;\\n    public RecentCounter() {}\\n    public int ping(int t) {\\n        list.add(t);\\n        int r = list.size() - 1;\\n        int target = t - 3000;\\n        while (lowerBound < r) {\\n            int m = lowerBound + (r-lowerBound) / 2;\\n            if (list.get(m) >= target)\\n                r = m;\\n            else\\n                lowerBound = m + 1;\\n        }\\n        return list.size() - lowerBound;\\n    }\\n}\\n```\\n**Time Complexity:** `O(log3001)` => `O(1)`\\n**Space Complexity:** `O(N)` for list",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    List<Integer> list = new ArrayList<>();\\n    int lowerBound = 0;\\n    public RecentCounter() {}\\n    public int ping(int t) {\\n        list.add(t);\\n        int r = list.size() - 1;\\n        int target = t - 3000;\\n        while (lowerBound < r) {\\n            int m = lowerBound + (r-lowerBound) / 2;\\n            if (list.get(m) >= target)\\n                r = m;\\n            else\\n                lowerBound = m + 1;\\n        }\\n        return list.size() - lowerBound;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906604,
                "title": "c-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class RecentCounter {\\n    int counter;\\n    Queue<int> q = new Queue<int>();\\n\\n    public RecentCounter() {\\n        counter = 0;\\n    }\\n    \\n    public int Ping(int t) {\\n        q.Enqueue(t);\\n        counter += 1;\\n        while (q.Count > 0 && (q.Peek() > t || q.Peek() < (t - 3000)))\\n        {\\n            q.Dequeue();\\n            counter -= 1;\\n        }\\n\\n        return counter;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.Ping(t);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class RecentCounter {\\n    int counter;\\n    Queue<int> q = new Queue<int>();\\n\\n    public RecentCounter() {\\n        counter = 0;\\n    }\\n    \\n    public int Ping(int t) {\\n        q.Enqueue(t);\\n        counter += 1;\\n        while (q.Count > 0 && (q.Peek() > t || q.Peek() < (t - 3000)))\\n        {\\n            q.Dequeue();\\n            counter -= 1;\\n        }\\n\\n        return counter;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.Ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879598,
                "title": "kotlin-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter() {\\n\\n    val queue = ArrayDeque<Int>()\\n\\n    fun ping(t: Int): Int {\\n        while (queue.isNotEmpty() && queue.first() < t - 3000) {\\n            queue.removeFirst()\\n        }\\n        queue.add(t)\\n        return queue.size\\n    }\\n\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass RecentCounter() {\\n\\n    val queue = ArrayDeque<Int>()\\n\\n    fun ping(t: Int): Int {\\n        while (queue.isNotEmpty() && queue.first() < t - 3000) {\\n            queue.removeFirst()\\n        }\\n        queue.add(t)\\n        return queue.size\\n    }\\n\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678085,
                "title": "simple-iterative-approach-using-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Arrays\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\n    ArrayList<Integer> calls ;\\n    public RecentCounter() {\\n        calls = new ArrayList<Integer>();\\n        }\\n    \\n    public int ping(int t) {\\n        calls.add(t);\\n        int count = 0;\\n        for(Integer call:calls){\\n            if( t-call<=3000) count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    ArrayList<Integer> calls ;\\n    public RecentCounter() {\\n        calls = new ArrayList<Integer>();\\n        }\\n    \\n    public int ping(int t) {\\n        calls.add(t);\\n        int count = 0;\\n        for(Integer call:calls){\\n            if( t-call<=3000) count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608833,
                "title": "c",
                "content": "\\n# Code\\n```\\npublic class RecentCounter\\n{\\n    int[] pings;\\n    int idx;\\n\\n    public RecentCounter()\\n    {\\n        pings = new int[10000];\\n        idx= 0;\\n    }\\n\\n    public int Ping(int t)\\n    {\\n        pings[idx++] = t;\\n        int left = t - 3000;\\n        int cnt = 1;\\n\\n        for(int i = idx-2; i >= 0; --i) \\n        {\\n            if (pings[i] < left)\\n                return cnt;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.Ping(t);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class RecentCounter\\n{\\n    int[] pings;\\n    int idx;\\n\\n    public RecentCounter()\\n    {\\n        pings = new int[10000];\\n        idx= 0;\\n    }\\n\\n    public int Ping(int t)\\n    {\\n        pings[idx++] = t;\\n        int left = t - 3000;\\n        int cnt = 1;\\n\\n        for(int i = idx-2; i >= 0; --i) \\n        {\\n            if (pings[i] < left)\\n                return cnt;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.Ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438043,
                "title": "simple-solution-but-logical-beats-99-70",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen I saw this problem for the first time, I thought problems related to queue in leetcode need to be solved by Node, but it is easier than Nodes here.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn while statement we check is it empty or not first if it is, we simply append it to queue (composition).\\nIn next Input, there is 1 in queue, so we add 1 + 3000 < t, t in this case 100, if it is the case we remove it from queue\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nBig O(n Log (n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nBig O(n)\\n# Code\\n```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and self.queue[0] + 3000 < t:\\n            self.queue.popleft()\\n        self.queue.append(t)\\n        return len(self.queue)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n    def __init__(self):\\n        self.queue = deque()\\n\\n    def ping(self, t: int) -> int:\\n        while self.queue and self.queue[0] + 3000 < t:\\n            self.queue.popleft()\\n        self.queue.append(t)\\n        return len(self.queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873768,
                "title": "c-easy-array-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RecentCounter {\\npublic:\\n    vector<int> arr;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        arr.push_back(t);\\n        int cnt=0;\\n        for (int i : arr) if (i>=t-3000 && i<=t) cnt++;\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> arr;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        arr.push_back(t);\\n        int cnt=0;\\n        for (int i : arr) if (i>=t-3000 && i<=t) cnt++;\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857801,
                "title": "one-line-code-in-c",
                "content": "\\n\\n# Code\\n```\\nclass RecentCounter {\\npublic:\\nqueue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000){\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\nqueue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000){\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444491,
                "title": "java-simple-and-friendly-97",
                "content": "```\\nclass RecentCounter {\\n    Queue<Integer> queue = new LinkedList<>();\\n\\n    public RecentCounter() {        \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.peek() < (t-3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> queue = new LinkedList<>();\\n\\n    public RecentCounter() {        \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while (queue.peek() < (t-3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337766,
                "title": "simple-c-queue-solution",
                "content": "Please upvote if you like my solution .\\n```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        int x = q.front();\\n        while(x < t-3000){\\n            q.pop(); x = q.front();\\n        }\\n        return q.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        int x = q.front();\\n        while(x < t-3000){\\n            q.pop(); x = q.front();\\n        }\\n        return q.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168734,
                "title": "python3-o-n-o-n-with-explanation",
                "content": "https://photos.app.goo.gl/sFqFttroBwRzf7MaA couldn\\'t upload it here dont know \\n\\n```\\nclass RecentCounter:\\n#     O(n) || O(n)\\n# Runtime: 310ms 78.53% || memory: 19.6mb 46.67%\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        \\n        while (t - self.queue[0]) > 3000:\\n            self.queue.pop(0)\\n            \\n        return self.queue.__len__()\\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n#     O(n) || O(n)\\n# Runtime: 310ms 78.53% || memory: 19.6mb 46.67%\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        \\n        while (t - self.queue[0]) > 3000:\\n            self.queue.pop(0)\\n            \\n        return self.queue.__len__()\\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142681,
                "title": "kotlin-concise-solution-with-a-queue-mutablelist",
                "content": "We instantiate a queue to keep track of the ping values. When we ping, we add to the queue and we dequeue items while `t - item > 3000`. The remaining items will all be pings that took place in the last 3000ms, so we can just return the size of the queue.\\n\\n```\\nclass RecentCounter(private val queue: MutableList<Int> = mutableListOf<Int>()) {\\n    fun ping(t: Int): Int {\\n        queue.add(t)\\n        while (t - queue[0] > 3000) queue.removeAt(0)\\n        return queue.size\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter(private val queue: MutableList<Int> = mutableListOf<Int>()) {\\n    fun ping(t: Int): Int {\\n        queue.add(t)\\n        while (t - queue[0] > 3000) queue.removeAt(0)\\n        return queue.size\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094027,
                "title": "python-deque",
                "content": "Some alternative solution with the Deque object which has Insertion or removal of elements at the end or beginning - constant O(1)\\n\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        from collections import deque\\n        self.t = deque()\\n\\n    def ping(self, t: int) -> int:        \\n        while self.t and self.t[0] < t - 3000:\\n            self.t.popleft()\\n        self.t.append(t)\\n        return len(self.t)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        from collections import deque\\n        self.t = deque()\\n\\n    def ping(self, t: int) -> int:        \\n        while self.t and self.t[0] < t - 3000:\\n            self.t.popleft()\\n        self.t.append(t)\\n        return len(self.t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011643,
                "title": "java-queue",
                "content": "```\\nclass RecentCounter {\\n\\n    /**\\n     * Time Complexity: O(1)\\n     * Space Complexity: O(n)\\n     * @topic Number of Recent Calls\\n     * @author ArtistS\\n     */\\n    Queue<Integer> recentRequests;\\n    public RecentCounter() {\\n        recentRequests = new LinkedList<Integer>();\\n    }\\n\\n    public int ping(int t) {\\n        recentRequests.offer(t);\\n        while (recentRequests.peek() < t - 3000) {\\n            recentRequests.poll();\\n        }\\n        return recentRequests.size();\\n    }\\n\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n\\n    /**\\n     * Time Complexity: O(1)\\n     * Space Complexity: O(n)\\n     * @topic Number of Recent Calls\\n     * @author ArtistS\\n     */\\n    Queue<Integer> recentRequests;\\n    public RecentCounter() {\\n        recentRequests = new LinkedList<Integer>();\\n    }\\n\\n    public int ping(int t) {\\n        recentRequests.offer(t);\\n        while (recentRequests.peek() < t - 3000) {\\n            recentRequests.poll();\\n        }\\n        return recentRequests.size();\\n    }\\n\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981013,
                "title": "c-using-queue-easy-to-understand",
                "content": "class RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000){\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n if its help please don\\'t forget to upvote it \\uD83D\\uDE0A.",
                "solutionTags": [
                    "Array",
                    "Queue"
                ],
                "code": "class RecentCounter {\\npublic:\\n    queue<int>q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000){\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n if its help please don\\'t forget to upvote it \\uD83D\\uDE0A.",
                "codeTag": "Java"
            },
            {
                "id": 1889394,
                "title": "python-two-solutions-deque",
                "content": "Using a deque:\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        while t - self.pings[0] > 3000:\\n            self.pings.popleft()\\n        return len(self.pings)\\n```\\n\\nOtherwise, using a list to save all the pings:\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = []\\n        self.start = 0\\n        self.cnt = 0\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        self.cnt += 1\\n        while t - self.pings[self.start] > 3000:\\n            self.start += 1\\n            self.cnt -= 1\\n        return self.cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        while t - self.pings[0] > 3000:\\n            self.pings.popleft()\\n        return len(self.pings)\\n```\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = []\\n        self.start = 0\\n        self.cnt = 0\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        self.cnt += 1\\n        while t - self.pings[self.start] > 3000:\\n            self.start += 1\\n            self.cnt -= 1\\n        return self.cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871821,
                "title": "java-queue-5-loc-super-easy-to-understand",
                "content": "```\\nclass RecentCounter {\\n    \\n    private Queue<Integer> q;\\n    \\n    public RecentCounter() {\\n        q = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n        while(q.peek() < t - 3000) {\\n            q.poll();\\n        }\\n        return q.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    \\n    private Queue<Integer> q;\\n    \\n    public RecentCounter() {\\n        q = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        q.add(t);\\n        while(q.peek() < t - 3000) {\\n            q.poll();\\n        }\\n        return q.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841306,
                "title": "beginner-friendly-python-solution",
                "content": "```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.calls = []\\n\\n    def ping(self, t):\\n        self.calls.append(t)\\n        while self.calls[0] < t-3000:\\n            self.calls.pop(0)\\n        return len(self.calls)\\n        \\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.calls = []\\n\\n    def ping(self, t):\\n        self.calls.append(t)\\n        while self.calls[0] < t-3000:\\n            self.calls.pop(0)\\n        return len(self.calls)\\n        \\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526660,
                "title": "linear-solution-queue",
                "content": "```\\ntype RecentCounter struct {\\n    values []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{values: make([]int, 0)}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    v := this.values\\n\\t// add the new values to the queue (end of slice)\\n    v = append(v, t)\\n    \\n    ind := 0\\n\\t// remove first elements till it\\'s in range we need [t-3000:t] (because every new t is bigger than previous)\\n    for ind<len(v) && v[ind] < t-3000 {\\n        ind++\\n    }\\n\\t// cut the first values that we don\\'t need anymore, cause they will not be in range for next queries\\n    this.values = v[ind:]\\n    \\n    return len(this.values)\\n}\\n ```\\n",
                "solutionTags": [],
                "code": "```\\ntype RecentCounter struct {\\n    values []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{values: make([]int, 0)}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    v := this.values\\n\\t// add the new values to the queue (end of slice)\\n    v = append(v, t)\\n    \\n    ind := 0\\n\\t// remove first elements till it\\'s in range we need [t-3000:t] (because every new t is bigger than previous)\\n    for ind<len(v) && v[ind] < t-3000 {\\n        ind++\\n    }\\n\\t// cut the first values that we don\\'t need anymore, cause they will not be in range for next queries\\n    this.values = v[ind:]\\n    \\n    return len(this.values)\\n}\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1445135,
                "title": "range-and-queues",
                "content": "```\\n queue<int> q; \\n    RecentCounter(){\\n    }\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front() < q.back()-3000) {\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n queue<int> q; \\n    RecentCounter(){\\n    }\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front() < q.back()-3000) {\\n            q.pop();\\n        }\\n        return q.size();\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1426727,
                "title": "c-queue-simple-queue-solution",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(t-q.front()>3000){q.pop();}\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(t-q.front()>3000){q.pop();}\\n        return q.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327267,
                "title": "java-simple-solution-with-queues",
                "content": "```\\nclass RecentCounter {\\n    Queue<Integer> q; \\n    \\n    public RecentCounter() {\\n        q = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!q.isEmpty() && t - 3000 > q.peek()) q.remove();\\n        \\n        q.add(t);\\n        \\n        return q.size();\\n        \\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n \\n ```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> q; \\n    \\n    public RecentCounter() {\\n        q = new LinkedList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!q.isEmpty() && t - 3000 > q.peek()) q.remove();\\n        \\n        q.add(t);\\n        \\n        return q.size();\\n        \\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1324137,
                "title": "java-binary-search",
                "content": "```\\nclass RecentCounter {\\n    private ArrayList<Integer> req = new ArrayList<>();\\n    \\n    public RecentCounter() {\\n        this.req = new ArrayList<>();    \\n    }\\n    \\n    public int ping(int t) {\\n        req.add(t);\\n        int start = t - 3000;\\n        int idx = binarySearch(req, start);\\n        idx += req.get(idx) >= start ? 0 : 1;\\n        return req.size() - idx;\\n    }\\n    \\n    // find index of element >= k\\n    public int binarySearch(ArrayList<Integer> s, int k) {\\n        int n = s.size();\\n        int l = 0; \\n        int r = n-1;\\n        while (l < r) {\\n            int mid = (l+r)/2;\\n            if (s.get(mid) == k) return mid;\\n            if (s.get(mid) > k) r = mid-1;\\n            if (s.get(mid) < k) l = mid+1;\\n        }\\n        return l;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    private ArrayList<Integer> req = new ArrayList<>();\\n    \\n    public RecentCounter() {\\n        this.req = new ArrayList<>();    \\n    }\\n    \\n    public int ping(int t) {\\n        req.add(t);\\n        int start = t - 3000;\\n        int idx = binarySearch(req, start);\\n        idx += req.get(idx) >= start ? 0 : 1;\\n        return req.size() - idx;\\n    }\\n    \\n    // find index of element >= k\\n    public int binarySearch(ArrayList<Integer> s, int k) {\\n        int n = s.size();\\n        int l = 0; \\n        int r = n-1;\\n        while (l < r) {\\n            int mid = (l+r)/2;\\n            if (s.get(mid) == k) return mid;\\n            if (s.get(mid) > k) r = mid-1;\\n            if (s.get(mid) < k) l = mid+1;\\n        }\\n        return l;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309447,
                "title": "java",
                "content": "class RecentCounter {\\n    List<Integer> a;\\n    public RecentCounter() {\\n        a=new ArrayList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        int n=1;\\n        for(int i=a.size()-1;i>=0;i--)\\n        {\\n            if(t-a.get(i)>3000)\\n                break;\\n            n++;\\n        }\\n        a.add(t);\\n        return n;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */",
                "solutionTags": [],
                "code": "class RecentCounter {\\n    List<Integer> a;\\n    public RecentCounter() {\\n        a=new ArrayList<Integer>();\\n    }\\n    \\n    public int ping(int t) {\\n        int n=1;\\n        for(int i=a.size()-1;i>=0;i--)\\n        {\\n            if(t-a.get(i)>3000)\\n                break;\\n            n++;\\n        }\\n        a.add(t);\\n        return n;\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1296327,
                "title": "golang-solution-faster-than-100-with-quick-explanation",
                "content": "For this solution, we have got to look at something that is said in the problem description:\\n\\n> It is ***guaranteed*** that every call to ping uses a strictly larger value of `t` than the previous call.\\n\\nSo using that, we can make a variable (Which I called `k`) and store the position of the last position of the value that is greater than or equal to `t - 3000`. Then when we add a `t` to an array, and we can keep adding to `k` so we find the number of recent calls/\\n\\n``` go\\ntype RecentCounter struct {\\n    k int\\n    arr []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{0, []int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.arr = append(this.arr, t)\\n    \\n    for this.arr[this.k] < t - 3000 {\\n        this.k++\\n    }\\n    return len(this.arr) - this.k\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\ntype RecentCounter struct {\\n    k int\\n    arr []int\\n}\\n\\n\\nfunc Constructor() RecentCounter {\\n    return RecentCounter{0, []int{}}\\n}\\n\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n    this.arr = append(this.arr, t)\\n    \\n    for this.arr[this.k] < t - 3000 {\\n        this.k++\\n    }\\n    return len(this.arr) - this.k\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280732,
                "title": "using-min-heap-c-easy-approach",
                "content": "class RecentCounter {\\npublic:\\n    priority_queue<int,vector<int>,greater<int>>res;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        res.push(t);\\n               while(t-res.top()>3000)\\n               {\\n                   res.pop();\\n               }\\n           return res.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */",
                "solutionTags": [],
                "code": "class RecentCounter {\\npublic:\\n    priority_queue<int,vector<int>,greater<int>>res;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        res.push(t);\\n               while(t-res.top()>3000)\\n               {\\n                   res.pop();\\n               }\\n           return res.size();\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1204527,
                "title": "simple-c-solution",
                "content": "```\\n\\nclass RecentCounter {\\npublic:\\n    vector<int>v;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        v.push_back(t);\\n        int count=0;\\n        int l=t-3000;\\n        int u=t;\\n        for(int i=0;i<v.size();i++)\\n            if(v[i]>=l && v[i]<=u)\\n                count++;\\nreturn count;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass RecentCounter {\\npublic:\\n    vector<int>v;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        v.push_back(t);\\n        int count=0;\\n        int l=t-3000;\\n        int u=t;\\n        for(int i=0;i<v.size();i++)\\n            if(v[i]>=l && v[i]<=u)\\n                count++;\\nreturn count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181188,
                "title": "python-3-straightforward-solution",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n        \\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while self.queue[0] < (t - 3000):\\n            self.queue.pop(0)\\n        return len(self.queue)\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.queue = []\\n        \\n    def ping(self, t: int) -> int:\\n        self.queue.append(t)\\n        while self.queue[0] < (t - 3000):\\n            self.queue.pop(0)\\n        return len(self.queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166259,
                "title": "java-solution-100",
                "content": "```\\nclass RecentCounter {\\n    List<Integer> list;\\n    public RecentCounter() {\\n        list = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        list.add(t);\\n        int range = t - 3000;\\n        while(range > list.get(0)){\\n            list.remove(0);\\n        }\\n        return list.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    List<Integer> list;\\n    public RecentCounter() {\\n        list = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        list.add(t);\\n        int range = t - 3000;\\n        while(range > list.get(0)){\\n            list.remove(0);\\n        }\\n        return list.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1105645,
                "title": "108-ms-runtime-faster-than-100-c-solution",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    int counter;\\n    RecentCounter() {\\n        counter= 0;\\n    }\\n    queue<int> myQ;\\n    int ping(int t) {\\n        myQ.push(t);\\n        while(myQ.front()<(t-3000)){//[t - 3000, t]\\n            myQ.pop();\\n            counter--;\\n        }\\n        counter++;\\n        return counter;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    int counter;\\n    RecentCounter() {\\n        counter= 0;\\n    }\\n    queue<int> myQ;\\n    int ping(int t) {\\n        myQ.push(t);\\n        while(myQ.front()<(t-3000)){//[t - 3000, t]\\n            myQ.pop();\\n            counter--;\\n        }\\n        counter++;\\n        return counter;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036132,
                "title": "python3-sliding-window-solution",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.counter = []\\n\\n    def ping(self, t: int) -> int:\\n        self.counter.append(t)\\n        while self.counter[0] < (t - 3000):\\n            self.counter.pop(0)\\n        return len(self.counter)\\n```\\nAnother way :-\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.counter = []\\n        self.left = 0\\n    def ping(self, t: int) -> int:\\n        self.counter.append(t)\\n        while self.counter[self.left] < (t - 3000):\\n            self.left += 1\\n        return len(self.counter[self.left:])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.counter = []\\n\\n    def ping(self, t: int) -> int:\\n        self.counter.append(t)\\n        while self.counter[0] < (t - 3000):\\n            self.counter.pop(0)\\n        return len(self.counter)\\n```\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.counter = []\\n        self.left = 0\\n    def ping(self, t: int) -> int:\\n        self.counter.append(t)\\n        while self.counter[self.left] < (t - 3000):\\n            self.left += 1\\n        return len(self.counter[self.left:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023185,
                "title": "python-solution",
                "content": "```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.queue = collections.deque()\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.queue.append(t)\\n        while self.queue[0] < t - 3000:\\n            self.queue.popleft()\\n        return len(self.queue)\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.queue = collections.deque()\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.queue.append(t)\\n        while self.queue[0] < t - 3000:\\n            self.queue.popleft()\\n        return len(self.queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975776,
                "title": "priorityqueue-soln-java",
                "content": "```\\nclass RecentCounter {\\n\\n    PriorityQueue<Integer> queue;\\n    public RecentCounter() {\\n        queue = new PriorityQueue<>((a,b) -> a-b);\\n    }\\n    public int ping(int t) {\\n        queue.add(t);\\n        while(t-queue.peek()>3000)\\n            queue.poll();\\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n\\n    PriorityQueue<Integer> queue;\\n    public RecentCounter() {\\n        queue = new PriorityQueue<>((a,b) -> a-b);\\n    }\\n    public int ping(int t) {\\n        queue.add(t);\\n        while(t-queue.peek()>3000)\\n            queue.poll();\\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 949641,
                "title": "binary-search-solution",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> v;\\n    \\n    RecentCounter() {\\n       \\n    }\\n    \\n    int ping(int t) {\\n        v.push_back(t);\\n        \\n        int low = t - 3000;\\n        int high = t;\\n        \\n        auto lowIdx = lower_bound(v.begin(), v.end(), low);\\n        auto highIdx = upper_bound(v.begin(), v.end(), high);\\n        \\n        return highIdx - lowIdx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> v;\\n    \\n    RecentCounter() {\\n       \\n    }\\n    \\n    int ping(int t) {\\n        v.push_back(t);\\n        \\n        int low = t - 3000;\\n        int high = t;\\n        \\n        auto lowIdx = lower_bound(v.begin(), v.end(), low);\\n        auto highIdx = upper_bound(v.begin(), v.end(), high);\\n        \\n        return highIdx - lowIdx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915985,
                "title": "5-lines-easy-soln-beat-99-21-soln-using-queue",
                "content": "```\\nclass RecentCounter {\\npublic: queue<int>q;\\n    RecentCounter() {\\n      }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000)\\n        {q.pop();}\\n        return q.size();\\n    }\\n};\\n\\n```\\nhappy coding :)\\nplease upvote",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic: queue<int>q;\\n    RecentCounter() {\\n      }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000)\\n        {q.pop();}\\n        return q.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906722,
                "title": "c-queue",
                "content": "```\\nclass RecentCounter {\\n    queue<int> requests;\\n    int counter;\\npublic:\\n    RecentCounter() {\\n        counter = 0;\\n    }\\n    \\n    int ping(int t) {\\n        requests.push(t);\\n        counter++;\\n        while(requests.front() < t-3000) {\\n            requests.pop();\\n            counter--;\\n        }\\n        return counter;\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    queue<int> requests;\\n    int counter;\\npublic:\\n    RecentCounter() {\\n        counter = 0;\\n    }\\n    \\n    int ping(int t) {\\n        requests.push(t);\\n        counter++;\\n        while(requests.front() < t-3000) {\\n            requests.pop();\\n            counter--;\\n        }\\n        return counter;\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896064,
                "title": "python-3-manual-binary-search",
                "content": "```\\n    def __init__(self):\\n        self.pings = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        low = 0\\n        high = len(self.pings)-1\\n        while low<=high:\\n            mid = low + ((high-low)//2)\\n            if self.pings[mid] < t-3000:\\n                low = mid+1\\n            else:\\n                high = mid-1\\n        return len(self.pings)-max(high,low)\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\n    def __init__(self):\\n        self.pings = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        low = 0\\n        high = len(self.pings)-1\\n        while low<=high:\\n            mid = low + ((high-low)//2)\\n            if self.pings[mid] < t-3000:\\n                low = mid+1\\n            else:\\n                high = mid-1\\n        return len(self.pings)-max(high,low)\\n\\t\\t",
                "codeTag": "Python3"
            },
            {
                "id": 888330,
                "title": "simple-python-without-recursion",
                "content": "Because t always increasing, we can use a loop to drop values from our list of pings until the value is greater than or equal to the minimum window for the most recent ping. There is no requirement to keep all of the timings, so we can remove each value that doesn\\'t fall in the range. This will shorten the loop for future pings. Then the number of pings in the range is just the length of our list of pings.\\n\\n\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pingTimes = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pingTimes.append(t)\\n        i = 0\\n        while self.pingTimes[i] < t - 3000:\\n            self.pingTimes.pop(i)\\n        \\n        return len(self.pingTimes)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pingTimes = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pingTimes.append(t)\\n        i = 0\\n        while self.pingTimes[i] < t - 3000:\\n            self.pingTimes.pop(i)\\n        \\n        return len(self.pingTimes)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882160,
                "title": "c-simple-short-solution-using-queue",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() \\n    {\\n        queue<int> temp;\\n        q=temp;\\n    }\\n    \\n    int ping(int t) \\n    {\\n        q.push(t);\\n        while(!q.empty()&&q.front()<(t-3000))\\n            q.pop();\\n        return q.size();\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() \\n    {\\n        queue<int> temp;\\n        q=temp;\\n    }\\n    \\n    int ping(int t) \\n    {\\n        q.push(t);\\n        while(!q.empty()&&q.front()<(t-3000))\\n            q.pop();\\n        return q.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875595,
                "title": "recent-counter-c-3-line",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {}\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000)q.pop();\\n        return q.size();\\n    }    \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {}\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.front()<t-3000)q.pop();\\n        return q.size();\\n    }    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874715,
                "title": "python-number-of-recent-calls-easy-solution-using-priority-queue",
                "content": "```py\\nimport heapq\\nfrom typing import List\\n\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.timestamps: List[int] = []\\n\\n    def ping(self, t: int) -> int:\\n        heapq.heappush(self.timestamps, t)\\n        limit = t - 3000\\n        while self.timestamps[0] < limit:\\n            self.timestamps.pop(0)\\n        return len(self.timestamps)\\n\\n```",
                "solutionTags": [],
                "code": "```py\\nimport heapq\\nfrom typing import List\\n\\n\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.timestamps: List[int] = []\\n\\n    def ping(self, t: int) -> int:\\n        heapq.heappush(self.timestamps, t)\\n        limit = t - 3000\\n        while self.timestamps[0] < limit:\\n            self.timestamps.pop(0)\\n        return len(self.timestamps)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874688,
                "title": "c-3-lines-simple-o-n-time-o-1-o-3000-space",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.size() && q.front() < (t - 3000)) q.pop();\\n        return q.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    int ping(int t) {\\n        q.push(t);\\n        while(q.size() && q.front() < (t - 3000)) q.pop();\\n        return q.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874631,
                "title": "python-binary-search-a-bit-slower-but-effective-and-easy-to-understand",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.p=[]   \\n\\n    def ping(self, t: int) -> int:\\n        self.p.append(t)\\n        if(t<=3000):\\n            return len(self.p)\\n        else:\\n            target=t-3000\\n            s,e=0,len(self.p)\\n            while(s<=e):\\n                mid=(s+e)//2\\n                if(self.p[mid]==target):\\n                    return len(self.p[mid:])\\n                elif(self.p[mid]<target):\\n                    s=mid+1\\n                else:\\n                    e=mid-1\\n            return len(self.p[s:])\\n\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.p=[]   \\n\\n    def ping(self, t: int) -> int:\\n        self.p.append(t)\\n        if(t<=3000):\\n            return len(self.p)\\n        else:\\n            target=t-3000\\n            s,e=0,len(self.p)\\n            while(s<=e):\\n                mid=(s+e)//2\\n                if(self.p[mid]==target):\\n                    return len(self.p[mid:])\\n                elif(self.p[mid]<target):\\n                    s=mid+1\\n                else:\\n                    e=mid-1\\n            return len(self.p[s:])\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874622,
                "title": "anyone-can-understand-this-solution",
                "content": "```\\nclass RecentCounter {\\n\\n    CustomeLL root = null;//current node at time t\\n    CustomeLL prev = null;//last node, in range of 3000\\n    \\n    int time_interval = 3000;\\n    \\n    int request_count = 0;//number of request\\n    \\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        if(root==null){\\n            root = new CustomeLL(t);\\n            prev = root;\\n            request_count++;\\n        }else{\\n            root.next = new CustomeLL(t);\\n            root = root.next;\\n            request_count++; //when new time added, increment count\\n            \\n            //check if last time and current time is in range of 3000\\n            while(prev!=root && root.t-prev.t>time_interval){\\n                prev = prev.next;\\n                request_count--;\\n            }\\n        }\\n        return request_count;\\n    }\\n}\\n//cutome linked List\\nclass CustomeLL{\\n    CustomeLL next;\\n    int t;\\n    CustomeLL(int t){\\n        this.t = t;\\n        this.next = null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n\\n    CustomeLL root = null;//current node at time t\\n    CustomeLL prev = null;//last node, in range of 3000\\n    \\n    int time_interval = 3000;\\n    \\n    int request_count = 0;//number of request\\n    \\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        if(root==null){\\n            root = new CustomeLL(t);\\n            prev = root;\\n            request_count++;\\n        }else{\\n            root.next = new CustomeLL(t);\\n            root = root.next;\\n            request_count++; //when new time added, increment count\\n            \\n            //check if last time and current time is in range of 3000\\n            while(prev!=root && root.t-prev.t>time_interval){\\n                prev = prev.next;\\n                request_count--;\\n            }\\n        }\\n        return request_count;\\n    }\\n}\\n//cutome linked List\\nclass CustomeLL{\\n    CustomeLL next;\\n    int t;\\n    CustomeLL(int t){\\n        this.t = t;\\n        this.next = null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874365,
                "title": "javascript-clean-code-beat-99",
                "content": "```javascript\\nclass RecentCounter {\\n    constructor() {\\n        this.queue = [];\\n    }\\n    \\n    ping(t) {\\n        this.queue.push(t);\\n        while(this.queue[0] < t - 3000) this.queue.shift();\\n        return this.queue.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nclass RecentCounter {\\n    constructor() {\\n        this.queue = [];\\n    }\\n    \\n    ping(t) {\\n        this.queue.push(t);\\n        while(this.queue[0] < t - 3000) this.queue.shift();\\n        return this.queue.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874330,
                "title": "java-using-a-minheap-to-store-the-recent-pings",
                "content": "\\n```\\nclass RecentCounter {\\n    private static final int MAX_DURATION = 3000;\\n    private Queue<Integer> recentPings;\\n\\n    public RecentCounter() {\\n        this.recentPings = new PriorityQueue<>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!recentPings.isEmpty() && (t - recentPings.peek()) > MAX_DURATION) {\\n            recentPings.remove();\\n        }\\n        recentPings.add(t);\\n        return recentPings.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    private static final int MAX_DURATION = 3000;\\n    private Queue<Integer> recentPings;\\n\\n    public RecentCounter() {\\n        this.recentPings = new PriorityQueue<>();\\n    }\\n    \\n    public int ping(int t) {\\n        while(!recentPings.isEmpty() && (t - recentPings.peek()) > MAX_DURATION) {\\n            recentPings.remove();\\n        }\\n        recentPings.add(t);\\n        return recentPings.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874304,
                "title": "python-3-solution-using-list-runtime-beats-98-34",
                "content": "1. In the __init__ method, initialize requests list and size to 0.\\n2. In the ping method, when there is a ping and t is passed to it, add t to the requests lists and increment the size by 1.\\n3. If the first call in the requests list is more than or equal to t - 3000, then return the size.\\n4. Otherwise, remove from the requests list all the calls before t - 3000 and everytime a call is deleted using pop on the requests list, decrement the size by 1.\\nReturn the size.\\n\\n\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.requests = []\\n        self.size = 0\\n    \\n    def ping(self, t: int) -> int:\\n        self.requests.append(t)\\n        self.size += 1\\n        \\n        while self.requests[0] < t - 3000:\\n            self.requests.pop(0)\\n            self.size -= 1\\n            \\n        return(self.size)\\n            \\n    \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.requests = []\\n        self.size = 0\\n    \\n    def ping(self, t: int) -> int:\\n        self.requests.append(t)\\n        self.size += 1\\n        \\n        while self.requests[0] < t - 3000:\\n            self.requests.pop(0)\\n            self.size -= 1\\n            \\n        return(self.size)\\n            \\n    \\n\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter()\\n# param_1 = obj.ping(t)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874298,
                "title": "java-ring-buffer-bs-solution-99-perfomance",
                "content": "I expected more perfomance for my solution. WIth predef ring buffer. UPDATED\\nNew optimized solution:\\n```\\nclass RecentCounter {\\n\\n    private static final int THRESHOLD = 3000 + 1;\\n    private final int[] cyclicBuffer;\\n    private int head = -1;\\n    private int length;\\n\\n    public RecentCounter() {\\n        this.cyclicBuffer = new int[THRESHOLD];\\n    }\\n\\n     public int ping(int t) {\\n        cyclicBuffer[head = (head + 1) % THRESHOLD] = t;\\n\\n        int value = t - THRESHOLD + 1;\\n\\n        int l = 0;\\n        int r = length;\\n        int shift = head - length;\\n         \\n        while (l <= r) {\\n            int m = l + r >>> 1;\\n            int mShift = (THRESHOLD + (m + shift)) % THRESHOLD;\\n            if (cyclicBuffer[mShift] == value) \\n                return length = mShift > head ? THRESHOLD - mShift + head + 1 : head + 1 - mShift;\\n            if (cyclicBuffer[mShift] > value) r = m - 1;\\n            else l = m + 1;\\n        }\\n        int lShift = (THRESHOLD + (l + shift)) % THRESHOLD;\\n\\n        return length = lShift > head ? THRESHOLD - lShift + head + 1 : head + 1 - lShift;\\n    }\\n    \\n}\\n```\\n\\n\\nOld one:\\n\\n```\\nclass RecentCounter {\\n\\n    private static final int THRESHOLD = 3000 + 1;\\n    private final int[] cyclicBuffer;\\n    private int head = -1;\\n    private int tail = -1;\\n    private int length;\\n\\n    public RecentCounter() {\\n        this.cyclicBuffer = new int[THRESHOLD];\\n    }\\n\\n    public int ping(int t) {\\n        cyclicBuffer[head = (head + 1) % THRESHOLD] = t;\\n        if (head == tail || tail == -1) {\\n            tail = ++tail % THRESHOLD;\\n        }\\n        length = Math.min(length + 1, THRESHOLD);\\n\\n        int idx = findIdx(t - THRESHOLD + 1);\\n        length -= idx >= tail ? idx - tail : head - idx;\\n        tail = idx;\\n      \\n        return tail > head ? head + (THRESHOLD - tail + 1) : head - tail + 1;\\n    }\\n\\n    private int findIdx(int value) {\\n        int l = 0;\\n        int r = length - 1;\\n        int shift = head - (length - 1);\\n        while (l <= r) {\\n            int m = l + r >>> 1;\\n            int mShift = (THRESHOLD + (m + shift)) % THRESHOLD;\\n            if (cyclicBuffer[mShift] == value) return mShift;\\n            if (cyclicBuffer[mShift] > value) r = m - 1;\\n            else l = m + 1;\\n        }\\n        return (THRESHOLD + (l + shift)) % THRESHOLD;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass RecentCounter {\\n\\n    private static final int THRESHOLD = 3000 + 1;\\n    private final int[] cyclicBuffer;\\n    private int head = -1;\\n    private int length;\\n\\n    public RecentCounter() {\\n        this.cyclicBuffer = new int[THRESHOLD];\\n    }\\n\\n     public int ping(int t) {\\n        cyclicBuffer[head = (head + 1) % THRESHOLD] = t;\\n\\n        int value = t - THRESHOLD + 1;\\n\\n        int l = 0;\\n        int r = length;\\n        int shift = head - length;\\n         \\n        while (l <= r) {\\n            int m = l + r >>> 1;\\n            int mShift = (THRESHOLD + (m + shift)) % THRESHOLD;\\n            if (cyclicBuffer[mShift] == value) \\n                return length = mShift > head ? THRESHOLD - mShift + head + 1 : head + 1 - mShift;\\n            if (cyclicBuffer[mShift] > value) r = m - 1;\\n            else l = m + 1;\\n        }\\n        int lShift = (THRESHOLD + (l + shift)) % THRESHOLD;\\n\\n        return length = lShift > head ? THRESHOLD - lShift + head + 1 : head + 1 - lShift;\\n    }\\n    \\n}\\n```\n```\\nclass RecentCounter {\\n\\n    private static final int THRESHOLD = 3000 + 1;\\n    private final int[] cyclicBuffer;\\n    private int head = -1;\\n    private int tail = -1;\\n    private int length;\\n\\n    public RecentCounter() {\\n        this.cyclicBuffer = new int[THRESHOLD];\\n    }\\n\\n    public int ping(int t) {\\n        cyclicBuffer[head = (head + 1) % THRESHOLD] = t;\\n        if (head == tail || tail == -1) {\\n            tail = ++tail % THRESHOLD;\\n        }\\n        length = Math.min(length + 1, THRESHOLD);\\n\\n        int idx = findIdx(t - THRESHOLD + 1);\\n        length -= idx >= tail ? idx - tail : head - idx;\\n        tail = idx;\\n      \\n        return tail > head ? head + (THRESHOLD - tail + 1) : head - tail + 1;\\n    }\\n\\n    private int findIdx(int value) {\\n        int l = 0;\\n        int r = length - 1;\\n        int shift = head - (length - 1);\\n        while (l <= r) {\\n            int m = l + r >>> 1;\\n            int mShift = (THRESHOLD + (m + shift)) % THRESHOLD;\\n            if (cyclicBuffer[mShift] == value) return mShift;\\n            if (cyclicBuffer[mShift] > value) r = m - 1;\\n            else l = m + 1;\\n        }\\n        return (THRESHOLD + (l + shift)) % THRESHOLD;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874257,
                "title": "number-of-recent-calls-java-queue",
                "content": "```\\nclass RecentCounter {\\n    \\n    Queue<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue= new LinkedList();\\n    }\\n    \\n    public int ping(int t) {\\n        \\n        int start = t-3000;\\n        while(!queue.isEmpty() && queue.peek()<start) queue.poll();\\n        \\n        queue.add(t);\\n        \\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    \\n    Queue<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue= new LinkedList();\\n    }\\n    \\n    public int ping(int t) {\\n        \\n        int start = t-3000;\\n        while(!queue.isEmpty() && queue.peek()<start) queue.poll();\\n        \\n        queue.add(t);\\n        \\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874195,
                "title": "simple-javascript",
                "content": "```\\nvar RecentCounter = function() {\\n    this.req = [];\\n};\\n\\nRecentCounter.prototype.ping = function(t) {\\n    this.req.push(t);\\n    let range = [t - 3000, t];\\n    let res = 0;\\n    for (let i = 0; i < this.req.length; i++)\\n    {\\n        if (this.req[i] >= range[0] && this.req[i] <= range[1])\\n            res++;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar RecentCounter = function() {\\n    this.req = [];\\n};\\n\\nRecentCounter.prototype.ping = function(t) {\\n    this.req.push(t);\\n    let range = [t - 3000, t];\\n    let res = 0;\\n    for (let i = 0; i < this.req.length; i++)\\n    {\\n        if (this.req[i] >= range[0] && this.req[i] <= range[1])\\n            res++;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 874125,
                "title": "java-faster-than-99",
                "content": "I had a variable to track the index of the lowest ping time within the valid range (most recent time - 3000), and updated it each time I added a time to the list.\\n\\n```\\nclass RecentCounter {\\n\\n    /**\\n     * List of all ping requests made.\\n     */\\n    private List<Integer> requests;\\n    \\n    /**\\n     * The index containing the the first element whose value is at most 3000\\n     * less than the last element.\\n     */\\n    private int minIndex;\\n    \\n    public RecentCounter() {\\n        requests = new ArrayList<>();\\n        minIndex = 0;\\n    }\\n    \\n    public int ping(int t) {\\n        requests.add(t); // Add new request\\n        \\n        // Increment minIndex until the element at minIndex is the first element in the 3000 range\\n        while(requests.get(minIndex) < t - 3000 && minIndex < requests.size() - 1) minIndex++;\\n        \\n        \\n        // Number of requests in range is the number of total requests minus\\n        // the index of the first element in the range\\n        return requests.size() - minIndex;\\n    }\\n}\\n ```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n\\n    /**\\n     * List of all ping requests made.\\n     */\\n    private List<Integer> requests;\\n    \\n    /**\\n     * The index containing the the first element whose value is at most 3000\\n     * less than the last element.\\n     */\\n    private int minIndex;\\n    \\n    public RecentCounter() {\\n        requests = new ArrayList<>();\\n        minIndex = 0;\\n    }\\n    \\n    public int ping(int t) {\\n        requests.add(t); // Add new request\\n        \\n        // Increment minIndex until the element at minIndex is the first element in the 3000 range\\n        while(requests.get(minIndex) < t - 3000 && minIndex < requests.size() - 1) minIndex++;\\n        \\n        \\n        // Number of requests in range is the number of total requests minus\\n        // the index of the first element in the range\\n        return requests.size() - minIndex;\\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 873933,
                "title": "c-very-simple-using-queue-100-runtime",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        while(!q_.empty() && q_.front() + 3000 < t) {\\n            q_.pop_front();\\n        }\\n        q_.push_back(t);\\n        return q_.size();\\n    }\\n\\nprivate:\\n    deque<int> q_;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        while(!q_.empty() && q_.front() + 3000 < t) {\\n            q_.pop_front();\\n        }\\n        q_.push_back(t);\\n        return q_.size();\\n    }\\n\\nprivate:\\n    deque<int> q_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873829,
                "title": "double-ended-queue-solution-in-rust",
                "content": "```\\nuse std::collections::VecDeque;\\nuse std::cell::RefCell;\\n\\nstruct RecentCounter {\\n    reqs: RefCell<VecDeque<i32>>,\\n}\\n\\nimpl RecentCounter {\\n\\n    fn new() -> Self {\\n        Self { reqs: RefCell::new(VecDeque::new()) }\\n    }\\n    \\n    fn ping(&self, t: i32) -> i32 {\\n        let mut reqs = self.reqs.borrow_mut();\\n        reqs.push_back(t);\\n        while reqs.front().unwrap() < &(t - 3000) {\\n            reqs.pop_front();\\n        }\\n        reqs.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::VecDeque;\\nuse std::cell::RefCell;\\n\\nstruct RecentCounter {\\n    reqs: RefCell<VecDeque<i32>>,\\n}\\n\\nimpl RecentCounter {\\n\\n    fn new() -> Self {\\n        Self { reqs: RefCell::new(VecDeque::new()) }\\n    }\\n    \\n    fn ping(&self, t: i32) -> i32 {\\n        let mut reqs = self.reqs.borrow_mut();\\n        reqs.push_back(t);\\n        while reqs.front().unwrap() < &(t - 3000) {\\n            reqs.pop_front();\\n        }\\n        reqs.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 873712,
                "title": "java-recent-calls-97-queue-well-explained-max-space-time-of-3k-constant-space",
                "content": "\\nSince we need to store only recent events, to avoid filling up space, we should remove older elements with event time greater than 3000.\\nSo for any event, if it\\'s event time is less than , current time - 3000, ie. if eventTime < t-3000, remove that event.\\nWe initially store all the event in a queue,  Basically store an event time in a queue.\\n\\nThe size of queue gives total number of events.\\nSince we are removing older elements, we ONLY have elements in the queue within 3000 time limit.\\nHence we return the queue size everytime.\\nWe dequeue elements from the queue, until all old elements are removed.\\n\\n```\\nclass RecentCounter {\\n\\n    Queue<Integer> recentEvents;\\n    \\n    public RecentCounter() {\\n      recentEvents = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        //while queue is not empty, and still holds events with event time more than 3000, remove those events\\n        while(recentEvents.size()>0 && recentEvents.peek()<t-3000){\\n            recentEvents.remove();\\n        }\\n        recentEvents.add(t);\\n        return recentEvents.size();\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n\\n    Queue<Integer> recentEvents;\\n    \\n    public RecentCounter() {\\n      recentEvents = new LinkedList<>();\\n    }\\n    \\n    public int ping(int t) {\\n        //while queue is not empty, and still holds events with event time more than 3000, remove those events\\n        while(recentEvents.size()>0 && recentEvents.peek()<t-3000){\\n            recentEvents.remove();\\n        }\\n        recentEvents.add(t);\\n        return recentEvents.size();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873705,
                "title": "java-priorityqueue-solution",
                "content": "```\\nclass RecentCounter {\\n    PriorityQueue<Integer> pq;\\n\\n    public RecentCounter() {\\n        pq = new PriorityQueue<Integer>(new Comparator<Integer>() {\\n            public int compare(Integer a, Integer b) {\\n                return a - b;\\n            }\\n        });\\n    }\\n    \\n    public int ping(int t) {\\n        pq.add(t);\\n        while(!pq.isEmpty() && pq.peek() < (t - 3000)) {\\n            pq.poll();\\n        }\\n        return pq.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass RecentCounter {\\n    PriorityQueue<Integer> pq;\\n\\n    public RecentCounter() {\\n        pq = new PriorityQueue<Integer>(new Comparator<Integer>() {\\n            public int compare(Integer a, Integer b) {\\n                return a - b;\\n            }\\n        });\\n    }\\n    \\n    public int ping(int t) {\\n        pq.add(t);\\n        while(!pq.isEmpty() && pq.peek() < (t - 3000)) {\\n            pq.poll();\\n        }\\n        return pq.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873380,
                "title": "question-explained-python-code-video-code",
                "content": "[](https://www.youtube.com/watch?v=NtNeA48tJDk)\\nhttps://www.youtube.com/watch?v=NtNeA48tJDk\\n```\\nimport collections\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while self.q[0] < t - 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nimport collections\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.q = collections.deque()\\n\\n    def ping(self, t: int) -> int:\\n        self.q.append(t)\\n        \\n        while self.q[0] < t - 3000:\\n            self.q.popleft()\\n            \\n        return len(self.q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873355,
                "title": "c-simplest-solution-possible-beats-100-with-explanation-comments",
                "content": "```\\nclass RecentCounter {\\npublic:\\n\\t// Queue for storing requests\\n    queue<int> req;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        // If the queue contains elements which will not come in the [t-3000, t] range then pop them.\\n\\t\\t// Example: Queue: [24, 42, 45, 90] and the request comes at 6000 sec.\\n\\t\\t// Then we have to pop all the elements in the queue as they don\\'t fit into [3000, 6000] range.\\n\\t\\t\\n        while(!req.empty() && req.front() + 3000 < t){\\n            req.pop();\\n        }\\n        // Now, pushing the current request.\\n        req.push(t);\\n\\t\\t// The size of the queue will be the answer as the elements will be in the range [t-3000, t].\\n        return req.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n\\t// Queue for storing requests\\n    queue<int> req;\\n    RecentCounter() {\\n    }\\n    \\n    int ping(int t) {\\n        // If the queue contains elements which will not come in the [t-3000, t] range then pop them.\\n\\t\\t// Example: Queue: [24, 42, 45, 90] and the request comes at 6000 sec.\\n\\t\\t// Then we have to pop all the elements in the queue as they don\\'t fit into [3000, 6000] range.\\n\\t\\t\\n        while(!req.empty() && req.front() + 3000 < t){\\n            req.pop();\\n        }\\n        // Now, pushing the current request.\\n        req.push(t);\\n\\t\\t// The size of the queue will be the answer as the elements will be in the range [t-3000, t].\\n        return req.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873318,
                "title": "java-easy-to-understand-concise-queue",
                "content": "**if helpful.... please do Upvote**\\n**Time / space Complexity: O(Math.min(N, 3000))**\\n```\\nclass RecentCounter {\\n    \\n    // It actually means the total numbers of pings within its range 3000.\\n    // 1 then count total number 1 (1-3001)\\n    // 2 then count total number 2 because previous 1 is also within its 3000 range. (1-3001)\\n    // then 3001 count total number 3 because 1 , 2 is within its 3000 range. ( also from 1- 3001)\\n    // then 3302 count total number 3 because 1 is out of its range and be omitted,\\n\\t//but then add 3002 itself. the total number 3 here is not the same meaning as previous total number 3( here is 2-3002, previous 3 is 1-3001)\\n    \\n    Queue<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue=new LinkedList<>();       \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.peek()<t-3000){\\n            queue.remove();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RecentCounter {\\n    \\n    // It actually means the total numbers of pings within its range 3000.\\n    // 1 then count total number 1 (1-3001)\\n    // 2 then count total number 2 because previous 1 is also within its 3000 range. (1-3001)\\n    // then 3001 count total number 3 because 1 , 2 is within its 3000 range. ( also from 1- 3001)\\n    // then 3302 count total number 3 because 1 is out of its range and be omitted,\\n\\t//but then add 3002 itself. the total number 3 here is not the same meaning as previous total number 3( here is 2-3002, previous 3 is 1-3001)\\n    \\n    Queue<Integer> queue;\\n    \\n    public RecentCounter() {\\n        queue=new LinkedList<>();       \\n    }\\n    \\n    public int ping(int t) {\\n        queue.add(t);\\n        while(queue.peek()<t-3000){\\n            queue.remove();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873306,
                "title": "c-easy-and-short-solution-queue",
                "content": "```\\nclass RecentCounter {\\n    priority_queue<int, vector<int>, greater<int> > pq;\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        while( !pq.empty() && t - 3000 > pq.top() ) \\n            pq.pop(); \\n        pq.push(t);\\n        return pq.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    priority_queue<int, vector<int>, greater<int> > pq;\\npublic:\\n    RecentCounter() {}\\n    \\n    int ping(int t) {\\n        while( !pq.empty() && t - 3000 > pq.top() ) \\n            pq.pop(); \\n        pq.push(t);\\n        return pq.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873192,
                "title": "number-of-recent-calls-cpp",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> a;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        int c=0;\\n        int min=t-3000>t?t:t-3000;\\n        int max=t-3000>t?t-3000:t;\\n        a.push_back(t);\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]<min){\\n                c++;\\n            }\\n        }\\n     return a.size()-c;   \\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> a;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        int c=0;\\n        int min=t-3000>t?t:t-3000;\\n        int max=t-3000>t?t-3000:t;\\n        a.push_back(t);\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]<min){\\n                c++;\\n            }\\n        }\\n     return a.size()-c;   \\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 722615,
                "title": "c-here-s-my-approach-pretty-hard-to-understand-question-simple-solution",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> prev;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        if(prev.empty()){\\n            prev.push_back(t);\\n            return 1;\\n        }\\n        else{\\n            int val = t - 3000;\\n            int count = 0;\\n            for(int i = prev.size() -1 ;i>=0 && val <= prev[i];i--){\\n                count++;\\n            }\\n            if(count == 0)  prev.clear();\\n            prev.push_back(t);\\n            return count + 1;\\n        }\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    vector<int> prev;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        if(prev.empty()){\\n            prev.push_back(t);\\n            return 1;\\n        }\\n        else{\\n            int val = t - 3000;\\n            int count = 0;\\n            for(int i = prev.size() -1 ;i>=0 && val <= prev[i];i--){\\n                count++;\\n            }\\n            if(count == 0)  prev.clear();\\n            prev.push_back(t);\\n            return count + 1;\\n        }\\n    }\\n};\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter* obj = new RecentCounter();\\n * int param_1 = obj->ping(t);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 662551,
                "title": "simple-solution-by-python-3",
                "content": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        while self.pings[0] < t - 3000:\\n            self.pings.pop(0)\\n        return len(self.pings)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        self.pings = []\\n\\n    def ping(self, t: int) -> int:\\n        self.pings.append(t)\\n        while self.pings[0] < t - 3000:\\n            self.pings.pop(0)\\n        return len(self.pings)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627188,
                "title": "go-solution-with-queue",
                "content": "``` go\\nimport \"container/list\"\\n\\ntype RecentCounter struct {\\n\\tqueue *list.List\\n}\\n\\nfunc Constructor() RecentCounter {\\n\\treturn RecentCounter{queue: list.New()}\\n}\\n\\n// Learning: Elements from the list need to be cast into specific type before being used.\\nfunc (this *RecentCounter) Ping(t int) int {\\n\\tthis.queue.PushBack(t)\\n\\tfor this.queue.Front().Value.(int) < t-3000 {\\n\\t\\tthis.queue.Remove(this.queue.Front())\\n\\t}\\n\\n\\treturn this.queue.Len()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nimport \"container/list\"\\n\\ntype RecentCounter struct {\\n\\tqueue *list.List\\n}\\n\\nfunc Constructor() RecentCounter {\\n\\treturn RecentCounter{queue: list.New()}\\n}\\n\\n// Learning: Elements from the list need to be cast into specific type before being used.\\nfunc (this *RecentCounter) Ping(t int) int {\\n\\tthis.queue.PushBack(t)\\n\\tfor this.queue.Front().Value.(int) < t-3000 {\\n\\t\\tthis.queue.Remove(this.queue.Front())\\n\\t}\\n\\n\\treturn this.queue.Len()\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 600880,
                "title": "simple-java-solution-for-slow-learners-like-myself",
                "content": "```\\nclass RecentCounter {\\n    private final Queue<Integer> queue = new LinkedList<>();\\n    \\n    public int ping(int t) {\\n        while (!queue.isEmpty() && queue.peek() < t - 3000)\\n            queue.poll();\\n        queue.offer(t);\\n        \\n        return queue.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\n    private final Queue<Integer> queue = new LinkedList<>();\\n    \\n    public int ping(int t) {\\n        while (!queue.isEmpty() && queue.peek() < t - 3000)\\n            queue.poll();\\n        queue.offer(t);\\n        \\n        return queue.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583861,
                "title": "java-100-faster-solution",
                "content": "```\\nclass RecentCounter {\\n    Queue<Integer> queue = new LinkedList();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        queue.offer(t);\\n        while(queue.peek() < (t - 3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\n    Queue<Integer> queue = new LinkedList();\\n    public RecentCounter() {\\n        \\n    }\\n    \\n    public int ping(int t) {\\n        queue.offer(t);\\n        while(queue.peek() < (t - 3000)){\\n            queue.poll();\\n        }\\n        return queue.size();\\n    }\\n}\\n\\n/**\\n * Your RecentCounter object will be instantiated and called as such:\\n * RecentCounter obj = new RecentCounter();\\n * int param_1 = obj.ping(t);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581876,
                "title": "go-clean-code-112ms-beats-100",
                "content": "```\\ntype RecentCounter struct {\\n\\tqueue []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n\\treturn RecentCounter{}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n\\tthis.queue = append(this.queue, t)\\n\\tfor this.queue[0]+3000 < t {\\n\\t\\tthis.queue = this.queue[1:]\\n\\t}\\n\\treturn len(this.queue)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype RecentCounter struct {\\n\\tqueue []int\\n}\\n\\nfunc Constructor() RecentCounter {\\n\\treturn RecentCounter{}\\n}\\n\\nfunc (this *RecentCounter) Ping(t int) int {\\n\\tthis.queue = append(this.queue, t)\\n\\tfor this.queue[0]+3000 < t {\\n\\t\\tthis.queue = this.queue[1:]\\n\\t}\\n\\treturn len(this.queue)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 572853,
                "title": "if-u-understood-the-q-its-a-joke",
                "content": "**Let me explain the Q first in simpler words**\\nAccording to  the Q at a time **t** when a message pings then it will stay in the notification till 3000 ms after that it will disappear.We need to tell the number of messages in notifications at time t when the current ping is done.\\n\\nSay \\nt=**0** ,, notification= 0 **(1)**\\nt=**100** ,, notification= 0,100 **(2)**\\nt=**1500** ,, notification= 0,100,1500 **(3)**\\nt=**3001** ,, notification= 100,1500,3001 **(3)**\\n**(Notice that at t=3001ms notificcation message which arrived at 0ms disappeared)**\\nt=**3099** ,, norification = 100,1500,3001,3099 **(4)**\\nt=**3101** ,, notification= 1500,3001,3099,3101 **(4)**\\n**(Notice that at t=3101ms notificcation message which arrived at 100ms disappeared)**\\n\\n\\nSo logic is simple the one at first come will first go so we need just a queue\\n```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);                                               //At time t only [(t-3000)->t] will remain in the queue\\n        while(q.front()<(t-3000))\\n            q.pop();\\n        return q.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> q;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);                                               //At time t only [(t-3000)->t] will remain in the queue\\n        while(q.front()<(t-3000))\\n            q.pop();\\n        return q.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547013,
                "title": "ruby-solution-with-custom-kueue-class",
                "content": "```\\nclass RecentCounter\\n    def initialize()\\n        @queue = Kueue.new\\n    end\\n\\n\\n=begin\\n    :type t: Integer\\n    :rtype: Integer\\n=end\\n    def ping(t)\\n        @queue.enq(t)\\n        if @queue.size > 0\\n            while t - @queue.peek > 3000\\n                @queue.shift\\n            end\\n        end\\n        @queue.size\\n    end\\n\\n\\nend\\n\\nclass Kueue\\n   \\n    attr_reader :kueue \\n    \\n    def initialize\\n        @kueue = []\\n    end\\n    \\n    def peek\\n        kueue[0]\\n    end\\n    \\n    def enq(x)\\n        @kueue << x\\n    end\\n    \\n    def shift\\n        @kueue.shift\\n    end\\n    \\n    def size\\n       kueue.length \\n    end\\nend\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter.new()\\n# param_1 = obj.ping(t)\\n```\\n\\nRuby\\'s built-in queue class does not support peeking at the first item without removing it. \\xAF\\\\\\\\_(\\u30C4)_/\\xAF Faster than 45.45% of solutions, 100% less memory. \\n\\n",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter\\n    def initialize()\\n        @queue = Kueue.new\\n    end\\n\\n\\n=begin\\n    :type t: Integer\\n    :rtype: Integer\\n=end\\n    def ping(t)\\n        @queue.enq(t)\\n        if @queue.size > 0\\n            while t - @queue.peek > 3000\\n                @queue.shift\\n            end\\n        end\\n        @queue.size\\n    end\\n\\n\\nend\\n\\nclass Kueue\\n   \\n    attr_reader :kueue \\n    \\n    def initialize\\n        @kueue = []\\n    end\\n    \\n    def peek\\n        kueue[0]\\n    end\\n    \\n    def enq(x)\\n        @kueue << x\\n    end\\n    \\n    def shift\\n        @kueue.shift\\n    end\\n    \\n    def size\\n       kueue.length \\n    end\\nend\\n\\n# Your RecentCounter object will be instantiated and called as such:\\n# obj = RecentCounter.new()\\n# param_1 = obj.ping(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529902,
                "title": "c-this-question-sucks-heres-a-commented-90-queue-solution",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    std::queue<int> q;\\n    RecentCounter() {\\n        return;\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n\\t\\t// Remove all pings that are too old\\n        while(!q.empty() and q.front() < t - 3000) q.pop();\\n\\t\\t// Return how many pings remain\\n        return q.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    std::queue<int> q;\\n    RecentCounter() {\\n        return;\\n    }\\n    \\n    int ping(int t) {\\n        q.push(t);\\n\\t\\t// Remove all pings that are too old\\n        while(!q.empty() and q.front() < t - 3000) q.pop();\\n\\t\\t// Return how many pings remain\\n        return q.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489645,
                "title": "c-using-queues",
                "content": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> que;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        this->que.push(t);\\n        while(que.front()<(t-3000))\\n        {\\n            que.pop();\\n        }\\n        return que.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RecentCounter {\\npublic:\\n    queue<int> que;\\n    RecentCounter() {\\n        \\n    }\\n    \\n    int ping(int t) {\\n        this->que.push(t);\\n        while(que.front()<(t-3000))\\n        {\\n            que.pop();\\n        }\\n        return que.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485711,
                "title": "simple-js-100-memory-and-100-time-optimal",
                "content": "\\n```\\nvar RecentCounter = function() {\\n    this.arr = [];\\n    this.start = 0;\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n    this.arr.push(t);\\n    while(this.arr[this.start] < t - 3000) {\\n        this.start++;\\n    }\\n    return this.arr.length - this.start;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar RecentCounter = function() {\\n    this.arr = [];\\n    this.start = 0;\\n};\\n\\n/** \\n * @param {number} t\\n * @return {number}\\n */\\nRecentCounter.prototype.ping = function(t) {\\n    this.arr.push(t);\\n    while(this.arr[this.start] < t - 3000) {\\n        this.start++;\\n    }\\n    return this.arr.length - this.start;\\n};\\n\\n/** \\n * Your RecentCounter object will be instantiated and called as such:\\n * var obj = new RecentCounter()\\n * var param_1 = obj.ping(t)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 476693,
                "title": "python-by-double-ended-queue-run-time-90-with-explanation",
                "content": "Python by double-ended queue\\n\\n```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        \\n        # a double-ended queue that keep fresh calls in math interval [t-3000, t]\\n        self.call_queue = collections.deque()\\n\\n\\n\\n    def ping(self, t: int) -> int:\\n        \\n        # pop out-of-date calls which calling time is smaller than t-3000 on the front\\n        while self.call_queue and self.call_queue[0] < t-3000:    \\n            self.call_queue.popleft()\\n        \\n        \\n        # push in-coming call on the rear\\n        self.call_queue.append(t)\\n        \\n        \\n        return len(self.call_queue)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass RecentCounter:\\n\\n    def __init__(self):\\n        \\n        # a double-ended queue that keep fresh calls in math interval [t-3000, t]\\n        self.call_queue = collections.deque()\\n\\n\\n\\n    def ping(self, t: int) -> int:\\n        \\n        # pop out-of-date calls which calling time is smaller than t-3000 on the front\\n        while self.call_queue and self.call_queue[0] < t-3000:    \\n            self.call_queue.popleft()\\n        \\n        \\n        # push in-coming call on the rear\\n        self.call_queue.append(t)\\n        \\n        \\n        return len(self.call_queue)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 469308,
                "title": "short-kotlin-solution",
                "content": "```\\nclass RecentCounter() {\\n    \\n    var pings = listOf<Int>()\\n    \\n    fun ping(t: Int): Int {\\n        pings = pings.filter {it in (t - 3000)..t} + t\\n        return pings.size\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RecentCounter() {\\n    \\n    var pings = listOf<Int>()\\n    \\n    fun ping(t: Int): Int {\\n        pings = pings.filter {it in (t - 3000)..t} + t\\n        return pings.size\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459575,
                "title": "c-solution-queue-t",
                "content": "Every time Ping is called we use the queue to remove any times that happened more than 3000 ms ago. The queue data struture is ideal for this problem because the oldest pings are stored at the end of the queue. When we get a new ping we just dequeue pings while they are invalid. Then we enque the new ping timestamp and return the Count value of our queue.\\n\\nAlso I made a custom queue that I used to solve the problem on my first attempt.  The custom queue was mainly created as an exercise to understand how a variable size queue is actually stored and the result is a bit rough I think. I included it below, but feel free to ignore it.\\n\\nBasically the queue keeps grows like a circular array until it is full, then all the contents are copied into a new array that is double the size of the previous one. I did not code in any mechanism for the array container to shrink though.\\n\\n```\\npublic class RecentCounter\\n    {\\n\\n        Queue<int> queue;\\n        public RecentCounter()\\n        {\\n            queue = new Queue<int>();\\n        }\\n\\n        public int Ping(int t)\\n        {\\n            \\n            for (int i = 0; i < queue.Count; i++)\\n            {\\n                int headValue = queue.Peek();\\n                if (t - headValue <= 3000)\\n                    break;\\n                queue.Dequeue();\\n            }\\n            queue.Enqueue(t);\\n            return queue.Count;\\n        }\\n    }\\n\\t\\n\\tpublic class RecentCounterCustomQueue\\n    {\\n\\n        VariableSizeQueue<int> queue;\\n        public RecentCounterCustomQueue()\\n        {\\n            queue = new VariableSizeQueue<int>(10, -1);\\n        }\\n\\n        public int Ping(int t)\\n        {\\n            queue.Enqueue(t);\\n            int startingCount = queue.Count - 1;\\n            for (int i = 0; i < startingCount; i++)\\n            {\\n                int headValue = queue.Peek();\\n                if (t - headValue <= 3000)\\n                    break;\\n                queue.Dequeue();\\n            }\\n            return queue.Count;\\n        }\\n    }\\n\\n    public class VariableSizeQueue<T>\\n    {\\n        public VariableSizeQueue(int capacity, T sentinelValue)\\n        {\\n            QueueInternal = new T[capacity];\\n            this.SentinelValue = sentinelValue;\\n        }\\n\\n        public T SentinelValue;\\n        public int Capacity\\n        {\\n            get => QueueInternal.Length;\\n        }\\n        public int Count = 0;\\n        public T[] QueueInternal;\\n\\n        public int QueueHeadIndex = 0;\\n        public int QueueTailIndex = 0;\\n\\n        public void Enqueue(T item)\\n        {\\n            if (QueueTailIndex == QueueHeadIndex && Count != 0)\\n                ResizeQueue();\\n            QueueInternal[QueueTailIndex] = item;\\n            Count++;\\n            QueueTailIndex = (QueueTailIndex + 1) % Capacity;\\n        }\\n\\n        //only called internally when all queue is completly full\\n        private void ResizeQueue()\\n        {\\n            //Create a new Queue starting from the beginning\\n            T[] resizedQueue = new T[Capacity * 2];\\n            int j = 0;\\n            for (int i = QueueHeadIndex; j < Capacity; i = (i + 1) % Capacity)\\n            {\\n                resizedQueue[j] = QueueInternal[i];\\n                j++;\\n            }\\n\\n            //change all of the pointers\\n            QueueHeadIndex = 0;\\n            QueueTailIndex = (Capacity);//tail will go one index to the end of old data\\n\\n            QueueInternal = resizedQueue;\\n        }\\n\\n        public T Peek()\\n        {\\n            if (Count == 0)\\n                return SentinelValue;\\n            return QueueInternal[QueueHeadIndex];\\n        }\\n\\n        public T Dequeue()\\n        {\\n            if (Count == 0)\\n                return SentinelValue;\\n\\n            T head = QueueInternal[QueueHeadIndex];\\n            QueueInternal[QueueHeadIndex] = SentinelValue;\\n            QueueHeadIndex = (QueueHeadIndex + 1) % Capacity;\\n            Count--;\\n            return head;\\n        }\\n\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "Every time Ping is called we use the queue to remove any times that happened more than 3000 ms ago. The queue data struture is ideal for this problem because the oldest pings are stored at the end of the queue. When we get a new ping we just dequeue pings while they are invalid. Then we enque the new ping timestamp and return the Count value of our queue.\\n\\nAlso I made a custom queue that I used to solve the problem on my first attempt.  The custom queue was mainly created as an exercise to understand how a variable size queue is actually stored and the result is a bit rough I think. I included it below, but feel free to ignore it.\\n\\nBasically the queue keeps grows like a circular array until it is full, then all the contents are copied into a new array that is double the size of the previous one. I did not code in any mechanism for the array container to shrink though.\\n\\n```\\npublic class RecentCounter\\n    {\\n\\n        Queue<int> queue;\\n        public RecentCounter()\\n        {\\n            queue = new Queue<int>();\\n        }\\n\\n        public int Ping(int t)\\n        {\\n            \\n            for (int i = 0; i < queue.Count; i++)\\n            {\\n                int headValue = queue.Peek();\\n                if (t - headValue <= 3000)\\n                    break;\\n                queue.Dequeue();\\n            }\\n            queue.Enqueue(t);\\n            return queue.Count;\\n        }\\n    }\\n\\t\\n\\tpublic class RecentCounterCustomQueue\\n    {\\n\\n        VariableSizeQueue<int> queue;\\n        public RecentCounterCustomQueue()\\n        {\\n            queue = new VariableSizeQueue<int>(10, -1);\\n        }\\n\\n        public int Ping(int t)\\n        {\\n            queue.Enqueue(t);\\n            int startingCount = queue.Count - 1;\\n            for (int i = 0; i < startingCount; i++)\\n            {\\n                int headValue = queue.Peek();\\n                if (t - headValue <= 3000)\\n                    break;\\n                queue.Dequeue();\\n            }\\n            return queue.Count;\\n        }\\n    }\\n\\n    public class VariableSizeQueue<T>\\n    {\\n        public VariableSizeQueue(int capacity, T sentinelValue)\\n        {\\n            QueueInternal = new T[capacity];\\n            this.SentinelValue = sentinelValue;\\n        }\\n\\n        public T SentinelValue;\\n        public int Capacity\\n        {\\n            get => QueueInternal.Length;\\n        }\\n        public int Count = 0;\\n        public T[] QueueInternal;\\n\\n        public int QueueHeadIndex = 0;\\n        public int QueueTailIndex = 0;\\n\\n        public void Enqueue(T item)\\n        {\\n            if (QueueTailIndex == QueueHeadIndex && Count != 0)\\n                ResizeQueue();\\n            QueueInternal[QueueTailIndex] = item;\\n            Count++;\\n            QueueTailIndex = (QueueTailIndex + 1) % Capacity;\\n        }\\n\\n        //only called internally when all queue is completly full\\n        private void ResizeQueue()\\n        {\\n            //Create a new Queue starting from the beginning\\n            T[] resizedQueue = new T[Capacity * 2];\\n            int j = 0;\\n            for (int i = QueueHeadIndex; j < Capacity; i = (i + 1) % Capacity)\\n            {\\n                resizedQueue[j] = QueueInternal[i];\\n                j++;\\n            }\\n\\n            //change all of the pointers\\n            QueueHeadIndex = 0;\\n            QueueTailIndex = (Capacity);//tail will go one index to the end of old data\\n\\n            QueueInternal = resizedQueue;\\n        }\\n\\n        public T Peek()\\n        {\\n            if (Count == 0)\\n                return SentinelValue;\\n            return QueueInternal[QueueHeadIndex];\\n        }\\n\\n        public T Dequeue()\\n        {\\n            if (Count == 0)\\n                return SentinelValue;\\n\\n            T head = QueueInternal[QueueHeadIndex];\\n            QueueInternal[QueueHeadIndex] = SentinelValue;\\n            QueueHeadIndex = (QueueHeadIndex + 1) % Capacity;\\n            Count--;\\n            return head;\\n        }\\n\\n    }\\n\\t\\n\\t",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564925,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1565392,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1566126,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1826057,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1905405,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1566562,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1564796,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1565709,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1574362,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1790072,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1564925,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1565392,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1566126,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1826057,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1905405,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1566562,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1564796,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1565709,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1574362,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1790072,
                "content": [
                    {
                        "username": "fadi17",
                        "content": "Can someone please explain this question to me?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You are asked to create a DS to keep track of recent calls. initialise it. Then whenever a call is made, store that call and return the number of calls that have been made in the last 3000 ms.\\n\\nFurther hint:\\nYou don\\'t care about any calls that happend more than 3000 ms ago. What DS can you use to add new calls and remove old ones efficiently?"
                    },
                    {
                        "username": "kamisetty23",
                        "content": "activally its a very easy problem.  please google it . then u can get solution for this question :)"
                    },
                    {
                        "username": "DozzaWozza",
                        "content": "please word it decently next time."
                    },
                    {
                        "username": "Supernova10",
                        "content": "the world itself is not decent my sweetheart.\\n"
                    },
                    {
                        "username": "nono_06",
                        "content": "confusion in understanding question language.\\nwhat is it asking to do?"
                    },
                    {
                        "username": "Itsover12",
                        "content": "Glad I wasn\\'t the only one confused by the problem statement. "
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "lol"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here\\'s how it works:\\n\\nWhen you create an instance of the RecentCounter class using RecentCounter(), it initializes the counter with zero recent requests.\\nThe ping(int t) method is used to add a new request at time t and returns the number of requests that have occurred within the past 3000 milliseconds (including the new request).\\nEach time you call the ping method with a new time t, it adds the request to a list of requests and calculates the number of requests within the inclusive range of [t - 3000, t].\\nLet\\'s go through the provided example to see how it works:\\n\\n1.First, you create an instance of RecentCounter called recentCounter using RecentCounter().\\n\\n2.Then, you call recentCounter.ping(1), which adds a new request at time 1 and returns the number of requests in the range [-2999, 1]. Since there\\'s only one request (1) in that range, the return value is 1.\\n\\n3.Next, you call recentCounter.ping(100), which adds another request at time 100 and returns the number of requests in the range [-2900, 100]. Now there are two requests (1 and 100) in that range, so the return value is 2.\\n\\n4.Then, you call recentCounter.ping(3001), adding a request at time 3001 and calculating the number of requests in the range [1, 3001]. At this point, there are three requests (1, 100, and 3001) within that range, so the return value is 3.\\n\\n5.Finally, you call recentCounter.ping(3002), adding a request at time 3002 and calculating the number of requests in the range [2, 3002]. Since all the requests fall within this range (1, 100, 3001, and 3002), the return value is still 3.\\nSo, as you can see, the ping method keeps track of the requests made within the past 3000 milliseconds and returns the count of requests within the specified range."
                    },
                    {
                        "username": "Umair9912",
                        "content": "at ping(3002) it is still 3 because 1 is excluded and only 100,3001 and 3002 are included in the range , otherwise it will be 4, or is that a error?"
                    },
                    {
                        "username": "AstronautBob",
                        "content": "I kind of understand what the question is asking for, which is to keep a reasonable range of number of ping actions, but the example given was really confusing, maybe consider to have some improvements on the statement and example."
                    },
                    {
                        "username": "rangitaaaa",
                        "content": "I am slightly confused by the problem statement, could anyone describe the sample output? I get how 1 and 2 are counted, but not why 3001 and 3002 are not."
                    },
                    {
                        "username": "yabets",
                        "content": "![image](https://assets.leetcode.com/users/images/e618e4ac-d1ba-40ed-afb1-f5db8879df80_1601537352.183472.png)\\nIn the following testcase the value of `t` is above `10000`. \\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[95616],[113489],[119737],[262253],[361209],[424697],[536658],[644230],[900217],[999444]].\\n\\nContraint should be <code>1 <= t <= 10<sup> 9</sup></code>\\nThanks @Kfir_Ram for the find.\\n"
                    },
                    {
                        "username": "geekyanurag",
                        "content": "Hi guys, clear and precise video explanation for Hindi peeps [sorry fot the discrimination folks xD]\\n\\nhttps://youtu.be/CRQXGjzGYWI\\n\\nDon\\'t forget to upvote, Thankyou!"
                    },
                    {
                        "username": "AMerrill",
                        "content": "A queue is your friend here"
                    },
                    {
                        "username": "pengzuo",
                        "content": "I used set, it\\'s my better friend"
                    }
                ]
            },
            {
                "id": 1874703,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 1953281,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 1921900,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 1574798,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 1574255,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 1574433,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 2076686,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 2075388,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 2066308,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            },
            {
                "id": 2043535,
                "content": [
                    {
                        "username": "iamgauravv",
                        "content": "We need to return the total number of recent requests at each instance/ping/element/time(t).\\n\\nThe total number of requests at each time(t) will be in the inclusive range :\\n                  Range - (t-3000 to t)."
                    },
                    {
                        "username": "yuvaldar",
                        "content": "finally i get it thanks!"
                    },
                    {
                        "username": "mail-man26",
                        "content": "Kya baat boli hai"
                    },
                    {
                        "username": "Barani2001",
                        "content": "Can anyone explain this?\\nInput:\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nOutput:\\n[null,1,2,3,4,5]\\n\\nExpected output:\\n[null,1,2,3,3,3]\\n\\n"
                    },
                    {
                        "username": "Weildcard",
                        "content": "When the last two pings come in, the earliest two pings were more than 3000 milliseconds ago, so they shouldn\\'t be counted anymore."
                    },
                    {
                        "username": "yin78105",
                        "content": "let\\'s assume that Leetcode is simulating the real situation in working places that your clients will never tell you what they really need. And you have to figure it out by survey all kinds of sources. ;)  \\n-I am joking"
                    },
                    {
                        "username": "rohitkushwaha630",
                        "content": "Leetcode problems are far away from realities"
                    },
                    {
                        "username": "Tejasvig1",
                        "content": "# what does INPUT means ?\\nInput\\'s first line is the operations that were performed by the system.\\nLike [\"RecentCounter\"] means initialisation \\nthen [\"ping\",\"ping\",\"ping\",\"ping\"]\\nmeans that PING function is called four times .\\nInput Second line - Because the PING function requires an ARGUEMENT so whenever the PING function is called a value has been passed. SO thts why you see a input value in second line corresponding to PING in input\\'s first line.\\nNow you simply have to design the PING function \\nfor getting the coresponding output.\\nIn short Input first line is trash.\\nJust look at the input second line and design the function to give output values.\\nQuestion is easy but language of the question is weird lol.\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/9ac616ae-e5f3-4405-9c35-2560e1331f15_1598029899.2144287.png)\\n\\n![image](https://assets.leetcode.com/users/images/b14bdf1a-2ba4-451a-ae50-acc67e6d0133_1598029904.5762844.png)\\n"
                    },
                    {
                        "username": "user3292p",
                        "content": "Can someone help me in understanding the question?"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "this seems like  it was newly added to the leet code \\n"
                    },
                    {
                        "username": "mehulpamale",
                        "content": "my local is giving correct output but leetcode compiler won\\'t\\n```obj = RecentCounter()\\noutput = [obj.ping(1178), obj.ping(1483), obj.ping(1563), obj.ping(4054), obj.ping(4152)]\\nprint(output)\\n```\\n\\ncode: \\n```\\nclass RecentCounter(object):\\n\\n    def __init__(self):\\n        self.q = []\\n\\n    def ping(self, t):\\n        \"\"\"\\n        :type t: int\\n        :rtype: int\\n        \"\"\"\\n        self.q.append(t)\\n        while self.q and self.q[0] < t - 3000:\\n            self.q.pop(0)\\n        return len(self.q)\\n```\\n\\nWrong Answer\\n3 / 68 testcases passed\\nEditorial\\nInput\\n[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\",\"ping\"]\\n[[],[1178],[1483],[1563],[4054],[4152]]\\n\\nUse Testcase\\nOutput\\n[null,4,5,6,6,7]\\nExpected\\n[null,1,2,3,4,5]\\n\\nthe compiler is giving correct output `[1, 2, 3, 4, 5]`"
                    },
                    {
                        "username": "tony__stark",
                        "content": "Poorly worded question. Explanation in the example does not make sense. "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "we can use binary search why they didnt include the tag"
                    }
                ]
            }
        ]
    }
]