[
    {
        "title": "Cousins in Binary Tree II",
        "question_content": "Given the root of a binary tree, replace the value of each node in the tree with the sum of all its cousins' values.\nTwo nodes of a binary tree are cousins if they have the same depth with different parents.\nReturn the root of the modified tree.\nNote that the depth of a node is the number of edges in the path from the root node to it.\n&nbsp;\nExample 1:\n\nInput: root = [5,4,9,1,10,null,7]\nOutput: [0,0,0,7,7,null,11]\nExplanation: The diagram above shows the initial binary tree and the binary tree after changing the value of each node.\n- Node with value 5 does not have any cousins so its sum is 0.\n- Node with value 4 does not have any cousins so its sum is 0.\n- Node with value 9 does not have any cousins so its sum is 0.\n- Node with value 1 has a cousin with value 7 so its sum is 7.\n- Node with value 10 has a cousin with value 7 so its sum is 7.\n- Node with value 7 has cousins with values 1 and 10 so its sum is 11.\n\nExample 2:\n\nInput: root = [3,1,2]\nOutput: [0,0,0]\nExplanation: The diagram above shows the initial binary tree and the binary tree after changing the value of each node.\n- Node with value 3 does not have any cousins so its sum is 0.\n- Node with value 1 does not have any cousins so its sum is 0.\n- Node with value 2 does not have any cousins so its sum is 0.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 105].\n\t1 <= Node.val <= 104",
        "solutions": [
            {
                "id": 3420099,
                "title": "simple-bfs-tracking-sum-of-child-very-simple-easy-to-understand",
                "content": "<b>Please Up Vote if you like the solution\\n```\\n/*\\n1. Run BFS \\n2. While traversing take the sum of the child nodes & also keep storing the node in a buffer\\n3. After each stage of the BFS, traverse the buf & update the node with value sum - (child\\'s sum)\\n*/\\n\\nTreeNode* replaceValueInTree(TreeNode* root) {\\n    root->val = 0;\\n    queue<TreeNode*> q;  q.push(root);\\n    while(!q.empty()){\\n        int n = q.size(), sum = 0;\\n        vector<TreeNode*> buf;\\n        while(n--){\\n            TreeNode* node = q.front(); q.pop();\\n            buf.push_back(node);\\n            if(node->left) { q.push(node->left); sum += node->left->val; }\\n            if(node->right){ q.push(node->right); sum += node->right->val; }\\n        }\\n        for(auto node: buf){\\n            int  t = sum;\\n            if(node->left)  t -= node->left->val;\\n            if(node->right) t -= node->right->val;\\n            if(node->left)  node->left->val = t;\\n            if(node->right) node->right->val = t;\\n        }\\n    }\\n    return root;\\n}\\n```\\n\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n1. Run BFS \\n2. While traversing take the sum of the child nodes & also keep storing the node in a buffer\\n3. After each stage of the BFS, traverse the buf & update the node with value sum - (child\\'s sum)\\n*/\\n\\nTreeNode* replaceValueInTree(TreeNode* root) {\\n    root->val = 0;\\n    queue<TreeNode*> q;  q.push(root);\\n    while(!q.empty()){\\n        int n = q.size(), sum = 0;\\n        vector<TreeNode*> buf;\\n        while(n--){\\n            TreeNode* node = q.front(); q.pop();\\n            buf.push_back(node);\\n            if(node->left) { q.push(node->left); sum += node->left->val; }\\n            if(node->right){ q.push(node->right); sum += node->right->val; }\\n        }\\n        for(auto node: buf){\\n            int  t = sum;\\n            if(node->left)  t -= node->left->val;\\n            if(node->right) t -= node->right->val;\\n            if(node->left)  node->left->val = t;\\n            if(node->right) node->right->val = t;\\n        }\\n    }\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420081,
                "title": "level-sum",
                "content": "> My account (votrubac) was banned due to the contest rules violation... I sometimes re-use bits of my previous solutions, like standard algorithms. Not sure if it spooked the plagiarism checker or something.\\n\\nWe traverse the tree two times, tracking the current depth `d`.\\n\\nFirst time, we sum values for each level using `l_sum`.\\n\\nSecond time, we update the node value to the level sum, minus value of the current node and its sibling `sib`.\\n\\nFor that, we pass the value of a sibling from the parent node.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> l_sum;\\n    void level_sum(TreeNode* n, int d = 0) {\\n        if (n == nullptr)\\n            return;\\n        l_sum.resize(max((int)l_sum.size(), d + 1));\\n        l_sum[d] += n->val;\\n        level_sum(n->left, d + 1);\\n        level_sum(n->right, d + 1);\\n    }\\n    void update_sum(TreeNode* n, int sib_sum, int d = 0) {\\n        if (n == nullptr)\\n            return;\\n        n->val = l_sum[d] - sib_sum;\\n        sib_sum = (n->left == nullptr ? 0 : n->left->val)\\n            + (n->right == nullptr ? 0 : n->right->val);\\n        update_sum(n->left, sib_sum, d + 1);\\n        update_sum(n->right, sib_sum, d + 1);\\n    }    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        level_sum(root);\\n        update_sum(root, root->val);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> l_sum;\\n    void level_sum(TreeNode* n, int d = 0) {\\n        if (n == nullptr)\\n            return;\\n        l_sum.resize(max((int)l_sum.size(), d + 1));\\n        l_sum[d] += n->val;\\n        level_sum(n->left, d + 1);\\n        level_sum(n->right, d + 1);\\n    }\\n    void update_sum(TreeNode* n, int sib_sum, int d = 0) {\\n        if (n == nullptr)\\n            return;\\n        n->val = l_sum[d] - sib_sum;\\n        sib_sum = (n->left == nullptr ? 0 : n->left->val)\\n            + (n->right == nullptr ? 0 : n->right->val);\\n        update_sum(n->left, sib_sum, d + 1);\\n        update_sum(n->right, sib_sum, d + 1);\\n    }    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        level_sum(root);\\n        update_sum(root, root->val);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419991,
                "title": "c-java-python3-double-dfs",
                "content": "\\n# Intuition\\nFirst find sum of all nodes on each level. Then to find sum of cousin, just need to subtract the value of child and its direct siblings to find sum of cousins.\\n\\n# Approach\\nThe first dfs finds the sum of nodes on each level\\nThe second dfs finds the sum of cousins and creates new binary tree\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n**Python3**:\\n```\\ndef replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n    m = Counter()\\n    def dfs(r, l):\\n        if not r: return\\n        m[l] += r.val\\n        dfs(r.left, l + 1)\\n        dfs(r.right, l + 1)\\n    dfs(root, 0)\\n    \\n    def dfs1(r, l, curr):\\n        sum_of_cousins = m[l + 1] - (r.left.val if r.left else 0) - (r.right.val if r.right else 0)\\n        if r.left:\\n            curr.left = TreeNode(sum_of_cousins)\\n            dfs1(r.left, l + 1, curr.left)\\n        if r.right:\\n            curr.right = TreeNode(sum_of_cousins)\\n            dfs1(r.right, l + 1, curr.right)\\n        return curr\\n    return dfs1(root, 0, TreeNode(0))\\n```\\n\\n**C++**:\\n```\\nTreeNode* replaceValueInTree(TreeNode* root) {\\n    unordered_map<int, int> m;\\n    dfs(root, 0, m);\\n    return dfs1(root, 0, new TreeNode(0), m);\\n}\\nvoid dfs(TreeNode* r, int l, unordered_map<int, int>& m) {\\n    if (!r) return;\\n    m[l] += r->val;\\n    dfs(r->left, l + 1, m);\\n    dfs(r->right, l + 1, m);\\n}\\nTreeNode* dfs1(TreeNode* r, int l, TreeNode* curr, unordered_map<int, int>& m) {\\n    int sum_of_cousins = m[l + 1] - (r->left ? r->left->val : 0) - (r->right ? r->right->val : 0);\\n    if (r->left) {\\n        curr->left = new TreeNode(sum_of_cousins);\\n        dfs1(r->left, l + 1, curr->left, m);\\n    }\\n    if (r->right) {\\n        curr->right = new TreeNode(sum_of_cousins);\\n        dfs1(r->right, l + 1, curr->right, m);\\n    }\\n    return curr;\\n}\\n```\\n\\n**Java**:\\n```\\npublic TreeNode replaceValueInTree(TreeNode root) {\\n    Map<Integer, Integer> m = new HashMap<>();\\n    dfs(root, 0, m);\\n    return dfs1(root, 0, new TreeNode(0), m);\\n}\\nprivate void dfs(TreeNode r, int l, Map<Integer, Integer> m) {\\n    if (r == null) return;\\n    m.put(l, m.getOrDefault(l, 0) + r.val);\\n    dfs(r.left, l + 1, m);\\n    dfs(r.right, l + 1, m);\\n}\\nprivate TreeNode dfs1(TreeNode r, int l, TreeNode curr, Map<Integer, Integer> m) {\\n    int sum_of_cousins = m.getOrDefault(l + 1, 0) - ((r.left != null) ? r.left.val : 0) - ((r.right != null) ? r.right.val : 0);\\n    if (r.left != null) {\\n        curr.left = new TreeNode(sum_of_cousins);\\n        dfs1(r.left, l + 1, curr.left, m);\\n    }\\n    if (r.right != null) {\\n        curr.right = new TreeNode(sum_of_cousins);\\n        dfs1(r.right, l + 1, curr.right, m);\\n    }\\n    return curr;\\n}\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n    m = Counter()\\n    def dfs(r, l):\\n        if not r: return\\n        m[l] += r.val\\n        dfs(r.left, l + 1)\\n        dfs(r.right, l + 1)\\n    dfs(root, 0)\\n    \\n    def dfs1(r, l, curr):\\n        sum_of_cousins = m[l + 1] - (r.left.val if r.left else 0) - (r.right.val if r.right else 0)\\n        if r.left:\\n            curr.left = TreeNode(sum_of_cousins)\\n            dfs1(r.left, l + 1, curr.left)\\n        if r.right:\\n            curr.right = TreeNode(sum_of_cousins)\\n            dfs1(r.right, l + 1, curr.right)\\n        return curr\\n    return dfs1(root, 0, TreeNode(0))\\n```\n```\\nTreeNode* replaceValueInTree(TreeNode* root) {\\n    unordered_map<int, int> m;\\n    dfs(root, 0, m);\\n    return dfs1(root, 0, new TreeNode(0), m);\\n}\\nvoid dfs(TreeNode* r, int l, unordered_map<int, int>& m) {\\n    if (!r) return;\\n    m[l] += r->val;\\n    dfs(r->left, l + 1, m);\\n    dfs(r->right, l + 1, m);\\n}\\nTreeNode* dfs1(TreeNode* r, int l, TreeNode* curr, unordered_map<int, int>& m) {\\n    int sum_of_cousins = m[l + 1] - (r->left ? r->left->val : 0) - (r->right ? r->right->val : 0);\\n    if (r->left) {\\n        curr->left = new TreeNode(sum_of_cousins);\\n        dfs1(r->left, l + 1, curr->left, m);\\n    }\\n    if (r->right) {\\n        curr->right = new TreeNode(sum_of_cousins);\\n        dfs1(r->right, l + 1, curr->right, m);\\n    }\\n    return curr;\\n}\\n```\n```\\npublic TreeNode replaceValueInTree(TreeNode root) {\\n    Map<Integer, Integer> m = new HashMap<>();\\n    dfs(root, 0, m);\\n    return dfs1(root, 0, new TreeNode(0), m);\\n}\\nprivate void dfs(TreeNode r, int l, Map<Integer, Integer> m) {\\n    if (r == null) return;\\n    m.put(l, m.getOrDefault(l, 0) + r.val);\\n    dfs(r.left, l + 1, m);\\n    dfs(r.right, l + 1, m);\\n}\\nprivate TreeNode dfs1(TreeNode r, int l, TreeNode curr, Map<Integer, Integer> m) {\\n    int sum_of_cousins = m.getOrDefault(l + 1, 0) - ((r.left != null) ? r.left.val : 0) - ((r.right != null) ? r.right.val : 0);\\n    if (r.left != null) {\\n        curr.left = new TreeNode(sum_of_cousins);\\n        dfs1(r.left, l + 1, curr.left, m);\\n    }\\n    if (r.right != null) {\\n        curr.right = new TreeNode(sum_of_cousins);\\n        dfs1(r.right, l + 1, curr.right, m);\\n    }\\n    return curr;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420337,
                "title": "c-simplest-and-easy-to-understand-superfast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we are going to find the level-wise sum of binary tree and store it in a vector `depthsum`. Thus, `depth[i]` will contain the sum of nodes at depth `i`. So, we can assign the node the value `depth[i]` and deduction the value of it\\'s own and it parental childer(sibling).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRead the comments you we will be able to get the solution easily.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> depthsum;\\n\\n    // Function to find the depth of each element.\\n    void solve(TreeNode* root, int d){\\n        if(root==NULL) return;\\n\\n        if(d>=depthsum.size()) depthsum.push_back(root->val);\\n        else depthsum[d] += root->val;\\n\\n        solve(root->left, d+1);\\n        solve(root->right, d+1);\\n    }\\n    \\n    // Function to recreate the tree \\n    void fill(TreeNode* root, int d){  \\n        if(root==NULL) return;\\n        int ded = 0;\\n\\n        // storing the value of children of current node in ded which to be deducted.\\n        if(root->left) ded += root->left->val;\\n        if(root->right) ded += root->right->val;\\n\\n        // then assigning the sum of all nodes at that depth and subtracting it\\'s own value and the value of its siblings which are stored in ded\\n        if(root->left) root->left->val = depthsum[d+1] -ded;\\n        if(root->right) root->right->val = depthsum[d+1] -ded;\\n        \\n        // then recursively do the same for all the nodes.\\n        fill(root->left, d+1);\\n        fill(root->right, d+1);\\n        \\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==NULL) return NULL;\\n        root->val=0;\\n        solve(root, 0); // Function to find the depth of each element.\\n        fill(root, 0); // Function to recreate the tree \\n        return root;    \\n    }\\n};\\n\\n// PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Backtracking",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> depthsum;\\n\\n    // Function to find the depth of each element.\\n    void solve(TreeNode* root, int d){\\n        if(root==NULL) return;\\n\\n        if(d>=depthsum.size()) depthsum.push_back(root->val);\\n        else depthsum[d] += root->val;\\n\\n        solve(root->left, d+1);\\n        solve(root->right, d+1);\\n    }\\n    \\n    // Function to recreate the tree \\n    void fill(TreeNode* root, int d){  \\n        if(root==NULL) return;\\n        int ded = 0;\\n\\n        // storing the value of children of current node in ded which to be deducted.\\n        if(root->left) ded += root->left->val;\\n        if(root->right) ded += root->right->val;\\n\\n        // then assigning the sum of all nodes at that depth and subtracting it\\'s own value and the value of its siblings which are stored in ded\\n        if(root->left) root->left->val = depthsum[d+1] -ded;\\n        if(root->right) root->right->val = depthsum[d+1] -ded;\\n        \\n        // then recursively do the same for all the nodes.\\n        fill(root->left, d+1);\\n        fill(root->right, d+1);\\n        \\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==NULL) return NULL;\\n        root->val=0;\\n        solve(root, 0); // Function to find the depth of each element.\\n        fill(root, 0); // Function to recreate the tree \\n        return root;    \\n    }\\n};\\n\\n// PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419993,
                "title": "java-python-3-dfs-and-bfs-w-brief-explanation-and-analysis",
                "content": "**DFS**\\n\\n\\n1. First `dfs` get the sum of each level;\\n2. In Second `dfs`, we first locate the nodes with `2` kids, then update the value of each kid to the sum of the `2`kids; then for each node use level sum to minus its updated value to get final value.\\n\\n```java\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        List<Integer> levelSum = new ArrayList<>();\\n        dfs(root, 0, levelSum);\\n        dfs2(root, 0, levelSum);\\n        return root;\\n    }\\n    private void dfs(TreeNode n, int depth, List<Integer> levelSum) {\\n        if (n != null) {\\n            if (depth == levelSum.size()) {\\n                levelSum.add(0);\\n            }\\n            levelSum.set(depth, levelSum.get(depth) + n.val);\\n            dfs(n.left, depth + 1, levelSum);    \\n            dfs(n.right, depth + 1, levelSum);    \\n        }\\n    }\\n    private void dfs2(TreeNode n, int depth, List<Integer> levelSum) {\\n        if (n != null) {\\n            n.val = levelSum.get(depth) - n.val;\\n            if (n.left != null && n.right != null) {\\n                int siblingsSum = n.left.val + n.right.val;\\n                n.left.val = n.right.val = siblingsSum;\\n            }\\n            dfs2(n.left, depth + 1, levelSum);\\n            dfs2(n.right, depth + 1, levelSum);\\n        }\\n    }\\n```\\n\\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n\\n        def dfs(node: TreeNode, depth: int) -> None:\\n            if node:\\n                if len(level_sum) == depth:\\n                    level_sum.append(0)\\n                level_sum[depth] += node.val\\n                dfs(node.left, depth + 1)\\n                dfs(node.right, depth + 1)\\n\\n        def dfs2(node: TreeNode, depth: int) -> None:\\n            if node:\\n                node.val = level_sum[depth] - node.val\\n                if node.left and node.right:\\n                    siblings_sum = node.left.val + node.right.val\\n                    node.left.val = node.right.val = siblings_sum\\n                dfs2(node.left, depth + 1)\\n                dfs2(node.right, depth + 1)\\n\\n        level_sum = []\\n        dfs(root, 0)        \\n        dfs2(root, 0)        \\n        return root\\n```\\n**Analysis:**\\nTime: `O(n)`, space: `O(h)`, where `n = # of nodes, h = height of the tree`.\\n\\n----\\n\\n**BFS**\\n\\nThe following idea and the corresponding 2 codes inspired by **@pbmessi**:\\n\\n1. BFS traversal to get next level sum, get the sum of each level;\\n2. During traversal, locate the nodes with `2` kids, then update the value of each kid to the sum of the `2`kids; then for each node use level sum to minus its updated value to get final value.\\n\\n\\n```java\\n    public TreeNode replaceValueInTree2(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int currentLevelSum = root.val;\\n        while (!q.isEmpty()) {\\n            int nextLevelSum = 0;\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                TreeNode n = q.poll();\\n                n.val = currentLevelSum - n.val;\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        q.offer(kid);\\n                        nextLevelSum += kid.val;\\n                    }\\n                }\\n                if (n.left != null && n.right != null) {\\n                    int sum = n.left.val + n.right.val;\\n                    n.left.val = n.right.val = sum;\\n                }\\n            }\\n            currentLevelSum = nextLevelSum;\\n        }\\n        return root;        \\n    }\\n```\\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        current_level_sum = root.val\\n        q = [root]\\n        while q:\\n            next_level, next_level_sum = [], 0\\n            for node in q:\\n                node.val = current_level_sum - node.val\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        next_level.append(kid)\\n                        next_level_sum += kid.val        \\n                if node.left and node.right:\\n                    sm = node.left.val + node.right.val\\n                    node.left.val = node.right.val = sm\\n            q, current_level_sum = next_level, next_level_sum\\n        return root\\n```\\n\\nAnother variant of **BFS**:\\n\\n1. BFS traversal to get next level sum, and keep a copy of current level of nodes;\\n2. For each node, use next level sum minus its kids\\' value sum to get the required value.\\n\\n```java\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        root.val = 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        while (!q.isEmpty()) {\\n            List<TreeNode> parents = new ArrayList<>(q);\\n            int nextLevelSum = 0;\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                TreeNode n = q.poll();\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        q.offer(kid);\\n                        nextLevelSum += kid.val;\\n                    }\\n                }\\n            }\\n            for (TreeNode n : parents) {\\n                int replacedVal = nextLevelSum;\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        replacedVal -= kid.val;\\n                    }\\n                }\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        kid.val = replacedVal;\\n                    }\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n```\\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        q = [root]\\n        while q:\\n            next_level, parents = [], q[:]\\n            next_level_sum = 0\\n            for node in q:\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        next_level.append(kid)\\n                        next_level_sum += kid.val        \\n            for node in parents:                \\n                replaced_val = next_level_sum\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        replaced_val -= kid.val\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        kid.val = replaced_val\\n            q = next_level        \\n        return root\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`,  space: `O(w)`, where `n = # of nodes, w = the max # of the nodes among all levels of the tree`.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```java\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        List<Integer> levelSum = new ArrayList<>();\\n        dfs(root, 0, levelSum);\\n        dfs2(root, 0, levelSum);\\n        return root;\\n    }\\n    private void dfs(TreeNode n, int depth, List<Integer> levelSum) {\\n        if (n != null) {\\n            if (depth == levelSum.size()) {\\n                levelSum.add(0);\\n            }\\n            levelSum.set(depth, levelSum.get(depth) + n.val);\\n            dfs(n.left, depth + 1, levelSum);    \\n            dfs(n.right, depth + 1, levelSum);    \\n        }\\n    }\\n    private void dfs2(TreeNode n, int depth, List<Integer> levelSum) {\\n        if (n != null) {\\n            n.val = levelSum.get(depth) - n.val;\\n            if (n.left != null && n.right != null) {\\n                int siblingsSum = n.left.val + n.right.val;\\n                n.left.val = n.right.val = siblingsSum;\\n            }\\n            dfs2(n.left, depth + 1, levelSum);\\n            dfs2(n.right, depth + 1, levelSum);\\n        }\\n    }\\n```\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n\\n        def dfs(node: TreeNode, depth: int) -> None:\\n            if node:\\n                if len(level_sum) == depth:\\n                    level_sum.append(0)\\n                level_sum[depth] += node.val\\n                dfs(node.left, depth + 1)\\n                dfs(node.right, depth + 1)\\n\\n        def dfs2(node: TreeNode, depth: int) -> None:\\n            if node:\\n                node.val = level_sum[depth] - node.val\\n                if node.left and node.right:\\n                    siblings_sum = node.left.val + node.right.val\\n                    node.left.val = node.right.val = siblings_sum\\n                dfs2(node.left, depth + 1)\\n                dfs2(node.right, depth + 1)\\n\\n        level_sum = []\\n        dfs(root, 0)        \\n        dfs2(root, 0)        \\n        return root\\n```\n```java\\n    public TreeNode replaceValueInTree2(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        int currentLevelSum = root.val;\\n        while (!q.isEmpty()) {\\n            int nextLevelSum = 0;\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                TreeNode n = q.poll();\\n                n.val = currentLevelSum - n.val;\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        q.offer(kid);\\n                        nextLevelSum += kid.val;\\n                    }\\n                }\\n                if (n.left != null && n.right != null) {\\n                    int sum = n.left.val + n.right.val;\\n                    n.left.val = n.right.val = sum;\\n                }\\n            }\\n            currentLevelSum = nextLevelSum;\\n        }\\n        return root;        \\n    }\\n```\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        current_level_sum = root.val\\n        q = [root]\\n        while q:\\n            next_level, next_level_sum = [], 0\\n            for node in q:\\n                node.val = current_level_sum - node.val\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        next_level.append(kid)\\n                        next_level_sum += kid.val        \\n                if node.left and node.right:\\n                    sm = node.left.val + node.right.val\\n                    node.left.val = node.right.val = sm\\n            q, current_level_sum = next_level, next_level_sum\\n        return root\\n```\n```java\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        root.val = 0;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        while (!q.isEmpty()) {\\n            List<TreeNode> parents = new ArrayList<>(q);\\n            int nextLevelSum = 0;\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                TreeNode n = q.poll();\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        q.offer(kid);\\n                        nextLevelSum += kid.val;\\n                    }\\n                }\\n            }\\n            for (TreeNode n : parents) {\\n                int replacedVal = nextLevelSum;\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        replacedVal -= kid.val;\\n                    }\\n                }\\n                for (TreeNode kid : new TreeNode[]{n.left, n.right}) {\\n                    if (kid != null) {\\n                        kid.val = replacedVal;\\n                    }\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n```\n```python\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        q = [root]\\n        while q:\\n            next_level, parents = [], q[:]\\n            next_level_sum = 0\\n            for node in q:\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        next_level.append(kid)\\n                        next_level_sum += kid.val        \\n            for node in parents:                \\n                replaced_val = next_level_sum\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        replaced_val -= kid.val\\n                for kid in node.left, node.right:\\n                    if kid:\\n                        kid.val = replaced_val\\n            q = next_level        \\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420073,
                "title": "c-easy-beginner-friendly-level-order-traversal",
                "content": "# Intuition\\nOverall, this solution calculates the sum of values of nodes at each level in the first pass and uses that information to update the values of nodes in the second pass, effectively replacing the values in the tree as required.\\n\\n# Approach\\nThe approach used in this solution is a two-pass level-order traversal of the tree. In the first pass, the sum of values of nodes at each level is calculated and stored in an unordered map with the level as the key. In the second pass, the values of nodes are updated using the sum of values of its children nodes and its own original value, retrieved from the map.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        int lev=0;\\n        unordered_map<int, int> mp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        mp[0]=root->val;\\n        while(!q.empty()) \\n        {\\n            lev++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++) \\n            {\\n                auto n=q.front();\\n                q.pop();\\n                if(n->left) \\n                {\\n                    q.push(n->left);\\n                    mp[lev]+=(n->left->val);\\n                }\\n                if(n->right)\\n                {\\n                    q.push(n->right);\\n                    mp[lev]+=(n->right->val);\\n                }\\n            }\\n        }\\n\\n        q.push(root);\\n        lev=0;\\n        root->val=0;\\n        while(!q.empty()) \\n        {\\n            lev++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++) \\n            {\\n                auto n=q.front();\\n                q.pop();\\n                int lef=(n->left)?n->left->val:0;\\n                int ri=(n->right)?n->right->val:0;\\n                if(n->left) \\n                {\\n                    q.push(n->left);\\n                    n->left->val=mp[lev]-lef-ri;\\n                }\\n                if(n->right) \\n                {\\n                    q.push(n->right);\\n                    n->right->val=mp[lev]-lef-ri;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        int lev=0;\\n        unordered_map<int, int> mp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        mp[0]=root->val;\\n        while(!q.empty()) \\n        {\\n            lev++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++) \\n            {\\n                auto n=q.front();\\n                q.pop();\\n                if(n->left) \\n                {\\n                    q.push(n->left);\\n                    mp[lev]+=(n->left->val);\\n                }\\n                if(n->right)\\n                {\\n                    q.push(n->right);\\n                    mp[lev]+=(n->right->val);\\n                }\\n            }\\n        }\\n\\n        q.push(root);\\n        lev=0;\\n        root->val=0;\\n        while(!q.empty()) \\n        {\\n            lev++;\\n            int size=q.size();\\n            for(int i=0;i<size;i++) \\n            {\\n                auto n=q.front();\\n                q.pop();\\n                int lef=(n->left)?n->left->val:0;\\n                int ri=(n->right)?n->right->val:0;\\n                if(n->left) \\n                {\\n                    q.push(n->left);\\n                    n->left->val=mp[lev]-lef-ri;\\n                }\\n                if(n->right) \\n                {\\n                    q.push(n->right);\\n                    n->right->val=mp[lev]-lef-ri;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419973,
                "title": "c-full-explanation-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    //same depth means node at same level\\n    //for this we will use queue\\n    //As we need parent information of each node so queue will have curr_node and its parent as pair \\n    // The main point here is ans of node at particular level is =(Total_Sum at that level) - (sum of node having same parent)\\n    // now for calculating sum of node having same parent i am using map\\n    //The key point here is i am not using int as my key in map because two different node can have same value so i am using TreeNode* as key\\n    // I am modifying same tree so i have used temp arr to store node in a way they are coming in queue at each level\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*,TreeNode*>>q;       \\n        q.push({NULL,root});\\n        \\n        while(q.size())\\n        {\\n            int size=q.size();\\n            unordered_map<TreeNode*,int>mp;\\n            vector<pair<TreeNode*,TreeNode*>>temp;\\n            int total_sum=0;\\n            while(size--)\\n            {\\n                auto node=q.front(); //node.first=parent , node.second=curr_node\\n                q.pop();\\n                 \\n                total_sum+=node.second->val;  //calculating total sum at particular level\\n                mp[node.first]+=node.second->val;  //storing sum of node having same parent\\n                temp.push_back({node.first,node.second}); //this is used so that we can modify current tree\\n                \\n                if(node.second->left)\\n                    q.push({node.second,node.second->left});\\n                \\n                if(node.second->right)\\n                    q.push({node.second,node.second->right});\\n            }\\n            \\n            for(auto it:temp)\\n            {\\n                int val=total_sum-mp[it.first]; //formula\\n                it.second->val=val;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //same depth means node at same level\\n    //for this we will use queue\\n    //As we need parent information of each node so queue will have curr_node and its parent as pair \\n    // The main point here is ans of node at particular level is =(Total_Sum at that level) - (sum of node having same parent)\\n    // now for calculating sum of node having same parent i am using map\\n    //The key point here is i am not using int as my key in map because two different node can have same value so i am using TreeNode* as key\\n    // I am modifying same tree so i have used temp arr to store node in a way they are coming in queue at each level\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*,TreeNode*>>q;       \\n        q.push({NULL,root});\\n        \\n        while(q.size())\\n        {\\n            int size=q.size();\\n            unordered_map<TreeNode*,int>mp;\\n            vector<pair<TreeNode*,TreeNode*>>temp;\\n            int total_sum=0;\\n            while(size--)\\n            {\\n                auto node=q.front(); //node.first=parent , node.second=curr_node\\n                q.pop();\\n                 \\n                total_sum+=node.second->val;  //calculating total sum at particular level\\n                mp[node.first]+=node.second->val;  //storing sum of node having same parent\\n                temp.push_back({node.first,node.second}); //this is used so that we can modify current tree\\n                \\n                if(node.second->left)\\n                    q.push({node.second,node.second->left});\\n                \\n                if(node.second->right)\\n                    q.push({node.second,node.second->right});\\n            }\\n            \\n            for(auto it:temp)\\n            {\\n                int val=total_sum-mp[it.first]; //formula\\n                it.second->val=val;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420009,
                "title": "using-bfs-to-precompute-lvl-sum",
                "content": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        List<Integer> l=new ArrayList<>();\\n        l.add(root.val);\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            int sum1=0;\\n            while(size-->0){\\n                TreeNode curr=q.poll();\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n            }\\n            l.add(sum1);\\n            \\n        }\\n       \\n        q.clear();\\n        q.add(root);\\n        int lvl=-1;\\n        while(!q.isEmpty()){\\n            lvl++;\\n            int size=q.size();\\n            \\n            while(size-->0){\\n                int sum1=0;\\n                TreeNode curr=q.poll();\\n                if(lvl==0 || lvl==1){\\n                    curr.val=0;\\n                }\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n               \\n                if(lvl>=1){\\n                  //   System.out.print(lvl+\" \");\\n                     if(curr.left!=null){\\n                          \\n                        curr.left.val=l.get(lvl+1)-sum1;\\n                     }\\n                    if(curr.right!=null){\\n                        curr.right.val=l.get(lvl+1)-sum1;\\n                     }\\n                }\\n            }\\n            \\n            \\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        List<Integer> l=new ArrayList<>();\\n        l.add(root.val);\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            int sum1=0;\\n            while(size-->0){\\n                TreeNode curr=q.poll();\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n            }\\n            l.add(sum1);\\n            \\n        }\\n       \\n        q.clear();\\n        q.add(root);\\n        int lvl=-1;\\n        while(!q.isEmpty()){\\n            lvl++;\\n            int size=q.size();\\n            \\n            while(size-->0){\\n                int sum1=0;\\n                TreeNode curr=q.poll();\\n                if(lvl==0 || lvl==1){\\n                    curr.val=0;\\n                }\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n               \\n                if(lvl>=1){\\n                  //   System.out.print(lvl+\" \");\\n                     if(curr.left!=null){\\n                          \\n                        curr.left.val=l.get(lvl+1)-sum1;\\n                     }\\n                    if(curr.right!=null){\\n                        curr.right.val=l.get(lvl+1)-sum1;\\n                     }\\n                }\\n            }\\n            \\n            \\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420230,
                "title": "explained-simple-and-clear-python-code",
                "content": "# Intuition\\nTo replace the value of each node in the tree with the sum of all its cousins\\' values, we first need to find the sum of each level of the tree. We can then use a DFS approach to traverse the tree and replace the value of each node with the sum of its cousins\\' values.\\n\\n\\n# Approach\\nWe will start by defining a function level_sum to calculate the sum of each level of the tree. This function will use BFS to traverse the tree level by level and store the sum of each level in a list.\\n\\nNext, we will create a copy of the original tree using the copy_tree function. This is because we don\\'t want to modify the original tree.\\n\\nFinally, we will use a DFS approach to traverse the tree and replace the value of each node with the sum of its cousins\\' values. We will pass the parent node and the level of the current node to the DFS function so that we can identify the cousins of the current node. We will also pass a copy of the copied tree to the DFS function, which we will modify as we traverse the tree.\\n\\nIn the DFS function, we will calculate the sum of the current level using the levels_sum list that we calculated earlier. We will then calculate the value of the current node based on the value of its parent and its cousins. We will then recursively call the DFS function on the left and right child of the current node.\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm is O(N), where N is the number of nodes in the tree. This is because we need to traverse the entire tree once to calculate the sum of each level and once again to replace the value of each node.\\n- Space complexity:\\nThe space complexity of this algorithm is O(N), where N is the number of nodes in the tree. This is because we need to store the sum of each level in a list, which can take up to N/2 space in the worst case (when the tree is a complete binary tree). Additionally, the recursive call stack can also take up to N space in the worst case.\\n# Code\\n```\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        def level_sum(root):\\n            if not root:\\n                return []\\n\\n            result = []\\n            queue = [root]\\n\\n            while queue:\\n                current_level_sum = 0\\n                level_size = len(queue)\\n\\n                for _ in range(level_size):\\n                    node = queue.pop(0)\\n                    current_level_sum += node.val\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n\\n                result.append(current_level_sum)\\n\\n            return result\\n\\n        levels_sum = level_sum(root)\\n        print(levels_sum)\\n\\n        def copy_tree(node):\\n            if node is None:\\n                return None\\n            new_node = TreeNode(node.val)\\n            new_node.left = copy_tree(node.left)\\n            new_node.right = copy_tree(node.right)\\n            return new_node\\n\\n        ans_tree = copy_tree(root)\\n\\n        def dfs(node, parent, level, ans):\\n            if node is None:\\n                return\\n            level_sum = levels_sum[level]\\n            if level < 2:\\n                ans.val = 0\\n            else:\\n                left_val = 0 if not parent.left else parent.left.val\\n                right_val = 0 if not parent.right else parent.right.val\\n                new_val = level_sum - left_val - right_val\\n                ans.val = new_val\\n            dfs(node.left, node, level+1, ans.left)\\n            dfs(node.right, node, level+1, ans.right)\\n\\n        dfs(root, None, 0, ans_tree)\\n        return ans_tree\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        def level_sum(root):\\n            if not root:\\n                return []\\n\\n            result = []\\n            queue = [root]\\n\\n            while queue:\\n                current_level_sum = 0\\n                level_size = len(queue)\\n\\n                for _ in range(level_size):\\n                    node = queue.pop(0)\\n                    current_level_sum += node.val\\n\\n                    if node.left:\\n                        queue.append(node.left)\\n\\n                    if node.right:\\n                        queue.append(node.right)\\n\\n                result.append(current_level_sum)\\n\\n            return result\\n\\n        levels_sum = level_sum(root)\\n        print(levels_sum)\\n\\n        def copy_tree(node):\\n            if node is None:\\n                return None\\n            new_node = TreeNode(node.val)\\n            new_node.left = copy_tree(node.left)\\n            new_node.right = copy_tree(node.right)\\n            return new_node\\n\\n        ans_tree = copy_tree(root)\\n\\n        def dfs(node, parent, level, ans):\\n            if node is None:\\n                return\\n            level_sum = levels_sum[level]\\n            if level < 2:\\n                ans.val = 0\\n            else:\\n                left_val = 0 if not parent.left else parent.left.val\\n                right_val = 0 if not parent.right else parent.right.val\\n                new_val = level_sum - left_val - right_val\\n                ans.val = new_val\\n            dfs(node.left, node, level+1, ans.left)\\n            dfs(node.right, node, level+1, ans.right)\\n\\n        dfs(root, None, 0, ans_tree)\\n        return ans_tree\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419999,
                "title": "explanation-inplace-simple-bfs-queue-time-o-n",
                "content": "# Approach\\nTop 3 nodes have no cousins, they will be 0. Use queue for BFS level order traversal. For a queue $\\\\{a_1,a_2,a_3\\\\}$, calculate the total sum of their next level. Then again traverse on **same** nodes ($\\\\{a_1,a_2,a_3\\\\}$) and change their children\\'s values, and push children to queue for next level order traversal.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        int total, currSum;\\n        TreeNode* curr;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val = 0;\\n        while (!q.empty()) {\\n            total = 0;\\n            for (int i = q.size(); i > 0; i--) {\\n                curr = q.front(); q.pop();\\n                total += (curr->left ? curr->left->val : 0) + (curr->right ? curr->right->val : 0);\\n                q.push(curr);\\n            }\\n            for (int i = q.size(); i > 0; i--) {\\n                curr = q.front(); q.pop();\\n                currSum = (curr->left ? curr->left->val : 0) + (curr->right ? curr->right->val : 0);\\n                if (curr->left) {\\n                    curr->left->val = total - currSum;\\n                    q.push(curr->left);\\n                }\\n                if (curr->right) {\\n                    curr->right->val = total - currSum;\\n                    q.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        int total, currSum;\\n        TreeNode* curr;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val = 0;\\n        while (!q.empty()) {\\n            total = 0;\\n            for (int i = q.size(); i > 0; i--) {\\n                curr = q.front(); q.pop();\\n                total += (curr->left ? curr->left->val : 0) + (curr->right ? curr->right->val : 0);\\n                q.push(curr);\\n            }\\n            for (int i = q.size(); i > 0; i--) {\\n                curr = q.front(); q.pop();\\n                currSum = (curr->left ? curr->left->val : 0) + (curr->right ? curr->right->val : 0);\\n                if (curr->left) {\\n                    curr->left->val = total - currSum;\\n                    q.push(curr->left);\\n                }\\n                if (curr->right) {\\n                    curr->right->val = total - currSum;\\n                    q.push(curr->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421153,
                "title": "c-bfs-map",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    #define ll long long\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<ll,ll>m;\\n        map<pair<ll,TreeNode*>,ll>p;\\n        queue<pair<TreeNode*,TreeNode*>>q,z;\\n        q.push({root,NULL});\\n        int d=0;\\n        while(q.size()){\\n            int k=q.size();\\n            for(int i=0;i<k;i++){\\n                auto x=q.front();\\n                TreeNode* par=x.second;\\n                TreeNode* act=x.first;\\n                q.pop();\\n                int t=0;\\n                if(par!=NULL)t=par->val;\\n                p[{d,par}]+=act->val;\\n                m[d]+=act->val;\\n                if(act->right!=NULL)q.push({act->right,act});\\n                 if(act->left!=NULL)q.push({act->left,act});\\n            }\\n            d++;\\n        }\\n        d=0;\\n\\n        z.push({root,NULL});\\n        while(z.size()){\\n        int k=z.size();\\n        for(int i=0;i<k;i++)\\n        {\\n            auto x=z.front().first;\\n            auto par=z.front().second;\\n            z.pop();\\n            x->val=m[d]-p[{d,par}];\\n             if(x->right!=NULL)z.push({x->right,x});\\n                 if(x->left!=NULL)z.push({x->left,x});\\n        }\\n            d++;\\n        }\\n        return root;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/c9199d51-858a-4e57-84bc-fa74dc1282e2_1681590164.240952.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    #define ll long long\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<ll,ll>m;\\n        map<pair<ll,TreeNode*>,ll>p;\\n        queue<pair<TreeNode*,TreeNode*>>q,z;\\n        q.push({root,NULL});\\n        int d=0;\\n        while(q.size()){\\n            int k=q.size();\\n            for(int i=0;i<k;i++){\\n                auto x=q.front();\\n                TreeNode* par=x.second;\\n                TreeNode* act=x.first;\\n                q.pop();\\n                int t=0;\\n                if(par!=NULL)t=par->val;\\n                p[{d,par}]+=act->val;\\n                m[d]+=act->val;\\n                if(act->right!=NULL)q.push({act->right,act});\\n                 if(act->left!=NULL)q.push({act->left,act});\\n            }\\n            d++;\\n        }\\n        d=0;\\n\\n        z.push({root,NULL});\\n        while(z.size()){\\n        int k=z.size();\\n        for(int i=0;i<k;i++)\\n        {\\n            auto x=z.front().first;\\n            auto par=z.front().second;\\n            z.pop();\\n            x->val=m[d]-p[{d,par}];\\n             if(x->right!=NULL)z.push({x->right,x});\\n                 if(x->left!=NULL)z.push({x->left,x});\\n        }\\n            d++;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422435,
                "title": "simple-approach-by-using-bfs-and-taking-sum-of-child-explanation-with-visualization",
                "content": "#### **Cousins in Binary Tree II**\\n\\n**Topic:** Binary Tree, DFS/BFS\\n**Hints1:** Find sum of values level wise\\n**Hints2:** Store the child sum of each node\\n\\nEssentially, this question can be divided into two distinct parts.\\n\\n##### **First Part:** Construct Required Things (level_wise_sum+child_sum)\\nIn this part, we need to store the level wise sum as well as child sum of each node. Here we can maintain the Map for storing the data that we need in future. \\n\\nThis code performs a BFS traversal of a binary tree and calculates the level wise sum of node values and the sum of child node values for each node. The code uses a queue to store nodes in the order they need to be processed, and a map to store the sums. During the traversal, for each node, the code adds the node value to the level wise sum and calculates the sum of child node values. The sum of child node values is stored in a map with the node pointer as the key.\\n\\n##### **Example:** \\n<img src=\"https://assets.leetcode.com/users/images/ea37b32e-7907-449d-abdc-c1bdb8bf8c66_1681625217.5710294.jpeg\" width=\"30%\"> <img src=\"https://assets.leetcode.com/users/images/a95d08c7-32a6-440d-92ee-e23074b9cccf_1681625269.7894928.jpeg\" width=\"30%\"> <img src=\"https://assets.leetcode.com/users/images/9093dfe5-4d53-4871-b714-e5b2554ab102_1681625306.391535.jpeg\" width=\"30%\">\\n\\n\\n##### **Second Part:** Final Answer prepare, modify the given Tree\\nTo determine if there are cousins of a given node in the binary tree, we can traverse the tree using either BFS or DFS. If the level_wise_sum value for a level is greater than the child_sum value stored in the parent node, then there must be at least one cousin node present in that level. In this case, we can remove the child_sum value from the level_wise_sum to calculate the sum of the cousin nodes. If the level_wise_sum value for a level is not greater than the child_sum value, then there are no cousin nodes in that level, and we store 0 as the sum of cousin nodes.\\n\\nThis code uses a queue to perform a BFS traversal of a binary tree and determine the sum of cousin nodes for each node. The pen queue stores pairs of nodes along with their level for processing. For each node, the code calculates whether the level wise sum of the node is greater than the sum of its child nodes. If so, the code calculates the difference and assigns it to the current node value. If not, the code assigns 0 to the current node value. Finally, the code sets the value of the root node to 0 and returns the root.\\n\\n#### **Code:**\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //First Part (Construct Required things)\\n        \\n        //store the each level sum\\n        map<int,long long> level_wise_sum;\\n        //store the parent-> child sum\\n        map<TreeNode*,long long> child_sum;\\n        //create a queue for BFS\\n        queue<pair<TreeNode*,int>> pending;\\n        pending.push({root,0});\\n        \\n        while(pending.size()!=0){\\n            TreeNode* temp = pending.front().first; \\n            int lvl = pending.front().second;\\n            pending.pop();\\n            \\n            //Store the level wise sum\\n            level_wise_sum[lvl]+=temp->val;\\n            //Take a variable sum that stores the child sum\\n            long long sum = 0;\\n            if(temp->left!=NULL){\\n                sum+=temp->left->val;\\n                pending.push({temp->left,lvl+1});\\n            }\\n            if(temp->right!=NULL){\\n                sum+=temp->right->val;\\n                pending.push({temp->right,lvl+1});\\n            }\\n            //store the each node-> child sum\\n            child_sum[temp]=sum;\\n        }\\n        \\n        \\n        \\n        // Second Part (Final ans prepare)\\n        \\n        //Create a queue for BFS <parent-child> and store level\\n        queue<pair<pair<TreeNode*,TreeNode*>,int>> pen;\\n        pen.push({{root,root},0});\\n        while(pen.size()!=0){\\n            TreeNode* parent = pen.front().first.first; \\n            TreeNode* curr = pen.front().first.second;\\n            int lvl = pen.front().second;\\n            pen.pop();\\n            \\n            //Calculate greater or not, if yes then store the substraction \\n            if(level_wise_sum[lvl]>=child_sum[parent]){\\n                curr->val = level_wise_sum[lvl]-child_sum[parent];\\n            }else{\\n                curr->val = 0;\\n            }\\n            \\n            if(curr->left!=NULL) pen.push({{curr,curr->left},lvl+1});\\n            if(curr->right!=NULL) pen.push({{curr,curr->right},lvl+1});\\n            \\n            \\n        }\\n        \\n        // Parent root will be always 0\\n        root->val=0;\\n        return root;\\n        \\n        \\n    }\\n};\\n```\\n\\n<br>\\n\\n##### **If you like this explanation, feel free to upvote this discussion ^^**",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //First Part (Construct Required things)\\n        \\n        //store the each level sum\\n        map<int,long long> level_wise_sum;\\n        //store the parent-> child sum\\n        map<TreeNode*,long long> child_sum;\\n        //create a queue for BFS\\n        queue<pair<TreeNode*,int>> pending;\\n        pending.push({root,0});\\n        \\n        while(pending.size()!=0){\\n            TreeNode* temp = pending.front().first; \\n            int lvl = pending.front().second;\\n            pending.pop();\\n            \\n            //Store the level wise sum\\n            level_wise_sum[lvl]+=temp->val;\\n            //Take a variable sum that stores the child sum\\n            long long sum = 0;\\n            if(temp->left!=NULL){\\n                sum+=temp->left->val;\\n                pending.push({temp->left,lvl+1});\\n            }\\n            if(temp->right!=NULL){\\n                sum+=temp->right->val;\\n                pending.push({temp->right,lvl+1});\\n            }\\n            //store the each node-> child sum\\n            child_sum[temp]=sum;\\n        }\\n        \\n        \\n        \\n        // Second Part (Final ans prepare)\\n        \\n        //Create a queue for BFS <parent-child> and store level\\n        queue<pair<pair<TreeNode*,TreeNode*>,int>> pen;\\n        pen.push({{root,root},0});\\n        while(pen.size()!=0){\\n            TreeNode* parent = pen.front().first.first; \\n            TreeNode* curr = pen.front().first.second;\\n            int lvl = pen.front().second;\\n            pen.pop();\\n            \\n            //Calculate greater or not, if yes then store the substraction \\n            if(level_wise_sum[lvl]>=child_sum[parent]){\\n                curr->val = level_wise_sum[lvl]-child_sum[parent];\\n            }else{\\n                curr->val = 0;\\n            }\\n            \\n            if(curr->left!=NULL) pen.push({{curr,curr->left},lvl+1});\\n            if(curr->right!=NULL) pen.push({{curr,curr->right},lvl+1});\\n            \\n            \\n        }\\n        \\n        // Parent root will be always 0\\n        root->val=0;\\n        return root;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420410,
                "title": "simply-the-bfs-way",
                "content": "**Time** O(n)\\n**Space** O(n+n)\\n\\n**Explanation**\\nEach node we need:\\ntotal childsum of the level\\nparent\\'s child sum\\nso putting in map with parent and childsum of parent\\nnode.val = (totalchildsum of prevlevel - parent\\'s child sum)\\n\\nPlease do dry run on test case\\n```\\nclass Solution {\\n    class Pair{\\n        TreeNode node;\\n        TreeNode parent;\\n        public Pair(TreeNode n, TreeNode p){\\n            node = n;\\n            parent = p;\\n        }\\n    }\\n    \\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        // same depth diff parent\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(root, null));\\n        \\n        int curLevelChildSum = 0;\\n        Map<TreeNode, Integer> map = new HashMap<>();       // storing parent : childsum   \\n        \\n        while(!q.isEmpty()){\\n           \\n            \\n            int lastLevelChildSum = curLevelChildSum;    // prevsum = cursum\\n            curLevelChildSum = 0;   // reset cursum\\n            \\n            int size = q.size();\\n            \\n            while(size-- > 0){\\n                Pair front = q.poll();\\n                \\n                TreeNode node = front.node;\\n                TreeNode par = front.parent;\\n\\n                int childsum = 0; \\n                // left\\n                if(node.left != null){\\n                    q.add(new Pair(node.left, node));\\n                    childsum += node.left.val;\\n                }\\n                // right\\n                if(node.right != null){\\n                    q.add(new Pair(node.right, node));\\n                    childsum += node.right.val;\\n                }\\n                \\n                // put value in map\\n                map.put(node, childsum);\\n                \\n                curLevelChildSum += childsum;\\n                \\n                node.val = lastLevelChildSum - map.getOrDefault(par, 0);  // get(par) gives me childsum of this node\\'s parent\\n            }\\n            \\n        }\\n        \\n        return root;\\n    }\\n}\\n```\\n\\nUpvote Kardo Yr !",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        TreeNode node;\\n        TreeNode parent;\\n        public Pair(TreeNode n, TreeNode p){\\n            node = n;\\n            parent = p;\\n        }\\n    }\\n    \\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        // same depth diff parent\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(root, null));\\n        \\n        int curLevelChildSum = 0;\\n        Map<TreeNode, Integer> map = new HashMap<>();       // storing parent : childsum   \\n        \\n        while(!q.isEmpty()){\\n           \\n            \\n            int lastLevelChildSum = curLevelChildSum;    // prevsum = cursum\\n            curLevelChildSum = 0;   // reset cursum\\n            \\n            int size = q.size();\\n            \\n            while(size-- > 0){\\n                Pair front = q.poll();\\n                \\n                TreeNode node = front.node;\\n                TreeNode par = front.parent;\\n\\n                int childsum = 0; \\n                // left\\n                if(node.left != null){\\n                    q.add(new Pair(node.left, node));\\n                    childsum += node.left.val;\\n                }\\n                // right\\n                if(node.right != null){\\n                    q.add(new Pair(node.right, node));\\n                    childsum += node.right.val;\\n                }\\n                \\n                // put value in map\\n                map.put(node, childsum);\\n                \\n                curLevelChildSum += childsum;\\n                \\n                node.val = lastLevelChildSum - map.getOrDefault(par, 0);  // get(par) gives me childsum of this node\\'s parent\\n            }\\n            \\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427535,
                "title": "simple-solution-bfs-o-n-time-o-n-space-comment-explained-cousins-in-binary-tree-ii",
                "content": "# Intuition\\n1. Initialize a queue and enqueue the root node with level -1.\\n2. Set the values of the root and its children to 0.\\n3. While the queue is not empty:\\na. Dequeue a node and its level from the front of the queue.\\nb. If the level is greater than 0 (i.e., the node is not at the root level):\\ni. Update the node value to the difference between the sum at the current level and the sum of its children.\\nc. Enqueue the node\\'s children along with their sum.\\nd. Update the sum at the current level.\\nReturn the root node.\\n\\n# Approach\\nWe can use a level-order traversal (BFS) to traverse the binary tree and update the node values.\\n\\nFor each node that we visit, we need to compute the sum of the values of its cousins. We can keep track of the sum of the values of the nodes at the current level by maintaining a sum variable. For each node at the current level, we add the values of its children to the sum and enqueue the children along with their sum. When we encounter a node at the next level, we update its value to the difference between the sum and the sum of its children.\\n\\nTo keep track of the level of each node, we can enqueue a pair containing the node and its level instead of just the node.\\n\\nWe also need to initialize the values of the root node and its children to 0.\\n\\n# Complexity\\n- **Time complexity:** We traverse each node of the tree once, so the time complexity is O(n), where n is the number of nodes in the tree.\\n\\n\\n- **Space complexity:**  Since we are using a queue data structure so space complexity is: O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n    \\n        queue<pair<TreeNode*, int>> q; // make a queue which will store the node and will also store node\\'s children sum;\\n        int temp,k=0;\\n        q.push({root, -1}); //Since first node so will push -1 for sum\\n        root->val=0;\\n\\n        // Considering tree starts form level 1\\n        // for 2nd level since only 2 roots and have same parent so we will always push 0 for both the childs\\n        if(root->left)\\n            root->left->val=0;\\n        if(root->right)\\n            root->right->val=0;\\n\\n        while(!q.empty())\\n        {\\n            int s=q.size(); //current queue size\\n            int sum=0;\\n            k++;\\n\\n            //iterating through the current size of queue\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode* t=q.front().first;\\n                int psum=q.front().second;\\n                q.pop();\\n                int cs=0;\\n\\n                if(k>1)  // since we have already pushed 0,0 for 2nd level so we are ignoring for 2nd level\\n                    t->val=temp-psum;\\n                if(t->left)\\n                    cs=cs+t->left->val;\\n                if(t->right)\\n                    cs=cs+t->right->val;\\n\\n                sum+=cs;       // sum is carrying the total sum a level node\\'s value\\n                if(t->left)\\n                    q.push({t->left, cs});\\n                if(t->right)\\n                    q.push({t->right, cs});\\n            }\\n            temp=sum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n    \\n        queue<pair<TreeNode*, int>> q; // make a queue which will store the node and will also store node\\'s children sum;\\n        int temp,k=0;\\n        q.push({root, -1}); //Since first node so will push -1 for sum\\n        root->val=0;\\n\\n        // Considering tree starts form level 1\\n        // for 2nd level since only 2 roots and have same parent so we will always push 0 for both the childs\\n        if(root->left)\\n            root->left->val=0;\\n        if(root->right)\\n            root->right->val=0;\\n\\n        while(!q.empty())\\n        {\\n            int s=q.size(); //current queue size\\n            int sum=0;\\n            k++;\\n\\n            //iterating through the current size of queue\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode* t=q.front().first;\\n                int psum=q.front().second;\\n                q.pop();\\n                int cs=0;\\n\\n                if(k>1)  // since we have already pushed 0,0 for 2nd level so we are ignoring for 2nd level\\n                    t->val=temp-psum;\\n                if(t->left)\\n                    cs=cs+t->left->val;\\n                if(t->right)\\n                    cs=cs+t->right->val;\\n\\n                sum+=cs;       // sum is carrying the total sum a level node\\'s value\\n                if(t->left)\\n                    q.push({t->left, cs});\\n                if(t->right)\\n                    q.push({t->right, cs});\\n            }\\n            temp=sum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420260,
                "title": "c-single-bfs-no-extra-space",
                "content": "Time complexity- O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n         q.push(root);\\n        vector<int> v;\\n        int ans=root->val;\\n        while(!q.empty()){\\n            int sz=q.size(); int sum=0;\\n            for(int i=0;i<sz;i++){\\n                auto p=q.front(); q.pop();\\n                p->val=ans-p->val;\\n                if(p->left){  q.push(p->left); sum+=p->left->val; }\\n                if(p->right) { q.push(p->right); sum+=p->right->val; }\\n                if(p->left&&p->right){\\n                    int x=p->right->val+p->left->val;\\n                    p->left->val=x;\\n                    p->right->val=x;\\n                }\\n            }\\n            ans=sum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n         q.push(root);\\n        vector<int> v;\\n        int ans=root->val;\\n        while(!q.empty()){\\n            int sz=q.size(); int sum=0;\\n            for(int i=0;i<sz;i++){\\n                auto p=q.front(); q.pop();\\n                p->val=ans-p->val;\\n                if(p->left){  q.push(p->left); sum+=p->left->val; }\\n                if(p->right) { q.push(p->right); sum+=p->right->val; }\\n                if(p->left&&p->right){\\n                    int x=p->right->val+p->left->val;\\n                    p->left->val=x;\\n                    p->right->val=x;\\n                }\\n            }\\n            ans=sum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420221,
                "title": "level-order-traversal-and-then-dfs-hashmap",
                "content": "# Intuition\\nConsider a node, $$node$$. Another node, $$cousin$$ is that node which is on the same level/depth as $$node$$ but has a different (immediate) parent than $$node$$ does.\\n \\nWe need to find the sum of values of all the cousins for a given node, a simpler problem would be to first calculate the sum of all nodes at a given level(**Level Order Traversal**), and then subtract something to this value. That value is nothing but the sum of the value of current Node, and it\\'s sibling. \\nConsider the tree: \\n![image.png](https://assets.leetcode.com/users/images/e232ce90-dd2f-4bbe-8c8b-d8af60a63676_1681574863.7901134.png) \\n\\nFor $$1$$, the value is:\\n```\\nRequired value for node with value 1:\\n Sum of the values of every node at that level - (1+10)\\n-\\n```\\nOr simply, take the node with value **4**, keep track of the sum of it\\'s children, $$(1+10)$$, and use that to calculate their modified value. This can be done using a dfs\\n\\n# Approach\\nWe create two Hash Tables, one for:\\n# Level Sum = Sum of all the node values at a given level\\n# Parent Sum= For a given node, the sum of values of all its children(only **root.left and root.right**, or upto 1 level lower. )\\n\\n\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        HashMap<TreeNode,Integer> map = new HashMap<>();\\n        ArrayDeque<TreeNode> q= new ArrayDeque<>();\\n        q.add(root);\\n        HashMap<Integer,Integer> level = new HashMap<>(); \\n        int l=0; //variable for level.\\n        \\n        while(!q.isEmpty()){\\n            int tsize=q.size();\\n            l++;\\n            int levelsum=0;\\n            while(tsize-- >0 ){\\n                TreeNode node = q.removeFirst(); \\n                //maintaining level sum:\\n                levelsum+=node.val;\\n\\n                //Computing sum of children:\\n                int lsum=node.left==null?0:node.left.val;\\n                int rsum=node.right==null?0:node.right.val;\\n                map.put(node,lsum+rsum);\\n\\n\\n                if(node.left!=null) q.addLast(node.left);\\n                if(node.right!=null) q.addLast(node.right);\\n            }\\n            level.put(l,levelsum); //set the sum value for current level\\n            \\n        }\\n        //update node values in a pre-order traversal\\n        //keeping track of the parent for every node.\\n        f(root,null,1,map,level);\\n        root.val=0;\\n        return root;\\n        \\n    }\\n    public void f(TreeNode root,TreeNode parent,int lev, HashMap<TreeNode,Integer> map,HashMap<Integer,Integer> level ){\\n        if(root==null) return;\\n        int psum= map.getOrDefault(parent,0);\\n        int lsum=level.get(lev);\\n        root.val=lsum-psum;\\n        f(root.left,root,lev+1,map,level);\\n        f(root.right,root,lev+1,map,level);\\n\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nRequired value for node with value 1:\\n Sum of the values of every node at that level - (1+10)\\n-\\n```\n```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        HashMap<TreeNode,Integer> map = new HashMap<>();\\n        ArrayDeque<TreeNode> q= new ArrayDeque<>();\\n        q.add(root);\\n        HashMap<Integer,Integer> level = new HashMap<>(); \\n        int l=0; //variable for level.\\n        \\n        while(!q.isEmpty()){\\n            int tsize=q.size();\\n            l++;\\n            int levelsum=0;\\n            while(tsize-- >0 ){\\n                TreeNode node = q.removeFirst(); \\n                //maintaining level sum:\\n                levelsum+=node.val;\\n\\n                //Computing sum of children:\\n                int lsum=node.left==null?0:node.left.val;\\n                int rsum=node.right==null?0:node.right.val;\\n                map.put(node,lsum+rsum);\\n\\n\\n                if(node.left!=null) q.addLast(node.left);\\n                if(node.right!=null) q.addLast(node.right);\\n            }\\n            level.put(l,levelsum); //set the sum value for current level\\n            \\n        }\\n        //update node values in a pre-order traversal\\n        //keeping track of the parent for every node.\\n        f(root,null,1,map,level);\\n        root.val=0;\\n        return root;\\n        \\n    }\\n    public void f(TreeNode root,TreeNode parent,int lev, HashMap<TreeNode,Integer> map,HashMap<Integer,Integer> level ){\\n        if(root==null) return;\\n        int psum= map.getOrDefault(parent,0);\\n        int lsum=level.get(lev);\\n        root.val=lsum-psum;\\n        f(root.left,root,lev+1,map,level);\\n        f(root.right,root,lev+1,map,level);\\n\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420085,
                "title": "simple-level-order-traversal-dfs",
                "content": "# Approach\\n- Used two hash table to store sum of each level and child sum to it\\'s parent respectively.\\n- then update current node value with the entire sum of that level minus parentSum of current node.\\n\\n# Complexity\\nWhere N is number of Nodes\\n- Time O(N)\\n- Space O(N)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def replaceValueInTree(self, root):\\n        def dfs(root, parent, lvl):\\n            if not root: return\\n            parentSum[parent] += root.val\\n            levelSum[lvl] += root.val\\n            dfs(root.left, root, lvl + 1)\\n            dfs(root.right, root, lvl + 1)\\n\\n        levelSum = defaultdict(int)\\n        parentSum = defaultdict(int)\\n        dfs(root, None, 0)\\n        queue = [[root, None, 0]]\\n        while queue:\\n            for _ in range(len(queue)):\\n                node, parent, lvl = queue.pop(0)\\n                sum_ = levelSum[lvl] - parentSum[parent]\\n                node.val = sum_\\n                if node.left: queue.append([node.left, node, lvl + 1])\\n                if node.right: queue.append([node.right, node, lvl + 1])\\n        return root\\n```\\nUpVote, if you like it **:)**",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def replaceValueInTree(self, root):\\n        def dfs(root, parent, lvl):\\n            if not root: return\\n            parentSum[parent] += root.val\\n            levelSum[lvl] += root.val\\n            dfs(root.left, root, lvl + 1)\\n            dfs(root.right, root, lvl + 1)\\n\\n        levelSum = defaultdict(int)\\n        parentSum = defaultdict(int)\\n        dfs(root, None, 0)\\n        queue = [[root, None, 0]]\\n        while queue:\\n            for _ in range(len(queue)):\\n                node, parent, lvl = queue.pop(0)\\n                sum_ = levelSum[lvl] - parentSum[parent]\\n                node.val = sum_\\n                if node.left: queue.append([node.left, node, lvl + 1])\\n                if node.right: queue.append([node.right, node, lvl + 1])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444565,
                "title": "level-order-c-easy-explanation",
                "content": "# Approach\\n   1. Find the sum at each level and store it in the map with depth as key and sum as pair\\n   2. Then to  a current Node the cousin sum for its each child Nodes will be (level sum of its children) - (sum of it\\'s childrent)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n         // Initialize a map to store the sum of nodes at each level\\n         map<int, int> mp;\\n       \\n         queue<TreeNode*>q;\\n       \\n         q.push(root);\\n       \\n         int depth = 0;\\n      \\n         while(!q.empty()){\\n             int l = q.size();\\n             int ans = 0;\\n      \\n             for(int i = 0;i<l;i++){\\n                 // Get the current node from the front of the queue\\n                 TreeNode* curr = q.front();\\n                 q.pop();\\n                 \\n                 ans+= curr->val;\\n                \\n                 if(curr->left) q.push(curr->left);\\n                 if(curr->right) q.push(curr->right);\\n             }\\n           \\n             mp[depth++] = ans;\\n         }\\n\\n         // Reset the depth to 0 and push the root node onto the queue again\\n         depth = 0;\\n         root->val = 0;\\n         q.push(root);\\n\\n         // Traverse the tree level by level again\\n         while(!q.empty()){\\n             int l = q.size();\\n             // Iterate through each node at the current level\\n             for(int i = 0;i<l;i++){\\n                // Get the current node from the front of the queue\\n                TreeNode* currNode = q.front();\\n                q.pop();\\n                // Get the sum of nodes at the next level\\n                int SumOfNextLevel = mp[depth+1];\\n                // Subtract the sum of the current node\\'s children from the sum of nodes at the next level\\n                if(currNode->left) SumOfNextLevel-= currNode->left->val;\\n                if(currNode->right) SumOfNextLevel-= currNode->right->val;\\n                // Set the current node\\'s value to the sum of its cousins\\n               \\n                if(currNode->left) {\\n                currNode->left->val = SumOfNextLevel;\\n                q.push(currNode->left);\\n                }\\n\\n                if(currNode->right) {\\n                currNode->right->val = SumOfNextLevel;\\n                q.push(currNode->right);\\n               }\\n             }\\n            \\n             depth++;\\n         }\\n         \\n         \\n         return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n         // Initialize a map to store the sum of nodes at each level\\n         map<int, int> mp;\\n       \\n         queue<TreeNode*>q;\\n       \\n         q.push(root);\\n       \\n         int depth = 0;\\n      \\n         while(!q.empty()){\\n             int l = q.size();\\n             int ans = 0;\\n      \\n             for(int i = 0;i<l;i++){\\n                 // Get the current node from the front of the queue\\n                 TreeNode* curr = q.front();\\n                 q.pop();\\n                 \\n                 ans+= curr->val;\\n                \\n                 if(curr->left) q.push(curr->left);\\n                 if(curr->right) q.push(curr->right);\\n             }\\n           \\n             mp[depth++] = ans;\\n         }\\n\\n         // Reset the depth to 0 and push the root node onto the queue again\\n         depth = 0;\\n         root->val = 0;\\n         q.push(root);\\n\\n         // Traverse the tree level by level again\\n         while(!q.empty()){\\n             int l = q.size();\\n             // Iterate through each node at the current level\\n             for(int i = 0;i<l;i++){\\n                // Get the current node from the front of the queue\\n                TreeNode* currNode = q.front();\\n                q.pop();\\n                // Get the sum of nodes at the next level\\n                int SumOfNextLevel = mp[depth+1];\\n                // Subtract the sum of the current node\\'s children from the sum of nodes at the next level\\n                if(currNode->left) SumOfNextLevel-= currNode->left->val;\\n                if(currNode->right) SumOfNextLevel-= currNode->right->val;\\n                // Set the current node\\'s value to the sum of its cousins\\n               \\n                if(currNode->left) {\\n                currNode->left->val = SumOfNextLevel;\\n                q.push(currNode->left);\\n                }\\n\\n                if(currNode->right) {\\n                currNode->right->val = SumOfNextLevel;\\n                q.push(currNode->right);\\n               }\\n             }\\n            \\n             depth++;\\n         }\\n         \\n         \\n         return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423474,
                "title": "bfs-and-dfs-java-solution",
                "content": "# Intuition\\nBFS , DFS\\n\\n# Approach\\n- First of All , traverse to every level and store the sum of every element of that level in a list.\\n- To store the level sum , we have created a method levelsum.\\n- Now traverse to every node again and if it has both child then put them in a map first child node as a key and its brother\\'s val as a value and vice-versa.\\n- For this, process there is a method called getRealBrothers.\\n- Now , do simple DFS to modify the values of every node.\\n- For this, just traverse to every node and if there exists it\\'s real brother then just substract it\\'s value and also it\\'s real brother\\'s value from the current level sum and modify the value of that node to the value you have got in the end after the substraction.\\n- Now you have the required modified tree.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void levelsum(TreeNode root,List<Integer>list){\\n        if(root==null) return;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        q.add(null);\\n        while(!q.isEmpty()){\\n            int sum = 0;\\n            while(q.peek()!=null){\\n               sum += q.peek().val;\\n               if(q.peek().left!=null) q.add(q.peek().left);\\n               if(q.peek().right!=null) q.add(q.peek().right);\\n               q.poll();\\n            }\\n            q.poll();\\n            list.add(sum);\\n            if(q.size()>0)  q.add(null);\\n        }\\n    }\\n    public void getRealBrothers(TreeNode root,HashMap<TreeNode,Integer> map){\\n        if(root==null) return;\\n        if(root.left != null && root.right != null){\\n            map.putIfAbsent(root.left,root.right.val);\\n            map.putIfAbsent(root.right,root.left.val);\\n        }\\n        getRealBrothers(root.left,map);\\n        getRealBrothers(root.right,map);\\n    }\\n    public void dfs(TreeNode root,HashMap<TreeNode,Integer> map,List<Integer>list,int level){\\n        if(root==null) return;\\n        int sum = map.containsKey(root)?map.get(root):0;\\n        root.val = list.get(level)-sum-root.val;\\n        dfs(root.left,map,list,level+1);\\n        dfs(root.right,map,list,level+1);\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        HashMap<TreeNode,Integer> map = new HashMap<>();\\n        levelsum(root,list);\\n        getRealBrothers(root,map);\\n        dfs(root,map,list,0);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void levelsum(TreeNode root,List<Integer>list){\\n        if(root==null) return;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        q.add(null);\\n        while(!q.isEmpty()){\\n            int sum = 0;\\n            while(q.peek()!=null){\\n               sum += q.peek().val;\\n               if(q.peek().left!=null) q.add(q.peek().left);\\n               if(q.peek().right!=null) q.add(q.peek().right);\\n               q.poll();\\n            }\\n            q.poll();\\n            list.add(sum);\\n            if(q.size()>0)  q.add(null);\\n        }\\n    }\\n    public void getRealBrothers(TreeNode root,HashMap<TreeNode,Integer> map){\\n        if(root==null) return;\\n        if(root.left != null && root.right != null){\\n            map.putIfAbsent(root.left,root.right.val);\\n            map.putIfAbsent(root.right,root.left.val);\\n        }\\n        getRealBrothers(root.left,map);\\n        getRealBrothers(root.right,map);\\n    }\\n    public void dfs(TreeNode root,HashMap<TreeNode,Integer> map,List<Integer>list,int level){\\n        if(root==null) return;\\n        int sum = map.containsKey(root)?map.get(root):0;\\n        root.val = list.get(level)-sum-root.val;\\n        dfs(root.left,map,list,level+1);\\n        dfs(root.right,map,list,level+1);\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        HashMap<TreeNode,Integer> map = new HashMap<>();\\n        levelsum(root,list);\\n        getRealBrothers(root,map);\\n        dfs(root,map,list,0);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422515,
                "title": "bsf-traversal-java-using-map-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        Map<TreeNode, List<Integer>> map = new HashMap<>();\\n        root.val = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int sum = 0;\\n            map = new HashMap<>();\\n            for(int i = 0; i < size; i++) {\\n                TreeNode cur = q.poll();\\n                map.put(cur, new ArrayList<>());\\n                if(cur.left != null) {\\n                    sum += cur.left.val;\\n                    q.add(cur.left);\\n                    map.get(cur).add(cur.left.val);\\n                }\\n                if(cur.right != null) {\\n                    sum += cur.right.val;\\n                    q.add(cur.right);\\n                    map.get(cur).add(cur.right.val);\\n                }\\n            }\\n            for(Map.Entry<TreeNode,List<Integer>> entry : map.entrySet()) {\\n                if(entry.getValue().size() == 2) {\\n                    int num = entry.getValue().get(0)+entry.getValue().get(1);\\n                    entry.getKey().left.val = sum - num;\\n                    entry.getKey().right.val = sum - num;\\n                } else if(entry.getValue().size() == 1) {\\n                    if(entry.getKey().left != null) entry.getKey().left.val = sum - entry.getValue().get(0);\\n                    else if(entry.getKey().right != null) entry.getKey().right.val = sum - entry.getValue().get(0);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        Map<TreeNode, List<Integer>> map = new HashMap<>();\\n        root.val = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int sum = 0;\\n            map = new HashMap<>();\\n            for(int i = 0; i < size; i++) {\\n                TreeNode cur = q.poll();\\n                map.put(cur, new ArrayList<>());\\n                if(cur.left != null) {\\n                    sum += cur.left.val;\\n                    q.add(cur.left);\\n                    map.get(cur).add(cur.left.val);\\n                }\\n                if(cur.right != null) {\\n                    sum += cur.right.val;\\n                    q.add(cur.right);\\n                    map.get(cur).add(cur.right.val);\\n                }\\n            }\\n            for(Map.Entry<TreeNode,List<Integer>> entry : map.entrySet()) {\\n                if(entry.getValue().size() == 2) {\\n                    int num = entry.getValue().get(0)+entry.getValue().get(1);\\n                    entry.getKey().left.val = sum - num;\\n                    entry.getKey().right.val = sum - num;\\n                } else if(entry.getValue().size() == 1) {\\n                    if(entry.getKey().left != null) entry.getKey().left.val = sum - entry.getValue().get(0);\\n                    else if(entry.getKey().right != null) entry.getKey().right.val = sum - entry.getValue().get(0);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420207,
                "title": "python3-simple-bfs",
                "content": "lets consider some node -> node X , \\nif node X has sibling then new value = (sum of level) - nodeX.val - (sibling of nodeX) , else new value =  (sum of level ) - nodeX.val . when storing child node in queue, check if it has sibling and if yes then store map[childnode] = (sibling node value)in hmap.\\n```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        dq = deque([root])\\n        hmap = {}\\n        total = 0\\n        while dq:\\n            size = len(dq)\\n            temp = 0\\n            for i in range(size):\\n                curr = dq.popleft()\\n                curr.val = max(0,total - curr.val - (hmap[curr] if curr in hmap else 0))\\n                if curr.left and curr.right:   \\n                    hmap[curr.left] = curr.right.val\\n                    hmap[curr.right] = curr.left.val\\n                    temp += curr.left.val + curr.right.val\\n                    dq.append(curr.left)\\n                    dq.append(curr.right)\\n                elif curr.right:\\n                    temp += curr.right.val\\n                    dq.append(curr.right)\\n                elif curr.left:\\n                    temp += curr.left.val\\n                    dq.append(curr.left)\\n            total = temp\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        dq = deque([root])\\n        hmap = {}\\n        total = 0\\n        while dq:\\n            size = len(dq)\\n            temp = 0\\n            for i in range(size):\\n                curr = dq.popleft()\\n                curr.val = max(0,total - curr.val - (hmap[curr] if curr in hmap else 0))\\n                if curr.left and curr.right:   \\n                    hmap[curr.left] = curr.right.val\\n                    hmap[curr.right] = curr.left.val\\n                    temp += curr.left.val + curr.right.val\\n                    dq.append(curr.left)\\n                    dq.append(curr.right)\\n                elif curr.right:\\n                    temp += curr.right.val\\n                    dq.append(curr.right)\\n                elif curr.left:\\n                    temp += curr.left.val\\n                    dq.append(curr.left)\\n            total = temp\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420196,
                "title": "c-level-order-traversal-easy-to-understand-code",
                "content": "````\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q1,q2;\\n        int n,d;\\n        TreeNode* node;\\n        q1.push(root);\\n        unordered_map<int,int> mp;\\n        int sum = 0;\\n        while(!q1.empty()){\\n            n = q1.size();\\n            sum = 0;\\n            q2 = q1;\\n            d = 0;\\n            mp.clear();\\n            while(n--){\\n                node = q1.front();\\n                q1.pop();\\n                if(node->left){\\n                    q1.push(node->left);\\n                    sum += node->left->val;\\n                    mp[d] += node->left->val;\\n                }\\n                if(node->right){\\n                    q1.push(node->right);\\n                    sum += node->right->val;\\n                    mp[d] += node->right->val;\\n                }\\n                d++;\\n            }\\n            \\n            n = q2.size();\\n            d = 0;\\n            while(n--){\\n                node = q2.front();\\n                q2.pop();\\n                if(node->left){\\n                    node->left->val = sum-mp[d];\\n                }\\n                if(node->right){\\n                    node->right->val = sum-mp[d];\\n                }\\n                d++;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q1,q2;\\n        int n,d;\\n        TreeNode* node;\\n        q1.push(root);\\n        unordered_map<int,int> mp;\\n        int sum = 0;\\n        while(!q1.empty()){\\n            n = q1.size();\\n            sum = 0;\\n            q2 = q1;\\n            d = 0;\\n            mp.clear();\\n            while(n--){\\n                node = q1.front();\\n                q1.pop();\\n                if(node->left){\\n                    q1.push(node->left);\\n                    sum += node->left->val;\\n                    mp[d] += node->left->val;\\n                }\\n                if(node->right){\\n                    q1.push(node->right);\\n                    sum += node->right->val;\\n                    mp[d] += node->right->val;\\n                }\\n                d++;\\n            }\\n            \\n            n = q2.size();\\n            d = 0;\\n            while(n--){\\n                node = q2.front();\\n                q2.pop();\\n                if(node->left){\\n                    node->left->val = sum-mp[d];\\n                }\\n                if(node->right){\\n                    node->right->val = sum-mp[d];\\n                }\\n                d++;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420195,
                "title": "simple-solution-maps-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, long long int> m; // To store the sum of the children \\n    vector<vector<TreeNode*>> depth; // to store the nodes at the given depth\\n    \\n    void dfs(TreeNode* root, int d){\\n        if(!root) return; \\n        if(depth.size()<d){\\n            depth.push_back({});\\n        }\\n        depth[d-1].push_back(root);\\n        long long int x = 0; \\n        \\n        if(root->right){\\n            x+=root->right->val; \\n            dfs(root->right, d+1); \\n        }\\n        if(root->left){ \\n            x+=root->left->val; \\n            dfs(root->left, d+1);\\n        } \\n        m[root] = x; \\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        dfs(root, 1); \\n        \\n        for(int i = depth.size()-1; i>=0; i--){\\n            long long int sum = 0; // sum is used to store the sum of all the nodes that are at depth same as that of child of j  \\n            for(auto &j:depth[i]){\\n                j->val =0; \\n                if(m[j]) sum+=m[j]; \\n            }\\n            // If there are children, then we can change their values. \\n            if(sum){\\n                for(auto &j:depth[i]){\\n                    // (sum-m[j]) gives us the sum value of the other nodes that are at the same depth as that of the children of j \\n                    \\n                    if(j->left){\\n                        j->left->val = sum - m[j]; \\n                    }\\n                    if(j->right){\\n                        j->right->val = sum - m[j]; \\n                    }\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, long long int> m; // To store the sum of the children \\n    vector<vector<TreeNode*>> depth; // to store the nodes at the given depth\\n    \\n    void dfs(TreeNode* root, int d){\\n        if(!root) return; \\n        if(depth.size()<d){\\n            depth.push_back({});\\n        }\\n        depth[d-1].push_back(root);\\n        long long int x = 0; \\n        \\n        if(root->right){\\n            x+=root->right->val; \\n            dfs(root->right, d+1); \\n        }\\n        if(root->left){ \\n            x+=root->left->val; \\n            dfs(root->left, d+1);\\n        } \\n        m[root] = x; \\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        dfs(root, 1); \\n        \\n        for(int i = depth.size()-1; i>=0; i--){\\n            long long int sum = 0; // sum is used to store the sum of all the nodes that are at depth same as that of child of j  \\n            for(auto &j:depth[i]){\\n                j->val =0; \\n                if(m[j]) sum+=m[j]; \\n            }\\n            // If there are children, then we can change their values. \\n            if(sum){\\n                for(auto &j:depth[i]){\\n                    // (sum-m[j]) gives us the sum value of the other nodes that are at the same depth as that of the children of j \\n                    \\n                    if(j->left){\\n                        j->left->val = sum - m[j]; \\n                    }\\n                    if(j->right){\\n                        j->right->val = sum - m[j]; \\n                    }\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420168,
                "title": "2-dfs-solution",
                "content": "# Intuition\\nUse DFS\\n\\n# Approach\\nDuring first DFS calculate sum of nodes on each level and store initial node value for every node.\\nDuring second DFS for every node:\\n1. Get node parent\\n2. Get both children of the current node parent.\\n3. Get total sum for node level\\n4. Extract sum of parent both child from total level sum.\\n5. Set this value as new value for the node.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\n\\nlet levelSums\\nlet nodeValues\\nlet parents\\nvar replaceValueInTree = function(root) {\\n    levelSums = new Map()\\n    nodeValues = new Map()\\n    parents = new Map()\\n    \\n    dfs1(root, 0, null)\\n    console.log(levelSums)\\n    dfs2(root, 0, null)\\n    \\n    return root\\n    \\n};\\n\\nfunction dfs1(node, level, parent){\\n    if(node == null){\\n        return\\n    }\\n    nodeValues.set(node, node.val)\\n    \\n    if(!levelSums.has(level)){\\n        levelSums.set(level, 0)\\n    }\\n    \\n    levelSums.set(level, node.val + levelSums.get(level))\\n    dfs1(node.left, level + 1, node)\\n    \\n    dfs1(node.right, level + 1, node)\\n    \\n    \\n}\\n\\nfunction dfs2(node, level, parent){\\n    if(node == null){\\n        return\\n    }\\n    if(parent == null){\\n        node.val = 0;\\n       \\n    } else{\\n\\n        let sum = levelSums.get(level);\\n        let left = parent.left\\n        let right = parent.right\\n\\n        if(left){\\n\\n            sum -= nodeValues.get(left)\\n        }\\n        if(right){\\n            sum -= nodeValues.get(right)\\n        }\\n\\n        node.val = sum;\\n    }\\n    \\n    dfs2(node.left, level+1, node)\\n    dfs2(node.right, level+1, node)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\n\\nlet levelSums\\nlet nodeValues\\nlet parents\\nvar replaceValueInTree = function(root) {\\n    levelSums = new Map()\\n    nodeValues = new Map()\\n    parents = new Map()\\n    \\n    dfs1(root, 0, null)\\n    console.log(levelSums)\\n    dfs2(root, 0, null)\\n    \\n    return root\\n    \\n};\\n\\nfunction dfs1(node, level, parent){\\n    if(node == null){\\n        return\\n    }\\n    nodeValues.set(node, node.val)\\n    \\n    if(!levelSums.has(level)){\\n        levelSums.set(level, 0)\\n    }\\n    \\n    levelSums.set(level, node.val + levelSums.get(level))\\n    dfs1(node.left, level + 1, node)\\n    \\n    dfs1(node.right, level + 1, node)\\n    \\n    \\n}\\n\\nfunction dfs2(node, level, parent){\\n    if(node == null){\\n        return\\n    }\\n    if(parent == null){\\n        node.val = 0;\\n       \\n    } else{\\n\\n        let sum = levelSums.get(level);\\n        let left = parent.left\\n        let right = parent.right\\n\\n        if(left){\\n\\n            sum -= nodeValues.get(left)\\n        }\\n        if(right){\\n            sum -= nodeValues.get(right)\\n        }\\n\\n        node.val = sum;\\n    }\\n    \\n    dfs2(node.left, level+1, node)\\n    dfs2(node.right, level+1, node)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420151,
                "title": "c-bfs-easy",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        int n=1;\\n        vector<TreeNode*> a1;\\n        unordered_map<TreeNode*, TreeNode*> par;\\n        unordered_map<TreeNode*,int> childSum;\\n        a1.push_back(root);\\n        root->val = 0;\\n        \\n        while(n){\\n            int sum=0,sChild=0;\\n            vector<TreeNode*> a2;\\n            \\n            for(int i=0;i<n;i++){\\n                sChild=0;\\n                auto fr = a1[i];\\n                sum += fr->val;\\n                if(fr->left){\\n                    a2.push_back(fr->left);\\n                    sChild+=fr->left->val;\\n                    par[fr->left] = fr;\\n                }\\n                if(fr->right){\\n                    a2.push_back(fr->right);\\n                    sChild += fr->right->val;\\n                    par[fr->right] = fr;\\n                }\\n                childSum[fr] = sChild;\\n            }\\n            for(int i=0;i<n;i++){\\n                auto fr = a1[i];\\n                fr->val = sum - childSum[par[fr]];\\n            }\\n            a1=a2;\\n            n=a1.size();\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        int n=1;\\n        vector<TreeNode*> a1;\\n        unordered_map<TreeNode*, TreeNode*> par;\\n        unordered_map<TreeNode*,int> childSum;\\n        a1.push_back(root);\\n        root->val = 0;\\n        \\n        while(n){\\n            int sum=0,sChild=0;\\n            vector<TreeNode*> a2;\\n            \\n            for(int i=0;i<n;i++){\\n                sChild=0;\\n                auto fr = a1[i];\\n                sum += fr->val;\\n                if(fr->left){\\n                    a2.push_back(fr->left);\\n                    sChild+=fr->left->val;\\n                    par[fr->left] = fr;\\n                }\\n                if(fr->right){\\n                    a2.push_back(fr->right);\\n                    sChild += fr->right->val;\\n                    par[fr->right] = fr;\\n                }\\n                childSum[fr] = sChild;\\n            }\\n            for(int i=0;i<n;i++){\\n                auto fr = a1[i];\\n                fr->val = sum - childSum[par[fr]];\\n            }\\n            a1=a2;\\n            n=a1.size();\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420138,
                "title": "level-order-traversal-c-easy-to-understnad",
                "content": "````\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q1,q2;\\n        for(int i = 0; i < 1000; i++){}\\n        int n,d;\\n        TreeNode* node;\\n        q1.push(root);\\n        unordered_map<int,int> mp;\\n        int sum = 0;\\n        while(!q1.empty()){\\n            n = q1.size();\\n            sum = 0;\\n            q2 = q1;\\n            d = 0;\\n            mp.clear();\\n            while(n--){\\n                node = q1.front();\\n                q1.pop();\\n                if(node->left){\\n                    q1.push(node->left);\\n                    sum += node->left->val;\\n                    mp[d] += node->left->val;\\n                }\\n                if(node->right){\\n                    q1.push(node->right);\\n                    sum += node->right->val;\\n                    mp[d] += node->right->val;\\n                }\\n                d++;\\n            }\\n            \\n            n = q2.size();\\n            d = 0;\\n            while(n--){\\n                node = q2.front();\\n                q2.pop();\\n                if(node->left){\\n                    node->left->val = sum-mp[d];\\n                }\\n                if(node->right){\\n                    node->right->val = sum-mp[d];\\n                }\\n                d++;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "````\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q1,q2;\\n        for(int i = 0; i < 1000; i++){}\\n        int n,d;\\n        TreeNode* node;\\n        q1.push(root);\\n        unordered_map<int,int> mp;\\n        int sum = 0;\\n        while(!q1.empty()){\\n            n = q1.size();\\n            sum = 0;\\n            q2 = q1;\\n            d = 0;\\n            mp.clear();\\n            while(n--){\\n                node = q1.front();\\n                q1.pop();\\n                if(node->left){\\n                    q1.push(node->left);\\n                    sum += node->left->val;\\n                    mp[d] += node->left->val;\\n                }\\n                if(node->right){\\n                    q1.push(node->right);\\n                    sum += node->right->val;\\n                    mp[d] += node->right->val;\\n                }\\n                d++;\\n            }\\n            \\n            n = q2.size();\\n            d = 0;\\n            while(n--){\\n                node = q2.front();\\n                q2.pop();\\n                if(node->left){\\n                    node->left->val = sum-mp[d];\\n                }\\n                if(node->right){\\n                    node->right->val = sum-mp[d];\\n                }\\n                d++;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420105,
                "title": "c-solution-using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void fill(unordered_map<int,int>&m,int level,TreeNode* root){\\n        if(root==NULL)return;\\n        m[level]+=root->val;\\n        fill(m,level+1,root->left);\\n        fill(m,level+1,root->right);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int>m;\\n        fill(m,0,root);\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int level=0;\\n        root->val=0;\\n        // for(auto i:m)cout<<i.first<<\" \"<<i.second<<endl;\\n        while(q.size()){\\n            int n=q.size();\\n            int sum=m[level+1];\\n            while(n--)\\n            {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                if(front->left)sum-=front->left->val;\\n                if(front->right)sum-=front->right->val;\\n                // cout<<sum<<\" \"<<front->val<<endl;\\n                if(front->left)\\n                front->left->val=sum;\\n                if(front->right)\\n                front->right->val=sum;\\n                sum=m[level+1];\\n                \\n                \\n                \\n                if(front->left)q.push(front->left);\\n                if(front->right)q.push(front->right);\\n            }\\n            level++;\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void fill(unordered_map<int,int>&m,int level,TreeNode* root){\\n        if(root==NULL)return;\\n        m[level]+=root->val;\\n        fill(m,level+1,root->left);\\n        fill(m,level+1,root->right);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int>m;\\n        fill(m,0,root);\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int level=0;\\n        root->val=0;\\n        // for(auto i:m)cout<<i.first<<\" \"<<i.second<<endl;\\n        while(q.size()){\\n            int n=q.size();\\n            int sum=m[level+1];\\n            while(n--)\\n            {\\n                TreeNode* front=q.front();\\n                q.pop();\\n                if(front->left)sum-=front->left->val;\\n                if(front->right)sum-=front->right->val;\\n                // cout<<sum<<\" \"<<front->val<<endl;\\n                if(front->left)\\n                front->left->val=sum;\\n                if(front->right)\\n                front->right->val=sum;\\n                sum=m[level+1];\\n                \\n                \\n                \\n                if(front->left)q.push(front->left);\\n                if(front->right)q.push(front->right);\\n            }\\n            level++;\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3938051,
                "title": "c-one-level-order-traversal-without-storing-level-pointer",
                "content": "# Intuition\\nthe idea is to push the value of sibling along with the pointer into the queue and you will be having level sum in advance, replace node value with level sum - sibling - self\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\nn= total number of nodes\\n\\n- Space complexity:\\nO(k) where k is number of nodes in a single level\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n\\n        queue< pair<TreeNode*,int> > q;\\n        q.push({root,0});\\n\\n        //curr_sum stores value of total level sum and for next level\\'s sum calc next_sum is updated on every push to the queue\\n        //in the end curr_sum equals to next_sum \\n        int curr_sum=root->val;\\n        \\n        while(!q.empty()){\\n            int sz=q.size();\\n\\n            int next_sum = 0;\\n\\n            for(int i=0;i<sz;i++){\\n                auto it=q.front();\\n\\n                TreeNode* node= it.first;\\n                int sibling= it.second;\\n\\n                q.pop();\\n\\n                //total level sum - sum of sibling(left or right  we don\\'t know at this moment)\\n                int newVal= curr_sum-sibling- node->val;\\n                //assign new value\\n                node->val=newVal;\\n\\n                //get value of left and right child, send value of left to right child to the left child and vice versa\\n                int left=0, right=0;\\n                if(node->left){\\n                    left=node->left->val;\\n                }\\n                if(node->right){\\n                    right=node->right->val;\\n                }\\n\\n                if(node->left){\\n                    q.push({node->left, right});\\n                    next_sum+=node->left->val;\\n                }\\n                if(node->right){\\n                    q.push({node->right, left});\\n                    next_sum+=node->right->val;\\n\\n                }\\n            }\\n\\n            curr_sum=next_sum;\\n\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n\\n        queue< pair<TreeNode*,int> > q;\\n        q.push({root,0});\\n\\n        //curr_sum stores value of total level sum and for next level\\'s sum calc next_sum is updated on every push to the queue\\n        //in the end curr_sum equals to next_sum \\n        int curr_sum=root->val;\\n        \\n        while(!q.empty()){\\n            int sz=q.size();\\n\\n            int next_sum = 0;\\n\\n            for(int i=0;i<sz;i++){\\n                auto it=q.front();\\n\\n                TreeNode* node= it.first;\\n                int sibling= it.second;\\n\\n                q.pop();\\n\\n                //total level sum - sum of sibling(left or right  we don\\'t know at this moment)\\n                int newVal= curr_sum-sibling- node->val;\\n                //assign new value\\n                node->val=newVal;\\n\\n                //get value of left and right child, send value of left to right child to the left child and vice versa\\n                int left=0, right=0;\\n                if(node->left){\\n                    left=node->left->val;\\n                }\\n                if(node->right){\\n                    right=node->right->val;\\n                }\\n\\n                if(node->left){\\n                    q.push({node->left, right});\\n                    next_sum+=node->left->val;\\n                }\\n                if(node->right){\\n                    q.push({node->right, left});\\n                    next_sum+=node->right->val;\\n\\n                }\\n            }\\n\\n            curr_sum=next_sum;\\n\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430980,
                "title": "easy-c-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->BFS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->we will calculate the sum of value of all the node at particular level using bfs then we can simply calculate value of that node by subtracting the value of that node and if it has real sibling then we will minus value of sibling also. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       map<TreeNode*,int>mp;//for storing the value of real sibling of a node\\n       \\n       while(!q.empty()){\\n           int sz =q.size();\\n           queue<TreeNode*>temp;//for storing all the node of current level\\n           int sum =0;          //sum of values of all the node at curent level\\n           for(int i=0;i<sz;i++){\\n               auto it =q.front();\\n               q.pop();\\n               \\n               sum+=it->val;  //calculating sum \\n               temp.push(it);\\n            if(it->left!=NULL){\\n                q.push(it->left);\\n                if(it->right!=NULL){\\n                mp[it->left]=it->right->val;//as at particular node we know parent we can check for real sibling of that node\\n                }\\n            }\\n            if(it->right!=NULL){\\n                q.push(it->right);\\n                if(it->left!=NULL){\\n                mp[it->right]=it->left->val;//as at particular node we know parent we can check for real sibling of that node\\n                }\\n            }\\n\\n           }\\n           while(!temp.empty()){\\n               auto it =temp.front();\\n               temp.pop();\\n               it->val=sum-it->val;\\n               if(mp.find(it)!=mp.end()){\\n                   it->val=it->val-mp[it];\\n               }\\n       } \\n    }\\n       return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       map<TreeNode*,int>mp;//for storing the value of real sibling of a node\\n       \\n       while(!q.empty()){\\n           int sz =q.size();\\n           queue<TreeNode*>temp;//for storing all the node of current level\\n           int sum =0;          //sum of values of all the node at curent level\\n           for(int i=0;i<sz;i++){\\n               auto it =q.front();\\n               q.pop();\\n               \\n               sum+=it->val;  //calculating sum \\n               temp.push(it);\\n            if(it->left!=NULL){\\n                q.push(it->left);\\n                if(it->right!=NULL){\\n                mp[it->left]=it->right->val;//as at particular node we know parent we can check for real sibling of that node\\n                }\\n            }\\n            if(it->right!=NULL){\\n                q.push(it->right);\\n                if(it->left!=NULL){\\n                mp[it->right]=it->left->val;//as at particular node we know parent we can check for real sibling of that node\\n                }\\n            }\\n\\n           }\\n           while(!temp.empty()){\\n               auto it =temp.front();\\n               temp.pop();\\n               it->val=sum-it->val;\\n               if(mp.find(it)!=mp.end()){\\n                   it->val=it->val-mp[it];\\n               }\\n       } \\n    }\\n       return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420809,
                "title": "simple-bfs-java-intuitive",
                "content": "# Code\\n```\\nclass Pair {\\n    public TreeNode node;\\n    public int p;\\n    public Pair(TreeNode node, int p) {\\n        this.node = node;\\n        this.p = p;\\n    }\\n}\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<Pair> q = new LinkedList<Pair>();\\n        int sum=0;\\n        int prevSum=0;\\n        q.add(new Pair(root,0));\\n        while(!q.isEmpty()) {\\n            int n = q.size();\\n            for(int i=0;i<n;i++) {\\n                int s = 0;\\n                Pair nn = q.poll();\\n                nn.node.val = prevSum - nn.p;\\n                if(nn.node.left!=null) s+=nn.node.left.val;\\n                if(nn.node.right!=null) {\\n                    s+=nn.node.right.val;\\n                    q.add(new Pair(nn.node.right,s));\\n                }\\n                if(nn.node.left!=null) q.add(new Pair(nn.node.left,s));\\n                sum+=s;\\n            }\\n            prevSum = sum;\\n            sum=0;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Pair {\\n    public TreeNode node;\\n    public int p;\\n    public Pair(TreeNode node, int p) {\\n        this.node = node;\\n        this.p = p;\\n    }\\n}\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<Pair> q = new LinkedList<Pair>();\\n        int sum=0;\\n        int prevSum=0;\\n        q.add(new Pair(root,0));\\n        while(!q.isEmpty()) {\\n            int n = q.size();\\n            for(int i=0;i<n;i++) {\\n                int s = 0;\\n                Pair nn = q.poll();\\n                nn.node.val = prevSum - nn.p;\\n                if(nn.node.left!=null) s+=nn.node.left.val;\\n                if(nn.node.right!=null) {\\n                    s+=nn.node.right.val;\\n                    q.add(new Pair(nn.node.right,s));\\n                }\\n                if(nn.node.left!=null) q.add(new Pair(nn.node.left,s));\\n                sum+=s;\\n            }\\n            prevSum = sum;\\n            sum=0;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420523,
                "title": "easy-to-understand-straightforward-solution-with-explanation-and-comments",
                "content": "# Intuition\\nThe solution is based on the follwing observations.\\n- Sum of cousins equals the difference between the sum of entire level AND the sum of siblings. \\n- We can use BFS to traverse the tree level-wise.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSteps :-\\n- Store the sum_of_children in a hashmap`hmap`, with the node refernece as the key.\\n- Maintain a running sum of the entire next level simultaneously.\\n- Now for each element in the current level do this:\\n    - pop out the node.\\n    - Use the hashmap to modify the children of the node : sum_of_next_level - sum_of_children\\n    - push the modified node into the queue for next level of operations.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        if not root.left and not root.right: return root\\n        q = deque()\\n        q.append(root)\\n        \\n        while q:\\n            hmap = {}       #store the sum of children of each node in the following fashion -> {node: node.left.val + node.right.val}\\n            size = len(q)\\n            runsum = 0      #store the running sum of next level.\\n            for i in range(size):\\n                childsum = 0      #sum of children of each node\\n                if q[i].left:\\n                    childsum+=q[i].left.val\\n                    runsum+=q[i].left.val\\n                if q[i].right:\\n                    childsum+=q[i].right.val\\n                    runsum+=q[i].right.val\\n                hmap[q[i]] = childsum       #add sum of children to hashmap\\n\\n            while size:\\n                node = q.popleft()\\n                if node.left:\\n                    node.left.val = runsum-hmap[node] #modify child\\n                    q.append(node.left) #push child in queue for next iteration       \\n                if node.right:\\n                    node.right.val =  runsum-hmap[node]\\n                    q.append(node.right)\\n                size-=1\\n                \\n        return root        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        if not root.left and not root.right: return root\\n        q = deque()\\n        q.append(root)\\n        \\n        while q:\\n            hmap = {}       #store the sum of children of each node in the following fashion -> {node: node.left.val + node.right.val}\\n            size = len(q)\\n            runsum = 0      #store the running sum of next level.\\n            for i in range(size):\\n                childsum = 0      #sum of children of each node\\n                if q[i].left:\\n                    childsum+=q[i].left.val\\n                    runsum+=q[i].left.val\\n                if q[i].right:\\n                    childsum+=q[i].right.val\\n                    runsum+=q[i].right.val\\n                hmap[q[i]] = childsum       #add sum of children to hashmap\\n\\n            while size:\\n                node = q.popleft()\\n                if node.left:\\n                    node.left.val = runsum-hmap[node] #modify child\\n                    q.append(node.left) #push child in queue for next iteration       \\n                if node.right:\\n                    node.right.val =  runsum-hmap[node]\\n                    q.append(node.right)\\n                size-=1\\n                \\n        return root        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420227,
                "title": "c-simple-bfs-level-order-traversal-clean-code-well-explained-beginner-friendly",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> levelOrder(TreeNode* root) {\\n        vector<vector<int>> ans; \\n        //base case\\n        if(root == NULL) \\n            return ans; \\n            \\n        queue<TreeNode*> q; \\n        q.push(root); \\n        \\n        //taking the level order or BFS traversal\\n        while(!q.empty()) {\\n            int size = q.size();\\n            vector<int> level;\\n            //this takes care of the whole level present\\n            while(size--){\\n                auto node = q.front();\\n                q.pop();\\n                if(node){\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                    level.push_back(node->val);\\n                }\\n//null nodes are assigned with 0 so that the total sum is not affected when we take level sum below\\n                else level.push_back(0);\\n                \\n            }\\n            ans.push_back(level);\\n        }\\n        return ans; \\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<vector<int>> lvl = levelOrder(root);\\n        if(root == NULL) \\n            return root; \\n            \\n        queue<TreeNode*> q; \\n        q.push(root);\\n        \\n        int n=0; //level number\\n        int l =lvl.size()-1;\\n        while(!q.empty() and n<l) {\\n            int size = q.size();\\n            long long sum = 0;\\n            int s = lvl[n].size();\\n            //taking the total sum present in the level\\n            for(int it=0;it<s;++it){\\n                sum+=lvl[n][it];\\n            }\\n            int j=0;\\n            while(size--){\\n                auto node = q.front();\\n                q.pop();\\n                if(node){\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                //node->val = 0 bcz they lie with the same parent\\n                    if(n<2)node->val=0;\\n                    else{\\n                        int temp = sum;\\n                        //only two adjacent nodes can be from the same parent\\n                        //so we are subracting it\\n                        if(j%2==0){\\n                            temp-=(lvl[n][j]+lvl[n][j+1]);\\n                        }\\n                        else{\\n                            temp-=(lvl[n][j]+lvl[n][j-1]);\\n                        }\\n                        node->val = temp;\\n                    }\\n                }\\n                ++j;\\n            }\\n            ++n;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> levelOrder(TreeNode* root) {\\n        vector<vector<int>> ans; \\n        //base case\\n        if(root == NULL) \\n            return ans; \\n            \\n        queue<TreeNode*> q; \\n        q.push(root); \\n        \\n        //taking the level order or BFS traversal\\n        while(!q.empty()) {\\n            int size = q.size();\\n            vector<int> level;\\n            //this takes care of the whole level present\\n            while(size--){\\n                auto node = q.front();\\n                q.pop();\\n                if(node){\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                    level.push_back(node->val);\\n                }\\n//null nodes are assigned with 0 so that the total sum is not affected when we take level sum below\\n                else level.push_back(0);\\n                \\n            }\\n            ans.push_back(level);\\n        }\\n        return ans; \\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<vector<int>> lvl = levelOrder(root);\\n        if(root == NULL) \\n            return root; \\n            \\n        queue<TreeNode*> q; \\n        q.push(root);\\n        \\n        int n=0; //level number\\n        int l =lvl.size()-1;\\n        while(!q.empty() and n<l) {\\n            int size = q.size();\\n            long long sum = 0;\\n            int s = lvl[n].size();\\n            //taking the total sum present in the level\\n            for(int it=0;it<s;++it){\\n                sum+=lvl[n][it];\\n            }\\n            int j=0;\\n            while(size--){\\n                auto node = q.front();\\n                q.pop();\\n                if(node){\\n                    q.push(node->left);\\n                    q.push(node->right);\\n                //node->val = 0 bcz they lie with the same parent\\n                    if(n<2)node->val=0;\\n                    else{\\n                        int temp = sum;\\n                        //only two adjacent nodes can be from the same parent\\n                        //so we are subracting it\\n                        if(j%2==0){\\n                            temp-=(lvl[n][j]+lvl[n][j+1]);\\n                        }\\n                        else{\\n                            temp-=(lvl[n][j]+lvl[n][j-1]);\\n                        }\\n                        node->val = temp;\\n                    }\\n                }\\n                ++j;\\n            }\\n            ++n;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420088,
                "title": "just-dfs",
                "content": "# Intuition\\nJust DFS.\\n\\n# Approach\\nJust DFS. Save:\\n(1) The depth of each node.\\n(2) The parent of each node.\\n(3) The sum of values of all descants of each node.\\n(4) The sum of values of all nodes on for each depth.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void dfs(int d, TreeNode* root, TreeNode* parent, unordered_map<TreeNode*, int>& dep, unordered_map<TreeNode*, int>& sons, unordered_map<int, int>& s, unordered_map<TreeNode*, TreeNode*> &f) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        dep[root] = d;\\n        sons[parent] += root->val;\\n        s[d] += root->val;\\n        f[root] = parent;\\n        dfs(d + 1, root->left, root, dep, sons, s, f);\\n        dfs(d + 1, root->right, root, dep, sons, s, f);\\n    }\\n    \\n    void dfs(TreeNode* root, unordered_map<TreeNode*, int>& dep, unordered_map<TreeNode*, int>& sons,\\n          unordered_map<int, int>& s, unordered_map<TreeNode*, TreeNode*> &f) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        root->val = s[dep[root]] - sons[f[root]];\\n        dfs(root->left, dep, sons, s, f);\\n        dfs(root->right, dep, sons, s, f);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<TreeNode*, int> dep, sons;\\n        unordered_map<int, int> s;\\n        unordered_map<TreeNode*, TreeNode*> f;\\n        dfs(0, root, nullptr, dep, sons, s, f);\\n        dfs(root, dep, sons, s, f);\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void dfs(int d, TreeNode* root, TreeNode* parent, unordered_map<TreeNode*, int>& dep, unordered_map<TreeNode*, int>& sons, unordered_map<int, int>& s, unordered_map<TreeNode*, TreeNode*> &f) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        dep[root] = d;\\n        sons[parent] += root->val;\\n        s[d] += root->val;\\n        f[root] = parent;\\n        dfs(d + 1, root->left, root, dep, sons, s, f);\\n        dfs(d + 1, root->right, root, dep, sons, s, f);\\n    }\\n    \\n    void dfs(TreeNode* root, unordered_map<TreeNode*, int>& dep, unordered_map<TreeNode*, int>& sons,\\n          unordered_map<int, int>& s, unordered_map<TreeNode*, TreeNode*> &f) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        root->val = s[dep[root]] - sons[f[root]];\\n        dfs(root->left, dep, sons, s, f);\\n        dfs(root->right, dep, sons, s, f);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<TreeNode*, int> dep, sons;\\n        unordered_map<int, int> s;\\n        unordered_map<TreeNode*, TreeNode*> f;\\n        dfs(0, root, nullptr, dep, sons, s, f);\\n        dfs(root, dep, sons, s, f);\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419971,
                "title": "bfs-twice-to-find-sum-of-each-level",
                "content": "```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        sums = defaultdict(int)\\n        sumparents = defaultdict(lambda: defaultdict(int))\\n        q = deque([(root, 0)])\\n        while len(q) > 0:\\n            curr, d = q.pop()\\n            if curr:\\n                sums[d] += curr.val\\n                q.appendleft((curr.left, d + 1))\\n                q.appendleft((curr.right, d + 1))\\n        q = deque([(root, root.val if root else 0, 0, 0)])\\n        while len(q) > 0:\\n            curr, currval, other, d = q.pop()\\n            curr.val = sums[d] - currval - other\\n            if curr.left:\\n                q.appendleft((curr.left, curr.left.val, curr.right.val if curr.right else 0, d + 1))\\n            if curr.right:\\n                q.appendleft((curr.right, curr.right.val, curr.left.val if curr.left else 0, d + 1))\\n        return root\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        sums = defaultdict(int)\\n        sumparents = defaultdict(lambda: defaultdict(int))\\n        q = deque([(root, 0)])\\n        while len(q) > 0:\\n            curr, d = q.pop()\\n            if curr:\\n                sums[d] += curr.val\\n                q.appendleft((curr.left, d + 1))\\n                q.appendleft((curr.right, d + 1))\\n        q = deque([(root, root.val if root else 0, 0, 0)])\\n        while len(q) > 0:\\n            curr, currval, other, d = q.pop()\\n            curr.val = sums[d] - currval - other\\n            if curr.left:\\n                q.appendleft((curr.left, curr.left.val, curr.right.val if curr.right else 0, d + 1))\\n            if curr.right:\\n                q.appendleft((curr.right, curr.right.val, curr.left.val if curr.left else 0, d + 1))\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920356,
                "title": "optimal-approach-with-full-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**- dfs1 Function:**\\nThis function performs a depth-first search (DFS) traversal of the binary tree while calculating the sum of node values at each depth. It uses a hash map mp to store the sum of values for each depth.\\n\\n**- dfs2 Function:**\\nThis function is another DFS traversal of the binary tree. It calculates the new value for each node based on the sum of values at its depth and the value of its sibling node. It first calculates the values of the left and right children of the current node and then updates the current node\\'s value according to the formula: new_value = sum_at_depth - current_value - sibling_value.\\n\\n**- replaceValueInTree Function:**\\nThis is the main function that orchestrates the entire process. It first creates an unordered map mp to store the sum of values at each depth. Then, it initiates the first DFS (dfs1) to populate the mp map. After that, it initiates the second DFS (dfs2) to update the values of the nodes.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1O)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs1(TreeNode* node,int depth,unordered_map<int,int>& mp) {\\n        if(node == NULL)\\n            return;\\n        \\n        mp[depth] += node->val;\\n        \\n        dfs1(node->left,depth+1,mp);\\n        dfs1(node->right,depth+1,mp);\\n    }\\n    \\n    void dfs2(TreeNode* node,int sibling,int depth,unordered_map<int,int>& mp) {\\n        if(node == NULL)\\n            return;\\n        \\n        node->val = mp[depth] - node->val - sibling;\\n        \\n        int lVal;\\n        if(node->left) {\\n            lVal = node->left->val;\\n        }\\n        else {\\n            lVal = 0;\\n        }\\n        \\n        int rVal;\\n        if(node->right) {\\n            rVal = node->right->val;\\n        }\\n        else {\\n            rVal = 0;\\n        }\\n        \\n        \\n        dfs2(node->left,rVal,depth+1,mp);\\n        dfs2(node->right,lVal,depth+1,mp);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n        \\n        \\n        \\n        TreeNode* dummy =  root;\\n        \\n        dfs1(root,0,mp);\\n        dfs2(root,0,0,mp);\\n            \\n            return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs1(TreeNode* node,int depth,unordered_map<int,int>& mp) {\\n        if(node == NULL)\\n            return;\\n        \\n        mp[depth] += node->val;\\n        \\n        dfs1(node->left,depth+1,mp);\\n        dfs1(node->right,depth+1,mp);\\n    }\\n    \\n    void dfs2(TreeNode* node,int sibling,int depth,unordered_map<int,int>& mp) {\\n        if(node == NULL)\\n            return;\\n        \\n        node->val = mp[depth] - node->val - sibling;\\n        \\n        int lVal;\\n        if(node->left) {\\n            lVal = node->left->val;\\n        }\\n        else {\\n            lVal = 0;\\n        }\\n        \\n        int rVal;\\n        if(node->right) {\\n            rVal = node->right->val;\\n        }\\n        else {\\n            rVal = 0;\\n        }\\n        \\n        \\n        dfs2(node->left,rVal,depth+1,mp);\\n        dfs2(node->right,lVal,depth+1,mp);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n        \\n        \\n        \\n        TreeNode* dummy =  root;\\n        \\n        dfs1(root,0,mp);\\n        dfs2(root,0,0,mp);\\n            \\n            return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843279,
                "title": "c-level-order-traversal-mapping-easy-solution-with-comments-and-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen i first read the question, it was clearly mentioned that we need to replace the value of nodes in tree with the sum of its cousins(nodes at the same level).Since, cousins are the nodes which are at the same level so i thought of traversing the tree level wise and while traversing i\\'ll keep a track of the sum of all nodes at that level.\\nAfter, mapping the level of tree with its respective sum i\\'ll again traverse the tree level wise and this time i\\'ll see if the node has left, right children, then i\\'ll subtract the sum which is mapped with that level and assign that value with the left and right children. \\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n    2*O(n) --> Two times level wise traversal\\n    O(1)--> insertion and retrieval in unordered_map\\n      **O(N)**\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->  \\n    O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        //map to store the sum at each level \\n        unordered_map<int,int> mp;\\n        queue<TreeNode*> q;\\n        //queue for level order traversal\\n        q.push(root);\\n        mp[0]=root->val;\\n        //we are doing first time level wise traversal to map each level to the sum of the value of nodes at that level\\n        int level=0;\\n        while(q.empty()!=1){\\n            int n=q.size();\\n            level++;\\n            for(int i=0;i<n;i++){\\n                auto r=q.front();\\n                q.pop();\\n                if(r->left){\\n                    mp[level]+=r->left->val;\\n                    q.push(r->left);\\n                }\\n                if(r->right){\\n                    q.push(r->right);\\n                    mp[level]+=r->right->val;\\n                }\\n            }\\n        }\\n        //second time level order traversal to alter the value of nodes according to the question\\n        q.push(root);   \\n        root->val=0;\\n        level=0;\\n        while(q.empty()!=1){\\n            int n=q.size();\\n            level++;\\n            for(int i=0;i<n;i++){\\n                auto it=q.front();\\n                q.pop();\\n                int l=it->left!=NULL?it->left->val:0;\\n                int r=it->right!=NULL?it->right->val:0;\\n                if(it->left){\\n                    q.push(it->left);\\n                    it->left->val=mp[level]-l-r;\\n                }\\n                if(it->right){\\n                    q.push(it->right);\\n                    it->right->val=mp[level]-l-r;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        //map to store the sum at each level \\n        unordered_map<int,int> mp;\\n        queue<TreeNode*> q;\\n        //queue for level order traversal\\n        q.push(root);\\n        mp[0]=root->val;\\n        //we are doing first time level wise traversal to map each level to the sum of the value of nodes at that level\\n        int level=0;\\n        while(q.empty()!=1){\\n            int n=q.size();\\n            level++;\\n            for(int i=0;i<n;i++){\\n                auto r=q.front();\\n                q.pop();\\n                if(r->left){\\n                    mp[level]+=r->left->val;\\n                    q.push(r->left);\\n                }\\n                if(r->right){\\n                    q.push(r->right);\\n                    mp[level]+=r->right->val;\\n                }\\n            }\\n        }\\n        //second time level order traversal to alter the value of nodes according to the question\\n        q.push(root);   \\n        root->val=0;\\n        level=0;\\n        while(q.empty()!=1){\\n            int n=q.size();\\n            level++;\\n            for(int i=0;i<n;i++){\\n                auto it=q.front();\\n                q.pop();\\n                int l=it->left!=NULL?it->left->val:0;\\n                int r=it->right!=NULL?it->right->val:0;\\n                if(it->left){\\n                    q.push(it->left);\\n                    it->left->val=mp[level]-l-r;\\n                }\\n                if(it->right){\\n                    q.push(it->right);\\n                    it->right->val=mp[level]-l-r;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641061,
                "title": "c-2-times-bfs-simple",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> levelSum;\\n        getSum(root, levelSum);\\n        return updateTree(root, levelSum);\\n    }\\n\\nprivate:\\n    void getSum(TreeNode* root, vector<int>& levelSum) {\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n    \\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            int sum = 0;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = Q.front();\\n                Q.pop();\\n                sum += curr->val;\\n                if (curr->left) Q.push(curr->left);\\n                if (curr->right) Q.push(curr->right);\\n            }\\n            levelSum.emplace_back(sum);\\n        }\\n    }\\n\\n    TreeNode* updateTree(TreeNode* root, vector<int>& levelSum) {\\n        int level = 0;\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n    \\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = Q.front();\\n                Q.pop();\\n                int siblingSum = (curr->left ? curr->left->val : 0) + \\n                                   (curr->right ? curr->right->val : 0);\\n                if (level == 0) curr->val = 0;\\n                if (curr->left) {\\n                    Q.push(curr->left);\\n                    curr->left->val = levelSum[level+1] - siblingSum;\\n                }\\n                if (curr->right) {\\n                    Q.push(curr->right);\\n                    curr->right->val = levelSum[level+1] - siblingSum;\\n                }\\n            }\\n            level++;\\n        }\\n\\n        return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> levelSum;\\n        getSum(root, levelSum);\\n        return updateTree(root, levelSum);\\n    }\\n\\nprivate:\\n    void getSum(TreeNode* root, vector<int>& levelSum) {\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n    \\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            int sum = 0;\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = Q.front();\\n                Q.pop();\\n                sum += curr->val;\\n                if (curr->left) Q.push(curr->left);\\n                if (curr->right) Q.push(curr->right);\\n            }\\n            levelSum.emplace_back(sum);\\n        }\\n    }\\n\\n    TreeNode* updateTree(TreeNode* root, vector<int>& levelSum) {\\n        int level = 0;\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n    \\n        while (!Q.empty()) {\\n            size_t size = Q.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* curr = Q.front();\\n                Q.pop();\\n                int siblingSum = (curr->left ? curr->left->val : 0) + \\n                                   (curr->right ? curr->right->val : 0);\\n                if (level == 0) curr->val = 0;\\n                if (curr->left) {\\n                    Q.push(curr->left);\\n                    curr->left->val = levelSum[level+1] - siblingSum;\\n                }\\n                if (curr->right) {\\n                    Q.push(curr->right);\\n                    curr->right->val = levelSum[level+1] - siblingSum;\\n                }\\n            }\\n            level++;\\n        }\\n\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640932,
                "title": "python-simple-and-clean-beats-99-89",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n# Intuition\\nThe problem asks us to replace the value of each node in a binary tree with the sum of all its cousins\\' values. Two nodes are cousins if they have the same depth with different parents. One way to approach this problem is to use a breadth-first search (BFS) algorithm to traverse the tree level by level and keep track of the sum of values of nodes at each level and the sum of values of siblings at each level.\\n\\n# Approach\\n1. Initialize a queue with a tuple containing the root node and its value. This queue will be used to perform BFS on the tree.\\n2. Initialize a variable `level_sum` with the value of the root node. This variable will be used to keep track of the sum of values of nodes at each level.\\n3. While the queue is not empty:\\n    1. Initialize a list `level_q` to store the nodes in the next level.\\n    2. Initialize a variable `curr` to store the sum of values of siblings in the next level.\\n    3. For each tuple `(node, sib)` in `queue`:\\n        1. Update the value of `node` to `level_sum - sib`, where `level_sum` is the sum of values of nodes at the current level and `sib` is the sum of values of `node`\\'s siblings.\\n        2. Initialize a variable `next_sib` to store the sum of values of `node`\\'s left and right children (or 0 if they don\\'t exist).\\n        3. Add `next_sib` to `curr`.\\n        4. If `node` has a left child, append a tuple containing its left child and `next_sib` to `level_q`.\\n        5. If `node` has a right child, append a tuple containing its right child and `next_sib` to `level_q`.\\n    4. Update `queue` with `level_q`.\\n    5. Update `level_sum` with `curr`.\\n4. Return the root of the modified tree.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the number of nodes in the tree.\\n- Space complexity: $$O(n)$$ where n is the number of nodes in the tree.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [(root,root.val)] # [node,siblings_sum]\\n        level_sum = root.val # sum of nodes at a level\\n        \\n        #BFS\\n        while queue:\\n            curr = 0\\n            level_q = []\\n            for node, sib in queue:\\n                node.val = level_sum - sib # replace node value with sum of siblings\\n                next_sib = 0\\n                if node.left:\\n                    next_sib += node.left.val\\n                if node.right:\\n                    next_sib += node.right.val\\n                curr += next_sib\\n                if node.left:\\n                    level_q.append((node.left,next_sib))\\n                if node.right:\\n                    level_q.append((node.right,next_sib))\\n            queue = level_q\\n            level_sum = curr # update sum of nodes at current level\\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [(root,root.val)] # [node,siblings_sum]\\n        level_sum = root.val # sum of nodes at a level\\n        \\n        #BFS\\n        while queue:\\n            curr = 0\\n            level_q = []\\n            for node, sib in queue:\\n                node.val = level_sum - sib # replace node value with sum of siblings\\n                next_sib = 0\\n                if node.left:\\n                    next_sib += node.left.val\\n                if node.right:\\n                    next_sib += node.right.val\\n                curr += next_sib\\n                if node.left:\\n                    level_q.append((node.left,next_sib))\\n                if node.right:\\n                    level_q.append((node.right,next_sib))\\n            queue = level_q\\n            level_sum = curr # update sum of nodes at current level\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516197,
                "title": "2641-cousins-in-binary-tree-ii-java",
                "content": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        List<Integer> sum=new ArrayList<>();\\n        sum.add(root.val);\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            int sum1=0;\\n            while(size-->0){\\n                TreeNode curr=q.poll();\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n            }\\n            sum.add(sum1);\\n        }\\n        q.clear();\\n        q.add(root);\\n        int lev=-1;\\n        while(!q.isEmpty())\\n        {\\n            lev++;\\n            int size=q.size();\\n            while(size--!=0)\\n            {\\n                int civiling_sum=0;\\n                TreeNode cur=q.poll();\\n                if(lev==1||lev==0)\\n                    cur.val=0;\\n                if(cur.left!=null)\\n                {\\n                    civiling_sum+=cur.left.val;\\n                    q.add(cur.left);\\n                }\\n                \\n                if(cur.right!=null)\\n                {\\n                    civiling_sum+=cur.right.val;\\n                    q.add(cur.right);\\n                }\\n                if(lev>=1){\\n                     if(cur.left!=null){\\n                          \\n                        cur.left.val=sum.get(lev+1)-civiling_sum;\\n                     }\\n                    if(cur.right!=null){\\n                        cur.right.val=sum.get(lev+1)-civiling_sum;\\n                     }\\n                }\\n            }\\n        }\\n        return root;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        List<Integer> sum=new ArrayList<>();\\n        sum.add(root.val);\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            int sum1=0;\\n            while(size-->0){\\n                TreeNode curr=q.poll();\\n                if(curr.left!=null){\\n                    sum1+=curr.left.val;\\n                    q.add(curr.left);\\n                }\\n                if(curr.right!=null){\\n                    sum1+=curr.right.val;\\n                    q.add(curr.right);\\n                }\\n            }\\n            sum.add(sum1);\\n        }\\n        q.clear();\\n        q.add(root);\\n        int lev=-1;\\n        while(!q.isEmpty())\\n        {\\n            lev++;\\n            int size=q.size();\\n            while(size--!=0)\\n            {\\n                int civiling_sum=0;\\n                TreeNode cur=q.poll();\\n                if(lev==1||lev==0)\\n                    cur.val=0;\\n                if(cur.left!=null)\\n                {\\n                    civiling_sum+=cur.left.val;\\n                    q.add(cur.left);\\n                }\\n                \\n                if(cur.right!=null)\\n                {\\n                    civiling_sum+=cur.right.val;\\n                    q.add(cur.right);\\n                }\\n                if(lev>=1){\\n                     if(cur.left!=null){\\n                          \\n                        cur.left.val=sum.get(lev+1)-civiling_sum;\\n                     }\\n                    if(cur.right!=null){\\n                        cur.right.val=sum.get(lev+1)-civiling_sum;\\n                     }\\n                }\\n            }\\n        }\\n        return root;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441647,
                "title": "hash-map-approach",
                "content": "class Solution {\\n    \\n    HashMap<Integer,Integer>map;\\n    HashMap<TreeNode,Integer>originalvalue;\\n    \\n    public void dfs(TreeNode root,int level){\\n        if(root==null)\\n            return;\\n        \\n        originalvalue.put(root,root.val);\\n        if(map.containsKey(level)){\\n            map.put(level,map.get(level)+root.val);\\n        }\\n        else\\n            map.put(level,root.val);\\n        \\n        dfs(root.left,level+1);\\n        dfs(root.right,level+1);\\n        \\n    }\\n    \\n    public void dfs2(TreeNode root,TreeNode par,int level){\\n        if(root==null){\\n            return;\\n        }\\n        \\n        if(par==null){\\n            root.val=0;\\n        }\\n        else{\\n            int total=map.get(level);\\n            if(par.left!=null)\\n                total-=originalvalue.get(par.left);\\n            if(par.right!=null)\\n                total-=originalvalue.get(par.right);\\n            root.val=total;\\n        }\\n        \\n        dfs2(root.left,root,level+1);\\n        dfs2(root.right,root,level+1);\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        map=new HashMap<Integer,Integer>();\\n        originalvalue=new HashMap<>();\\n        dfs(root,1);\\n        \\n        for(int i=1;i<=3;i++)\\n            System.out.println(i+\" \"+map.get(i));\\n        \\n        dfs2(root,null,1);\\n        \\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    HashMap<Integer,Integer>map;\\n    HashMap<TreeNode,Integer>originalvalue;\\n    \\n    public void dfs(TreeNode root,int level){\\n        if(root==null)\\n            return;\\n        \\n        originalvalue.put(root,root.val);\\n        if(map.containsKey(level)){\\n            map.put(level,map.get(level)+root.val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3437493,
                "title": "java-6ms-100-bfs-speed-optimized-explanation-fastest",
                "content": "The following code uses a Breadth-First-Search (BFS) to descend through the levels of the tree to modify the tree to contain cousin sums.  \\n\\nThis code is optimized for execution speed.  It could be simpler and more general case, and therefore more readable, but those simplifications are slower.  Unless execution speed is needed, the simpler and more generalized coding techniques are usually thought of as better coding practices, because they are easier to modify, handle changes of requirements better, and are easier to maintain over time.  If at a job interview, using speed optimized code such as this takes more time to create, and is more difficult for the interviewer to read.  Using the simpler more general case code is usually thought of as better coding practices.  When creating code at an interview, I feel it is good to ask the interviewer what their priorities are, such as time to complete the coding, readability, commenting and documenting, execition time, error and bad input handling, etc.  This lets me create code to better meet the interviewer\\'s expectations, lets the interviewer know that I consider these priorities before coding, and gives the impression that I can write the code for any of these priorities.\\n\\nTo get faster execution speed, the code below uses a single `TreeNode[]` array to contain breadth first search\\'s list of tree nodes on a single level.  Using an array has faster execution time than a `Queue` or an `ArrayList` class.  The array actually contains two lists of TreeNode\\'s.  One list is the current level for the BFS, while the other is the list being built for the next BFS level.  Within the array, these lists alternate between being built from the start of the array going forward, and from the end of the array going backward.  As the list for the current BFS level is processed, it is shrinking, while the list that is being built for the next BFS level is growing, making for less needed space in the array, because the array will never have to hold complete lists for both current and next level at the same time.  One list is shrinking as the other list is growing.  The array has to be big enough for the worst case storage requirements, which will be (max_number_of_nodes+1)/2 = 100_001/2 = 50_000.\\n\\nIn April 2023, this code ran as fast as 6ms.  The next fastest code on the runtime graph was 12ms, which used two `Queue` for its BFS lists.\\n\\nIf useful, please upvote.\\n```\\nclass Solution {\\n    // The nodes[] array contains the list of nodes for a breadth \\n    // first search (BFS) of a level of the tree, while building \\n    // the list of nodes for the BFS for the next level.  These \\n    // two lists are stored in the nodes[] array at the same time.  \\n    // One list, the \"left\" list, is built from the start of \\n    // nodes[] going upward in the array.  The other list, the \\n    // \"right\" list, is built from the end of nodes[] going \\n    // downward.  Because the tree has a maximum of 100_000 (10^5) \\n    // nodes, we will need an array of size 100_000/2 == 50_000 \\n    // to simultaneously hold both lists in the same array.  \\n    // But for this leetcode problem\\'s test cases in April 2023, \\n    // an array length of 9000 is long enough.  By making this \\n    // array a static, the array will only be allocated once for \\n    // all the leetcode problem\\'s test cases, instead of allocating \\n    // the array again for each test case, which would require \\n    // slower runtime.\\n    static final TreeNode[] nodes = new TreeNode[50_000];\\n    \\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        nodes[0] = root;\\n        int sumL = root.val;\\n        int sumR = 0;\\n        final int startL = 0;\\n        final int startR = nodes.length - 1;\\n        int lastL = startL + 1;\\n        int lastR = startR;\\n        TreeNode node = null;\\n        \\n        // Loop through the levels of the tree in a breadth first \\n        // search (BFS) of the tree nodes.  Each time through this \\n        // loop processes the next two levels of the tree.  First \\n        // processing the list of nodes on the left side of nodes[] \\n        // while building the list of the next level\\'s nodes on \\n        // the right side of nodes[].  Then secondly, processing \\n        // the list of nodes on the right side of nodes[] while \\n        // building the list of the next level\\'s nodes on the left \\n        // side of nodes[].\\n        while (lastL != 0) {\\n            // Process the list of nodes on the left side of nodes[] \\n            // while building the list of the next level\\'s nodes on \\n            // the right side of nodes[].\\n            sumR = 0;\\n            while (lastL > 0) {\\n                node = nodes[--lastL];\\n                node.val = sumL - node.val;\\n                if (node.left != null) {\\n                    if (node.right != null) {    // If two children.\\n                        sumR += node.left.val = node.right.val = \\n                                    node.left.val + node.right.val;\\n                        nodes[lastR--] = node.left;\\n                        nodes[lastR--] = node.right;\\n                    } else {                     // If left child only.\\n                        sumR += node.left.val;\\n                        nodes[lastR--] = node.left;\\n                    }\\n                } else if (node.right != null) { // If right child only.\\n                    sumR += node.right.val;\\n                    nodes[lastR--] = node.right;\\n                }\\n            }\\n            if (lastR == startR)  break;    // If no more levels.\\n            // Process the list of nodes on the right side of \\n            // nodes[] while building the list of the next level\\'s \\n            // nodes on the left side of nodes[].\\n            sumL = 0;\\n            while (lastR < startR) {\\n                node = nodes[++lastR];\\n                node.val = sumR - node.val;\\n                if (node.left != null) {\\n                    if (node.right != null) {    // If two children.\\n                        sumL += node.left.val = node.right.val = \\n                                    node.left.val + node.right.val;\\n                        nodes[lastL++] = node.left;\\n                        nodes[lastL++] = node.right;\\n                    } else {                     // If left child only.\\n                        sumL += node.left.val;\\n                        nodes[lastL++] = node.left;\\n                    }\\n                } else if (node.right != null) { // If right child only.\\n                    sumL += node.right.val;\\n                    nodes[lastL++] = node.right;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    // The nodes[] array contains the list of nodes for a breadth \\n    // first search (BFS) of a level of the tree, while building \\n    // the list of nodes for the BFS for the next level.  These \\n    // two lists are stored in the nodes[] array at the same time.  \\n    // One list, the \"left\" list, is built from the start of \\n    // nodes[] going upward in the array.  The other list, the \\n    // \"right\" list, is built from the end of nodes[] going \\n    // downward.  Because the tree has a maximum of 100_000 (10^5) \\n    // nodes, we will need an array of size 100_000/2 == 50_000 \\n    // to simultaneously hold both lists in the same array.  \\n    // But for this leetcode problem\\'s test cases in April 2023, \\n    // an array length of 9000 is long enough.  By making this \\n    // array a static, the array will only be allocated once for \\n    // all the leetcode problem\\'s test cases, instead of allocating \\n    // the array again for each test case, which would require \\n    // slower runtime.\\n    static final TreeNode[] nodes = new TreeNode[50_000];\\n    \\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        nodes[0] = root;\\n        int sumL = root.val;\\n        int sumR = 0;\\n        final int startL = 0;\\n        final int startR = nodes.length - 1;\\n        int lastL = startL + 1;\\n        int lastR = startR;\\n        TreeNode node = null;\\n        \\n        // Loop through the levels of the tree in a breadth first \\n        // search (BFS) of the tree nodes.  Each time through this \\n        // loop processes the next two levels of the tree.  First \\n        // processing the list of nodes on the left side of nodes[] \\n        // while building the list of the next level\\'s nodes on \\n        // the right side of nodes[].  Then secondly, processing \\n        // the list of nodes on the right side of nodes[] while \\n        // building the list of the next level\\'s nodes on the left \\n        // side of nodes[].\\n        while (lastL != 0) {\\n            // Process the list of nodes on the left side of nodes[] \\n            // while building the list of the next level\\'s nodes on \\n            // the right side of nodes[].\\n            sumR = 0;\\n            while (lastL > 0) {\\n                node = nodes[--lastL];\\n                node.val = sumL - node.val;\\n                if (node.left != null) {\\n                    if (node.right != null) {    // If two children.\\n                        sumR += node.left.val = node.right.val = \\n                                    node.left.val + node.right.val;\\n                        nodes[lastR--] = node.left;\\n                        nodes[lastR--] = node.right;\\n                    } else {                     // If left child only.\\n                        sumR += node.left.val;\\n                        nodes[lastR--] = node.left;\\n                    }\\n                } else if (node.right != null) { // If right child only.\\n                    sumR += node.right.val;\\n                    nodes[lastR--] = node.right;\\n                }\\n            }\\n            if (lastR == startR)  break;    // If no more levels.\\n            // Process the list of nodes on the right side of \\n            // nodes[] while building the list of the next level\\'s \\n            // nodes on the left side of nodes[].\\n            sumL = 0;\\n            while (lastR < startR) {\\n                node = nodes[++lastR];\\n                node.val = sumR - node.val;\\n                if (node.left != null) {\\n                    if (node.right != null) {    // If two children.\\n                        sumL += node.left.val = node.right.val = \\n                                    node.left.val + node.right.val;\\n                        nodes[lastL++] = node.left;\\n                        nodes[lastL++] = node.right;\\n                    } else {                     // If left child only.\\n                        sumL += node.left.val;\\n                        nodes[lastL++] = node.left;\\n                    }\\n                } else if (node.right != null) { // If right child only.\\n                    sumL += node.right.val;\\n                    nodes[lastL++] = node.right;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431529,
                "title": "c-bfs-sum-at-each-level-dfs-calculate-for-each-child",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n        void dfs2(TreeNode* root,vector<int>&dep,int d){\\n        if(root==NULL || d+1==dep.size())\\n        return ;\\n\\n        int l=(root->left)?root->left->val:0;\\n        int r=(root->right)?root->right->val:0;\\n\\n        if((l+r<=dep[d+1])){\\n            if(l!=0)\\n            root->left->val=(dep[d+1]-(l+r));\\n\\n            if(r!=0)\\n            root->right->val=(dep[d+1]-(l+r));\\n        }\\n        dfs2(root->left,dep,d+1);\\n        dfs2(root->right,dep,d+1);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int>dep;\\n\\n         int level=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        dep.push_back(0);  \\n            \\n        while(q.empty()==false){\\n           int size=q.size();\\n           int sum=0;\\n        \\n            for(int i=0;i<size;i++){\\n                TreeNode* node = q.front();\\n                 q.pop();\\n                 if(node->left){\\n                      q.push(node->left);\\n                      sum+=node->left->val;\\n                 }  \\n               if (node->right){\\n                  q.push(node->right);\\n                  sum+=node->right->val;\\n               }\\n                 \\n            }\\n            if(!q.empty())\\n            dep.push_back(sum);    \\n        }\\n\\n        dfs2(root,dep,0);\\n        root->val=0;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n        void dfs2(TreeNode* root,vector<int>&dep,int d){\\n        if(root==NULL || d+1==dep.size())\\n        return ;\\n\\n        int l=(root->left)?root->left->val:0;\\n        int r=(root->right)?root->right->val:0;\\n\\n        if((l+r<=dep[d+1])){\\n            if(l!=0)\\n            root->left->val=(dep[d+1]-(l+r));\\n\\n            if(r!=0)\\n            root->right->val=(dep[d+1]-(l+r));\\n        }\\n        dfs2(root->left,dep,d+1);\\n        dfs2(root->right,dep,d+1);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int>dep;\\n\\n         int level=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        dep.push_back(0);  \\n            \\n        while(q.empty()==false){\\n           int size=q.size();\\n           int sum=0;\\n        \\n            for(int i=0;i<size;i++){\\n                TreeNode* node = q.front();\\n                 q.pop();\\n                 if(node->left){\\n                      q.push(node->left);\\n                      sum+=node->left->val;\\n                 }  \\n               if (node->right){\\n                  q.push(node->right);\\n                  sum+=node->right->val;\\n               }\\n                 \\n            }\\n            if(!q.empty())\\n            dep.push_back(sum);    \\n        }\\n\\n        dfs2(root,dep,0);\\n        root->val=0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427575,
                "title": "bfs-and-childsum-easy-to-understand",
                "content": "Please UpVote if you  like the solution !\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea here is store every node\\'s child value for future reference i.e **futureSum** and a temporary sum which stores the sum for the siblings sum and then assign those siblings node their sibling sum i.e **tempsum** , after one level we have our **totalSum** in the form of **futureSum**. And the node for which we doing these calculations just assign totalSum-siblingsSum.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        unordered_map<TreeNode*,int>mp;\\n        TreeNode* r = root;\\n        if(root == NULL)\\n            return r;\\n        q.push(root);\\n        int totalSum = root->val;\\n        mp[root] = root->val;\\n        while(!q.empty())\\n        {\\n            int size = q.size(), futureSum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n                int tempsum = 0;\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left){ \\n                    q.push(node->left);\\n                    futureSum += node->left->val; \\n                    tempsum += node->left->val;\\n                }\\n                    \\n                if(node->right){\\n                    q.push(node->right);\\n                    futureSum += node->right->val;\\n                    tempsum += node->right->val;\\n                }\\n                \\n                if(node->left)\\n                    mp[node->left] = tempsum;\\n                if(node->right)\\n                    mp[node->right] = tempsum;\\n\\n                node->val = totalSum-mp[node];\\n                mp.erase(node);\\n            }\\n            totalSum = futureSum;\\n         }\\n        return r;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        unordered_map<TreeNode*,int>mp;\\n        TreeNode* r = root;\\n        if(root == NULL)\\n            return r;\\n        q.push(root);\\n        int totalSum = root->val;\\n        mp[root] = root->val;\\n        while(!q.empty())\\n        {\\n            int size = q.size(), futureSum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n                int tempsum = 0;\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left){ \\n                    q.push(node->left);\\n                    futureSum += node->left->val; \\n                    tempsum += node->left->val;\\n                }\\n                    \\n                if(node->right){\\n                    q.push(node->right);\\n                    futureSum += node->right->val;\\n                    tempsum += node->right->val;\\n                }\\n                \\n                if(node->left)\\n                    mp[node->left] = tempsum;\\n                if(node->right)\\n                    mp[node->right] = tempsum;\\n\\n                node->val = totalSum-mp[node];\\n                mp.erase(node);\\n            }\\n            totalSum = futureSum;\\n         }\\n        return r;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426376,
                "title": "a-simple-bfs-with-one-time-traversal",
                "content": "```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        \\n        Queue<Pair<TreeNode,Integer>> q = new LinkedList<>();\\n        \\n        q.offer(new Pair(root,0));\\n        \\n        int totalSumAtSameHeight = 0;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int k=q.size();\\n            \\n            int prev = totalSumAtSameHeight;\\n            totalSumAtSameHeight = 0;\\n            \\n            while(k-->0){\\n                \\n                Pair<TreeNode,Integer> p=q.poll();\\n                \\n                int siblingSum = 0;\\n                \\n                TreeNode curr = p.getKey();\\n                \\n                if(curr.left!=null){\\n                    siblingSum += curr.left.val;\\n                    totalSumAtSameHeight += curr.left.val;\\n                }\\n                \\n                if(curr.right!=null){\\n                    siblingSum += curr.right.val;\\n                    totalSumAtSameHeight += curr.right.val;\\n\\n                }\\n                \\n                if(p.getKey().left!=null){\\n                    q.offer(new Pair(curr.left, siblingSum));\\n                }\\n                \\n                if(p.getKey().right!=null){\\n                    q.offer(new Pair(curr.right, siblingSum));\\n                }\\n                \\n                curr.val = prev - p.getValue();\\n            }\\n            \\n        }\\n        \\n        \\n        return root;\\n        \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        \\n        Queue<Pair<TreeNode,Integer>> q = new LinkedList<>();\\n        \\n        q.offer(new Pair(root,0));\\n        \\n        int totalSumAtSameHeight = 0;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int k=q.size();\\n            \\n            int prev = totalSumAtSameHeight;\\n            totalSumAtSameHeight = 0;\\n            \\n            while(k-->0){\\n                \\n                Pair<TreeNode,Integer> p=q.poll();\\n                \\n                int siblingSum = 0;\\n                \\n                TreeNode curr = p.getKey();\\n                \\n                if(curr.left!=null){\\n                    siblingSum += curr.left.val;\\n                    totalSumAtSameHeight += curr.left.val;\\n                }\\n                \\n                if(curr.right!=null){\\n                    siblingSum += curr.right.val;\\n                    totalSumAtSameHeight += curr.right.val;\\n\\n                }\\n                \\n                if(p.getKey().left!=null){\\n                    q.offer(new Pair(curr.left, siblingSum));\\n                }\\n                \\n                if(p.getKey().right!=null){\\n                    q.offer(new Pair(curr.right, siblingSum));\\n                }\\n                \\n                curr.val = prev - p.getValue();\\n            }\\n            \\n        }\\n        \\n        \\n        return root;\\n        \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425996,
                "title": "100-beats-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    class Pair{\\n        TreeNode node;\\n        TreeNode parent;\\n        Pair(TreeNode node, TreeNode parent){\\n            this.node = node;\\n            this.parent = parent;\\n        }\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<Pair> que = new LinkedList<>();\\n        que.add(new Pair(root,null));\\n        while(que.size() > 0){\\n            int sz = que.size();\\n            HashMap<TreeNode, Integer> map = new HashMap<>();\\n            ArrayList<Pair> kids = new ArrayList<>();\\n            int totalsum = 0;\\n            while(sz-- > 0){\\n                Pair rem = que.remove();\\n                totalsum += rem.node.val;\\n                kids.add(rem);\\n                if(map.containsKey(rem.parent) == false){\\n                    map.put(rem.parent,rem.node.val);\\n                }else{\\n                    map.put(rem.parent, map.get(rem.parent) + rem.node.val);\\n                }\\n                if(rem.node.left != null){\\n                    que.add(new Pair(rem.node.left,rem.node));\\n                }\\n                if(rem.node.right != null){\\n                    que.add(new Pair(rem.node.right,rem.node));\\n                }\\n            }\\n            for(Pair kid: kids){\\n                kid.node.val = totalsum - map.get(kid.parent);\\n            }            \\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    class Pair{\\n        TreeNode node;\\n        TreeNode parent;\\n        Pair(TreeNode node, TreeNode parent){\\n            this.node = node;\\n            this.parent = parent;\\n        }\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<Pair> que = new LinkedList<>();\\n        que.add(new Pair(root,null));\\n        while(que.size() > 0){\\n            int sz = que.size();\\n            HashMap<TreeNode, Integer> map = new HashMap<>();\\n            ArrayList<Pair> kids = new ArrayList<>();\\n            int totalsum = 0;\\n            while(sz-- > 0){\\n                Pair rem = que.remove();\\n                totalsum += rem.node.val;\\n                kids.add(rem);\\n                if(map.containsKey(rem.parent) == false){\\n                    map.put(rem.parent,rem.node.val);\\n                }else{\\n                    map.put(rem.parent, map.get(rem.parent) + rem.node.val);\\n                }\\n                if(rem.node.left != null){\\n                    que.add(new Pair(rem.node.left,rem.node));\\n                }\\n                if(rem.node.right != null){\\n                    que.add(new Pair(rem.node.right,rem.node));\\n                }\\n            }\\n            for(Pair kid: kids){\\n                kid.node.val = totalsum - map.get(kid.parent);\\n            }            \\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425973,
                "title": "parent-tracking-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n{\\n    unordered_map<TreeNode*,TreeNode*>mp;\\n\\tfillmap(root,mp);         \\n\\t\\n\\tint level=0;\\n    unordered_map<int,int>level_sum;\\n    dfs(root,level_sum,level);\\n    \\n    //now preforming the bfs stuff\\n    queue<TreeNode*>q;\\n    q.push(root);\\n    level = 0;\\n    \\n    unordered_map<int,vector<int>>result;  //temporory map to store the result\\n    while(!q.empty())\\n    {\\n    \\tint size = q.size();\\n    \\tfor(int i=0;i<size;i++)\\n    \\t{\\n    \\t\\tTreeNode* temp = q.front();\\n    \\t\\tq.pop();\\n    \\t\\t\\n    \\t\\tif(temp == root)\\n    \\t\\t{\\n    \\t\\t\\tresult[level].push_back(0);\\n\\t\\t\\t}\\n\\t\\t\\telse \\n\\t\\t\\t{\\n\\t\\t\\t\\tint levelsum  = level_sum[level];\\n\\t\\t\\t\\tTreeNode* par = mp[temp];\\n                //7 9\\n                //10 4\\n                //1 4\\n                //9 5\\n                //4 5\\n                if(par->left != NULL)\\n                levelsum = levelsum - (par->left->val);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(par->right != NULL)\\n\\t\\t\\t\\tlevelsum = levelsum - (par->right->val);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tresult[level].push_back(levelsum); \\n\\t\\t\\t}\\n\\t\\t\\tif(temp->left != NULL)\\n\\t\\t\\tq.push(temp->left);\\n\\t\\t\\t\\n\\t\\t\\tif(temp->right != NULL)\\n\\t\\t\\tq.push(temp->right);\\n\\t\\t}\\n\\t\\tlevel++;\\n    }\\n\\t\\n\\t//making the queue empty\\n\\twhile(!q.empty())\\n\\tq.pop();\\n\\t\\n    //again doing the bsf to fill the valus in the tree\\n\\tq.push(root);\\n\\tlevel = 0;\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tint idx = 0;\\n\\t\\tint size = q.size();\\n\\t\\tfor(int i=0;i<size;i++)\\n\\t\\t{\\n\\t\\t\\tTreeNode* temp = q.front();\\n\\t\\t\\ttemp->val = result[level][idx];\\n\\t\\t\\tidx++;\\n\\t\\t\\tq.pop();\\n\\t\\t\\t\\n\\t\\t\\tif(temp->left != NULL)\\n\\t\\t\\tq.push(temp->left);\\n\\t\\t\\t\\n\\t\\t\\tif(temp->right != NULL)\\n\\t\\t\\tq.push(temp->right);\\n\\t\\t}\\n\\t\\tlevel++;\\n\\t}\\n\\treturn root;\\n}\\nvoid dfs(TreeNode* root,unordered_map<int,int>&level_sum,int level)\\n{\\n\\tif(root == NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\tlevel_sum[level]+=root->val;\\n\\tdfs(root->left,level_sum,level+1);\\n\\tdfs(root->right,level_sum,level+1);\\n}\\nvoid fillmap(TreeNode* root,unordered_map<TreeNode*,TreeNode*>&mp)\\n{\\n\\tif(root == NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t//if the left child exist\\n\\tif(root->left != NULL)\\n\\t{\\n\\t\\tmp[root->left] = root;\\n\\t}\\n\\t//if the right child exist\\n\\tif(root->right != NULL)\\n\\t{\\n\\t\\tmp[root->right] = root;\\n\\t}\\n\\tfillmap(root->left,mp);\\n\\tfillmap(root->right,mp);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n{\\n    unordered_map<TreeNode*,TreeNode*>mp;\\n\\tfillmap(root,mp);         \\n\\t\\n\\tint level=0;\\n    unordered_map<int,int>level_sum;\\n    dfs(root,level_sum,level);\\n    \\n    //now preforming the bfs stuff\\n    queue<TreeNode*>q;\\n    q.push(root);\\n    level = 0;\\n    \\n    unordered_map<int,vector<int>>result;  //temporory map to store the result\\n    while(!q.empty())\\n    {\\n    \\tint size = q.size();\\n    \\tfor(int i=0;i<size;i++)\\n    \\t{\\n    \\t\\tTreeNode* temp = q.front();\\n    \\t\\tq.pop();\\n    \\t\\t\\n    \\t\\tif(temp == root)\\n    \\t\\t{\\n    \\t\\t\\tresult[level].push_back(0);\\n\\t\\t\\t}\\n\\t\\t\\telse \\n\\t\\t\\t{\\n\\t\\t\\t\\tint levelsum  = level_sum[level];\\n\\t\\t\\t\\tTreeNode* par = mp[temp];\\n                //7 9\\n                //10 4\\n                //1 4\\n                //9 5\\n                //4 5\\n                if(par->left != NULL)\\n                levelsum = levelsum - (par->left->val);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(par->right != NULL)\\n\\t\\t\\t\\tlevelsum = levelsum - (par->right->val);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tresult[level].push_back(levelsum); \\n\\t\\t\\t}\\n\\t\\t\\tif(temp->left != NULL)\\n\\t\\t\\tq.push(temp->left);\\n\\t\\t\\t\\n\\t\\t\\tif(temp->right != NULL)\\n\\t\\t\\tq.push(temp->right);\\n\\t\\t}\\n\\t\\tlevel++;\\n    }\\n\\t\\n\\t//making the queue empty\\n\\twhile(!q.empty())\\n\\tq.pop();\\n\\t\\n    //again doing the bsf to fill the valus in the tree\\n\\tq.push(root);\\n\\tlevel = 0;\\n\\twhile(!q.empty())\\n\\t{\\n\\t\\tint idx = 0;\\n\\t\\tint size = q.size();\\n\\t\\tfor(int i=0;i<size;i++)\\n\\t\\t{\\n\\t\\t\\tTreeNode* temp = q.front();\\n\\t\\t\\ttemp->val = result[level][idx];\\n\\t\\t\\tidx++;\\n\\t\\t\\tq.pop();\\n\\t\\t\\t\\n\\t\\t\\tif(temp->left != NULL)\\n\\t\\t\\tq.push(temp->left);\\n\\t\\t\\t\\n\\t\\t\\tif(temp->right != NULL)\\n\\t\\t\\tq.push(temp->right);\\n\\t\\t}\\n\\t\\tlevel++;\\n\\t}\\n\\treturn root;\\n}\\nvoid dfs(TreeNode* root,unordered_map<int,int>&level_sum,int level)\\n{\\n\\tif(root == NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\tlevel_sum[level]+=root->val;\\n\\tdfs(root->left,level_sum,level+1);\\n\\tdfs(root->right,level_sum,level+1);\\n}\\nvoid fillmap(TreeNode* root,unordered_map<TreeNode*,TreeNode*>&mp)\\n{\\n\\tif(root == NULL)\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t//if the left child exist\\n\\tif(root->left != NULL)\\n\\t{\\n\\t\\tmp[root->left] = root;\\n\\t}\\n\\t//if the right child exist\\n\\tif(root->right != NULL)\\n\\t{\\n\\t\\tmp[root->right] = root;\\n\\t}\\n\\tfillmap(root->left,mp);\\n\\tfillmap(root->right,mp);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424785,
                "title": "c-single-bfs-faster-92",
                "content": "**Intiution**\\n- To store metadata for each node in a data structure, we incorporate a wrapper node that holds the sum of the values of two siblings.\\n- This strategy is crucial in allowing us to perform subtraction of the `sum of values of two siblings` from the `total value sum` at every level.\\n- Then we sinply run `BFS` fro level order traversal.\\n\\n**Code**\\n```c++\\nstruct NodeWrapper {\\n    TreeNode* inner = NULL;\\n    int sibling_val_sum = 0;\\n    NodeWrapper(TreeNode* inner, int sibling_val_sum): inner(inner), sibling_val_sum(sibling_val_sum) {}\\n};\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<NodeWrapper*> q{ new NodeWrapper(root, root->val) };\\n        \\n        while (q.size()) {\\n            int sum = 0;\\n            for (auto w: q) sum += w->inner->val;\\n            \\n            vector<NodeWrapper*> t;\\n            for (auto w: q) {\\n                auto n = w->inner; int total = w->sibling_val_sum;\\n                n->val = sum - total;\\n                \\n                auto sum = (n->left ? n->left->val: 0) + (n->right ? n->right->val: 0);\\n                \\n                if (n->left) t.push_back(new NodeWrapper(n->left, sum));\\n                if (n->right) t.push_back(new NodeWrapper(n->right, sum));\\n            }\\n            q = t;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nstruct NodeWrapper {\\n    TreeNode* inner = NULL;\\n    int sibling_val_sum = 0;\\n    NodeWrapper(TreeNode* inner, int sibling_val_sum): inner(inner), sibling_val_sum(sibling_val_sum) {}\\n};\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<NodeWrapper*> q{ new NodeWrapper(root, root->val) };\\n        \\n        while (q.size()) {\\n            int sum = 0;\\n            for (auto w: q) sum += w->inner->val;\\n            \\n            vector<NodeWrapper*> t;\\n            for (auto w: q) {\\n                auto n = w->inner; int total = w->sibling_val_sum;\\n                n->val = sum - total;\\n                \\n                auto sum = (n->left ? n->left->val: 0) + (n->right ? n->right->val: 0);\\n                \\n                if (n->left) t.push_back(new NodeWrapper(n->left, sum));\\n                if (n->right) t.push_back(new NodeWrapper(n->right, sum));\\n            }\\n            q = t;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424011,
                "title": "c-code-for-this-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsolve this problem by storing the parent of each node and \\nvalue corresponding to each node\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void solve(TreeNode *root,map<TreeNode*,TreeNode*> &mp){\\n        if(root == NULL){\\n            return;\\n        }\\n        if(root->left)mp[root->left] = root;\\n        if(root->right)mp[root->right] = root;\\n        \\n        solve(root->left,mp);\\n        solve(root->right,mp);\\n    }\\n    void accvalue(TreeNode *root,unordered_map<TreeNode*,int> &mp){\\n        if(root == NULL)return;\\n        mp[root] = root->val;\\n        accvalue(root->left,mp);\\n        accvalue(root->right,mp);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        if(root == NULL)return NULL;\\n        map<TreeNode*,TreeNode*> mp;\\n        solve(root,mp);\\n        mp[root] = NULL;\\n        unordered_map<TreeNode*,int> m;\\n        accvalue(root,m);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        vector<int> ans;\\n        while(q.empty() == false){\\n            int n = q.size();\\n            int sum = 0;\\n            for(int i=0;i<n;i++){\\n                TreeNode *currnode = q.front();\\n                q.pop();\\n                sum+=currnode->val;\\n                if(currnode->left)q.push(currnode->left);\\n                if(currnode->right)q.push(currnode->right);\\n            }\\n            ans.push_back(sum);\\n        }\\n        \\n        queue<TreeNode*> pq;\\n        pq.push(root);\\n        int ptr = 0;\\n        while(pq.empty() == false){\\n            int n = pq.size();\\n            int levelsum = ans[ptr++];\\n            for(int i=0;i<n;i++){\\n                TreeNode *currnode= pq.front();\\n                pq.pop();\\n                TreeNode *par = mp[currnode];\\n                if(par == NULL){\\n                    currnode->val = 0;\\n                }\\n                else if(par->left == currnode){\\n                   // if(par->right)cout<<m[par->right]<<endl;\\n                    if(par->right)currnode->val = levelsum - currnode->val - m[par->right];\\n                    else currnode->val = levelsum - currnode->val;\\n                }\\n                else if(par->right == currnode){\\n                    if(par->left)cout<<m[par->left]<<endl;\\n                    if(par->left)currnode->val = levelsum - currnode->val - m[par->left];\\n                    else currnode->val = levelsum - currnode->val;\\n                }\\n                if(currnode->left)pq.push(currnode->left);\\n                if(currnode->right)pq.push(currnode->right);\\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void solve(TreeNode *root,map<TreeNode*,TreeNode*> &mp){\\n        if(root == NULL){\\n            return;\\n        }\\n        if(root->left)mp[root->left] = root;\\n        if(root->right)mp[root->right] = root;\\n        \\n        solve(root->left,mp);\\n        solve(root->right,mp);\\n    }\\n    void accvalue(TreeNode *root,unordered_map<TreeNode*,int> &mp){\\n        if(root == NULL)return;\\n        mp[root] = root->val;\\n        accvalue(root->left,mp);\\n        accvalue(root->right,mp);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        if(root == NULL)return NULL;\\n        map<TreeNode*,TreeNode*> mp;\\n        solve(root,mp);\\n        mp[root] = NULL;\\n        unordered_map<TreeNode*,int> m;\\n        accvalue(root,m);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        vector<int> ans;\\n        while(q.empty() == false){\\n            int n = q.size();\\n            int sum = 0;\\n            for(int i=0;i<n;i++){\\n                TreeNode *currnode = q.front();\\n                q.pop();\\n                sum+=currnode->val;\\n                if(currnode->left)q.push(currnode->left);\\n                if(currnode->right)q.push(currnode->right);\\n            }\\n            ans.push_back(sum);\\n        }\\n        \\n        queue<TreeNode*> pq;\\n        pq.push(root);\\n        int ptr = 0;\\n        while(pq.empty() == false){\\n            int n = pq.size();\\n            int levelsum = ans[ptr++];\\n            for(int i=0;i<n;i++){\\n                TreeNode *currnode= pq.front();\\n                pq.pop();\\n                TreeNode *par = mp[currnode];\\n                if(par == NULL){\\n                    currnode->val = 0;\\n                }\\n                else if(par->left == currnode){\\n                   // if(par->right)cout<<m[par->right]<<endl;\\n                    if(par->right)currnode->val = levelsum - currnode->val - m[par->right];\\n                    else currnode->val = levelsum - currnode->val;\\n                }\\n                else if(par->right == currnode){\\n                    if(par->left)cout<<m[par->left]<<endl;\\n                    if(par->left)currnode->val = levelsum - currnode->val - m[par->left];\\n                    else currnode->val = levelsum - currnode->val;\\n                }\\n                if(currnode->left)pq.push(currnode->left);\\n                if(currnode->right)pq.push(currnode->right);\\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3423874,
                "title": "bfs-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n        \\n        while(q.size()) {\\n            int n = q.size(), levelSum = 0;\\n            vector<pair<TreeNode*, int>> v;\\n            \\n            for(int i=0; i<n; i++) {\\n                TreeNode* temp = q.front().first;\\n                int value = q.front().second; q.pop();\\n                v.push_back({temp, value});\\n\\n                if(temp -> left) levelSum += temp -> left -> val;\\n                if(temp -> right)  levelSum += temp -> right -> val;\\n            }\\n            for(int i=0; i<n; i++) {\\n                TreeNode* temp = v[i].first;\\n                int value = v[i].second;\\n                \\n                if(temp -> left) {\\n                    q.push({temp -> left, levelSum - temp -> left -> val - (temp -> right ? temp -> right -> val : 0)});\\n                }\\n                if(temp -> right) {\\n                    q.push({temp -> right, levelSum - temp -> right -> val - (temp -> left ? temp -> left -> val : 0)});\\n                }\\n                temp -> val = value;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n        \\n        while(q.size()) {\\n            int n = q.size(), levelSum = 0;\\n            vector<pair<TreeNode*, int>> v;\\n            \\n            for(int i=0; i<n; i++) {\\n                TreeNode* temp = q.front().first;\\n                int value = q.front().second; q.pop();\\n                v.push_back({temp, value});\\n\\n                if(temp -> left) levelSum += temp -> left -> val;\\n                if(temp -> right)  levelSum += temp -> right -> val;\\n            }\\n            for(int i=0; i<n; i++) {\\n                TreeNode* temp = v[i].first;\\n                int value = v[i].second;\\n                \\n                if(temp -> left) {\\n                    q.push({temp -> left, levelSum - temp -> left -> val - (temp -> right ? temp -> right -> val : 0)});\\n                }\\n                if(temp -> right) {\\n                    q.push({temp -> right, levelSum - temp -> right -> val - (temp -> left ? temp -> left -> val : 0)});\\n                }\\n                temp -> val = value;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423709,
                "title": "java-beats-100-bfs",
                "content": "My idea was simple. \\n\\nTraverse every node in Tree with BFS. In every level traverse twice.\\nHashMap map is used to find the parent\\'s value\\nHashMap nodes is used to find the parent node of the node\\n\\n- First is to find the total of the all values.\\n- Second is to find the value of the node ( total - parent\\'s value). And the node is added to`nodes` map as parent with its children if they exist. And the total of left and right children are added to `map` \\n\\nRoot.val is never changed. So,` root.val=0` then we can return root safely. \\n```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        HashMap<TreeNode, Integer> map = new HashMap<>();\\n        HashMap<TreeNode, TreeNode> nodes = new HashMap<>();    \\n        q.add(root);\\n        \\n        while(!q.isEmpty()){\\n            int size= q.size();\\n            int total= 0;\\n            for(TreeNode t: q) total+= t.val;\\n            for(int i=0; i<size; i++){\\n                TreeNode curr = q.poll();        \\n                if(curr != root){  // to avoid null pointer exception\\n                    TreeNode parent = nodes.get(curr);\\n                    curr.val = total - map.get(parent);\\n                }\\n                int left = 0;\\n                int right= 0;\\n                if(curr.left != null){ \\n                    left = curr.left.val;\\n                    q.add(curr.left);\\n                    nodes.put(curr.left, curr);\\n                }\\n                if(curr.right != null){\\n                    right = curr.right.val;\\n                    q.add(curr.right);\\n                    nodes.put(curr.right, curr);\\n                }\\n                map.put(curr, left+right);\\n            }\\n        }\\n        root.val = 0;\\n        return root;\\n    }\\n}\\n```\\nIf the data is correct, it is pretty efficient. \\n![image](https://assets.leetcode.com/users/images/249c1a0f-d481-419e-8129-c1b2fd29f415_1681652315.6029444.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        HashMap<TreeNode, Integer> map = new HashMap<>();\\n        HashMap<TreeNode, TreeNode> nodes = new HashMap<>();    \\n        q.add(root);\\n        \\n        while(!q.isEmpty()){\\n            int size= q.size();\\n            int total= 0;\\n            for(TreeNode t: q) total+= t.val;\\n            for(int i=0; i<size; i++){\\n                TreeNode curr = q.poll();        \\n                if(curr != root){  // to avoid null pointer exception\\n                    TreeNode parent = nodes.get(curr);\\n                    curr.val = total - map.get(parent);\\n                }\\n                int left = 0;\\n                int right= 0;\\n                if(curr.left != null){ \\n                    left = curr.left.val;\\n                    q.add(curr.left);\\n                    nodes.put(curr.left, curr);\\n                }\\n                if(curr.right != null){\\n                    right = curr.right.val;\\n                    q.add(curr.right);\\n                    nodes.put(curr.right, curr);\\n                }\\n                map.put(curr, left+right);\\n            }\\n        }\\n        root.val = 0;\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423095,
                "title": "easy-to-understand-c-solution-binary-tree-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int height(TreeNode* root)\\n    {\\n        if(root==nullptr)return 0;\\n        int l = height(root->left);\\n        int r = height(root->right);\\n        return max(l,r)+1;\\n    }\\n    void f(TreeNode* root,int x)\\n    {\\n        if(root==nullptr)return ;\\n        ans[x]+= root->val;\\n        f(root->left,x+1);\\n        f(root->right,x+1);\\n    }\\n    \\n    TreeNode* dfs(TreeNode* par,TreeNode* root,int x)\\n    {\\n        if(root==NULL)return NULL;\\n        TreeNode* node;\\n        if(x==1 || x==2)\\n        {\\n            node = new TreeNode(0);\\n            node->left = dfs(root,root->left,x+1);\\n            node->right = dfs(root,root->right,x+1);\\n        }\\n        else\\n        {\\n            int sum = ans[x];\\n               if(par->left) sum-=par->left->val;\\n            if(par->right) sum-=par->right->val;\\n            node = new TreeNode(sum);\\n            node->left = dfs(root,root->left,x+1);\\n            node->right = dfs(root,root->right,x+1);\\n\\n        }\\n        return node;\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==nullptr)return nullptr;\\n        ans.resize(height(root)+1,0);\\n        f(root,1);\\n        return dfs(nullptr,root,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    int height(TreeNode* root)\\n    {\\n        if(root==nullptr)return 0;\\n        int l = height(root->left);\\n        int r = height(root->right);\\n        return max(l,r)+1;\\n    }\\n    void f(TreeNode* root,int x)\\n    {\\n        if(root==nullptr)return ;\\n        ans[x]+= root->val;\\n        f(root->left,x+1);\\n        f(root->right,x+1);\\n    }\\n    \\n    TreeNode* dfs(TreeNode* par,TreeNode* root,int x)\\n    {\\n        if(root==NULL)return NULL;\\n        TreeNode* node;\\n        if(x==1 || x==2)\\n        {\\n            node = new TreeNode(0);\\n            node->left = dfs(root,root->left,x+1);\\n            node->right = dfs(root,root->right,x+1);\\n        }\\n        else\\n        {\\n            int sum = ans[x];\\n               if(par->left) sum-=par->left->val;\\n            if(par->right) sum-=par->right->val;\\n            node = new TreeNode(sum);\\n            node->left = dfs(root,root->left,x+1);\\n            node->right = dfs(root,root->right,x+1);\\n\\n        }\\n        return node;\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==nullptr)return nullptr;\\n        ans.resize(height(root)+1,0);\\n        f(root,1);\\n        return dfs(nullptr,root,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422551,
                "title": "2-dfs-c-readable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int, int>m;// To store sum of all Node val at each level\\n    void dfs(TreeNode *root,int k)\\n    {\\n        if(!root) return ;\\n        m[k]=m[k]+root->val;\\n        dfs(root->left,k+1);\\n        dfs(root->right,k+1);\\n\\n    }\\n    void Dfs(TreeNode *root,int k)\\n    {\\n         if(!root) return ;\\n         Dfs(root->left,k+1);\\n         Dfs(root->right,k+1);\\n         if(root->left && root->right)\\n         {\\n        \\n          root->left->val=m[k+1]-(root->left->val+root->right->val);\\n          root->right->val=root->left->val;\\n         }\\n         else if(root->left)\\n         {\\n             root->left->val=m[k+1]-(root->left->val);\\n         }\\n          else if(root->right)\\n         {\\n             root->right->val=m[k+1]-(root->right->val);\\n         }\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n          dfs(root,0);//update our map that will store sum at every level\\n          Dfs(root,0);// update node val\\n          root->val=0;// updating root to 0\\n          return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int, int>m;// To store sum of all Node val at each level\\n    void dfs(TreeNode *root,int k)\\n    {\\n        if(!root) return ;\\n        m[k]=m[k]+root->val;\\n        dfs(root->left,k+1);\\n        dfs(root->right,k+1);\\n\\n    }\\n    void Dfs(TreeNode *root,int k)\\n    {\\n         if(!root) return ;\\n         Dfs(root->left,k+1);\\n         Dfs(root->right,k+1);\\n         if(root->left && root->right)\\n         {\\n        \\n          root->left->val=m[k+1]-(root->left->val+root->right->val);\\n          root->right->val=root->left->val;\\n         }\\n         else if(root->left)\\n         {\\n             root->left->val=m[k+1]-(root->left->val);\\n         }\\n          else if(root->right)\\n         {\\n             root->right->val=m[k+1]-(root->right->val);\\n         }\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n          dfs(root,0);//update our map that will store sum at every level\\n          Dfs(root,0);// update node val\\n          root->val=0;// updating root to 0\\n          return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422255,
                "title": "dfs-with-diagram-o-n",
                "content": "\\n![BinaryTree_Cousins.jpg](https://assets.leetcode.com/users/images/88b12fae-0e7a-4d94-b9a1-cd0675a938db_1681622795.4665618.jpeg)\\n# Complexity-Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIf you have any suggestion to improve it then please tell. \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n        public TreeNode replaceValueInTree(TreeNode root) {\\n            root.val=0;\\n            Queue<TreeNode>que=new LinkedList<>();\\n            que.add(root);\\n            while(!que.isEmpty()){\\n                int size=que.size();\\n                LinkedList<TreeNode>parentnode=new LinkedList<>(que);\\n                int sum=0;\\n                while(size>0){\\n                    TreeNode tr=que.remove();\\n                    if(tr.left!=null){sum+=tr.left.val;que.add(tr.left);}\\n                    if(tr.right!=null){sum+=tr.right.val;que.add(tr.right);}\\n                    size--;\\n                }\\n                for(TreeNode n:parentnode){int tempsum=sum;\\n                    if(n.left!=null){tempsum-=n.left.val;}\\n                    if(n.right!=null){tempsum-=n.right.val;}\\n                    if(n.left!=null) n.left.val=tempsum;\\n                   if(n.right!=null) n.right.val=tempsum;\\n                }\\n            }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n        public TreeNode replaceValueInTree(TreeNode root) {\\n            root.val=0;\\n            Queue<TreeNode>que=new LinkedList<>();\\n            que.add(root);\\n            while(!que.isEmpty()){\\n                int size=que.size();\\n                LinkedList<TreeNode>parentnode=new LinkedList<>(que);\\n                int sum=0;\\n                while(size>0){\\n                    TreeNode tr=que.remove();\\n                    if(tr.left!=null){sum+=tr.left.val;que.add(tr.left);}\\n                    if(tr.right!=null){sum+=tr.right.val;que.add(tr.right);}\\n                    size--;\\n                }\\n                for(TreeNode n:parentnode){int tempsum=sum;\\n                    if(n.left!=null){tempsum-=n.left.val;}\\n                    if(n.right!=null){tempsum-=n.right.val;}\\n                    if(n.left!=null) n.left.val=tempsum;\\n                   if(n.right!=null) n.right.val=tempsum;\\n                }\\n            }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421399,
                "title": "i-kotlin-bfs-with-illustrated-explanation",
                "content": "# Intuition\\nThe first approach that may come to one\\u2019s mind is pretty straightforward: calculate the sum of all cousines and then replace each cousin\\'s value with the difference if this sum and a sum of thise node siblings values.\\n\\n# Approach\\nLet\\u2019s take a look at a tree. \\n\\n![A Tree](https://assets.leetcode.com/users/images/bd390a75-a75f-40c5-b21b-55e13b252653_1681603051.9156284.png)\\n\\n\\nTraversing the tree level by level we can calculate a sum of all values at each level. This sum is the sum of all cousines. The next step would be assigning the sum minus values of all node siblings.\\n\\n![](https://assets.leetcode.com/users/images/491435a6-6e97-4fa9-8efd-4d39f6aed356_1681603084.5572708.png)\\n\\n\\nUnfortunately, this approach won\\'t work, because we don\\'t possess the information about siblings. As one of possible options we can operate with nodes children, instead of nodes itself.\\n\\n**Step 1.** Sum all children values and put it to sum\\n\\n![](https://assets.leetcode.com/users/images/95f66493-bab0-459c-89af-47b0c755ecae_1681603075.0084324.png)\\n\\n\\n**Step 2.** For each node, calculate the value of sum - value of the left child if it exists - value of the right child, if it exists.\\n**Step 3.** Assign the values to all node children\\n\\n![](https://assets.leetcode.com/users/images/7d08671a-5659-43d9-a70c-3da594946a86_1681603170.5213504.png)\\n\\n\\n**Step 4.** Repeat all previous steps for the children.\\n\\n\\n# Complexity\\n- Time complexity: $O(nlog(n))$\\n\\n- Space complexity: $O(log(n))$\\n\\n# Code\\n```\\nclass Solution {\\n    fun replaceValueInTree(root: TreeNode): TreeNode {\\n        \\n        fun TreeNode.sumOfChildrenValues() = \\n            (left?.`val` ?: 0) + (right?.`val` ?: 0)\\n\\n        var nodes = mutableListOf(root.apply { `val` = 0 })\\n        while (nodes.isNotEmpty()) {\\n            val sumOfAllCousins = nodes\\n                .map(TreeNode::sumOfChildrenValues).sum()\\n            \\n            nodes = mutableListOf<TreeNode>().apply {\\n                for (node in nodes) {\\n                    val sumOfOtherCousines = \\n                        sumOfAllCousins - node.sumOfChildrenValues()\\n                    node.left?.also { child ->\\n                        child.`val` = sumOfOtherCousines\\n                        add(child) \\n                    }\\n                    node.right?.also { child ->\\n                        child.`val` = sumOfOtherCousines\\n                        add(child) \\n                    }\\n                }\\n            }\\n        }\\n\\n        return root\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    fun replaceValueInTree(root: TreeNode): TreeNode {\\n        \\n        fun TreeNode.sumOfChildrenValues() = \\n            (left?.`val` ?: 0) + (right?.`val` ?: 0)\\n\\n        var nodes = mutableListOf(root.apply { `val` = 0 })\\n        while (nodes.isNotEmpty()) {\\n            val sumOfAllCousins = nodes\\n                .map(TreeNode::sumOfChildrenValues).sum()\\n            \\n            nodes = mutableListOf<TreeNode>().apply {\\n                for (node in nodes) {\\n                    val sumOfOtherCousines = \\n                        sumOfAllCousins - node.sumOfChildrenValues()\\n                    node.left?.also { child ->\\n                        child.`val` = sumOfOtherCousines\\n                        add(child) \\n                    }\\n                    node.right?.also { child ->\\n                        child.`val` = sumOfOtherCousines\\n                        add(child) \\n                    }\\n                }\\n            }\\n        }\\n\\n        return root\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420939,
                "title": "pretty-hard-to-understand-but-works-flawless-not-a-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == nullptr) return root;\\n        \\n        root->val = 0;\\n        \\n        if(!root->left && !root->right) return root;\\n    \\n        if(root->left) {\\n            root->left->val = 0;    \\n        }\\n        \\n        if(root->right) {\\n            root->right->val = 0; \\n        }\\n        \\n        vector<vector<pair<int,int>>> values;\\n        \\n        TreeNode* root_node = root;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root_node);\\n        \\n        while(!q.empty()) {\\n            int n = q.size();\\n            vector<pair<int,int>> vec;\\n            \\n            for(int i = 0 ; i<n ; i++) {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                pair<int,int> vals = {0, 0};\\n\\n                if(node->left) {\\n                    vals.first = node->left->val;\\n                    q.push(node->left);\\n                }\\n\\n                if(node->right) {\\n                    vals.second = node->right->val;\\n                    q.push(node->right);\\n                }\\n                \\n                vec.push_back(vals);\\n            }\\n            \\n            values.push_back(vec);\\n        }\\n                \\n        root_node = root;\\n        \\n        if(root_node->left) {\\n            q.push(root_node->left);        \\n        }\\n        \\n        if(root_node->right) {\\n            q.push(root_node->right);        \\n        }\\n        \\n        int index = 1;\\n        int m = values.size();\\n        \\n        while(!q.empty() && index < m) {\\n            int n = q.size();\\n            \\n            int sum = 0;\\n            \\n            for(pair<int,int>& p : values[index]) {\\n                sum += p.first + p.second;\\n            }\\n            \\n            index++;\\n            \\n            for(int i = 0 ; i<n ; i++) {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                if(node->left && node->right) {\\n                    int val = sum - (node->left->val + node->right->val);\\n                    \\n                    node->left->val = val;\\n                    node->right->val = val;\\n                                        \\n                    q.push(node->left);\\n                    q.push(node->right);\\n                } else if(node->left) {\\n                    int val = sum - node->left->val;\\n                    \\n                    node->left->val = val;\\n                    \\n                    q.push(node->left);\\n                } else if(node->right) {\\n                    int val = sum - node->right->val;\\n                    \\n                    node->right->val = val;\\n                    \\n                    q.push(node->right);\\n                }\\n            }\\n            \\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == nullptr) return root;\\n        \\n        root->val = 0;\\n        \\n        if(!root->left && !root->right) return root;\\n    \\n        if(root->left) {\\n            root->left->val = 0;    \\n        }\\n        \\n        if(root->right) {\\n            root->right->val = 0; \\n        }\\n        \\n        vector<vector<pair<int,int>>> values;\\n        \\n        TreeNode* root_node = root;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root_node);\\n        \\n        while(!q.empty()) {\\n            int n = q.size();\\n            vector<pair<int,int>> vec;\\n            \\n            for(int i = 0 ; i<n ; i++) {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                pair<int,int> vals = {0, 0};\\n\\n                if(node->left) {\\n                    vals.first = node->left->val;\\n                    q.push(node->left);\\n                }\\n\\n                if(node->right) {\\n                    vals.second = node->right->val;\\n                    q.push(node->right);\\n                }\\n                \\n                vec.push_back(vals);\\n            }\\n            \\n            values.push_back(vec);\\n        }\\n                \\n        root_node = root;\\n        \\n        if(root_node->left) {\\n            q.push(root_node->left);        \\n        }\\n        \\n        if(root_node->right) {\\n            q.push(root_node->right);        \\n        }\\n        \\n        int index = 1;\\n        int m = values.size();\\n        \\n        while(!q.empty() && index < m) {\\n            int n = q.size();\\n            \\n            int sum = 0;\\n            \\n            for(pair<int,int>& p : values[index]) {\\n                sum += p.first + p.second;\\n            }\\n            \\n            index++;\\n            \\n            for(int i = 0 ; i<n ; i++) {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                if(node->left && node->right) {\\n                    int val = sum - (node->left->val + node->right->val);\\n                    \\n                    node->left->val = val;\\n                    node->right->val = val;\\n                                        \\n                    q.push(node->left);\\n                    q.push(node->right);\\n                } else if(node->left) {\\n                    int val = sum - node->left->val;\\n                    \\n                    node->left->val = val;\\n                    \\n                    q.push(node->left);\\n                } else if(node->right) {\\n                    int val = sum - node->right->val;\\n                    \\n                    node->right->val = val;\\n                    \\n                    q.push(node->right);\\n                }\\n            }\\n            \\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420930,
                "title": "100-fast-easiest-java-solution-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        Queue<TreeNode> q2 = new LinkedList<>();\\n        q.offer(root);\\n        q2.offer(root);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int s = 0;\\n            System.out.println(size);\\n            while(size-- > 0) {\\n                TreeNode p = q.poll();\\n                int sum = 0;\\n                if(p.left != null) {\\n                    sum = sum + p.left.val;\\n                    q.offer(p.left);\\n                }\\n                if(p.right != null) {\\n                    sum = sum + p.right.val;\\n                    q.offer(p.right);\\n                }\\n                s += sum;\\n            }\\n            size = q2.size();\\n            while(size-- > 0) {\\n                TreeNode p = q2.poll();\\n                int sum = 0;\\n                if(p.left != null) {\\n                    sum = sum + p.left.val;\\n                    q2.offer(p.left);\\n                }\\n                if(p.right != null) {\\n                    sum = sum + p.right.val;\\n                    q2.offer(p.right);\\n                }\\n                if(p.left != null) {\\n                    p.left.val = s - sum;\\n                }\\n                if(p.right != null) {\\n                    p.right.val = s - sum;\\n                }\\n            }\\n        }\\n        root.val = 0;\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        Queue<TreeNode> q2 = new LinkedList<>();\\n        q.offer(root);\\n        q2.offer(root);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            int s = 0;\\n            System.out.println(size);\\n            while(size-- > 0) {\\n                TreeNode p = q.poll();\\n                int sum = 0;\\n                if(p.left != null) {\\n                    sum = sum + p.left.val;\\n                    q.offer(p.left);\\n                }\\n                if(p.right != null) {\\n                    sum = sum + p.right.val;\\n                    q.offer(p.right);\\n                }\\n                s += sum;\\n            }\\n            size = q2.size();\\n            while(size-- > 0) {\\n                TreeNode p = q2.poll();\\n                int sum = 0;\\n                if(p.left != null) {\\n                    sum = sum + p.left.val;\\n                    q2.offer(p.left);\\n                }\\n                if(p.right != null) {\\n                    sum = sum + p.right.val;\\n                    q2.offer(p.right);\\n                }\\n                if(p.left != null) {\\n                    p.left.val = s - sum;\\n                }\\n                if(p.right != null) {\\n                    p.right.val = s - sum;\\n                }\\n            }\\n        }\\n        root.val = 0;\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420892,
                "title": "simple-bfs-codes-gives-explanation-tracking-previous-value",
                "content": "# Intuition\\n***Summing up All the TreeNode values within a particular level and\\nSubstracting the value of particular node and sibling node value.***\\n# Approach\\n***Simple BFS to track the child along with parent\\nComputed sum of all the nodes of the previous level used in the particular level for summing up other than sibling nodes.***\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# please upvote if it helped\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> qu;\\n        \\n        qu.push(root);\\n        int prev_sum=root->val;\\n        root->val=-root->val;\\n\\n        while(!qu.empty())\\n        {\\n            queue<TreeNode*> qu2;\\n            int sum_=0;\\n            int size = qu.size();\\n            for(int i=0;i<size;i++)\\n            {    \\n                TreeNode *cur= qu.front();\\n                int a=0,b=0;\\n                if(cur->left)\\n                {\\n                    qu.push(cur->left);  \\n                    if(cur->right)\\n                    {\\n                       a=cur->right->val;           \\n                    }       \\n                }\\n                if(cur->right)\\n                {\\n                    qu.push(cur->right);\\n                    if(cur->left)\\n                    {\\n                        b=cur->left->val;\\n                    }\\n                }\\n                if(cur->right)\\n                {\\n                    sum_+=cur->right->val;\\n                    cur->right->val+=b;\\n                    cur->right->val=-cur->right->val;\\n                }\\n                if(cur->left)\\n                {\\n                    sum_+=cur->left->val;\\n                    cur->left->val+=a;\\n                    cur->left->val=-cur->left->val;\\n                }\\n\\n                qu2.push(qu.front());\\n                qu.pop();\\n            }\\n            while(!qu2.empty())\\n            {\\n                TreeNode *cur=qu2.front();\\n                qu2.pop();\\n                cur->val+=prev_sum;\\n            } \\n            prev_sum=sum_; \\n        }\\n\\n        return root;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> qu;\\n        \\n        qu.push(root);\\n        int prev_sum=root->val;\\n        root->val=-root->val;\\n\\n        while(!qu.empty())\\n        {\\n            queue<TreeNode*> qu2;\\n            int sum_=0;\\n            int size = qu.size();\\n            for(int i=0;i<size;i++)\\n            {    \\n                TreeNode *cur= qu.front();\\n                int a=0,b=0;\\n                if(cur->left)\\n                {\\n                    qu.push(cur->left);  \\n                    if(cur->right)\\n                    {\\n                       a=cur->right->val;           \\n                    }       \\n                }\\n                if(cur->right)\\n                {\\n                    qu.push(cur->right);\\n                    if(cur->left)\\n                    {\\n                        b=cur->left->val;\\n                    }\\n                }\\n                if(cur->right)\\n                {\\n                    sum_+=cur->right->val;\\n                    cur->right->val+=b;\\n                    cur->right->val=-cur->right->val;\\n                }\\n                if(cur->left)\\n                {\\n                    sum_+=cur->left->val;\\n                    cur->left->val+=a;\\n                    cur->left->val=-cur->left->val;\\n                }\\n\\n                qu2.push(qu.front());\\n                qu.pop();\\n            }\\n            while(!qu2.empty())\\n            {\\n                TreeNode *cur=qu2.front();\\n                qu2.pop();\\n                cur->val+=prev_sum;\\n            } \\n            prev_sum=sum_; \\n        }\\n\\n        return root;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420849,
                "title": "python-two-dfs",
                "content": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        def dfs(node, p, d):\\n            if not node:\\n                return\\n\\n            vals[d] += node.val\\n            pars[d][hash(p)] += node.val\\n            dfs(node.left, node, d + 1)\\n            dfs(node.right, node, d + 1)\\n\\n        vals = defaultdict(int)\\n        pars = defaultdict(lambda: defaultdict(int))\\n        dfs(root, 0, 0)\\n\\n        def modify(node, p, d):\\n            if not node:\\n                return\\n\\n            s = vals[d] - pars[d][p]\\n            orig = hash(node)\\n            node.val = s\\n\\n            modify(node.left, orig, d + 1)\\n            modify(node.right, orig, d + 1)\\n\\n        modify(root, 0, 0)\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        def dfs(node, p, d):\\n            if not node:\\n                return\\n\\n            vals[d] += node.val\\n            pars[d][hash(p)] += node.val\\n            dfs(node.left, node, d + 1)\\n            dfs(node.right, node, d + 1)\\n\\n        vals = defaultdict(int)\\n        pars = defaultdict(lambda: defaultdict(int))\\n        dfs(root, 0, 0)\\n\\n        def modify(node, p, d):\\n            if not node:\\n                return\\n\\n            s = vals[d] - pars[d][p]\\n            orig = hash(node)\\n            node.val = s\\n\\n            modify(node.left, orig, d + 1)\\n            modify(node.right, orig, d + 1)\\n\\n        modify(root, 0, 0)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420656,
                "title": "golang-simple-bfs",
                "content": "# Approach\\n```\\n           5\\n         /   \\\\\\n       4       9\\n     /   \\\\       \\\\\\n   1       10      7\\n```\\n\\n```\\n                        parents=[]\\n\\n          5-5           children=[5], sum=5\\n         /   \\\\\\n       4       9\\n     /   \\\\       \\\\\\n   1       10      7\\n```\\n\\n```    \\n           0            parents=[x]\\n         /   \\\\\\n    sum-4-9  sum-4-9    children=[4, 9], sum=13\\n     /   \\\\       \\\\\\n   1       10      7\\n```\\n\\n```   \\n           0           \\n         /   \\\\\\n       0       0        parents=[x, x]\\n     /   \\\\       \\\\\\nsum-1-10 sum-1-10 sum-7 children=[1, 10, 7], sum=18\\n```\\n\\n```     \\n           0           \\n         /   \\\\\\n       0       0        \\n     /   \\\\       \\\\\\n   7       7      11    parents=[x, x, x]\\n\\n                        children=[]\\n```\\n\\n# Code\\n```\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n    children := []*TreeNode{root}\\n    root.Val = 0\\n\\n    // Each iteration children list contains all elements with the same depth\\n    for len(children) > 0 {\\n        parents := children\\n        children = []*TreeNode{}\\n\\n        // Find sum of all children in this depth\\n        sum := 0\\n        for _, parent := range parents {\\n            if parent.Left != nil { sum += parent.Left.Val }\\n            if parent.Right != nil { sum += parent.Right.Val } \\n        }\\n\\n        // Update children values:\\n        // Calculated sum minus the current childer values (if they exist)\\n        // Also add all children to the list for the next iteration (depth+1)\\n        for _, parent := range parents {\\n            reduce := 0\\n            if parent.Left != nil { reduce += parent.Left.Val }\\n            if parent.Right != nil { reduce += parent.Right.Val }\\n            \\n            if parent.Left != nil {\\n                parent.Left.Val = sum - reduce\\n                children = append(children, parent.Left)\\n            }\\n            if parent.Right != nil {\\n                parent.Right.Val = sum - reduce\\n                children = append(children, parent.Right)\\n            }\\n        }\\n    }\\n    \\n    return root\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n           5\\n         /   \\\\\\n       4       9\\n     /   \\\\       \\\\\\n   1       10      7\\n```\n```\\n                        parents=[]\\n\\n          5-5           children=[5], sum=5\\n         /   \\\\\\n       4       9\\n     /   \\\\       \\\\\\n   1       10      7\\n```\n```    \\n           0            parents=[x]\\n         /   \\\\\\n    sum-4-9  sum-4-9    children=[4, 9], sum=13\\n     /   \\\\       \\\\\\n   1       10      7\\n```\n```   \\n           0           \\n         /   \\\\\\n       0       0        parents=[x, x]\\n     /   \\\\       \\\\\\nsum-1-10 sum-1-10 sum-7 children=[1, 10, 7], sum=18\\n```\n```     \\n           0           \\n         /   \\\\\\n       0       0        \\n     /   \\\\       \\\\\\n   7       7      11    parents=[x, x, x]\\n\\n                        children=[]\\n```\n```\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n    children := []*TreeNode{root}\\n    root.Val = 0\\n\\n    // Each iteration children list contains all elements with the same depth\\n    for len(children) > 0 {\\n        parents := children\\n        children = []*TreeNode{}\\n\\n        // Find sum of all children in this depth\\n        sum := 0\\n        for _, parent := range parents {\\n            if parent.Left != nil { sum += parent.Left.Val }\\n            if parent.Right != nil { sum += parent.Right.Val } \\n        }\\n\\n        // Update children values:\\n        // Calculated sum minus the current childer values (if they exist)\\n        // Also add all children to the list for the next iteration (depth+1)\\n        for _, parent := range parents {\\n            reduce := 0\\n            if parent.Left != nil { reduce += parent.Left.Val }\\n            if parent.Right != nil { reduce += parent.Right.Val }\\n            \\n            if parent.Left != nil {\\n                parent.Left.Val = sum - reduce\\n                children = append(children, parent.Left)\\n            }\\n            if parent.Right != nil {\\n                parent.Right.Val = sum - reduce\\n                children = append(children, parent.Right)\\n            }\\n        }\\n    }\\n    \\n    return root\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420594,
                "title": "python3-easy-and-clean-bfs-solution",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        \\n        \\n        queue = deque([(root,None)])\\n        \\n        while queue:\\n            \\n            child_sum = defaultdict(int)\\n            p = {}\\n            curr = 0\\n            \\n            for _ in range(len(queue)):\\n\\n                node, parent = queue.popleft()\\n                child_sum[parent] += node.val\\n                p[node] = parent\\n                curr += node.val\\n\\n                if node.left:\\n                    queue.append((node.left, node))\\n                if node.right:\\n                    queue.append((node.right, node))\\n            \\n            for node in p:\\n                node.val = curr - child_sum[p[node]]\\n            \\n            \\n        \\n        return root\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        \\n        \\n        queue = deque([(root,None)])\\n        \\n        while queue:\\n            \\n            child_sum = defaultdict(int)\\n            p = {}\\n            curr = 0\\n            \\n            for _ in range(len(queue)):\\n\\n                node, parent = queue.popleft()\\n                child_sum[parent] += node.val\\n                p[node] = parent\\n                curr += node.val\\n\\n                if node.left:\\n                    queue.append((node.left, node))\\n                if node.right:\\n                    queue.append((node.right, node))\\n            \\n            for node in p:\\n                node.val = curr - child_sum[p[node]]\\n            \\n            \\n        \\n        return root\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420521,
                "title": "c-well-explained-level-order-traversal-o-n-time",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlevel order traversal of binary tree\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root)   return root;\\n        map<int, int> mp;   // this map stores the total sum of every level\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int lvl = 0;\\n\\n        // level order traversing : storing the sum every level in the map\\n        while(!q.empty())   {\\n            int n = q.size();\\n            for(int i=0; i<n; i++)  {\\n                TreeNode* frNode = q.front();\\n                q.pop();\\n                mp[lvl] += frNode -> val;\\n                if(frNode -> left)  q.push(frNode -> left);\\n                if(frNode -> right) q.push(frNode -> right);\\n            }\\n            lvl++;\\n        }\\n\\n        q.push(root);   lvl = 0;\\n\\n        // modifing the value of every node\\n        // node value = (total level sum) - node->parent -> (left & right)\\n        while(!q.empty())   {\\n            int n = q.size();\\n            for(int i=0; i<n; i++)  {\\n                TreeNode* frNode = q.front();\\n                q.pop();\\n                int l = frNode->left ? frNode->left->val : 0;\\n                int r = frNode->right ? frNode->right->val : 0;\\n                if(frNode -> left)  {\\n                    q.push(frNode->left);\\n                    frNode->left->val = mp[lvl + 1] - (l+r);\\n                }\\n                if(frNode->right)   {\\n                    q.push(frNode->right);\\n                    frNode->right->val = mp[lvl + 1] - (l+r);   \\n                }\\n            }\\n            lvl++;\\n        }\\n\\n        root -> val = 0;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root)   return root;\\n        map<int, int> mp;   // this map stores the total sum of every level\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int lvl = 0;\\n\\n        // level order traversing : storing the sum every level in the map\\n        while(!q.empty())   {\\n            int n = q.size();\\n            for(int i=0; i<n; i++)  {\\n                TreeNode* frNode = q.front();\\n                q.pop();\\n                mp[lvl] += frNode -> val;\\n                if(frNode -> left)  q.push(frNode -> left);\\n                if(frNode -> right) q.push(frNode -> right);\\n            }\\n            lvl++;\\n        }\\n\\n        q.push(root);   lvl = 0;\\n\\n        // modifing the value of every node\\n        // node value = (total level sum) - node->parent -> (left & right)\\n        while(!q.empty())   {\\n            int n = q.size();\\n            for(int i=0; i<n; i++)  {\\n                TreeNode* frNode = q.front();\\n                q.pop();\\n                int l = frNode->left ? frNode->left->val : 0;\\n                int r = frNode->right ? frNode->right->val : 0;\\n                if(frNode -> left)  {\\n                    q.push(frNode->left);\\n                    frNode->left->val = mp[lvl + 1] - (l+r);\\n                }\\n                if(frNode->right)   {\\n                    q.push(frNode->right);\\n                    frNode->right->val = mp[lvl + 1] - (l+r);   \\n                }\\n            }\\n            lvl++;\\n        }\\n\\n        root -> val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420368,
                "title": "scala-two-dfs-tle",
                "content": "# Intuition\\nFirst find sum of all nodes on each level. Then, subtract cousins sum from the level sums. Value is replaced in the tree nodes to save memory allocations. Nevertheless, the solution doesn\\'t pass the tests.\\n\\n# Code\\n```\\ndef replaceValueInTree(root: TreeNode): TreeNode = {\\n    val levels = scala.collection.mutable.Map.empty[Int, Long].withDefaultValue(0)\\n    def goSums(node: TreeNode, level: Int): Unit =\\n      if (node != null) {\\n        levels(level) += node.value\\n        goSums(node.left, level + 1)\\n        goSums(node.right, level + 1)\\n      }\\n\\n    goSums(root, 0)\\n\\n    def go(node: TreeNode, level: Int, parentSum: Long): Unit = {\\n      if(node != null) {\\n        val nodeSum = computeParentSum(node)\\n        node.value = (levels(level) - parentSum).toInt\\n        go(node.left, level + 1, nodeSum)\\n        go(node.right, level + 1, nodeSum)\\n      }\\n    }\\n\\n    val rootSum = computeParentSum(root)\\n    go(root.left, 1, rootSum)\\n    go(root.right, 1, rootSum)\\n    root.value = 0\\n    root\\n  }\\n\\n  def computeParentSum(node: TreeNode) = {\\n    val left = if(node.left == null) 0 else node.left.value\\n    val right = if(node.right == null) 0 else node.right.value\\n    left.toLong + right\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\ndef replaceValueInTree(root: TreeNode): TreeNode = {\\n    val levels = scala.collection.mutable.Map.empty[Int, Long].withDefaultValue(0)\\n    def goSums(node: TreeNode, level: Int): Unit =\\n      if (node != null) {\\n        levels(level) += node.value\\n        goSums(node.left, level + 1)\\n        goSums(node.right, level + 1)\\n      }\\n\\n    goSums(root, 0)\\n\\n    def go(node: TreeNode, level: Int, parentSum: Long): Unit = {\\n      if(node != null) {\\n        val nodeSum = computeParentSum(node)\\n        node.value = (levels(level) - parentSum).toInt\\n        go(node.left, level + 1, nodeSum)\\n        go(node.right, level + 1, nodeSum)\\n      }\\n    }\\n\\n    val rootSum = computeParentSum(root)\\n    go(root.left, 1, rootSum)\\n    go(root.right, 1, rootSum)\\n    root.value = 0\\n    root\\n  }\\n\\n  def computeParentSum(node: TreeNode) = {\\n    val left = if(node.left == null) 0 else node.left.value\\n    val right = if(node.right == null) 0 else node.right.value\\n    left.toLong + right\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420359,
                "title": "simple-dfs-level-ordering-find-sum-at-depth-o-n",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    void dfs(TreeNode* root,ll depth, map<ll,ll>&mp){\\n        if(root == NULL) return;\\n        mp[depth] += root->val;\\n        dfs(root->left,depth+1,mp);\\n        dfs(root->right,depth+1,mp);\\n    }\\n    \\n    void dfs2(TreeNode* root,ll depth, map<ll,ll>&mp){\\n        if(root == NULL) return ;\\n        ll l = 0, r = 0;\\n        if(root->left) l = root->left->val;\\n        if(root->right) r = root->right->val;\\n        \\n        ll k = mp[depth+1] - l - r;\\n        // cout<<root->val<<\" \"<<l<<\" \"<<r<<\" \"<<k<<\" \"<<mp[depth+1]<<endl;\\n        if(root->left) root->left->val = k;\\n        if(root->right) root->right->val = k;\\n        \\n        \\n        dfs2(root->left,depth+1,mp);\\n        dfs2(root->right,depth+1,mp);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        map<ll,ll>mp;\\n        dfs(root,0,mp);\\n        dfs2(root,0,mp);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```\\n# upvote if it\\'s help you HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    void dfs(TreeNode* root,ll depth, map<ll,ll>&mp){\\n        if(root == NULL) return;\\n        mp[depth] += root->val;\\n        dfs(root->left,depth+1,mp);\\n        dfs(root->right,depth+1,mp);\\n    }\\n    \\n    void dfs2(TreeNode* root,ll depth, map<ll,ll>&mp){\\n        if(root == NULL) return ;\\n        ll l = 0, r = 0;\\n        if(root->left) l = root->left->val;\\n        if(root->right) r = root->right->val;\\n        \\n        ll k = mp[depth+1] - l - r;\\n        // cout<<root->val<<\" \"<<l<<\" \"<<r<<\" \"<<k<<\" \"<<mp[depth+1]<<endl;\\n        if(root->left) root->left->val = k;\\n        if(root->right) root->right->val = k;\\n        \\n        \\n        dfs2(root->left,depth+1,mp);\\n        dfs2(root->right,depth+1,mp);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        map<ll,ll>mp;\\n        dfs(root,0,mp);\\n        dfs2(root,0,mp);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3420240,
                "title": "c-level-order-traversal",
                "content": "## Explanation\\nPerform level order traversal. Use hashmap to store the parent and its children at each level. Accumulate the sum of all node values in the level too using a variable. \\n\\nFor each node, assign value as `sumOfValues - currentNodeVal - siblingNodeVal`. Finally make the root value as 0 too.\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root) return root;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int s = q.size();\\n            long long sum = 0;\\n            unordered_map <TreeNode*,pair<TreeNode*,TreeNode*>> mp;\\n            for(int i = 0 ; i < s ; i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                if(node->left){\\n                    mp[node].first = node->left;\\n                    sum += node->left->val;\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    mp[node].second = node->right;\\n                    sum += node->right->val;\\n                    q.push(node->right);\\n                }\\n            }\\n\\n            for(auto &[k,v] : mp){\\n                int f = (v.first == nullptr) ? 0 : v.first->val , s = ( v.second == nullptr ) ? 0 : v.second->val;\\n                if(v.first) v.first->val = sum-f-s;\\n                if(v.second) v.second->val = sum-f-s;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n\\n```\\n\\n## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root) return root;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int s = q.size();\\n            long long sum = 0;\\n            unordered_map <TreeNode*,pair<TreeNode*,TreeNode*>> mp;\\n            for(int i = 0 ; i < s ; i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                \\n                if(node->left){\\n                    mp[node].first = node->left;\\n                    sum += node->left->val;\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    mp[node].second = node->right;\\n                    sum += node->right->val;\\n                    q.push(node->right);\\n                }\\n            }\\n\\n            for(auto &[k,v] : mp){\\n                int f = (v.first == nullptr) ? 0 : v.first->val , s = ( v.second == nullptr ) ? 0 : v.second->val;\\n                if(v.first) v.first->val = sum-f-s;\\n                if(v.second) v.second->val = sum-f-s;\\n            }\\n        }\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420192,
                "title": "level-order-traversing",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector< pair<TreeNode*, int > > arr;\\n        arr.push_back({root, 0});\\n        root->val = 0;\\n        while(arr.size() != 0) {\\n            vector< pair<TreeNode*, int > > x;\\n            int sum = 0;\\n            for(auto i : arr) {\\n                int left = 0, right = 0;\\n                if(i.first -> left != NULL) {\\n                    left = i.first ->left -> val;\\n                    sum += left;\\n                }\\n                if(i.first -> right != NULL) {\\n                    right = i.first ->right -> val;\\n                    sum += right;\\n                }\\n                if(i.first -> left != NULL) {\\n                    x.push_back({i.first ->left, right});\\n                }\\n                if(i.first -> right != NULL) {\\n                    x.push_back({i.first ->right, left});\\n                }\\n            }\\n            for(auto i : x) {\\n                i.first->val = sum - i.second - i.first->val;\\n            }\\n            arr = x;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector< pair<TreeNode*, int > > arr;\\n        arr.push_back({root, 0});\\n        root->val = 0;\\n        while(arr.size() != 0) {\\n            vector< pair<TreeNode*, int > > x;\\n            int sum = 0;\\n            for(auto i : arr) {\\n                int left = 0, right = 0;\\n                if(i.first -> left != NULL) {\\n                    left = i.first ->left -> val;\\n                    sum += left;\\n                }\\n                if(i.first -> right != NULL) {\\n                    right = i.first ->right -> val;\\n                    sum += right;\\n                }\\n                if(i.first -> left != NULL) {\\n                    x.push_back({i.first ->left, right});\\n                }\\n                if(i.first -> right != NULL) {\\n                    x.push_back({i.first ->right, left});\\n                }\\n            }\\n            for(auto i : x) {\\n                i.first->val = sum - i.second - i.first->val;\\n            }\\n            arr = x;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420191,
                "title": "python3-solution",
                "content": "\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        sumLevels = list()\\n        sumLevels.append(dict())\\n        sumLevels[-1][None] = 0\\n        totalLevels = list()\\n        totalLevels.append(0)\\n        \\n        def calculateLevelSum(root, level, parent):\\n            if not root:\\n                return\\n            \\n            if parent in sumLevels[level-1]:\\n                sumLevels[level-1][parent] += root.val\\n            \\n            if len(totalLevels) < level + 1:\\n                totalLevels.append(0)\\n            \\n            totalLevels[level] += root.val\\n            \\n            if len(sumLevels) < level + 1:\\n                sumLevels.append(dict())\\n            \\n            sumLevels[level][root] = 0\\n            \\n            calculateLevelSum(root.left, level+1, root)\\n            calculateLevelSum(root.right, level+1, root)\\n        \\n        calculateLevelSum(root, 1, None)\\n        \\n        def reassignValues(root, level, parent):\\n            if not root:\\n                return\\n            \\n            curValue = totalLevels[level] - sumLevels[level-1][parent]\\n\\n            root.val = curValue\\n            reassignValues(root.left, level+1, root)\\n            reassignValues(root.right, level+1, root)\\n            \\n        reassignValues(root, 1, None)\\n        return root\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        sumLevels = list()\\n        sumLevels.append(dict())\\n        sumLevels[-1][None] = 0\\n        totalLevels = list()\\n        totalLevels.append(0)\\n        \\n        def calculateLevelSum(root, level, parent):\\n            if not root:\\n                return\\n            \\n            if parent in sumLevels[level-1]:\\n                sumLevels[level-1][parent] += root.val\\n            \\n            if len(totalLevels) < level + 1:\\n                totalLevels.append(0)\\n            \\n            totalLevels[level] += root.val\\n            \\n            if len(sumLevels) < level + 1:\\n                sumLevels.append(dict())\\n            \\n            sumLevels[level][root] = 0\\n            \\n            calculateLevelSum(root.left, level+1, root)\\n            calculateLevelSum(root.right, level+1, root)\\n        \\n        calculateLevelSum(root, 1, None)\\n        \\n        def reassignValues(root, level, parent):\\n            if not root:\\n                return\\n            \\n            curValue = totalLevels[level] - sumLevels[level-1][parent]\\n\\n            root.val = curValue\\n            reassignValues(root.left, level+1, root)\\n            reassignValues(root.right, level+1, root)\\n            \\n        reassignValues(root, 1, None)\\n        return root\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420179,
                "title": "easy-c-solution-using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        //pushing NULL after every siblings\\n        q.push(root);\\n        q.push(NULL);\\n        \\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            vector<int> v;\\n            //made copy queue for changing values\\n            queue<TreeNode*> q1(q);\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                //if NULL then we push 0 to separate the cousins\\n                if(temp == NULL)\\n                {\\n                    v.push_back(0);\\n                }\\n                else\\n                {\\n                    if(temp->left)\\n                    {\\n                        q.push(temp->left);\\n                    }\\n                    if(temp->right)\\n                    {\\n                        q.push(temp->right);\\n                    }\\n                    //pushing NULL after every siblings ( NOT COUSINS )\\n                    q.push(NULL);\\n                    v.push_back(temp->val);\\n                }\\n            }\\n            \\n            int sum = 0;\\n            int count = 0;\\n            // summing whole one level of tree and counting number of 0\\'s\\n            for(int i = 0; i < v.size(); i++)\\n            {\\n                sum = sum + v[i];\\n                if(v[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            // if count is 0 then it means it is level 1 and 2 so make all nodes 0 using temp queue we kept\\n            if(count == 1)\\n            {\\n                while(!q1.empty())\\n                {\\n                    TreeNode* temp = q1.front();\\n                    if(temp)\\n                    {\\n                        temp->val = 0;\\n                    }\\n                    q1.pop();\\n                }\\n            }\\n            //if count > 1 means other levels then\\n            else if(count > 1)\\n            {\\n                for(int i = 0; i < v.size();)\\n                {\\n                    // we remove siblings from sum and make them equal to that new sum ( sum of all cousins )\\n                    if(v[i] == 0)\\n                    {\\n                        i++;\\n                    }\\n                    else if(i+1 < v.size() && v[i] && v[i+1])\\n                    {\\n                        v[i] = sum-v[i]-v[i+1];\\n                        v[i+1] = v[i];\\n                        i = i + 2;\\n                    }\\n                    else if(i+1 < v.size() && v[i] && !v[i+1])\\n                    {\\n                        v[i] = sum-v[i];\\n                        i++;\\n                    }\\n                }\\n                int i = 0;\\n                while(!q1.empty())\\n                {\\n                    // assigning sum to all nodes\\n                    TreeNode* temp = q1.front();\\n                    if(temp)\\n                    {\\n                        temp->val = v[i];\\n                    }\\n                    i++;\\n                    q1.pop();\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> q;\\n        //pushing NULL after every siblings\\n        q.push(root);\\n        q.push(NULL);\\n        \\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            vector<int> v;\\n            //made copy queue for changing values\\n            queue<TreeNode*> q1(q);\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                //if NULL then we push 0 to separate the cousins\\n                if(temp == NULL)\\n                {\\n                    v.push_back(0);\\n                }\\n                else\\n                {\\n                    if(temp->left)\\n                    {\\n                        q.push(temp->left);\\n                    }\\n                    if(temp->right)\\n                    {\\n                        q.push(temp->right);\\n                    }\\n                    //pushing NULL after every siblings ( NOT COUSINS )\\n                    q.push(NULL);\\n                    v.push_back(temp->val);\\n                }\\n            }\\n            \\n            int sum = 0;\\n            int count = 0;\\n            // summing whole one level of tree and counting number of 0\\'s\\n            for(int i = 0; i < v.size(); i++)\\n            {\\n                sum = sum + v[i];\\n                if(v[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            // if count is 0 then it means it is level 1 and 2 so make all nodes 0 using temp queue we kept\\n            if(count == 1)\\n            {\\n                while(!q1.empty())\\n                {\\n                    TreeNode* temp = q1.front();\\n                    if(temp)\\n                    {\\n                        temp->val = 0;\\n                    }\\n                    q1.pop();\\n                }\\n            }\\n            //if count > 1 means other levels then\\n            else if(count > 1)\\n            {\\n                for(int i = 0; i < v.size();)\\n                {\\n                    // we remove siblings from sum and make them equal to that new sum ( sum of all cousins )\\n                    if(v[i] == 0)\\n                    {\\n                        i++;\\n                    }\\n                    else if(i+1 < v.size() && v[i] && v[i+1])\\n                    {\\n                        v[i] = sum-v[i]-v[i+1];\\n                        v[i+1] = v[i];\\n                        i = i + 2;\\n                    }\\n                    else if(i+1 < v.size() && v[i] && !v[i+1])\\n                    {\\n                        v[i] = sum-v[i];\\n                        i++;\\n                    }\\n                }\\n                int i = 0;\\n                while(!q1.empty())\\n                {\\n                    // assigning sum to all nodes\\n                    TreeNode* temp = q1.front();\\n                    if(temp)\\n                    {\\n                        temp->val = v[i];\\n                    }\\n                    i++;\\n                    q1.pop();\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420086,
                "title": "easy-bfs-java-solution-using-2-queue",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root == null) return root;\\n        TreeNode res = new TreeNode(0);\\n        Queue<TreeNode> resq = new LinkedList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        resq.offer(res);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            TreeNode[] t = new TreeNode[size];\\n            int sum = 0;\\n            for(int i = 0; i<size; i++){\\n                t[i] = q.poll();\\n                if(t[i].left != null){\\n                    q.offer(t[i].left);\\n                    sum += t[i].left.val;\\n                }\\n                if(t[i].right != null){\\n                    q.offer(t[i].right);\\n                    sum += t[i].right.val;\\n                }\\n            }\\n            for(int i = 0; i<size; i++){\\n                TreeNode curr = resq.poll();\\n                int cusins = sum - (t[i].left != null ? t[i].left.val : 0) - (t[i].right != null ? t[i].right.val : 0);\\n                if(t[i].left != null){\\n                    curr.left = new TreeNode(cusins);\\n                    resq.offer(curr.left);\\n                }\\n                if(t[i].right != null){\\n                    curr.right = new TreeNode(cusins);\\n                    resq.offer(curr.right);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root == null) return root;\\n        TreeNode res = new TreeNode(0);\\n        Queue<TreeNode> resq = new LinkedList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        resq.offer(res);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            TreeNode[] t = new TreeNode[size];\\n            int sum = 0;\\n            for(int i = 0; i<size; i++){\\n                t[i] = q.poll();\\n                if(t[i].left != null){\\n                    q.offer(t[i].left);\\n                    sum += t[i].left.val;\\n                }\\n                if(t[i].right != null){\\n                    q.offer(t[i].right);\\n                    sum += t[i].right.val;\\n                }\\n            }\\n            for(int i = 0; i<size; i++){\\n                TreeNode curr = resq.poll();\\n                int cusins = sum - (t[i].left != null ? t[i].left.val : 0) - (t[i].right != null ? t[i].right.val : 0);\\n                if(t[i].left != null){\\n                    curr.left = new TreeNode(cusins);\\n                    resq.offer(curr.left);\\n                }\\n                if(t[i].right != null){\\n                    curr.right = new TreeNode(cusins);\\n                    resq.offer(curr.right);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420019,
                "title": "c-bfs-using-mapping-of-parent",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*,TreeNode*>> q;\\n        q.push({root,nullptr});\\n        while(q.size()){\\n            long long sz = q.size();\\n            vector<pair<TreeNode*,TreeNode*>> arr;\\n            unordered_map<TreeNode*,long long> mp;\\n            long long sum = 0; \\n            for(int i=0;i<sz;i++){\\n                auto xx = q.front();\\n                auto x = xx.first;\\n                if(xx.second!=nullptr)\\n                    mp[xx.second] += x->val;\\n                sum += x->val;\\n                arr.push_back(xx);\\n                q.pop();\\n                if(x->left) q.push({x->left,x});\\n                if(x->right) q.push({x->right,x});\\n            }\\n            for(int i=0;i<arr.size();i++){\\n                arr[i].first->val = (sum - mp[arr[i].second]);\\n            }\\n            if(sz == 1) arr[0].first->val = 0;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*,TreeNode*>> q;\\n        q.push({root,nullptr});\\n        while(q.size()){\\n            long long sz = q.size();\\n            vector<pair<TreeNode*,TreeNode*>> arr;\\n            unordered_map<TreeNode*,long long> mp;\\n            long long sum = 0; \\n            for(int i=0;i<sz;i++){\\n                auto xx = q.front();\\n                auto x = xx.first;\\n                if(xx.second!=nullptr)\\n                    mp[xx.second] += x->val;\\n                sum += x->val;\\n                arr.push_back(xx);\\n                q.pop();\\n                if(x->left) q.push({x->left,x});\\n                if(x->right) q.push({x->right,x});\\n            }\\n            for(int i=0;i<arr.size();i++){\\n                arr[i].first->val = (sum - mp[arr[i].second]);\\n            }\\n            if(sz == 1) arr[0].first->val = 0;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420010,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution{\\n    typedef TreeNode tn;\\npublic:\\n    void bfs(tn*rt){\\n        rt->val=0;\\n        list<tn*>l={rt}; // transformed parents\\n        while(!l.empty()){\\n            int sum=0; // sum of the values of all the nodes at the next depth level\\n            for(tn* par : l){\\n                if(par->left){\\n                    sum+=par->left->val;\\n                }\\n                if(par->right){\\n                    sum+=par->right->val;\\n                }\\n            }\\n            int sz=l.size();\\n            while(sz--){\\n                tn* par = l.front();\\n                l.pop_front();\\n                int lc = (par->left ? par->left->val : 0),\\n                    rc = (par->right ? par->right->val : 0);\\n                if(par->left){\\n                    par->left->val=sum-lc-rc;\\n                    l.push_back(par->left);\\n                }\\n                if(par->right){\\n                    par->right->val=sum-lc-rc;\\n                    l.push_back(par->right);\\n                }\\n            }\\n        }\\n    }\\n    tn* replaceValueInTree(tn* root) {\\n        bfs(root);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution{\\n    typedef TreeNode tn;\\npublic:\\n    void bfs(tn*rt){\\n        rt->val=0;\\n        list<tn*>l={rt}; // transformed parents\\n        while(!l.empty()){\\n            int sum=0; // sum of the values of all the nodes at the next depth level\\n            for(tn* par : l){\\n                if(par->left){\\n                    sum+=par->left->val;\\n                }\\n                if(par->right){\\n                    sum+=par->right->val;\\n                }\\n            }\\n            int sz=l.size();\\n            while(sz--){\\n                tn* par = l.front();\\n                l.pop_front();\\n                int lc = (par->left ? par->left->val : 0),\\n                    rc = (par->right ? par->right->val : 0);\\n                if(par->left){\\n                    par->left->val=sum-lc-rc;\\n                    l.push_back(par->left);\\n                }\\n                if(par->right){\\n                    par->right->val=sum-lc-rc;\\n                    l.push_back(par->right);\\n                }\\n            }\\n        }\\n    }\\n    tn* replaceValueInTree(tn* root) {\\n        bfs(root);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419989,
                "title": "java-c-simple-solution-dfs-hashmap",
                "content": "\\n``` java []\\nclass Solution {\\n    Map<Integer,Integer> map;\\n    Map<TreeNode,Integer> map2;\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        map = new HashMap<>();\\n        map2 = new HashMap<>();\\n        dfs(root, null, 0);\\n        fillSum(root, null, 0);\\n        return root;\\n    }\\n    \\n    private void dfs(TreeNode root,TreeNode parent,int c){\\n        if(root==null){\\n            return;\\n        }\\n        if(parent!=null){\\n           map2.put(parent,map2.getOrDefault(parent,0)+root.val);\\n           map.put(c,map.getOrDefault(c,0)+root.val);\\n        }\\n        dfs(root.left,root,c+1);\\n        dfs(root.right,root,c+1);\\n    }\\n\\n    private void fillSum(TreeNode root,TreeNode parent,int c){\\n        if(root==null){\\n            return;\\n        }\\n        root.val = parent==null? 0: (map.get(c)-map2.get(parent));\\n        fillSum(root.left,root,c+1);\\n        fillSum(root.right,root,c+1);\\n    }\\n}\\n```\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    unordered_map<int,int> depthSumMap;\\n    unordered_map<TreeNode*,int> cousinSumMap;\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       dfs(root,NULL, 0);\\n       fillSum(root,NULL,0);\\n       return root;\\n    }\\n    \\n    void dfs(TreeNode* root, TreeNode* parent, int depth){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(parent!=NULL){\\n            cousinSumMap[parent] += root->val;\\n            depthSumMap[depth] += root->val;\\n        }\\n        dfs(root->left,root,depth+1);\\n        dfs(root->right,root,depth+1);\\n    }\\n    \\n    void fillSum(TreeNode* root, TreeNode* parent, int depth){\\n        if(root==NULL){\\n            return;\\n        }\\n        root->val = parent==NULL? 0 :(depthSumMap[depth] - cousinSumMap[parent]);\\n        fillSum(root->left,root,depth+1);\\n        fillSum(root->right,root,depth+1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search"
                ],
                "code": "``` java []\\nclass Solution {\\n    Map<Integer,Integer> map;\\n    Map<TreeNode,Integer> map2;\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        map = new HashMap<>();\\n        map2 = new HashMap<>();\\n        dfs(root, null, 0);\\n        fillSum(root, null, 0);\\n        return root;\\n    }\\n    \\n    private void dfs(TreeNode root,TreeNode parent,int c){\\n        if(root==null){\\n            return;\\n        }\\n        if(parent!=null){\\n           map2.put(parent,map2.getOrDefault(parent,0)+root.val);\\n           map.put(c,map.getOrDefault(c,0)+root.val);\\n        }\\n        dfs(root.left,root,c+1);\\n        dfs(root.right,root,c+1);\\n    }\\n\\n    private void fillSum(TreeNode root,TreeNode parent,int c){\\n        if(root==null){\\n            return;\\n        }\\n        root.val = parent==null? 0: (map.get(c)-map2.get(parent));\\n        fillSum(root.left,root,c+1);\\n        fillSum(root.right,root,c+1);\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    unordered_map<int,int> depthSumMap;\\n    unordered_map<TreeNode*,int> cousinSumMap;\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       dfs(root,NULL, 0);\\n       fillSum(root,NULL,0);\\n       return root;\\n    }\\n    \\n    void dfs(TreeNode* root, TreeNode* parent, int depth){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(parent!=NULL){\\n            cousinSumMap[parent] += root->val;\\n            depthSumMap[depth] += root->val;\\n        }\\n        dfs(root->left,root,depth+1);\\n        dfs(root->right,root,depth+1);\\n    }\\n    \\n    void fillSum(TreeNode* root, TreeNode* parent, int depth){\\n        if(root==NULL){\\n            return;\\n        }\\n        root->val = parent==NULL? 0 :(depthSumMap[depth] - cousinSumMap[parent]);\\n        fillSum(root->left,root,depth+1);\\n        fillSum(root->right,root,depth+1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419981,
                "title": "c-explained",
                "content": "\\t// Firstly find and store the level wise sum of all nodes in the sum array (use level order traversal for this).\\n\\n\\t// Secondly do preorder traversal and subtract the left and right sibling value (which are from same parent) from the sum of that current level values \\n\\t// and replace the values of these two nodes with these levelSum - leftChild - rightChild.\\n\\n\\t// Finally for 0th level and 1st level value of nodes will always remain zero.\\n\\n\\tclass Solution {\\n\\t\\n\\t\\tpublic:\\n\\n\\t\\tvoid levelorder(TreeNode* root,vector<int> &sum)\\n\\t\\t{\\n\\t\\t\\tqueue<TreeNode*> q;\\n\\t\\t\\tq.push(root);\\n\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint levelSum=0;\\n\\t\\t\\t\\tint size=q.size();\\n\\n\\t\\t\\t\\tfor(int i=0;i<size;i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tauto node = q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\t\\tlevelSum += node->val;\\n\\n\\t\\t\\t\\t\\tif(node->left)\\n\\t\\t\\t\\t\\t\\tq.push(node->left);\\n\\t\\t\\t\\t\\tif(node->right)\\n\\t\\t\\t\\t\\t\\tq.push(node->right);\\n\\t\\t\\t\\t}            \\n\\t\\t\\t\\tsum.push_back(levelSum);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid preorder(TreeNode* root,int level,vector<int> &sum)\\n\\t\\t{\\n\\t\\t\\tif(!root)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tint leftVal=-1,rightVal=-1;\\n\\n\\t\\t\\tif(level!=0 && root->left)\\n\\t\\t\\t\\tleftVal = root->left->val;\\n\\n\\t\\t\\tif(level!=0 && root->right)\\n\\t\\t\\t\\trightVal = root->right->val;    \\n\\n\\t\\t\\tif(level+1<sum.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint val = sum[level+1];\\n\\t\\t\\t\\tif(leftVal!=-1)\\n\\t\\t\\t\\t\\tval -= leftVal;\\n\\t\\t\\t\\tif(rightVal!=-1)\\n\\t\\t\\t\\t\\tval -= rightVal;\\n\\n\\t\\t\\t\\tif(root->left)\\n\\t\\t\\t\\t\\troot->left->val = val;\\n\\n\\t\\t\\t\\tif(root->right)\\n\\t\\t\\t\\t\\troot->right->val = val;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpreorder(root->left,level+1,sum);\\n\\t\\t\\tpreorder(root->right,level+1,sum);\\n\\t\\t}\\n\\n\\t\\tTreeNode* replaceValueInTree(TreeNode* root) {\\n\\n\\t\\t\\tvector<int> sum;\\n\\n\\t\\t\\tlevelorder(root,sum);\\n\\t\\t\\tpreorder(root,0,sum);\\n\\n\\t\\t\\troot->val = 0;                          // Root node and its child Nodes will always remain zero\\n\\t\\t\\tif(root->left)\\n\\t\\t\\t\\troot->left->val=0;\\n\\n\\t\\t\\tif(root->right)\\n\\t\\t\\t\\troot->right->val=0;\\n\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t \\n\\t };",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\n\\t\\tpublic:\\n\\n\\t\\tvoid levelorder(TreeNode* root,vector<int> &sum)\\n\\t\\t{\\n\\t\\t\\tqueue<TreeNode*> q;\\n\\t\\t\\tq.push(root);\\n\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint levelSum=0;\\n\\t\\t\\t\\tint size=q.size();\\n\\n\\t\\t\\t\\tfor(int i=0;i<size;i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tauto node = q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\t\\tlevelSum += node->val;\\n\\n\\t\\t\\t\\t\\tif(node->left)\\n\\t\\t\\t\\t\\t\\tq.push(node->left);\\n\\t\\t\\t\\t\\tif(node->right)\\n\\t\\t\\t\\t\\t\\tq.push(node->right);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3419968,
                "title": "depth-sum-minus-parent-sum",
                "content": "A cousin by definition has the same depth of the node and also a different parent. So we can calculate the sum of each level of the tree, as well as the sum of each parent\\'s children. Then the sum of all non-cousins is the sum of the entire level of the tree minus the sum of the node\\'s parent\\'s children. We can do this easily in two traversals, one to calculate depth and parent sums, and one to set the values to the correct answer.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    long long v[100001] = {};\\n    map<TreeNode*, long long> par;\\n    void trav(TreeNode* root, int h, int& id, TreeNode* last){\\n        if(root == nullptr) return;\\n        v[h] += root->val;\\n        if(last != nullptr) par[last] += root->val;\\n        trav(root->left, h+1, id, root);\\n        trav(root->right, h+1, id, root);\\n    }\\n    void fix(TreeNode* root, int h, int& id, TreeNode* last){\\n        if(root == nullptr) return;\\n        if(last == nullptr) root->val = 0;\\n        else root->val = v[h]-par[last];\\n        fix(root->left, h+1, root);\\n        fix(root->right, h+1, root);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        trav(root, 1, nullptr);\\n        fix(root, 1, nullptr);\\n        return root;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long v[100001] = {}",
                "codeTag": "Java"
            },
            {
                "id": 4080973,
                "title": "simple-bfs-simple-solution",
                "content": "# Intuition\\nSolved it using BFS. Calculated the sum of all all node keys at each individual level and then subtracted from the sum of the node keys of a particular parent and assigned that value to its children nodes. Easy and Simple to understand.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int sum=0;\\n            queue<TreeNode*>parent;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                parent.push(temp);\\n                if(temp->left!=NULL)\\n                {\\n                    q.push(temp->left);\\n                    sum+=temp->left->val;\\n                }\\n                if(temp->right!=NULL)\\n                {\\n                    q.push(temp->right);\\n                    sum+=temp->right->val;\\n                }\\n            }\\n                while(!parent.empty())\\n                {\\n                    TreeNode* lul=parent.front();\\n                    parent.pop();\\n                    int nv=0;\\n                    if(lul->left!=NULL)\\n                    {\\n                        nv+=lul->left->val;\\n                    }\\n                    if(lul->right!=NULL)\\n                    {\\n                        nv+=lul->right->val;\\n                    }\\n                    if(lul->left!=NULL)\\n                        lul->left->val=sum-nv;\\n                    if(lul->right!=NULL)\\n                        lul->right->val=sum-nv;\\n                }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int sum=0;\\n            queue<TreeNode*>parent;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                parent.push(temp);\\n                if(temp->left!=NULL)\\n                {\\n                    q.push(temp->left);\\n                    sum+=temp->left->val;\\n                }\\n                if(temp->right!=NULL)\\n                {\\n                    q.push(temp->right);\\n                    sum+=temp->right->val;\\n                }\\n            }\\n                while(!parent.empty())\\n                {\\n                    TreeNode* lul=parent.front();\\n                    parent.pop();\\n                    int nv=0;\\n                    if(lul->left!=NULL)\\n                    {\\n                        nv+=lul->left->val;\\n                    }\\n                    if(lul->right!=NULL)\\n                    {\\n                        nv+=lul->right->val;\\n                    }\\n                    if(lul->left!=NULL)\\n                        lul->left->val=sum-nv;\\n                    if(lul->right!=NULL)\\n                        lul->right->val=sum-nv;\\n                }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067854,
                "title": "using-2-dfs-with-o-n-run-time-and-space-complexity",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_somme=defaultdict(int)\\n        def levelSomme(root,depth):\\n            if not root:\\n                return\\n            level_somme[depth]+=root.val\\n            levelSomme(root.left,depth+1)\\n            levelSomme(root.right,depth+1)\\n\\n        def dfs(root,depth,sib):\\n            if not root:\\n                return\\n            root.val=level_somme[depth]-root.val-sib\\n            left_val=root.left.val if root.left else 0\\n            right_val=root.right.val if root.right else 0\\n\\n            dfs(root.left,depth+1,right_val)\\n            dfs(root.right,depth+1,left_val)\\n\\n        levelSomme(root,0)\\n        dfs(root,0,0)\\n        return root\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_somme=defaultdict(int)\\n        def levelSomme(root,depth):\\n            if not root:\\n                return\\n            level_somme[depth]+=root.val\\n            levelSomme(root.left,depth+1)\\n            levelSomme(root.right,depth+1)\\n\\n        def dfs(root,depth,sib):\\n            if not root:\\n                return\\n            root.val=level_somme[depth]-root.val-sib\\n            left_val=root.left.val if root.left else 0\\n            right_val=root.right.val if root.right else 0\\n\\n            dfs(root.left,depth+1,right_val)\\n            dfs(root.right,depth+1,left_val)\\n\\n        levelSomme(root,0)\\n        dfs(root,0,0)\\n        return root\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061254,
                "title": "c-solution-using-map",
                "content": "class Solution {\\npublic:\\n    void levelSum(TreeNode* root,int level,map<int,int>&mp){\\n        if(!root)return;\\n        mp[level]+=root->val;\\n        levelSum(root->left,level+1,mp);\\n        levelSum(root->right,level+1,mp);\\n    }\\n    void solve(TreeNode* root,int level,map<int,int>&mp){\\n        if(!root)return;\\n        if(root->left and root->right){\\n        root->left->val=mp[level+1]-root->left->val-root->right->val;\\n        root->right->val=root->left->val;\\n        }\\n         if(root->left and !root->right)\\n        root->left->val=mp[level+1]-root->left->val;\\n         if(!root->left and root->right)\\n        root->right->val=mp[level+1]-root->right->val;\\n        solve(root->left,level+1,mp);\\n        solve(root->right,level+1,mp);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root)return NULL;\\n        map<int,int>mp;\\n        levelSum(root,0,mp);\\n        solve(root,0,mp);\\n        root->val=0;\\n        return root;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void levelSum(TreeNode* root,int level,map<int,int>&mp){\\n        if(!root)return;\\n        mp[level]+=root->val;\\n        levelSum(root->left,level+1,mp);\\n        levelSum(root->right,level+1,mp);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4032291,
                "title": "o-n-level-order-traversal-optimized-solution-by-anurag",
                "content": "# Intuition\\nThe goal is to replace the value of each node in the binary tree with the sum of its cousins\\' values. Cousins are nodes at the same depth but with different parents. We can use a level-order traversal (BFS) to compute the sum of cousins for each node in the tree and update their values accordingly.\\n\\n# Approach\\n1.Initialize a queue for level-order traversal, a map to store the sum of cousins for each node at the current level, and a variable to keep track of the sum of cousins.\\n\\n2.Start with the root node and push it into the queue.\\n\\n3.While the queue is not empty, process each level:\\n\\na. For each node at the current level, calculate the sum of its left and right children\\'s values and update the map.\\n\\nb. Update the value of the current node with the sum of its cousins.\\n\\nc. If the current node has left and right children, adjust their values accordingly.\\n\\nd. Push the left and right children of the current node into the queue for the next level.\\n\\n4.Continue this process until all levels have been processed.\\n\\n5.Return the modified root node.\\n\\n# Complexity\\n- Time complexity:O(N),Visiting each node in BFS.\\n\\n- Space complexity:O(M),Where M is the maximum number of nodes at any level (Worse case space complexity).\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  TreeNode* replaceValueInTree(TreeNode* root) {\\n    queue<TreeNode*>q;\\n    TreeNode*dummy=root;\\n    root->val=0;\\n    q.push(dummy);\\n    while(q.size()){\\n        queue<TreeNode*>temp;\\n        map<TreeNode*,int>m;\\n        while(q.size()){\\n            if(q.front()->left){\\n                temp.push(q.front()->left);\\n                m[q.front()]+=q.front()->left->val;\\n            }\\n             if(q.front()->right){\\n                temp.push(q.front()->right);\\n                m[q.front()]+=q.front()->right->val;\\n            }\\n            q.pop();\\n        }\\n        int sum=0;\\n        map<TreeNode*,int> ::iterator i;\\n        for(i=m.begin();i!=m.end();i++){\\n            sum+=(*i).second;\\n        }\\n       \\n        for(i=m.begin();i!=m.end();i++){\\n            int temp2=0;\\n            if((*i).first->left){\\n                temp2+=(*i).first->left->val;\\n            }\\n            if((*i).first->right){\\n                temp2+=(*i).first->right->val;\\n            }\\n            temp2=sum-temp2;\\n            if((*i).first->left){\\n                (*i).first->left->val=temp2;\\n            }\\n            if((*i).first->right){\\n                (*i).first->right->val=temp2;\\n            }\\n            q=temp;\\n        }\\n    }\\n    return root;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  TreeNode* replaceValueInTree(TreeNode* root) {\\n    queue<TreeNode*>q;\\n    TreeNode*dummy=root;\\n    root->val=0;\\n    q.push(dummy);\\n    while(q.size()){\\n        queue<TreeNode*>temp;\\n        map<TreeNode*,int>m;\\n        while(q.size()){\\n            if(q.front()->left){\\n                temp.push(q.front()->left);\\n                m[q.front()]+=q.front()->left->val;\\n            }\\n             if(q.front()->right){\\n                temp.push(q.front()->right);\\n                m[q.front()]+=q.front()->right->val;\\n            }\\n            q.pop();\\n        }\\n        int sum=0;\\n        map<TreeNode*,int> ::iterator i;\\n        for(i=m.begin();i!=m.end();i++){\\n            sum+=(*i).second;\\n        }\\n       \\n        for(i=m.begin();i!=m.end();i++){\\n            int temp2=0;\\n            if((*i).first->left){\\n                temp2+=(*i).first->left->val;\\n            }\\n            if((*i).first->right){\\n                temp2+=(*i).first->right->val;\\n            }\\n            temp2=sum-temp2;\\n            if((*i).first->left){\\n                (*i).first->left->val=temp2;\\n            }\\n            if((*i).first->right){\\n                (*i).first->right->val=temp2;\\n            }\\n            q=temp;\\n        }\\n    }\\n    return root;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998816,
                "title": "two-solutions-bfs-and-dfs",
                "content": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [root]\\n        root.val = 0\\n        while queue:\\n            dic_sum_children, new_queue, sum_level = {}, [], 0\\n            for node in queue:\\n                old_sum_level = sum_level\\n                if node.left:\\n                    sum_level += node.left.val\\n                if node.right:\\n                    sum_level += node.right.val        \\n                dic_sum_children[node] = sum_level - old_sum_level\\n            for node in queue:\\n                sum_chidren = dic_sum_children[node]  \\n                if node.left:\\n                    node.left.val = sum_level - sum_chidren\\n                    new_queue.append(node.left)\\n                if node.right:\\n                    node.right.val = sum_level - sum_chidren\\n                    new_queue.append(node.right)\\n            queue = new_queue\\n        return root\\n```\\n```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        return self.replase_val(root, TreeNode(left= root), 0, self.sum_level(root, 0 ,[]))\\n\\n    def sum_level(self, root, depth, list_sum):\\n        if not root:\\n            return list_sum\\n        if depth == len(list_sum):\\n            list_sum.append(root.val)\\n        else:\\n            list_sum[depth] += root.val\\n        self.sum_level(root.left, depth+1, list_sum)\\n        self.sum_level(root.right, depth+1, list_sum)\\n        return list_sum\\n\\n    def replase_val(self, root, parent, depth, list_sum):\\n        if not root:\\n            return None\\n        if parent.left and parent.left is root:  \\n            if parent.right:     \\n                root.val = parent.right.val = list_sum[depth]-root.val-parent.right.val  \\n            else: \\n                root.val = list_sum[depth]-root.val\\n        elif not parent.left:\\n            root.val = list_sum[depth]-root.val\\n        self.replase_val(root.left, root, depth+1, list_sum)\\n        self.replase_val(root.right, root, depth+1, list_sum)\\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Recursion",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [root]\\n        root.val = 0\\n        while queue:\\n            dic_sum_children, new_queue, sum_level = {}, [], 0\\n            for node in queue:\\n                old_sum_level = sum_level\\n                if node.left:\\n                    sum_level += node.left.val\\n                if node.right:\\n                    sum_level += node.right.val        \\n                dic_sum_children[node] = sum_level - old_sum_level\\n            for node in queue:\\n                sum_chidren = dic_sum_children[node]  \\n                if node.left:\\n                    node.left.val = sum_level - sum_chidren\\n                    new_queue.append(node.left)\\n                if node.right:\\n                    node.right.val = sum_level - sum_chidren\\n                    new_queue.append(node.right)\\n            queue = new_queue\\n        return root\\n```\n```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        return self.replase_val(root, TreeNode(left= root), 0, self.sum_level(root, 0 ,[]))\\n\\n    def sum_level(self, root, depth, list_sum):\\n        if not root:\\n            return list_sum\\n        if depth == len(list_sum):\\n            list_sum.append(root.val)\\n        else:\\n            list_sum[depth] += root.val\\n        self.sum_level(root.left, depth+1, list_sum)\\n        self.sum_level(root.right, depth+1, list_sum)\\n        return list_sum\\n\\n    def replase_val(self, root, parent, depth, list_sum):\\n        if not root:\\n            return None\\n        if parent.left and parent.left is root:  \\n            if parent.right:     \\n                root.val = parent.right.val = list_sum[depth]-root.val-parent.right.val  \\n            else: \\n                root.val = list_sum[depth]-root.val\\n        elif not parent.left:\\n            root.val = list_sum[depth]-root.val\\n        self.replase_val(root.left, root, depth+1, list_sum)\\n        self.replase_val(root.right, root, depth+1, list_sum)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979218,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStore sum of node values of all heights in dictionary.\\nthen substract dictionary[height] - left-right.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(height)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        total, root.val = {}, 0\\n        def getSumOfHeights(node, height):\\n            if height not in total:\\n                total[height] = 0\\n            total[height] += node.val\\n            if node.left:\\n                getSumOfHeights(node.left, height+1)\\n            if node.right:\\n                getSumOfHeights(node.right, height+1)\\n        getSumOfHeights(root, 0)\\n        \\n        def helper(node,height):\\n            left,right = 0,0\\n            if node.left:\\n                helper(node.left,height+1)\\n                left = node.left.val\\n\\n            if node.right:\\n                helper(node.right,height+1)\\n                right = node.right.val\\n            if left+right != 0:\\n                if node.left:\\n                    node.left.val = total[height+1]-(left+right)\\n                if node.right:\\n                    node.right.val = total[height+1]-(left+right)\\n        helper(root,0)\\n        return root\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        total, root.val = {}, 0\\n        def getSumOfHeights(node, height):\\n            if height not in total:\\n                total[height] = 0\\n            total[height] += node.val\\n            if node.left:\\n                getSumOfHeights(node.left, height+1)\\n            if node.right:\\n                getSumOfHeights(node.right, height+1)\\n        getSumOfHeights(root, 0)\\n        \\n        def helper(node,height):\\n            left,right = 0,0\\n            if node.left:\\n                helper(node.left,height+1)\\n                left = node.left.val\\n\\n            if node.right:\\n                helper(node.right,height+1)\\n                right = node.right.val\\n            if left+right != 0:\\n                if node.left:\\n                    node.left.val = total[height+1]-(left+right)\\n                if node.right:\\n                    node.right.val = total[height+1]-(left+right)\\n        helper(root,0)\\n        return root\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976447,
                "title": "bfs-dfs",
                "content": "**bfs**\\n```\\nclass Solution \\n{\\n    void transform_tree(TreeNode* r)\\n    {\\n        vector<TreeNode*> v{r}, vv;\\n        for( ; !empty(v); )\\n        {\\n            int sum{};\\n            for(auto & v : v)\\n            {\\n                auto t = (v->left ? v->left->val : 0)+(v->right ? v->right->val : 0);\\n                if(v->left)  \\n                {\\n                    vv.push_back(v->left);\\n                    v->left->val = -t;\\n                }\\n                if(v->right) \\n                {\\n                    vv.push_back(v->right);\\n                    v->right->val = -t;\\n                }\\n                sum += t;\\n            }\\n            for(auto & v : v)\\n            {\\n                if(v->left)  v->left->val  += sum;\\n                if(v->right) v->right->val += sum;\\n            }\\n            v.clear();\\n            swap(v,vv);\\n        }\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* r)\\n    {\\n        r->val=0;\\n        transform_tree(r);\\n        return r;\\n    }\\n};\\n```\\n**dfs**\\n```\\nclass Solution \\n{\\n    unordered_map<int,int> m;\\n\\n    void make_sum(TreeNode* r, int d=0)\\n    {\\n        if(!r) return ;\\n        m[d]+=r->val;\\n        make_sum(r->left, d+1);\\n        make_sum(r->right, d+1);\\n    }\\n    void transform_tree(TreeNode* r, int d=0)\\n    {\\n        if(!r) return ;\\n        int t = (r->left ? r->left->val : 0)+(r->right ? r->right->val : 0);\\n        if(r->left)    \\n              r->left->val = m[d+1]-t;\\n        if(r->right)    \\n              r->right->val = m[d+1]-t;\\n        transform_tree(r->left, d+1);\\n        transform_tree(r->right, d+1);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* r)\\n    {\\n        make_sum(r);\\n        r->val=0;\\n        transform_tree(r);\\n        return r;\\n    }\\n```\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    void transform_tree(TreeNode* r)\\n    {\\n        vector<TreeNode*> v{r}, vv;\\n        for( ; !empty(v); )\\n        {\\n            int sum{};\\n            for(auto & v : v)\\n            {\\n                auto t = (v->left ? v->left->val : 0)+(v->right ? v->right->val : 0);\\n                if(v->left)  \\n                {\\n                    vv.push_back(v->left);\\n                    v->left->val = -t;\\n                }\\n                if(v->right) \\n                {\\n                    vv.push_back(v->right);\\n                    v->right->val = -t;\\n                }\\n                sum += t;\\n            }\\n            for(auto & v : v)\\n            {\\n                if(v->left)  v->left->val  += sum;\\n                if(v->right) v->right->val += sum;\\n            }\\n            v.clear();\\n            swap(v,vv);\\n        }\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* r)\\n    {\\n        r->val=0;\\n        transform_tree(r);\\n        return r;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\n    unordered_map<int,int> m;\\n\\n    void make_sum(TreeNode* r, int d=0)\\n    {\\n        if(!r) return ;\\n        m[d]+=r->val;\\n        make_sum(r->left, d+1);\\n        make_sum(r->right, d+1);\\n    }\\n    void transform_tree(TreeNode* r, int d=0)\\n    {\\n        if(!r) return ;\\n        int t = (r->left ? r->left->val : 0)+(r->right ? r->right->val : 0);\\n        if(r->left)    \\n              r->left->val = m[d+1]-t;\\n        if(r->right)    \\n              r->right->val = m[d+1]-t;\\n        transform_tree(r->left, d+1);\\n        transform_tree(r->right, d+1);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* r)\\n    {\\n        make_sum(r);\\n        r->val=0;\\n        transform_tree(r);\\n        return r;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953288,
                "title": "simple-bfs",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> temp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            int sum =0;\\n            for(int i=0;i<size;i++){\\n                sum+=(q.front()->val);\\n                TreeNode* node = q.front();\\n                if(node->left){\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n                q.pop();\\n            }\\n            temp.push_back(sum);\\n        }\\n         q.push(root);\\n        int level =0;\\n        root->val =0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(level==0){\\n                      if(node->left){\\n                    q.push(node->left);\\n                          node->left->val=0;\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                    node->right->val=0;\\n                }\\n                }\\n                else{\\n                    int sum =0;\\n                     if(node->left){\\n                    q.push(node->left);\\n                         sum+=(node->left->val);\\n                         \\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                   sum+=(node->right->val);\\n                }\\n                    if(node->left){\\n                        node->left->val = temp[level+1]-sum;\\n                    }\\n                    if(node->right){\\n                        node->right->val = temp[level+1]-sum;\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> temp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            int sum =0;\\n            for(int i=0;i<size;i++){\\n                sum+=(q.front()->val);\\n                TreeNode* node = q.front();\\n                if(node->left){\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n                q.pop();\\n            }\\n            temp.push_back(sum);\\n        }\\n         q.push(root);\\n        int level =0;\\n        root->val =0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode* node = q.front();\\n                q.pop();\\n                if(level==0){\\n                      if(node->left){\\n                    q.push(node->left);\\n                          node->left->val=0;\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                    node->right->val=0;\\n                }\\n                }\\n                else{\\n                    int sum =0;\\n                     if(node->left){\\n                    q.push(node->left);\\n                         sum+=(node->left->val);\\n                         \\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                   sum+=(node->right->val);\\n                }\\n                    if(node->left){\\n                        node->left->val = temp[level+1]-sum;\\n                    }\\n                    if(node->right){\\n                        node->right->val = temp[level+1]-sum;\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909119,
                "title": "level-order-bfs-traversal-hashmap",
                "content": "# Intuition\\n- Finding the level sum excluding those under the same parent will give sum of cousins\\n\\n# Approach\\n- Iterate through in level order\\n- At each level, create a hashmap of `parent -> total child sum`\\n- Also calculate the total sum at each level\\n- In each iteration, update current node values, subtracting as mentioned above (i.e. `total_sum - parent_sum[par]`)\\n\\n# Complexity\\n- Time complexity: O(N), as we visit each nodes twice so 2N times\\n\\n- Space complexity: O(N), at most (N+1)/2 nodes in the queue\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n      queue = deque([(root, None)])\\n      while queue:\\n        level = []\\n        parent_sum = defaultdict(int)\\n        total_sum = 0\\n        for _ in range(len(queue)):\\n          node, par = queue.popleft()\\n          level.append((node, par))\\n          parent_sum[par] += node.val\\n          total_sum += node.val\\n          if node.left:\\n            queue.append((node.left, node))\\n          if node.right:\\n            queue.append((node.right, node))\\n        for node, par in level:\\n          node.val = total_sum - parent_sum[par]\\n      return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n      queue = deque([(root, None)])\\n      while queue:\\n        level = []\\n        parent_sum = defaultdict(int)\\n        total_sum = 0\\n        for _ in range(len(queue)):\\n          node, par = queue.popleft()\\n          level.append((node, par))\\n          parent_sum[par] += node.val\\n          total_sum += node.val\\n          if node.left:\\n            queue.append((node.left, node))\\n          if node.right:\\n            queue.append((node.right, node))\\n        for node, par in level:\\n          node.val = total_sum - parent_sum[par]\\n      return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899815,
                "title": "simple-fast-easy-c",
                "content": "# Intuition\\nFirst thought: To use level sum wisely\\nSecond thought: Intoduce BFS\\n\\n# Complexit\\n- Time complexity:\\n  O(n)\\n  where n is the number of nodes in the tree\\n- Space complexity:\\n- O(h)\\n- where h is the height of the tree\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private: \\n    void getLevelSum(TreeNode* root,int depth,vector<int>& levelSum)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        if(levelSum.size()==depth)\\n        {\\n            levelSum.push_back(root->val);\\n        }\\n        else{\\n            levelSum[depth]+=root->val;\\n        }\\n        getLevelSum(root->left,depth+1,levelSum);\\n        getLevelSum(root->right,depth+1,levelSum);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> levelSum;\\n        getLevelSum(root,0,levelSum);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val=0;\\n        int depth=1;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                int nodeChildSum=0;\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left!=NULL)\\n                {\\n                    nodeChildSum+=node->left->val;\\n                }\\n                if(node->right!=NULL)\\n                {\\n                    nodeChildSum+=node->right->val;\\n                }\\n                if(node->left)\\n                {\\n                    node->left->val=levelSum[depth]-nodeChildSum;\\n                    q.push(node->left);\\n                }\\n                if(node->right)\\n                {\\n                    node->right->val=levelSum[depth]-nodeChildSum;\\n                    q.push(node->right);\\n                }\\n            }\\n            depth++;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private: \\n    void getLevelSum(TreeNode* root,int depth,vector<int>& levelSum)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        if(levelSum.size()==depth)\\n        {\\n            levelSum.push_back(root->val);\\n        }\\n        else{\\n            levelSum[depth]+=root->val;\\n        }\\n        getLevelSum(root->left,depth+1,levelSum);\\n        getLevelSum(root->right,depth+1,levelSum);\\n    }\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int> levelSum;\\n        getLevelSum(root,0,levelSum);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val=0;\\n        int depth=1;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                int nodeChildSum=0;\\n                TreeNode* node=q.front();\\n                q.pop();\\n                if(node->left!=NULL)\\n                {\\n                    nodeChildSum+=node->left->val;\\n                }\\n                if(node->right!=NULL)\\n                {\\n                    nodeChildSum+=node->right->val;\\n                }\\n                if(node->left)\\n                {\\n                    node->left->val=levelSum[depth]-nodeChildSum;\\n                    q.push(node->left);\\n                }\\n                if(node->right)\\n                {\\n                    node->right->val=levelSum[depth]-nodeChildSum;\\n                    q.push(node->right);\\n                }\\n            }\\n            depth++;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892360,
                "title": "simple-java-recursion-2-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    HashMap<Integer,Integer>hm = new HashMap<>();\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        fill(root, 0);\\n        modify(root,0);\\n        root.val = 0;\\n        return root;\\n    }\\n\\n    public void modify(TreeNode root, int depth){\\n        if(root == null || (root.left == null && root.right == null))return;\\n        if(root.right == null)root.left.val = hm.get(depth+1)-root.left.val;\\n        else if(root.left == null)root.right.val = hm.get(depth+1)-root.right.val;\\n        else{\\n            int temp = hm.get(depth+1)-root.left.val-root.right.val;\\n            root.left.val = temp;\\n            root.right.val = temp;\\n        }\\n        modify(root.left, depth+1);\\n        modify(root.right, depth+1);\\n    }\\n\\n    public void fill(TreeNode root, int depth){\\n        if(root == null)return;\\n        int val = hm.getOrDefault(depth,0);\\n        hm.put(depth,val+root.val);\\n        fill(root.left, depth+1);\\n        fill(root.right, depth+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    HashMap<Integer,Integer>hm = new HashMap<>();\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        fill(root, 0);\\n        modify(root,0);\\n        root.val = 0;\\n        return root;\\n    }\\n\\n    public void modify(TreeNode root, int depth){\\n        if(root == null || (root.left == null && root.right == null))return;\\n        if(root.right == null)root.left.val = hm.get(depth+1)-root.left.val;\\n        else if(root.left == null)root.right.val = hm.get(depth+1)-root.right.val;\\n        else{\\n            int temp = hm.get(depth+1)-root.left.val-root.right.val;\\n            root.left.val = temp;\\n            root.right.val = temp;\\n        }\\n        modify(root.left, depth+1);\\n        modify(root.right, depth+1);\\n    }\\n\\n    public void fill(TreeNode root, int depth){\\n        if(root == null)return;\\n        int val = hm.getOrDefault(depth,0);\\n        hm.put(depth,val+root.val);\\n        fill(root.left, depth+1);\\n        fill(root.right, depth+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883029,
                "title": "well-commented-c-code-dfs",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Good very good question classical dfs question\\n\\n    // Stores sum at every depth\\n    unordered_map<int,int> depthSum;\\\\\\n\\n    // Stores child ---> parent \\n    unordered_map<TreeNode* , TreeNode*> parentChild;\\n\\n    // stores sum of both the child of a parent\\n    unordered_map<TreeNode* , int> parentSum;\\n\\n    // This dfs call will actually replace the values of all the nodes with the cousins sum\\n    void dfs2(TreeNode* root , int depth){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        if(root->left != NULL){\\n            dfs2(root->left , depth+1);\\n        }\\n\\n        if(root->right != NULL){\\n            dfs2(root->right , depth+1);\\n        }\\n\\n        int sum = depthSum[depth];\\n        int parentsum = 0;\\n        \\n        TreeNode* parent = parentChild[root];\\n        parentsum = parentSum[parent];\\n        \\n\\n        root->val = sum - parentsum;\\n    }\\n\\n    // Here in first dfs call we will try to fill all the three maps\\n    void dfs(TreeNode* root , int depth){\\n        if(root == NULL){\\n            return;\\n        }   \\n\\n        if(root->right != NULL){\\n            depthSum[depth+1] += root->right->val;\\n            parentSum[root] += root->right->val;\\n            parentChild[root->right] = root;\\n            dfs(root->right , depth+1);\\n        }\\n\\n        if(root->left != NULL){\\n            depthSum[depth+1] += root->left->val;\\n            parentSum[root] += root->left->val;\\n            parentChild[root->left] = root;\\n            dfs(root->left , depth+1);\\n        }\\n        return;\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == NULL){\\n            return root;\\n        }\\n\\n        \\n        // We are passing root and depth\\n        parentChild[root] = NULL;\\n        depthSum[0] = root->val;\\n        parentSum[NULL] = 0;\\n        dfs(root,0);\\n        dfs2(root,0);\\n        \\n        // At final to check if root->val != 0 we replace it with zero\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Good very good question classical dfs question\\n\\n    // Stores sum at every depth\\n    unordered_map<int,int> depthSum;\\\\\\n\\n    // Stores child ---> parent \\n    unordered_map<TreeNode* , TreeNode*> parentChild;\\n\\n    // stores sum of both the child of a parent\\n    unordered_map<TreeNode* , int> parentSum;\\n\\n    // This dfs call will actually replace the values of all the nodes with the cousins sum\\n    void dfs2(TreeNode* root , int depth){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        if(root->left != NULL){\\n            dfs2(root->left , depth+1);\\n        }\\n\\n        if(root->right != NULL){\\n            dfs2(root->right , depth+1);\\n        }\\n\\n        int sum = depthSum[depth];\\n        int parentsum = 0;\\n        \\n        TreeNode* parent = parentChild[root];\\n        parentsum = parentSum[parent];\\n        \\n\\n        root->val = sum - parentsum;\\n    }\\n\\n    // Here in first dfs call we will try to fill all the three maps\\n    void dfs(TreeNode* root , int depth){\\n        if(root == NULL){\\n            return;\\n        }   \\n\\n        if(root->right != NULL){\\n            depthSum[depth+1] += root->right->val;\\n            parentSum[root] += root->right->val;\\n            parentChild[root->right] = root;\\n            dfs(root->right , depth+1);\\n        }\\n\\n        if(root->left != NULL){\\n            depthSum[depth+1] += root->left->val;\\n            parentSum[root] += root->left->val;\\n            parentChild[root->left] = root;\\n            dfs(root->left , depth+1);\\n        }\\n        return;\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == NULL){\\n            return root;\\n        }\\n\\n        \\n        // We are passing root and depth\\n        parentChild[root] = NULL;\\n        depthSum[0] = root->val;\\n        parentSum[NULL] = 0;\\n        dfs(root,0);\\n        dfs2(root,0);\\n        \\n        // At final to check if root->val != 0 we replace it with zero\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878642,
                "title": "readable-one-pass-solution-in-c",
                "content": "This is an attempt to make [this (original)](https://leetcode.com/problems/cousins-in-binary-tree-ii/discuss/3420010/easy-short-efficient-clean-code) solution more readable.\\n```\\nclass Solution {\\npublic:\\n    int getChildrenSum(const TreeNode* node) {\\n        return ((node->left) ? node->left->val : 0) + ((node->right) ? node->right->val : 0);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        list <TreeNode*> q;\\n        q.push_back(root);\\n        \\n        root->val = 0;\\n        \\n        while(!q.empty()) {\\n            int nextLevelSum = 0;\\n            for(const TreeNode* node : q) {\\n                nextLevelSum += getChildrenSum(node);\\n            }\\n            \\n            int len = q.size();\\n            for(int i = 1; i <= len; i++) {\\n                TreeNode* curr = q.front();\\n                q.pop_front();\\n                \\n                int currNodeChildrenSum = getChildrenSum(curr);\\n                \\n                if(curr->left) {\\n                    curr->left->val = nextLevelSum - currNodeChildrenSum;\\n                    q.push_back(curr->left);\\n                }\\n                if(curr->right) {\\n                    curr->right->val = nextLevelSum - currNodeChildrenSum;\\n                    q.push_back(curr->right);\\n                }\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getChildrenSum(const TreeNode* node) {\\n        return ((node->left) ? node->left->val : 0) + ((node->right) ? node->right->val : 0);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        list <TreeNode*> q;\\n        q.push_back(root);\\n        \\n        root->val = 0;\\n        \\n        while(!q.empty()) {\\n            int nextLevelSum = 0;\\n            for(const TreeNode* node : q) {\\n                nextLevelSum += getChildrenSum(node);\\n            }\\n            \\n            int len = q.size();\\n            for(int i = 1; i <= len; i++) {\\n                TreeNode* curr = q.front();\\n                q.pop_front();\\n                \\n                int currNodeChildrenSum = getChildrenSum(curr);\\n                \\n                if(curr->left) {\\n                    curr->left->val = nextLevelSum - currNodeChildrenSum;\\n                    q.push_back(curr->left);\\n                }\\n                if(curr->right) {\\n                    curr->right->val = nextLevelSum - currNodeChildrenSum;\\n                    q.push_back(curr->right);\\n                }\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876864,
                "title": "c-2-pass-dfs",
                "content": "# Intuition\\n- DFS 1 : store sum of all levels.\\n- DFS 2 : $$root -> left$$, $$root -> right$$ = `(sum of level of [root]) - sum(root->left, root->right)`\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> l;\\n    void dfs1(TreeNode* root, int h) {\\n        if(!root) return;\\n        l[h] += root->val;\\n        dfs1(root->left, h + 1);\\n        dfs1(root->right, h + 1);\\n    }\\n\\n    void dfs2(TreeNode* root, int h = 0) {\\n        if(!root) return;\\n        int s = 0, lvl = l[h + 1];\\n        if(root->left) s += root->left->val;\\n        if(root->right) s += root->right->val;\\n        if(root->left) root->left->val = lvl - s;\\n        if(root->right) root->right->val = lvl - s;\\n        dfs2(root->left, h + 1);\\n        dfs2(root->right, h + 1);\\n    } \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        l.resize(100005, 0);\\n        dfs1(root, 0);\\n        dfs2(root);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> l;\\n    void dfs1(TreeNode* root, int h) {\\n        if(!root) return;\\n        l[h] += root->val;\\n        dfs1(root->left, h + 1);\\n        dfs1(root->right, h + 1);\\n    }\\n\\n    void dfs2(TreeNode* root, int h = 0) {\\n        if(!root) return;\\n        int s = 0, lvl = l[h + 1];\\n        if(root->left) s += root->left->val;\\n        if(root->right) s += root->right->val;\\n        if(root->left) root->left->val = lvl - s;\\n        if(root->right) root->right->val = lvl - s;\\n        dfs2(root->left, h + 1);\\n        dfs2(root->right, h + 1);\\n    } \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        l.resize(100005, 0);\\n        dfs1(root, 0);\\n        dfs2(root);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860491,
                "title": "easy-cpp-solution-using-recursion-and-mapping-brute-force-solution-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void getmp(TreeNode* root, map<TreeNode*, TreeNode*> &mp, map<TreeNode*, int> &smp, vector<int> &lsum, int level){\\n        if(root == NULL) return;\\n        if(level < lsum.size())\\n                lsum[level] += root->val;\\n            else\\n                lsum.push_back(root->val);\\n        if(root->left){\\n            mp[root->left] = root;\\n            smp[root] = root->left->val;\\n            getmp(root->left, mp, smp, lsum, level+1);\\n        }\\n        if(root->right){\\n            mp[root->right] = root;\\n            smp[root] += root->right->val;\\n            getmp(root->right, mp, smp, lsum, level+1);\\n        }\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == NULL) return root;\\n        else root->val = 0;\\n        if(root->left == NULL && root->right == NULL) return root;\\n        // For storing mappping of child with parent node\\n        map<TreeNode*, TreeNode*> mp;\\n        // For storing mapping of prent node with child nodes\\' sum\\n        map<TreeNode*, int> smp;\\n        // For storing level wise sum\\n        vector<int> lsum;\\n        // Getting all the values inserted into map\\n        getmp(root, mp, smp, lsum, 0);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        int level = 0;\\n        while(!q.empty()){\\n            TreeNode* front = q.front();\\n            q.pop();\\n            if(front == NULL){\\n                if(!q.empty()){\\n                    front = q.front();\\n                    q.pop();\\n                    q.push(NULL);\\n                    level++;\\n                }\\n                else break;\\n            }\\n            front->val = lsum[level] - smp[mp[front]];\\n            if(front->left)\\n                q.push(front->left);\\n            if(front->right)\\n                q.push(front->right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void getmp(TreeNode* root, map<TreeNode*, TreeNode*> &mp, map<TreeNode*, int> &smp, vector<int> &lsum, int level){\\n        if(root == NULL) return;\\n        if(level < lsum.size())\\n                lsum[level] += root->val;\\n            else\\n                lsum.push_back(root->val);\\n        if(root->left){\\n            mp[root->left] = root;\\n            smp[root] = root->left->val;\\n            getmp(root->left, mp, smp, lsum, level+1);\\n        }\\n        if(root->right){\\n            mp[root->right] = root;\\n            smp[root] += root->right->val;\\n            getmp(root->right, mp, smp, lsum, level+1);\\n        }\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root == NULL) return root;\\n        else root->val = 0;\\n        if(root->left == NULL && root->right == NULL) return root;\\n        // For storing mappping of child with parent node\\n        map<TreeNode*, TreeNode*> mp;\\n        // For storing mapping of prent node with child nodes\\' sum\\n        map<TreeNode*, int> smp;\\n        // For storing level wise sum\\n        vector<int> lsum;\\n        // Getting all the values inserted into map\\n        getmp(root, mp, smp, lsum, 0);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        int level = 0;\\n        while(!q.empty()){\\n            TreeNode* front = q.front();\\n            q.pop();\\n            if(front == NULL){\\n                if(!q.empty()){\\n                    front = q.front();\\n                    q.pop();\\n                    q.push(NULL);\\n                    level++;\\n                }\\n                else break;\\n            }\\n            front->val = lsum[level] - smp[mp[front]];\\n            if(front->left)\\n                q.push(front->left);\\n            if(front->right)\\n                q.push(front->right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853893,
                "title": "golang-dfs-solution-beat-90",
                "content": "# Code\\n```go\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n\\tlevelSummation := make(map[int]int)\\n\\twalk(root, 0, levelSummation)\\n\\ttree := &TreeNode{\\n\\t\\tVal: 0,\\n\\t\\tLeft: nil,\\n\\t\\tRight: nil,\\n\\t}\\n\\tcalc(root, tree, 0, levelSummation)\\n\\treturn tree\\n}\\n\\nfunc walk(node *TreeNode, level int, levelSummation map[int]int) {\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\tlevelSummation[level] += node.Val\\n\\twalk(node.Left, level+1, levelSummation)\\n\\twalk(node.Right, level+1, levelSummation)\\n}\\n\\nfunc calc(node *TreeNode, resultTree *TreeNode, level int, levelSummation map[int]int) {\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\tlevel++\\n\\tval := 0\\n\\tif node.Left != nil {\\n\\t\\tval += node.Left.Val\\n\\t}\\n\\tif node.Right != nil {\\n\\t\\tval += node.Right.Val\\n\\t}\\n\\tif node.Left != nil {\\n\\t\\tresultTree.Left = &TreeNode{\\n\\t\\t\\tVal: levelSummation[level] - val,\\n\\t\\t\\tLeft: nil,\\n\\t\\t\\tRight: nil,\\n\\t\\t}\\n\\t\\tcalc(node.Left, resultTree.Left, level, levelSummation)\\n\\t}\\n\\tif node.Right != nil {\\n\\t\\tresultTree.Right = &TreeNode{\\n\\t\\t\\tVal: levelSummation[level] - val,\\n\\t\\t\\tLeft: nil,\\n\\t\\t\\tRight: nil,\\n\\t\\t}\\n\\t\\tcalc(node.Right, resultTree.Right, level, levelSummation)\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```go\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n\\tlevelSummation := make(map[int]int)\\n\\twalk(root, 0, levelSummation)\\n\\ttree := &TreeNode{\\n\\t\\tVal: 0,\\n\\t\\tLeft: nil,\\n\\t\\tRight: nil,\\n\\t}\\n\\tcalc(root, tree, 0, levelSummation)\\n\\treturn tree\\n}\\n\\nfunc walk(node *TreeNode, level int, levelSummation map[int]int) {\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\tlevelSummation[level] += node.Val\\n\\twalk(node.Left, level+1, levelSummation)\\n\\twalk(node.Right, level+1, levelSummation)\\n}\\n\\nfunc calc(node *TreeNode, resultTree *TreeNode, level int, levelSummation map[int]int) {\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\tlevel++\\n\\tval := 0\\n\\tif node.Left != nil {\\n\\t\\tval += node.Left.Val\\n\\t}\\n\\tif node.Right != nil {\\n\\t\\tval += node.Right.Val\\n\\t}\\n\\tif node.Left != nil {\\n\\t\\tresultTree.Left = &TreeNode{\\n\\t\\t\\tVal: levelSummation[level] - val,\\n\\t\\t\\tLeft: nil,\\n\\t\\t\\tRight: nil,\\n\\t\\t}\\n\\t\\tcalc(node.Left, resultTree.Left, level, levelSummation)\\n\\t}\\n\\tif node.Right != nil {\\n\\t\\tresultTree.Right = &TreeNode{\\n\\t\\t\\tVal: levelSummation[level] - val,\\n\\t\\t\\tLeft: nil,\\n\\t\\t\\tRight: nil,\\n\\t\\t}\\n\\t\\tcalc(node.Right, resultTree.Right, level, levelSummation)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3848282,
                "title": "bfs-with-hashmap-node-siblings-sums",
                "content": "```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        List<TreeNode> bfsQueue = new ArrayList<>();\\n        root.val = 0;\\n        bfsQueue.add(root);\\n        Map<TreeNode, Integer> parentChildrenSum = new HashMap<>();\\n\\n        while (!bfsQueue.isEmpty()) {\\n            List<TreeNode> nodesToProcessNext = new ArrayList<>();\\n            int sum = 0;\\n            for (TreeNode node : bfsQueue) {\\n                int childSum = 0;\\n                if (node.left != null) {\\n                    nodesToProcessNext.add(node.left);\\n                    childSum += node.left.val;\\n                }\\n                if (node.right != null) {\\n                    nodesToProcessNext.add(node.right);\\n                    childSum += node.right.val;\\n                }\\n\\n                if (node.left != null) {\\n                    parentChildrenSum.put(node.left, childSum);\\n                }\\n                if (node.right != null) {\\n                    parentChildrenSum.put(node.right, childSum);\\n                }\\n                sum += node.val;\\n            }\\n\\n            for (TreeNode node : bfsQueue) {\\n                node.val = sum - parentChildrenSum.getOrDefault(node, 0);\\n            }\\n\\n            bfsQueue = nodesToProcessNext;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        List<TreeNode> bfsQueue = new ArrayList<>();\\n        root.val = 0;\\n        bfsQueue.add(root);\\n        Map<TreeNode, Integer> parentChildrenSum = new HashMap<>();\\n\\n        while (!bfsQueue.isEmpty()) {\\n            List<TreeNode> nodesToProcessNext = new ArrayList<>();\\n            int sum = 0;\\n            for (TreeNode node : bfsQueue) {\\n                int childSum = 0;\\n                if (node.left != null) {\\n                    nodesToProcessNext.add(node.left);\\n                    childSum += node.left.val;\\n                }\\n                if (node.right != null) {\\n                    nodesToProcessNext.add(node.right);\\n                    childSum += node.right.val;\\n                }\\n\\n                if (node.left != null) {\\n                    parentChildrenSum.put(node.left, childSum);\\n                }\\n                if (node.right != null) {\\n                    parentChildrenSum.put(node.right, childSum);\\n                }\\n                sum += node.val;\\n            }\\n\\n            for (TreeNode node : bfsQueue) {\\n                node.val = sum - parentChildrenSum.getOrDefault(node, 0);\\n            }\\n\\n            bfsQueue = nodesToProcessNext;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844010,
                "title": "python-clean-bfs-solution",
                "content": "```python\\nfrom itertools import chain\\nfrom operator import attrgetter\\nfrom typing import Optional\\n\\nflatten = chain.from_iterable\\n\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        siblings = [[root]]\\n\\n        while siblings:\\n            self.update_siblings(siblings)\\n\\n            _siblings = []  # solution structure requires do-while loop\\n\\n            for parent in flatten(siblings):\\n                _siblings.append(children := [])\\n\\n                if parent.left:\\n                    children.append(parent.left)\\n\\n                if parent.right:\\n                    children.append(parent.right)\\n\\n            siblings = _siblings\\n\\n        return root\\n\\n    @staticmethod\\n    def update_siblings(siblings: list[list[TreeNode]]):\\n        \"\"\"\\n        if i and j be two value index in \"siblings\" and i != j then nodes in siblings[i]\\n        are sibling to nodes in siblings[j]\\n        :param siblings:\\n        \"\"\"\\n        values = [Solution.total_sum_of_node_values(children) for children in siblings]\\n        total = sum(values)\\n\\n        for children, child_val_sum in zip(siblings, values):\\n            sibling_val_sum = total - child_val_sum\\n\\n            for child in children:\\n                child.val = sibling_val_sum\\n\\n    @staticmethod\\n    def total_sum_of_node_values(nodes: list[TreeNode]) -> int:\\n        return sum(map(attrgetter(\\'val\\'), nodes))\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nfrom itertools import chain\\nfrom operator import attrgetter\\nfrom typing import Optional\\n\\nflatten = chain.from_iterable\\n\\n\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        siblings = [[root]]\\n\\n        while siblings:\\n            self.update_siblings(siblings)\\n\\n            _siblings = []  # solution structure requires do-while loop\\n\\n            for parent in flatten(siblings):\\n                _siblings.append(children := [])\\n\\n                if parent.left:\\n                    children.append(parent.left)\\n\\n                if parent.right:\\n                    children.append(parent.right)\\n\\n            siblings = _siblings\\n\\n        return root\\n\\n    @staticmethod\\n    def update_siblings(siblings: list[list[TreeNode]]):\\n        \"\"\"\\n        if i and j be two value index in \"siblings\" and i != j then nodes in siblings[i]\\n        are sibling to nodes in siblings[j]\\n        :param siblings:\\n        \"\"\"\\n        values = [Solution.total_sum_of_node_values(children) for children in siblings]\\n        total = sum(values)\\n\\n        for children, child_val_sum in zip(siblings, values):\\n            sibling_val_sum = total - child_val_sum\\n\\n            for child in children:\\n                child.val = sibling_val_sum\\n\\n    @staticmethod\\n    def total_sum_of_node_values(nodes: list[TreeNode]) -> int:\\n        return sum(map(attrgetter(\\'val\\'), nodes))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841705,
                "title": "c-easy-to-understand-simple-traversal-to-store-sum-on-level-basis",
                "content": "First I am storing sum of nodes on level basis and keeping track of parent and its child. We can avoi storing parents too. And in the I am subtracting all sblings from sum so that we can get sum of cousins.\\n\\n```\\nvoid solve(TreeNode* root, TreeNode* parent, unordered_map<int,int> &mpLevel,unordered_map<TreeNode*,TreeNode*> &mpParent, int l){\\n        if(!root){\\n            return;\\n        }\\n        mpLevel[l] += root->val;\\n        mpParent[root] = parent;\\n        solve(root->left,root,mpLevel,mpParent,l+1);\\n        solve(root->right,root,mpLevel,mpParent,l+1);\\n    }\\n    void traverse(TreeNode* root, unordered_map<int,int> &mpLevel,unordered_map<TreeNode*,TreeNode*> &mpParent,unordered_map<TreeNode*,int> &cousinValue, int l){\\n        if(!root){\\n            return;\\n        }\\n        int s=0;\\n        s = mpLevel[l];\\n        TreeNode* parent = mpParent[root];\\n        if(!parent){\\n            s = s - root->val;\\n        }else{\\n            if(parent->left){\\n                s = s - parent->left->val;\\n            }\\n            if(parent->right){\\n                s = s - parent->right->val;\\n            }\\n        }\\n        cousinValue[root] = s;\\n        \\n        traverse(root->left,mpLevel,mpParent,cousinValue,l+1);\\n        traverse(root->right,mpLevel,mpParent,cousinValue,l+1);\\n    }\\n    void fillCousinValue(TreeNode* root, unordered_map<TreeNode*,int> &cousinValue){\\n        if(!root){\\n            return;\\n        }\\n        \\n        root->val = cousinValue[root];\\n        fillCousinValue(root->left,cousinValue);\\n        fillCousinValue(root->right,cousinValue);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mpLevel;\\n        unordered_map<TreeNode*,TreeNode*> mpParent;\\n        unordered_map<TreeNode*,int> cousinValue;\\n\\n        solve(root,nullptr,mpLevel,mpParent,1);\\n        traverse(root,mpLevel,mpParent,cousinValue,1);\\n        fillCousinValue(root,cousinValue);\\n        return root;\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nvoid solve(TreeNode* root, TreeNode* parent, unordered_map<int,int> &mpLevel,unordered_map<TreeNode*,TreeNode*> &mpParent, int l){\\n        if(!root){\\n            return;\\n        }\\n        mpLevel[l] += root->val;\\n        mpParent[root] = parent;\\n        solve(root->left,root,mpLevel,mpParent,l+1);\\n        solve(root->right,root,mpLevel,mpParent,l+1);\\n    }\\n    void traverse(TreeNode* root, unordered_map<int,int> &mpLevel,unordered_map<TreeNode*,TreeNode*> &mpParent,unordered_map<TreeNode*,int> &cousinValue, int l){\\n        if(!root){\\n            return;\\n        }\\n        int s=0;\\n        s = mpLevel[l];\\n        TreeNode* parent = mpParent[root];\\n        if(!parent){\\n            s = s - root->val;\\n        }else{\\n            if(parent->left){\\n                s = s - parent->left->val;\\n            }\\n            if(parent->right){\\n                s = s - parent->right->val;\\n            }\\n        }\\n        cousinValue[root] = s;\\n        \\n        traverse(root->left,mpLevel,mpParent,cousinValue,l+1);\\n        traverse(root->right,mpLevel,mpParent,cousinValue,l+1);\\n    }\\n    void fillCousinValue(TreeNode* root, unordered_map<TreeNode*,int> &cousinValue){\\n        if(!root){\\n            return;\\n        }\\n        \\n        root->val = cousinValue[root];\\n        fillCousinValue(root->left,cousinValue);\\n        fillCousinValue(root->right,cousinValue);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mpLevel;\\n        unordered_map<TreeNode*,TreeNode*> mpParent;\\n        unordered_map<TreeNode*,int> cousinValue;\\n\\n        solve(root,nullptr,mpLevel,mpParent,1);\\n        traverse(root,mpLevel,mpParent,cousinValue,1);\\n        fillCousinValue(root,cousinValue);\\n        return root;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3829849,
                "title": "easy-to-read-bfs-solution",
                "content": "bfs\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\'\\'\\'\\nGiven the root of a binary tree, replace the value of each node in the tree with the sum of all its cousins\\' values.\\nSo if you are given a tree with 3 pairs of cousins\\nIt will be the sum of the other two \\n\\nIDEA:\\n\\n    Level_sum - children_sum = sum_of_cousins\\n\\n    level_sum = sum of all the children in that level \\n    children_sum = given parent and its children: sum the children\\n\\n\\nBFS:\\n    Maintain level sum\\n    When working with current level : Maintain / build up sum for the next level\\n    That way, when working with that next level, we have that sum to begin with \\n\\n    CAVEAT:\\n        When encountering parents with left and right children:\\n            We need to update their values to be the sum \\n\\n            why?\\n            Those values will be the same to begin with \\n            solves many gaps of this problem\\n                level 1 == 0 \\n\\'\\'\\'\\n\\nfrom collections import deque\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        que = deque()\\n        que.append(root)\\n        level_sum = root.val \\n        while que:\\n            length = len(que)\\n            next_level_sum = 0\\n            for i in range(length):\\n                node = que.popleft()\\n                #update node value with cousins sum \\n                node.val = level_sum - node.val\\n\\n                #get next level sum to work with \\n                if node.left:\\n                    next_level_sum += node.left.val\\n                    que.append(node.left)\\n                \\n                if node.right:\\n                    next_level_sum += node.right.val\\n                    que.append(node.right)\\n                \\n                #CAVEAT updating values for parents with two kids \\n                if node.left and node.right:\\n                    children_sum = node.left.val + node.right.val\\n                    node.left.val = children_sum\\n                    node.right.val = children_sum\\n            \\n            level_sum = next_level_sum\\n        \\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\'\\'\\'\\nGiven the root of a binary tree, replace the value of each node in the tree with the sum of all its cousins\\' values.\\nSo if you are given a tree with 3 pairs of cousins\\nIt will be the sum of the other two \\n\\nIDEA:\\n\\n    Level_sum - children_sum = sum_of_cousins\\n\\n    level_sum = sum of all the children in that level \\n    children_sum = given parent and its children: sum the children\\n\\n\\nBFS:\\n    Maintain level sum\\n    When working with current level : Maintain / build up sum for the next level\\n    That way, when working with that next level, we have that sum to begin with \\n\\n    CAVEAT:\\n        When encountering parents with left and right children:\\n            We need to update their values to be the sum \\n\\n            why?\\n            Those values will be the same to begin with \\n            solves many gaps of this problem\\n                level 1 == 0 \\n\\'\\'\\'\\n\\nfrom collections import deque\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        que = deque()\\n        que.append(root)\\n        level_sum = root.val \\n        while que:\\n            length = len(que)\\n            next_level_sum = 0\\n            for i in range(length):\\n                node = que.popleft()\\n                #update node value with cousins sum \\n                node.val = level_sum - node.val\\n\\n                #get next level sum to work with \\n                if node.left:\\n                    next_level_sum += node.left.val\\n                    que.append(node.left)\\n                \\n                if node.right:\\n                    next_level_sum += node.right.val\\n                    que.append(node.right)\\n                \\n                #CAVEAT updating values for parents with two kids \\n                if node.left and node.right:\\n                    children_sum = node.left.val + node.right.val\\n                    node.left.val = children_sum\\n                    node.right.val = children_sum\\n            \\n            level_sum = next_level_sum\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825495,
                "title": "python3-level-order-traversal-beats-100",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        prev,curr = [],[root]\\n\\n        while curr:\\n            sums = []\\n            for node in curr:\\n                s = 0\\n                if node.left: s += node.left.val\\n                if node.right: s += node.right.val\\n                sums.append(s)\\n\\n            total = sum(sums)\\n            for i,node in enumerate(curr):\\n                if node.left: node.left.val = total - sums[i]\\n                if node.right: node.right.val = total - sums[i]\\n\\n            prev,curr = curr, [child for node in curr for child in [node.left,node.right] if child]\\n\\n        root.val = 0\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        prev,curr = [],[root]\\n\\n        while curr:\\n            sums = []\\n            for node in curr:\\n                s = 0\\n                if node.left: s += node.left.val\\n                if node.right: s += node.right.val\\n                sums.append(s)\\n\\n            total = sum(sums)\\n            for i,node in enumerate(curr):\\n                if node.left: node.left.val = total - sums[i]\\n                if node.right: node.right.val = total - sums[i]\\n\\n            prev,curr = curr, [child for node in curr for child in [node.left,node.right] if child]\\n\\n        root.val = 0\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820213,
                "title": "easy-bfs-solution-c-just-addition-and-subtraction-from-sum-of-levels",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// #include <queue>\\n// #include <vector>\\n// #include <cmath>\\n\\n// struct TreeNode {\\n//     int val;\\n//     TreeNode *left;\\n//     TreeNode *right;\\n//     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n//     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n//     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n// };\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if (root == nullptr) \\n        {\\n            return nullptr;\\n        }\\n\\n        queue<TreeNode*> q;\\n        vector<int> sumL;\\n        int sum = 0;\\n\\n        q.push(root);\\n        while (!q.empty()) \\n        {\\n            int size = q.size();\\n            while (size--) \\n            {\\n                TreeNode* t = q.front();\\n                sum += t->val;\\n                q.pop();\\n                if (t->left) \\n                {\\n                    q.push(t->left);\\n                }\\n                if (t->right) \\n                {\\n                    q.push(t->right);\\n                }\\n            }\\n            sumL.push_back(sum);\\n            sum = 0;\\n        }\\n\\n\\n        queue<TreeNode*> q1; \\n        q1.push(root);\\n        int i = 0;\\n        while (!q1.empty()) \\n        {\\n            int size = q1.size();\\n            while (size--) \\n            {\\n                TreeNode* t = q1.front();\\n                q1.pop();\\n                 t->val = abs(t->val - sumL[i]);\\n                if (t->left && t->right) \\n                {\\n                    int l=t->left->val;\\n                    int r=t->right->val;\\n                    t->left->val = l + r;\\n                    t->right->val = r + l;\\n                }\\n                if (t->left) \\n                {\\n                    q1.push(t->left);\\n                }\\n                if (t->right) \\n                {\\n                    q1.push(t->right);\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// #include <queue>\\n// #include <vector>\\n// #include <cmath>\\n\\n// struct TreeNode {\\n//     int val;\\n//     TreeNode *left;\\n//     TreeNode *right;\\n//     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n//     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n//     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n// };\\n\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if (root == nullptr) \\n        {\\n            return nullptr;\\n        }\\n\\n        queue<TreeNode*> q;\\n        vector<int> sumL;\\n        int sum = 0;\\n\\n        q.push(root);\\n        while (!q.empty()) \\n        {\\n            int size = q.size();\\n            while (size--) \\n            {\\n                TreeNode* t = q.front();\\n                sum += t->val;\\n                q.pop();\\n                if (t->left) \\n                {\\n                    q.push(t->left);\\n                }\\n                if (t->right) \\n                {\\n                    q.push(t->right);\\n                }\\n            }\\n            sumL.push_back(sum);\\n            sum = 0;\\n        }\\n\\n\\n        queue<TreeNode*> q1; \\n        q1.push(root);\\n        int i = 0;\\n        while (!q1.empty()) \\n        {\\n            int size = q1.size();\\n            while (size--) \\n            {\\n                TreeNode* t = q1.front();\\n                q1.pop();\\n                 t->val = abs(t->val - sumL[i]);\\n                if (t->left && t->right) \\n                {\\n                    int l=t->left->val;\\n                    int r=t->right->val;\\n                    t->left->val = l + r;\\n                    t->right->val = r + l;\\n                }\\n                if (t->left) \\n                {\\n                    q1.push(t->left);\\n                }\\n                if (t->right) \\n                {\\n                    q1.push(t->right);\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3818772,
                "title": "c-simple-solution-using-level-order-and-parent-mapping",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void ParentMapping(TreeNode* root, unordered_map<TreeNode*, TreeNode*> &parent){\\n    if(root==NULL)\\n    return;\\n    if(root->left==NULL && root->right==NULL)\\n    return;\\n\\n    if(root->left){\\n        TreeNode* child = root->left;\\n        parent[child] = root;\\n        ParentMapping(root->left, parent);\\n    }\\n    if(root->right){\\n        TreeNode* child = root->right;\\n        parent[child] = root;\\n        ParentMapping(root->right, parent);\\n    }\\n}\\n\\nvoid levelOrder(TreeNode* &root, unordered_map<TreeNode*, TreeNode*> &parent){\\n    queue<TreeNode*> q;\\n    q.push(root);\\n\\n    while(!q.empty()){\\n        \\n        unordered_map<TreeNode*, int> mp;\\n        int sum = 0;\\n        queue<TreeNode*> temp;\\n        int n = q.size();\\n\\n        for(int i=0 ;i<n ;i++){\\n            TreeNode* frt = q.front();\\n            q.pop();\\n\\n            temp.push(frt);\\n            sum += frt->val;\\n\\n            if(mp.find(parent[frt]) == mp.end())\\n            mp[parent[frt]] = frt->val;\\n            else\\n            mp[parent[frt]] = mp[parent[frt]]+frt->val;\\n\\n            if(frt->left)\\n            q.push(frt->left);\\n            if(frt->right)\\n            q.push(frt->right);\\n        }\\n        \\n        while(!temp.empty()){\\n            TreeNode* frt = temp.front();\\n            temp.pop();\\n\\n            frt->val = sum-mp[parent[frt]];\\n        }\\n    }\\n    return;\\n}\\n\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<TreeNode*, TreeNode*> parent;\\n        parent[root] = new TreeNode(-1);\\n        ParentMapping(root, parent);\\n\\n        int depthX = -1, depthY = -1;\\n        levelOrder(root, parent);\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void ParentMapping(TreeNode* root, unordered_map<TreeNode*, TreeNode*> &parent){\\n    if(root==NULL)\\n    return;\\n    if(root->left==NULL && root->right==NULL)\\n    return;\\n\\n    if(root->left){\\n        TreeNode* child = root->left;\\n        parent[child] = root;\\n        ParentMapping(root->left, parent);\\n    }\\n    if(root->right){\\n        TreeNode* child = root->right;\\n        parent[child] = root;\\n        ParentMapping(root->right, parent);\\n    }\\n}\\n\\nvoid levelOrder(TreeNode* &root, unordered_map<TreeNode*, TreeNode*> &parent){\\n    queue<TreeNode*> q;\\n    q.push(root);\\n\\n    while(!q.empty()){\\n        \\n        unordered_map<TreeNode*, int> mp;\\n        int sum = 0;\\n        queue<TreeNode*> temp;\\n        int n = q.size();\\n\\n        for(int i=0 ;i<n ;i++){\\n            TreeNode* frt = q.front();\\n            q.pop();\\n\\n            temp.push(frt);\\n            sum += frt->val;\\n\\n            if(mp.find(parent[frt]) == mp.end())\\n            mp[parent[frt]] = frt->val;\\n            else\\n            mp[parent[frt]] = mp[parent[frt]]+frt->val;\\n\\n            if(frt->left)\\n            q.push(frt->left);\\n            if(frt->right)\\n            q.push(frt->right);\\n        }\\n        \\n        while(!temp.empty()){\\n            TreeNode* frt = temp.front();\\n            temp.pop();\\n\\n            frt->val = sum-mp[parent[frt]];\\n        }\\n    }\\n    return;\\n}\\n\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<TreeNode*, TreeNode*> parent;\\n        parent[root] = new TreeNode(-1);\\n        ParentMapping(root, parent);\\n\\n        int depthX = -1, depthY = -1;\\n        levelOrder(root, parent);\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813889,
                "title": "using-hashmap-and-level-order",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root==null)return root;\\n       HashMap<Integer,Integer> map=new HashMap<>();\\n       int lvl=0;\\n       Queue <TreeNode> q=new ArrayDeque<>();\\n        if(root!=null)\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int s=q.size();\\n            int max=0;\\n\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode curr=q.remove();\\n                max+=curr.val;\\n                if(curr.left!=null)\\n                {\\n                    q.offer(curr.left);\\n                }\\n                if(curr.right!=null)\\n                {\\n                    q.offer(curr.right);\\n                }\\n            }map.put(lvl,max);  \\n            lvl++;\\n        }\\n        lvl=0;\\n        root.val=0;\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int s=q.size();\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode curr=q.remove();\\n                int sum=0;\\n                if(curr.left!=null)\\n                {\\n                    sum+=curr.left.val;\\n                }\\n                if(curr.right!=null)\\n                {\\n                    sum+=curr.right.val;\\n                }\\n                 if(curr.left!=null)\\n                {\\n                    curr.left.val=map.get(lvl+1)-sum;\\n                    q.offer(curr.left);\\n                }\\n                if(curr.right!=null)\\n                {\\n                    curr.right.val=map.get(lvl+1)-sum;\\n                    q.offer(curr.right);\\n                }\\n            } \\n            lvl++;\\n        }\\n      \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root==null)return root;\\n       HashMap<Integer,Integer> map=new HashMap<>();\\n       int lvl=0;\\n       Queue <TreeNode> q=new ArrayDeque<>();\\n        if(root!=null)\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int s=q.size();\\n            int max=0;\\n\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode curr=q.remove();\\n                max+=curr.val;\\n                if(curr.left!=null)\\n                {\\n                    q.offer(curr.left);\\n                }\\n                if(curr.right!=null)\\n                {\\n                    q.offer(curr.right);\\n                }\\n            }map.put(lvl,max);  \\n            lvl++;\\n        }\\n        lvl=0;\\n        root.val=0;\\n        q.offer(root);\\n        while(!q.isEmpty())\\n        {\\n            int s=q.size();\\n            for(int i=0;i<s;i++)\\n            {\\n                TreeNode curr=q.remove();\\n                int sum=0;\\n                if(curr.left!=null)\\n                {\\n                    sum+=curr.left.val;\\n                }\\n                if(curr.right!=null)\\n                {\\n                    sum+=curr.right.val;\\n                }\\n                 if(curr.left!=null)\\n                {\\n                    curr.left.val=map.get(lvl+1)-sum;\\n                    q.offer(curr.left);\\n                }\\n                if(curr.right!=null)\\n                {\\n                    curr.right.val=map.get(lvl+1)-sum;\\n                    q.offer(curr.right);\\n                }\\n            } \\n            lvl++;\\n        }\\n      \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813678,
                "title": "c-solution-using-inorder-and-level-order-traversal-beats-89-15",
                "content": "# Complexity\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root, vector<long long> &v, int level){\\n        if(root == nullptr){\\n            return;\\n        }\\n        int sum = 0;\\n        if(root->left){\\n            sum += root->left->val;\\n        }\\n        if(root->right){\\n            sum += root->right->val;\\n        }\\n        if(root->left){\\n            root->left->val = v[level] - sum;\\n        }\\n        if(root->right){\\n            root->right->val = v[level] - sum;\\n        }\\n        solve(root->left, v, level+1);\\n        solve(root->right, v, level+1);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<long long> v;\\n        int level = 1;\\n        kthLargestLevelSum(root, v);\\n        if(root){\\n            root->val = 0;\\n        }\\n        solve(root, v, level);\\n        return root;\\n    }\\n    void kthLargestLevelSum(TreeNode* root, vector<long long> &v) {\\n        queue<TreeNode*> q;\\n        long long sum = 0;\\n        q.push(root);\\n        q.push(nullptr);\\n        \\n        while(!q.empty()){\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node == nullptr){\\n                v.push_back(sum);\\n                sum = 0;\\n                if(!q.empty()){\\n                    q.push(nullptr);\\n                }\\n            }else{\\n                sum += node->val;\\n                if(node->left){\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode* root, vector<long long> &v, int level){\\n        if(root == nullptr){\\n            return;\\n        }\\n        int sum = 0;\\n        if(root->left){\\n            sum += root->left->val;\\n        }\\n        if(root->right){\\n            sum += root->right->val;\\n        }\\n        if(root->left){\\n            root->left->val = v[level] - sum;\\n        }\\n        if(root->right){\\n            root->right->val = v[level] - sum;\\n        }\\n        solve(root->left, v, level+1);\\n        solve(root->right, v, level+1);\\n    }\\n    \\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<long long> v;\\n        int level = 1;\\n        kthLargestLevelSum(root, v);\\n        if(root){\\n            root->val = 0;\\n        }\\n        solve(root, v, level);\\n        return root;\\n    }\\n    void kthLargestLevelSum(TreeNode* root, vector<long long> &v) {\\n        queue<TreeNode*> q;\\n        long long sum = 0;\\n        q.push(root);\\n        q.push(nullptr);\\n        \\n        while(!q.empty()){\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node == nullptr){\\n                v.push_back(sum);\\n                sum = 0;\\n                if(!q.empty()){\\n                    q.push(nullptr);\\n                }\\n            }else{\\n                sum += node->val;\\n                if(node->left){\\n                    q.push(node->left);\\n                }\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806098,
                "title": "c-bfs-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val=0;\\n        \\n        \\n        while(q.empty()==false){\\n            int n=q.size();\\n            int sum=0;\\n            vector<TreeNode*> childs;\\n            for(int i=0;i<n;i++){\\n                auto node=q.front();\\n                q.pop();\\n                childs.push_back(node);\\n                if(node->left){\\n                    q.push(node->left);\\n                    sum+=node->left->val;\\n                    // childs.push_back(node->left);\\n                }\\n                \\n                if(node->right){\\n                    q.push(node->right);\\n                    sum+=node->right->val;\\n                    // childs.push_back(node->right);\\n                }\\n                \\n            }\\n            \\n            for(auto child:childs){\\n                int dummySum=sum;\\n                // cout<<sum<<\"\\\\n\";\\n                if(child->left){\\n                    dummySum-=child->left->val;\\n                }\\n                \\n                if(child->right){\\n                    dummySum-=child->right->val;\\n                }\\n                if(child->left){\\n                    child->left->val=dummySum;\\n                }\\n                if(child->right){\\n                    child->right->val=dummySum;\\n                }\\n            }\\n            \\n            \\n            \\n        }\\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        root->val=0;\\n        \\n        \\n        while(q.empty()==false){\\n            int n=q.size();\\n            int sum=0;\\n            vector<TreeNode*> childs;\\n            for(int i=0;i<n;i++){\\n                auto node=q.front();\\n                q.pop();\\n                childs.push_back(node);\\n                if(node->left){\\n                    q.push(node->left);\\n                    sum+=node->left->val;\\n                    // childs.push_back(node->left);\\n                }\\n                \\n                if(node->right){\\n                    q.push(node->right);\\n                    sum+=node->right->val;\\n                    // childs.push_back(node->right);\\n                }\\n                \\n            }\\n            \\n            for(auto child:childs){\\n                int dummySum=sum;\\n                // cout<<sum<<\"\\\\n\";\\n                if(child->left){\\n                    dummySum-=child->left->val;\\n                }\\n                \\n                if(child->right){\\n                    dummySum-=child->right->val;\\n                }\\n                if(child->left){\\n                    child->left->val=dummySum;\\n                }\\n                if(child->right){\\n                    child->right->val=dummySum;\\n                }\\n            }\\n            \\n            \\n            \\n        }\\n        \\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3800491,
                "title": "c-bfs-o-n-one-traversal-super-easy-solution-using-child-sum-and-current-and-last-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(2^H)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==NULL) return root;\\n        queue<pair<TreeNode*,long long int>> q;\\n        q.push({root,root->val});\\n        int long long lastSum=root->val;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            long long int currSum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n                auto it=q.front();\\n                TreeNode* currNode=it.first;\\n                q.pop();\\n                long long int childSum=0;\\n                if(currNode->left) childSum+=currNode->left->val;\\n                if(currNode->right) childSum+=currNode->right->val;\\n                currSum+=childSum;\\n                if(currNode->left) q.push({currNode->left,childSum});\\n                if(currNode->right)q.push({currNode->right,childSum});\\n                currNode->val=abs(lastSum-it.second);\\n            }\\n            lastSum=currSum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(root==NULL) return root;\\n        queue<pair<TreeNode*,long long int>> q;\\n        q.push({root,root->val});\\n        int long long lastSum=root->val;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            long long int currSum=0;\\n            for(int i=0;i<size;i++)\\n            {\\n                auto it=q.front();\\n                TreeNode* currNode=it.first;\\n                q.pop();\\n                long long int childSum=0;\\n                if(currNode->left) childSum+=currNode->left->val;\\n                if(currNode->right) childSum+=currNode->right->val;\\n                currSum+=childSum;\\n                if(currNode->left) q.push({currNode->left,childSum});\\n                if(currNode->right)q.push({currNode->right,childSum});\\n                currNode->val=abs(lastSum-it.second);\\n            }\\n            lastSum=currSum;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789552,
                "title": "easy-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity:\\nO(h) , h=height of the binary tree\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   void rec(TreeNode* node,int sum,vector<int>&v,int level)\\n   {\\n       if (!node) return;\\n       node->val=v[level]-sum;\\n       int cur=0;\\n       if (node->left) cur+=node->left->val;\\n       if (node->right) cur+=node->right->val;\\n       rec(node->left,cur,v,level+1);\\n       rec(node->right,cur,v,level+1);\\n\\n   }\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       vector<int>v;\\n       while(!q.empty())\\n       {\\n           int sz=q.size();\\n           int sum=0;\\n           while(sz--)\\n           {\\n               TreeNode* node=q.front();\\n               q.pop();\\n               sum+=node->val;\\n               if (node->left)\\n               {\\n                   q.push(node->left);\\n               }\\n               if (node->right)\\n               {\\n                   q.push(node->right);\\n               }\\n           }\\n           v.push_back(sum);\\n       }\\n       rec(root,root->val,v,0);\\n       return root;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   void rec(TreeNode* node,int sum,vector<int>&v,int level)\\n   {\\n       if (!node) return;\\n       node->val=v[level]-sum;\\n       int cur=0;\\n       if (node->left) cur+=node->left->val;\\n       if (node->right) cur+=node->right->val;\\n       rec(node->left,cur,v,level+1);\\n       rec(node->right,cur,v,level+1);\\n\\n   }\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       vector<int>v;\\n       while(!q.empty())\\n       {\\n           int sz=q.size();\\n           int sum=0;\\n           while(sz--)\\n           {\\n               TreeNode* node=q.front();\\n               q.pop();\\n               sum+=node->val;\\n               if (node->left)\\n               {\\n                   q.push(node->left);\\n               }\\n               if (node->right)\\n               {\\n                   q.push(node->right);\\n               }\\n           }\\n           v.push_back(sum);\\n       }\\n       rec(root,root->val,v,0);\\n       return root;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785332,
                "title": "python-medium",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        alias = root\\n        \\n        q = deque()\\n        q.append((root, None, 0))\\n        \\n        level = 0\\n        \\n        \\n        while q:\\n            \\n            nxt = deque()\\n            \\n            \\n            total = 0\\n            \\n            for n, par, other in q:\\n                total += n.val\\n                \\n                \\n            \\n            while q:\\n                node, par, otherVal = q.popleft()\\n                \\n                \\n                        \\n                node.val = total - node.val - otherVal\\n                \\n                \\n                if node.left and node.right:\\n                    nxt.append((node.left, node, node.right.val))\\n                    nxt.append((node.right, node, node.left.val))\\n                    \\n                elif node.left:\\n                    nxt.append((node.left, node, 0))\\n                    \\n                elif node.right:\\n                    nxt.append((node.right, node, 0))\\n                    \\n                \\n                \\n                \\n        \\n        \\n            \\n            q = nxt\\n            level += 1\\n            \\n        \\n        return alias\\n            \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        alias = root\\n        \\n        q = deque()\\n        q.append((root, None, 0))\\n        \\n        level = 0\\n        \\n        \\n        while q:\\n            \\n            nxt = deque()\\n            \\n            \\n            total = 0\\n            \\n            for n, par, other in q:\\n                total += n.val\\n                \\n                \\n            \\n            while q:\\n                node, par, otherVal = q.popleft()\\n                \\n                \\n                        \\n                node.val = total - node.val - otherVal\\n                \\n                \\n                if node.left and node.right:\\n                    nxt.append((node.left, node, node.right.val))\\n                    nxt.append((node.right, node, node.left.val))\\n                    \\n                elif node.left:\\n                    nxt.append((node.left, node, 0))\\n                    \\n                elif node.right:\\n                    nxt.append((node.right, node, 0))\\n                    \\n                \\n                \\n                \\n        \\n        \\n            \\n            q = nxt\\n            level += 1\\n            \\n        \\n        return alias\\n            \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784425,
                "title": "2-times-bfs-level-order-traversal-clean-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst calulcate level order sum and store in map then replace values by calculating children sum and substracting it from children\\'s level sum\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe use one map to store sum of all nodes at a level and one queue for doing level order traversal/BFS.\\nfirst calulcate level order sum and store in map,set root\\'s value to zero, then replace values by calculating children sum and substracting it from children\\'s level sum\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void CalculateLevelSum(unordered_map<int,int> &mp,queue<TreeNode*> &q); \\n    void changeValues(unordered_map<int,int> &mp,queue<TreeNode*> &q);\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        CalculateLevelSum(mp,q);\\n        root->val=0;\\n        q.push(root);\\n        changeValues(mp,q);\\n        return root;\\n    }\\n};\\nvoid Solution::CalculateLevelSum(unordered_map<int,int> &mp,queue<TreeNode*> &q)\\n{\\n    int level=1;\\n    while(!q.empty())\\n    {\\n        int n=q.size(),sum=0;\\n        while(n--)\\n        {\\n            TreeNode *f=q.front();\\n            q.pop();\\n            sum+=f->val;\\n            if(f->left)\\n                q.push(f->left);\\n            if(f->right)\\n                q.push(f->right);\\n        }\\n        mp[level]=sum;\\n        level++;\\n    }\\n}\\nvoid Solution::changeValues(unordered_map<int,int> &mp,queue<TreeNode*> &q)\\n{\\n    int level=1;\\n    while(!q.empty())\\n    {\\n        int n=q.size();\\n        while(n--)\\n        {\\n            int sum=0;\\n            TreeNode *f=q.front();\\n            q.pop();\\n            if(f->left) sum+=f->left->val;\\n            if(f->right) sum+=f->right->val;\\n            if(f->left)\\n            {\\n                f->left->val=mp[level+1]-sum;\\n                q.push(f->left);\\n            }\\n            if(f->right)\\n            {\\n                f->right->val=mp[level+1]-sum;\\n                q.push(f->right);\\n            } \\n        }\\n        level++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void CalculateLevelSum(unordered_map<int,int> &mp,queue<TreeNode*> &q); \\n    void changeValues(unordered_map<int,int> &mp,queue<TreeNode*> &q);\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        CalculateLevelSum(mp,q);\\n        root->val=0;\\n        q.push(root);\\n        changeValues(mp,q);\\n        return root;\\n    }\\n};\\nvoid Solution::CalculateLevelSum(unordered_map<int,int> &mp,queue<TreeNode*> &q)\\n{\\n    int level=1;\\n    while(!q.empty())\\n    {\\n        int n=q.size(),sum=0;\\n        while(n--)\\n        {\\n            TreeNode *f=q.front();\\n            q.pop();\\n            sum+=f->val;\\n            if(f->left)\\n                q.push(f->left);\\n            if(f->right)\\n                q.push(f->right);\\n        }\\n        mp[level]=sum;\\n        level++;\\n    }\\n}\\nvoid Solution::changeValues(unordered_map<int,int> &mp,queue<TreeNode*> &q)\\n{\\n    int level=1;\\n    while(!q.empty())\\n    {\\n        int n=q.size();\\n        while(n--)\\n        {\\n            int sum=0;\\n            TreeNode *f=q.front();\\n            q.pop();\\n            if(f->left) sum+=f->left->val;\\n            if(f->right) sum+=f->right->val;\\n            if(f->left)\\n            {\\n                f->left->val=mp[level+1]-sum;\\n                q.push(f->left);\\n            }\\n            if(f->right)\\n            {\\n                f->right->val=mp[level+1]-sum;\\n                q.push(f->right);\\n            } \\n        }\\n        level++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780429,
                "title": "python-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nfrom queue import Queue\\nclass Solution:\\n    def dfs(self, root, parent, level_sum, depth, clone):\\n        if root is None:\\n            return\\n        if parent is None:\\n            clone.val = 0\\n            self.dfs(root.left, root, level_sum, depth+1, clone.left)\\n            self.dfs(root.right, root, level_sum, depth+1, clone.right)\\n        else:\\n            siblings_sum = 0\\n            if parent.left:\\n                siblings_sum+=parent.left.val\\n            if parent.right:\\n                siblings_sum+=parent.right.val\\n            cousins_sum = level_sum[depth] - siblings_sum\\n            clone.val = cousins_sum\\n            self.dfs(root.left, root, level_sum, depth+1, clone.left)\\n            self.dfs(root.right, root, level_sum, depth+1, clone.right)\\n            \\n    def copy_tree(self, root):\\n        if root is None:\\n            return None\\n        new_node = TreeNode(root.val)\\n        new_node.left = self.copy_tree(root.left)\\n        new_node.right = self.copy_tree(root.right)\\n        return new_node\\n    \\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_sum = {}\\n        q = Queue(maxsize=0)\\n        q.put(root)\\n        depth = 0\\n        while q.empty() is False:\\n            curr_nodes = []\\n            while q.empty() is False:\\n                crr = q.get()\\n                curr_nodes.append(crr)\\n            sum = 0\\n            for x in curr_nodes:\\n                sum = sum + x.val\\n            level_sum[depth] = sum\\n            for x in curr_nodes:\\n                if x.left is not None:\\n                    q.put(x.left)\\n                if x.right is not None:\\n                    q.put(x.right)\\n            depth+=1\\n        #print(level_sum)\\n        clone = self.copy_tree(root)\\n        self.dfs(root, None, level_sum, 0, clone)\\n        return clone\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nfrom queue import Queue\\nclass Solution:\\n    def dfs(self, root, parent, level_sum, depth, clone):\\n        if root is None:\\n            return\\n        if parent is None:\\n            clone.val = 0\\n            self.dfs(root.left, root, level_sum, depth+1, clone.left)\\n            self.dfs(root.right, root, level_sum, depth+1, clone.right)\\n        else:\\n            siblings_sum = 0\\n            if parent.left:\\n                siblings_sum+=parent.left.val\\n            if parent.right:\\n                siblings_sum+=parent.right.val\\n            cousins_sum = level_sum[depth] - siblings_sum\\n            clone.val = cousins_sum\\n            self.dfs(root.left, root, level_sum, depth+1, clone.left)\\n            self.dfs(root.right, root, level_sum, depth+1, clone.right)\\n            \\n    def copy_tree(self, root):\\n        if root is None:\\n            return None\\n        new_node = TreeNode(root.val)\\n        new_node.left = self.copy_tree(root.left)\\n        new_node.right = self.copy_tree(root.right)\\n        return new_node\\n    \\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_sum = {}\\n        q = Queue(maxsize=0)\\n        q.put(root)\\n        depth = 0\\n        while q.empty() is False:\\n            curr_nodes = []\\n            while q.empty() is False:\\n                crr = q.get()\\n                curr_nodes.append(crr)\\n            sum = 0\\n            for x in curr_nodes:\\n                sum = sum + x.val\\n            level_sum[depth] = sum\\n            for x in curr_nodes:\\n                if x.left is not None:\\n                    q.put(x.left)\\n                if x.right is not None:\\n                    q.put(x.right)\\n            depth+=1\\n        #print(level_sum)\\n        clone = self.copy_tree(root)\\n        self.dfs(root, None, level_sum, 0, clone)\\n        return clone\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776780,
                "title": "c-solution-using-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,vector<pair<TreeNode*,int>>> m;\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        traverse(root, 0, NULL);\\n        cousinSum(root, 0, NULL);\\n        return root;\\n    }\\n\\n    void traverse(TreeNode* r, int d, TreeNode* prev){\\n        if(r==NULL) return;\\n        \\n        m[d].push_back(make_pair(prev, r->val));\\n        \\n        traverse(r->left, d+1, r);\\n        traverse(r->right, d+1, r);\\n    }\\n\\n    void cousinSum(TreeNode* r, int d, TreeNode* prev){\\n        if(r==NULL) return;\\n        int sum = 0;\\n        for(auto it : m[d]){\\n            if(it.first != prev && prev != NULL) sum += it.second;\\n        }\\n        r->val = sum;\\n        cousinSum(r->left, d + 1, r);\\n        cousinSum(r->right, d + 1, r);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,vector<pair<TreeNode*,int>>> m;\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        traverse(root, 0, NULL);\\n        cousinSum(root, 0, NULL);\\n        return root;\\n    }\\n\\n    void traverse(TreeNode* r, int d, TreeNode* prev){\\n        if(r==NULL) return;\\n        \\n        m[d].push_back(make_pair(prev, r->val));\\n        \\n        traverse(r->left, d+1, r);\\n        traverse(r->right, d+1, r);\\n    }\\n\\n    void cousinSum(TreeNode* r, int d, TreeNode* prev){\\n        if(r==NULL) return;\\n        int sum = 0;\\n        for(auto it : m[d]){\\n            if(it.first != prev && prev != NULL) sum += it.second;\\n        }\\n        r->val = sum;\\n        cousinSum(r->left, d + 1, r);\\n        cousinSum(r->right, d + 1, r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770660,
                "title": "level-ordertraversal-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void func(TreeNode *root,int sum,int h,vector<int>&presum)\\n    {\\n        if(root==NULL)\\n            return;\\n        int tmp=0;\\n        if(root->right!=NULL)\\n            tmp+=root->right->val;\\n        if(root->left!=NULL)\\n            tmp+=root->left->val;\\n        root->val=presum[h]-sum;\\n        func(root->left,tmp,h+1,presum);\\n        func(root->right,tmp,h+1,presum);\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int>presum;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            int sum=0;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* node=q.front();\\n                q.pop();\\n                sum+=node->val;\\n\\n                if(node->left!=NULL)\\n                    q.push(node->left);\\n\\n                if(node->right!=NULL)\\n                    q.push(node->right);\\n            }\\n            presum.push_back(sum);\\n        }\\n     \\n        func(root,root->val,0,presum);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void func(TreeNode *root,int sum,int h,vector<int>&presum)\\n    {\\n        if(root==NULL)\\n            return;\\n        int tmp=0;\\n        if(root->right!=NULL)\\n            tmp+=root->right->val;\\n        if(root->left!=NULL)\\n            tmp+=root->left->val;\\n        root->val=presum[h]-sum;\\n        func(root->left,tmp,h+1,presum);\\n        func(root->right,tmp,h+1,presum);\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<int>presum;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            int sum=0;\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* node=q.front();\\n                q.pop();\\n                sum+=node->val;\\n\\n                if(node->left!=NULL)\\n                    q.push(node->left);\\n\\n                if(node->right!=NULL)\\n                    q.push(node->right);\\n            }\\n            presum.push_back(sum);\\n        }\\n     \\n        func(root,root->val,0,presum);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765298,
                "title": "python-bfs-o-n-no-deque",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing BFS to access nodes level by level. Calculate the sum of each level in first iteration, and subtract the value of `currrent node and its brother` to get the `cousin sum` in second iteration.\\n\\nInstead of using a deque, I use two variables, `cur_level` and `next_level`. This is also a queue because we append children to `next_level` while iterating `cur_level`, and disregard the original `cur_level` and reassign `next_level` to `cur_level` when iteration is done.\\n\\n**First For-Loop:**\\nCalculate the sum of current level, and append the children along with sum of its left child\\'s value and right child\\'s value. If a child is missing, we treat its value as 0. The reason we push the sum of children is `cousin_sum = level_sum - brother_sum`.\\n\\n**Second For-Loop:**\\nUse the formula `cousin_sum = level_sum - brother_sum` to get the cousin sum for each node and update the value of each node.\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        # find cur level sum\\n        # when pushing the node, push the sum of its brother also, so we can get the sum of cousins by substracting it\\n        \\n        cur_level, next_level = [[root, root.val]], []\\n        while cur_level:\\n            level_sum = 0\\n            # calculate current level sum and push the next level to queue\\n            for [node, brother_sum] in cur_level:\\n                level_sum += node.val\\n\\n                left_val = node.left.val if node.left else 0\\n                right_val = node.right.val if node.right else 0\\n                brother_sum = left_val + right_val\\n                if node.left:\\n                    next_level.append([node.left, brother_sum])\\n                if node.right:\\n                    next_level.append([node.right, brother_sum])\\n\\n            # replace the value of current level nodes\\n            for [node, brother_sum] in cur_level:\\n                node.val = level_sum - brother_sum\\n            \\n            cur_level, next_level = next_level, []\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        # find cur level sum\\n        # when pushing the node, push the sum of its brother also, so we can get the sum of cousins by substracting it\\n        \\n        cur_level, next_level = [[root, root.val]], []\\n        while cur_level:\\n            level_sum = 0\\n            # calculate current level sum and push the next level to queue\\n            for [node, brother_sum] in cur_level:\\n                level_sum += node.val\\n\\n                left_val = node.left.val if node.left else 0\\n                right_val = node.right.val if node.right else 0\\n                brother_sum = left_val + right_val\\n                if node.left:\\n                    next_level.append([node.left, brother_sum])\\n                if node.right:\\n                    next_level.append([node.right, brother_sum])\\n\\n            # replace the value of current level nodes\\n            for [node, brother_sum] in cur_level:\\n                node.val = level_sum - brother_sum\\n            \\n            cur_level, next_level = next_level, []\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747073,
                "title": "level-order-traversal-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(N)*log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log(N))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<pair<TreeNode*,int>> curr,temp,empty;\\n        \\n        curr.push_back({root,0});\\n        int sum=0;\\n        int a,b;\\n        while(curr.size()){\\n            temp=empty;\\n            sum=0;\\n            for(int i=0;i<curr.size();i++){\\n                sum+=curr[i].first->val;\\n                if(curr[i].first->left){\\n                    if(curr[i].first->right)\\n                       temp.push_back({curr[i].first->left,curr[i].first->right->val}); \\n                    else \\n                       temp.push_back({curr[i].first->left,0}); \\n                }\\n                if(curr[i].first->right){\\n                    if(curr[i].first->left)\\n                       temp.push_back({curr[i].first->right,curr[i].first->left->val});\\n                    else\\n                       temp.push_back({curr[i].first->right,0}); \\n                }\\n            }\\n\\n            for(int i=0;i<curr.size();i++){\\n                a=curr[i].first->val;\\n                b=curr[i].second;\\n                curr[i].first->val=sum-a-b;\\n            }\\n\\n            curr=temp;\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<pair<TreeNode*,int>> curr,temp,empty;\\n        \\n        curr.push_back({root,0});\\n        int sum=0;\\n        int a,b;\\n        while(curr.size()){\\n            temp=empty;\\n            sum=0;\\n            for(int i=0;i<curr.size();i++){\\n                sum+=curr[i].first->val;\\n                if(curr[i].first->left){\\n                    if(curr[i].first->right)\\n                       temp.push_back({curr[i].first->left,curr[i].first->right->val}); \\n                    else \\n                       temp.push_back({curr[i].first->left,0}); \\n                }\\n                if(curr[i].first->right){\\n                    if(curr[i].first->left)\\n                       temp.push_back({curr[i].first->right,curr[i].first->left->val});\\n                    else\\n                       temp.push_back({curr[i].first->right,0}); \\n                }\\n            }\\n\\n            for(int i=0;i<curr.size();i++){\\n                a=curr[i].first->val;\\n                b=curr[i].second;\\n                curr[i].first->val=sum-a-b;\\n            }\\n\\n            curr=temp;\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742685,
                "title": "2dfs-refined",
                "content": "# Intuition\\ngot the approach from the solution 2DFS, but refined the code and tried to make it more reable\\n\\n# Approach\\ncreate sums of each level\\ncreate node and node value has hashmap\\nand in second DFS, just used the recursion call stack to get the parent left and right, to substract their values\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\nvar replaceValueInTree = function(root) {\\n    const levelSums = new Map();\\n    const nodeValues = new Map();\\n    const createLevelSums = (node, level) => {\\n        if(!node) return;\\n        nodeValues.set(node,node.val);\\n        if(!levelSums.has(level)) levelSums.set(level,0);\\n        levelSums.set(level,node.val + levelSums.get(level));\\n        createLevelSums(node.left,level+1);\\n        createLevelSums(node.right, level+1);\\n    }\\n\\n    const refineBinaryTree = (node,level,parent) => {\\n        if(!node) return;\\n        if(!parent) node.val = 0;\\n        else {\\n            let sum = levelSums.get(level);\\n            let left = parent.left;\\n            let right = parent.right;\\n            if(left) sum-=nodeValues.get(left);\\n            if(right) sum-=nodeValues.get(right);\\n            node.val = sum;\\n        }\\n        refineBinaryTree(node.left,level+1,node);\\n        refineBinaryTree(node.right,level+1,node);\\n    }\\n\\n    createLevelSums(root,0);\\n    refineBinaryTree(root,0,null);\\n    return root;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\nvar replaceValueInTree = function(root) {\\n    const levelSums = new Map();\\n    const nodeValues = new Map();\\n    const createLevelSums = (node, level) => {\\n        if(!node) return;\\n        nodeValues.set(node,node.val);\\n        if(!levelSums.has(level)) levelSums.set(level,0);\\n        levelSums.set(level,node.val + levelSums.get(level));\\n        createLevelSums(node.left,level+1);\\n        createLevelSums(node.right, level+1);\\n    }\\n\\n    const refineBinaryTree = (node,level,parent) => {\\n        if(!node) return;\\n        if(!parent) node.val = 0;\\n        else {\\n            let sum = levelSums.get(level);\\n            let left = parent.left;\\n            let right = parent.right;\\n            if(left) sum-=nodeValues.get(left);\\n            if(right) sum-=nodeValues.get(right);\\n            node.val = sum;\\n        }\\n        refineBinaryTree(node.left,level+1,node);\\n        refineBinaryTree(node.right,level+1,node);\\n    }\\n\\n    createLevelSums(root,0);\\n    refineBinaryTree(root,0,null);\\n    return root;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3724125,
                "title": "python-linear-time-in-place-modification-with-explanation",
                "content": "# Intuition\\nLet\\'s take a look at some level of this binary tree and their parents. \\n\\n```\\n   4      5      6      7          - parents of that level\\n  / \\\\    / \\\\    / \\\\    / \\\\\\n 8   9  10 11  12 13  14  15       - our level\\n```\\n\\nWe can have this information by traversing the tree level by level in BFS fashion. When we cover this level, we store two additional pieces of information:\\n - total sum in the level `(8 + 9 + 10 + ... + 15)`\\n - dictionary which maps parent to a sum of children `4 -> (8 + 9), ..., 6 -> (12 + 13)`\\n\\nThen using this information we can find the updated value of the node is `node.val = total_sum - parent_to_sum[parent]`\\n\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$\\n\\n# Code\\n```\\nclass Solution:\\n  def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n    frontier = [(root, -1)]\\n\\n    while frontier:\\n      new_frontier, total_sum, parent_to_sum = [], 0, {}\\n      for (node, parent) in frontier:\\n        total_sum += node.val\\n        parent_to_sum[parent] = parent_to_sum.get(parent, 0) + node.val\\n\\n        if node.left:\\n          new_frontier.append((node.left, node))\\n        if node.right:\\n          new_frontier.append((node.right, node))\\n      \\n      for (node, parent) in frontier:\\n        node.val = total_sum - parent_to_sum[parent]\\n\\n      frontier = new_frontier\\n    \\n    return root\\n      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n   4      5      6      7          - parents of that level\\n  / \\\\    / \\\\    / \\\\    / \\\\\\n 8   9  10 11  12 13  14  15       - our level\\n```\n```\\nclass Solution:\\n  def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n    frontier = [(root, -1)]\\n\\n    while frontier:\\n      new_frontier, total_sum, parent_to_sum = [], 0, {}\\n      for (node, parent) in frontier:\\n        total_sum += node.val\\n        parent_to_sum[parent] = parent_to_sum.get(parent, 0) + node.val\\n\\n        if node.left:\\n          new_frontier.append((node.left, node))\\n        if node.right:\\n          new_frontier.append((node.right, node))\\n      \\n      for (node, parent) in frontier:\\n        node.val = total_sum - parent_to_sum[parent]\\n\\n      frontier = new_frontier\\n    \\n    return root\\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709342,
                "title": "go-level-order-traversal-then-dfs",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc calculateCousinsSum(node *TreeNode, depth int, m map[int]int) {\\n\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\tif depth > 1 {\\n\\t\\tm[depth] += node.Val\\n\\t}\\n\\n\\tcalculateCousinsSum(node.Left, depth+1, m)\\n\\tcalculateCousinsSum(node.Right, depth+1, m)\\n}\\n\\nfunc replaceValueInTreeUtil(node *TreeNode, depth int, m map[int]int) {\\n\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\tif depth == 0 {\\n\\t\\tnode.Val = 0\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tnode.Left.Val = 0\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tnode.Right.Val = 0\\n\\t\\t}\\n\\t} else {\\n\\n\\t\\tsiblingsSum := 0\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tsiblingsSum += node.Left.Val\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tsiblingsSum += node.Right.Val\\n\\t\\t}\\n\\n\\t\\tcousinsSum := m[depth+1] - siblingsSum\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tnode.Left.Val = cousinsSum\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tnode.Right.Val = cousinsSum\\n\\t\\t}\\n\\t}\\n\\n\\tdepth++\\n\\n\\treplaceValueInTreeUtil(node.Left, depth, m)\\n\\treplaceValueInTreeUtil(node.Right, depth, m)\\n}\\n\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n\\tm := make(map[int]int)\\n\\n\\tcalculateCousinsSum(root, 0, m)\\n\\treplaceValueInTreeUtil(root, 0, m)\\n\\n\\treturn root\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc calculateCousinsSum(node *TreeNode, depth int, m map[int]int) {\\n\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\tif depth > 1 {\\n\\t\\tm[depth] += node.Val\\n\\t}\\n\\n\\tcalculateCousinsSum(node.Left, depth+1, m)\\n\\tcalculateCousinsSum(node.Right, depth+1, m)\\n}\\n\\nfunc replaceValueInTreeUtil(node *TreeNode, depth int, m map[int]int) {\\n\\n\\tif node == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\tif depth == 0 {\\n\\t\\tnode.Val = 0\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tnode.Left.Val = 0\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tnode.Right.Val = 0\\n\\t\\t}\\n\\t} else {\\n\\n\\t\\tsiblingsSum := 0\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tsiblingsSum += node.Left.Val\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tsiblingsSum += node.Right.Val\\n\\t\\t}\\n\\n\\t\\tcousinsSum := m[depth+1] - siblingsSum\\n\\n\\t\\tif node.Left != nil {\\n\\t\\t\\tnode.Left.Val = cousinsSum\\n\\t\\t}\\n\\n\\t\\tif node.Right != nil {\\n\\t\\t\\tnode.Right.Val = cousinsSum\\n\\t\\t}\\n\\t}\\n\\n\\tdepth++\\n\\n\\treplaceValueInTreeUtil(node.Left, depth, m)\\n\\treplaceValueInTreeUtil(node.Right, depth, m)\\n}\\n\\nfunc replaceValueInTree(root *TreeNode) *TreeNode {\\n\\tm := make(map[int]int)\\n\\n\\tcalculateCousinsSum(root, 0, m)\\n\\treplaceValueInTreeUtil(root, 0, m)\\n\\n\\treturn root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683893,
                "title": "simple-bfs-solution-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTraverse the tree by bfs approach and replace each roots value with the sum of its sibling value .Also maintain a currS variable which calculates the sum of all the nodes at a particular level .Finally just substract the replaced value with the currS for each node.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int preS = root->val;\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            int currS = 0;\\n            while(s-- >0)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                temp->val = preS - temp->val;\\n                int sibS = temp->left ? temp->left->val:0;\\n                sibS += temp->right ? temp->right->val:0;\\n                if(temp->left!=NULL)\\n                {\\n                currS = currS + temp->left->val;\\n                temp->left->val=sibS;\\n                q.push(temp->left);\\n                }\\n                if(temp->right!=NULL)\\n                {\\n                currS = currS + temp->right->val;\\n                temp->right->val=sibS;\\n                q.push(temp->right);\\n                }\\n            }\\n            preS = currS;\\n            \\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int preS = root->val;\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            int currS = 0;\\n            while(s-- >0)\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                temp->val = preS - temp->val;\\n                int sibS = temp->left ? temp->left->val:0;\\n                sibS += temp->right ? temp->right->val:0;\\n                if(temp->left!=NULL)\\n                {\\n                currS = currS + temp->left->val;\\n                temp->left->val=sibS;\\n                q.push(temp->left);\\n                }\\n                if(temp->right!=NULL)\\n                {\\n                currS = currS + temp->right->val;\\n                temp->right->val=sibS;\\n                q.push(temp->right);\\n                }\\n            }\\n            preS = currS;\\n            \\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678189,
                "title": "c-level-order-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void UpdateTree(TreeNode* root, int level, vector<long long>& levelSum)\\n    {\\n        if(root==NULL)    return;\\n        int sum = 0;\\n        if(root->left)    sum += root->left->val;\\n        if(root->right)   sum += root->right->val;\\n        if(root->left)    root->left->val = levelSum[level+1] - sum;\\n        if(root->right)   root->right->val = levelSum[level+1] - sum;\\n\\n        UpdateTree(root->left, level+1, levelSum);\\n        UpdateTree(root->right, level+1, levelSum);  \\n    }\\n\\n    vector<long long> CalculateLevelSum(TreeNode* root)\\n    {\\n        vector<long long> levelSum;\\n        queue<TreeNode *> q; \\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            int sum = 0;\\n            for(int i=0; i<n; i++)\\n            {\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                sum += curr->val;\\n                if(curr->left)    q.push(curr->left);\\n                if(curr->right)   q.push(curr->right);\\n            }\\n\\n            levelSum.push_back(sum);\\n        }\\n\\n        return levelSum;\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<long long> levelSum = CalculateLevelSum(root);\\n        int level = 0;\\n        UpdateTree(root, level, levelSum);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void UpdateTree(TreeNode* root, int level, vector<long long>& levelSum)\\n    {\\n        if(root==NULL)    return;\\n        int sum = 0;\\n        if(root->left)    sum += root->left->val;\\n        if(root->right)   sum += root->right->val;\\n        if(root->left)    root->left->val = levelSum[level+1] - sum;\\n        if(root->right)   root->right->val = levelSum[level+1] - sum;\\n\\n        UpdateTree(root->left, level+1, levelSum);\\n        UpdateTree(root->right, level+1, levelSum);  \\n    }\\n\\n    vector<long long> CalculateLevelSum(TreeNode* root)\\n    {\\n        vector<long long> levelSum;\\n        queue<TreeNode *> q; \\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            int sum = 0;\\n            for(int i=0; i<n; i++)\\n            {\\n                TreeNode* curr = q.front();\\n                q.pop();\\n                sum += curr->val;\\n                if(curr->left)    q.push(curr->left);\\n                if(curr->right)   q.push(curr->right);\\n            }\\n\\n            levelSum.push_back(sum);\\n        }\\n\\n        return levelSum;\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<long long> levelSum = CalculateLevelSum(root);\\n        int level = 0;\\n        UpdateTree(root, level, levelSum);\\n        root->val = 0;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675313,
                "title": "shortest-code-using-level-order-traversal",
                "content": "# Intuition\\nlevel order traversal \\n\\n# Approach\\nnode\\'s value = sum of all the nodes in that level - (sum of node\\' value and its siblings value i.e. they both are the left and right child of the same node\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^l) ; l = max depth of binary tree.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {     \\n\\n        queue<pair<TreeNode*,int>>q;\\n      \\n        q.push({root,0});\\n        int prev=0;\\n        while(!q.empty()){\\n            \\n            int n = q.size();\\n            \\n            int Tsum=0;\\n            for(int i=0; i<n; i++){\\n                int sum=0;\\n                auto [node,rootSum] = q.front();\\n                q.pop();\\n                \\n                if(!node) continue;\\n                \\n                node->val= prev - rootSum; // total sum of level - sibling sum.\\n                \\n                if(node->left)\\n                    sum+= node->left->val;\\n                \\n                if(node->right)\\n                    sum+= node->right->val;\\n                Tsum+= sum;\\n                \\n                q.push({node->left,sum}); // sibling sum\\n                q.push({node->right, sum});\\n            }\\n            prev = Tsum; // storing the total sum of a level so that we can use in the next iteration.\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {     \\n\\n        queue<pair<TreeNode*,int>>q;\\n      \\n        q.push({root,0});\\n        int prev=0;\\n        while(!q.empty()){\\n            \\n            int n = q.size();\\n            \\n            int Tsum=0;\\n            for(int i=0; i<n; i++){\\n                int sum=0;\\n                auto [node,rootSum] = q.front();\\n                q.pop();\\n                \\n                if(!node) continue;\\n                \\n                node->val= prev - rootSum; // total sum of level - sibling sum.\\n                \\n                if(node->left)\\n                    sum+= node->left->val;\\n                \\n                if(node->right)\\n                    sum+= node->right->val;\\n                Tsum+= sum;\\n                \\n                q.push({node->left,sum}); // sibling sum\\n                q.push({node->right, sum});\\n            }\\n            prev = Tsum; // storing the total sum of a level so that we can use in the next iteration.\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671958,
                "title": "simple-bfs",
                "content": "# Intuition\\nBreadth first search\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if root == None:\\n            return root\\n        root.val = 0\\n        parents = collections.deque()\\n        parents.append(root)\\n        while parents:\\n            children = []\\n            total = 0\\n            for parent in parents:\\n                if parent.left:\\n                    children.append(parent.left)\\n                    total += parent.left.val\\n                if parent.right:\\n                    children.append(parent.right)\\n                    total += parent.right.val\\n            while parents:\\n                parent = parents.popleft()\\n                subtotal = 0\\n                if parent.left:\\n                    subtotal += parent.left.val\\n                if parent.right:\\n                    subtotal += parent.right.val\\n                    parent.right.val = total - subtotal\\n                if parent.left:\\n                    parent.left.val = total - subtotal\\n            parents.extend(children)\\n        return root\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        if root == None:\\n            return root\\n        root.val = 0\\n        parents = collections.deque()\\n        parents.append(root)\\n        while parents:\\n            children = []\\n            total = 0\\n            for parent in parents:\\n                if parent.left:\\n                    children.append(parent.left)\\n                    total += parent.left.val\\n                if parent.right:\\n                    children.append(parent.right)\\n                    total += parent.right.val\\n            while parents:\\n                parent = parents.popleft()\\n                subtotal = 0\\n                if parent.left:\\n                    subtotal += parent.left.val\\n                if parent.right:\\n                    subtotal += parent.right.val\\n                    parent.right.val = total - subtotal\\n                if parent.left:\\n                    parent.left.val = total - subtotal\\n            parents.extend(children)\\n        return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668081,
                "title": "bfs-w-level-sums",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst replaceValueInTree = (root) => {\\n  let queue = [[root, root.val]];\\n  let currentSum = root.val;\\n  while (queue.length) {\\n    let nextSum = 0;\\n    const nextLevel = [];\\n    for (let [node, sum] of queue) {\\n      const leftVal = node.left ? node.left.val : 0;\\n      const rightVal = node.right ? node.right.val : 0;\\n      node.val = currentSum - sum;\\n      if (node.left) {\\n        nextSum += node.left.val;\\n        nextLevel.push([node.left, leftVal + rightVal]);\\n      }\\n      if (node.right) {\\n        nextSum += node.right.val;\\n        nextLevel.push([node.right, leftVal + rightVal]);\\n      }\\n    }\\n    currentSum = nextSum;\\n    queue = nextLevel;\\n  }\\n  return root;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst replaceValueInTree = (root) => {\\n  let queue = [[root, root.val]];\\n  let currentSum = root.val;\\n  while (queue.length) {\\n    let nextSum = 0;\\n    const nextLevel = [];\\n    for (let [node, sum] of queue) {\\n      const leftVal = node.left ? node.left.val : 0;\\n      const rightVal = node.right ? node.right.val : 0;\\n      node.val = currentSum - sum;\\n      if (node.left) {\\n        nextSum += node.left.val;\\n        nextLevel.push([node.left, leftVal + rightVal]);\\n      }\\n      if (node.right) {\\n        nextSum += node.right.val;\\n        nextLevel.push([node.right, leftVal + rightVal]);\\n      }\\n    }\\n    currentSum = nextSum;\\n    queue = nextLevel;\\n  }\\n  return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3667230,
                "title": "simple-level-sum-double-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOverwriting values as you do a single traversal can be difficult to wrap your head around, and is prone to coding errors. Once you understand that the final value of a node is\\n\\n```\\nnode_val = sum_of_level - original_self_val - sibling_val\\n```\\n\\nthings get much simpler.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI separated out level sum code and overwrite into separate methods for clarity. A single method with a long parameter list, and lots of ifs may have been feasible, but would be messy.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) - traverses all nodes twice\\n\\n- Space complexity:\\nO(Log(n)) additional space for level sums\\n**Additional stack space for recursion\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    level_sum = None\\n\\n    def lvl_sum_helper(self, node: Optional[TreeNode], level: int):\\n        if node is None:\\n            return\\n\\n        Solution.level_sum[level] += node.val\\n\\n        self.lvl_sum_helper(node.left, level+1)\\n        self.lvl_sum_helper(node.right, level+1)\\n\\n    def write_trav_helper(self, node: Optional[TreeNode], level: int, sub: int) -> None:\\n        if node is None:\\n            return\\n\\n        node.val = Solution.level_sum[level] - sub\\n\\n        left_val = node.left.val if node.left else 0\\n        right_val = node.right.val if node.right else 0\\n\\n        self.write_trav_helper(node.left, level+1, left_val+right_val)\\n        self.write_trav_helper(node.right, level+1, left_val+right_val)\\n\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        Solution.level_sum = [0]*(10**5)\\n        \\n        # First pass, we iterate through and find original level sums\\n        self.lvl_sum_helper(root, 0)\\n\\n        # Second pass we overwrite, value should be level_sum-self-sibs\\n        self.write_trav_helper(root, 0, root.val)\\n\\n        return root\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nnode_val = sum_of_level - original_self_val - sibling_val\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    level_sum = None\\n\\n    def lvl_sum_helper(self, node: Optional[TreeNode], level: int):\\n        if node is None:\\n            return\\n\\n        Solution.level_sum[level] += node.val\\n\\n        self.lvl_sum_helper(node.left, level+1)\\n        self.lvl_sum_helper(node.right, level+1)\\n\\n    def write_trav_helper(self, node: Optional[TreeNode], level: int, sub: int) -> None:\\n        if node is None:\\n            return\\n\\n        node.val = Solution.level_sum[level] - sub\\n\\n        left_val = node.left.val if node.left else 0\\n        right_val = node.right.val if node.right else 0\\n\\n        self.write_trav_helper(node.left, level+1, left_val+right_val)\\n        self.write_trav_helper(node.right, level+1, left_val+right_val)\\n\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        Solution.level_sum = [0]*(10**5)\\n        \\n        # First pass, we iterate through and find original level sums\\n        self.lvl_sum_helper(root, 0)\\n\\n        # Second pass we overwrite, value should be level_sum-self-sibs\\n        self.write_trav_helper(root, 0, root.val)\\n\\n        return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666968,
                "title": "beats-100-java-clean-solution-2-dfs-with-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root.left == null && root.right == null)\\n            return new TreeNode(0);\\n        TreeNode nroot = null;\\n        dfs1(root, 0);\\n        dfs2(root, 0, root.val);\\n        return root;\\n    }\\n    private void dfs1(TreeNode root, int depth){\\n        if(root == null)\\n            return;\\n        map.put(depth, map.getOrDefault(depth, 0) + root.val);\\n        dfs1(root.left, depth+1);\\n        dfs1(root.right, depth+1);    \\n    }\\n    private void dfs2(TreeNode root, int depth, int sibling){\\n        if(root == null)\\n            return;\\n        \\n        root.val = map.get(depth) - sibling;\\n        sibling = (root.left == null ? 0 : root.left.val) + (root.right == null ? 0 : root.right.val);\\n        dfs2(root.left, depth+1, sibling);\\n        dfs2(root.right, depth+1, sibling);                    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer, Integer> map = new HashMap<>();\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root.left == null && root.right == null)\\n            return new TreeNode(0);\\n        TreeNode nroot = null;\\n        dfs1(root, 0);\\n        dfs2(root, 0, root.val);\\n        return root;\\n    }\\n    private void dfs1(TreeNode root, int depth){\\n        if(root == null)\\n            return;\\n        map.put(depth, map.getOrDefault(depth, 0) + root.val);\\n        dfs1(root.left, depth+1);\\n        dfs1(root.right, depth+1);    \\n    }\\n    private void dfs2(TreeNode root, int depth, int sibling){\\n        if(root == null)\\n            return;\\n        \\n        root.val = map.get(depth) - sibling;\\n        sibling = (root.left == null ? 0 : root.left.val) + (root.right == null ? 0 : root.right.val);\\n        dfs2(root.left, depth+1, sibling);\\n        dfs2(root.right, depth+1, sibling);                    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664398,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>pq;\\n\\n        if(!root){\\n            return root;\\n        }\\n        pq.push(root);\\n\\n        while(pq.size()){\\n            int size = pq.size();\\n            int sum = 0;\\n            vector<pair<TreeNode*,int>>M;\\n            while(size--){\\n                TreeNode* temp = pq.front();\\n                pq.pop();\\n                int curr_sum = 0;\\n                if(temp -> left){\\n                    sum += temp -> left->val;\\n                    curr_sum += temp -> left->val; \\n                    pq.push(temp->left);\\n                }\\n                if(temp -> right){\\n                    sum += temp -> right->val;\\n                    curr_sum += temp -> right->val; \\n                    pq.push(temp->right);\\n                }\\n                M.push_back({temp,curr_sum});\\n            }\\n            for(int i=0;i<M.size();i++){\\n                TreeNode* curr = M[i].first;\\n                int total = M[i].second;\\n                if(curr -> left){\\n                    curr->left->val = sum-total;\\n                }\\n                if(curr -> right){\\n                    curr->right->val = sum-total;\\n                }\\n            }\\n        }\\n        root->val =  0;\\n        return root;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<TreeNode*>pq;\\n\\n        if(!root){\\n            return root;\\n        }\\n        pq.push(root);\\n\\n        while(pq.size()){\\n            int size = pq.size();\\n            int sum = 0;\\n            vector<pair<TreeNode*,int>>M;\\n            while(size--){\\n                TreeNode* temp = pq.front();\\n                pq.pop();\\n                int curr_sum = 0;\\n                if(temp -> left){\\n                    sum += temp -> left->val;\\n                    curr_sum += temp -> left->val; \\n                    pq.push(temp->left);\\n                }\\n                if(temp -> right){\\n                    sum += temp -> right->val;\\n                    curr_sum += temp -> right->val; \\n                    pq.push(temp->right);\\n                }\\n                M.push_back({temp,curr_sum});\\n            }\\n            for(int i=0;i<M.size();i++){\\n                TreeNode* curr = M[i].first;\\n                int total = M[i].second;\\n                if(curr -> left){\\n                    curr->left->val = sum-total;\\n                }\\n                if(curr -> right){\\n                    curr->right->val = sum-total;\\n                }\\n            }\\n        }\\n        root->val =  0;\\n        return root;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651926,
                "title": "java-horizontal-level-sum",
                "content": "# Intuition\\nUse horizontal level sum\\n\\n# Approach\\nFind horizontal level sum, once you are ready with this then for each parent you need to get their children sum and update children with with new value which is horizontalLevelSum[depth+1]-childrenSum;\\nHere I used horizontalLevelSum[depth+1] instead of horizontalLevelSum[depth] because it\\'s easy to get both child from parent and since you\\'re at the parent level so to get children\\'s level sum the you have to increase depth by 1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> horizontalSum;\\n    public void traverse(TreeNode root, int depth) {\\n        if(root == null) {\\n            return;\\n        }\\n        if(depth<horizontalSum.size()) {\\n            horizontalSum.set(depth, horizontalSum.get(depth)+root.val);\\n        } else {\\n            horizontalSum.add(root.val);\\n        }\\n        traverse(root.left, depth+1);\\n        traverse(root.right, depth+1);\\n    }\\n    public void traverse1(TreeNode root, int depth) {\\n        if(root == null) {\\n            return;\\n        }\\n        if(depth>0) {\\n            int sum=0;\\n            if(root.left!=null) {\\n                sum+=root.left.val;\\n            }\\n            if(root.right!=null) {\\n                sum+=root.right.val;\\n            }\\n            if(root.left!=null) {\\n                root.left.val=horizontalSum.get(depth+1)-sum;\\n            }\\n            if(root.right!=null) {\\n                root.right.val=horizontalSum.get(depth+1)-sum;\\n            }\\n        }\\n        traverse1(root.left, depth+1);\\n        traverse1(root.right, depth+1);\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        horizontalSum = new ArrayList();\\n        root.val = 0;\\n        if(root.left!=null) {\\n            root.left.val = 0;\\n        }\\n        if(root.right!=null) {\\n            root.right.val = 0;\\n        }\\n        traverse(root, 0);\\n        traverse1(root,0);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> horizontalSum;\\n    public void traverse(TreeNode root, int depth) {\\n        if(root == null) {\\n            return;\\n        }\\n        if(depth<horizontalSum.size()) {\\n            horizontalSum.set(depth, horizontalSum.get(depth)+root.val);\\n        } else {\\n            horizontalSum.add(root.val);\\n        }\\n        traverse(root.left, depth+1);\\n        traverse(root.right, depth+1);\\n    }\\n    public void traverse1(TreeNode root, int depth) {\\n        if(root == null) {\\n            return;\\n        }\\n        if(depth>0) {\\n            int sum=0;\\n            if(root.left!=null) {\\n                sum+=root.left.val;\\n            }\\n            if(root.right!=null) {\\n                sum+=root.right.val;\\n            }\\n            if(root.left!=null) {\\n                root.left.val=horizontalSum.get(depth+1)-sum;\\n            }\\n            if(root.right!=null) {\\n                root.right.val=horizontalSum.get(depth+1)-sum;\\n            }\\n        }\\n        traverse1(root.left, depth+1);\\n        traverse1(root.right, depth+1);\\n    }\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        horizontalSum = new ArrayList();\\n        root.val = 0;\\n        if(root.left!=null) {\\n            root.left.val = 0;\\n        }\\n        if(root.right!=null) {\\n            root.right.val = 0;\\n        }\\n        traverse(root, 0);\\n        traverse1(root,0);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646700,
                "title": "python3-w-detailed-explanation",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        from collections import deque\\n        \\n        q = deque([root])\\n        l_sum = []\\n        \\n\\t\\t# Use BFS to collect the sum of each level\\n        while q:\\n            _sum = 0\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                _sum += node.val\\n                \\n                if node.left:\\n                    q.append(node.left)\\n                    \\n                if node.right:\\n                    q.append(node.right)\\n                    \\n            l_sum.append(_sum)\\n            \\n        def helper(node, sib_sum, level):\\n            if not node:\\n                return\\n            \\n\\t\\t\\t# `sib_sum` here consists of the values of every nodes under one parent\\n\\t\\t\\t# i.e. value of the node itself and its sibling nodes.\\n            node.val = l_sum[level] - sib_sum\\n            \\n            sib_sum = 0\\n            \\n            if node.left:\\n                sib_sum += node.left.val\\n                \\n            if node.right:\\n                sib_sum += node.right.val\\n            \\n            helper(node.left, sib_sum, level+1)\\n            helper(node.right, sib_sum, level+1)\\n            \\n\\t\\t# Use DFS to go through every node to update its value\\n\\t\\t# The key point is that - \\n\\t\\t# Sum of one level consists of \\n\\t\\t# 1. value of the node itself\\n\\t\\t# 2. values of the node\\'s sibilings (same parent) \\n\\t\\t# 3. and values of the node\\'s cousins (different parent)\\n        helper(root, root.val, 0)\\n        \\n        return root\\n```\\t\\t\\n\\nTime complexity: O(2n) = O(n) - we traverse the tree twice to count the sum of each level and update the values\\nSpace complexity: O(n) - we used queue to store nodes and list to store sum of each level",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        \\n        from collections import deque\\n        \\n        q = deque([root])\\n        l_sum = []\\n        \\n\\t\\t# Use BFS to collect the sum of each level\\n        while q:\\n            _sum = 0\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                _sum += node.val\\n                \\n                if node.left:\\n                    q.append(node.left)\\n                    \\n                if node.right:\\n                    q.append(node.right)\\n                    \\n            l_sum.append(_sum)\\n            \\n        def helper(node, sib_sum, level):\\n            if not node:\\n                return\\n            \\n\\t\\t\\t# `sib_sum` here consists of the values of every nodes under one parent\\n\\t\\t\\t# i.e. value of the node itself and its sibling nodes.\\n            node.val = l_sum[level] - sib_sum\\n            \\n            sib_sum = 0\\n            \\n            if node.left:\\n                sib_sum += node.left.val\\n                \\n            if node.right:\\n                sib_sum += node.right.val\\n            \\n            helper(node.left, sib_sum, level+1)\\n            helper(node.right, sib_sum, level+1)\\n            \\n\\t\\t# Use DFS to go through every node to update its value\\n\\t\\t# The key point is that - \\n\\t\\t# Sum of one level consists of \\n\\t\\t# 1. value of the node itself\\n\\t\\t# 2. values of the node\\'s sibilings (same parent) \\n\\t\\t# 3. and values of the node\\'s cousins (different parent)\\n        helper(root, root.val, 0)\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644460,
                "title": "if-you-still-didn-t-get-it-see-this",
                "content": "# Intuition\\nIf you get the sum of all values of nodes in a level and for any node you subtract the value of itself and its siblings from the total sum of nodes of it level, you get the sum of its cousins. You update the node value with that answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all you need to get the sum of values of all nodes in a level and for that purpose we use a map to store the sum level wise by calling the sum fn(dfs).\\n\\nAfter the first function call(dfs), we run another dfs call(solve fn), where we update the node values with the sum of their cousin nodes.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe Sum function will run max O(n) times, as it will visit each node.\\nThe solve function shall run for another O(n) times as we traverse each node once.\\n\\nOverall T.C. = O(n)\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe hashmap shall store max n nodes if the tree is skewed i.e. n different levels so,\\n\\nS.C. = O(n)\\n(Ignoring the stack space used due to the function calls)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n\\n        sum(root, 0, mp);\\n        solve(root, 0,mp);\\n        return root;\\n        \\n    }\\n\\n\\n    void solve(TreeNode* root, int level, unordered_map<int,int>& mp){\\n        if(!root) return;\\n\\n        level += 1;\\n\\n        if(level == 1){\\n            root->val = 0;\\n        }\\n        int right_val = 0,left_val= 0 ;\\n\\n        if(root->left){\\n            left_val = root->left->val;\\n            if(root->right){\\n                right_val = root->right->val;\\n            }\\n            root->left->val = mp[level+1] - (root->left->val + right_val);\\n        }\\n\\n        if(root->right){\\n           \\n           \\n            \\n            root->right->val = mp[level+1] - (root->right->val + left_val);\\n        }\\n\\n        solve(root->left,level,mp);\\n        solve(root->right,level,mp);\\n\\n        return;\\n\\n\\n    }\\n\\n    void sum(TreeNode* root, int level,  unordered_map<int,int>& mp){\\n        if(!root) return;\\n\\n        level += 1;\\n\\n        sum(root -> left, level, mp);\\n        sum(root->right,level,mp);\\n\\n        if(mp.find(level) != mp.end()){\\n            mp[level] += root->val;\\n        }else{\\n            mp[level]=root->val;\\n        }\\n\\n        return;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        unordered_map<int,int> mp;\\n\\n        sum(root, 0, mp);\\n        solve(root, 0,mp);\\n        return root;\\n        \\n    }\\n\\n\\n    void solve(TreeNode* root, int level, unordered_map<int,int>& mp){\\n        if(!root) return;\\n\\n        level += 1;\\n\\n        if(level == 1){\\n            root->val = 0;\\n        }\\n        int right_val = 0,left_val= 0 ;\\n\\n        if(root->left){\\n            left_val = root->left->val;\\n            if(root->right){\\n                right_val = root->right->val;\\n            }\\n            root->left->val = mp[level+1] - (root->left->val + right_val);\\n        }\\n\\n        if(root->right){\\n           \\n           \\n            \\n            root->right->val = mp[level+1] - (root->right->val + left_val);\\n        }\\n\\n        solve(root->left,level,mp);\\n        solve(root->right,level,mp);\\n\\n        return;\\n\\n\\n    }\\n\\n    void sum(TreeNode* root, int level,  unordered_map<int,int>& mp){\\n        if(!root) return;\\n\\n        level += 1;\\n\\n        sum(root -> left, level, mp);\\n        sum(root->right,level,mp);\\n\\n        if(mp.find(level) != mp.end()){\\n            mp[level] += root->val;\\n        }else{\\n            mp[level]=root->val;\\n        }\\n\\n        return;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642738,
                "title": "2-bfs",
                "content": "\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root->left && !root->right){\\n            root->val=0;\\n            return root;\\n        }\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int lvll=1;\\n        \\n        vector<long long>lvlsum;\\n        queue<TreeNode*>lvl;\\n        lvl.push(root);\\n        while(lvl.size()){\\n            int size=lvl.size();\\n            long long sum=0;\\n            while(size--){\\n                TreeNode*f=lvl.front();\\n                lvl.pop();\\n                sum+=f->val;\\n                if(f->left)lvl.push(f->left);\\n                if(f->right)lvl.push(f->right);\\n            }\\n            lvlsum.push_back(sum);\\n        }\\n        while(q.size()){\\n            int size=q.size();\\n            while(size--){\\n                TreeNode*f=q.front();\\n                q.pop();\\n                long long x=0;\\n                if(!f->left && !f->right)continue;\\n                if(f->left){\\n                    x+=f->left->val;\\n                    q.push(f->left);\\n                }\\n                if(f->right){\\n                    x+=f->right->val;\\n                    q.push(f->right);\\n                }\\n                // cout<<x<<endl;\\n                if(f->left)f->left->val=lvlsum[lvll]-x;\\n                if(f->right)f->right->val=lvlsum[lvll]-x;\\n            }\\n            lvll++;\\n        }\\n        root->val=0;\\n        return root;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if(!root->left && !root->right){\\n            root->val=0;\\n            return root;\\n        }\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        int lvll=1;\\n        \\n        vector<long long>lvlsum;\\n        queue<TreeNode*>lvl;\\n        lvl.push(root);\\n        while(lvl.size()){\\n            int size=lvl.size();\\n            long long sum=0;\\n            while(size--){\\n                TreeNode*f=lvl.front();\\n                lvl.pop();\\n                sum+=f->val;\\n                if(f->left)lvl.push(f->left);\\n                if(f->right)lvl.push(f->right);\\n            }\\n            lvlsum.push_back(sum);\\n        }\\n        while(q.size()){\\n            int size=q.size();\\n            while(size--){\\n                TreeNode*f=q.front();\\n                q.pop();\\n                long long x=0;\\n                if(!f->left && !f->right)continue;\\n                if(f->left){\\n                    x+=f->left->val;\\n                    q.push(f->left);\\n                }\\n                if(f->right){\\n                    x+=f->right->val;\\n                    q.push(f->right);\\n                }\\n                // cout<<x<<endl;\\n                if(f->left)f->left->val=lvlsum[lvll]-x;\\n                if(f->right)f->right->val=lvlsum[lvll]-x;\\n            }\\n            lvll++;\\n        }\\n        root->val=0;\\n        return root;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 3642198,
                "title": "bfs-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<vector<int>>arr;\\n        vector<int>tarr;\\n        vector<int>sumarr;\\n        int nnode=10001;\\n        int childSum=0,totsum=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        q.push(new TreeNode(nnode));\\n        q.push(NULL);\\n        arr.push_back({root->val});\\n        sumarr.push_back(root->val);\\n        while(!q.empty()){\\n            TreeNode* n=q.front();\\n            q.pop();\\n            if(n!=NULL && n->val!=nnode){\\n                childSum=0;\\n                if(n->left){\\n                    q.push(n->left);\\n                    childSum+=n->left->val;\\n                }\\n                if(n->right){\\n                    q.push(n->right);\\n                    childSum+=n->right->val;\\n                }\\n                totsum+= childSum;\\n                tarr.push_back(childSum); \\n                q.push(new TreeNode(nnode));       \\n            }\\n            else if(n!=NULL && n->val==nnode){\\n                childSum=0;\\n            }\\n            else if(!q.empty()){\\n                arr.push_back(tarr);\\n                sumarr.push_back(totsum);\\n                tarr.clear();\\n                totsum=0;\\n                childSum=0;\\n                q.push(NULL);\\n            }\\n        }\\n\\n        root->val=0;\\n        q.push(root);\\n        q.push(NULL);\\n        int lvl=1,indx=0;\\n        while(!q.empty()){\\n            TreeNode* n=q.front();\\n            q.pop();\\n            if(n!=NULL){\\n                //cout<<lvl<<\" \"<<sumarr[lvl]<<\" \"<<arr[lvl][indx]<<\"\\\\n\";\\n                if(n->left){\\n                    n->left->val=sumarr[lvl]-arr[lvl][indx];\\n                    q.push(n->left);\\n                }\\n                if(n->right)\\n                 {\\n                     n->right->val=sumarr[lvl]-arr[lvl][indx];\\n                     q.push(n->right);\\n                 }\\n                indx++;\\n            }\\n            else if(!q.empty()){\\n                q.push(NULL);\\n                indx=0;\\n                lvl++;\\n            }          \\n        }\\n        return root;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<vector<int>>arr;\\n        vector<int>tarr;\\n        vector<int>sumarr;\\n        int nnode=10001;\\n        int childSum=0,totsum=0;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        q.push(new TreeNode(nnode));\\n        q.push(NULL);\\n        arr.push_back({root->val});\\n        sumarr.push_back(root->val);\\n        while(!q.empty()){\\n            TreeNode* n=q.front();\\n            q.pop();\\n            if(n!=NULL && n->val!=nnode){\\n                childSum=0;\\n                if(n->left){\\n                    q.push(n->left);\\n                    childSum+=n->left->val;\\n                }\\n                if(n->right){\\n                    q.push(n->right);\\n                    childSum+=n->right->val;\\n                }\\n                totsum+= childSum;\\n                tarr.push_back(childSum); \\n                q.push(new TreeNode(nnode));       \\n            }\\n            else if(n!=NULL && n->val==nnode){\\n                childSum=0;\\n            }\\n            else if(!q.empty()){\\n                arr.push_back(tarr);\\n                sumarr.push_back(totsum);\\n                tarr.clear();\\n                totsum=0;\\n                childSum=0;\\n                q.push(NULL);\\n            }\\n        }\\n\\n        root->val=0;\\n        q.push(root);\\n        q.push(NULL);\\n        int lvl=1,indx=0;\\n        while(!q.empty()){\\n            TreeNode* n=q.front();\\n            q.pop();\\n            if(n!=NULL){\\n                //cout<<lvl<<\" \"<<sumarr[lvl]<<\" \"<<arr[lvl][indx]<<\"\\\\n\";\\n                if(n->left){\\n                    n->left->val=sumarr[lvl]-arr[lvl][indx];\\n                    q.push(n->left);\\n                }\\n                if(n->right)\\n                 {\\n                     n->right->val=sumarr[lvl]-arr[lvl][indx];\\n                     q.push(n->right);\\n                 }\\n                indx++;\\n            }\\n            else if(!q.empty()){\\n                q.push(NULL);\\n                indx=0;\\n                lvl++;\\n            }          \\n        }\\n        return root;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3642036,
                "title": "python-faster-than-98-bfs-precalculate-level-sum",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        if root.left:\\n            root.left.val = 0\\n        if root.right:\\n            root.right.val = 0\\n        cur_level = [(root.left, root.right)]\\n        while cur_level:\\n            next_level = []\\n            s = 0\\n            for node_info in cur_level:\\n                l, r = node_info\\n                if l:\\n                    s += l.val\\n                    next_level.append((l.left, l.right))\\n                if r:\\n                    s += r.val\\n                    next_level.append((r.left, r.right))\\n            \\n            for node_info in cur_level:\\n                l, r = node_info\\n                val = s - (l.val if l else 0) - (r.val if r else 0)\\n                if l:\\n                    l.val = val\\n                if r:\\n                    r.val = val\\n\\n            cur_level = next_level\\n\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        root.val = 0\\n        if root.left:\\n            root.left.val = 0\\n        if root.right:\\n            root.right.val = 0\\n        cur_level = [(root.left, root.right)]\\n        while cur_level:\\n            next_level = []\\n            s = 0\\n            for node_info in cur_level:\\n                l, r = node_info\\n                if l:\\n                    s += l.val\\n                    next_level.append((l.left, l.right))\\n                if r:\\n                    s += r.val\\n                    next_level.append((r.left, r.right))\\n            \\n            for node_info in cur_level:\\n                l, r = node_info\\n                val = s - (l.val if l else 0) - (r.val if r else 0)\\n                if l:\\n                    l.val = val\\n                if r:\\n                    r.val = val\\n\\n            cur_level = next_level\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641975,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n  public:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n      queue<TreeNode*> q;\\n      q.push(root);\\n      TreeNode* guard = root;\\n      vector<int> diff, level;\\n      diff.push_back(root->val);\\n      level.push_back(root->val);\\n      int i = 0, sum = 0, l = 0;\\n      while (!q.empty()) {\\n        TreeNode* c = q.front();\\n        q.pop();\\n        c->val = level[l] - diff[i++];\\n        int v = 0;\\n        if (c->left) {\\n          v += c->left->val;\\n          q.push(c->left);\\n        }\\n        if (c->right) {\\n          v += c->right->val;\\n          q.push(c->right);\\n        }\\n        if (c->left)\\n          diff.push_back(v);\\n        if (c->right)\\n          diff.push_back(v);\\n        sum += v;\\n        if (c == guard) {\\n          guard = !q.empty() ? q.back() : nullptr;\\n          level.push_back(sum);\\n          sum = 0;\\n          l++;\\n        }\\n      }\\n      return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n  public:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n      queue<TreeNode*> q;\\n      q.push(root);\\n      TreeNode* guard = root;\\n      vector<int> diff, level;\\n      diff.push_back(root->val);\\n      level.push_back(root->val);\\n      int i = 0, sum = 0, l = 0;\\n      while (!q.empty()) {\\n        TreeNode* c = q.front();\\n        q.pop();\\n        c->val = level[l] - diff[i++];\\n        int v = 0;\\n        if (c->left) {\\n          v += c->left->val;\\n          q.push(c->left);\\n        }\\n        if (c->right) {\\n          v += c->right->val;\\n          q.push(c->right);\\n        }\\n        if (c->left)\\n          diff.push_back(v);\\n        if (c->right)\\n          diff.push_back(v);\\n        sum += v;\\n        if (c == guard) {\\n          guard = !q.empty() ? q.back() : nullptr;\\n          level.push_back(sum);\\n          sum = 0;\\n          l++;\\n        }\\n      }\\n      return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641728,
                "title": "c-solution-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution \\n{\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n        int i,n,sum,prevsum;\\n\\n        vector<int> v,prev;\\n        queue<TreeNode *> q;\\n        TreeNode *temp;\\n\\n        prevsum=0;\\n        prev.push_back(0);\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            n=q.size();\\n            sum=0;\\n\\n            for(i=0;i<n;i++)\\n            {\\n                temp=q.front();\\n                q.pop();\\n                temp->val=prevsum-prev[i];\\n\\n                if(temp->left)\\n                {\\n                    q.push(temp->left);\\n                }\\n\\n                if(temp->right)\\n                {\\n                    q.push(temp->right);\\n                }\\n\\n                if(temp->left && temp->right)\\n                {\\n                    v.push_back(temp->left->val+temp->right->val);\\n                    v.push_back(temp->left->val+temp->right->val);\\n                    sum+=v.back();\\n                }\\n\\n                else if(!temp->left && temp->right)\\n                {\\n                    v.push_back(temp->right->val);\\n                    sum+=v.back();\\n                }\\n\\n                else if(temp->left && !temp->right)\\n                {\\n                    v.push_back(temp->left->val);\\n                    sum+=v.back();\\n                }\\n            }\\n\\n            prevsum=sum;\\n            prev=v;\\n            v.clear();\\n        }        \\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution \\n{\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) \\n    {\\n        int i,n,sum,prevsum;\\n\\n        vector<int> v,prev;\\n        queue<TreeNode *> q;\\n        TreeNode *temp;\\n\\n        prevsum=0;\\n        prev.push_back(0);\\n        q.push(root);\\n\\n        while(!q.empty())\\n        {\\n            n=q.size();\\n            sum=0;\\n\\n            for(i=0;i<n;i++)\\n            {\\n                temp=q.front();\\n                q.pop();\\n                temp->val=prevsum-prev[i];\\n\\n                if(temp->left)\\n                {\\n                    q.push(temp->left);\\n                }\\n\\n                if(temp->right)\\n                {\\n                    q.push(temp->right);\\n                }\\n\\n                if(temp->left && temp->right)\\n                {\\n                    v.push_back(temp->left->val+temp->right->val);\\n                    v.push_back(temp->left->val+temp->right->val);\\n                    sum+=v.back();\\n                }\\n\\n                else if(!temp->left && temp->right)\\n                {\\n                    v.push_back(temp->right->val);\\n                    sum+=v.back();\\n                }\\n\\n                else if(temp->left && !temp->right)\\n                {\\n                    v.push_back(temp->left->val);\\n                    sum+=v.back();\\n                }\\n            }\\n\\n            prevsum=sum;\\n            prev=v;\\n            v.clear();\\n        }        \\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641620,
                "title": "simple-java-o-n-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSum of all cousins at level i = (Sum of all nodes at level i) - (val of sibling) - (val of self)\\n\\nWe can precompute sum of each level in one traversal of tree in O(n). Then in second traversal we can update values. Small catch is to get value of sibling, which can be passed by parent node.\\n\\nIf going to left subtree, then siblingValue will be of right node.\\nIf going to right subtree, then siblingValue will be of left node.\\n\\nBFS traversal is not necessarily required to solve this problem. Any traversal would work(in-order, pre-order, postorder, BFS). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSteps:\\n1. Calculate depth of tree(This can be avoided if using List instead of array): depth = 1 + max(leftDepth, rightDepth);\\n2. Compute level sum. You can use any traversal, I used pre-order. \\n3. Update node values. You can choose to create new tree instead of updating existing one if asked by interviewer.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O (n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        int levels = depth(root);\\n        int[] arr = new int[levels]; // Stores sum of level\\n        computeLevelSum(root, 0, arr);\\n        updateNodes(root, 0, 0, arr);\\n        return root;\\n    }\\n\\n    private void updateNodes(TreeNode root, int siblingVal, int i, int[] arr) {\\n        if (root == null) return;\\n        \\n        int leftValue = root.left != null ? root.left.val : 0;\\n        int rightValue = root.right != null ? root.right.val : 0;\\n        updateNodes(root.left, rightValue, i+1, arr);\\n        updateNodes(root.right, leftValue, i+1, arr);\\n\\n        root.val = arr[i] - root.val - siblingVal;\\n    }\\n\\n    private void computeLevelSum(TreeNode root, int i, int[] arr) {\\n        if (root == null) return;\\n\\n        arr[i] += root.val;\\n        computeLevelSum(root.left, i+1, arr);\\n        computeLevelSum(root.right, i+1, arr);\\n    }\\n\\n    private int depth(TreeNode root) {\\n        if (root == null) return 0;\\n        return Math.max(depth(root.left), depth(root.right)) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        int levels = depth(root);\\n        int[] arr = new int[levels]; // Stores sum of level\\n        computeLevelSum(root, 0, arr);\\n        updateNodes(root, 0, 0, arr);\\n        return root;\\n    }\\n\\n    private void updateNodes(TreeNode root, int siblingVal, int i, int[] arr) {\\n        if (root == null) return;\\n        \\n        int leftValue = root.left != null ? root.left.val : 0;\\n        int rightValue = root.right != null ? root.right.val : 0;\\n        updateNodes(root.left, rightValue, i+1, arr);\\n        updateNodes(root.right, leftValue, i+1, arr);\\n\\n        root.val = arr[i] - root.val - siblingVal;\\n    }\\n\\n    private void computeLevelSum(TreeNode root, int i, int[] arr) {\\n        if (root == null) return;\\n\\n        arr[i] += root.val;\\n        computeLevelSum(root.left, i+1, arr);\\n        computeLevelSum(root.right, i+1, arr);\\n    }\\n\\n    private int depth(TreeNode root) {\\n        if (root == null) return 0;\\n        return Math.max(depth(root.left), depth(root.right)) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641423,
                "title": "simple-bfs-pysthon",
                "content": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        node = root\\n        st = [node]\\n        while st:\\n            k = []\\n            s = 0\\n            for i in st:\\n                if i.left:\\n                    s += i.left.val\\n                if i.right:\\n                    s += i.right.val\\n            for i in st:\\n                node_sum = 0\\n                if i.left:\\n                    node_sum += i.left.val\\n                if i.right:\\n                    node_sum += i.right.val\\n                if i.left:\\n                    i.left.val = s-node_sum\\n                    k.append(i.left)\\n                if i.right:\\n                    i.right.val = s-node_sum\\n                    k.append(i.right)\\n            st = k\\n        root.val = 0\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        node = root\\n        st = [node]\\n        while st:\\n            k = []\\n            s = 0\\n            for i in st:\\n                if i.left:\\n                    s += i.left.val\\n                if i.right:\\n                    s += i.right.val\\n            for i in st:\\n                node_sum = 0\\n                if i.left:\\n                    node_sum += i.left.val\\n                if i.right:\\n                    node_sum += i.right.val\\n                if i.left:\\n                    i.left.val = s-node_sum\\n                    k.append(i.left)\\n                if i.right:\\n                    i.right.val = s-node_sum\\n                    k.append(i.right)\\n            st = k\\n        root.val = 0\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641378,
                "title": "dfs-bfs-easy-to-understand",
                "content": "# Intuition\\nreplaced_value = (sum of all nodes at a level) - (node itself + its siblings)\\nuse a standard bfs level order approach to store the sum of all nodes at a level in a level array(vector)\\nthen recursively(dfs) go for every node and first store both the left and right child values(only 2 sibling for every node as it is a binary tree that has the property of max 2 child per node) in a sibling variable.\\nif left child is not null then replace its value with totalsumatthatlevel-sibling, do the same with right child\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define ll long long\\nclass Solution {\\npublic:\\n    void dfs(TreeNode*root, vector<ll>&level, int i){\\n        if(!root) return;\\n        ll sibling=0;\\n        if(root->left) sibling+=root->left->val;\\n        if(root->right) sibling+=root->right->val;\\n        if(root->left) root->left->val=level[i+1]-sibling;\\n        if(root->right) root->right->val=level[i+1]-sibling;\\n        dfs(root->left,level,i+1);\\n        dfs(root->right,level,i+1);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<ll> level;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            ll sum=0;\\n            int s=q.size();\\n            while(s--){\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                sum+=temp->val;\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            level.push_back(sum);\\n        }\\n        if(root) root->val=0;\\n        dfs(root,level,0);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#define ll long long\\nclass Solution {\\npublic:\\n    void dfs(TreeNode*root, vector<ll>&level, int i){\\n        if(!root) return;\\n        ll sibling=0;\\n        if(root->left) sibling+=root->left->val;\\n        if(root->right) sibling+=root->right->val;\\n        if(root->left) root->left->val=level[i+1]-sibling;\\n        if(root->right) root->right->val=level[i+1]-sibling;\\n        dfs(root->left,level,i+1);\\n        dfs(root->right,level,i+1);\\n    }\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        vector<ll> level;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            ll sum=0;\\n            int s=q.size();\\n            while(s--){\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                sum+=temp->val;\\n                if(temp->left) q.push(temp->left);\\n                if(temp->right) q.push(temp->right);\\n            }\\n            level.push_back(sum);\\n        }\\n        if(root) root->val=0;\\n        dfs(root,level,0);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640324,
                "title": "cpp-solution-using-hashmap",
                "content": "Level order traversal\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nusing map & queue\\n<!-- Describe your approach to solving the problem. -->\\n\\nO(N)\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       root->val = 0;\\n\\n       while(!q.empty()){\\n           int n = q.size();\\n           unordered_map<TreeNode* , int>m;\\n           for(int i=0;i<n;i++){\\n               TreeNode* topNode = q.front();\\n               if(topNode->left){\\n                   q.push(topNode->left);\\n                   m[topNode] += topNode->left->val;\\n               }\\n               if(topNode->right){\\n                   q.push(topNode->right);\\n                   m[topNode] += topNode->right->val;\\n               }\\n               q.pop();\\n           }\\n           int sum = 0;\\n           for(auto it:m){\\n               sum += it.second;\\n           }\\n           for(auto it : m){\\n            if(it.first->left)\\n            it.first->left->val = sum-it.second;\\n            if(it.first->right)\\n            it.first->right->val = sum-it.second;\\n           }\\n       } \\n       return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n       queue<TreeNode*>q;\\n       q.push(root);\\n       root->val = 0;\\n\\n       while(!q.empty()){\\n           int n = q.size();\\n           unordered_map<TreeNode* , int>m;\\n           for(int i=0;i<n;i++){\\n               TreeNode* topNode = q.front();\\n               if(topNode->left){\\n                   q.push(topNode->left);\\n                   m[topNode] += topNode->left->val;\\n               }\\n               if(topNode->right){\\n                   q.push(topNode->right);\\n                   m[topNode] += topNode->right->val;\\n               }\\n               q.pop();\\n           }\\n           int sum = 0;\\n           for(auto it:m){\\n               sum += it.second;\\n           }\\n           for(auto it : m){\\n            if(it.first->left)\\n            it.first->left->val = sum-it.second;\\n            if(it.first->right)\\n            it.first->right->val = sum-it.second;\\n           }\\n       } \\n       return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639609,
                "title": "level-sum-then-preorder-dfs-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> level_sum;\\n    void find_sum(TreeNode* root,int level){\\n        if(!root) return;\\n        if(level>=level_sum.size()) level_sum.push_back(0);\\n        level_sum[level]+=root->val;\\n        find_sum(root->left,level+1);\\n        find_sum(root->right,level+1);\\n    }\\n\\n    void preorder(TreeNode* root, int brothersum,int level){\\n        if(!root) return;\\n        int cousin_sum=level_sum[level]-brothersum;\\n        root->val=cousin_sum;\\n\\n        int childsum=0;\\n        childsum+=(root->left)? root->left->val : 0;\\n        childsum+=(root->right)? root->right->val : 0;\\n\\n        preorder(root->left,childsum,level+1);\\n        preorder(root->right,childsum,level+1);\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        find_sum(root,0);\\n        preorder(root,root->val,0);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> level_sum;\\n    void find_sum(TreeNode* root,int level){\\n        if(!root) return;\\n        if(level>=level_sum.size()) level_sum.push_back(0);\\n        level_sum[level]+=root->val;\\n        find_sum(root->left,level+1);\\n        find_sum(root->right,level+1);\\n    }\\n\\n    void preorder(TreeNode* root, int brothersum,int level){\\n        if(!root) return;\\n        int cousin_sum=level_sum[level]-brothersum;\\n        root->val=cousin_sum;\\n\\n        int childsum=0;\\n        childsum+=(root->left)? root->left->val : 0;\\n        childsum+=(root->right)? root->right->val : 0;\\n\\n        preorder(root->left,childsum,level+1);\\n        preorder(root->right,childsum,level+1);\\n    }\\n\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        find_sum(root,0);\\n        preorder(root,root->val,0);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639510,
                "title": "python-queue",
                "content": "Key here is to record in each node, the value of it\\'s sibling, in the queue.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [[root, 0]]\\n        tot_sum = 0\\n\\n        while queue:\\n            nextQ = []\\n            cur_sum = 0\\n\\n            for [node, sib_val] in queue:\\n                cur_sum += node.val\\n\\n                if node.left and node.right:\\n                    nextQ.append([node.left, node.right.val])\\n                    nextQ.append([node.right, node.left.val])\\n                elif node.left:\\n                    nextQ.append([node.left, 0])\\n                elif node.right:\\n                    nextQ.append([node.right, 0])\\n\\n            for [node, sib_val] in queue:\\n                node.val = cur_sum - sib_val - node.val\\n\\n            queue = nextQ\\n\\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        queue = [[root, 0]]\\n        tot_sum = 0\\n\\n        while queue:\\n            nextQ = []\\n            cur_sum = 0\\n\\n            for [node, sib_val] in queue:\\n                cur_sum += node.val\\n\\n                if node.left and node.right:\\n                    nextQ.append([node.left, node.right.val])\\n                    nextQ.append([node.right, node.left.val])\\n                elif node.left:\\n                    nextQ.append([node.left, 0])\\n                elif node.right:\\n                    nextQ.append([node.right, 0])\\n\\n            for [node, sib_val] in queue:\\n                node.val = cur_sum - sib_val - node.val\\n\\n            queue = nextQ\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639437,
                "title": "python-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_sum=defaultdict(int)\\n        def dfs(root,height):\\n            if not root:return\\n            level_sum[height]+=root.val\\n            if root.left:dfs(root.left,height+1)\\n            if root.right:dfs(root.right,height+1)\\n        dfs(root,0)\\n        def dfs_sum(sib_val,own,height):\\n            if not own:\\n                return \\n            own.val=level_sum[height]-own.val-sib_val\\n            if own.left:\\n                left=own.left.val\\n            else:\\n                left=0\\n            right=own.right.val if own.right else 0\\n            dfs_sum(left,own.right,height+1)\\n            dfs_sum(right,own.left,height+1)\\n        dfs_sum(0,root,0)\\n        return root     \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        level_sum=defaultdict(int)\\n        def dfs(root,height):\\n            if not root:return\\n            level_sum[height]+=root.val\\n            if root.left:dfs(root.left,height+1)\\n            if root.right:dfs(root.right,height+1)\\n        dfs(root,0)\\n        def dfs_sum(sib_val,own,height):\\n            if not own:\\n                return \\n            own.val=level_sum[height]-own.val-sib_val\\n            if own.left:\\n                left=own.left.val\\n            else:\\n                left=0\\n            right=own.right.val if own.right else 0\\n            dfs_sum(left,own.right,height+1)\\n            dfs_sum(right,own.left,height+1)\\n        dfs_sum(0,root,0)\\n        return root     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639381,
                "title": "level-order-traversal-and-hashing",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     TreeNode *replaceValueInTree(TreeNode *root)\\n    {\\n        queue<pair<TreeNode *, TreeNode *>> q;\\n        q.push({nullptr, root});\\n\\n        while (!q.empty())\\n        {\\n            unordered_map<TreeNode *, int> mp;\\n            vector<pair<TreeNode *, TreeNode *>> dummy;\\n            int tot = 0;\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++)\\n            {\\n                TreeNode *par = q.front().first;\\n                TreeNode *node = q.front().second;\\n                q.pop();\\n                if (node->left)\\n                {\\n                    q.push({node, node->left});\\n                }\\n                if (node->right)\\n                {\\n                    q.push({node, node->right});\\n                }\\n\\n                if (par == nullptr)\\n                {\\n                    node->val = 0;\\n                    continue;\\n                }\\n                dummy.push_back({node, par});\\n\\n                mp[par] += node->val;\\n                tot += node->val;\\n            }\\n\\n            for (auto it : dummy)\\n            {\\n                TreeNode *node = it.first;\\n                TreeNode *par = it.second;\\n\\n                node->val = tot - mp[par];\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     TreeNode *replaceValueInTree(TreeNode *root)\\n    {\\n        queue<pair<TreeNode *, TreeNode *>> q;\\n        q.push({nullptr, root});\\n\\n        while (!q.empty())\\n        {\\n            unordered_map<TreeNode *, int> mp;\\n            vector<pair<TreeNode *, TreeNode *>> dummy;\\n            int tot = 0;\\n            int sz = q.size();\\n            for (int i = 0; i < sz; i++)\\n            {\\n                TreeNode *par = q.front().first;\\n                TreeNode *node = q.front().second;\\n                q.pop();\\n                if (node->left)\\n                {\\n                    q.push({node, node->left});\\n                }\\n                if (node->right)\\n                {\\n                    q.push({node, node->right});\\n                }\\n\\n                if (par == nullptr)\\n                {\\n                    node->val = 0;\\n                    continue;\\n                }\\n                dummy.push_back({node, par});\\n\\n                mp[par] += node->val;\\n                tot += node->val;\\n            }\\n\\n            for (auto it : dummy)\\n            {\\n                TreeNode *node = it.first;\\n                TreeNode *par = it.second;\\n\\n                node->val = tot - mp[par];\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639184,
                "title": "easy-java-soluation-freshser",
                "content": "\\n  \\n  \\n  \\n\\n  \\n  class Pair{\\n    TreeNode node,par;\\n    public Pair(TreeNode a,TreeNode b){\\n        node =a;\\n        par =b;\\n    }\\n}\\n\\nclass Demo {\\n \\n public TreeNode replaceValueInTree(TreeNode root) {\\n \\n        Queue<Pair>q = new LinkedList<>();\\n        \\n        q.add(new Pair(root,root));\\n        \\n        while(!q.isEmpty()){\\n            int n=q.size();\\n            Queue<Pair>tq = new LinkedList<>();\\n             long sum=0;\\n            for(int i=0;i<n;i++){\\n                Pair p=q.remove();\\n                tq.add(p);\\n                sum+=p.node.val;\\n                if(p.node.left!=null){\\n                    q.add(new Pair(p.node.left,p.node));\\n                }\\n                 if(p.node.right!=null){\\n                    q.add(new Pair(p.node.right,p.node));\\n                }\\n            }\\n            //updating the value\\n            \\n            while(!tq.isEmpty()){\\n                Pair p=tq.remove();\\n               //node ans par are same example: parent node\\n                if(p.node==p.par)\\n                    p.node.val=0;\\n                else{\\n                    //if current node siblings not exist ;\\n                    if(p.par.left==null||p.par.right==null){\\n                     long tempSum=0;\\n                     tempSum=((p.par.left!=null?p.par.left.val:0)+(p.par.right!=null?p.par.right.val:0));\\n                     p.node.val=(int) (sum-tempSum);\\n                    }else{\\n                        //if current node siblings exist \\n                    \\n                    long l=p.par.left.val;\\n                    long r=p.par.right.val; \\n                     p.par.left.val=(int) (sum-(l+r));\\n                     p.par.right.val=(int) (sum-(l+r));\\n                    //both node and its siblings update together so remove its sibling for queue\\n                        tq.remove();\\n                    }\\n                   \\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "\\n  \\n  \\n  \\n\\n  \\n  class Pair{\\n    TreeNode node,par;\\n    public Pair(TreeNode a,TreeNode b){\\n        node =a;\\n        par =b;\\n    }\\n}\\n\\nclass Demo {\\n \\n public TreeNode replaceValueInTree(TreeNode root) {\\n \\n        Queue<Pair>q = new LinkedList<>();\\n        \\n        q.add(new Pair(root,root));\\n        \\n        while(!q.isEmpty()){\\n            int n=q.size();\\n            Queue<Pair>tq = new LinkedList<>();\\n             long sum=0;\\n            for(int i=0;i<n;i++){\\n                Pair p=q.remove();\\n                tq.add(p);\\n                sum+=p.node.val;\\n                if(p.node.left!=null){\\n                    q.add(new Pair(p.node.left,p.node));\\n                }\\n                 if(p.node.right!=null){\\n                    q.add(new Pair(p.node.right,p.node));\\n                }\\n            }\\n            //updating the value\\n            \\n            while(!tq.isEmpty()){\\n                Pair p=tq.remove();\\n               //node ans par are same example: parent node\\n                if(p.node==p.par)\\n                    p.node.val=0;\\n                else{\\n                    //if current node siblings not exist ;\\n                    if(p.par.left==null||p.par.right==null){\\n                     long tempSum=0;\\n                     tempSum=((p.par.left!=null?p.par.left.val:0)+(p.par.right!=null?p.par.right.val:0));\\n                     p.node.val=(int) (sum-tempSum);\\n                    }else{\\n                        //if current node siblings exist \\n                    \\n                    long l=p.par.left.val;\\n                    long r=p.par.right.val; \\n                     p.par.left.val=(int) (sum-(l+r));\\n                     p.par.right.val=(int) (sum-(l+r));\\n                    //both node and its siblings update together so remove its sibling for queue\\n                        tq.remove();\\n                    }\\n                   \\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3639091,
                "title": "java-code-using-bfs-16-ms-beats-93-of-all-java-submissions",
                "content": "# Intuition\\nUse BFS to iterate level by level, getting the level sum and for each node get the parent sum.\\nThe new node value = levelSum - parentSum.\\n\\n# Approach\\nCreate an annotated tree node class to hold the tree node and its parent children sum.\\n\\nUse standard BFS search with initial level Sum = root.val.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private class AnnotatedTreeNode {\\n\\n        public int parentSum;\\n\\n        public TreeNode node;\\n\\n        public AnnotatedTreeNode(int parentSum, TreeNode node) {\\n\\n            this.parentSum = parentSum;\\n\\n            this.node = node;\\n\\n        } \\n\\n\\n    }\\n\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n\\n        Queue<AnnotatedTreeNode> current = new LinkedList<>();\\n\\n        int levelSum = root.val;\\n\\n        current.offer(new AnnotatedTreeNode(root.val, root));\\n\\n        while (!current.isEmpty()) {\\n\\n            int sum = 0;\\n\\n            int length = current.size();\\n\\n            for (int index = 0; index < length; ++index) {\\n\\n                AnnotatedTreeNode curr = current.poll();\\n\\n                curr.node.val = levelSum - curr.parentSum;\\n\\n                int parentSum = (curr.node.left == null ? 0 : curr.node.left.val) + (curr.node.right == null ? 0 : curr.node.right.val);\\n\\n                sum += parentSum;\\n\\n                if (curr.node.left != null)\\n                    current.offer(new AnnotatedTreeNode(parentSum, curr.node.left)) ;         \\n\\n                if (curr.node.right != null)\\n                    current.offer(new AnnotatedTreeNode(parentSum, curr.node.right)) ;         \\n\\n           }\\n\\n           levelSum = sum;\\n\\n        }\\n\\n        return root;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    private class AnnotatedTreeNode {\\n\\n        public int parentSum;\\n\\n        public TreeNode node;\\n\\n        public AnnotatedTreeNode(int parentSum, TreeNode node) {\\n\\n            this.parentSum = parentSum;\\n\\n            this.node = node;\\n\\n        } \\n\\n\\n    }\\n\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n\\n        Queue<AnnotatedTreeNode> current = new LinkedList<>();\\n\\n        int levelSum = root.val;\\n\\n        current.offer(new AnnotatedTreeNode(root.val, root));\\n\\n        while (!current.isEmpty()) {\\n\\n            int sum = 0;\\n\\n            int length = current.size();\\n\\n            for (int index = 0; index < length; ++index) {\\n\\n                AnnotatedTreeNode curr = current.poll();\\n\\n                curr.node.val = levelSum - curr.parentSum;\\n\\n                int parentSum = (curr.node.left == null ? 0 : curr.node.left.val) + (curr.node.right == null ? 0 : curr.node.right.val);\\n\\n                sum += parentSum;\\n\\n                if (curr.node.left != null)\\n                    current.offer(new AnnotatedTreeNode(parentSum, curr.node.left)) ;         \\n\\n                if (curr.node.right != null)\\n                    current.offer(new AnnotatedTreeNode(parentSum, curr.node.right)) ;         \\n\\n           }\\n\\n           levelSum = sum;\\n\\n        }\\n\\n        return root;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639070,
                "title": "two-solutions-pre-order-traversal-easy-to-understand",
                "content": "# Solution 1\\n\\n1439 ms Beats 68.18%\\n\\n```swift\\nfunc replaceValueInTree(_ root: TreeNode?) -> TreeNode? {\\n    var sums: [Int] = []\\n    getSums(root, 0, &sums)\\n    assign(root, 0, sums)\\n    root?.val = 0\\n    return root\\n}\\n\\nprivate func getSums(_ node: TreeNode?, _ level: Int, _ sums: inout [Int]) {\\n    guard let node = node else { return }\\n    if level < sums.count {\\n        sums[level] += node.val\\n    } else {\\n        sums.append(node.val)\\n    }\\n    getSums(node.left, 1 + level, &sums)\\n    getSums(node.right, 1 + level, &sums)\\n}\\n\\nprivate func assign(_ node: TreeNode?, _ level: Int, _ sums: [Int]) {\\n    guard let node = node, (node.left != nil || node.right != nil) else { return }\\n    let value = sums[1 + level] - (node.left?.val ?? 0) - (node.right?.val ?? 0)\\n    node.left?.val = value\\n    node.right?.val = value\\n    assign(node.left, 1 + level, sums)\\n    assign(node.right, 1 + level, sums)\\n}\\n```\\n\\n# Solution 2\\n\\n1453 ms Beats 54.54%\\n\\n```swift\\nfunc replaceValueInTree(_ root: TreeNode?) -> TreeNode? {\\n    var sums: [Int] = []\\n    traverse(root, 0) { node, level in\\n        if level < sums.count {\\n            sums[level] += node.val\\n        } else {\\n            sums.append(node.val)\\n        }\\n        return true\\n    }\\n    traverse(root, 0) { node, level in\\n        guard node.left != nil || node.right != nil else { return false }\\n        let value = sums[1 + level] - (node.left?.val ?? 0) - (node.right?.val ?? 0)\\n        node.left?.val = value\\n        node.right?.val = value\\n        return true\\n    }\\n    root?.val = 0\\n    return root\\n}\\n\\nprivate func traverse(_ node: TreeNode?, _ level: Int, _ visitAndContinue: (TreeNode, Int) -> Bool) {\\n    guard let node = node, visitAndContinue(node, level) else { return }\\n    traverse(node.left, 1 + level, visitAndContinue)\\n    traverse(node.right, 1 + level, visitAndContinue)\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Recursion"
                ],
                "code": "```swift\\nfunc replaceValueInTree(_ root: TreeNode?) -> TreeNode? {\\n    var sums: [Int] = []\\n    getSums(root, 0, &sums)\\n    assign(root, 0, sums)\\n    root?.val = 0\\n    return root\\n}\\n\\nprivate func getSums(_ node: TreeNode?, _ level: Int, _ sums: inout [Int]) {\\n    guard let node = node else { return }\\n    if level < sums.count {\\n        sums[level] += node.val\\n    } else {\\n        sums.append(node.val)\\n    }\\n    getSums(node.left, 1 + level, &sums)\\n    getSums(node.right, 1 + level, &sums)\\n}\\n\\nprivate func assign(_ node: TreeNode?, _ level: Int, _ sums: [Int]) {\\n    guard let node = node, (node.left != nil || node.right != nil) else { return }\\n    let value = sums[1 + level] - (node.left?.val ?? 0) - (node.right?.val ?? 0)\\n    node.left?.val = value\\n    node.right?.val = value\\n    assign(node.left, 1 + level, sums)\\n    assign(node.right, 1 + level, sums)\\n}\\n```\n```swift\\nfunc replaceValueInTree(_ root: TreeNode?) -> TreeNode? {\\n    var sums: [Int] = []\\n    traverse(root, 0) { node, level in\\n        if level < sums.count {\\n            sums[level] += node.val\\n        } else {\\n            sums.append(node.val)\\n        }\\n        return true\\n    }\\n    traverse(root, 0) { node, level in\\n        guard node.left != nil || node.right != nil else { return false }\\n        let value = sums[1 + level] - (node.left?.val ?? 0) - (node.right?.val ?? 0)\\n        node.left?.val = value\\n        node.right?.val = value\\n        return true\\n    }\\n    root?.val = 0\\n    return root\\n}\\n\\nprivate func traverse(_ node: TreeNode?, _ level: Int, _ visitAndContinue: (TreeNode, Int) -> Bool) {\\n    guard let node = node, visitAndContinue(node, level) else { return }\\n    traverse(node.left, 1 + level, visitAndContinue)\\n    traverse(node.right, 1 + level, visitAndContinue)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3634434,
                "title": "java-bfs-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Queue<List<TreeNode>> queue = new LinkedList<>();\\n        \\n        List<TreeNode> listRoot = new ArrayList<>();\\n        listRoot.add(root);\\n        queue.add(listRoot);\\n        int sum = 0;\\n        for (TreeNode node : listRoot)\\n            sum += node.val;\\n        \\n        map.put(0, sum);\\n        int level = -1;\\n        \\n        while (!queue.isEmpty()) {\\n            int n = queue.size();\\n            level++;\\n            for (int i = 0; i < n; i++) {\\n                List<TreeNode> list = queue.poll();\\n                int  localSum = 0;\\n                \\n                for (TreeNode node : list) {\\n                    localSum += node.val;\\n                }\\n                for (TreeNode node : list) {\\n                    node.val = map.get(level) - localSum;\\n                    List<TreeNode> list1 = new ArrayList<>();\\n                    \\n                    if (node.left != null) {\\n                        map.put(level + 1, map.getOrDefault(level + 1, 0) + node.left.val);\\n                        list1.add(node.left);\\n                    }\\n                    if (node.right != null) {\\n                        map.put(level + 1, map.getOrDefault(level + 1, 0) + node.right.val);\\n                        list1.add(node.right);\\n                    }\\n                    if (list1.size() > 0)\\n                        queue.add(list1);\\n                }   \\n            }\\n        }\\n        return root;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Queue<List<TreeNode>> queue = new LinkedList<>();\\n        \\n        List<TreeNode> listRoot = new ArrayList<>();\\n        listRoot.add(root);\\n        queue.add(listRoot);\\n        int sum = 0;\\n        for (TreeNode node : listRoot)\\n            sum += node.val;\\n        \\n        map.put(0, sum);\\n        int level = -1;\\n        \\n        while (!queue.isEmpty()) {\\n            int n = queue.size();\\n            level++;\\n            for (int i = 0; i < n; i++) {\\n                List<TreeNode> list = queue.poll();\\n                int  localSum = 0;\\n                \\n                for (TreeNode node : list) {\\n                    localSum += node.val;\\n                }\\n                for (TreeNode node : list) {\\n                    node.val = map.get(level) - localSum;\\n                    List<TreeNode> list1 = new ArrayList<>();\\n                    \\n                    if (node.left != null) {\\n                        map.put(level + 1, map.getOrDefault(level + 1, 0) + node.left.val);\\n                        list1.add(node.left);\\n                    }\\n                    if (node.right != null) {\\n                        map.put(level + 1, map.getOrDefault(level + 1, 0) + node.right.val);\\n                        list1.add(node.right);\\n                    }\\n                    if (list1.size() > 0)\\n                        queue.add(list1);\\n                }   \\n            }\\n        }\\n        return root;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632507,
                "title": "java-easy-solution",
                "content": "\\n# Code\\n```\\n//RITIK PATEL\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> que = new LinkedList();\\n        HashMap<TreeNode,TreeNode> par = new HashMap();\\n        HashMap<Integer, Integer> levelSum = new HashMap();\\n        que.add(root);\\n        par.put(root, null);\\n        int level = 0;\\n        while(que.size()!=0){\\n            int size = que.size();\\n            int sum = 0;\\n            level+=1;\\n            while(size!=0){\\n                size--;\\n                TreeNode top = que.poll();\\n                sum+=top.val;\\n                if(top.left!=null){\\n                    que.add(top.left);\\n                    par.put(top.left,top);\\n                }\\n                if(top.right!=null){\\n                    que.add(top.right);\\n                    par.put(top.right,top);\\n                }\\n            }\\n            levelSum.put(level,sum);\\n        }\\n        TreeNode newNode = new TreeNode();\\n        DFS(root,newNode, par,levelSum,1);\\n        return newNode;   \\n    }\\n    void DFS(TreeNode root,TreeNode newNode, HashMap<TreeNode,TreeNode> par,HashMap<Integer, Integer> levelSum, int level){\\n        //check neighbour\\n        newNode.val = levelSum.get(level);\\n        TreeNode parent = par.get(root);\\n        if(parent!=null){\\n            int val = 0;\\n            if(parent.left!=null){\\n                val = parent.left.val;\\n            }\\n            if(parent.right!=null){\\n                val += parent.right.val;\\n            }\\n            newNode.val-=val;\\n        }\\n        else{\\n            newNode.val-=root.val;\\n        }\\n        if(root.left!=null){\\n            TreeNode node = new TreeNode();\\n            newNode.left = node;\\n            DFS(root.left, newNode.left, par, levelSum, level+1);\\n        }\\n        if(root.right!=null){\\n            TreeNode node = new TreeNode();\\n            newNode.right = node;\\n            DFS(root.right, newNode.right, par, levelSum, level+1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n//RITIK PATEL\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        Queue<TreeNode> que = new LinkedList();\\n        HashMap<TreeNode,TreeNode> par = new HashMap();\\n        HashMap<Integer, Integer> levelSum = new HashMap();\\n        que.add(root);\\n        par.put(root, null);\\n        int level = 0;\\n        while(que.size()!=0){\\n            int size = que.size();\\n            int sum = 0;\\n            level+=1;\\n            while(size!=0){\\n                size--;\\n                TreeNode top = que.poll();\\n                sum+=top.val;\\n                if(top.left!=null){\\n                    que.add(top.left);\\n                    par.put(top.left,top);\\n                }\\n                if(top.right!=null){\\n                    que.add(top.right);\\n                    par.put(top.right,top);\\n                }\\n            }\\n            levelSum.put(level,sum);\\n        }\\n        TreeNode newNode = new TreeNode();\\n        DFS(root,newNode, par,levelSum,1);\\n        return newNode;   \\n    }\\n    void DFS(TreeNode root,TreeNode newNode, HashMap<TreeNode,TreeNode> par,HashMap<Integer, Integer> levelSum, int level){\\n        //check neighbour\\n        newNode.val = levelSum.get(level);\\n        TreeNode parent = par.get(root);\\n        if(parent!=null){\\n            int val = 0;\\n            if(parent.left!=null){\\n                val = parent.left.val;\\n            }\\n            if(parent.right!=null){\\n                val += parent.right.val;\\n            }\\n            newNode.val-=val;\\n        }\\n        else{\\n            newNode.val-=root.val;\\n        }\\n        if(root.left!=null){\\n            TreeNode node = new TreeNode();\\n            newNode.left = node;\\n            DFS(root.left, newNode.left, par, levelSum, level+1);\\n        }\\n        if(root.right!=null){\\n            TreeNode node = new TreeNode();\\n            newNode.right = node;\\n            DFS(root.right, newNode.right, par, levelSum, level+1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620265,
                "title": "python-dfs-modify-tree-in-place",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTrack the layer sum and the sum of every node\\'s immediate children node. \\nSibling sum for any node becomes (layerSum - the children sum from parent).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![IMG_0007.jpg](https://assets.leetcode.com/users/images/5b293152-1994-4c3d-a704-910845a7f97c_1686371153.119484.jpeg)\\n\\n\\nDFS once to calculate layerSum. In the same DFS pass, calculate the sum of immediate children and store the sum in parent node.\\n\\nDFS a second time, for each node, we want to set its children to the (layerSum - the children sum this node is tracking), then reset the sibling sum of itself.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(L), where L is the number of layers.\\n\\n# Code\\n```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        layerSum = collections.defaultdict(int)\\n\\n        def dfs1(node, layer):\\n            if node is None:\\n                return\\n            layerSum[layer] += node.val\\n            leftSum = node.left.val if node.left else 0\\n            rightSum = node.right.val if node.right else 0\\n            node.val = leftSum + rightSum\\n            dfs1(node.left, layer+1)\\n            dfs1(node.right, layer+1)\\n        \\n        dfs1(root, 0)\\n\\n        def setSiblingSum(node, layer, ss):\\n            if node is None:\\n                return\\n            siblingSum = layerSum[layer+1] - node.val\\n            setSiblingSum(node.left, layer+1, siblingSum)\\n            setSiblingSum(node.right, layer+1, siblingSum)\\n            node.val = ss\\n\\n        setSiblingSum(root.left, 1, 0)\\n        setSiblingSum(root.right, 1, 0)\\n        root.val = 0\\n        return root\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        layerSum = collections.defaultdict(int)\\n\\n        def dfs1(node, layer):\\n            if node is None:\\n                return\\n            layerSum[layer] += node.val\\n            leftSum = node.left.val if node.left else 0\\n            rightSum = node.right.val if node.right else 0\\n            node.val = leftSum + rightSum\\n            dfs1(node.left, layer+1)\\n            dfs1(node.right, layer+1)\\n        \\n        dfs1(root, 0)\\n\\n        def setSiblingSum(node, layer, ss):\\n            if node is None:\\n                return\\n            siblingSum = layerSum[layer+1] - node.val\\n            setSiblingSum(node.left, layer+1, siblingSum)\\n            setSiblingSum(node.right, layer+1, siblingSum)\\n            node.val = ss\\n\\n        setSiblingSum(root.left, 1, 0)\\n        setSiblingSum(root.right, 1, 0)\\n        root.val = 0\\n        return root\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615361,
                "title": "bfs-96-time-99-space",
                "content": "```\\ndef replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        # 2023/06/08 13:30PM -> 13:55PM\\n        total, q = root.val, collections.deque([(root, root.val)])\\n        while q:\\n            new_total = 0\\n            for _ in range(len(q)):\\n                cur, vals = q.popleft()\\n                l = cur.left.val if cur.left else 0\\n                r = cur.right.val if cur.right else 0\\n                new_total += (l + r)\\n                if cur.left:\\n                    q.append((cur.left, l + r))\\n                if cur.right:\\n                    q.append((cur.right, l + r))\\n                cur.val = total - vals\\n            total = new_total\\n        return root\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\ndef replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\\n        # 2023/06/08 13:30PM -> 13:55PM\\n        total, q = root.val, collections.deque([(root, root.val)])\\n        while q:\\n            new_total = 0\\n            for _ in range(len(q)):\\n                cur, vals = q.popleft()\\n                l = cur.left.val if cur.left else 0\\n                r = cur.right.val if cur.right else 0\\n                new_total += (l + r)\\n                if cur.left:\\n                    q.append((cur.left, l + r))\\n                if cur.right:\\n                    q.append((cur.right, l + r))\\n                cur.val = total - vals\\n            total = new_total\\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3589099,
                "title": "bfs-explained",
                "content": "# Intuition\\nWe need cousins how can we get it my first reaction was level order traversal. Now bfs offers same but efficiently.\\n\\n# Approach\\nSimply run bfs and have a vector or a set your call and on each level take the sum of the nodes at that level and keep inserting them in the vector. Once a level has been traversed for every child of the node in the vector subract the left and right value and voila what is left is the value of it\\'s cousin.\\nRemember you have subtracted the left and right values of each node so if any value is left it is definitely the cousin.\\n\\n# Complexity\\n- Time complexity:\\nO(v+e)\\n\\n- Space complexity:\\n- o(max number of nodes at any level) o(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        root->val=0;// initialising the root to be 0 as it has 0 cousin;\\n        queue<TreeNode*> q; q.push(root);\\n        while(!q.empty()){\\n            vector<TreeNode*> buffer;\\n            int szq=q.size();\\n            int sum=0;\\n            while(szq--){\\n                TreeNode* curr=q.front();\\n                buffer.push_back(curr);\\n                q.pop();\\n                if(curr->left){\\n                    q.push(curr->left);\\n                    sum+=curr->left->val;\\n                }if(curr->right){\\n                    q.push(curr->right);\\n                    sum+=curr->right->val;\\n                }\\n            }\\n            for(TreeNode* nodes:buffer){\\n                int temp=sum;\\n                if(nodes->left)temp-=nodes->left->val;\\n                if(nodes->right)temp-=nodes->right->val;\\n                if(nodes->left)nodes->left->val=temp;\\n                if(nodes->right)nodes->right->val=temp;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        root->val=0;// initialising the root to be 0 as it has 0 cousin;\\n        queue<TreeNode*> q; q.push(root);\\n        while(!q.empty()){\\n            vector<TreeNode*> buffer;\\n            int szq=q.size();\\n            int sum=0;\\n            while(szq--){\\n                TreeNode* curr=q.front();\\n                buffer.push_back(curr);\\n                q.pop();\\n                if(curr->left){\\n                    q.push(curr->left);\\n                    sum+=curr->left->val;\\n                }if(curr->right){\\n                    q.push(curr->right);\\n                    sum+=curr->right->val;\\n                }\\n            }\\n            for(TreeNode* nodes:buffer){\\n                int temp=sum;\\n                if(nodes->left)temp-=nodes->left->val;\\n                if(nodes->right)temp-=nodes->right->val;\\n                if(nodes->left)nodes->left->val=temp;\\n                if(nodes->right)nodes->right->val=temp;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588991,
                "title": "c-solution-level-order-traversal",
                "content": "# Intuition\\nWe will perform level-order traversal on the tree, ans calculate the sum of all the nodes on the levels, ans store the sum of all nodes for the respective parent nodes for each node on that level. Then change the node values by `(total sum of all the nodes in that level) - (sum of nodes of that parent).`\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*, TreeNode*>> q;\\n        q.push({NULL, root});\\n        while(q.size()){\\n           int s = q.size(), sum=0;\\n           unordered_map<TreeNode*, int> sumIn;\\n           vector<pair<TreeNode*, TreeNode*>> layer;\\n           while(s--){\\n                auto [parent, node] = q.front();\\n                sum+=node->val;\\n                layer.push_back({parent, node});\\n                q.pop();\\n                sumIn[parent]+=node->val;\\n                if(node->left) q.push({node, node->left});\\n                if(node->right) q.push({node, node->right});\\n           }\\n           for(auto &[parent, node]: layer)\\n                if(parent==nullptr)\\n                    node->val = 0;\\n                else\\n                    node->val = sum-sumIn[parent];\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        queue<pair<TreeNode*, TreeNode*>> q;\\n        q.push({NULL, root});\\n        while(q.size()){\\n           int s = q.size(), sum=0;\\n           unordered_map<TreeNode*, int> sumIn;\\n           vector<pair<TreeNode*, TreeNode*>> layer;\\n           while(s--){\\n                auto [parent, node] = q.front();\\n                sum+=node->val;\\n                layer.push_back({parent, node});\\n                q.pop();\\n                sumIn[parent]+=node->val;\\n                if(node->left) q.push({node, node->left});\\n                if(node->right) q.push({node, node->right});\\n           }\\n           for(auto &[parent, node]: layer)\\n                if(parent==nullptr)\\n                    node->val = 0;\\n                else\\n                    node->val = sum-sumIn[parent];\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587175,
                "title": "java-solution-92-runtime-62-memory-bfs-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we need to replace the value of each node in the tree with the sum of all its cousins\\' values, we shall use **Breadth First Traversal**. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhile traversing any level, we will be adding the next level node\\'s value to a int variable `nextLevelSum` and we will push the left and right child of the current level nodes by modifying it\\'s `val`. The modified value will be the sum of that node\\'s `val` and it\\'s cousin\\'s `val`.\\nThis modification is done so that in the next level traversal, we can use the `nextLevelSum` by assigning it to `curLevelSum` and the final `val` of the current level nodes will be `curLevelSum - node.val`.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root == null)return root;\\n\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int nextLevelSum = root.val;\\n        int curLevelSum = 0;\\n        while(!q.isEmpty()){\\n            curLevelSum = nextLevelSum;\\n            nextLevelSum = 0;\\n            Queue<TreeNode> temp = new LinkedList<>();\\n            while(!q.isEmpty()){\\n                TreeNode t = q.poll();\\n                t.val = curLevelSum-t.val;\\n                if(t.left!=null && t.right!=null){\\n                    nextLevelSum+=t.left.val;\\n                    nextLevelSum+=t.right.val;\\n\\n                    int val = t.left.val + t.right.val;\\n                    t.left.val = val;\\n                    t.right.val = val;\\n\\n                    temp.add(t.left);\\n                    temp.add(t.right);\\n                }else if(t.left!=null){\\n                    nextLevelSum+=t.left.val;\\n                    temp.add(t.left);\\n                }else if(t.right!=null){\\n                    nextLevelSum+=t.right.val;\\n                    temp.add(t.right);\\n                }\\n            }\\n            q = temp;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        if(root == null)return root;\\n\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        int nextLevelSum = root.val;\\n        int curLevelSum = 0;\\n        while(!q.isEmpty()){\\n            curLevelSum = nextLevelSum;\\n            nextLevelSum = 0;\\n            Queue<TreeNode> temp = new LinkedList<>();\\n            while(!q.isEmpty()){\\n                TreeNode t = q.poll();\\n                t.val = curLevelSum-t.val;\\n                if(t.left!=null && t.right!=null){\\n                    nextLevelSum+=t.left.val;\\n                    nextLevelSum+=t.right.val;\\n\\n                    int val = t.left.val + t.right.val;\\n                    t.left.val = val;\\n                    t.right.val = val;\\n\\n                    temp.add(t.left);\\n                    temp.add(t.right);\\n                }else if(t.left!=null){\\n                    nextLevelSum+=t.left.val;\\n                    temp.add(t.left);\\n                }else if(t.right!=null){\\n                    nextLevelSum+=t.right.val;\\n                    temp.add(t.right);\\n                }\\n            }\\n            q = temp;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581166,
                "title": "bfs-very-detailed-comments-so-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //Empty tree return NULL, no need of modification\\n        if(root == NULL)\\n            return root;\\n        \\n        //root will never have any cousin , hence it will always have value 0\\n        root->val = 0;\\n        \\n        //queue stores current node and parent node\\n        queue<pair<TreeNode*, TreeNode*>>q;\\n        \\n        //parent of root is NULL of course\\n        q.push({root,NULL});\\n        \\n        \\n        while(!q.empty())\\n        {\\n            //Size of the queue\\n            int n = q.size();\\n            \\n            //Sum stores the sum of a particular level\\n            int sum = 0;\\n            \\n            //sum of children of a parent\\n            unordered_map<TreeNode*, int>mp;\\n            \\n            //stores pair of parent and its child of a particular level\\n            vector<pair<TreeNode*,TreeNode*>>level;\\n            \\n            \\n             for(int i = 0; i<n; i++)\\n             {\\n                 //current node\\n                TreeNode* node = q.front().first;\\n                 \\n                 // parent of the current node\\n                 TreeNode* parent = q.front().second;\\n                 q.pop();\\n                 \\n                 //Adding value of the current node to the sum of a level\\n                 sum += node->val;\\n                 \\n                 //parent storing the sum of this childen\\n                 mp[parent] += node->val;\\n                 \\n                 //storing the parent and its child for ease of future modification\\n                 level.push_back({parent, node});\\n                 \\n                 //pushing left child of current node with parent as the current node\\n                 if(node->left)\\n                 {\\n                     q.push({node->left,node});\\n                 }\\n                 \\n                 //pushing right child of current node with parent as the current node\\n                 if(node->right)\\n                 {\\n                     q. push({node->right, node});                    \\n                 }\\n             }\\n        \\n            //one level is completed, now we are modifing the tree\\n            for(auto it: level)\\n            {\\n                //Substracting the sum of childen of a prent from the total sum of a level\\n                int val = sum - mp[it.first];\\n                                \\n                it.second->val = val;           \\n            }            \\n            \\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //Empty tree return NULL, no need of modification\\n        if(root == NULL)\\n            return root;\\n        \\n        //root will never have any cousin , hence it will always have value 0\\n        root->val = 0;\\n        \\n        //queue stores current node and parent node\\n        queue<pair<TreeNode*, TreeNode*>>q;\\n        \\n        //parent of root is NULL of course\\n        q.push({root,NULL});\\n        \\n        \\n        while(!q.empty())\\n        {\\n            //Size of the queue\\n            int n = q.size();\\n            \\n            //Sum stores the sum of a particular level\\n            int sum = 0;\\n            \\n            //sum of children of a parent\\n            unordered_map<TreeNode*, int>mp;\\n            \\n            //stores pair of parent and its child of a particular level\\n            vector<pair<TreeNode*,TreeNode*>>level;\\n            \\n            \\n             for(int i = 0; i<n; i++)\\n             {\\n                 //current node\\n                TreeNode* node = q.front().first;\\n                 \\n                 // parent of the current node\\n                 TreeNode* parent = q.front().second;\\n                 q.pop();\\n                 \\n                 //Adding value of the current node to the sum of a level\\n                 sum += node->val;\\n                 \\n                 //parent storing the sum of this childen\\n                 mp[parent] += node->val;\\n                 \\n                 //storing the parent and its child for ease of future modification\\n                 level.push_back({parent, node});\\n                 \\n                 //pushing left child of current node with parent as the current node\\n                 if(node->left)\\n                 {\\n                     q.push({node->left,node});\\n                 }\\n                 \\n                 //pushing right child of current node with parent as the current node\\n                 if(node->right)\\n                 {\\n                     q. push({node->right, node});                    \\n                 }\\n             }\\n        \\n            //one level is completed, now we are modifing the tree\\n            for(auto it: level)\\n            {\\n                //Substracting the sum of childen of a prent from the total sum of a level\\n                int val = sum - mp[it.first];\\n                                \\n                it.second->val = val;           \\n            }            \\n            \\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581163,
                "title": "bfs-very-detailed-comments-so-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //Empty tree return NULL, no need of modification\\n        if(root == NULL)\\n            return root;\\n        \\n        //root will never have any cousin , hence it will always have value 0\\n        root->val = 0;\\n        \\n        //queue stores current node and parent node\\n        queue<pair<TreeNode*, TreeNode*>>q;\\n        \\n        //parent of root is NULL of course\\n        q.push({root,NULL});\\n        \\n        \\n        while(!q.empty())\\n        {\\n            //Size of the queue\\n            int n = q.size();\\n            \\n            //Sum stores the sum of a particular level\\n            int sum = 0;\\n            \\n            //sum of children of a parent\\n            unordered_map<TreeNode*, int>mp;\\n            \\n            //stores pair of parent and its child of a particular level\\n            vector<pair<TreeNode*,TreeNode*>>level;\\n            \\n            \\n             for(int i = 0; i<n; i++)\\n             {\\n                 //current node\\n                TreeNode* node = q.front().first;\\n                 \\n                 // parent of the current node\\n                 TreeNode* parent = q.front().second;\\n                 q.pop();\\n                 \\n                 //Adding value of the current node to the sum of a level\\n                 sum += node->val;\\n                 \\n                 //parent storing the sum of this childen\\n                 mp[parent] += node->val;\\n                 \\n                 //storing the parent and its child for ease of future modification\\n                 level.push_back({parent, node});\\n                 \\n                 //pushing left child of current node with parent as the current node\\n                 if(node->left)\\n                 {\\n                     q.push({node->left,node});\\n                 }\\n                 \\n                 //pushing right child of current node with parent as the current node\\n                 if(node->right)\\n                 {\\n                     q. push({node->right, node});                    \\n                 }\\n             }\\n        \\n            //one level is completed, now we are modifing the tree\\n            for(auto it: level)\\n            {\\n                //Substracting the sum of childen of a prent from the total sum of a level\\n                int val = sum - mp[it.first];\\n                                \\n                it.second->val = val;           \\n            }            \\n            \\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        \\n        //Empty tree return NULL, no need of modification\\n        if(root == NULL)\\n            return root;\\n        \\n        //root will never have any cousin , hence it will always have value 0\\n        root->val = 0;\\n        \\n        //queue stores current node and parent node\\n        queue<pair<TreeNode*, TreeNode*>>q;\\n        \\n        //parent of root is NULL of course\\n        q.push({root,NULL});\\n        \\n        \\n        while(!q.empty())\\n        {\\n            //Size of the queue\\n            int n = q.size();\\n            \\n            //Sum stores the sum of a particular level\\n            int sum = 0;\\n            \\n            //sum of children of a parent\\n            unordered_map<TreeNode*, int>mp;\\n            \\n            //stores pair of parent and its child of a particular level\\n            vector<pair<TreeNode*,TreeNode*>>level;\\n            \\n            \\n             for(int i = 0; i<n; i++)\\n             {\\n                 //current node\\n                TreeNode* node = q.front().first;\\n                 \\n                 // parent of the current node\\n                 TreeNode* parent = q.front().second;\\n                 q.pop();\\n                 \\n                 //Adding value of the current node to the sum of a level\\n                 sum += node->val;\\n                 \\n                 //parent storing the sum of this childen\\n                 mp[parent] += node->val;\\n                 \\n                 //storing the parent and its child for ease of future modification\\n                 level.push_back({parent, node});\\n                 \\n                 //pushing left child of current node with parent as the current node\\n                 if(node->left)\\n                 {\\n                     q.push({node->left,node});\\n                 }\\n                 \\n                 //pushing right child of current node with parent as the current node\\n                 if(node->right)\\n                 {\\n                     q. push({node->right, node});                    \\n                 }\\n             }\\n        \\n            //one level is completed, now we are modifing the tree\\n            for(auto it: level)\\n            {\\n                //Substracting the sum of childen of a prent from the total sum of a level\\n                int val = sum - mp[it.first];\\n                                \\n                it.second->val = val;           \\n            }            \\n            \\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571273,
                "title": "bfs-easy-java-solution-beats-90-online-submissions",
                "content": "# Code\\n```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n\\n        List<Integer> level_sum = new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int sum = 0;\\n\\n            while(n-- > 0){\\n                TreeNode res = q.poll();\\n                sum += res.val;\\n\\n                if(res.left != null){\\n                    q.offer(res.left);\\n                }\\n                if(res.right != null){\\n                    q.offer(res.right);\\n                }\\n            }\\n\\n            level_sum.add(sum);\\n        }\\n\\n        int i = 0;\\n        q.offer(root);\\n        root.val = 0;\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            i++;\\n\\n            while(n-- > 0){\\n                TreeNode res = q.poll();\\n                int sum = 0;\\n\\n                if(res.left != null){\\n                    q.add(res.left);\\n                    sum += res.left.val;\\n                }\\n\\n                if(res.right != null){\\n                    q.add(res.right);\\n                    sum += res.right.val;\\n                }\\n                if(res.left != null){\\n                    res.left.val = level_sum.get(i) - sum;\\n                }\\n\\n                if(res.right != null){\\n                    res.right.val = level_sum.get(i) - sum;\\n                }\\n\\n            }\\n        }\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode replaceValueInTree(TreeNode root) {\\n\\n        List<Integer> level_sum = new ArrayList<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int sum = 0;\\n\\n            while(n-- > 0){\\n                TreeNode res = q.poll();\\n                sum += res.val;\\n\\n                if(res.left != null){\\n                    q.offer(res.left);\\n                }\\n                if(res.right != null){\\n                    q.offer(res.right);\\n                }\\n            }\\n\\n            level_sum.add(sum);\\n        }\\n\\n        int i = 0;\\n        q.offer(root);\\n        root.val = 0;\\n\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            i++;\\n\\n            while(n-- > 0){\\n                TreeNode res = q.poll();\\n                int sum = 0;\\n\\n                if(res.left != null){\\n                    q.add(res.left);\\n                    sum += res.left.val;\\n                }\\n\\n                if(res.right != null){\\n                    q.add(res.right);\\n                    sum += res.right.val;\\n                }\\n                if(res.left != null){\\n                    res.left.val = level_sum.get(i) - sum;\\n                }\\n\\n                if(res.right != null){\\n                    res.right.val = level_sum.get(i) - sum;\\n                }\\n\\n            }\\n        }\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568189,
                "title": "c-bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if (!root)\\n            return root;\\n        deque<pair<TreeNode*, TreeNode*>> deque;\\n        deque.push_back({root, nullptr});\\n        while (!deque.empty()) \\n        {\\n            int totalSum = 0;\\n            for (const auto& [node, _] : deque)\\n                totalSum += node -> val;\\n            int qSize = deque.size();\\n            while (qSize) \\n            {\\n                auto [firstChild, firstChildParent] = deque.front();\\n                deque.pop_front();\\n                --qSize;\\n                if (deque.empty())\\n                {\\n                    int newVal = totalSum - firstChild -> val;\\n                    firstChild -> val = newVal;\\n                    if (firstChild -> left)\\n                        deque.push_back({firstChild -> left, firstChild});\\n                    if (firstChild -> right)\\n                        deque.push_back({firstChild -> right, firstChild});\\n                    continue;\\n                }\\n                auto [secondChild, secondChildParent] = deque.front();\\n                if (firstChild -> left)\\n                    deque.push_back({firstChild -> left, firstChild});\\n                if (firstChild -> right)\\n                    deque.push_back({firstChild -> right, firstChild});\\n                if (firstChildParent == secondChildParent)\\n                {\\n                    deque.pop_front();\\n                    --qSize;\\n                    int newVal = totalSum - (firstChild -> val + secondChild -> val);\\n                    firstChild -> val = newVal;\\n                    secondChild -> val = newVal;\\n                    if (secondChild -> left)\\n                        deque.push_back({secondChild -> left, secondChild});\\n                    if (secondChild -> right)\\n                        deque.push_back({secondChild -> right, secondChild});\\n                }\\n                else\\n                {\\n                    int newVal = totalSum - firstChild -> val;\\n                    firstChild -> val = newVal;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* replaceValueInTree(TreeNode* root) {\\n        if (!root)\\n            return root;\\n        deque<pair<TreeNode*, TreeNode*>> deque;\\n        deque.push_back({root, nullptr});\\n        while (!deque.empty()) \\n        {\\n            int totalSum = 0;\\n            for (const auto& [node, _] : deque)\\n                totalSum += node -> val;\\n            int qSize = deque.size();\\n            while (qSize) \\n            {\\n                auto [firstChild, firstChildParent] = deque.front();\\n                deque.pop_front();\\n                --qSize;\\n                if (deque.empty())\\n                {\\n                    int newVal = totalSum - firstChild -> val;\\n                    firstChild -> val = newVal;\\n                    if (firstChild -> left)\\n                        deque.push_back({firstChild -> left, firstChild});\\n                    if (firstChild -> right)\\n                        deque.push_back({firstChild -> right, firstChild});\\n                    continue;\\n                }\\n                auto [secondChild, secondChildParent] = deque.front();\\n                if (firstChild -> left)\\n                    deque.push_back({firstChild -> left, firstChild});\\n                if (firstChild -> right)\\n                    deque.push_back({firstChild -> right, firstChild});\\n                if (firstChildParent == secondChildParent)\\n                {\\n                    deque.pop_front();\\n                    --qSize;\\n                    int newVal = totalSum - (firstChild -> val + secondChild -> val);\\n                    firstChild -> val = newVal;\\n                    secondChild -> val = newVal;\\n                    if (secondChild -> left)\\n                        deque.push_back({secondChild -> left, secondChild});\\n                    if (secondChild -> right)\\n                        deque.push_back({secondChild -> right, secondChild});\\n                }\\n                else\\n                {\\n                    int newVal = totalSum - firstChild -> val;\\n                    firstChild -> val = newVal;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556994,
                "title": "c-single-method-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n    public class Solution\\n    {\\n        public TreeNode ReplaceValueInTree(TreeNode root)\\n        {\\n            var wave = new List<TreeNode>();\\n            var nextWave = new List<TreeNode>();\\n\\n            wave.Add(root);\\n\\n            while (wave.Count > 0)\\n            {\\n                var waveSum = 0;\\n\\n                foreach (var node in wave)\\n                {\\n                    if (node != null)\\n                    {\\n                        nextWave.Add(node?.left);\\n                        nextWave.Add(node?.right);\\n                        waveSum += node.val;\\n                    }\\n                }\\n\\n                var couple = 0;\\n\\n                for (int i = 0; i < wave.Count; i++)\\n                {\\n                    if (i % 2 == 0)\\n                    {\\n                        couple = 0;\\n                        if (wave[i] != null) couple += wave[i].val;\\n                        if (i + 1 < wave.Count && wave[i + 1] != null) couple += wave[i + 1].val;\\n                    }\\n                    if (wave[i] != null) wave[i].val = waveSum - couple;\\n                }\\n\\n                wave = nextWave;\\n                nextWave = new List<TreeNode>();\\n            }\\n            return root;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n    public class Solution\\n    {\\n        public TreeNode ReplaceValueInTree(TreeNode root)\\n        {\\n            var wave = new List<TreeNode>();\\n            var nextWave = new List<TreeNode>();\\n\\n            wave.Add(root);\\n\\n            while (wave.Count > 0)\\n            {\\n                var waveSum = 0;\\n\\n                foreach (var node in wave)\\n                {\\n                    if (node != null)\\n                    {\\n                        nextWave.Add(node?.left);\\n                        nextWave.Add(node?.right);\\n                        waveSum += node.val;\\n                    }\\n                }\\n\\n                var couple = 0;\\n\\n                for (int i = 0; i < wave.Count; i++)\\n                {\\n                    if (i % 2 == 0)\\n                    {\\n                        couple = 0;\\n                        if (wave[i] != null) couple += wave[i].val;\\n                        if (i + 1 < wave.Count && wave[i + 1] != null) couple += wave[i + 1].val;\\n                    }\\n                    if (wave[i] != null) wave[i].val = waveSum - couple;\\n                }\\n\\n                wave = nextWave;\\n                nextWave = new List<TreeNode>();\\n            }\\n            return root;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2040655,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            },
            {
                "id": 2010958,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            },
            {
                "id": 1931021,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            },
            {
                "id": 1930458,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            },
            {
                "id": 1864489,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            },
            {
                "id": 1864324,
                "content": [
                    {
                        "username": "sam_Eldoro",
                        "content": "They must have mentioned that Tree may have duplicate values. "
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Use level Sum wisely\\uD83D\\uDE4C\\uD83D\\uDE0A"
                    },
                    {
                        "username": "sKipper97",
                        "content": "Something wrong with Leetcode.  I am getting this error eventhough I am just returning null.\n\n[0.019s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "SG-C",
                        "content": "reload the page then try again to submit worked for me "
                    },
                    {
                        "username": "layyy",
                        "content": "Can be implemented with one pass using BFS"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "My code is passing 38 cases out of 41 and showing runtime error on 39 case can anyone please help and tell what exactly is wrong\n `your inline code...your inline code...`\nclass Solution {\npublic:\n   \n    TreeNode* replaceValueInTree(TreeNode* root) {\n        if(root==NULL)return root;\n        TreeNode *node = root;\n        vector<long long> vals(1000,0);\n        \n        queue<pair<TreeNode*,int>> q;\n        q.push({node,0});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            vals[depth]+=cur->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n            }\n        }\n        \n        q.push({node,1});\n        while(!q.empty()){\n            TreeNode* cur = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n            int right1 = 0;\n            int left1 =0;\n        if(cur->right!=NULL)right1=cur->right->val;\n        if(cur->left!=NULL)left1=cur->left->val;\n            if(cur->left!=NULL){\n                q.push({cur->left,depth+1});\n                cur->left->val=vals[depth]-(long long)left1-(long long)right1;\n            }\n            if(cur->right!=NULL){\n                    q.push({cur->right,depth+1});\n                cur->right->val=vals[depth]-(long long)left1-(long long)right1;\n                \n            }\n        }\n        root->val=0;\n        if(root->right!=NULL)root->right->val=0;\n        if(root->left!=NULL)root->left->val=0;\n        return root;\n        \n    }\n};"
                    },
                    {
                        "username": "KartikSingh023",
                        "content": "[@SarthakAgg12](/SarthakAgg12) \\nThank You I got your idea, Now its working\\n"
                    },
                    {
                        "username": "SarthakAgg12",
                        "content": "you declared vals vector of size 1000, but number of nodes can be 10^5, hence it shows runtime error because in worst case depth can be equal to number of nodes-1, so it shows out of bound error, i hope you understand"
                    },
                    {
                        "username": "neel19",
                        "content": "Can anyone explain why this gives WA. I implemented as the question asked. [link](https://leetcode.com/problems/cousins-in-binary-tree-ii/submissions/934233863/)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Calculate Delayed Arrival Time",
        "question_content": "<p>You are given a positive integer <code>arrivalTime</code> denoting the arrival time of a train in hours, and another positive integer <code>delayedTime</code> denoting the amount of delay in hours.</p>\n\n<p>Return <em>the time when the train will arrive at the station.</em></p>\n\n<p>Note that the time in this problem is in 24-hours format.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arrivalTime = 15, delayedTime = 5 \n<strong>Output:</strong> 20 \n<strong>Explanation:</strong> Arrival time of the train was 15:00 hours. It is delayed by 5 hours. Now it will reach at 15+5 = 20 (20:00 hours).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arrivalTime = 13, delayedTime = 11\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Arrival time of the train was 13:00 hours. It is delayed by 11 hours. Now it will reach at 13+11=24 (Which is denoted by 00:00 in 24 hours format so return 0).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arrivaltime &lt;&nbsp;24</code></li>\n\t<li><code>1 &lt;= delayedTime &lt;= 24</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3446050,
                "title": "one-liner-using-modulo-24-very-simple-easy-to-understand-solution",
                "content": "<b>Up vote if you like the solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime)%24;\\n    }\\n};\\n```\\n<b> Here is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446040,
                "title": "leetcode-the-hard-way-one-line",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n};\\n```\\n\\n```py\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```\\n\\n```java\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```\n```java\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445952,
                "title": "easiest-best-solution-in-3-lines-time-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int b) {\\n        return (a+b)%24;\\n        //     Or\\n        // if(a+b>=24) return (a+b)-24;\\n        // else return a+b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int b) {\\n        return (a+b)%24;\\n        //     Or\\n        // if(a+b>=24) return (a+b)-24;\\n        // else return a+b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445669,
                "title": "simple-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int aT, int dT) {\\n        return (aT+dT)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int aT, int dT) {\\n        return (aT+dT)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446380,
                "title": "c-python-o-1-time-and-space",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int at, int dt) {\\n        int arrive = at + dt;\\n        return arrive >= 24 ? arrive - 24 : arrive;\\n    }\\n};\\n```\\n\\n# Python / Python 3\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, at: int, dt: int) -> int:\\n        arrive = at + dt\\n        if arrive >= 24:\\n            return arrive - 24\\n        return arrive\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int at, int dt) {\\n        int arrive = at + dt;\\n        return arrive >= 24 ? arrive - 24 : arrive;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, at: int, dt: int) -> int:\\n        arrive = at + dt\\n        if arrive >= 24:\\n            return arrive - 24\\n        return arrive\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492584,
                "title": "c-math-retuen-a-b-24",
                "content": "# Complexity\\n- Time complexity:\\no(1)\\n\\n- Space complexity:\\n(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        return (a+b)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        return (a+b)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488470,
                "title": "python-go-easy-solution",
                "content": "# Python\\u2705\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n            return (arrivalTime + delayedTime)%24\\n}\\n```\\n# Go\\u2705\\n```\\nfunc findDelayedArrivalTime(arrivalTime int, delayedTime int) int {\\n    return (arrivalTime+delayedTime)%24\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n            return (arrivalTime + delayedTime)%24\\n}\\n```\n```\\nfunc findDelayedArrivalTime(arrivalTime int, delayedTime int) int {\\n    return (arrivalTime+delayedTime)%24\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469224,
                "title": "simple-one-line-solution",
                "content": "\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3445936,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime+delayedTime)%24\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime+delayedTime)%24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592642,
                "title": "very-easy-java-solution-beats-100-runtime-0ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int arriveAt = arrivalTime + delayedTime;\\n        if(arriveAt >= 24) return (arriveAt - 24);\\n        else return arriveAt;\\n    }\\n}\\n```\\n\\nPlease upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int arriveAt = arrivalTime + delayedTime;\\n        if(arriveAt >= 24) return (arriveAt - 24);\\n        else return arriveAt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545787,
                "title": "java-just-2-line-and-that-s-it",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime >= 24) return Math.abs((arrivalTime+delayedTime) - 24);\\n        return arrivalTime+delayedTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime >= 24) return Math.abs((arrivalTime+delayedTime) - 24);\\n        return arrivalTime+delayedTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446023,
                "title": "javascript-2651-calculate-delayed-arrival-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar findDelayedArrivalTime = function (arrivalTime, delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n};\\n```\\n\\n---\\n\\n**Contest**\\n- https://leetcode.com/contest/weekly-contest-342/ranking/67/\\n\\n**All Answers**\\n- **Q1** - https://leetcode.com/problems/calculate-delayed-arrival-time/solutions/3446023/javascript-2651-calculate-delayed-arrival-time/?orderBy=most_votes\\n- **Q2** - https://leetcode.com/problems/sum-multiples/solutions/3446027/javascript-2652-sum-multiples/?orderBy=most_votes\\n- **Q3** - https://leetcode.com/problems/sliding-subarray-beauty/solutions/3446035/javascript-2653-sliding-subarray-beauty/?orderBy=most_votes\\n- **Q4** - https://leetcode.com/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/solutions/3446411/javascript-2654-minimum-number-of-operations-to-make-all-array-elements-equal-to-1/?orderBy=most_votes\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/37970e7b-b559-4aa9-834c-e178df5ddaa7_1682232917.7638698.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findDelayedArrivalTime = function (arrivalTime, delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445855,
                "title": "two-liner-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAns is totalTime%24.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find total time and return totaltime % 24.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\n       int time=arrivalTime+delayedTime;\\n        return time%24;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\n       int time=arrivalTime+delayedTime;\\n        return time%24;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445660,
                "title": "java-one-liner",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478275,
                "title": "1-liner-c-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447662,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(1)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        return (a+d)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        return (a+d)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447038,
                "title": "c-oneliner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTypical modulo arithmetic problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA simple formula\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindDelayedArrivalTime(int arrivalTime, int delayedTime) => \\n      (arrivalTime + delayedTime) % 24;    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindDelayedArrivalTime(int arrivalTime, int delayedTime) => \\n      (arrivalTime + delayedTime) % 24;    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446669,
                "title": "100-fast-and-space-optimized-c-1-liner",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrival, int delay) {\\n        return (arrival+delay)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Design"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrival, int delay) {\\n        return (arrival+delay)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446085,
                "title": "1line-c",
                "content": "````\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        return (a+b)%24;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        return (a+b)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446053,
                "title": "easy-and-simplest-c-approach-1-line-code",
                "content": "# Intuition\\n sum of arrival and delayed time was done and remainder of sum is returned \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$ \\n- Space complexity:\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int sum = arrivalTime + delayedTime ;\\n                return sum % 24 ;\\n \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int sum = arrivalTime + delayedTime ;\\n                return sum % 24 ;\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445791,
                "title": "c-well-explained-1-line-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445703,
                "title": "one-line-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445682,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arr, int del) {\\n        return (arr+del)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arr, int del) {\\n        return (arr+del)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097910,
                "title": "solution-of-calculate-delayed-arrival-time-problem",
                "content": "# Approach\\n- The problem of availability of 24 hours is solved using %\\n\\n# Complexity\\n- Time complexity:\\nO(1) - as, no functions were called\\n\\n- Space complexity:\\nO(1) - as, no extra space is required.\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966648,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n      int a=arrivalTime+delayedTime;\\n      return a%24;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n      int a=arrivalTime+delayedTime;\\n      return a%24;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865349,
                "title": "java-one-liner-0ms-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748908,
                "title": "one-liner",
                "content": "\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return ((arrivalTime+delayedTime)%24);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return ((arrivalTime+delayedTime)%24);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710960,
                "title": "super-easy-simpe-great-best-start-good-solution-in-js-d",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n    let time = arrivalTime + delayedTime\\n    return time >= 24 ? time - 24 : time\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n    let time = arrivalTime + delayedTime\\n    return time >= 24 ? time - 24 : time\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3710748,
                "title": "calculate-delayed-arrival-time-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int time = 24;\\n        int temp_time = arrivalTime + delayedTime;\\n        if(temp_time > time){\\n            temp_time = temp_time % time;\\n            return temp_time;\\n        }\\n        else if(time > temp_time){\\n            return temp_time;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int time = 24;\\n        int temp_time = arrivalTime + delayedTime;\\n        if(temp_time > time){\\n            temp_time = temp_time % time;\\n            return temp_time;\\n        }\\n        else if(time > temp_time){\\n            return temp_time;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651228,
                "title": "beats-in-runtime-and-97-beats-in-memory-usage-easy-solution-with-one-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590637,
                "title": "actual-one-liner-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDay resets at 24.So the count gets set back to 0 upon time>=24;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf delay==24 we reset it 0. Delay caps at 24,so simply mod 24 works.\\nNow for the final time,it is just addition but we will reset to 0 after 23.\\nThus,we again with mod 24 over the final sum.\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public:\\n        int findDelayedArrivalTime(int a,int d) \\n        {\\n            return (a+(d%24))%24;\\n        }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n        int findDelayedArrivalTime(int a,int d) \\n        {\\n            return (a+(d%24))%24;\\n        }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533404,
                "title": "simplest-efficient-1-liner-c-code-time-o-1-space-o-1",
                "content": "# Intuition\\nThe problem asks for finding the delayed arrival time given the original arrival time and the amount of delay. We need to consider the possibility of the arrival time crossing midnight (i.e., going beyond 24 hours).\\n\\n# Approach\\nTo solve this problem, we can use the modulus operator (%), which calculates the remainder when the arrival time and delayed time are divided by 24. This operation ensures that the result is always within the range of 0 to 23, representing the hours of a day. By adding the arrival time and delayed time together and then taking the modulus 24, we can find the delayed arrival time.\\n\\nFor example, if the arrival time is 20 (8 PM) and the delayed time is 6, adding them together gives us 26. Taking the modulus 24 of 26, we get 2, which represents 2 AM, indicating the delayed arrival time.\\n\\n# Complexity\\n- Time complexity: The time complexity of this approach is $O(1)$ since it only involves a simple calculation and a modulus operation, which are constant time operations.\\n\\n- Space complexity: The space complexity is also $O(1)$ as there is no additional space used apart from the return value.\\n\\n# Code\\n```\\nint findDelayedArrivalTime(int arrivalTime, int delayedTime){\\n    return (arrivalTime + delayedTime)%24;}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findDelayedArrivalTime(int arrivalTime, int delayedTime){\\n    return (arrivalTime + delayedTime)%24;}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3479012,
                "title": "c-easy-solution-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n      \\n        int sum=arrivalTime+delayedTime;\\n\\n        if(sum==24){\\n            sum=0;\\n        }\\n        else if(sum>24){\\n            sum=sum-24;\\n        }\\n   return sum; }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n      \\n        int sum=arrivalTime+delayedTime;\\n\\n        if(sum==24){\\n            sum=0;\\n        }\\n        else if(sum>24){\\n            sum=sum-24;\\n        }\\n   return sum; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463571,
                "title": "easy-1-liner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        int x = (a+b);\\n        return x%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        int x = (a+b);\\n        return x%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453891,
                "title": "simple-way-to-find-out-time-using-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrival, int delayed) {\\n        \\n        int time =0;\\n   if(arrival + delayed >=24)\\n       return ( arrival + delayed - 24);\\n\\n       else{\\n           time = arrival + delayed;\\n       }\\n     \\n        return time;\\n  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrival, int delayed) {\\n        \\n        int time =0;\\n   if(arrival + delayed >=24)\\n       return ( arrival + delayed - 24);\\n\\n       else{\\n           time = arrival + delayed;\\n       }\\n     \\n        return time;\\n  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453850,
                "title": "beats-100-simple-ready-to-begin-question-in-cpp-language",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we can see we have to convert total time taken by train ie(arrivalTime + delayedTime)in 24 hour format. We calculate total time and if it is greater than 23 then take mod 24 of that time and return it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int time=arrivalTime+delayedTime;\\n        if(time>23){\\n        time=time%24;}\\n        return time;\\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int time=arrivalTime+delayedTime;\\n        if(time>23){\\n        time=time%24;}\\n        return time;\\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449994,
                "title": "one-liner-code-in-java-python-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt adds the delayed time to the arrival time, and then calculates the modulo 24.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```JAVA []\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n```\\n```python []\\ndef findDelayedArrivalTime(arrivalTime, delayedTime):\\n    return (arrivalTime + delayedTime) % 24\\n\\n```\\n```C++ []\\nint findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```JAVA []\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n```\n```python []\\ndef findDelayedArrivalTime(arrivalTime, delayedTime):\\n    return (arrivalTime + delayedTime) % 24\\n\\n```\n```C++ []\\nint findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3447596,
                "title": "easiest-one-line-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int at, int dt) {\\n         return (at + dt) %24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int at, int dt) {\\n         return (at + dt) %24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447112,
                "title": "learn-maths-ye-nahi-dekha-to-kya-dekha",
                "content": "# Intuition\\n```AGAR YE BHI NAHI HUA TO BHAI APKO CODING BADME SIKHNI HAI FIRST LEARN BASICS OF MATHEMATICS. (NO NEED TO OFFEND JUST KIDDING \\uD83E\\uDD71\\uD83D\\uDE25\\uD83D\\uDE1E)```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        return (a+d)%24;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```AGAR YE BHI NAHI HUA TO BHAI APKO CODING BADME SIKHNI HAI FIRST LEARN BASICS OF MATHEMATICS. (NO NEED TO OFFEND JUST KIDDING \\uD83E\\uDD71\\uD83D\\uDE25\\uD83D\\uDE1E)```\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        return (a+d)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446862,
                "title": "one-liner-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        return (a + b) % 24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        return (a + b) % 24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446651,
                "title": "python3-simple-one-line",
                "content": "Just sum the arrivalTime and the delayedTime and check if the sum is outside the limits of 24.\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return arrivalTime + delayedTime if arrivalTime + delayedTime < 24 else arrivalTime + delayedTime - 24\\n```\\nor shorter version using **mod**:\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return arrivalTime + delayedTime if arrivalTime + delayedTime < 24 else arrivalTime + delayedTime - 24\\n```\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446635,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans=arrivalTime+delayedTime;\\n        if(ans>=24){\\n            return ans-24;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans=arrivalTime+delayedTime;\\n        if(ans>=24){\\n            return ans-24;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446531,
                "title": "java-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans=arrivalTime+delayedTime;\\n        if(ans>=24){\\n            return ans-24;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans=arrivalTime+delayedTime;\\n        if(ans>=24){\\n            return ans-24;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446119,
                "title": "easy-c-1-line-code-beats-100-time",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445953,
                "title": "simple-logic-c-no-need-of-modulo-operator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint findDelayedArrivalTime(int arrivalTime, int delayedTime)\\n{\\n    if (arrivalTime + delayedTime < 24)\\n    {\\n        return arrivalTime + delayedTime;\\n    }\\n    else\\n    {\\n        return arrivalTime + delayedTime - 24;\\n    }\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint findDelayedArrivalTime(int arrivalTime, int delayedTime)\\n{\\n    if (arrivalTime + delayedTime < 24)\\n    {\\n        return arrivalTime + delayedTime;\\n    }\\n    else\\n    {\\n        return arrivalTime + delayedTime - 24;\\n    }\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445935,
                "title": "c-one-line-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n      \\n        return (a+d)%24;;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n      \\n        return (a+d)%24;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445714,
                "title": "python3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        if arrivalTime + delayedTime == 24: return 0\\n        elif arrivalTime + delayedTime > 24: return abs(24 - (arrivalTime + delayedTime))\\n        else: return arrivalTime + delayedTime\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        if arrivalTime + delayedTime == 24: return 0\\n        elif arrivalTime + delayedTime > 24: return abs(24 - (arrivalTime + delayedTime))\\n        else: return arrivalTime + delayedTime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445676,
                "title": "c-a-d-24",
                "content": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        return (a+d)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        return (a+d)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101341,
                "title": "java-one-line-solution-beats-100",
                "content": "# Approach\\nJust simply using modulo to get the remainder, which is the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100994,
                "title": "simple-and-easy-to-understand-java-solution-2liner",
                "content": "\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int actualTime = arrivalTime + delayedTime;\\n        return actualTime%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int actualTime = arrivalTime + delayedTime;\\n        return actualTime%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092377,
                "title": "3line-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n      int time=arrivalTime+delayedTime;\\n      if(time>=24){\\n          return time%24;\\n      }  else return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n      int time=arrivalTime+delayedTime;\\n      if(time>=24){\\n          return time%24;\\n      }  else return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089448,
                "title": "0-ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085284,
                "title": "best-java-solution-for-beginners-beats-100",
                "content": "**UP VOTE IF YOU LIKE IT**\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int val=arrivalTime+delayedTime;\\n        if(val<=23){\\n            return val;\\n        }\\n        else{\\n            int val2=val-24;\\n            if (val==24){\\n                return 0;\\n            }\\n            return val2;\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int val=arrivalTime+delayedTime;\\n        if(val<=23){\\n            return val;\\n        }\\n        else{\\n            int val2=val-24;\\n            if (val==24){\\n                return 0;\\n            }\\n            return val2;\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082219,
                "title": "php-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $arrivalTime\\n     * @param Integer $delayedTime\\n     * @return Integer\\n     */\\n    function findDelayedArrivalTime($arrivalTime, $delayedTime) {\\n        $result = $arrivalTime + $delayedTime;\\n        // return $result;\\n        if($result == \\'24\\'){\\n          return \\'0\\';\\n        }else if($result > \\'24\\'){\\n         return  $result - \\'24\\';\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $arrivalTime\\n     * @param Integer $delayedTime\\n     * @return Integer\\n     */\\n    function findDelayedArrivalTime($arrivalTime, $delayedTime) {\\n        $result = $arrivalTime + $delayedTime;\\n        // return $result;\\n        if($result == \\'24\\'){\\n          return \\'0\\';\\n        }else if($result > \\'24\\'){\\n         return  $result - \\'24\\';\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080215,
                "title": "c-python-easiest-solution-ever-t-c-o-1-s-c-o-1",
                "content": "# Complexity\\n- Time complexity:$$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int aT, int dT) {\\n        return (aT + dT)%24;\\n    }\\n};\\n```\\n``` Python []\\nclass Solution:\\n    def findDelayedArrivalTime(self, aT: int, dT: int) -> int:\\n        return (aT + dT)%24\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int aT, int dT) {\\n        return (aT + dT)%24;\\n    }\\n};\\n```\n``` Python []\\nclass Solution:\\n    def findDelayedArrivalTime(self, aT: int, dT: int) -> int:\\n        return (aT + dT)%24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077356,
                "title": "0ms-solution-one-line-of-code",
                "content": "# Intuition\\n<!-- At first glance I thought that I was going to need a way to wrap around back to 0 after the total time reaches 24 -->\\n\\n# Approach\\n<!-- I first needed to add the two times. Once I did that I needed a way to have all times over 24h be reset back to 0. I found that the modulo operation best performed this and would allow me to output everything in one line -->\\n\\n# Time and Space\\n- Runtime: 0 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Memory Used: 39.12 \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        //adding the arrival time and the delayed time together then modulo-ing that by 24. This allows any time over 24h to be reset back to 0. (Ex: 25%24 = 1 | 40%24 = 16 )\\n        return (arrivalTime + delayedTime)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        //adding the arrival time and the delayed time together then modulo-ing that by 24. This allows any time over 24h to be reset back to 0. (Ex: 25%24 = 1 | 40%24 = 16 )\\n        return (arrivalTime + delayedTime)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077123,
                "title": "very-basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072086,
                "title": "swift-runtime-beating-100-upvote-if-helpful",
                "content": "# Intuition\\nTo calculate the actual time when the train had arrived.\\n\\n# Approach\\nMathematical\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\n    func findDelayedArrivalTime(_ arrivalTime: Int, _ delayedTime: Int) -> Int {\\n        // 24 or 48 hours mean 0 (i.e. 00:00 in time standards)\\n        if(arrivalTime + delayedTime == 24 || arrivalTime + delayedTime == 48){\\n            return 0\\n        }\\n        if(arrivalTime + delayedTime < 24){\\n            return arrivalTime + delayedTime\\n        }\\n        // when the time is greater than 24 but less than 48 hours\\n        if(arrivalTime + delayedTime > 24 && arrivalTime + delayedTime < 48) {\\n            return arrivalTime + delayedTime - 24\\n        }\\n        return arrivalTime + delayedTime\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    func findDelayedArrivalTime(_ arrivalTime: Int, _ delayedTime: Int) -> Int {\\n        // 24 or 48 hours mean 0 (i.e. 00:00 in time standards)\\n        if(arrivalTime + delayedTime == 24 || arrivalTime + delayedTime == 48){\\n            return 0\\n        }\\n        if(arrivalTime + delayedTime < 24){\\n            return arrivalTime + delayedTime\\n        }\\n        // when the time is greater than 24 but less than 48 hours\\n        if(arrivalTime + delayedTime > 24 && arrivalTime + delayedTime < 48) {\\n            return arrivalTime + delayedTime - 24\\n        }\\n        return arrivalTime + delayedTime\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056843,
                "title": "100-beats-0ms-1-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n           \\n               return  (arrivalTime+delayedTime)%24;\\n           \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n           \\n               return  (arrivalTime+delayedTime)%24;\\n           \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050730,
                "title": "java-so-lution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042710,
                "title": "simple-straight-forward-without-any-optimisation",
                "content": "# Intuition\\nIt\\'s a very simple problem, use reminder of 24 to get hours\\n\\n# Approach\\nBrute force approach\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun findDelayedArrivalTime(arrivalTime: Int, delayedTime: Int): Int {\\n        var time = arrivalTime + delayedTime\\n\\n        time = time % 24\\n\\n        return time\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun findDelayedArrivalTime(arrivalTime: Int, delayedTime: Int): Int {\\n        var time = arrivalTime + delayedTime\\n\\n        time = time % 24\\n\\n        return time\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036292,
                "title": "2-lines-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int res = (arrivalTime + delayedTime);\\n        return res % 24 ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int res = (arrivalTime + delayedTime);\\n        return res % 24 ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027381,
                "title": "simplest-code-0ms-runtime",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) \\n    {\\n     \\n      int sum = arrivalTime + delayedTime;\\n       if(sum >= 24)\\n       {\\n           sum -= 24;  // sum = sum - 24\\n       }  \\n       return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) \\n    {\\n     \\n      int sum = arrivalTime + delayedTime;\\n       if(sum >= 24)\\n       {\\n           sum -= 24;  // sum = sum - 24\\n       }  \\n       return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023884,
                "title": "beginner-friendly-python-runtime-8ms-beats-96-5",
                "content": "# Complexity\\n- Time complexity:\\nRuntime 8ms || Beats 96.5%\\n\\n- Space complexity:\\nMemory 13.2MB || Beats 39.13%\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findDelayedArrivalTime(self, arrivalTime, delayedTime):\\n        return (arrivalTime + delayedTime) % 24\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findDelayedArrivalTime(self, arrivalTime, delayedTime):\\n        return (arrivalTime + delayedTime) % 24\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022072,
                "title": "easiest-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n    return (arrivalTime + delayedTime) % 24\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n    return (arrivalTime + delayedTime) % 24\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014498,
                "title": "solution-using-python",
                "content": "# Complexity\\n- Time complexity: 9ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 13.30MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findDelayedArrivalTime(self, arrivalTime, delayedTime):\\n        \"\"\"\\n        :type arrivalTime: int\\n        :type delayedTime: int\\n        :rtype: int\\n        \"\"\"\\n        res = arrivalTime + delayedTime\\n        res1 = res%24\\n        if res <= 24:\\n            if res1!=0:\\n                return res\\n            elif res1==0:\\n                return 0\\n        elif res <= 47:\\n            res1 = res1%24\\n            return res1\\n        else:\\n            return 0\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findDelayedArrivalTime(self, arrivalTime, delayedTime):\\n        \"\"\"\\n        :type arrivalTime: int\\n        :type delayedTime: int\\n        :rtype: int\\n        \"\"\"\\n        res = arrivalTime + delayedTime\\n        res1 = res%24\\n        if res <= 24:\\n            if res1!=0:\\n                return res\\n            elif res1==0:\\n                return 0\\n        elif res <= 47:\\n            res1 = res1%24\\n            return res1\\n        else:\\n            return 0\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008143,
                "title": "python-simple-solution-math",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nclass Solution:\\n  def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n    return (arrivalTime + delayedTime) % 24\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n  def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n    return (arrivalTime + delayedTime) % 24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998172,
                "title": "o-1-100-beats-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime>=24){            \\n            return (arrivalTime+delayedTime)-24;\\n        }else{\\n            return arrivalTime+delayedTime;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime>=24){            \\n            return (arrivalTime+delayedTime)-24;\\n        }else{\\n            return arrivalTime+delayedTime;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995903,
                "title": "one-line-python3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991512,
                "title": "only-one-line-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nonly one line code using Modulo operator.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        return (a+b)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) {\\n        return (a+b)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983551,
                "title": "c-very-simple-and-easy-to-understand-solution",
                "content": "# Intuition\\nThe intuition behind this solution is to calculate the time when the train will arrive at the station after accounting for the delay.\\n\\n# Approach\\nThe approach to solving this problem involves adding the `arrivalTime` and `delayedTime` to determine the new arrival time after the delay. If the sum of `arrivalTime` and `delayedTime` exceeds 23 (the maximum hour in 24-hour format), we need to subtract 24 to get the correct time within the 24-hour format.\\n\\n# Complexity\\n- Time complexity: **O(1)**  \\n\\n- Space complexity: **O(1)**  \\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if (arrivalTime + delayedTime > 23) {\\n            return (arrivalTime + delayedTime) - 24;\\n        }\\n        return arrivalTime + delayedTime;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if (arrivalTime + delayedTime > 23) {\\n            return (arrivalTime + delayedTime) - 24;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3977565,
                "title": "easiest-c-solution-2023",
                "content": "```\\nint findDelayedArrivalTime(int arrivalTime, int delayedTime){\\nreturn (arrivalTime+delayedTime)%24;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findDelayedArrivalTime(int arrivalTime, int delayedTime){\\nreturn (arrivalTime+delayedTime)%24;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3967568,
                "title": "simplest-java-code-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int time = arrivalTime + delayedTime;\\n        if(time < 24){\\n            return time;\\n        }\\n        return time-24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int time = arrivalTime + delayedTime;\\n        if(time < 24){\\n            return time;\\n        }\\n        return time-24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967379,
                "title": "simple-solution-using-java",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950413,
                "title": "beginner-friendly-100-beats-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a basic question which can easily be easily solved from if and else condition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->To solve this problem first we need to compare the sum of the arrivaltime and delayed time with 24 as the output should be in 24 hrs format.\\nIf the sum is greater or equal to 24 we can simply return (time-24).\\nelse directly we will return the sum.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int time=arrivalTime+delayedTime;\\n        if(time>=24){\\n            return (time-24);\\n        }\\n        else {\\n            return time;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int time=arrivalTime+delayedTime;\\n        if(time>=24){\\n            return (time-24);\\n        }\\n        else {\\n            return time;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944981,
                "title": "c-solution-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int  s=arrivalTime+delayedTime;\\n        if(s==24){\\n            return 0;\\n        }else if(s<24){\\n            return s;\\n        }else{\\n            return s-24;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int  s=arrivalTime+delayedTime;\\n        if(s==24){\\n            return 0;\\n        }else if(s<24){\\n            return s;\\n        }else{\\n            return s-24;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941933,
                "title": "single-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime+delayedTime) if arrivalTime+delayedTime<24 else arrivalTime+delayedTime-24\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime+delayedTime) if arrivalTime+delayedTime<24 else arrivalTime+delayedTime-24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941090,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return ((arrivalTime  + delayedTime) % 24);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return ((arrivalTime  + delayedTime) % 24);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937822,
                "title": "calculate-delayed-arrival-time-in-java",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(1)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931685,
                "title": "very-easy-math-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int at = arrivalTime;\\n        int dt = delayedTime;\\n        int t = dt + at;\\n        if(t >= 24){\\n            return t - 24;\\n        }\\n        return t % 24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int at = arrivalTime;\\n        int dt = delayedTime;\\n        int t = dt + at;\\n        if(t >= 24){\\n            return t - 24;\\n        }\\n        return t % 24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925999,
                "title": "one-line-code-beats-100-memory-and-100-time",
                "content": "\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        return (a+d)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        return (a+d)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924631,
                "title": "simple-elixir-solution",
                "content": "```\\ndefmodule Solution do\\n  @spec find_delayed_arrival_time(arrival_time :: integer, delayed_time :: integer) :: integer\\n  def find_delayed_arrival_time(arrival_time, delayed_time) do\\n      new_time = arrival_time + delayed_time\\n      new_time = if new_time >= 24 do\\n                   new_time - 24\\n                 else\\n                   new_time\\n                 end\\n                  \\n      \\n      new_time\\n\\n  end\\nend\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndefmodule Solution do\\n  @spec find_delayed_arrival_time(arrival_time :: integer, delayed_time :: integer) :: integer\\n  def find_delayed_arrival_time(arrival_time, delayed_time) do\\n      new_time = arrival_time + delayed_time\\n      new_time = if new_time >= 24 do\\n                   new_time - 24\\n                 else\\n                   new_time\\n                 end\\n                  \\n      \\n      new_time\\n\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3922014,
                "title": "kotlin-oneline-solution",
                "content": "```\\nclass Solution {\\n    fun findDelayedArrivalTime(arrivalTime: Int, delayedTime: Int): Int = (arrivalTime + delayedTime) % 24\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun findDelayedArrivalTime(arrivalTime: Int, delayedTime: Int): Int = (arrivalTime + delayedTime) % 24\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921241,
                "title": "solved-in-c-00ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int sumOfHours=delayedTime+arrivalTime;\\n        if (sumOfHours >= 24){\\n            return sumOfHours -24;\\n        }\\n        return sumOfHours;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int sumOfHours=delayedTime+arrivalTime;\\n        if (sumOfHours >= 24){\\n            return sumOfHours -24;\\n        }\\n        return sumOfHours;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911397,
                "title": "beats-100-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int x=arrivalTime+delayedTime;\\n        if(x>=24)\\n        x=x%24;\\n        return x;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int x=arrivalTime+delayedTime;\\n        if(x>=24)\\n        x=x%24;\\n        return x;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910105,
                "title": "2651-calculate-delayed-arrival-time-solution-for-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        resTime = arrivalTime\\n        more = delayedTime\\n        \\n        while more != 0:\\n            more -= 1\\n            resTime += 1\\n            if resTime == 24:\\n                resTime = 0\\n        return resTime\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        resTime = arrivalTime\\n        more = delayedTime\\n        \\n        while more != 0:\\n            more -= 1\\n            resTime += 1\\n            if resTime == 24:\\n                resTime = 0\\n        return resTime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908727,
                "title": "c-easy-worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n     int delayedArrival=arrivalTime+delayedTime;\\n     return delayedArrival%24;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n     int delayedArrival=arrivalTime+delayedTime;\\n     return delayedArrival%24;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908324,
                "title": "give-the-delayed-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        \\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        \\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899659,
                "title": "beats-100-veryy-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) \\n    {\\n        int sum = a + b;\\n        \\n        if (sum >= 24) {\\n            sum -= 24;  // Adjust the time if it\\'s past 24 hours\\n        }\\n        \\n        return sum; // Convert and return the integer part of sum\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int b) \\n    {\\n        int sum = a + b;\\n        \\n        if (sum >= 24) {\\n            sum -= 24;  // Adjust the time if it\\'s past 24 hours\\n        }\\n        \\n        return sum; // Convert and return the integer part of sum\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896868,
                "title": "go-simple-solution",
                "content": "```go\\n// Improve documentation\\nconst (\\n    maxHourPerDay = 24\\n)\\n\\nfunc findDelayedArrivalTime(arrivalTime, delayedTime int) int {\\n    return (arrivalTime + delayedTime) % maxHourPerDay\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n// Improve documentation\\nconst (\\n    maxHourPerDay = 24\\n)\\n\\nfunc findDelayedArrivalTime(arrivalTime, delayedTime int) int {\\n    return (arrivalTime + delayedTime) % maxHourPerDay\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3895451,
                "title": "beats-100-00-of-users-with-c-hope-you-upvote-me",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime + delayedTime >=24)\\n        return arrivalTime +delayedTime-24;\\n        return arrivalTime +delayedTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime + delayedTime >=24)\\n        return arrivalTime +delayedTime-24;\\n        return arrivalTime +delayedTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892346,
                "title": "100-simple-python-solution-with-best-efficiency-90",
                "content": "# Intuition\\n>First Just plus two Numbers\\n> Check on 24\\n> If more then take Remainder\\n\\n\\n# Approach\\n> Brut Force\\n\\n# Complexity\\n- Time complexity:\\n> O(1)\\n\\n- Space complexity:\\n> O(1)\\n\\n\\n> ----\\n\\n\\n![Capture.JPG](https://assets.leetcode.com/users/images/c297efbb-4c3f-4a24-b8fb-f7ecd6edcd0b_1691698542.1492267.jpeg)\\n\\n> -----\\n\\n\\n> ### kindly Like my Solution. Please It will Support me. Thanks.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findDelayedArrivalTime(self, arrivalTime, delayedTime):\\n        \"\"\"\\n        :type arrivalTime: int\\n        :type delayedTime: int\\n        :rtype: int\\n        \"\"\"\\n        arrivalTime = arrivalTime + delayedTime   # O(1)\\n        if arrivalTime >= 24:                     # O(1)\\n          arrivalTime = arrivalTime % 24          \\n\\n        return arrivalTime\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findDelayedArrivalTime(self, arrivalTime, delayedTime):\\n        \"\"\"\\n        :type arrivalTime: int\\n        :type delayedTime: int\\n        :rtype: int\\n        \"\"\"\\n        arrivalTime = arrivalTime + delayedTime   # O(1)\\n        if arrivalTime >= 24:                     # O(1)\\n          arrivalTime = arrivalTime % 24          \\n\\n        return arrivalTime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891580,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n       int ans = 0;\\n\\n        if (arrivalTime + delayedTime >= 24) {\\n            ans = (arrivalTime + delayedTime) - 24;\\n        } else {\\n            ans = arrivalTime + delayedTime;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n       int ans = 0;\\n\\n        if (arrivalTime + delayedTime >= 24) {\\n            ans = (arrivalTime + delayedTime) - 24;\\n        } else {\\n            ans = arrivalTime + delayedTime;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891490,
                "title": "easy-cpp-solution-single-line-solution-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        // By using % 24, we ensure that \\n        // The arrivalTime + delayedTime does not exceeds 24\\n        // and remains in the 24 hours format as mentioned in problem statement\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        // By using % 24, we ensure that \\n        // The arrivalTime + delayedTime does not exceeds 24\\n        // and remains in the 24 hours format as mentioned in problem statement\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890474,
                "title": "delayed-arrival-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime+delayedTime)%24\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime+delayedTime)%24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889307,
                "title": "simple-and-easy-java-solution-single-line-answer-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884765,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n       int sum=0;\\n       sum=arrivalTime+delayedTime;\\n\\n       if(sum<24){\\n           sum=sum;\\n       } \\n\\n       else if(sum>24){\\n           sum=sum-24;\\n       }\\n       else{\\n           sum=0;\\n       }\\n       return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n       int sum=0;\\n       sum=arrivalTime+delayedTime;\\n\\n       if(sum<24){\\n           sum=sum;\\n       } \\n\\n       else if(sum>24){\\n           sum=sum-24;\\n       }\\n       else{\\n           sum=0;\\n       }\\n       return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882462,
                "title": "python3-the-best-uzbekistan",
                "content": "# Intuition\\n![Screenshot from 2023-08-08 20-44-45.png](https://assets.leetcode.com/users/images/87a76601-8951-4284-ac96-648a53aef00f_1691509531.998496.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880681,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans = arrivalTime + delayedTime;\\n\\n        if(ans>=24) return ans-24;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans = arrivalTime + delayedTime;\\n\\n        if(ans>=24) return ans-24;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872027,
                "title": "beats-99-07-99-40-solution-from-a-noob",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n***30ms\\nBeats 99.07%of users with Python3***\\n\\n- Space complexity:\\n***16.06mb\\nBeats 99.40%of users with Python3***\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, a: int, d: int) -> int:\\n        s=a+d\\n        #sum of arrival and delay\\n        while s>24:\\n            s=s-24\\n        #Note that the time in this problem is in 24-hours format.(desc.)\\n        if s==24:\\n            s=0\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, a: int, d: int) -> int:\\n        s=a+d\\n        #sum of arrival and delay\\n        while s>24:\\n            s=s-24\\n        #Note that the time in this problem is in 24-hours format.(desc.)\\n        if s==24:\\n            s=0\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871508,
                "title": "short-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n          return (arrivalTime+delayedTime)%24\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n          return (arrivalTime+delayedTime)%24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861519,
                "title": "beats-88-easy-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        if (arrivalTime+delayedTime)>=24: return (arrivalTime+delayedTime)-24\\n        else: return arrivalTime + delayedTime\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        if (arrivalTime+delayedTime)>=24: return (arrivalTime+delayedTime)-24\\n        else: return arrivalTime + delayedTime\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860743,
                "title": "2651-calculate-delayed-arrival-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        output=arrivalTime+delayedTime\\n        if output>=24:\\n            output-=24\\n        return output        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        output=arrivalTime+delayedTime\\n        if output>=24:\\n            output-=24\\n        return output        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858678,
                "title": "using-mod",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int r=arrivalTime+delayedTime;\\n        return (r%24);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int r=arrivalTime+delayedTime;\\n        return (r%24);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857196,
                "title": "beats-100-cpp-users-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\n       int ans=arrivalTime+delayedTime;\\n       if(ans>=24){\\n           ans=ans-24;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\n       int ans=arrivalTime+delayedTime;\\n       if(ans>=24){\\n           ans=ans-24;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853554,
                "title": "c-easy-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:***O(1)***\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ***O(1)***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime + delayedTime >= 24)\\n        {\\n            return arrivalTime + delayedTime - 24;\\n        }\\n        return arrivalTime + delayedTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime + delayedTime >= 24)\\n        {\\n            return arrivalTime + delayedTime - 24;\\n        }\\n        return arrivalTime + delayedTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844377,
                "title": "easy-and-quick-solution-using-javascript-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function (arrivalTime, delayedTime) {\\n    let totalTime = arrivalTime + delayedTime; // initialize totalTime is the sum of arrivalTime and delayedTime\\n\\n    if (totalTime == 24) { // if totalTime is equal to 24 then return 0\\n        return 0;\\n    } else if (totalTime < 24) { // if totalTime is less than 24 then return totalTime\\n        return totalTime;\\n    } else { // else return subtraction of totalTime to 24\\n        return totalTime - 24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function (arrivalTime, delayedTime) {\\n    let totalTime = arrivalTime + delayedTime; // initialize totalTime is the sum of arrivalTime and delayedTime\\n\\n    if (totalTime == 24) { // if totalTime is equal to 24 then return 0\\n        return 0;\\n    } else if (totalTime < 24) { // if totalTime is less than 24 then return totalTime\\n        return totalTime;\\n    } else { // else return subtraction of totalTime to 24\\n        return totalTime - 24;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3841522,
                "title": "java-one-line-100-faster",
                "content": "\\tclass Solution {\\n\\t\\tpublic int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\t\\t\\treturn (arrivalTime + delayedTime)%24;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n\\t\\tpublic int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\t\\t\\treturn (arrivalTime + delayedTime)%24;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3840534,
                "title": "python-easy-clean-one-line-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```\\n![catty.png](https://assets.leetcode.com/users/images/99367335-87d2-40e4-a585-9428dd5db020_1690761949.3162441.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839250,
                "title": "sreeja-s-approach-python3-easy-solution-beats-84",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        time = arrivalTime + delayedTime\\n        if time == 24:\\n            return 0\\n        elif time > 24:\\n            return time - 24\\n        else:\\n            return time\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        time = arrivalTime + delayedTime\\n        if time == 24:\\n            return 0\\n        elif time > 24:\\n            return time - 24\\n        else:\\n            return time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837250,
                "title": "java-beats-100-00-of-users-with-java-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int sum =arrivalTime+delayedTime;\\n        int tot=0;\\n        if(sum==24){\\n            tot =0;\\n        }\\n        else if(sum>24){\\n            tot =(arrivalTime+delayedTime)-24;\\n        }\\n        else if(sum<24){\\n            tot =sum;\\n        }\\n        return tot;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int sum =arrivalTime+delayedTime;\\n        int tot=0;\\n        if(sum==24){\\n            tot =0;\\n        }\\n        else if(sum>24){\\n            tot =(arrivalTime+delayedTime)-24;\\n        }\\n        else if(sum<24){\\n            tot =sum;\\n        }\\n        return tot;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834162,
                "title": "easiest-100-beats-one-line-ans",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime +delayedTime)%24;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime +delayedTime)%24;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833877,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans;\\n        int totalHours = arrivalTime + delayedTime;\\n        \\n        if (totalHours >= 24) {\\n            ans = totalHours % 24;\\n        } else {\\n            ans = totalHours;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans;\\n        int totalHours = arrivalTime + delayedTime;\\n        \\n        if (totalHours >= 24) {\\n            ans = totalHours % 24;\\n        } else {\\n            ans = totalHours;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832953,
                "title": "delayed-arrival-time-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n0s\\n\\n- Space complexity:\\n6MB\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int result = arrivalTime+delayedTime;\\n        if(result < 24){\\n            return result;\\n        }else{\\n            result -= 24;\\n            return result;\\n        }    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int result = arrivalTime+delayedTime;\\n        if(result < 24){\\n            return result;\\n        }else{\\n            result -= 24;\\n            return result;\\n        }    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831459,
                "title": "c-easy-solution-3-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayed) {\\n        if(arrivalTime+delayed==24)\\n        {\\n            return 0;\\n        }\\n        if(arrivalTime+delayed>24)\\n        {\\n            return (arrivalTime+delayed)-24;\\n        }\\n        return arrivalTime+delayed;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayed) {\\n        if(arrivalTime+delayed==24)\\n        {\\n            return 0;\\n        }\\n        if(arrivalTime+delayed>24)\\n        {\\n            return (arrivalTime+delayed)-24;\\n        }\\n        return arrivalTime+delayed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821581,
                "title": "2651-calculate-delayed-arrival-time",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        if(a+d>=24){\\n            return (a+d-24);\\n        }\\n        else{\\n            return a+d;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int a, int d) {\\n        if(a+d>=24){\\n            return (a+d-24);\\n        }\\n        else{\\n            return a+d;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819360,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        finaltime = arrivalTime + delayedTime\\n        return finaltime % 24\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        finaltime = arrivalTime + delayedTime\\n        return finaltime % 24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819010,
                "title": "c-beats-100-easy-to-understand-solution",
                "content": "# Complexity\\n- Time complexity:\\nThe time complexity of the code is O(1)\\n- Space complexity:\\nThe space complexity of the code is also O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\n        int ans = arrivalTime+delayedTime;\\n        if(ans>=24)\\n        {\\n            ans = ans-24;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\n        int ans = arrivalTime+delayedTime;\\n        if(ans>=24)\\n        {\\n            ans = ans-24;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818754,
                "title": "java-beats-97-memory-beats-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n      int total=arrivalTime+delayedTime;\\n      return total%24; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n      int total=arrivalTime+delayedTime;\\n      return total%24; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813016,
                "title": "easy-solution-in-c-beats-100",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime) % 24;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime) % 24;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812297,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        \\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        \\n        return (arrivalTime+delayedTime)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810422,
                "title": "c-one-line-code-simple-and-easy-approach",
                "content": "# Intuition\\nWe are given a positive integer arrivalTime denoting the arrival time of a train in hours, and another positive integer delayedTime denoting the amount of delay in hours. We have to return the time when the train will arrive at the station where the time in this problem is in 24-hours format.\\n\\n# Approach\\nThe time when train will arrive at the station is (arrivalTime+delayedTime)%24, that is because the total time train will take to arrive is arrivalTime+delayedTime and in 24-hour clock the clock resets at 24th hour to 00:00 as it is cyclic in nature, so we return (arrivalTime+delayedTime)%24.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime+delayedTime)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806562,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int result = arrivalTime + delayedTime;\\n        if(result >= 24) return result - 24;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int result = arrivalTime + delayedTime;\\n        if(result >= 24) return result - 24;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801864,
                "title": "with-explanation-comments-time-xx-ms-98-97-space-xx-mb-89-9",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        \\n        return (arrivalTime+delayedTime < 24) ? arrivalTime+delayedTime : arrivalTime+delayedTime-24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        \\n        return (arrivalTime+delayedTime < 24) ? arrivalTime+delayedTime : arrivalTime+delayedTime-24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801042,
                "title": "simple-kotlin-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    fun findDelayedArrivalTime(arrivalTime: Int, delayedTime: Int): Int {\\n        return if (arrivalTime + delayedTime >= 24) {\\n            arrivalTime + delayedTime - 24\\n        } else {\\n            arrivalTime + delayedTime\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun findDelayedArrivalTime(arrivalTime: Int, delayedTime: Int): Int {\\n        return if (arrivalTime + delayedTime >= 24) {\\n            arrivalTime + delayedTime - 24\\n        } else {\\n            arrivalTime + delayedTime\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799743,
                "title": "python-rust-solution-0-ms",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```\\n```rust []\\nimpl Solution {\\n    pub fn find_delayed_arrival_time(arrival_time: i32, delayed_time: i32) -> i32 {\\n        (arrival_time + delayed_time) % 24\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```python []\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```\n```rust []\\nimpl Solution {\\n    pub fn find_delayed_arrival_time(arrival_time: i32, delayed_time: i32) -> i32 {\\n        (arrival_time + delayed_time) % 24\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797546,
                "title": "very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24) {\\n            return (arrivalTime+delayedTime);\\n        }else {\\n            return (arrivalTime+delayedTime-24);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24) {\\n            return (arrivalTime+delayedTime);\\n        }else {\\n            return (arrivalTime+delayedTime-24);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796231,
                "title": "simple-solution-in-java",
                "content": "In this code we takes two integer parameters and they returns an integer value. after that we add both arrivalTime and delayedTime and store the result in the variable \\'ans\\'. and then we take condition if our ans is greater than 24(time exceeded one day). it means arrival will happen on next day, in this case, code subtracts 24 from \\'ans\\' to adjust time within 24 hour format. After that code returns calculated \\'ans\\', which represents delayed arrival time.\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans = arrivalTime+delayedTime;\\n        int num = 0;\\n        if(ans>=24){\\n            ans = ans-24;\\n            return ans;\\n        }\\n        else{\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int ans = arrivalTime+delayedTime;\\n        int num = 0;\\n        if(ans>=24){\\n            ans = ans-24;\\n            return ans;\\n        }\\n        else{\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795093,
                "title": "c-one-line-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime) % 24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793976,
                "title": "java",
                "content": "# Code\\n```\\nclass Solution \\n{\\n    public int findDelayedArrivalTime(int a, int d) \\n    {\\n        int t = a + d;\\n        if(t >= 24)\\n        t = t % 24;\\n        return t;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int findDelayedArrivalTime(int a, int d) \\n    {\\n        int t = a + d;\\n        if(t >= 24)\\n        t = t % 24;\\n        return t;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791711,
                "title": "java-easy-solution-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int d) {\\n        if(a+d<24)\\n        return a+d;\\n        else\\n        return Math.abs(24-(a+d));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int d) {\\n        if(a+d<24)\\n        return a+d;\\n        else\\n        return Math.abs(24-(a+d));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788379,
                "title": "one-line-solution-and-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 26 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 26.72mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime)%24;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime)%24;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782361,
                "title": "simple-formula",
                "content": "![image.png](https://assets.leetcode.com/users/images/65869e86-149f-4098-8467-fdc086e9f5b8_1689674214.6587172.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        return (arrivalTime + delayedTime) % 24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780598,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        sum = arrivalTime + delayedTime\\n        if sum != 24 and sum< 24:\\n            return sum\\n        else:\\n            return sum -24\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n        sum = arrivalTime + delayedTime\\n        if sum != 24 and sum< 24:\\n            return sum\\n        else:\\n            return sum -24\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778733,
                "title": "java-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int r = arrivalTime + delayedTime;\\n        if(r >= 24){\\n            r = r-24;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int r = arrivalTime + delayedTime;\\n        if(r >= 24){\\n            r = r-24;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774831,
                "title": "time-o-1-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n\\n        a = arrivalTime + delayedTime\\n        if a==24:\\n            return 0\\n        elif a>24:\\n            return a-24\\n        else:\\n            return a\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n\\n        a = arrivalTime + delayedTime\\n        if a==24:\\n            return 0\\n        elif a>24:\\n            return a-24\\n        else:\\n            return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774556,
                "title": "easy-3-line-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        \\n        return arrivalTime+delayedTime-24;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        \\n        return arrivalTime+delayedTime-24;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767009,
                "title": "100-faster-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime)%24;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        return (arrivalTime + delayedTime)%24;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763845,
                "title": "one-liner-solution-containing-only-return-statement-beating-100-in-both-runtime-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int d) {\\n        return ((a+d)%24); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int d) {\\n        return ((a+d)%24); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761529,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(logn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3758127,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int ar, int de) {\\n        if(ar+de>=24 || de+ar>=24){\\n            return Math.abs(ar+de-24); \\n        }\\n        return (ar+de)==24?0:ar+de;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int ar, int de) {\\n        if(ar+de>=24 || de+ar>=24){\\n            return Math.abs(ar+de-24); \\n        }\\n        return (ar+de)==24?0:ar+de;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752938,
                "title": "c-100-faster-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tint findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\t\\treturn (arrivalTime + delayedTime) % 24;       \\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n\\t\\treturn (arrivalTime + delayedTime) % 24;       \\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750432,
                "title": "java-delayed-arrival-time-explained",
                "content": "# Approach\\nJust some Cases to take care of like the sum being 24 or above.\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int aT, int dT) {\\n        int sum=aT+dT;\\n        if(sum==24){return 0;}\\n        if(sum>24){return sum-24;}\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int aT, int dT) {\\n        int sum=aT+dT;\\n        if(sum==24){return 0;}\\n        if(sum>24){return sum-24;}\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747098,
                "title": "simple-solution-c",
                "content": "# Complexity\\n- Time complexity: **O(1)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n    return (arrivalTime + delayedTime) % 24;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741750,
                "title": "very-very-easy-solution-simple-to-understand-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int d) {\\n        int c = a+d;\\n        if(c>24)\\n            return c-24;\\n        else if(c==24)\\n            return 0;\\n        else\\n            return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int d) {\\n        int c = a+d;\\n        if(c>24)\\n            return c-24;\\n        else if(c==24)\\n            return 0;\\n        else\\n            return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741746,
                "title": "very-very-easy-solution-simple-to-understand-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int d) {\\n        int c = a+d;\\n        if(c>24)\\n            return c-24;\\n        else if(c==24)\\n            return 0;\\n        else\\n            return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int a, int d) {\\n        int c = a+d;\\n        if(c>24)\\n            return c-24;\\n        else if(c==24)\\n            return 0;\\n        else\\n            return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737386,
                "title": "just-one-line-javascript",
                "content": "# Have fun with my code\\n```\\nconst findDelayedArrivalTime = (arrivalTime, delayedTime) => (arrivalTime + delayedTime) % 24\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findDelayedArrivalTime = (arrivalTime, delayedTime) => (arrivalTime + delayedTime) % 24\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3736602,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int c= arrivalTime+delayedTime;\\n        int d=c-24;\\n        if(c<24){\\n            return c;\\n        }\\n        else \\n        return d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        int c= arrivalTime+delayedTime;\\n        int d=c-24;\\n        if(c<24){\\n            return c;\\n        }\\n        else \\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735271,
                "title": "finddelayedarrivaltime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n\\n     let time = arrivalTime + delayedTime;\\n     let output = time >= 24 ? time - 24 : time; \\n\\n     return output;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} arrivalTime\\n * @param {number} delayedTime\\n * @return {number}\\n */\\nvar findDelayedArrivalTime = function(arrivalTime, delayedTime) {\\n\\n     let time = arrivalTime + delayedTime;\\n     let output = time >= 24 ? time - 24 : time; \\n\\n     return output;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731824,
                "title": "one-line-code-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n             return (arrivalTime + delayedTime) % 24\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\\n             return (arrivalTime + delayedTime) % 24\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1871512,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 2047912,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1874264,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1872350,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1943111,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 2069849,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1991763,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1964413,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1959184,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1936237,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1871512,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 2047912,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1874264,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1872350,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1943111,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 2069849,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1991763,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1964413,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1959184,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            },
            {
                "id": 1936237,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Bruh, for real?"
                    },
                    {
                        "username": "123GJWEQ2",
                        "content": "some of the other problems were tough tho"
                    },
                    {
                        "username": "getimad",
                        "content": "It is a good start after \"Hello World!\" problem."
                    },
                    {
                        "username": "user4779gR",
                        "content": "This one was so easy I was thinking I misunderstood the prompt."
                    },
                    {
                        "username": "Balwierz",
                        "content": "I can\\'t believe people are posting solutions to this problem"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "genuinely came here for this comment :\\'))"
                    },
                    {
                        "username": "dmr11235",
                        "content": "Question is trivial, consider removing"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "I\\'m wondering why do we have hard questions that give no hints at all, while this easy question generously gives out 4 hints (well 2 actually)."
                    },
                    {
                        "username": "Ramya1102",
                        "content": "I had to submit the answer to actually see if there\\'s some hidden difficulty. lol"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "This question is too hard for me :((((("
                    },
                    {
                        "username": "jarircse16ruet",
                        "content": "class Solution {\\npublic:\\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\\n        if(arrivalTime+delayedTime<24)\\n            return arrivalTime+delayedTime;\\n        else \\n            return abs(24 - (arrivalTime+delayedTime));\\n    }\\n};"
                    },
                    {
                        "username": "manojscoder",
                        "content": " return (arrivalTime + delayedTime) % 24;"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "fr ? its not even a question bruh! "
                    }
                ]
            }
        ]
    },
    {
        "title": "Allow One Function Call",
        "question_content": "<p>Given a function <code>fn</code>, return a new function that is identical to the original function except that it ensures&nbsp;<code>fn</code>&nbsp;is&nbsp;called at most once.</p>\n\n<ul>\n\t<li>The first time the returned function is called, it should return the same result as&nbsp;<code>fn</code>.</li>\n\t<li>Every subsequent time it is called, it should return&nbsp;<code>undefined</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> fn = (a,b,c) =&gt; (a + b + c), calls = [[1,2,3],[2,3,6]]\n<strong>Output:</strong> [{&quot;calls&quot;:1,&quot;value&quot;:6}]\n<strong>Explanation:</strong>\nconst onceFn = once(fn);\nonceFn(1, 2, 3); // 6\nonceFn(2, 3, 6); // undefined, fn was not called\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> fn = (a,b,c) =&gt; (a * b * c), calls = [[5,7,4],[2,3,6],[4,6,8]]\n<strong>Output:</strong> [{&quot;calls&quot;:1,&quot;value&quot;:140}]\n<strong>Explanation:</strong>\nconst onceFn = once(fn);\nonceFn(5, 7, 4); // 140\nonceFn(2, 3, 6); // undefined, fn was not called\nonceFn(4, 6, 8); // undefined, fn was not called\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>calls</code> is a valid JSON array</li>\n\t<li><code>1 &lt;= calls.length &lt;= 10</code></li>\n\t<li><code>1 &lt;= calls[i].length &lt;= 100</code></li>\n\t<li><code>2 &lt;= JSON.stringify(calls).length &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3514065,
                "title": "o-1-sc-o-1-tc-4-diff-method-solution-in-js-and-typescript-day-8",
                "content": "# Intuition\\nThe problem is asking us to return a `new function` that behaves differently depending on whether it has been called before. If it has not been called before, it should call the original function and return its result. If it has been called before, it should return `undefined` without calling the original function again.\\n\\n# Approach\\nTo solve this problem, we can return a `new function `that keeps track of whether it has been called before. We can do this by using a `closure `to store a `boolean flag` that is initially set to false. The first time the new function is called, we call the original function and set the flag to `true`. We also store the result of the original function. Subsequent calls to the new function simply return `undefined `without calling the original function again.\\n\\n# Complexity\\n- Time complexity:\\nO(1) for both the first and subsequent calls to the returned function. This is because checking the hasBeenCalled flag and returning either the result or undefined are constant-time operations.\\n\\n- Space complexity:\\nO(1) as well. This is because we only use a constant amount of extra space to store the hasBeenCalled flag and the result of the original function. \\n\\n# Learning \\nThe key idea behind this problem is to use a closure to store the state of the returned function. By doing this, we can keep track of whether the function has been called before and behave accordingly.\\n\\n# Code In JS\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n\\n};\\n\\nlet fn = (a,b,c) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1,2,3)); // 6\\nconsole.log(onceFn(2,3,6)); // undefined\\n```\\n\\n# Code In TypeScript\\n```\\ntype Func<T, U> = (...args: T[]) => U;\\n\\nfunction once<T, U>(fn: Func<T, U>): Func<T, U | undefined> {\\n  let hasBeenCalled = false;\\n  let result: U;\\n\\n  return function (...args: T[]): U | undefined {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n}\\n\\n// Example usage:\\nlet fn = (a: number, b: number, c: number) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1, 2, 3)); // 6\\nconsole.log(onceFn(2, 3, 6)); // undefined\\n\\n```\\n\\n# Using a closure and an arrow function\\n\\nIn this approach, we use an `arrow function` to create the returned function. We store the` hasBeenCalled flag` and result in a closure, and use an if statement to check whether the function has already been called.\\n\\n```\\nfunction once(fn) {\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return (...args) => {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```\\n\\n# Using a class\\n\\nIn this approach, we define a `Once class` that has a call method that behaves like the returned function in the previous approaches. We use a class property to store the hasBeenCalled flag and result.\\n\\n```\\nclass Once {\\n  hasBeenCalled = false;\\n  result;\\n\\n  call(fn, ...args) {\\n    if (!this.hasBeenCalled) {\\n      this.result = fn(...args);\\n      this.hasBeenCalled = true;\\n      return this.result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n}\\n\\nfunction once(fn) {\\n  const instance = new Once();\\n  return instance.call.bind(instance, fn);\\n}\\n\\n```\\n# Using a traditional function and an object\\n\\nwe use a` traditional function` to create the returned function. Instead of using a `closure`, we store the `hasBeenCalled flag` and result in an object that is passed as an argument to the returned function.\\n\\n```\\nfunction once(fn) {\\n  return function(...args) {\\n    const state = {\\n      hasBeenCalled: false,\\n      result: undefined\\n    };\\n\\n    if (!state.hasBeenCalled) {\\n      state.result = fn(...args);\\n      state.hasBeenCalled = true;\\n      return state.result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```\\n![upvote-2.png](https://assets.leetcode.com/users/images/e79ad083-6070-43a5-903c-7a0bdf69dcf4_1683853739.9399579.png)\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n\\n};\\n\\nlet fn = (a,b,c) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1,2,3)); // 6\\nconsole.log(onceFn(2,3,6)); // undefined\\n```\n```\\ntype Func<T, U> = (...args: T[]) => U;\\n\\nfunction once<T, U>(fn: Func<T, U>): Func<T, U | undefined> {\\n  let hasBeenCalled = false;\\n  let result: U;\\n\\n  return function (...args: T[]): U | undefined {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n}\\n\\n// Example usage:\\nlet fn = (a: number, b: number, c: number) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1, 2, 3)); // 6\\nconsole.log(onceFn(2, 3, 6)); // undefined\\n\\n```\n```\\nfunction once(fn) {\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return (...args) => {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```\n```\\nclass Once {\\n  hasBeenCalled = false;\\n  result;\\n\\n  call(fn, ...args) {\\n    if (!this.hasBeenCalled) {\\n      this.result = fn(...args);\\n      this.hasBeenCalled = true;\\n      return this.result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n}\\n\\nfunction once(fn) {\\n  const instance = new Once();\\n  return instance.call.bind(instance, fn);\\n}\\n\\n```\n```\\nfunction once(fn) {\\n  return function(...args) {\\n    const state = {\\n      hasBeenCalled: false,\\n      result: undefined\\n    };\\n\\n    if (!state.hasBeenCalled) {\\n      state.result = fn(...args);\\n      state.hasBeenCalled = true;\\n      return state.result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514233,
                "title": "dry-run-beginner-friendly-explanation-js-ts-o-1-sc-o-1-tc-day8",
                "content": "## Intuition: \\nWe can keep a boolean which can track if a function is called or not\\n***\\n## Explanation: \\n* The returned function uses a **[Closure](https://leetcode.com/problems/counter/discuss/3491300/Day2O(1)greaterUnderstanding-Closure-in-easy-way-and-its-practical-uses!!)** to keep track of whether `fn` has already been called. The `usedOnce` variable is initially set to `false`, indicating that `fn` has not yet been called.\\n* When the returned function is **called for the first time**, it sets `usedOnce` to `true`, calls `fn` with the input arguments `args`, stores the result in the `result` variable, and returns the `result`.\\n* When the returned function is **called subsequent times**, it simply returns `undefined`, since fn has already been called and its result has been stored in result.\\n* The use of the rest parameter `...args` allows the returned function to **accept any number of arguments**, which are then passed to `fn`.\\n\\t* To be more clear, `...args` represents the **input arguments** that are passed to the returned function. The use of the **spread syntax** allows the function to accept any number of input arguments, which are then passed as an **array** to the `fn` function using the spread syntax `...args`.\\n\\t* **For example,** if you call the returned function with `myFunc(1, 2, 4)`, the `...args` syntax will **convert the input arguments** into an `array [1, 2, 4]` that can be passed to the `fn` function using the spread syntax `...args`.\\n\\n*Dry Run is given after the solution part :)*\\n***\\n**JavaScript Solution:** \\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n  let usedOnce = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!usedOnce) {\\n      result = fn(...args);\\n      usedOnce = true;\\n      return result;\\n    }\\n    return undefined;\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\\n***\\n**TypeScript Solution:**\\n```\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n     let usedOnce = false;\\n  return function (...args) {\\n      if(!usedOnce){\\n          usedOnce = true;\\n          return fn(...args);\\n      }\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\\n***\\n**Dry Run :**\\n```\\nvar myFunc = function(a, b, c) {\\n  return a + b + c;\\n};\\nvar onceFunc = once(myFunc);\\nconsole.log(onceFunc(1, 2, 3));    // O/P:6\\nconsole.log(onceFunc(4, 5, 6));    // O/P:undefined\\n```\\n* We call `onceFunc` for the first time with arguments `1, 2, 3.` Since this is the first call to `onceFunc`, the `usedOnce` variable is `false`, so the `result` variable is set to the `result` of calling `myFunc` with the arguments `1, 2, 3`, and `usedOnce` is set to `true`. The value of `result (= 6)` is then returned by `onceFunc`.\\n* We then call `onceFunc` for the second time with `arguments 4, 5, 6`. Since `usedOnce` is now `true`, `onceFunc` does not call `myFunc`, but instead returns `undefined`.\\n***\\n**Time Complexity: O(1)\\nSpace Complexity: O(1)**\\n***",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n  let usedOnce = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!usedOnce) {\\n      result = fn(...args);\\n      usedOnce = true;\\n      return result;\\n    }\\n    return undefined;\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\n```\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n     let usedOnce = false;\\n  return function (...args) {\\n      if(!usedOnce){\\n          usedOnce = true;\\n          return fn(...args);\\n      }\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\n```\\nvar myFunc = function(a, b, c) {\\n  return a + b + c;\\n};\\nvar onceFunc = once(myFunc);\\nconsole.log(onceFunc(1, 2, 3));    // O/P:6\\nconsole.log(onceFunc(4, 5, 6));    // O/P:undefined\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514984,
                "title": "2666-allow-one-function-call-level-up-your-javascript-skills-day-8",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n>The goal of the `once` function is to create a new function that ensures the original function is called at most once. The implementation achieves this by defining a variable that keeps track of whether the function has been called already, and returning a new function that checks whether the function has been called already before calling the original function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>The approach taken by the `once` function is to return a new function that wraps the original function and ensures that it is called at most once. The implementation achieves this by defining a variable `called` that keeps track of whether the function has been called already. The returned function checks whether `called` is true or false. If `called` is false, it calls the original function with the given arguments and stores the result in a variable `result`. It then sets `called` to true and returns `result`. If `called` is true, it simply returns `undefined` without calling the original function again.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n>The time complexity of the `once` function is O(1) for the returned function since it checks the value of a single boolean variable before calling the original function. The time complexity of the original function passed to `once` is not considered since it depends on the implementation of the function itself\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>The space complexity of the `once` function is O(1) since it only defines a few variables that are used to keep track of whether the function has been called and store the result of the first call. The space complexity of the original function passed to `once` is not considered since it depends on the implementation of the function itself.\\n\\n\\n# Code\\n``` JS []\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let result;\\n    let called = false;\\n    return function(...args) {\\n        if (!called) {\\n            result = fn(...args);\\n            called = true;\\n            return result;\\n        }\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\\n``` TS []\\nfunction once<T extends (...args: any[]) => any>(fn: T): ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n  let called = false;\\n  let result: ReturnType<T>;\\n\\n  return function (...args: Parameters<T>) {\\n    if (!called) {\\n      result = fn(...args);\\n      called = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n> Here are a few more ways to implement the `once` function in JavaScript:\\n\\n\\n1.Using a `closure` and an `arrow function`:\\n```\\nconst once = (fn) => {\\n  let called = false;\\n  let result;\\n  \\n  return (...args) => {\\n    if (!called) {\\n      result = fn(...args);\\n      called = true;\\n      return result;\\n    }\\n  };\\n};\\n\\n```\\n>In this implementation, we use an arrow function to define the returned function. The rest of the implementation is similar to the closure-based implementation described earlier.\\n\\n2. Using an `object` with a `method`:\\n```\\nfunction once(fn) {\\n  return {\\n    called: false,\\n    result: undefined,\\n    execute(...args) {\\n      if (!this.called) {\\n        this.result = fn(...args);\\n        this.called = true;\\n      }\\n      return this.result;\\n    }\\n  };\\n}\\n```\\n>In this implementation, we define an object with two properties: `called` and `result`. We also define a method `execute` that checks whether `called` is true or false. If `called` is false, it calls the original function with the given arguments and stores the result in `result`. It then sets `called` to true and returns `result`. If called` is true, it simply returns `result` without calling the original function again.\\n\\n3. Using a `class`:\\n```\\nclass Once {\\n  constructor(fn) {\\n    this.called = false;\\n    this.result = undefined;\\n    this.fn = fn;\\n  }\\n  \\n  execute(...args) {\\n    if (!this.called) {\\n      this.result = this.fn(...args);\\n      this.called = true;\\n    }\\n    return this.result;\\n  }\\n}\\n\\nconst onceFn = new Once(fn).execute;\\nonceFn(1, 2, 3); // returns 6\\nonceFn(2, 3, 6); // returns undefined\\n\\n```\\n\\n# Important topic to Learn\\n\\n##### One important topic related to this problem is the concept of \"memoization\". \\n>Memoization is a technique used in computer science to speed up computations by storing the results of expensive function calls and returning the cached result when the same inputs occur again.\\n\\n>The once function we have implemented is a simple example of memoization, as it ensures that the original function is only called once, and then returns the cached result on subsequent calls.\\n\\n>Memoization can be used to optimize performance in a wide range of scenarios, such as:\\n\\n1. >Recursive functions that repeatedly compute the same value for different inputs.\\n2. >Functions that make expensive network requests or database queries.\\n3. >Functions that perform complex computations that are computationally expensive. By memoizing these functions, we can avoid recomputing the same values multiple times, which can lead to significant performance improvements.\\n\\n>It\\'s worth noting that memoization should be used judiciously, as caching results can also use up memory and slow down the program if not managed properly. Additionally, memoization can only be used when the function being memoized is pure (i.e. it always returns the same output for a given input), otherwise the cached result may not be correct.\\n\\n| Sr No. | Topic |\\n|-----|-----|\\n1.|Array methods|\\n2.|Functional programming|\\n3.|Higher-order functions|\\n4.|Memoization|\\n\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` JS []\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let result;\\n    let called = false;\\n    return function(...args) {\\n        if (!called) {\\n            result = fn(...args);\\n            called = true;\\n            return result;\\n        }\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\n``` TS []\\nfunction once<T extends (...args: any[]) => any>(fn: T): ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n  let called = false;\\n  let result: ReturnType<T>;\\n\\n  return function (...args: Parameters<T>) {\\n    if (!called) {\\n      result = fn(...args);\\n      called = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  };\\n}\\n\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```\\nconst once = (fn) => {\\n  let called = false;\\n  let result;\\n  \\n  return (...args) => {\\n    if (!called) {\\n      result = fn(...args);\\n      called = true;\\n      return result;\\n    }\\n  };\\n};\\n\\n```\n```\\nfunction once(fn) {\\n  return {\\n    called: false,\\n    result: undefined,\\n    execute(...args) {\\n      if (!this.called) {\\n        this.result = fn(...args);\\n        this.called = true;\\n      }\\n      return this.result;\\n    }\\n  };\\n}\\n```\n```\\nclass Once {\\n  constructor(fn) {\\n    this.called = false;\\n    this.result = undefined;\\n    this.fn = fn;\\n  }\\n  \\n  execute(...args) {\\n    if (!this.called) {\\n      this.result = this.fn(...args);\\n      this.called = true;\\n    }\\n    return this.result;\\n  }\\n}\\n\\nconst onceFn = new Once(fn).execute;\\nonceFn(1, 2, 3); // returns 6\\nonceFn(2, 3, 6); // returns undefined\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484232,
                "title": "save-an-internal-boolean",
                "content": "# Intuition\\nSave an internal boolean.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n \\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (!called) {\\n            called = true;\\n            return fn(...args);\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n \\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (!called) {\\n            called = true;\\n            return fn(...args);\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3512772,
                "title": "simple-and-easy-solution-using-javascript-with-intuition-and-approach-o-1-tc-and-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We will use a variable which handle the count of times function has been called .\\n- On the basis of count ,we will return result.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  1. Declare a variable `times` and intialize it with zero.`times`  will holds number of times given function has been called.  \\n  2. If `times` is one,fn() will be ans.\\n  3. Else undefined will return. \\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let times=0;\\n    return function(...args){\\n           times+=1;     \\n           if(times==1)\\n               return fn(...args);\\n           return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let times=0;\\n    return function(...args){\\n           times+=1;     \\n           if(times==1)\\n               return fn(...args);\\n           return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514408,
                "title": "day-o-1-o-7-commented-with-examples",
                "content": "This code defines a JavaScript function called **once**, which is used to create a new function that can only be invoked once. The ***once function*** takes another function fn as its ***parameter***.\\n\\nHere\\'s how the code works:\\n\\n* The ***once function*** creates a variable ans and initializes it to true. This variable keeps track of whether the wrapped function has been invoked before or not.\\n\\n* The ***once function*** returns an ***anonymous*** function that accepts any number of arguments using the rest parameter syntax (...args).\\n\\n* Inside the anonymous function, there is an if statement that checks the value of the ans variable. If it is true, it means that the wrapped function has not been invoked before.\\n \\n* If the condition is true, the ans variable is set to false to indicate that the wrapped function has now been invoked.\\n \\n* Finally, the wrapped **function** (fn) is called with the provided arguments using the spread operator (...args), and its result is returned.\\n\\nLet\\'s see an example to better understand how this code can be used:\\n```\\n// Example function\\nfunction sayHello(name) {\\n  console.log(\"Hello, \" + name);\\n}\\n\\n// Creating a new function using `once`\\nvar sayHelloOnce = once(sayHello);\\n\\n// Invoking the new function multiple times\\nsayHelloOnce(\"Alice\"); // Output: Hello, Alice\\nsayHelloOnce(\"Bob\");   // (no output)\\n\\n// The wrapped function is invoked only once\\n\\n```\\n\\nIn this example, the ***sayHelloOnce function*** is created using the once function and wraps the sayHello function. When sayHelloOnce is called the first time with the **argument** \"Alice\",\\n it invokes the wrapped sayHello function and prints \"Hello, Alice\" to the console. \\nHowever, when sayHelloOnce is called the second time with the **argument** \"Bob\", nothing happens because the wrapped function is set to be invoked only once.\\n\\n\\n***Here is the code to the current Problem :- ***\\n\\n```\\n\\nvar once = function(fn) {\\n    let ans = true;\\n    return function(...args){\\n        if (ans) {\\n            ans = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n// Example function\\nfunction sayHello(name) {\\n  console.log(\"Hello, \" + name);\\n}\\n\\n// Creating a new function using `once`\\nvar sayHelloOnce = once(sayHello);\\n\\n// Invoking the new function multiple times\\nsayHelloOnce(\"Alice\"); // Output: Hello, Alice\\nsayHelloOnce(\"Bob\");   // (no output)\\n\\n// The wrapped function is invoked only once\\n\\n```\n```\\n\\nvar once = function(fn) {\\n    let ans = true;\\n    return function(...args){\\n        if (ans) {\\n            ans = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514735,
                "title": "understand-question-step-by-step-solution-with-comments-javascript-typescript",
                "content": "# Understand the problem\\n\\nGiven a function `fn`, return a new function that is identical to the original function except that it ensures `fn` is called at most once.\\n\\nBreakdown -\\n\\nGiven a function `fn` -> means we have to give a function `fn` as an input\\n```\\n// give fn as an input\\nvar once = function(fn){\\n\\n}\\n```\\n\\nreturn a new function -> we have to return a function \\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // we have to return a function\\n    return function(...args){\\n    }\\n};\\n```\\n\\nthat is identical to the original function -> means return function is identical like original function ,**that means it should also return a function becasue original function is return a function.**\\n\\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // we have to return a function\\n    return function(...args){\\n      // it will also return a function\\n      return someFunction(...args){ }\\n    }\\n};\\n```\\n\\n except that it ensures `fn` is called at most once -> means we have to return a function `fn` and ensure one thing that it called only one time, means we have to track that function is called or not. \\n\\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // for tracking like function is called or not\\n    let isCalled = false;\\n    // we have to return a function\\n    return function(...args){\\n        // if function is called , we have to return undefined\\n        if(isCalled) return undefined;\\n        // change is called to true\\n        isCalled = !isCalled;\\n        // it will also return a function (otherwise)\\n        return fn(...args);\\n    }\\n};\\n```\\n\\nTypescript \\n```\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n    let isCalled = false;\\n        return function(...args){\\n            if(isCalled) return undefined;\\n            isCalled = !isCalled;\\n            return fn(...args);\\n        }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n// give fn as an input\\nvar once = function(fn){\\n\\n}\\n```\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // we have to return a function\\n    return function(...args){\\n    }\\n};\\n```\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // we have to return a function\\n    return function(...args){\\n      // it will also return a function\\n      return someFunction(...args){ }\\n    }\\n};\\n```\n```\\n// give fn as an input\\nvar once = function(fn) {\\n    // for tracking like function is called or not\\n    let isCalled = false;\\n    // we have to return a function\\n    return function(...args){\\n        // if function is called , we have to return undefined\\n        if(isCalled) return undefined;\\n        // change is called to true\\n        isCalled = !isCalled;\\n        // it will also return a function (otherwise)\\n        return fn(...args);\\n    }\\n};\\n```\n```\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n    let isCalled = false;\\n        return function(...args){\\n            if(isCalled) return undefined;\\n            isCalled = !isCalled;\\n            return fn(...args);\\n        }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3485421,
                "title": "2-solutions-closure-and-return-by-reference",
                "content": "# Closure\\n\\n```\\nfunction once(fn) {\\n    let called = false;\\n\\n    return (...args) => {\\n        if (called) return;\\n\\n        called = true;\\n\\n        return fn(...args);\\n    }\\n};\\n```\\n\\n# Return by reference\\n\\n```\\nfunction once(fn) {\\n    return (...args) => {\\n        const result = fn(...args);\\n\\n        fn = Function();\\n\\n        return result;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction once(fn) {\\n    let called = false;\\n\\n    return (...args) => {\\n        if (called) return;\\n\\n        called = true;\\n\\n        return fn(...args);\\n    }\\n};\\n```\n```\\nfunction once(fn) {\\n    return (...args) => {\\n        const result = fn(...args);\\n\\n        fn = Function();\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516813,
                "title": "easy-to-understand-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514632,
                "title": "java-script-solution-for-allow-one-function-call-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the once function is to create a wrapper function that ensures the original function fn is called only once. Subsequent calls to the wrapper function will not invoke fn but return undefined instead.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach taken by the once function is to use a closure to store a flag (hasBeenCalled) indicating whether fn has already been called. The wrapper function checks the flag and conditionally invokes fn only if it has not been called before\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the once function is O(1) because it performs a constant number of operations regardless of the size of the input.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasBeenCalled = false;\\n    return function(...args){\\n        if (!hasBeenCalled) {\\n      hasBeenCalled = true;\\n      return fn(...args);\\n    }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasBeenCalled = false;\\n    return function(...args){\\n        if (!hasBeenCalled) {\\n      hasBeenCalled = true;\\n      return fn(...args);\\n    }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3836594,
                "title": "javascript",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0; //counter variable\\n    return function(...args){\\n        if(c==0){ \\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n        return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0; //counter variable\\n    return function(...args){\\n        if(c==0){ \\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n        return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516941,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let cnt = 0;\\n    return function(...args){\\n        cnt++;\\n        if(cnt == 1)\\n        {\\n            return fn(...args);\\n        }\\n        return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let cnt = 0;\\n    return function(...args){\\n        cnt++;\\n        if(cnt == 1)\\n        {\\n            return fn(...args);\\n        }\\n        return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516647,
                "title": "javascript-day-8-of-30-days-challange",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515793,
                "title": "limit-function-to-one-call",
                "content": "The code defines a function called `once` that takes a function `fn` as its parameter. The `once` function returns a new function that wraps around `fn` and ensures that it is called at most once.\\n\\nThe inner function keeps track of whether `fn` has been called before by setting a boolean variable `hasBeenCalled` to `false`. It also declares a variable `result` that will store the result of the first call to `fn`.\\n\\nThe inner function takes any number of arguments using the spread syntax `(...args)`. When the inner function is called for the first time, it checks whether `hasBeenCalled` is `false`. If so, it calls `fn` with the provided arguments using the spread syntax `fn(...args)`, and stores the result in the `result` variable. It then sets `hasBeenCalled` to `true` and returns the result.\\n\\nIf the inner function is called a second time or later, `hasBeenCalled` will be true, and the inner function will simply return `undefined`. This ensures that `fn` is only called once.\\n\\nThe expression `hasBeenCalled ? undefined : ((hasBeenCalled = true), (result = fn(...args)))` is used as the return value of the inner function. If `hasBeenCalled` is true, the function returns `undefined`. Otherwise, it sets `hasBeenCalled` to true, calls `fn` with the provided arguments, and stores the result in `result`, then returns `result`.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) => {\\n  let result;\\n  let hasBeenCalled = false;\\n  return (...args) => hasBeenCalled ? undefined : ((hasBeenCalled = true), (result = fn(...args)));\\n}\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) => {\\n  let result;\\n  let hasBeenCalled = false;\\n  return (...args) => hasBeenCalled ? undefined : ((hasBeenCalled = true), (result = fn(...args)));\\n}\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515785,
                "title": "javascript-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/708964a3-2181-4495-af4b-dfc3650f3c50_1683887783.4264705.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515110,
                "title": "simplest-code-in-javascript-using-counter-variable",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0; //counter variable\\n    return function(...args){\\n        if(c==0){ \\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n        return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0; //counter variable\\n    return function(...args){\\n        if(c==0){ \\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n        return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515043,
                "title": "javascript-simple-javascript-typescript-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 52 ms, faster than 88.74% of JavaScript online submissions for Allow One Function Call.\\n# Memory Usage: 41.8 MB, less than 62.02% of JavaScript online submissions for Allow One Function Call.\\n\\tvar once = function(fn) {\\n\\n\\t\\tlet Flag = true\\n\\t\\treturn function(...args){\\n\\n\\t\\t\\tif(Flag == true)\\n\\t\\t\\t{\\n\\t\\t\\t\\tconst result = fn(...args);\\n\\t\\t\\t\\tFlag = false\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n# Approach 2 Using Typescript :\\n# Runtime: 63 ms, faster than 54.55% of TypeScript online submissions for Allow One Function Call.\\n# Memory Usage: 42.8 MB, less than 62.03% of TypeScript online submissions for Allow One Function Call.\\n\\n\\tfunction once<T extends (...args: any[]) => any>(fn: T): \\n\\t ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n\\n\\t\\tlet Flag = true\\n\\n\\t\\treturn function (...args) {\\n\\n\\t\\t\\tif(Flag == true)\\n\\t\\t\\t{\\n\\t\\t\\t\\tconst result = fn(...args);\\n\\t\\t\\t\\tFlag = false\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t}\\n\\n\\t  };\\n\\t}\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Javascript :\\n# Runtime: 52 ms, faster than 88.74% of JavaScript online submissions for Allow One Function Call.\\n# Memory Usage: 41.8 MB, less than 62.02% of JavaScript online submissions for Allow One Function Call.\\n\\tvar once = function(fn) {\\n\\n\\t\\tlet Flag = true\\n\\t\\treturn function(...args){\\n\\n\\t\\t\\tif(Flag == true)\\n\\t\\t\\t{\\n\\t\\t\\t\\tconst result = fn(...args);\\n\\t\\t\\t\\tFlag = false\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n# Approach 2 Using Typescript :\\n# Runtime: 63 ms, faster than 54.55% of TypeScript online submissions for Allow One Function Call.\\n# Memory Usage: 42.8 MB, less than 62.03% of TypeScript online submissions for Allow One Function Call.\\n\\n\\tfunction once<T extends (...args: any[]) => any>(fn: T): \\n\\t ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n\\n\\t\\tlet Flag = true\\n\\n\\t\\treturn function (...args) {\\n\\n\\t\\t\\tif(Flag == true)\\n\\t\\t\\t{\\n\\t\\t\\t\\tconst result = fn(...args);\\n\\t\\t\\t\\tFlag = false\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn undefined;\\n\\t\\t\\t}\\n\\n\\t  };\\n\\t}\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Unknown"
            },
            {
                "id": 3514953,
                "title": "javascript-solution-best-solution-with-99-efficiency",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe `once` function takes a function `fn` as an argument and returns a new function that ensures `fn` is called at most once. The new function returns the result of the first call to `fn` and returns `undefined` for all subsequent calls.\\n\\n![Screenshot 2023-05-12 113031.png](https://assets.leetcode.com/users/images/886d7a34-d878-493f-a074-fb88a12e4aeb_1683871248.2008448.png)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. `once` is a function that takes a function `fn` as an argument.\\n\\n2. Inside the `once` function, we initialize a boolean flag `flag` to `true`. This `flag` will be used to determine whether `fn` has been called before.\\n\\n3. We also declare a variable `result` to store the result of the function. This will allow us to return the same `result` every time the function is called.\\n\\n4. We return a new function that takes any number of arguments using the rest parameter syntax `...args`.\\n\\n5. Inside the new function, we check if the `flag` is `true`. If it is, we call the original function fn with the `args`, store the result in result, set the `flag` to `false`, and return the `result`.\\n\\n6. If the `flag` is `false`, we simply return `undefined` without calling the original function.\\n\\n7. We now have a new function that behaves like the original function, but ensures that it is only called `once`.\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let flag = true;\\n    let result;\\n    return function(...args){\\n        if(flag) {\\n            result = fn(...args);\\n            flag = false;\\n            return result;\\n        } else return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let flag = true;\\n    let result;\\n    return function(...args){\\n        if(flag) {\\n            result = fn(...args);\\n            flag = false;\\n            return result;\\n        } else return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514757,
                "title": "editorial-one-in-javascript-0-0",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n  let hasBeenCalled = false;\\n  return function(...args){\\n    if (hasBeenCalled) {\\n      return undefined;\\n    } else {\\n      hasBeenCalled = true;\\n      return fn(...args);\\n    }\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n  let hasBeenCalled = false;\\n  return function(...args){\\n    if (hasBeenCalled) {\\n      return undefined;\\n    } else {\\n      hasBeenCalled = true;\\n      return fn(...args);\\n    }\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514370,
                "title": "simple-javascript-solution-o-1",
                "content": "# Intuition\\nTake a boolean variable or integer variable and track if function is called once.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nvar once = function(fn) {\\n    let count  = 0;\\n    return function(...args){\\n        if(count<1) {\\n            count++;\\n            return fn(...args);\\n        }\\n        else {\\n         return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let count  = 0;\\n    return function(...args){\\n        if(count<1) {\\n            count++;\\n            return fn(...args);\\n        }\\n        else {\\n         return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3500997,
                "title": "js-simple-solution",
                "content": "# Approach\\nWe must keep the information if we\\'ve already triggered the function in a variable. Then on first trigger just set it and from then just return undefined.\\n\\nIt is possible to use Function.apply also to trigger the function with an array of arguments (works in older versions of ES):\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```js\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) => {\\n    let isTriggered = false\\n    return (...args) => {\\n        if (isTriggered) return\\n        isTriggered = true\\n        return fn(...args)\\n    }\\n};\\n```\\n\\nAlternatively, we can use Function.apply method:\\n```js\\nfn.apply(this, args)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) => {\\n    let isTriggered = false\\n    return (...args) => {\\n        if (isTriggered) return\\n        isTriggered = true\\n        return fn(...args)\\n    }\\n};\\n```\n```js\\nfn.apply(this, args)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3493253,
                "title": "my-once",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let calls = false;\\n  \\n  return function (...args) {\\n    if (calls === false) {\\n      calls = true;\\n      return fn(...args);\\n    }\\n    else\\n      return undefined;\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let calls = false;\\n  \\n  return function (...args) {\\n    if (calls === false) {\\n      calls = true;\\n      return fn(...args);\\n    }\\n    else\\n      return undefined;\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3488425,
                "title": "javascript-solution",
                "content": "\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    return function(...args){\\n        const ans=fn(...args);\\n        fn=Function();\\n        return ans;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    return function(...args){\\n        const ans=fn(...args);\\n        fn=Function();\\n        return ans;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3485777,
                "title": "1-liner",
                "content": "```\\nvar once = f => (...a) => f ? [f(...a), f=undefined][0] : f\\n```",
                "solutionTags": [],
                "code": "```\\nvar once = f => (...a) => f ? [f(...a), f=undefined][0] : f\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3485501,
                "title": "3-lines-js-solution-beats-100",
                "content": "# Code\\n```\\nvar once = function(fn) {\\n    let count=0;\\n    return function(...args){\\n        if (count++==0) return fn(...args);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let count=0;\\n    return function(...args){\\n        if (count++==0) return fn(...args);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3523010,
                "title": "very-easy-to-understand-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let used = false;\\n    return function(...args){\\n       if(used) return undefined\\n       used = true\\n       return fn(...args)\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let used = false;\\n    return function(...args){\\n       if(used) return undefined\\n       used = true\\n       return fn(...args)\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514171,
                "title": "use-a-generator-function",
                "content": "# Intuition\\nUse generator function and put an infinite loop with a undefined yeild.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    function* OnceOnly()\\n    {\\n        const args = yield;\\n        const result = fn.apply(null, args);\\n        yield result;\\n        while (true)\\n        {\\n            yield undefined\\n        }\\n    }\\n    \\n    const gen = OnceOnly();\\n    \\n    return function(...args)\\n    {\\n        gen.next(args); // First value sent to generator is always lost. we will run it twice every subsequent time but thats fine because after second call the generator always returns undefined\\n        let result = gen.next(args)\\n        \\n        return result.value;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    function* OnceOnly()\\n    {\\n        const args = yield;\\n        const result = fn.apply(null, args);\\n        yield result;\\n        while (true)\\n        {\\n            yield undefined\\n        }\\n    }\\n    \\n    const gen = OnceOnly();\\n    \\n    return function(...args)\\n    {\\n        gen.next(args); // First value sent to generator is always lost. we will run it twice every subsequent time but thats fine because after second call the generator always returns undefined\\n        let result = gen.next(args)\\n        \\n        return result.value;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3502193,
                "title": "ts-simple-boolean-flag-52ms-41-9mb",
                "content": "Pretty simple problem to be solved with encapsulation, similar to other [base](https://leetcode.com/problems/counter/solutions/3492591/) [ones](https://leetcode.com/problems/counter-ii/solutions/3492633/) we already solved with a wrapper. The classic [debounce challenge](https://leetcode.com/problems/debounce/) ([solved here](https://leetcode.com/problems/debounce/solutions/3517553/)) might be a good next step.\\n\\nIn this specific case we will just need a boolean flag `isCallable` initially set to `true`, right outside the wrapper function we are going to `return`.\\n\\nSaid wrapper will check if `callable == true` and if so, it will:\\n* flag `isCallable` to `false`;\\n* `return` the expected result, invoking `fn` with all the arguments (`args`) it was called with.\\n\\nIf the flag is set to `false`, it means `fn` was already invoked once, so we will just `return` `undefined`.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n# Code\\n```ts\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n    let isCallable = true;\\n    return function (...args) {\\n        return isCallable ? (isCallable = false, fn(...args)) : undefined;\\n    };\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```ts\\nfunction once<T extends (...args: any[]) => any>(fn: T): \\n ((...args: Parameters<T>) => ReturnType<T> | undefined) {\\n    let isCallable = true;\\n    return function (...args) {\\n        return isCallable ? (isCallable = false, fn(...args)) : undefined;\\n    };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494782,
                "title": "simple-solution-happy-coding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let result = false;\\n    return function(...args){\\n        if(!result){\\n            result = true;\\n            return fn(...args);\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let result = false;\\n    return function(...args){\\n        if(!result){\\n            result = true;\\n            return fn(...args);\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100680,
                "title": "allow-one-function-call-javascript-solution-by-bharadwaj",
                "content": "# Approach\\nFunctional Programming\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nvar once = function(fn) {\\n    let count = 0;\\n    return function(...args){\\n        if(count++ === 0) return fn(...args)\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let count = 0;\\n    return function(...args){\\n        if(count++ === 0) return fn(...args)\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097518,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = true\\n\\treturn function(...args){\\n        if(called) {\\n            called = false\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = true\\n\\treturn function(...args){\\n        if(called) {\\n            called = false\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096082,
                "title": "the-solution-only-by-two-lines-of-code",
                "content": "\\n# Code\\n```\\nvar once = function (fn)\\n{\\n      let expired = false;\\n      // if expired == true  retrun undefined\\n      // else set expierd to true and return orginal function\\n      //this is calld ternany operator \\n      return (...args) => (expired ? undefined : ((expired = true), fn(...args)));\\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function (fn)\\n{\\n      let expired = false;\\n      // if expired == true  retrun undefined\\n      // else set expierd to true and return orginal function\\n      //this is calld ternany operator \\n      return (...args) => (expired ? undefined : ((expired = true), fn(...args)));\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096013,
                "title": "easy-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasCalled = false;\\n\\treturn function(...args){\\n        if(!hasCalled){\\n            result  = fn(...args);\\n            hasCalled = true;\\n            return result;\\n        } else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasCalled = false;\\n\\treturn function(...args){\\n        if(!hasCalled){\\n            result  = fn(...args);\\n            hasCalled = true;\\n            return result;\\n        } else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088217,
                "title": "allow-function-to-be-called-only-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem.\\n -->\\nClosure concept: internal function will have access to the lexical scope of its parent, \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso we can keep a flag or number there to check if the internal function has been called or not\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype OnceFn = (...args: JSONValue[]) => JSONValue | undefined\\n\\nfunction once(fn: Function): OnceFn {\\n    let called = false;\\n    return function (...args) {\\n        if (called) {\\n            return;\\n        }\\n        else {\\n            called = true;\\n            return fn(...args);\\n        }\\n    };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype OnceFn = (...args: JSONValue[]) => JSONValue | undefined\\n\\nfunction once(fn: Function): OnceFn {\\n    let called = false;\\n    return function (...args) {\\n        if (called) {\\n            return;\\n        }\\n        else {\\n            called = true;\\n            return fn(...args);\\n        }\\n    };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087225,
                "title": "why-not-nullify-func-after-first-call",
                "content": "# Intuition\\nMy first thoughts in solving this problems were to either keep track of whether the func call was made or simply nullify the func. So that the actual fn call is not made. \\n\\nIdeally this approach should not be used, as it tampers the func definition, which we do not want. A calling function in general does not expect the called function to update any of its params. \\n\\nBut here we are solving the problems in all ways possible for the sake of learning!\\n\\n# Approach\\nJust nullify the func after invoke statement\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    return (...args) => {\\n        let a = fn(...args);\\n        fn = () => {null};\\n        return a;\\n    }\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    return (...args) => {\\n        let a = fn(...args);\\n        fn = () => {null};\\n        return a;\\n    }\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082559,
                "title": "solution-with-conditional-ternary-operator-and-apply-method-using-count-in-a-let-to-manage-state",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n\\n    let count = 0\\n\\n    return function (...args) {\\n        count += 1\\n        return count > 1 ?  undefined :  fn.apply(this, args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n\\n    let count = 0\\n\\n    return function (...args) {\\n        count += 1\\n        return count > 1 ?  undefined :  fn.apply(this, args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081167,
                "title": "js-simple-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    return function(...args){\\n        if(isCalled) return;\\n        isCalled = true;\\n        return fn.apply(null,args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    return function(...args){\\n        if(isCalled) return;\\n        isCalled = true;\\n        return fn.apply(null,args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078995,
                "title": "very-very-simple-and-clean-javascript-typescript-solution",
                "content": "```\\nconst once = (fn) => {\\n    let isCalled = 0;\\n    \\n    return function(...args) {\\n        if (isCalled) return;\\n\\n        isCalled = true;\\n\\n        return fn.apply(this, args);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst once = (fn) => {\\n    let isCalled = 0;\\n    \\n    return function(...args) {\\n        if (isCalled) return;\\n\\n        isCalled = true;\\n\\n        return fn.apply(this, args);\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072258,
                "title": "straightforward-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calledBefore = false;\\n    return function(...args){\\n        if(!calledBefore){\\n            calledBefore = true;\\n            return fn(...args);\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calledBefore = false;\\n    return function(...args){\\n        if(!calledBefore){\\n            calledBefore = true;\\n            return fn(...args);\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4071326,
                "title": "allow-one-function-call-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let status = false;\\n    return function(...args){\\n        if(status){\\n            return undefined;\\n        }\\n        status = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let status = false;\\n    return function(...args){\\n        if(status){\\n            return undefined;\\n        }\\n        status = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069367,
                "title": "js-closure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    \\n    return function(...args){\\n        if (isCalled) {\\n            return undefined;\\n        } else {\\n            isCalled = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    \\n    return function(...args){\\n        if (isCalled) {\\n            return undefined;\\n        } else {\\n            isCalled = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068172,
                "title": "beats-97-48-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let called=false;\\n\\n    return (...args) => {\\n        if(called) return;\\n        \\n        called=true;\\n        \\n        return fn(...args)\\n    }\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let called=false;\\n\\n    return (...args) => {\\n        if(called) return;\\n        \\n        called=true;\\n        \\n        return fn(...args)\\n    }\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068158,
                "title": "allow-one-function-call-with-constant-time-complexity",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$Big-O = O(1) - Constant$$\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nlet once = function (fn) {\\n  let flag = false;\\n  return function (...args) {\\n    if (!flag) {\\n      flag = true;\\n     return fn(...args)\\n    } else {\\n      return undefined;\\n    }\\n  };\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nlet once = function (fn) {\\n  let flag = false;\\n  return function (...args) {\\n    if (!flag) {\\n      flag = true;\\n     return fn(...args)\\n    } else {\\n      return undefined;\\n    }\\n  };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067085,
                "title": "2666-allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0;\\n\\n    return function(...args){\\n       \\n        if (count > 0) return undefined; count++;\\n\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0;\\n\\n    return function(...args){\\n       \\n        if (count > 0) return undefined; count++;\\n\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062288,
                "title": "beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var count=0;\\n    let result;\\n    return function(...args){\\n       if(count<1){\\n           result = fn(...args);\\n           count += 1\\n           return result;\\n       }else{\\n           return undefined;\\n       }\\n        \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var count=0;\\n    let result;\\n    return function(...args){\\n       if(count<1){\\n           result = fn(...args);\\n           count += 1\\n           return result;\\n       }else{\\n           return undefined;\\n       }\\n        \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058710,
                "title": "simplest-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let x;\\n    return function(...args){\\n        if(x == null) return x = fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let x;\\n    return function(...args){\\n        if(x == null) return x = fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056677,
                "title": "simple-function-for-return-func-one-tiome",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let runner = 0\\n    return function(...args){\\n        for(let i = 0; i < args.length; i++) {\\n            if(runner === 0) {\\n            runner = 1\\n            return fn(...args)\\n            } else {\\n                return undefined\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let runner = 0\\n    return function(...args){\\n        for(let i = 0; i < args.length; i++) {\\n            if(runner === 0) {\\n            runner = 1\\n            return fn(...args)\\n            } else {\\n                return undefined\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055983,
                "title": "the-fastest-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    counter = 0;\\n    return function(...args){\\n        if(counter > 0) return undefined\\n        counter++\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    counter = 0;\\n    return function(...args){\\n        if(counter > 0) return undefined\\n        counter++\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051156,
                "title": "simple-solution-in-js-ts",
                "content": "# Code\\n```\\ntype Fn = (...args: any[]) => any;\\n\\nfunction once(fn: Fn): Fn {\\n    let fnCalled: boolean = false;\\n\\n    return function (...args): Fn {\\n        if (fnCalled) return undefined;\\n\\n        fnCalled = true;\\n        return fn(...args);\\n\\n    };\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any;\\n\\nfunction once(fn: Fn): Fn {\\n    let fnCalled: boolean = false;\\n\\n    return function (...args): Fn {\\n        if (fnCalled) return undefined;\\n\\n        fnCalled = true;\\n        return fn(...args);\\n\\n    };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048303,
                "title": "allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let hasBeenCalled = false;\\n    let result;\\n\\n    return function(...args){\\n        if(!hasBeenCalled){\\n            result = fn(...args);\\n            hasBeenCalled = true;\\n            return result;\\n        } else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let hasBeenCalled = false;\\n    let result;\\n\\n    return function(...args){\\n        if(!hasBeenCalled){\\n            result = fn(...args);\\n            hasBeenCalled = true;\\n            return result;\\n        } else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048005,
                "title": "js-ts-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nconst once = (fn: Fn): Fn  =>{\\n    let fun;\\n  return function (...args) {\\n    if(fun !== undefined) return undefined;\\n   return fun = fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nconst once = (fn: Fn): Fn  =>{\\n    let fun;\\n  return function (...args) {\\n    if(fun !== undefined) return undefined;\\n   return fun = fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047007,
                "title": "creating-a-javascript-once-function-execute-functions-only-once-and-cache-results",
                "content": "# Intuition\\n<!-- Provide a brief description of your initial thoughts and strategies for solving this problem. -->\\n\\nThe goal of this code is to create a function called `once` that takes another function (`fn`) as its argument and returns a new function. This new function ensures that the original `fn` is executed only once, and its result is cached and returned on subsequent calls.\\n\\n# Approach\\n<!-- Describe the approach you took to solve the problem. -->\\n\\nI\\'ve implemented the `once` function to encapsulate the behavior of the original function (`fn`). Here\\'s how it works:\\n\\n- We initialize a `called` variable to track whether the `fn` function has been called before.\\n- We also declare a `result` variable to store the result of the `fn` function when it\\'s called.\\n\\n- The returned function accepts any number of arguments using the `...args` syntax. This allows it to work with functions that accept different argument lists.\\n\\n- Inside the returned function:\\n  - It checks if `called` is `true`. If it\\'s true, the function returns the cached `result` without calling `fn` again.\\n  - If `called` is `false`, it sets `called` to `true`, calls the original `fn` with the provided `args`, stores the result in `result`, and then returns the result.\\n\\nThis design ensures that the `fn` function is executed only once, and subsequent calls return the cached result.\\n\\n# Code\\n```javascript\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false \\n    let result;\\n    return function(...args){\\n        if(called) return undefined\\n        called = true \\n        result = fn(...args)\\n        return result \\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false \\n    let result;\\n    return function(...args){\\n        if(called) return undefined\\n        called = true \\n        result = fn(...args)\\n        return result \\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044293,
                "title": "once",
                "content": "# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    var hasUsed:boolean = false    \\n    return function (...args) {\\n        var result = hasUsed ? undefined : fn(...args); hasUsed = true; return result;\\n    };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    var hasUsed:boolean = false    \\n    return function (...args) {\\n        var result = hasUsed ? undefined : fn(...args); hasUsed = true; return result;\\n    };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044275,
                "title": "once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar c = true;\\nvar once = (fn) => {\\n    c = true\\n    return (...args) => {\\n        var res = c ? fn(...args) : undefined\\n        c = false\\n        return res\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar c = true;\\nvar once = (fn) => {\\n    c = true\\n    return (...args) => {\\n        var res = c ? fn(...args) : undefined\\n        c = false\\n        return res\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044140,
                "title": "the-most-simple-single-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(1)\\n- Space complexity:\\n    O(1)\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0\\n    return function(...args){\\n        if(!count++) return fn(...args)    \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0\\n    return function(...args){\\n        if(!count++) return fn(...args)    \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041566,
                "title": "using-clouser",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n\\n    let hasBeenCalled = false\\n    let result;\\n    return function (...args) {\\n        if (!hasBeenCalled) {\\n            hasBeenCalled = 1 //true\\n            result = fn(...args)\\n            return result\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n\\n    let hasBeenCalled = false\\n    let result;\\n    return function (...args) {\\n        if (!hasBeenCalled) {\\n            hasBeenCalled = 1 //true\\n            result = fn(...args)\\n            return result\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041206,
                "title": "javascript-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasBeenCalled = false;\\n\\n    return function(...args) {\\n        if (hasBeenCalled) return undefined;\\n        hasBeenCalled = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let hasBeenCalled = false;\\n\\n    return function(...args) {\\n        if (hasBeenCalled) return undefined;\\n        hasBeenCalled = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037119,
                "title": "a-c-analogy",
                "content": "### cpp thoughts...\\n New to js. Related to cpp to make sense of it! Thought of sharing!\\n\\n```javascript []\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let flag=false;\\n    return function(...args){\\n        if(!flag){ \\n            flag=true;\\n            // console.log(args[0]);\\n            return fn(...args); \\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\\n```cpp []\\n// made my data type- func() :)\\n\\nfunc() once(function){\\n    // code\\n    return function(); // obv\\n}\\n\\nfunc() x=once(fn); // x is a function right?! `once` returns x\\nx(...args); // now x can be parameterized (this case).\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let flag=false;\\n    return function(...args){\\n        if(!flag){ \\n            flag=true;\\n            // console.log(args[0]);\\n            return fn(...args); \\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```\n```cpp []\\n// made my data type- func() :)\\n\\nfunc() once(function){\\n    // code\\n    return function(); // obv\\n}\\n\\nfunc() x=once(fn); // x is a function right?! `once` returns x\\nx(...args); // now x can be parameterized (this case).\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036829,
                "title": "simple-javascript-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var Oncecall=true;\\n    return function(...args){\\n        if(Oncecall){\\n            Oncecall=false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var Oncecall=true;\\n    return function(...args){\\n        if(Oncecall){\\n            Oncecall=false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036301,
                "title": "allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false\\n    return function(...args){\\n         if(!isCalled){\\n            isCalled=true\\n            return fn(...args)\\n         }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false\\n    return function(...args){\\n         if(!isCalled){\\n            isCalled=true\\n            return fn(...args)\\n         }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035292,
                "title": "learn-closures",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false;\\n    return function(...args){\\n        if(!isCalled){\\n           \\n            isCalled=true;\\n             return fn(...args);\\n        }\\n        else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false;\\n    return function(...args){\\n        if(!isCalled){\\n           \\n            isCalled=true;\\n             return fn(...args);\\n        }\\n        else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4029763,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n    let flag = false;\\n    return function(...args){\\n        \\n        if(!flag) {\\n            flag = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n    let flag = false;\\n    return function(...args){\\n        \\n        if(!flag) {\\n            flag = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4026281,
                "title": "ok",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n   \\n    let called = false;\\n    return function(...args){\\n         \\n        if(called){\\n            return undefined\\n        }\\n       called = true;\\n\\n    if(called){\\n        return fn(...args);\\n    }\\n\\n\\n\\n\\n        \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n   \\n    let called = false;\\n    return function(...args){\\n         \\n        if(called){\\n            return undefined\\n        }\\n       called = true;\\n\\n    if(called){\\n        return fn(...args);\\n    }\\n\\n\\n\\n\\n        \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4024273,
                "title": "perfect-solution-allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nlet fn = (a,b,c) => (a + b + c);\\nvar once = function(fn) {\\n    let call = 0;\\n    return function(...args){\\n        if (call ==0){\\n            call +=1;\\n            return fn(...args)\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nlet fn = (a,b,c) => (a + b + c);\\nvar once = function(fn) {\\n    let call = 0;\\n    return function(...args){\\n        if (call ==0){\\n            call +=1;\\n            return fn(...args)\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4019836,
                "title": "x",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\n var once = function(fn) {\\n let o = true\\n  let onceFn    \\n    return function(...args){\\n        if(o){  \\n        o = false\\n       onceFn = fn(...args)\\n     return onceFn;         \\n     }else{\\n      return undefined  \\n        }  \\n    }\\n};\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\n var once = function(fn) {\\n let o = true\\n  let onceFn    \\n    return function(...args){\\n        if(o){  \\n        o = false\\n       onceFn = fn(...args)\\n     return onceFn;         \\n     }else{\\n      return undefined  \\n        }  \\n    }\\n};\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018094,
                "title": "clean-solution-with-detailed-explanation",
                "content": "#  Explanation\\nWhen `once` is called the first time, it returns another function and do nothing. Since it is a closure, the inner function will still have access to lexical scope or the arguments that were passed in the parent function.. which is `fn` in this case. We don\\'t know the internals of what that function does but **OUR TASK** is to pass all the arguments we have to that callback function and let it do its part. The only thing we need to make sure is we should only let this function invoke once. To solve this, define a variable, `called` in my case and set it to `false` and set it to `true` before we call the `callback fn` and wrap this logic with.\\n```\\nif(!called) {\\n    called = true\\n    return fn(...args)\\n}\\n```\\nI could have `if/else` condition here like `if(called) return undefined`. But just wrapping it like this will do the trick too. If the `if condition` is not met, then `javascript` will return `undefined` itself since there is nothing to return.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false\\n    \\n    return function(...args){\\n    if(!called) {\\n        called = true\\n        return fn(...args)\\n    }\\n    }\\n};\\n\\n\\n  // let fn = (a,b,c) => (a + b + c)\\n  // let onceFn = once(fn)\\n \\n  // onceFn(1,2,3); // 6\\n  // onceFn(2,3,6); // returns undefined without calling fn\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nif(!called) {\\n    called = true\\n    return fn(...args)\\n}\\n```\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false\\n    \\n    return function(...args){\\n    if(!called) {\\n        called = true\\n        return fn(...args)\\n    }\\n    }\\n};\\n\\n\\n  // let fn = (a,b,c) => (a + b + c)\\n  // let onceFn = once(fn)\\n \\n  // onceFn(1,2,3); // 6\\n  // onceFn(2,3,6); // returns undefined without calling fn\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005231,
                "title": "js-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    var cnt=0;  \\n    return function(...args){\\n        cnt++;\\n         if(cnt==1)return fn(...args)\\n         else return undefined\\n         \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    var cnt=0;  \\n    return function(...args){\\n        cnt++;\\n         if(cnt==1)return fn(...args)\\n         else return undefined\\n         \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000085,
                "title": "javascript-solution-for-beginners",
                "content": "# JavaScript Solution\\n1.```let called = false;``` Inside the once function, a variable ***called*** is declared and initialized with false. This variable is used to keep track of whether the fn function has been called before.\\n\\n2.```if (called === false) { ... }```: Inside the inner function, it checks if the called variable is false, which means that fn has not been called before.\\n\\n3.```called = true;``` If fn has not been called before, it sets called to true, indicating that fn has now been called.\\n\\n4.```return fn(...args);``` It then calls the fn function with the provided arguments (args) and returns its result. This essentially allows you to call fn only once, and subsequent calls will return undefined.\\n\\n\\n# Code\\n```\\nvar once = function(fn) {\\n    let called = false;\\n  \\n    return function (...args) {\\n        if (called === false) {\\n            called = true;\\n            return fn(...args);\\n        }\\n        else return undefined;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```let called = false;```\n```if (called === false) { ... }```\n```called = true;```\n```return fn(...args);```\n```\\nvar once = function(fn) {\\n    let called = false;\\n  \\n    return function (...args) {\\n        if (called === false) {\\n            called = true;\\n            return fn(...args);\\n        }\\n        else return undefined;\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997948,
                "title": "javascript-easy-simple-and-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n<!-- upvote if it helps -->\\n\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let t=true;\\n    let result;\\n    return function(...args){\\n        if(t)\\n        {\\n            result = fn(...args);\\n            t= false;\\n            return result;\\n        }\\n        else\\n       { return undefined;}\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n<!-- upvote if it helps -->\\n\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let t=true;\\n    let result;\\n    return function(...args){\\n        if(t)\\n        {\\n            result = fn(...args);\\n            t= false;\\n            return result;\\n        }\\n        else\\n       { return undefined;}\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997718,
                "title": "best-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0;\\n    return function(...args){\\n      if(c==0)  {\\n          c++;\\n          return fn(...args);\\n      }\\n      else{\\n          return undefined;\\n      }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0;\\n    return function(...args){\\n      if(c==0)  {\\n          c++;\\n          return fn(...args);\\n      }\\n      else{\\n          return undefined;\\n      }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996909,
                "title": "yea",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = (fn) => {\\n  let executed = false;\\n  return (...args) => {\\n    if (!executed) {\\n      executed = true;\\n      return fn(...args);\\n    } else {\\n      return undefined;\\n    }\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = (fn) => {\\n  let executed = false;\\n  return (...args) => {\\n    if (!executed) {\\n      executed = true;\\n      return fn(...args);\\n    } else {\\n      return undefined;\\n    }\\n  };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983468,
                "title": "easy-to-understand",
                "content": "\\n\\n# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let call=0;\\n  return function (...args) {\\n      if(call==1) return undefined\\n      ++call;\\n      return fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let call=0;\\n  return function (...args) {\\n      if(call==1) return undefined\\n      ++call;\\n      return fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982969,
                "title": "a-really-short-solution",
                "content": "# Solution\\nJust change the reference of the argument, we do not need any more extra variables.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    return function(...args){\\n        let rs = fn(...args);\\n        fn = ()=>undefined;\\n        return rs;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    return function(...args){\\n        let rs = fn(...args);\\n        fn = ()=>undefined;\\n        return rs;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978446,
                "title": "explaining-a-closure-based-once-only-function-counter",
                "content": "# Intuition\\nThe purpose of this code is to create a function `once` that takes another function `fn` as input and returns a new function. This new function ensures that the provided function `fn` is executed only the first time it\\'s called, and subsequent calls will not execute `fn` again.\\n\\n# Approach\\n\\nThe code uses a closure and a counter variable to achieve its goal. Here\\'s how it works:\\n\\n1. The `once` function is called with an input function `fn`.\\n\\n2. Inside `once`, a `counter` variable is initialized with a value of 0.\\n\\n3. The `once` function returns an inner function (a closure) that captures the `counter` variable and takes any number of arguments using the spread operator `...args`.\\n\\n4. When the inner function is called, it first increments the `counter` using `++counter`. This means that the `counter` is incremented before its value is used in the comparison.\\n\\n5. The incremented value of `counter` is then compared to 1 using `=== 1`. If the comparison is true (meaning this is the first call to the inner function), it executes the original function `fn` with the provided arguments using `fn(...args)`.\\n\\n6. If the comparison is false (meaning this is not the first call), the inner function returns `undefined` without executing `fn`.\\n\\n**Explanation of ++counter:**\\nThe `++counter` part is a pre-increment operation on the `counter` variable. This means that before the value of counter is used for comparison, it is incremented by 1. In other words, the value of `counter` is increased by 1 before it\\'s checked in the comparison `++counter === 1`.\\n\\nThis pre-increment is crucial for ensuring that fn is executed only on the very first call to the inner function. Once the counter is incremented to 1 and the comparison succeeds, it ensures that subsequent calls to the inner function will result in counter being greater than 1, thus preventing fn from executing again.\\n\\n# Complexity\\n**- Time complexity:**\\nThe time complexity of this code is constant time, `O(1)`, regardless of how many times the functions are called.\\n\\n\\n**- Space complexity:**\\nThe space complexity is also constant, `O(1)`, as the memory used is fixed and does not increase with the number of function calls.\\n\\nIn summary, the code leverages a closure and a pre-increment operation to create a function that executes the provided function only on its first call and returns `undefined` on `subsequent calls`.\\n\\n\\n# Code\\n```\\nconst once = fn => {\\n  let counter = 0\\n\\n  return (...args) => (++counter === 1 ? fn(...args) : undefined)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst once = fn => {\\n  let counter = 0\\n\\n  return (...args) => (++counter === 1 ? fn(...args) : undefined)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3975950,
                "title": "l",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\nif(called){\\n    return  undefined;\\n}\\ncalled = true;\\n              return fn.apply(this,args)\\n\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\nif(called){\\n    return  undefined;\\n}\\ncalled = true;\\n              return fn.apply(this,args)\\n\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3973416,
                "title": "super-simple-and-straightforward-approach-stringifying-the-function-with-map-javascript",
                "content": "# Intuition\\nThis seems like the Memoization problem, except we want to remember the function itself.\\n\\n# Approach\\n- We can save the function into a Map as a string.\\n- When a function is passed, we check if it exist in the map, if it does, return undefined.\\n- If it doesn\\'t, stringify the function, save it as an entry in the map, and returns the function result with the argument paramenter \\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    const map = new Map();\\n    \\n    return function(...args) {\\n        if (map.get(\"\" + fn)) return undefined;\\n        map.set(\"\" + fn, 1);\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    const map = new Map();\\n    \\n    return function(...args) {\\n        if (map.get(\"\" + fn)) return undefined;\\n        map.set(\"\" + fn, 1);\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972906,
                "title": "o-1-sc-o-1-tc-solution-in-js-day-8",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking us to return a new function that behaves differently depending on whether it has been called before. If it has not been called before, it should call the original function and return its result. If it has been called before, it should return undefined without calling the original function again.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can return a new function that keeps track of whether it has been called before. We can do this by using a closure to store a boolean flag that is initially set to false. The first time the new function is called, we call the original function and set the flag to true. We also store the result of the original function. Subsequent calls to the new function simply return undefined without calling the original function again\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) for both the first and subsequent calls to the returned function. This is because checking the hasBeenCalled flag and returning either the result or undefined are constant-time operations.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) as well. This is because we only use a constant amount of extra space to store the hasBeenCalled flag and the result of the original function\\n# Code In JS\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n\\n};\\n\\nlet fn = (a,b,c) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1,2,3)); // 6\\nconsole.log(onceFn(2,3,6)); // undefined\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n  let hasBeenCalled = false;\\n  let result;\\n\\n  return function(...args) {\\n    if (!hasBeenCalled) {\\n      result = fn(...args);\\n      hasBeenCalled = true;\\n      return result;\\n    } else {\\n      return undefined;\\n    }\\n  }\\n\\n};\\n\\nlet fn = (a,b,c) => (a + b + c);\\nlet onceFn = once(fn);\\n\\nconsole.log(onceFn(1,2,3)); // 6\\nconsole.log(onceFn(2,3,6)); // undefined\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972004,
                "title": "easy-solution-runtime-53-ms-space-41-77-mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved if we somehow restrict the function(...args) from calling it more than one time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we can start with initialising a boolean variable witha true value (example let val = true) outside the function to be returned and by using a while loop we can check for val as the condition for the while loop. When the function is being called for once we can change the value of val to false. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let val =true;\\n    return function(...args){\\n        while(val){\\n            val = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let val =true;\\n    return function(...args){\\n        while(val){\\n            val = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3971151,
                "title": "simple-o-1-o-1-complexities",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter =0;\\n    return function(...args){\\n            if(counter ===0){\\n                counter++;\\n                return fn(...args)\\n            }\\n            return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter =0;\\n    return function(...args){\\n            if(counter ===0){\\n                counter++;\\n                return fn(...args)\\n            }\\n            return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3966505,
                "title": "sweet-and-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args) {\\n        if (called) return undefined;\\n        called = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args) {\\n        if (called) return undefined;\\n        called = true;\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3963242,
                "title": "one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let trigger = 0;\\n    return function(...args){\\n        if(trigger == 0){\\n            trigger++;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let trigger = 0;\\n    return function(...args){\\n        if(trigger == 0){\\n            trigger++;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962458,
                "title": "closure",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = function(fn) {\\n\\n    let wasCalled = false\\n    \\n    return function(...args){\\n        if (!wasCalled) {\\n            wasCalled = true\\n            const result = fn(...args)\\n            return result\\n        }    \\n    }\\n\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = function(fn) {\\n\\n    let wasCalled = false\\n    \\n    return function(...args){\\n        if (!wasCalled) {\\n            wasCalled = true\\n            const result = fn(...args)\\n            return result\\n        }    \\n    }\\n\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957853,
                "title": "very-simple-solution-using-flag",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    return function(...args){\\n        if(!isCalled){\\n            isCalled = true;\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled = false;\\n    return function(...args){\\n        if(!isCalled){\\n            isCalled = true;\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955653,
                "title": "js-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let k=0;\\n\\n    return function(...args){\\n        \\n        if(k>0){\\n            return undefined;\\n        }\\n\\n        k++;\\n        return fn(...args);\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let k=0;\\n\\n    return function(...args){\\n        \\n        if(k>0){\\n            return undefined;\\n        }\\n\\n        k++;\\n        return fn(...args);\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955273,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0 \\n    return function(...args){\\n        if(count < 1){\\n            count++\\n            return fn(...args)\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count = 0 \\n    return function(...args){\\n        if(count < 1){\\n            count++\\n            return fn(...args)\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3954054,
                "title": "allow-one-function-call-day-10-javascript-solution-apply",
                "content": "# Intuition\\nThe problem is asking us to return a result as fn but on consequent calls it should return undefined.\\n\\n# Approach\\n- Assign a new variable `val` to the result of calling the passed function.\\n- Reassign the function `fn` to return undefined.\\n- Return the new variable `val`.\\n\\n# Complexity\\n- Time complexity:\\n0(1)\\n\\n- Space complexity:\\n0(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    return function(...args){\\n      const val = fn.apply(this, args)\\n      fn = () => undefined\\n      return val\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    return function(...args){\\n      const val = fn.apply(this, args)\\n      fn = () => undefined\\n      return val\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3953782,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(called === false){\\n            called=true;\\n            return fn(...args);\\n        }\\n        else {\\n            return undefined;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(called === false){\\n            called=true;\\n            return fn(...args);\\n        }\\n        else {\\n            return undefined;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3948148,
                "title": "allow-once-function-call-in-simple-way",
                "content": "# Intuition\\nFunction needs to be called only once we need counter or we need to assign null or undefined to that function and first call will return function so function needs to be stored as variable of outer function so we can use closure concept\\n\\n# Approach\\nfirst we assigned function to variable in outerfunction so returned function will hold reference to that function due to closure and when first time called if check will be true and after calling we will assign undefined or null so next time call that if check will fail and return undefined\\n\\n# Complexity\\n- Time complexity:\\n  -\\n\\n- Space complexity:\\n -\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let fnToCall = fn;\\n    return function(...args){\\n      if(fnToCall) {\\n       let result =  fnToCall(...arguments);\\n       fnToCall = undefined;\\n       return result;\\n      }\\n      return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let fnToCall = fn;\\n    return function(...args){\\n      if(fnToCall) {\\n       let result =  fnToCall(...arguments);\\n       fnToCall = undefined;\\n       return result;\\n      }\\n      return undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947942,
                "title": "easy-solution-with-proper-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let firstCalled = false;\\n    return function(...args){\\n // we have  first need to return the same function \\n//    with its argument (...args)\\n   \\n   // to check wheather it is called for one time only\\n   if (firstCalled ){\\n       return undefined;\\n   }\\n    firstCalled =!firstCalled\\n    return fn(...args)\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    let firstCalled = false;\\n    return function(...args){\\n // we have  first need to return the same function \\n//    with its argument (...args)\\n   \\n   // to check wheather it is called for one time only\\n   if (firstCalled ){\\n       return undefined;\\n   }\\n    firstCalled =!firstCalled\\n    return fn(...args)\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947476,
                "title": "javascript-solution",
                "content": "\\n- se crea un state called para saber cuando una fn fue llamada\\n\\n- el if (called) si es true significa que la funci\\xF3n ya fue llamada entonces retornara undefined\\n\\n- si no es true proceder\\xE1 a convertir called=true y llamar la funci\\xF3n que este quiera ejecutar\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (called) {\\n            return undefined;\\n        }\\n        called = true;\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (called) {\\n            return undefined;\\n        }\\n        called = true;\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3946528,
                "title": "no-return-undefined-needed-if-statement-only",
                "content": "# Approach\\nSimple if statement to check if the function has been called at least once. It returns undefined automatically if we remove the return statement.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = (fn) => {\\n    let res\\n    return (...args) => {\\n        if (!res) {\\n            res = fn(...args)\\n            return res \\n        } \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = (fn) => {\\n    let res\\n    return (...args) => {\\n        if (!res) {\\n            res = fn(...args)\\n            return res \\n        } \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3945579,
                "title": "shortest-typescript-solution",
                "content": "# Approach\\nThe once function creates a closure over a `counter` variable, which is incremented each time the returned function is called. If `counter` is equal to 1, the original function is called with the provided arguments and its result is returned. Otherwise, `undefined` is returned.\\n\\n# Complexity\\nTime complexity: The time complexity of calling the returned function is `O(1)`, since it only involves incrementing a counter and checking its value.\\nSpace complexity: The space complexity of the once function is `O(1)`, since it only needs to store a single counter variable. However, keep in mind that the returned function also maintains a reference to the original function and its arguments, so the total space complexity will depend on the size of those objects.\\n# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let counter = 0;\\n  return function (...args) {\\n    counter++;\\n    return counter === 1 ? fn(...args) : undefined;\\n  };\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let counter = 0;\\n  return function (...args) {\\n    counter++;\\n    return counter === 1 ? fn(...args) : undefined;\\n  };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944565,
                "title": "resolved-the-problem-using-js",
                "content": "\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    const memorizeFunction = {}\\n    \\n    return (...arg) => {\\n        if(fn in memorizeFunction) {\\n           return undefined\\n        }\\n        \\n        let result = fn(...arg)\\n        memorizeFunction[fn] = result\\n        return result\\n    }\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    const memorizeFunction = {}\\n    \\n    return (...arg) => {\\n        if(fn in memorizeFunction) {\\n           return undefined\\n        }\\n        \\n        let result = fn(...arg)\\n        memorizeFunction[fn] = result\\n        return result\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3941484,
                "title": "simple-logic",
                "content": "# Code\\n```\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (called) return undefined;\\n        called = true;\\n        return fn(...args);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if (called) return undefined;\\n        called = true;\\n        return fn(...args);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936617,
                "title": "function-as-objects-smart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn Javascript functions are treated as objects. We can leverage this property and use it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAdd a count variable to the function `fn`\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\t  fn.count = 0\\n    return function(...args){\\n\\t\\t\\t if(fn.count == 1){\\n\\t\\t\\t\\t return undefined\\n\\t\\t\\t }else{\\n\\t\\t\\t\\t fn.count = 1\\n\\t\\t\\t\\t return fn(...args)\\n\\t\\t\\t }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\t  fn.count = 0\\n    return function(...args){\\n\\t\\t\\t if(fn.count == 1){\\n\\t\\t\\t\\t return undefined\\n\\t\\t\\t }else{\\n\\t\\t\\t\\t fn.count = 1\\n\\t\\t\\t\\t return fn(...args)\\n\\t\\t\\t }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936595,
                "title": "flag-closure-and-one-if-statement",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically, you just need a flag to say when is the first time and then you turn it to false.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used closure in the first function and then i added a condition to the second function with just 1 \"if\", cause that\\'s the only one we need and in the same if we change the value of the \"flag\" to \"false\", so it won\\'t run in the second time and return \"undefined\" by default.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let flag = true;\\n    return function(...args){\\n        if(flag){\\n        flag = false;\\n        return fn(...args)\\n    }\\n    }\\n\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let flag = true;\\n    return function(...args){\\n        if(flag){\\n        flag = false;\\n        return fn(...args)\\n    }\\n    }\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3935468,
                "title": "allow-one-function-call-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking us to return a new function that behaves differently depending on whether it has been called before. If it has not been called before, it should call the original function and return its result. If it has been called before, it should return undefined without calling the original function again.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled =false;\\n    return function(...args){\\n        if(!isCalled){\\n            isCalled=true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled =false;\\n    return function(...args){\\n        if(!isCalled){\\n            isCalled=true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3927737,
                "title": "alternative-approach-using-a-ternary",
                "content": "# Intuition\\nI solved this first with the a separate `hasBeenCalled` variable. In that solution I was already declaring `result` which also gets changed, so I worked out a solution relies on this change instead.\\n\\n# Approach\\nSince `result` is already declared, we set its value to null (to avoid any issues with `fn()` returning a falsy value). Then we use a ternary to reassign `result` if it\\'s not still `null`.\\n\\n# Complexity\\n- Time complexity: Constant\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let result = null;\\n    \\n    return (...args) => {\\n        result = result === null ? fn(...args) : undefined;\\n        \\n        return result;\\n    }\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let result = null;\\n    \\n    return (...args) => {\\n        result = result === null ? fn(...args) : undefined;\\n        \\n        return result;\\n    }\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3925559,
                "title": "javascript-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let usedOnce = false;\\n    let result;\\n\\n    return function (...args) {\\n        if (!usedOnce) {\\n            result = fn(...args);\\n            usedOnce = true;\\n            return result;\\n        }\\n        return undefined;\\n    };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let usedOnce = false;\\n    let result;\\n\\n    return function (...args) {\\n        if (!usedOnce) {\\n            result = fn(...args);\\n            usedOnce = true;\\n            return result;\\n        }\\n        return undefined;\\n    };\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924468,
                "title": "typescript-my-solution",
                "content": "# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let wasCalled = false;    \\n  return function (...args) {\\n      return wasCalled ? undefined : (wasCalled = true) && fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let wasCalled = false;    \\n  return function (...args) {\\n      return wasCalled ? undefined : (wasCalled = true) && fn(...args)\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923735,
                "title": "simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: *```O()```* -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar once = function(fn) {\\n    \\n    let callStatus = false;\\n\\n    return function(...args){\\n    \\n        if(callStatus)\\n            return undefined;\\n    \\n        let result = fn(...args);\\n        callStatus = true;\\n        return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```O()```\n```\\nvar once = function(fn) {\\n    \\n    let callStatus = false;\\n\\n    return function(...args){\\n    \\n        if(callStatus)\\n            return undefined;\\n    \\n        let result = fn(...args);\\n        callStatus = true;\\n        return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3916412,
                "title": "easy-javascript-solution",
                "content": "> Vote Up if You Like it\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called=true;\\n    return function(...args){\\n        let value=fn(...args)\\n        if(called){\\n           called=false\\n           return value\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called=true;\\n    return function(...args){\\n        let value=fn(...args)\\n        if(called){\\n           called=false\\n           return value\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914774,
                "title": "js-solution-with-explanation",
                "content": "# Approach\\nWhat we have to do here is that, we have to return the result of fn if once is called atmost 1 time else we return undefined.\\n\\n- So, to keep track of calling we keep a boolean variable HasBeenCalled initially to true.\\n- and for the first time it will enter the fn function and return the result and also set HasBeenCalled to true.\\n- What happens now is that if fn function is called directly then, it will check if !hasbeencalled which will result in false and the undefined will be returned. \\n# Complexity\\n- Time complexity:\\nO(1)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) =>{\\n    let HasbeenCalled = false;\\n    let  result;\\n\\n    return (...args) =>{\\n      if(!HasbeenCalled){\\n        result = fn(...args)\\n        HasbeenCalled = true;\\n        return result;\\n      }\\n      else{\\n        return undefined;\\n      }\\n    }\\n\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nconst once = (fn) =>{\\n    let HasbeenCalled = false;\\n    let  result;\\n\\n    return (...args) =>{\\n      if(!HasbeenCalled){\\n        result = fn(...args)\\n        HasbeenCalled = true;\\n        return result;\\n      }\\n      else{\\n        return undefined;\\n      }\\n    }\\n\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914293,
                "title": "easiest-way-javascript-closure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let call = false;\\n    return function(...args){\\n        if(call) return;\\n        call = true;\\n        return fn(...args);\\n    }\\n};\\n\\n\\nlet fn = (a,b,c) => (a + b + c)\\nlet onceFn = once(fn)\\n\\nonceFn(1,2,3); // 6\\nonceFn(2,3,6); // returns undefined without calling fn\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let call = false;\\n    return function(...args){\\n        if(call) return;\\n        call = true;\\n        return fn(...args);\\n    }\\n};\\n\\n\\nlet fn = (a,b,c) => (a + b + c)\\nlet onceFn = once(fn)\\n\\nonceFn(1,2,3); // 6\\nonceFn(2,3,6); // returns undefined without calling fn\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3912370,
                "title": "js-solution",
                "content": "# Code\\n```\\nvar once = function(fn) {\\n    let beenCalled = false\\n    let result\\n    return function(...args){\\n        if (!beenCalled) {\\n            result = fn(...args)\\n            beenCalled = true\\n            return result\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let beenCalled = false\\n    let result\\n    return function(...args){\\n        if (!beenCalled) {\\n            result = fn(...args)\\n            beenCalled = true\\n            return result\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3908795,
                "title": "easy-peasy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn){\\n    var c = true;\\n    return (...args) =>  c ? (()=>{ c = !c ; return fn(...args) })()  : undefined\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn){\\n    var c = true;\\n    return (...args) =>  c ? (()=>{ c = !c ; return fn(...args) })()  : undefined\\n};\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907216,
                "title": "simple-solution",
                "content": "\\n```\\nvar once = function(fn) {\\n    let cnt = 0;\\n    return function(...args){\\n        if(++cnt > 1) return undefined;\\n        return fn(...args)\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let cnt = 0;\\n    return function(...args){\\n        if(++cnt > 1) return undefined;\\n        return fn(...args)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906380,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return (...args)=>{\\n        if(called) return;\\n\\n        called = true;\\n\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return (...args)=>{\\n        if(called) return;\\n\\n        called = true;\\n\\n        return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3899310,
                "title": "beginner-friendly-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe must have a boolean trigger to prevent function from running twice or more. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this solution this boolean value represented by `let onced`\\nThen we check condition and if fuction hasn\\'t ran before we set `onced` to `true` return input fn with its `...args`. Otherwise we return `undefined`\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let onced = false\\n    return function(...args){\\n        if(!onced){\\n            onced = true\\n            return fn(...args)\\n        }else{\\n            return undefined\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let onced = false\\n    return function(...args){\\n        if(!onced){\\n            onced = true\\n            return fn(...args)\\n        }else{\\n            return undefined\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3897336,
                "title": "simple-two-line-solution-javascript-using-boolean-variable",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialised a boolean variable , for checking the data as if it is  called at least once.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false;\\n    return function(...args){\\n        if (!isCalled) {\\n            isCalled = true;\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let isCalled=false;\\n    return function(...args){\\n        if (!isCalled) {\\n            isCalled = true;\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3892509,
                "title": "beats-98-user",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 40ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 41.2mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n        if(!called){\\n            called = true;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3892035,
                "title": "js-solution-runtime-48-ms-beats-91-2-memory-41-7-mb-beats-66-11",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\n\\nvar once = function(fn) {\\n    this.isCalled = false;\\n    return function(...args){\\n        if(this.isCalled )return ;\\n        this.isCalled = true;\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\n\\nvar once = function(fn) {\\n    this.isCalled = false;\\n    return function(...args){\\n        if(this.isCalled )return ;\\n        this.isCalled = true;\\n        return fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888922,
                "title": "single-invocation-enforcer-for-javascript-functions",
                "content": "# Intuition and Approach:\\nThe intuition behind the solution is to use closure and a flag to keep track of whether the original function has been called before. The approach involves creating a new function that checks this flag. If the original function hasn\\'t been called before, it invokes the original function with the provided arguments and returns the result. Subsequent calls return undefined, ensuring that the original function is executed only once.\\n\\n# Time Complexity:\\nThe time complexity of the once function is constant (O(1)) for each call, regardless of the original function\\'s complexity. The main operation is checking the hasBeenCalled flag and invoking the original function if necessary.\\n\\n# Space Complexity:\\nThe space complexity is influenced by the closure created by the returned function and the storage of the hasBeenCalled flag and result. This takes up constant space (O(1)) for each invocation.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let Hascalled=false;\\n    let result;\\n    return function(...args){\\n        if(!Hascalled){\\n            result=fn(...args);\\n            Hascalled = true;\\n            return result;\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n\\n```\\nThe once function is designed to wrap an original function and ensure it\\'s called at most once. It achieves this by creating a new function that keeps track of whether the original function has been invoked. The solution has a constant time and space complexity and enhances control over function invocations.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let Hascalled=false;\\n    let result;\\n    return function(...args){\\n        if(!Hascalled){\\n            result=fn(...args);\\n            Hascalled = true;\\n            return result;\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888089,
                "title": "simple-solution",
                "content": "\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    was_executed = false\\n    return function(...args){\\n        if (!was_executed){\\n            was_executed = true\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    was_executed = false\\n    return function(...args){\\n        if (!was_executed){\\n            was_executed = true\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3887719,
                "title": "allow-one-function-call",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var called = false; \\n    return function(...args){\\n        if(!called){\\n        //return args.reduce(fn);\\n        called = true;\\n        return fn(...args);\\n        }\\n    } \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    var called = false; \\n    return function(...args){\\n        if(!called){\\n        //return args.reduce(fn);\\n        called = true;\\n        return fn(...args);\\n        }\\n    } \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879026,
                "title": "top-1-answer",
                "content": "# Intuition\\nFirst is done. When it is called, it triggered a flag and done. then just pass the function and array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have to handle the done variable. I don\\'t use boolean but use integer as boolean variable. So, I can omit update statement of done.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let done = 0\\n    return function(...args){\\n        return (done++)? undefined: fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let done = 0\\n    return function(...args){\\n        return (done++)? undefined: fn(...args)\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3878454,
                "title": "easy-solution-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let call = 0;\\n\\n    return function(...args){\\n        if(call>0)\\n            return undefined;\\n        call += 1 ; \\n        let ans = fn(...args);\\n        return ans;\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let call = 0;\\n\\n    return function(...args){\\n        if(call>0)\\n            return undefined;\\n        call += 1 ; \\n        let ans = fn(...args);\\n        return ans;\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3868848,
                "title": "3-lines-of-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let count = 0;\\n    return function (...args) {\\n        count++;\\n        return count === 1 ? fn(...args) : undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n    let count = 0;\\n    return function (...args) {\\n        count++;\\n        return count === 1 ? fn(...args) : undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3864483,
                "title": "easy-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n  \\nvar once = function(fn) {\\n\\n    return function(...args){\\n\\n            var k = fn(...args)\\n           if(k[\"calls\"]==1){\\n               return k\\n           }\\n            \\n     \\n      \\n     \\n        \\n    }\\n}\\n\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n  \\nvar once = function(fn) {\\n\\n    return function(...args){\\n\\n            var k = fn(...args)\\n           if(k[\"calls\"]==1){\\n               return k\\n           }\\n            \\n     \\n      \\n     \\n        \\n    }\\n}\\n\\n\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3861979,
                "title": "intuitive-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Closure to track the number of functions calls\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUtilize Closure to keep track of how many times fn has been called, return undefined after the first call\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let fnCalls = 0;\\n    \\n    return function(...args){\\n        if(fnCalls < 1){\\n            fnCalls++\\n            return fn(...args)\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let fnCalls = 0;\\n    \\n    return function(...args){\\n        if(fnCalls < 1){\\n            fnCalls++\\n            return fn(...args)\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855225,
                "title": "simple-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter =0;\\n    return function(...args){\\n        if(counter == 0){\\n            counter =1;\\n            return fn(...args);\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter =0;\\n    return function(...args){\\n        if(counter == 0){\\n            counter =1;\\n            return fn(...args);\\n        }else{\\n            return undefined;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854212,
                "title": "simpler-js-code-with-o-1-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    x = 0\\n    return function(...args){\\n        if(x == 0){x++; return fn(...args)}\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    x = 0\\n    return function(...args){\\n        if(x == 0){x++; return fn(...args)}\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854062,
                "title": "1-line-simple-solution-with-minimal-code-unique-approach",
                "content": "# Intuition\\nThese approach emphasizes achieving performance with minimal code.\\n\\n1. Use of **Arrow functions** to reduce the code.\\n2. Utilization of **ternary operator and parentheses** to simplify the code.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return (...args) => \\n        (called == true) ? undefined : ((called = true), (fn(...args)));\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    return (...args) => \\n        (called == true) ? undefined : ((called = true), (fn(...args)));\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3851517,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let func_called = true;\\n\\n    return function(...args){\\n        if(func_called){\\n            func_called = false;\\n            return fn(...args);\\n        }    \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let func_called = true;\\n\\n    return function(...args){\\n        if(func_called){\\n            func_called = false;\\n            return fn(...args);\\n        }    \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850182,
                "title": "very-easy-short-solution-javascript",
                "content": "# Code\\n```\\nvar once = function(fn) {\\n\\n    let cont = 0;\\n\\n    return function(...args){\\n\\n        return cont !== 0 ? undefined : (cont++, fn(...args));\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n\\n    let cont = 0;\\n\\n    return function(...args){\\n\\n        return cont !== 0 ? undefined : (cont++, fn(...args));\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3847941,
                "title": "runtime-beats-75-01-memory-beats-91-04",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let iscalled=false;\\n    \\n    return function(...args){\\n        if(!iscalled){\\n            iscalled=true;\\n            return fn(...args);\\n        }\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let iscalled=false;\\n    \\n    return function(...args){\\n        if(!iscalled){\\n            iscalled=true;\\n            return fn(...args);\\n        }\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3845396,
                "title": "simple-js-solution",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (called) return undefined;\\n      called = true;\\n      return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (called) return undefined;\\n      called = true;\\n      return fn(...args);\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3843912,
                "title": "typescript-based",
                "content": "```\\ntype Fn = (...args: any[]) => any;\\n\\nfunction once(fn: Fn): Fn {\\n  let called: boolean = false;\\n  return function (...args) {\\n    if (called) return undefined;\\n    called = true;\\n    return fn.apply(this,args);\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any;\\n\\nfunction once(fn: Fn): Fn {\\n  let called: boolean = false;\\n  return function (...args) {\\n    if (called) return undefined;\\n    called = true;\\n    return fn.apply(this,args);\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3838780,
                "title": "use-boolearn-internal-to-solve-this-question",
                "content": "# Intuition\\nJust use an internal boolean to test whether it\\'s been called or not.\\nIf not once, one can define a counter to check how many times `fn` can be called.\\n\\n# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let called = false;\\n  return function (...args) {\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let called = false;\\n  return function (...args) {\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n  };\\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3837534,
                "title": "day3-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0;\\n    return function(...args){\\n        if(c==0){\\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n            return undefined;\\n        }\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let c=0;\\n    return function(...args){\\n        if(c==0){\\n            c++;\\n            return fn(...args);\\n        }\\n        else{\\n            return undefined;\\n        }\\n\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3836632,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let limiter = \\'a\\'\\n    return function(...args){\\n        if(limiter == \\'a\\'){\\n            limiter = \\'b\\'\\n            return fn(...args)\\n        }\\n        else{\\n            return undefined\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let limiter = \\'a\\'\\n    return function(...args){\\n        if(limiter == \\'a\\'){\\n            limiter = \\'b\\'\\n            return fn(...args)\\n        }\\n        else{\\n            return undefined\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3836615,
                "title": "concise-fast-memory-efficient-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWith the fact that booleans are only two bytes as compared to 4 for ints, setting a simple \"counter\" with bool not only faster but saves memory\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let limiter = false\\n    return function(...args){\\n      return (!limiter++) ? fn(...args) : undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let limiter = false\\n    return function(...args){\\n      return (!limiter++) ? fn(...args) : undefined;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831581,
                "title": "fast-js-w-o-booleans",
                "content": "# Code\\n```\\nlet once = (fn) => {\\n    return (...args) => { \\n        let x = fn(...args);\\n        fn = () => {};\\n        return x;\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet once = (fn) => {\\n    return (...args) => { \\n        let x = fn(...args);\\n        fn = () => {};\\n        return x;\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831572,
                "title": "2666-allow-one-function-call-top-96",
                "content": "# Intuition\\nThe goal of this problem is to create a new function that behaves exactly like the original function fn, but it should only execute fn once and return the result on the first call. All subsequent calls to the new function should return undefined.\\n\\n# Approach\\nWe can use a closure to keep track of whether fn has been called before. By using a single variable to store the result of the first call, we can easily determine if the function has already been executed. If it has, we return undefined, otherwise, we call fn and store the result for future reference.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the once function is O(1) because it only performs a constant number of operations, regardless of the number of times the returned function is called.\\n\\n- Space complexity:\\nThe space complexity of the once function is also O(1) because it uses a fixed amount of memory to store the result and whether fn has been called before. The size of the input does not affect the space complexity.\\n\\n# Code\\n```\\nvar once = function(fn) {\\n    let result;\\n\\n    return function(...args) {\\n        if (typeof result === \\'undefined\\') {\\n            result = fn(...args);\\n            return result;\\n        } else {\\n            return undefined;\\n        }\\n    };\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar once = function(fn) {\\n    let result;\\n\\n    return function(...args) {\\n        if (typeof result === \\'undefined\\') {\\n            result = fn(...args);\\n            return result;\\n        } else {\\n            return undefined;\\n        }\\n    };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831099,
                "title": "simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  return function (...args) {\\n    if (fn) {\\n      let f = fn;\\n      fn = undefined;\\n      return f(...args);\\n    }\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  return function (...args) {\\n    if (fn) {\\n      let f = fn;\\n      fn = undefined;\\n      return f(...args);\\n    }\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3819719,
                "title": "beginner-s-attempt-at-a-beginners-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially I figured the simplest way would be to implement some sort of counter variable that would keep track of how many times fn was called.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI initialized the counter variable outside of the return function so that it would not be overwritten.\\n`var counter = 0;`\\n\\nAfter learning that \"...args\" is called a **spread** I was able to understand that \"...args\" is essentially just passing the arguments from \"fn\" to this return function.\\n\\nI then implemented a loop to check if counter is greater than 0. If so it returns \"undefined\". It is important to ensure that you increment counter by 1 each time the function is called.\\n```\\nif (counter > 0) {\\n    return undefined;\\n}\\n\\ncounter++;\\n```\\nAt this stage I ran into a wall with trying to simply input the \"args\" array of values into the fn. This wasn\\'t working but after looking in the Function documents for JavaScript I found a prototype called \"apply\" which is similar to \"call()\" but you are able to pass in an array of values.\\n\\nThe main difference between call() and apply is that call() typically only handles lists of elements like:\\n\\n```\\nfn.call(this, \"value0\", \"value1\", \"value2\", \"...\")\\n\\nconst exampleArray = [\"value0\", \"value1\", \"value2\",\"...\"]\\n\\nfn.apply(this, exampleArray)\\n```\\nWith apply you are also able to call an arbitrary value for the \"this\" if you are calling an existing function:\\n```\\nfn.apply(null, exampleArray)\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) -> Since we are going through each function 1 at a time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n    var counter = 0;\\n    \\n    return function(...args){\\n\\n        if (counter > 0) {\\n            return undefined;\\n        }\\n\\n        counter++;\\n\\n        let value = fn.apply(null, args);\\n\\n        return value;\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nif (counter > 0) {\\n    return undefined;\\n}\\n\\ncounter++;\\n```\n```\\nfn.call(this, \"value0\", \"value1\", \"value2\", \"...\")\\n\\nconst exampleArray = [\"value0\", \"value1\", \"value2\",\"...\"]\\n\\nfn.apply(this, exampleArray)\\n```\n```\\nfn.apply(null, exampleArray)\\n```\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n\\n    var counter = 0;\\n    \\n    return function(...args){\\n\\n        if (counter > 0) {\\n            return undefined;\\n        }\\n\\n        counter++;\\n\\n        let value = fn.apply(null, args);\\n\\n        return value;\\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3818939,
                "title": "simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function (fn) {\\n    var first_call = true;\\n    return function (...args) {\\n        if (first_call) {\\n            first_call = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function (fn) {\\n    var first_call = true;\\n    return function (...args) {\\n        if (first_call) {\\n            first_call = false;\\n            return fn(...args);\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3815584,
                "title": "just-use-a-boolean-switch",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    <!-- boolean switch -->\\n    let once = true;\\n\\n    return function(...args){        \\n        if(once){\\n            once = false\\n            return fn(...args)\\n        }\\n        return\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    \\n    <!-- boolean switch -->\\n    let once = true;\\n\\n    return function(...args){        \\n        if(once){\\n            once = false\\n            return fn(...args)\\n        }\\n        return\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813299,
                "title": "line-by-line-beat-80-90-in-terms-of-time-memory",
                "content": "# Intuition\\nFirst, we have to understand the question thoroughly. It is a skill of its own.\\n\\n1. From the code template: `var once = function(fn){...}` we can derive 2 things:\\n    i. There is a function called `once` with a parameter that is another function. The parameter takes on an argument called `fn`.\\n    ii. Since `once` is a function and can take another function `fn` as an argument, we can conclude that `once` is a higher-order function.\\n\\n2. From the code template: `return function(...args){...}` we can confirm 1 thing:\\n    i. `once` is indeed a higher-order function since it is a function that returns another function.\\n\\n3. `fn` is a function that takes on a parameter of arrays. The arguments have been left as `...args`.\\n\\n**What the question wants**\\n- When `once(fn)` is called, return `fn(...args)` as is.\\n- If `once(fn)` is called for the >1th time, return the value `undefined`.\\n\\n# Approach\\nThere are multiple approaches to this question. I prefer doing each step one at a time.\\n\\n**When `once(fn)` is called, return `fn(...args)` as is:**\\n\\n`return function(...args) {`\\n(when `once(fn)` is called with `...args`...)\\n`result = fn(...args);` \\n(run `fn(...args)` and save the output as a variable called `result`)\\n`return result; }`\\n(return the output stored as `result`)\\n\\nThe first step is now done.\\n\\n**If `once(fn)` is called for the >1th time, return the value `undefined`**\\n\\n`let called = false;`\\n(use a variable called `called` to check if `once(fn)` has been called before)\\n`let result;`\\n(create a variable called `result` which has no value at first, giving an output of `undefined`)\\n\\n`if(called===false){`\\n(if the variable `called` has a value of `false`, run the next lines of code)\\n`called = true;`\\n(change the value of `called` to `true`)\\n\\nNow, the second step is done.\\n\\nI was not able to explain where each line of code should go into. Please check my code solution below to decipher that on your own.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    let result;\\n\\n    return function(...args){\\n        if (called == false) {\\n            called = true;\\n            result = fn(...args);\\n            return result;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let called = false;\\n    let result;\\n\\n    return function(...args){\\n        if (called == false) {\\n            called = true;\\n            result = fn(...args);\\n            return result;\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810623,
                "title": "limiter-function",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calls = 0\\n    return function(...args){\\n        if(calls<=0){\\n            calls++\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calls = 0\\n    return function(...args){\\n        if(calls<=0){\\n            calls++\\n            return fn(...args)\\n        }\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806322,
                "title": "javascript-o-1-solution",
                "content": "# Intuition\\nFlag based approach, early exit if already executed\\n\\n# Approach\\n1. Take a flag and initialize it to false. \\n2. Write the trigger condition for it to be true inside the function capturing the inputs. \\n3. Now that trigger has been set, one line above it, handle the early exit condition for the function when flag value is \"true\"\\n4. Below the trigger, use apply method to pass the captured inputs to the input function.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let executed = false;\\n    return function(...args){\\n        if(executed) return;\\n        executed = true;\\n        return fn.apply(null,args);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let executed = false;\\n    return function(...args){\\n        if(executed) return;\\n        executed = true;\\n        return fn.apply(null,args);\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805268,
                "title": "crisp-and-clear",
                "content": "\\n\\n# Code\\n```\\nconst once = (fn) => {\\n  let calls = 0\\n  return (...args) => {\\n    if (calls > 0) return \\n    ++calls\\n    return fn(...args.flat(Infinity))\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst once = (fn) => {\\n  let calls = 0\\n  return (...args) => {\\n    if (calls > 0) return \\n    ++calls\\n    return fn(...args.flat(Infinity))\\n  }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3800962,
                "title": "js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calls = 0;\\n    return function(...args){\\n        if (!calls) {\\n            calls++;\\n            return fn(...args)\\n        }\\n        return;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let calls = 0;\\n    return function(...args){\\n        if (!calls) {\\n            calls++;\\n            return fn(...args)\\n        }\\n        return;\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3797338,
                "title": "call-only-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let count = 0\\n  \\n    return function (...args) {\\n        if(!(count > 0)){\\n            count++;\\n            return fn(...args);\\n        }   \\n    };\\n  \\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n    let count = 0\\n  \\n    return function (...args) {\\n        if(!(count > 0)){\\n            count++;\\n            return fn(...args);\\n        }   \\n    };\\n  \\n}\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3796932,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count =0;\\n    return function(...args){\\n       if(count<1){\\n        count++;\\n        return fn(...args)\\n       }else return undefined\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let count =0;\\n    return function(...args){\\n       if(count<1){\\n        count++;\\n        return fn(...args)\\n       }else return undefined\\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3796631,
                "title": "allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n      let hasBeenCalled = 0;\\n   return function (...args) {\\n      hasBeenCalled ++;\\n   if(hasBeenCalled==1)\\n    {\\n    return fn(...args); \\n    } \\n    return undefined;\\n   }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n      let hasBeenCalled = 0;\\n   return function (...args) {\\n      hasBeenCalled ++;\\n   if(hasBeenCalled==1)\\n    {\\n    return fn(...args); \\n    } \\n    return undefined;\\n   }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3794963,
                "title": "2666-allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let call = false;\\n  return function (...args) {\\n    if (call) return;\\n    call = true;\\n    return fn(...args);\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let call = false;\\n  return function (...args) {\\n    if (call) return;\\n    call = true;\\n    return fn(...args);\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3794962,
                "title": "2666-allow-one-function-call",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let call = false;\\n  return function (...args) {\\n    if (call) return;\\n    call = true;\\n    return fn(...args);\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function (fn) {\\n  let call = false;\\n  return function (...args) {\\n    if (call) return;\\n    call = true;\\n    return fn(...args);\\n  }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3794769,
                "title": "javascript-solution-and-order-of-execution",
                "content": "# Execution Order of Code\\nI found this super useful website that shows the order in which JavaScript code gets executed. It\\'s just for anyone who\\'s just starting out with JS like me. Here\\'s the link:  https://pythontutor.com/visualize.html#mode=edit\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\nlet times=[];\\n\\n\\n    return function(...args){\\n  \\n    times.push(1); \\n    if(times.length ===1){\\n        return (fn(...args))\\n        }else {\\n\\n    return undefined}\\n    \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\n\\nvar once = function(fn) {\\nlet times=[];\\n\\n\\n    return function(...args){\\n  \\n    times.push(1); \\n    if(times.length ===1){\\n        return (fn(...args))\\n        }else {\\n\\n    return undefined}\\n    \\n        \\n    }\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3788847,
                "title": "using-if-statement",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thought is clicked on my mind is we need to returns a new function but condition is it will call only once so setting counter to 0 and checking with condition if counter is 0 then increment by 1 and call the function if it will try to run on counter 2 return undefined because we cannot run twice.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconditional statement \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter = 0\\n    return function(...args){\\n        if(counter == 0){\\n            counter ++\\n            return fn(...args)\\n        }else{\\n        return undefined\\n        }\\n        \\n    }\\n\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @return {Function}\\n */\\nvar once = function(fn) {\\n    let counter = 0\\n    return function(...args){\\n        if(counter == 0){\\n            counter ++\\n            return fn(...args)\\n        }else{\\n        return undefined\\n        }\\n        \\n    }\\n\\n};\\n\\n/**\\n * let fn = (a,b,c) => (a + b + c)\\n * let onceFn = once(fn)\\n *\\n * onceFn(1,2,3); // 6\\n * onceFn(2,3,6); // returns undefined without calling fn\\n */\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1890874,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1951035,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890911,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 2017399,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890956,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 2005696,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1965347,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1891536,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1891145,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890795,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890874,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1951035,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890911,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 2017399,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890956,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 2005696,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1965347,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1891536,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1891145,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            },
            {
                "id": 1890795,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "Ok, we've been talking a lot about higher order functions, callbacks and all this functional programming stuff, which I find interesting, but as a JS noob, I have one burning question:\n\n**what makes the functional programming paradigm so popular for javascript in particular?**\n\nLet me explain: when I learned languages for backend, like python, java, I never saw such focus on higher functions and all that stuff. You could totally do it in those languages too tho, I don't see what would stop you from using functional programming in python for example. It just seems like this is not the typically preferred style, and OOP takes more importance. Javascript can also use an object oriented style tho.\n\n Basically, my question is: why do we need this kind of stuff more when learning JS than when learning any other language? Is it just for historical reasons (most of the existing codebase follows a functional programming style, so this is now an established convention), or is there an intrinsic reason that makes this stuff more relvant for javascript use cases?"
                    },
                    {
                        "username": "mad_hup",
                        "content": "Functions in javascript are first class citizens. They can be treated as variables, passed as variables, and can be returned from a function. That\\'s why functional programming is efficient and easy in javascript.\\nYou can read more about it here - https://www.geeksforgeeks.org/what-is-first-class-citizen-in-javascript/"
                    },
                    {
                        "username": "bcjagadish16",
                        "content": "I\\'d say its mainly to get rid of boiler plate codes and verbose syntaxes, and if u can use functional programming, u can reuse a lot more code. making your code less error prone. I\\'m also a noob so don\\'t take anything I say srsly lol"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var once = function(fn) {\\n    let called = false;\\n    return function(...args){\\n      if (!called) {\\n        called = true;\\n        return fn(...args);\\n      }\\n    \\n    return undefined;\\n    }\\n};"
                    },
                    {
                        "username": "kartik100phadke",
                        "content": "[@loki-099](/loki-099) after return the down part are not executed..."
                    },
                    {
                        "username": "kqtchcheng97",
                        "content": "[@loki-099](/loki-099) because it ng\\u1EEF ngh\\u0129a"
                    },
                    {
                        "username": "loki-099",
                        "content": "[@loki-099](/loki-099) i get it now, for every function, return statement must always be the final line, right? or else the statement below return statement will not be executed"
                    },
                    {
                        "username": "loki-099",
                        "content": "how does putting \\'called = true\\' first before returning the function works while putting it vice versa won\\'t work?"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day 8 : Done Solving the question for today\\n\\nHint : Keep Track of the function calling by flag\\nif not called then return fn(...args)\\nelse return undefined"
                    },
                    {
                        "username": "rayhan-dev",
                        "content": "```\\ntype Fn = (...args: any[]) => any\\n\\nfunction once(fn: Fn): Fn {\\n  let executionCount = 0;\\n  return function (...args) {\\n    if(executionCount > 0) return undefined;\\n    executionCount++;\\n    return fn(...args);\\n  };\\n}\\n```"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Back to closures"
                    },
                    {
                        "username": "Bethel_nz",
                        "content": "you can use the array approach as well:\\n\\n\\n`var once = function(fn) {\\n    let storedArgs = [];\\n    return function (...args) {\\n        if (storedArgs.length === 0) {\\n            storedArgs = args;\\n            return fn(...args);\\n        }\\n        return undefined;\\n    };\\n};\\n`"
                    },
                    {
                        "username": "rajagrawal23",
                        "content": "The once function is a higher-order function that takes a function fn as input and returns a new function. This new function ensures that the original function fn is called at most once. It keeps track of whether fn has been called before using a flag. On the first call, it executes fn and returns the result. On subsequent calls, it does nothing and returns undefined. The implementation uses a closure to store the flag and result across multiple calls. The example usage demonstrates how to create the new function using once(fn) and process multiple function calls, returning the results and indicating the number of calls made."
                    },
                    {
                        "username": "devvrat02",
                        "content": "Simply It Is helpful when you want to declare a function and want it to run only once. We can Use It in multiple way like running only n times a function  by changing a flag with n integer and reducing the n with 1 Value \\n`var once = function(fn) {\\n    let flag=false\\n    return function(...args){\\n        if(!flag){\\n            flag=true\\n            return fn(...args)\\n        }\\n    }\\n};`\\n\\nLike Example You can now change no of time you want to run this Function \\n`\\nvar once = function(fn,n=1) {\\n    let flag=n\\n    return function(...args){\\n        if(flag){\\n            flag--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\nIn more simple way \\n`\\nvar once = function(fn,n=1) {\\n    return function(...args){\\n        if(n){\\n            n--;\\n            return fn(...args)\\n        }\\n    }\\n};\\n`\\n\\n"
                    },
                    {
                        "username": "hiteshmaan",
                        "content": "I used an object adding keys as functions is optimal?\\n"
                    },
                    {
                        "username": "shrikantamazumder",
                        "content": "First you can keep track main function is called or not by a flag. If not called then call and return fn by passing ...args inside return function. Also update the flag by true since it called already."
                    }
                ]
            }
        ]
    },
    {
        "title": "Throttle",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1899833,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            },
            {
                "id": 1899769,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            },
            {
                "id": 1898831,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            },
            {
                "id": 1899628,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            },
            {
                "id": 1899533,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            },
            {
                "id": 1900100,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            },
            {
                "id": 1900088,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            },
            {
                "id": 1899865,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            },
            {
                "id": 1900012,
                "content": [
                    {
                        "username": "Dzuchun",
                        "content": "I don't know if it's just for me, but these images make no sense to me. I guess I should try to avoid them better, as they actually make me understand <b>less</b> about the problem.\n\nSame goes for examples. Just can't see a connection between them and a pure specification."
                    },
                    {
                        "username": "Pellyyy",
                        "content": "Each block represents 100ms and every different colored rectangle represents a different call (with different arguments) to our throttled function. You can see that there's a gap of at least 4 rectangles (400ms) between every output event. This is because the throttle time (passed to the throttle function) is 400ms. If you pay attention to the color of the rectangles, you can see that the arguments are \"overwritten\" if the throttled function is called multiple times within the throttle delay. Look at the first 3 calls on the image: Blue gets called immediately because there is no initial delay (our function hasn't been throttled yet). Right after, within the throttle time window, there are 2 calls to our function, pink and green. After the delay has passed, only the green function call is being processed -> the arguments of the pink function call have been overwritten by the green one and our throttled function is called with the green arguments only. "
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Agree. The example is confusing. This is how I\\'m reading it:\\n\\nGeneral idea:\\nA. If a colored rectangle shows in the *Input Events*, it means that the function was passed to the throttled function (but it does NOT mean that it got called just yet).\\n\\nB. If a colored rectangle shows in the *Throttled Events*, it means that the function was actually executed.\\n\\nC. Once there is a colored rectangle in the *Throttled Events* (i.e. a function has been executed), you will not see another colored rectangle in the *Throttled Events* until the timeout period has expired regardless of how many new colored rectangles show in the *Input Events*. \\n\\nNow let\\'s talk specifics:\\n1. The blue rectangle in the *Input Event* is the first function we want to execute from our throttled function. Since it\\'s the first one, we show a blue rectangle right below it in the *Throttled Events* to denote that it was executed right away.\\n\\n2. The timeout is set to 400ms. Keeping in mind that each rectangle is 100ms, this means that we will need 3 blank rectangles before we are able to color another rectangle (i.e. before we are able to execute another function).\\n\\n3. During the time out, two functions get called: \\n\\na. The fuchsia at 200ms and \\nb. The green at 300ms\\n\\nThe fuchsia doesn\\'t appear in the *Throttled Events* just yet (i.e. it doesn\\'t get executed) because we need to respect blue\\'s 400ms timeout. Fuchsia will wait patiently to be called \"4 blank rectangle\" (i.e. 400ms) after blue was executed.\\n\\nLife is not fair, however. Even though fuchsia was waiting in line, green comes and cuts in front of her. Only one color can be in line so we forget about poor fuchsia and, 400ms after blue has been called, green gets called. Green only had to wait 100ms. I guess some colors are luckier than others.\\n\\nAfter fuchsia saw green get called, it cried for 300ms before deciding to give it another try. This is the 2nd fuchsia you see on the *Input Event*.\\n\\nFuchsia only had to wait one rectangle (i.e. 100ms) to be called because green had already been around for 300ms.\\n\\nFuchsia had so much fun that she wanted to go again only 200ms later. This is the 3rd fuchsia you see in the *Input Events*. This time, however, it had to wait two more rectangles (i.e. 200ms) because of the timeout she put in place the last time she ran. That\\'s why you will see the last fuchsia in the *Throttled Events* two squares to the right instead of below the last fuchsia in the \"Input Events\".\\n\\nFinally, more than 400ms transpires between fuchsia\\'s last rendezvous and green wanting to go again. Lucky green gets executed right away and, realizing that he can just cut in line at the last second, cuts in front of blue. Don\\'t feel bad for blue, however, because blue did the same to poor fuchsia just 100ms ago.\\n\\nBottom line, no matter how many *Input Events* there were, only 8 functions were executed with a minimum of 400ms in between them.\\n\\nHope this helps. Good luck!\\n"
                    },
                    {
                        "username": "soupracer",
                        "content": "Think of differing colors as different inputs to the same throttle function. In the throttled events, you\\'ll see which inputs were processed after the delay has passed. Also, every output in the throttled event is delayed by 400 ms (`t = 400ms`), which is 4 rectangles, which is why you\\'ll see some calls being delayed a bit in the middle, i.e. the call is being  throttled. I agree that they are confusing but hopefully this clears up some of it."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "instead of using static image, try to show animation, so that we can understand better"
                    },
                    {
                        "username": "Ashotovich1990",
                        "content": "ok, our lord, as you order us, to your humble serfs hahaha"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "[@cartesPerforees](/cartesPerforees) That\\'s why I would like to understand here better."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, this is a problem, it\\'s normal that we have stuff to figure out. In an interview setting, you\\'d have a hard time asking the interviewer for an animation, and you wouldn;t have a picture at all."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "OK, I have a problem here.\nWhen I run my code on the **single** following testcase, it passes :\n```\n50\n[{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]}]\n```\n\nHowever, if I have a second testcase in my custom testcases bank, it fails.\nWhy do testcases interfere with each other? Are the testcases called all together in a concurrent fashion or something? It's confusing, that makes it quite hard to predict and test the behavior\n\nAlso, when I use `console.log` to try and keep track of my variables, the output from all the testcases are all mixed up together (and presented in the stdout of testcase 1). That makes it very hard to debug anything if you don;t have access to the premium debugger.\n\nI think those two issues might come from the same underlying problem and need to be fixed"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@cloudeeoh](/cloudeeoh) it seems to fail regardless of the order of the testcases (It fails when I call example 2 and 3 together, regardless of the order, but it passes when I call either one of them individually)"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "This is very strange. Testcases should not interfere with each other. Did you try to swap the order of the testcases see if that gives you more clues?\\n\\nIn regards to console.log, I agree that it\\'s inconvenient the way it\\'s setup. You can try something like adding console.log(\"==== Test Case ====\" to somewhat separate them as the testcases get call one after the other (not in parallel).     "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@20jasper](/20jasper) Yes, just to claify, I\\'m sure my code is incorrect and that\\'s why it doesn\\'t pass. I\\'m just saying it\\'s a headache to debug because I was also testing one case at a time due to the log problem, but it now gives inconsistent result (different outcomes when testing one by one vs all 3 at once)"
                    },
                    {
                        "username": "20jasper",
                        "content": "I had to test one case at a time since the logs since like you said, it\\'s hard to debug when everything is running in parallel, but I was able to pass all three test cases at once with my solution"
                    },
                    {
                        "username": "c4tdog",
                        "content": "are we going to implement all lodash functions here?"
                    },
                    {
                        "username": "gautam1168",
                        "content": "KEK"
                    },
                    {
                        "username": "Xdynix",
                        "content": "Implementations using `setTimeout` may be less stable, as there is no guarantee that it will run at exactly that time. When the test data involved this situation, a new function call might not be able to be just in time to cancel a delayed previous call that would run 1ms later. In this case you can retry a submit (this worked for me)."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "### This is what ChatGPT had to say about the examples given.\\n\\n> After reviewing the examples again, I realize that there are inconsistencies with the behavior described in the problem statement. The given examples do not accurately reflect the expected behavior of a throttled function as mentioned in the problem statement.\\n\\n> The discrepancies include the handling of the delay period, the overwriting of arguments, and the creation of subsequent delay periods.\\n\\n> To clarify, a correct implementation of a throttled function would work as follows:\\n\\n> The first call to the function is always executed immediately without any delay.\\nSubsequent calls within the delay period do not overwrite previous arguments. Instead, they are ignored or postponed until the delay period ends.\\n> After the delay period for a call ends, the latest arguments provided during that delay period are used for the callback, and a new delay period begins."
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@khe1154](/khe1154) So in general implementation, there is no immediate invocation, calls happen only during in the callbacks correct? Thanks "
                    },
                    {
                        "username": "khe1154",
                        "content": "there are different implementations of throttle. following is the most common one and it is how the lodash\\'s throttle behave. the leetcode\\'s throttle implementation is bit different then standard throttle implemtation \\n```\\nvar throttle = function (fn, time) {\\n  let timeoutId;\\n\\n  return function () {\\n    // Check for existing calls\\n    if (timeoutId) {\\n      // If timer is already running, exit\\n      return;\\n    }\\n\\n    timeoutId = setTimeout(() => {\\n      // Invoke fn\\n      fn.apply(this, arguments);\\n      // Clear timeout to unblock next call\\n      timeoutId = null;\\n\\n    }, time);\\n  }\\n}\\n```\\nSimilar to this there are different implemetation of debounce eg. trailing debounce and leading debounce"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "[@cartesPerforees](/cartesPerforees) FYI I just copy pasted the PS and the examples given. It gave me an answer. As the model is known to jump into conclusions at times (which can be wrong), I casually asked it to review once again, to check if the examples given match with the problem statement. And this was it\\'s response. I didn\\'t tweak it, honestly, you think I\\'ve nothing better to do? Also please don\\'t think you are eligible to talk smack just because you think you are better. For what it\\'s worth you can provide me a means to share the chatGPT page screenshots. Damn, why do you even care lol. Looks like you have nothing better to do, get back to reddit my guy. I posted this here only because chatGPT gave this response, its beyond me that you\\'d think I did this on purpose and for what. I\\'m sad for you. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "this is just empty gibberish to me. Not sure why you felt it was worth copy pasting it here. \nAlso he was reviewing those examples \"again\", so it sounds like you tried several times to make it say there's a problem for some reason.\nMaybe you should also include your first attempts where it told you it's completely fine?\n\nIt doesn't explain what any of the actual problems are. Just sounds to me like a guy telling you \"yeah, yeah, ok sure buddy, there's a problem if you want, now go play with your friends ok?\"\n\nThe \"problem\" that you imagined in your last comment is just you not counting properly. Managing to get chatGPT down to your level doesn't add any weight to your point.\n\nIt makes me sad to see that people still manage to make one of the most brilliant tools humanity has ever created look stupid by using it without rhyme or reason"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "Why does call happen at 190ms in example 3? shouldn\\'t it happend at 140ms and 210ms?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "First call at 50ms goes through directly, then 50+70=120, 120+70=190"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Wow, it\\'s the first time I face the problem of testing being performed wrong.\\n\\nFor a testcase\\nt = 70\\ncalls = [{\"t\":50,\"inputs\":[1]},{\"t\":75,\"inputs\":[2]},{\"t\":90,\"inputs\":[8]},{\"t\": 140, \"inputs\":[5,7]},{\"t\": 300, \"inputs\": [9,4]}]\\nI set up this small testing script:\\n\\nlet start = Date.now();\\nconst throttled = throttle((...args) => console.log(Date.now() - start, ...args), 70);\\nsetTimeout(throttled, 50, 1);\\nsetTimeout(throttled, 75, 2);\\nsetTimeout(throttled, 90, 8);\\nsetTimeout(throttled, 140, [5, 7]);\\nsetTimeout(throttled, 300, [9, 4]);\\n\\nAnd the result is seemingly the one expected by a testcase:\\n\\n51 1\\n121 8\\n192 [ 5, 7 ]\\n301 [ 9, 4 ]\\n\\nMeanwhile, site testing informs me that first call at 50ms is not performed. Oh well"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Yup there are some weird things going on with their tests. I\\'m kinda stuck because I get different results if I run several cases vs if I run them one by one"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Day16: Done Solving Today\\'s Question "
                    }
                ]
            }
        ]
    },
    {
        "title": "Immediate Food Delivery III",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1926748,
                "content": [
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT order_date,\\nROUND(AVG(order_date = customer_pref_delivery_date) * 100,2) AS immediate_percentage\\nFROM delivery\\nGROUP BY 1\\nORDER BY 1;"
                    }
                ]
            }
        ]
    },
    {
        "title": "Return Length of Arguments Passed",
        "question_content": "Write a function&nbsp;<code>argumentsLength</code> that returns the count of arguments passed to it.\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> args = [5]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\nargumentsLength(5); // 1\n\nOne value was passed to the function so it should return 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> args = [{}, null, &quot;3&quot;]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> \nargumentsLength({}, null, &quot;3&quot;); // 3\n\nThree values were passed to the function so it should return 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>args</code>&nbsp;is a valid JSON array</li>\n\t<li><code>0 &lt;= args.length &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3586843,
                "title": "learn-rest-parameter-argument-handling-in-function-1-line-easy-sol-in-js-ts",
                "content": "# Why rest parameter ?\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRest parameters in JavaScript allow us to represent an indefinite number of arguments as an array within a function. It enables us to handle multiple arguments without explicitly defining each one in the function signature. \\n\\nThe rest parameter is denoted by three dots (`...`) followed by a parameter name in a function declaration or function expression.\\n\\nlets understand with example where we have an array and we want to pass all its value to a function :-\\n\\n```\\nlet array = [1,2,3,4,5];\\n\\n// we expect argument to be passed in this way\\nfunction sum (a,b,c,d,e){\\n    console.log(a,b,c,d,e) // 1 2 3 4 5 \\n}\\n\\n// brute force method \\nsum(array[0],array[1],array[2],array[3],array[4]);\\n\\n// Problem :- we have to pass each value individually & \\n// if we have 1000 values in array then \\n// we have to pass 1000 arguments in function which is not feasible.\\n\\n\\n// using rest parameter we can pass all the values of array in one go\\nsum(...array); \\n\\n//rest parameter allows us to pass indefinite number of arguments as an array within a function.\\n\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we know `args` is an array of arguments passed to a function. We can use `args.length` to get the number of arguments passed to a function.\\n\\nhence we will return `args.length` to get the number of arguments passed to a function.\\n\\n# Complexity \\n- Time complexity: $$O(1)$$ \\n- Space complexity: $$O(1)$$\\n\\n<img src=\"https://assets.leetcode.com/users/images/b93dcc50-7e19-44d3-80ec-c41558d719ba_1684043630.2104852.png\" width=\"50%\">\\n\\n# Code\\n```javascript []\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```\\n\\n```typescript []\\nfunction argumentsLength(...args: any[]): number {\\n  return args.length\\n};\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\nlet array = [1,2,3,4,5];\\n\\n// we expect argument to be passed in this way\\nfunction sum (a,b,c,d,e){\\n    console.log(a,b,c,d,e) // 1 2 3 4 5 \\n}\\n\\n// brute force method \\nsum(array[0],array[1],array[2],array[3],array[4]);\\n\\n// Problem :- we have to pass each value individually & \\n// if we have 1000 values in array then \\n// we have to pass 1000 arguments in function which is not feasible.\\n\\n\\n// using rest parameter we can pass all the values of array in one go\\nsum(...array); \\n\\n//rest parameter allows us to pass indefinite number of arguments as an array within a function.\\n\\n```\n```javascript []\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```\n```typescript []\\nfunction argumentsLength(...args: any[]): number {\\n  return args.length\\n};\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567330,
                "title": "one-liner-full-simple-short-explanation",
                "content": "# Approach\\nIn JavaScript, arguments are passed as an array-like object. Because of this, you can use a lot of the same kind of functions on arguments as you can on arrays, including using ```args.length```.\\n\\nAnd so, in the same way you would find the number of elements in an array ```arr``` with ```arr.length```, you can find the number of arguments in ```args``` with ```args.length```.\\n\\n# Code\\n```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```args.length```\n```arr```\n```arr.length```\n```args```\n```args.length```\n```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567802,
                "title": "very-tough-ques",
                "content": "# Intuition\\n### you need to have a thorough understanding of nothing actually.\\n\\n\\n# Complexity\\n- Time complexity and Space complexity -> too complex, cant even tell you\\n\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3568918,
                "title": "ok",
                "content": "```\\nvar argumentsLength = (...args) => args.length; \\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvar argumentsLength = (...args) => args.length; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566162,
                "title": "simple-1-line",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n \\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n \\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023446,
                "title": "two-line-solution-using-javascript",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)Create array.\\n2)use spread operator to copy all arguments into array.\\n3)use length method to get the length of array and retrun it.\\n\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let arr=[...args]\\n let len=arr.length;\\n return len\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```\\n### Please Upvote\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let arr=[...args]\\n let len=arr.length;\\n return len\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3836496,
                "title": "javascript",
                "content": "# Code\\n```\\n/**\\n * @return {number}\\n */\\n\\nfunction argumentsLength(){\\n    return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\n\\nfunction argumentsLength(){\\n    return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3665162,
                "title": "just-1-line-code",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3658044,
                "title": "90-1-line-solution",
                "content": "# Intuition\\nWe can calculate total amount of arguments by comprising an array from args.\\n\\n# Approach\\nSpread all the arguments into an empty array, then count its length\\n\\n# Code\\n```\\nvar argumentsLength = function(...args) {\\n    return [...args].length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n    return [...args].length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3648775,
                "title": "oneliner-return-args-length",
                "content": "```\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567070,
                "title": "simple-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  let count = 0;\\n  for (let i = 0; i < args.length; i++) {\\n    if (args[i] !== undefined) {\\n      count++;\\n    }\\n  }\\n  return count;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  let count = 0;\\n  for (let i = 0; i < args.length; i++) {\\n    if (args[i] !== undefined) {\\n      count++;\\n    }\\n  }\\n  return count;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566898,
                "title": "javascript",
                "content": "\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983467,
                "title": "super-easy-52ms-beats-64-40mb-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst I was going to use the for loop but then I said why would\\'t I just use the length function , And that\\'s how I solved the problem\\n\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854288,
                "title": "return-length-of-arguments-passed-javascript-solution-code",
                "content": "# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n\\nreturn args.length;\\n \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n\\nreturn args.length;\\n \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582473,
                "title": "ts-return-args-length-58ms-42-7mb",
                "content": "I guess LC really thinks that JS developers are a few notches less capable than all the rest, seeing problems like this or [hello world](https://leetcode.com/problems/create-hello-world-function/) ([cracked here](https://leetcode.com/problems/create-hello-world-function/solutions/3492572/ts-traditional-vs-arrow-function-with-differences-50ms-42-8mb/)).\\n\\nWell, guess what? We will just `return` the `.length` property on `args` and be done with the problem.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```ts\\nfunction argumentsLength(...args: any[]): number {\\n    return args.length;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction argumentsLength(...args: any[]): number {\\n    return args.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3569813,
                "title": "best-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nfunction argumentsLength() {\\n    return arguments.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nfunction argumentsLength() {\\n    return arguments.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566246,
                "title": "2-simple-solutions",
                "content": "\\n# Length of `args`\\n\\n```\\nfunction argumentsLength(...args: any[]): number {\\n    return args.length;\\n};\\n```\\n\\n\\n# Length of [the arguments object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)\\n```\\nfunction argumentsLength(...args: any[]): number {\\n    return arguments.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction argumentsLength(...args: any[]): number {\\n    return args.length;\\n};\\n```\n```\\nfunction argumentsLength(...args: any[]): number {\\n    return arguments.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100670,
                "title": "return-length-of-arguments-passed-javascript-solution-by-bharadwaj",
                "content": "# Approach\\nFunctional Programming\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nvar argumentsLength = function(...args) {\\n   \\treturn args.length\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n   \\treturn args.length\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4099715,
                "title": "one-of-the-easiest-problem-single-line-answer",
                "content": "# Intuition\\nJust return length of Args and done . \\uD83D\\uDD25 \\n\\n\\n# Code\\n```\\n\\nvar argumentsLength = function(...args) {\\n\\treturn args.length\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar argumentsLength = function(...args) {\\n\\treturn args.length\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096699,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction argumentsLength  () {\\n\\treturn arguments.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction argumentsLength  () {\\n\\treturn arguments.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092596,
                "title": "solution-with-arguments-lenght",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {...(null|boolean|number|string|Array|Object)} args\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n\\treturn args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {...(null|boolean|number|string|Array|Object)} args\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n\\treturn args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091643,
                "title": "javascript-function-for-determining-the-number-of-arguments-using-the-rest-parameter",
                "content": "# Intuition\\nThe intuition here is that by using the JavaScript rest parameter (...args), we can capture all the arguments passed to the function and then determine the number of arguments based on the length of the args array.\\n# Approach\\nDefine a function argumentsLength that uses the rest parameter ...args to collect all the arguments passed to it.\\nReturn the length of the args array, which represents the count of arguments.\\n\\n# Complexity\\nTime complexity: O(1)\\nThe length of the args array can be determined in constant time because it\\'s based on the number of arguments passed to the function.\\nSpace complexity: O(1)\\nThe args array doesn\\'t consume additional memory because it\\'s a reference to the arguments passed to the function, and its length property is used to determine the count.\\n\\n\\n# Code\\n```\\nfunction argumentsLength(...args) {\\n  return args.length;\\n}\\n// Example 1:\\nconst result1 = argumentsLength(5);\\nconsole.log(result1); // Output: 1\\n// Example 2:\\nconst result2 = argumentsLength({}, null, \"3\");\\nconsole.log(result2); // Output: 3\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction argumentsLength(...args) {\\n  return args.length;\\n}\\n// Example 1:\\nconst result1 = argumentsLength(5);\\nconsole.log(result1); // Output: 1\\n// Example 2:\\nconst result2 = argumentsLength({}, null, \"3\");\\nconsole.log(result2); // Output: 3\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088434,
                "title": "100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088420,
                "title": "array-length",
                "content": "# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084402,
                "title": "finally-a-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args) => args.length;\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args) => args.length;\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084275,
                "title": "simple-js-solution-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->using length\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n \\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n \\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080907,
                "title": "arguments-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbasic return array.length method\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nreturn the length of the array of arguments\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```\\nanother solution for better runtime\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\n\\nvar argumentsLength = (...args) => args.length;\\n\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```\n```\\n/**\\n * @return {number}\\n */\\n\\nvar argumentsLength = (...args) => args.length;\\n\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078266,
                "title": "javascript-array-length-41ms-beats-95-98-41-1mb-beats-98-64",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s a valid JSON Array, so I just get the length using Javascript Array.length and return it immediatly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt worked.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073128,
                "title": "first-win",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070176,
                "title": "object-arguments-o-1",
                "content": "# Intuition\\nUse the object arguments which in an object inside the function and contains the paramtters passed to the function\\n\\n# Complexity\\n- Time complexity:O(1)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070146,
                "title": "javascript-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    var count = 0;\\n args.map(index=>{\\n        count++\\n })\\n return count\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    var count = 0;\\n args.map(index=>{\\n        count++\\n })\\n return count\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068905,
                "title": "simple-one-line-solution",
                "content": "# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return [...args].length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return [...args].length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4066916,
                "title": "return-length-of-arguments-passed-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062271,
                "title": "beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    var result = 0;\\n    for (let arg of args){\\n        result += 1\\n    }\\n    return result;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    var result = 0;\\n    for (let arg of args){\\n        result += 1\\n    }\\n    return result;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062025,
                "title": "return-length-of-the-argument",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    // let a = [...args];\\n    // let length = a.length;\\n    // return length;\\n    return args.length;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    // let a = [...args];\\n    // let length = a.length;\\n    // return length;\\n    return args.length;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059993,
                "title": "easy-peasy-solution",
                "content": "# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059917,
                "title": "return-length-of-arguments-passed-with-one-line-solution-o-1",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$Big-O = O(1) - Constant$$\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nlet argumentsLength = function (...args) {\\n  return args.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nlet argumentsLength = function (...args) {\\n  return args.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056638,
                "title": "using-length-method",
                "content": "ribe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Use  ```<array>.length``` method\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```<array>.length```\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050643,
                "title": "beginners-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let arr=[...args]\\n let argLength=arr.length;\\n return argLength;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let arr=[...args]\\n let argLength=arr.length;\\n return argLength;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049607,
                "title": "js-one-liner-very-easy-beginner-friendly",
                "content": "# Please Upvote Guys\\n```\\nreturn args.length;\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nreturn args.length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048347,
                "title": "js-ts-one-line-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\n\\nconst argumentsLength = (...args: JSONValue[]): number => args.length;\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\n\\nconst argumentsLength = (...args: JSONValue[]): number => args.length;\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047360,
                "title": "array-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thougth was to determine the length.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used array.length on the args to determine the length\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047058,
                "title": "1-line-solution-using-javascript",
                "content": "# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045707,
                "title": "return-length-of-arguments-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    let leng = args.length;\\n    return leng\\n};\\n\\nargumentsLength(1,2,3)\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    let leng = args.length;\\n    return leng\\n};\\n\\nargumentsLength(1,2,3)\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045090,
                "title": "1-line-solution",
                "content": "# Easy way to solve\\n\\nIf we have ... in function argument - this is Rest Operator. Rest operator compact all arguments into array, so we can easy use length parametr of array \\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044985,
                "title": "return",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let arr = [...args]\\n let len = arr.length;\\n return len\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let arr = [...args]\\n let len = arr.length;\\n return len\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044106,
                "title": "1-line-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args) => [...args].length\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args) => [...args].length\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043568,
                "title": "one-line-code-rohit-raj",
                "content": "# Intuition\\ncode in just one line....\\n\\n# Approach\\njust return arr length like arr i used args only .you can also use [...args].length\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041179,
                "title": "javascript-1-liner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040940,
                "title": "just-in-one-line",
                "content": "# Intuition\\nuse  array length function to tacle it \\n\\n# Approach\\nreturn array.length for this args.length()\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040482,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038641,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse the inbuilt .length method on the array and return it .\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let n= args.length;\\n return n;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let n= args.length;\\n return n;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038570,
                "title": "if-you-like-pls-upvote-it-for-any-doubt-feel-free-to-ask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n\\n    var i=0;\\n    args.forEach((st) => { \\n        console.log(st); i++;   })\\n     return i;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n\\n    var i=0;\\n    args.forEach((st) => { \\n        console.log(st); i++;   })\\n     return i;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036563,
                "title": "javascript-one-line",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nreturn the length of the array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function (...args) {\\n  return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function (...args) {\\n  return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036220,
                "title": "return-length-of-arguments-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n   return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n   return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035279,
                "title": "learn-array-destructuring",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let arr=[...args];\\n let length = arr.length;\\n return length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n let arr=[...args];\\n let length = arr.length;\\n return length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035019,
                "title": "much-simplest-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n \\n let array=[...args]\\n return array.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n \\n let array=[...args]\\n return array.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034381,
                "title": "simple-solution-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\n  \\nvar argumentsLength = function(...args) {\\n  var c=args.length;\\n  return c\\n\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\n  \\nvar argumentsLength = function(...args) {\\n  var c=args.length;\\n  return c\\n\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030760,
                "title": "neat-short-solution-with-explanation-es6",
                "content": "# Explanation\\n`...` in `...args` refers to rest paramters when used in parameters and returns an array of whatever arguments passed. Since, it\\'s an array, simply return the length.\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4029744,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028166,
                "title": "single-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince```args```is an array you can access it\\'s```length```property.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply return the```length```property of```args```.\\n# Code\\n```\\nconst argumentsLength = (...args) => args.length\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```args```\n```length```\n```length```\n```args```\n```\\nconst argumentsLength = (...args) => args.length\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021896,
                "title": "easy-one-line-solution",
                "content": "\\n\\n# Approach\\nwe know that when we want to get all the arguments we use ...args that is the rest operator which give us all the arguments in form of an array,\\nnow to get the count of arguments simple get the length or args array\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n         return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n         return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021127,
                "title": "length-of-arguments-passed-to-any-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018364,
                "title": "easy-one-line-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015877,
                "title": "extremely-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust add a return with the array.length\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015477,
                "title": "easy-to-understand-quick-solution",
                "content": "# Intuition\\nUsing the arguments object we do not have to reassign or use any other object to access the length of the arguments passed.\\n\\n# Approach\\nUse the arguments object with the length accessor to provide yourself with the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013764,
                "title": "code-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  let count = 0;\\n  for (let i = 0; i < args.length; i++){\\n    count++\\n  }\\n  return count\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  let count = 0;\\n  for (let i = 0; i < args.length; i++){\\n    count++\\n  }\\n  return count\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013339,
                "title": "simple-javascript-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011923,
                "title": "one-line-solution-return-length-of-arguments-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nargu By argu\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007096,
                "title": "o-1-javascript-solution-one-liner",
                "content": "# Approach\\nIn JavaScript, arguments are passed as an array-like object. Because of this, you can use a lot of the same kind of functions on arguments as you can on arrays, including using args.length.\\n\\nAnd so, in the same way you would find the number of elements in an array arr with arr.length, you can find the number of arguments in args with args.length.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002681,
                "title": "easy-way-of-the-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust one line code you should only return arguments.length. That\\'s all.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4001698,
                "title": "find-the-length-of-the-arguments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000016,
                "title": "one-line-javascript-solution",
                "content": "# JavaScript Solution\\n\\n\\n\\n# Code\\n```\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n```\\n\\n\"*return args.length*\" returns the length of the args array, which is equivalent to the number of arguments passed to the function.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997851,
                "title": "javascript-easy-simple-and-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n<!-- upvote if it helps -->\\n\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n<!-- upvote if it helps -->\\n\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997276,
                "title": "my-first-easy-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    var len = parseInt(args.length)\\n    return len;\\n \\n};\\n\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    var len = parseInt(args.length)\\n    return len;\\n \\n};\\n\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991655,
                "title": "obvious-answer-js",
                "content": "\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3986707,
                "title": "shortest-javascript-solutions",
                "content": "```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985875,
                "title": "one-line-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n   return args.length \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n   return args.length \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3984653,
                "title": "okay",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3964213,
                "title": "js-two-solutions-with-explanation",
                "content": "1) **arguments** is an array-like object accessible inside functions that contains the values of the arguments passed to that function;\\n\\n# Code\\n```\\n\\nvar argumentsLength = function(...args) {\\n    return arguments.length;\\n};\\n\\n```\\n2) the **rest parameter** syntax allows a function to accept an indefinite number of arguments *as an array*;\\n\\n# Code\\n```\\n\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar argumentsLength = function(...args) {\\n    return arguments.length;\\n};\\n\\n```\n```\\n\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3963225,
                "title": "rest-arguments-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n...args is a rest arguments and its an array. So we can use array length property to get the size of the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962951,
                "title": "easy-and-efficiant-solution-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- 0(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n     var n=args.length;\\n     return n;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n     var n=args.length;\\n     return n;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3956453,
                "title": "simplest-solution",
                "content": "# Intuition\\nProbably the easiest problem in entirety of Leetcode\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3954586,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar argumentsLength = function(...args) {\\n      return args.length;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n      return args.length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3954065,
                "title": "javascript-solution",
                "content": "# Factors\\n- Runtime\\n50ms\\n\\n- Memory\\n41.10MB\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function() {\\n    return arguments.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function() {\\n    return arguments.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952328,
                "title": "way-too-easy",
                "content": "# Complexity\\n- Time complexity:$$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3950869,
                "title": "javascript",
                "content": "# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949832,
                "title": "javascript-oneliner-o-1",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947875,
                "title": "simple-one-liner-with-explanation",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWith the help of spread operator we can easily we can easily do it.\\nwe just have to return the length of spread operator.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947409,
                "title": "return-length-of-arguments-passed-javascript-solution-code",
                "content": "\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3943188,
                "title": "2-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 62 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n const p = Array.from(args);\\n return p.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n const p = Array.from(args);\\n return p.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931856,
                "title": "return-length-of-arguments-passed-easy-solution",
                "content": "# Rest Parameters\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe rest parameter syntax allows a function to accept an indefinite number of arguments as an array, providing a way to represent variadic functions in JavaScript.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we know args is an array of arguments passed to a function. We can use args.length to get the number of arguments passed to a function.\\n\\nhence we will return args.length to get the number of arguments passed to a function.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n      return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n      return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931027,
                "title": "1-line-solution",
                "content": "# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3930392,
                "title": "return-length-js-three-solutions",
                "content": "1. Intuitive Solution \\n```\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n```\\n2. Use variable arguments to access arguments of function\\n```\\nvar argumentsLength = function(...args) {\\n    count = 0\\n\\n    for (i = 0; i < arguments.length; i++) {\\n        count ++\\n        // arguments[i] - contain argument value\\n    }\\n\\n    return count\\n};\\n```\\n3. Reduce\\n```\\nvar argumentsLength = (...args) => args.reduce(sum => sum + 1, 0)\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n```\n```\\nvar argumentsLength = function(...args) {\\n    count = 0\\n\\n    for (i = 0; i < arguments.length; i++) {\\n        count ++\\n        // arguments[i] - contain argument value\\n    }\\n\\n    return count\\n};\\n```\n```\\nvar argumentsLength = (...args) => args.reduce(sum => sum + 1, 0)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3929977,
                "title": "typescript-simple-approach",
                "content": "# Complexity\\n- Time complexity: $O(1)$\\n- Space complexity: $O(1)$\\n\\n\\n# Code\\n```\\nfunction argumentsLength(...args: any[]): number {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction argumentsLength(...args: any[]): number {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3928477,
                "title": "the-trick-is-in-the-length",
                "content": "# Intuition\\nWhen length was mentioned I already had in mind that I had to pass in the argumenta and apply the length method to it.\\n\\nI than returned it as a function.\\n\\n# Code\\n```\\n\\nvar argumentsLength = function(...args) {\\n \\n return args.length;\\n\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar argumentsLength = function(...args) {\\n \\n return args.length;\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923625,
                "title": "single-line-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *```O(1)```*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar argumentsLength = (...args) => args.length;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```O(1)```\n```\\nvar argumentsLength = (...args) => args.length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3921483,
                "title": "javascript-args-length",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3919560,
                "title": "simple-two-line-submit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    let count=0;\\n   for(let i=0;i<args.length;i++){\\n      count++;\\n   }\\n   return count;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    let count=0;\\n   for(let i=0;i<args.length;i++){\\n      count++;\\n   }\\n   return count;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917603,
                "title": "easiest-single-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\nreturn args.length;\\n};\\n\\n\\n  argumentsLength(1, 2, 3); // 3\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\nreturn args.length;\\n};\\n\\n\\n  argumentsLength(1, 2, 3); // 3\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3916616,
                "title": "easy-javascript-solution-one-line-code",
                "content": "> vote up if you like it\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915136,
                "title": "simple-1-line-solution",
                "content": "```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914241,
                "title": "typescript-solution-one-liner",
                "content": "```\\nfunction argumentsLength(...args: any[]): number {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction argumentsLength(...args: any[]): number {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914121,
                "title": "easiest-way-and-shortest-way-return-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3913935,
                "title": "with-one-line-solution",
                "content": "# Intuition\\nthe input can be a number ,array etc. So the important thing for us the length of the input . And as we think the input is \"args\" the func will be like this.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3911526,
                "title": "argument-length",
                "content": "```\\nargument is a simple HTML collection of arguments passed to \\nvar argumentsLength = function(...args) {\\n    \\n    return arguments.length;\\n }\\n```",
                "solutionTags": [],
                "code": "```\\nargument is a simple HTML collection of arguments passed to \\nvar argumentsLength = function(...args) {\\n    \\n    return arguments.length;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3908453,
                "title": "simple-solution-of-return-length-of-arguments-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907240,
                "title": "javascript-have-method-for-same",
                "content": "# Intuition\\n\\nBasic array length method\\n\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\n var argsArr = [5];\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n\\nargumentsLength(1, 2, 3); // 3\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\n var argsArr = [5];\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n\\nargumentsLength(1, 2, 3); // 3\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906326,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n        return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n        return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3905189,
                "title": "easy-fast-javascript",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n \\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3905090,
                "title": "javascript-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3902850,
                "title": "easy",
                "content": "\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3894157,
                "title": "1-line-solution",
                "content": "# Intuition\\nAll we have to do is return the length of the argument which is \"...args\"\\n\\n# Approach\\nBy using .length we can easily achieve this. Just return the array.length.\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3891752,
                "title": "js-solution-runtime-43-ms-beats-97-63-memory-42-2-mb-beats-15-8",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n* @return {number}\\n*/\\nvar argumentsLength = function(...args) {\\n    return args.length ;\\n};\\n\\n/**\\n* argumentsLength(1, 2, 3); // 3\\n*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n* @return {number}\\n*/\\nvar argumentsLength = function(...args) {\\n    return args.length ;\\n};\\n\\n/**\\n* argumentsLength(1, 2, 3); // 3\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888674,
                "title": "i-though-this-was-going-to-be-more-complicated-than-return-args-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3887668,
                "title": "return-length-of-arguments-passed",
                "content": "Return Length of Arguments Passed\\n\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3887125,
                "title": "very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3885299,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3884094,
                "title": "runtime-details-43ms-beats-97-71-args-length-not-used-simple-method-javascript",
                "content": "# Intuition\\nLets not directly try to use length which might not be the best testing of concepts. \\nIf the array arguments are undefined we can just travel with a count variable and it will automatically  increase the count unless it finds undefined in array and simply return the count.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    let count = 0 ;\\n    if(args == null ) return count;\\n    while(args[count] !== undefined)\\n        count++;\\n    \\n \\n return count;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    let count = 0 ;\\n    if(args == null ) return count;\\n    while(args[count] !== undefined)\\n        count++;\\n    \\n \\n return count;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3883442,
                "title": "easy-code-for-this-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Rest operator concept is used here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs rest operator collects individual elements and groups them into a array and return the array. we need to just print the array length.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\nreturn args.length;\\n\\n\\n};\\n\\n\\n argumentsLength(1, 2, 3); // 3\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\nreturn args.length;\\n\\n\\n};\\n\\n\\n argumentsLength(1, 2, 3); // 3\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879016,
                "title": "simple-solution-one-liner",
                "content": "\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return [...args].length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return [...args].length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3878368,
                "title": "easiest-solution-possible-on-internet",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) // N => Number of arguments\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n const arr = [...args];\\n return arr.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n const arr = [...args];\\n return arr.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3877090,
                "title": "one-line-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args) => args.length\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args) => args.length\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876149,
                "title": "accepted-javascript",
                "content": "```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3874721,
                "title": "1-line-code-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->We have to find number of arguments passed to that function(argumentsLength).\\nargumentsLength(1, 2, 3); // 3\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have argumenst.length statement to return number of arguments passed to a function.\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return arguments.length;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->We have to find number of arguments passed to that function(argumentsLength).\\nargumentsLength(1, 2, 3); // 3\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have argumenst.length statement to return number of arguments passed to a function.\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return arguments.length;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3873740,
                "title": "javascript-solution",
                "content": "```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872797,
                "title": "js-one-liner-the-wrong-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.reduce((acc,args,i)=>acc+1,0)\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.reduce((acc,args,i)=>acc+1,0)\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872690,
                "title": "easiest-solution-js",
                "content": "# Approach\\nArgs has the list of all Arguments so return its length.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3871260,
                "title": "1-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function (...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function (...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3858634,
                "title": "without-using-array-length-or-for-foreach-loop-using-array-reduce-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every element int the array reduce the arraysize and increase the number of elements.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPassing 0 as initial value for count, which will be used as return value and initial value for next iteration.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    // return args.length;\\n    /*let count = 0;\\n    args.forEach(()=>count++);\\n    return count;*/\\n    return args.reduce((count, el) => ++count, 0);\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    // return args.length;\\n    /*let count = 0;\\n    args.forEach(()=>count++);\\n    return count;*/\\n    return args.reduce((count, el) => ++count, 0);\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3857600,
                "title": "simple-js-using-arrow-function",
                "content": "# Intuition\\n- The code uses the rest parameter to collect all function arguments into an array.\\n\\n# Approach\\n- By using the rest parameter, the code gathers all arguments in the args array.\\n- It then returns the length of the args array, which represents the number of arguments passed.\\n\\n\\n# Complexity\\n- Time complexity: O(1) - Constant time complexity, as it directly returns the length of the array.\\n\\n- Space complexity: O(n) - Linear space complexity, where n is the number of function arguments. The rest parameter creates an array with all the arguments.\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args )=> args.length;\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args )=> args.length;\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3857351,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855133,
                "title": "1st",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854883,
                "title": "runtime-40ms-beats-99-44",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854689,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n   let count = 0;\\n   return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n   let count = 0;\\n   return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3854003,
                "title": "1-line-simple-solution",
                "content": "# Intuition\\nThese approach emphasizes achieving performance with minimal code.\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args) => args.length;\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = (...args) => args.length;\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853706,
                "title": "solved",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nfunction argumentsLength() {\\n    return arguments.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nfunction argumentsLength() {\\n    return arguments.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853247,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust return length of the given array\\n\\n# Complexity\\n- Time complexity:\\n- O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3844990,
                "title": "avoiding-the-native-and-obvious-one-liner",
                "content": "# Intuition\\nAvoid the obvious \"One liner\" using for-loop and verifying if next argument in the array is available\\n\\n# Approach\\nCounting using for loop and avoid when not needed\\n\\n# Complexity\\n- Time complexity:\\n38ms\\n\\n- Space complexity:\\n41.50mb\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    if (args[0] === undefined) return 0;\\n\\n    let index = -1;\\n    while (args[index + 1] !== undefined) {\\n        index++;\\n    }\\n\\n    return index + 1;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    if (args[0] === undefined) return 0;\\n\\n    let index = -1;\\n    while (args[index + 1] !== undefined) {\\n        index++;\\n    }\\n\\n    return index + 1;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3844304,
                "title": "using-special-argument-variable-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe \"**arguments.length**\" data property contains the number of arguments passed to the function.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3842222,
                "title": "simple-js-1-line-solution",
                "content": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n  return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3839065,
                "title": "seriously-1-line-easy-task",
                "content": "\\n```\\nconst argumentsLength = (...args) => args.length;\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\nconst argumentsLength = (...args) => args.length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3837524,
                "title": "day3-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return arguments.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833708,
                "title": "args-is-an-array",
                "content": "# Intuition\\nwell to solve this problem u have to know only one thing which is ...args is an array parameter that is used when u dont know the the number of passed arguments\\n# Approach\\nwe r going to use the .length method to determine the length of an array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833038,
                "title": "length-of-argument-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n   return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n   return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830892,
                "title": "javascript-fast-execution",
                "content": "# Runtime\\n39ms\\nBeats 99.79%of users with JavaScript\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3828397,
                "title": "one-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3827375,
                "title": "length-of-array-beginner-friendly-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->check what the question is asking about\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe will make a variable let n= args.length and then we will return it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    let n = args.length;\\n    \\n     \\n         return n;\\n     \\n\\n\\n\\n\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n    let n = args.length;\\n    \\n     \\n         return n;\\n     \\n\\n\\n\\n\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3824514,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @return {number}\\n */\\nvar argumentsLength = function(...args) {\\n return args.length;\\n};\\n\\n/**\\n * argumentsLength(1, 2, 3); // 3\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3821642,
                "title": "literal-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst argumentsLength = (...args) => args.length;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst argumentsLength = (...args) => args.length;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1977171,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1907883,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1985754,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1941449,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1945228,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1940272,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1930589,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 2075513,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 2061550,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 2050131,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1977171,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1907883,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1985754,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1941449,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1945228,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1940272,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 1930589,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 2075513,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 2061550,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            },
            {
                "id": 2050131,
                "content": [
                    {
                        "username": "Stot_Tot",
                        "content": "FAANG gonna be spamming my inbox after this one."
                    },
                    {
                        "username": "bessadam",
                        "content": "Welcome to the world of competitive programming..."
                    },
                    {
                        "username": "tmbrnr",
                        "content": "Can already hear the recruiters knocking on my door"
                    },
                    {
                        "username": "jerryy147",
                        "content": "this is one of the rare situations where i can\\'t find anyone who did different code than me lol"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "This was the question of 4th dimension of js lol..."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "The case when it's hard to solve a problem with **not** a one-liner"
                    },
                    {
                        "username": "BristolJ",
                        "content": "This one was tricky"
                    },
                    {
                        "username": "GP_Gp",
                        "content": "very very  hard question\\nvar argumentsLength = function(...args) {\\n\\treturn args.length;\\n};\\n"
                    },
                    {
                        "username": "kutaysahindev",
                        "content": "this took a lotta sweat to solve but managed to do it after couple hours of brainstorming"
                    },
                    {
                        "username": "user7408ET",
                        "content": "I\\'m learning Java. And for a long time I could not find a task of my level. Although this is JavaScript, I managed to solve it. Finally I found my level"
                    }
                ]
            }
        ]
    }
]